package service

import (
	"context"
	"crypto/sha256"
	"errors"
	"fmt"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/sven-victor/ez-console/pkg/db"
	"github.com/sven-victor/ez-console/pkg/model"
	"github.com/sven-victor/ez-utils/safe"
)

// SessionService session service
type SessionService struct {
	geoipService *GeoIPService
}

// SessionInfo session information
type SessionInfo struct {
	ID           string    `json:"id"`
	IPAddress    string    `json:"ip_address"`
	UserAgent    string    `json:"user_agent"`
	Location     string    `json:"location"`
	CreatedAt    time.Time `json:"created_at"`
	LastActiveAt time.Time `json:"last_active_at"`
	IsCurrent    bool      `json:"is_current"`
}

// DeleteSession deletes a session record
func (s *SessionService) DeleteSession(ctx context.Context, userID, token string) error {
	return db.Session(ctx).Where("user_id = ? AND token = ?", userID, safe.NewHash(sha256.New, []byte(token)).HexString(64)).Delete(&model.Session{}).Error
}

// CreateSession creates a new session record
func (s *SessionService) CreateSession(ctx context.Context, userID, token, ipAddress, userAgent string, expiredAt time.Time) (*model.Session, error) {
	// Create new session record
	session := &model.Session{
		UserID:       userID,
		Token:        safe.NewHash(sha256.New, []byte(token)).HexString(64),
		IPAddress:    ipAddress,
		UserAgent:    userAgent,
		LastActiveAt: time.Now(),
		ExpiredAt:    expiredAt,
		IsValid:      true,
	}

	// ResourceID will be automatically generated by BeforeCreate hook

	if err := db.Session(ctx).Create(session).Error; err != nil {
		return nil, fmt.Errorf("failed to create session record: %w", err)
	}

	return session, nil
}

// GetUserSessions gets all sessions for a user
func (s *SessionService) GetUserSessions(ctx context.Context, userID string, currentSessionID string, language string) ([]SessionInfo, error) {
	var sessions []model.Session
	if err := db.Session(ctx).Where("user_id = ? AND is_valid = ?", userID, true).Find(&sessions).Error; err != nil {
		return nil, fmt.Errorf("failed to get session list: %w", err)
	}

	sessionInfos := make([]SessionInfo, 0, len(sessions))
	for _, session := range sessions {
		if session.IsExpired() {
			continue
		}

		location := s.geoipService.MustGetLocation(ctx, session.IPAddress, language)

		sessionInfos = append(sessionInfos, SessionInfo{
			ID:           session.ResourceID,
			IPAddress:    session.IPAddress,
			UserAgent:    session.UserAgent,
			Location:     location,
			CreatedAt:    session.CreatedAt,
			LastActiveAt: session.LastActiveAt,
			IsCurrent:    session.ResourceID == currentSessionID,
		})
	}

	return sessionInfos, nil
}

// TerminateSession terminates a specified session
func (s *SessionService) TerminateSession(ctx context.Context, sessionID string, currentUserID string) error {
	var session model.Session
	if err := db.Session(ctx).Where("resource_id = ?", sessionID).First(&session).Error; err != nil {
		return fmt.Errorf("session not found: %w", err)
	}

	// Verify session ownership
	if session.UserID != currentUserID {
		return errors.New("no permission to terminate this session")
	}

	// Invalidate session
	session.Invalidate()
	if err := db.Session(ctx).Select("IsValid").Save(&session).Error; err != nil {
		return fmt.Errorf("failed to terminate session: %w", err)
	}

	return nil
}

// TerminateOtherSessions terminates all sessions except the current one
func (s *SessionService) TerminateOtherSessions(ctx context.Context, userID string, currentSessionID string) error {
	result := db.Session(ctx).Model(&model.Session{}).
		Where("user_id = ? AND resource_id != ? AND is_valid = ?", userID, currentSessionID, true).
		Updates(map[string]interface{}{
			"is_valid": false,
		})

	if result.Error != nil {
		return fmt.Errorf("failed to terminate other sessions: %w", result.Error)
	}

	return nil
}

// GetSessionByToken gets a session by token
func (s *SessionService) GetSessionByToken(ctx context.Context, token string) (*model.Session, error) {
	var session model.Session
	if err := db.Session(ctx).Where("token = ? AND is_valid = ?", token, true).First(&session).Error; err != nil {
		return nil, fmt.Errorf("session not found or invalid: %w", err)
	}

	if session.IsExpired() {
		session.Invalidate()
		db.Session(ctx).Select("IsValid").Save(&session)
		return nil, errors.New("session expired")
	}

	return &session, nil
}

// UpdateSessionActivity updates session activity information
func (s *SessionService) UpdateSessionActivity(ctx context.Context, sessionID string) error {
	result := db.Session(ctx).Model(&model.Session{}).
		Where("resource_id = ?", sessionID).
		Updates(map[string]interface{}{
			"last_active_at": time.Now(),
		})

	if result.Error != nil {
		return fmt.Errorf("failed to update session activity information: %w", result.Error)
	}

	return nil
}

// GetCurrentSessionID gets the current session ID from the request context
func (s *SessionService) GetCurrentSessionID(c *gin.Context) string {
	sessionInterface, exists := c.Get("session")
	if !exists {
		return ""
	}

	session, ok := sessionInterface.(*model.Session)
	if !ok {
		return ""
	}

	return session.ResourceID
}
