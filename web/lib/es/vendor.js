var xH = Object.defineProperty;
var wH = (t, e, r) => e in t ? xH(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r;
var Ye = (t, e, r) => wH(t, typeof e != "symbol" ? e + "" : e, r);
import * as de from "react";
import lt, { Component as EH, isValidElement as TH, version as H8, useRef as tn, useLayoutEffect as SH, useEffect as Fi, useInsertionEffect as CH, useContext as qi, useMemo as V8, cloneElement as AH, forwardRef as CS, useState as dE, useImperativeHandle as q8, createContext as AS } from "react";
import { g as ho, c as Jt } from "./vite.js";
import { c as kH, r as RH, a as MH, b as _H, d as LH, e as NH, f as OH, g as IH, h as PH, i as DH, j as $H, k as FH, l as BH, m as zH, n as GH, o as UH, p as HH, q as VH, s as qH, t as WH, u as jH, v as YH, w as XH, x as KH, y as ZH, z as QH, A as JH, B as eV, C as tV, D as rV, E as nV, F as aV, G as iV, H as sV, I as oV, J as lV, K as uV, L as cV, M as fV, N as hV, O as dV, P as pV, Q as gV, R as vV, S as mV, T as yV, U as bV, V as xV, W as wV, X as EV, Y as TV, Z as SV, _ as CV, $ as AV, a0 as kV, a1 as RV, a2 as MV, a3 as _V, a4 as LV, a5 as NV, a6 as OV, a7 as IV, a8 as PV, a9 as DV, aa as $V, ab as FV, ac as BV, ad as zV, ae as GV, af as UV, ag as HV, ah as VV, ai as qV, aj as WV, ak as jV, al as YV, am as XV, an as KV, ao as ZV, ap as QV, aq as JV, ar as eq, as as tq, at as rq, au as nq, av as aq, aw as iq, ax as sq, ay as oq, az as lq, aA as uq, aB as cq, aC as fq, aD as hq, aE as dq, aF as pq, aG as gq, aH as vq, aI as mq, aJ as yq, aK as bq, aL as xq, aM as wq, aN as Eq, aO as Tq, aP as Sq, aQ as Cq, aR as Aq, aS as kq, aT as Rq, aU as Mq, aV as _q, aW as Lq, aX as Nq, aY as Oq, aZ as Iq, a_ as Pq, a$ as Dq, b0 as $q, b1 as Fq, b2 as Bq, b3 as zq, b4 as Gq, b5 as Uq, b6 as Hq, b7 as Vq, b8 as qq, b9 as Wq, ba as jq, bb as Yq, bc as Xq, bd as Kq, be as Zq, bf as Qq, bg as Jq, bh as eW, bi as tW, bj as rW, bk as nW, bl as aW, bm as iW, bn as sW, bo as oW, bp as lW, bq as uW, br as cW, bs as fW, bt as hW, bu as dW, bv as pW, bw as gW, bx as vW, by as mW, bz as yW, bA as bW, bB as xW, bC as wW, bD as EW, bE as TW, bF as SW, bG as CW, bH as AW, bI as kW, bJ as RW, bK as MW, bL as _W, bM as LW, bN as NW, bO as OW, bP as IW, bQ as PW, bR as DW, bS as $W, bT as FW, bU as BW, bV as zW, bW as GW, bX as UW, bY as HW, bZ as VW, b_ as qW, b$ as WW, c0 as jW, c1 as YW, c2 as XW, c3 as KW, c4 as ZW, c5 as QW, c6 as JW, c7 as ej, c8 as tj, c9 as rj } from "./highlight.js";
import { r as nj } from "./refractor.js";
import fr from "classnames";
import Z3 from "react-dom";
var pE = { exports: {} }, zf = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Q3;
function aj() {
  if (Q3) return zf;
  Q3 = 1;
  var t = lt, e = Symbol.for("react.element"), r = Symbol.for("react.fragment"), n = Object.prototype.hasOwnProperty, a = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function s(o, l, u) {
    var c, f = {}, h = null, d = null;
    u !== void 0 && (h = "" + u), l.key !== void 0 && (h = "" + l.key), l.ref !== void 0 && (d = l.ref);
    for (c in l) n.call(l, c) && !i.hasOwnProperty(c) && (f[c] = l[c]);
    if (o && o.defaultProps) for (c in l = o.defaultProps, l) f[c] === void 0 && (f[c] = l[c]);
    return { $$typeof: e, type: o, key: h, ref: d, props: f, _owner: a.current };
  }
  return zf.Fragment = r, zf.jsx = s, zf.jsxs = s, zf;
}
var Gf = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var J3;
function ij() {
  return J3 || (J3 = 1, process.env.NODE_ENV !== "production" && function() {
    var t = lt, e = Symbol.for("react.element"), r = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), a = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), o = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), f = Symbol.for("react.memo"), h = Symbol.for("react.lazy"), d = Symbol.for("react.offscreen"), p = Symbol.iterator, g = "@@iterator";
    function v(ee) {
      if (ee === null || typeof ee != "object")
        return null;
      var Re = p && ee[p] || ee[g];
      return typeof Re == "function" ? Re : null;
    }
    var m = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function b(ee) {
      {
        for (var Re = arguments.length, Ge = new Array(Re > 1 ? Re - 1 : 0), ot = 1; ot < Re; ot++)
          Ge[ot - 1] = arguments[ot];
        y("error", ee, Ge);
      }
    }
    function y(ee, Re, Ge) {
      {
        var ot = m.ReactDebugCurrentFrame, kt = ot.getStackAddendum();
        kt !== "" && (Re += "%s", Ge = Ge.concat([kt]));
        var wt = Ge.map(function(pt) {
          return String(pt);
        });
        wt.unshift("Warning: " + Re), Function.prototype.apply.call(console[ee], console, wt);
      }
    }
    var x = !1, E = !1, S = !1, w = !1, C = !1, k;
    k = Symbol.for("react.module.reference");
    function N(ee) {
      return !!(typeof ee == "string" || typeof ee == "function" || ee === n || ee === i || C || ee === a || ee === u || ee === c || w || ee === d || x || E || S || typeof ee == "object" && ee !== null && (ee.$$typeof === h || ee.$$typeof === f || ee.$$typeof === s || ee.$$typeof === o || ee.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      ee.$$typeof === k || ee.getModuleId !== void 0));
    }
    function R(ee, Re, Ge) {
      var ot = ee.displayName;
      if (ot)
        return ot;
      var kt = Re.displayName || Re.name || "";
      return kt !== "" ? Ge + "(" + kt + ")" : Ge;
    }
    function _(ee) {
      return ee.displayName || "Context";
    }
    function O(ee) {
      if (ee == null)
        return null;
      if (typeof ee.tag == "number" && b("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof ee == "function")
        return ee.displayName || ee.name || null;
      if (typeof ee == "string")
        return ee;
      switch (ee) {
        case n:
          return "Fragment";
        case r:
          return "Portal";
        case i:
          return "Profiler";
        case a:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof ee == "object")
        switch (ee.$$typeof) {
          case o:
            var Re = ee;
            return _(Re) + ".Consumer";
          case s:
            var Ge = ee;
            return _(Ge._context) + ".Provider";
          case l:
            return R(ee, ee.render, "ForwardRef");
          case f:
            var ot = ee.displayName || null;
            return ot !== null ? ot : O(ee.type) || "Memo";
          case h: {
            var kt = ee, wt = kt._payload, pt = kt._init;
            try {
              return O(pt(wt));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var T = Object.assign, L = 0, M, A, I, D, F, B, G;
    function H() {
    }
    H.__reactDisabledLog = !0;
    function K() {
      {
        if (L === 0) {
          M = console.log, A = console.info, I = console.warn, D = console.error, F = console.group, B = console.groupCollapsed, G = console.groupEnd;
          var ee = {
            configurable: !0,
            enumerable: !0,
            value: H,
            writable: !0
          };
          Object.defineProperties(console, {
            info: ee,
            log: ee,
            warn: ee,
            error: ee,
            group: ee,
            groupCollapsed: ee,
            groupEnd: ee
          });
        }
        L++;
      }
    }
    function j() {
      {
        if (L--, L === 0) {
          var ee = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: T({}, ee, {
              value: M
            }),
            info: T({}, ee, {
              value: A
            }),
            warn: T({}, ee, {
              value: I
            }),
            error: T({}, ee, {
              value: D
            }),
            group: T({}, ee, {
              value: F
            }),
            groupCollapsed: T({}, ee, {
              value: B
            }),
            groupEnd: T({}, ee, {
              value: G
            })
          });
        }
        L < 0 && b("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Z = m.ReactCurrentDispatcher, te;
    function ne(ee, Re, Ge) {
      {
        if (te === void 0)
          try {
            throw Error();
          } catch (kt) {
            var ot = kt.stack.trim().match(/\n( *(at )?)/);
            te = ot && ot[1] || "";
          }
        return `
` + te + ee;
      }
    }
    var V = !1, q;
    {
      var X = typeof WeakMap == "function" ? WeakMap : Map;
      q = new X();
    }
    function W(ee, Re) {
      if (!ee || V)
        return "";
      {
        var Ge = q.get(ee);
        if (Ge !== void 0)
          return Ge;
      }
      var ot;
      V = !0;
      var kt = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var wt;
      wt = Z.current, Z.current = null, K();
      try {
        if (Re) {
          var pt = function() {
            throw Error();
          };
          if (Object.defineProperty(pt.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(pt, []);
            } catch (Vt) {
              ot = Vt;
            }
            Reflect.construct(ee, [], pt);
          } else {
            try {
              pt.call();
            } catch (Vt) {
              ot = Vt;
            }
            ee.call(pt.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Vt) {
            ot = Vt;
          }
          ee();
        }
      } catch (Vt) {
        if (Vt && ot && typeof Vt.stack == "string") {
          for (var gt = Vt.stack.split(`
`), or = ot.stack.split(`
`), ze = gt.length - 1, le = or.length - 1; ze >= 1 && le >= 0 && gt[ze] !== or[le]; )
            le--;
          for (; ze >= 1 && le >= 0; ze--, le--)
            if (gt[ze] !== or[le]) {
              if (ze !== 1 || le !== 1)
                do
                  if (ze--, le--, le < 0 || gt[ze] !== or[le]) {
                    var Oe = `
` + gt[ze].replace(" at new ", " at ");
                    return ee.displayName && Oe.includes("<anonymous>") && (Oe = Oe.replace("<anonymous>", ee.displayName)), typeof ee == "function" && q.set(ee, Oe), Oe;
                  }
                while (ze >= 1 && le >= 0);
              break;
            }
        }
      } finally {
        V = !1, Z.current = wt, j(), Error.prepareStackTrace = kt;
      }
      var at = ee ? ee.displayName || ee.name : "", Ht = at ? ne(at) : "";
      return typeof ee == "function" && q.set(ee, Ht), Ht;
    }
    function ue(ee, Re, Ge) {
      return W(ee, !1);
    }
    function J(ee) {
      var Re = ee.prototype;
      return !!(Re && Re.isReactComponent);
    }
    function Ce(ee, Re, Ge) {
      if (ee == null)
        return "";
      if (typeof ee == "function")
        return W(ee, J(ee));
      if (typeof ee == "string")
        return ne(ee);
      switch (ee) {
        case u:
          return ne("Suspense");
        case c:
          return ne("SuspenseList");
      }
      if (typeof ee == "object")
        switch (ee.$$typeof) {
          case l:
            return ue(ee.render);
          case f:
            return Ce(ee.type, Re, Ge);
          case h: {
            var ot = ee, kt = ot._payload, wt = ot._init;
            try {
              return Ce(wt(kt), Re, Ge);
            } catch {
            }
          }
        }
      return "";
    }
    var Ee = Object.prototype.hasOwnProperty, Te = {}, me = m.ReactDebugCurrentFrame;
    function we(ee) {
      if (ee) {
        var Re = ee._owner, Ge = Ce(ee.type, ee._source, Re ? Re.type : null);
        me.setExtraStackFrame(Ge);
      } else
        me.setExtraStackFrame(null);
    }
    function Ae(ee, Re, Ge, ot, kt) {
      {
        var wt = Function.call.bind(Ee);
        for (var pt in ee)
          if (wt(ee, pt)) {
            var gt = void 0;
            try {
              if (typeof ee[pt] != "function") {
                var or = Error((ot || "React class") + ": " + Ge + " type `" + pt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof ee[pt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw or.name = "Invariant Violation", or;
              }
              gt = ee[pt](Re, pt, ot, Ge, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (ze) {
              gt = ze;
            }
            gt && !(gt instanceof Error) && (we(kt), b("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ot || "React class", Ge, pt, typeof gt), we(null)), gt instanceof Error && !(gt.message in Te) && (Te[gt.message] = !0, we(kt), b("Failed %s type: %s", Ge, gt.message), we(null));
          }
      }
    }
    var Ne = Array.isArray;
    function Ie(ee) {
      return Ne(ee);
    }
    function Me(ee) {
      {
        var Re = typeof Symbol == "function" && Symbol.toStringTag, Ge = Re && ee[Symbol.toStringTag] || ee.constructor.name || "Object";
        return Ge;
      }
    }
    function _e(ee) {
      try {
        return Be(ee), !1;
      } catch {
        return !0;
      }
    }
    function Be(ee) {
      return "" + ee;
    }
    function st(ee) {
      if (_e(ee))
        return b("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Me(ee)), Be(ee);
    }
    var ct = m.ReactCurrentOwner, dt = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, ft, rt;
    function je(ee) {
      if (Ee.call(ee, "ref")) {
        var Re = Object.getOwnPropertyDescriptor(ee, "ref").get;
        if (Re && Re.isReactWarning)
          return !1;
      }
      return ee.ref !== void 0;
    }
    function ae(ee) {
      if (Ee.call(ee, "key")) {
        var Re = Object.getOwnPropertyDescriptor(ee, "key").get;
        if (Re && Re.isReactWarning)
          return !1;
      }
      return ee.key !== void 0;
    }
    function z(ee, Re) {
      typeof ee.ref == "string" && ct.current;
    }
    function Q(ee, Re) {
      {
        var Ge = function() {
          ft || (ft = !0, b("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Re));
        };
        Ge.isReactWarning = !0, Object.defineProperty(ee, "key", {
          get: Ge,
          configurable: !0
        });
      }
    }
    function se(ee, Re) {
      {
        var Ge = function() {
          rt || (rt = !0, b("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Re));
        };
        Ge.isReactWarning = !0, Object.defineProperty(ee, "ref", {
          get: Ge,
          configurable: !0
        });
      }
    }
    var oe = function(ee, Re, Ge, ot, kt, wt, pt) {
      var gt = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: ee,
        key: Re,
        ref: Ge,
        props: pt,
        // Record the component responsible for creating this element.
        _owner: wt
      };
      return gt._store = {}, Object.defineProperty(gt._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(gt, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ot
      }), Object.defineProperty(gt, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: kt
      }), Object.freeze && (Object.freeze(gt.props), Object.freeze(gt)), gt;
    };
    function he(ee, Re, Ge, ot, kt) {
      {
        var wt, pt = {}, gt = null, or = null;
        Ge !== void 0 && (st(Ge), gt = "" + Ge), ae(Re) && (st(Re.key), gt = "" + Re.key), je(Re) && (or = Re.ref, z(Re, kt));
        for (wt in Re)
          Ee.call(Re, wt) && !dt.hasOwnProperty(wt) && (pt[wt] = Re[wt]);
        if (ee && ee.defaultProps) {
          var ze = ee.defaultProps;
          for (wt in ze)
            pt[wt] === void 0 && (pt[wt] = ze[wt]);
        }
        if (gt || or) {
          var le = typeof ee == "function" ? ee.displayName || ee.name || "Unknown" : ee;
          gt && Q(pt, le), or && se(pt, le);
        }
        return oe(ee, gt, or, kt, ot, ct.current, pt);
      }
    }
    var Le = m.ReactCurrentOwner, ge = m.ReactDebugCurrentFrame;
    function Se(ee) {
      if (ee) {
        var Re = ee._owner, Ge = Ce(ee.type, ee._source, Re ? Re.type : null);
        ge.setExtraStackFrame(Ge);
      } else
        ge.setExtraStackFrame(null);
    }
    var xe;
    xe = !1;
    function $e(ee) {
      return typeof ee == "object" && ee !== null && ee.$$typeof === e;
    }
    function Ze() {
      {
        if (Le.current) {
          var ee = O(Le.current.type);
          if (ee)
            return `

Check the render method of \`` + ee + "`.";
        }
        return "";
      }
    }
    function We(ee) {
      return "";
    }
    var He = {};
    function Pe(ee) {
      {
        var Re = Ze();
        if (!Re) {
          var Ge = typeof ee == "string" ? ee : ee.displayName || ee.name;
          Ge && (Re = `

Check the top-level render call using <` + Ge + ">.");
        }
        return Re;
      }
    }
    function De(ee, Re) {
      {
        if (!ee._store || ee._store.validated || ee.key != null)
          return;
        ee._store.validated = !0;
        var Ge = Pe(Re);
        if (He[Ge])
          return;
        He[Ge] = !0;
        var ot = "";
        ee && ee._owner && ee._owner !== Le.current && (ot = " It was passed a child from " + O(ee._owner.type) + "."), Se(ee), b('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Ge, ot), Se(null);
      }
    }
    function mt(ee, Re) {
      {
        if (typeof ee != "object")
          return;
        if (Ie(ee))
          for (var Ge = 0; Ge < ee.length; Ge++) {
            var ot = ee[Ge];
            $e(ot) && De(ot, Re);
          }
        else if ($e(ee))
          ee._store && (ee._store.validated = !0);
        else if (ee) {
          var kt = v(ee);
          if (typeof kt == "function" && kt !== ee.entries)
            for (var wt = kt.call(ee), pt; !(pt = wt.next()).done; )
              $e(pt.value) && De(pt.value, Re);
        }
      }
    }
    function Ke(ee) {
      {
        var Re = ee.type;
        if (Re == null || typeof Re == "string")
          return;
        var Ge;
        if (typeof Re == "function")
          Ge = Re.propTypes;
        else if (typeof Re == "object" && (Re.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        Re.$$typeof === f))
          Ge = Re.propTypes;
        else
          return;
        if (Ge) {
          var ot = O(Re);
          Ae(Ge, ee.props, "prop", ot, ee);
        } else if (Re.PropTypes !== void 0 && !xe) {
          xe = !0;
          var kt = O(Re);
          b("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", kt || "Unknown");
        }
        typeof Re.getDefaultProps == "function" && !Re.getDefaultProps.isReactClassApproved && b("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function et(ee) {
      {
        for (var Re = Object.keys(ee.props), Ge = 0; Ge < Re.length; Ge++) {
          var ot = Re[Ge];
          if (ot !== "children" && ot !== "key") {
            Se(ee), b("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ot), Se(null);
            break;
          }
        }
        ee.ref !== null && (Se(ee), b("Invalid attribute `ref` supplied to `React.Fragment`."), Se(null));
      }
    }
    var Pt = {};
    function vt(ee, Re, Ge, ot, kt, wt) {
      {
        var pt = N(ee);
        if (!pt) {
          var gt = "";
          (ee === void 0 || typeof ee == "object" && ee !== null && Object.keys(ee).length === 0) && (gt += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var or = We();
          or ? gt += or : gt += Ze();
          var ze;
          ee === null ? ze = "null" : Ie(ee) ? ze = "array" : ee !== void 0 && ee.$$typeof === e ? (ze = "<" + (O(ee.type) || "Unknown") + " />", gt = " Did you accidentally export a JSX literal instead of a component?") : ze = typeof ee, b("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", ze, gt);
        }
        var le = he(ee, Re, Ge, kt, wt);
        if (le == null)
          return le;
        if (pt) {
          var Oe = Re.children;
          if (Oe !== void 0)
            if (ot)
              if (Ie(Oe)) {
                for (var at = 0; at < Oe.length; at++)
                  mt(Oe[at], ee);
                Object.freeze && Object.freeze(Oe);
              } else
                b("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              mt(Oe, ee);
        }
        if (Ee.call(Re, "key")) {
          var Ht = O(ee), Vt = Object.keys(Re).filter(function(qn) {
            return qn !== "key";
          }), yr = Vt.length > 0 ? "{key: someKey, " + Vt.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Pt[Ht + yr]) {
            var jr = Vt.length > 0 ? "{" + Vt.join(": ..., ") + ": ...}" : "{}";
            b(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, yr, Ht, jr, Ht), Pt[Ht + yr] = !0;
          }
        }
        return ee === n ? et(le) : Ke(le), le;
      }
    }
    function nt(ee, Re, Ge) {
      return vt(ee, Re, Ge, !0);
    }
    function Dt(ee, Re, Ge) {
      return vt(ee, Re, Ge, !1);
    }
    var Gt = Dt, yt = nt;
    Gf.Fragment = n, Gf.jsx = Gt, Gf.jsxs = yt;
  }()), Gf;
}
process.env.NODE_ENV === "production" ? pE.exports = aj() : pE.exports = ij();
var CMe = pE.exports, kS = {}, W8 = { exports: {} };
(function(t) {
  function e(r) {
    return r && r.__esModule ? r : {
      default: r
    };
  }
  t.exports = e, t.exports.__esModule = !0, t.exports.default = t.exports;
})(W8);
var Kt = W8.exports, xy = {};
Object.defineProperty(xy, "__esModule", {
  value: !0
});
xy.default = void 0;
var sj = {
  // Options
  items_per_page: "条/页",
  jump_to: "跳至",
  jump_to_confirm: "确定",
  page: "页",
  // Pagination
  prev_page: "上一页",
  next_page: "下一页",
  prev_5: "向前 5 页",
  next_5: "向后 5 页",
  prev_3: "向前 3 页",
  next_3: "向后 3 页",
  page_size: "页码"
};
xy.default = sj;
var wy = {}, x0 = {}, Ey = {}, j8 = { exports: {} }, Y8 = { exports: {} }, X8 = { exports: {} }, K8 = { exports: {} };
(function(t) {
  function e(r) {
    "@babel/helpers - typeof";
    return t.exports = e = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(n) {
      return typeof n;
    } : function(n) {
      return n && typeof Symbol == "function" && n.constructor === Symbol && n !== Symbol.prototype ? "symbol" : typeof n;
    }, t.exports.__esModule = !0, t.exports.default = t.exports, e(r);
  }
  t.exports = e, t.exports.__esModule = !0, t.exports.default = t.exports;
})(K8);
var w0 = K8.exports, Z8 = { exports: {} };
(function(t) {
  var e = w0.default;
  function r(n, a) {
    if (e(n) != "object" || !n) return n;
    var i = n[Symbol.toPrimitive];
    if (i !== void 0) {
      var s = i.call(n, a || "default");
      if (e(s) != "object") return s;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (a === "string" ? String : Number)(n);
  }
  t.exports = r, t.exports.__esModule = !0, t.exports.default = t.exports;
})(Z8);
var oj = Z8.exports;
(function(t) {
  var e = w0.default, r = oj;
  function n(a) {
    var i = r(a, "string");
    return e(i) == "symbol" ? i : i + "";
  }
  t.exports = n, t.exports.__esModule = !0, t.exports.default = t.exports;
})(X8);
var lj = X8.exports;
(function(t) {
  var e = lj;
  function r(n, a, i) {
    return (a = e(a)) in n ? Object.defineProperty(n, a, {
      value: i,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : n[a] = i, n;
  }
  t.exports = r, t.exports.__esModule = !0, t.exports.default = t.exports;
})(Y8);
var uj = Y8.exports;
(function(t) {
  var e = uj;
  function r(a, i) {
    var s = Object.keys(a);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(a);
      i && (o = o.filter(function(l) {
        return Object.getOwnPropertyDescriptor(a, l).enumerable;
      })), s.push.apply(s, o);
    }
    return s;
  }
  function n(a) {
    for (var i = 1; i < arguments.length; i++) {
      var s = arguments[i] != null ? arguments[i] : {};
      i % 2 ? r(Object(s), !0).forEach(function(o) {
        e(a, o, s[o]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(a, Object.getOwnPropertyDescriptors(s)) : r(Object(s)).forEach(function(o) {
        Object.defineProperty(a, o, Object.getOwnPropertyDescriptor(s, o));
      });
    }
    return a;
  }
  t.exports = n, t.exports.__esModule = !0, t.exports.default = t.exports;
})(j8);
var al = j8.exports, bs = {};
Object.defineProperty(bs, "__esModule", {
  value: !0
});
bs.commonLocale = void 0;
bs.commonLocale = {
  yearFormat: "YYYY",
  dayFormat: "D",
  cellMeridiemFormat: "A",
  monthBeforeYear: !0
};
var cj = Kt.default;
Object.defineProperty(Ey, "__esModule", {
  value: !0
});
Ey.default = void 0;
var eA = cj(al), fj = bs, hj = (0, eA.default)((0, eA.default)({}, fj.commonLocale), {}, {
  locale: "zh_CN",
  today: "今天",
  now: "此刻",
  backToToday: "返回今天",
  ok: "确定",
  timeSelect: "选择时间",
  dateSelect: "选择日期",
  weekSelect: "选择周",
  clear: "清除",
  week: "周",
  month: "月",
  year: "年",
  previousMonth: "上个月 (翻页上键)",
  nextMonth: "下个月 (翻页下键)",
  monthSelect: "选择月份",
  yearSelect: "选择年份",
  decadeSelect: "选择年代",
  previousYear: "上一年 (Control键加左方向键)",
  nextYear: "下一年 (Control键加右方向键)",
  previousDecade: "上一年代",
  nextDecade: "下一年代",
  previousCentury: "上一世纪",
  nextCentury: "下一世纪",
  yearFormat: "YYYY年",
  cellDateFormat: "D",
  monthBeforeYear: !1
});
Ey.default = hj;
var E0 = {};
Object.defineProperty(E0, "__esModule", {
  value: !0
});
E0.default = void 0;
const dj = {
  placeholder: "请选择时间",
  rangePlaceholder: ["开始时间", "结束时间"]
};
E0.default = dj;
var Q8 = Kt.default;
Object.defineProperty(x0, "__esModule", {
  value: !0
});
x0.default = void 0;
var pj = Q8(Ey), gj = Q8(E0);
const J8 = {
  lang: Object.assign({
    placeholder: "请选择日期",
    yearPlaceholder: "请选择年份",
    quarterPlaceholder: "请选择季度",
    monthPlaceholder: "请选择月份",
    weekPlaceholder: "请选择周",
    rangePlaceholder: ["开始日期", "结束日期"],
    rangeYearPlaceholder: ["开始年份", "结束年份"],
    rangeMonthPlaceholder: ["开始月份", "结束月份"],
    rangeQuarterPlaceholder: ["开始季度", "结束季度"],
    rangeWeekPlaceholder: ["开始周", "结束周"]
  }, pj.default),
  timePickerLocale: Object.assign({}, gj.default)
};
J8.lang.ok = "确定";
x0.default = J8;
var vj = Kt.default;
Object.defineProperty(wy, "__esModule", {
  value: !0
});
wy.default = void 0;
var mj = vj(x0);
wy.default = mj.default;
var Ty = Kt.default;
Object.defineProperty(kS, "__esModule", {
  value: !0
});
var yj = kS.default = void 0, bj = Ty(xy), xj = Ty(wy), wj = Ty(x0), Ej = Ty(E0);
const $a = "${label}不是一个有效的${type}", Tj = {
  locale: "zh-cn",
  Pagination: bj.default,
  DatePicker: wj.default,
  TimePicker: Ej.default,
  Calendar: xj.default,
  // locales for all components
  global: {
    placeholder: "请选择"
  },
  Table: {
    filterTitle: "筛选",
    filterConfirm: "确定",
    filterReset: "重置",
    filterEmptyText: "无筛选项",
    filterCheckAll: "全选",
    filterSearchPlaceholder: "在筛选项中搜索",
    emptyText: "暂无数据",
    selectAll: "全选当页",
    selectInvert: "反选当页",
    selectNone: "清空所有",
    selectionAll: "全选所有",
    sortTitle: "排序",
    expand: "展开行",
    collapse: "关闭行",
    triggerDesc: "点击降序",
    triggerAsc: "点击升序",
    cancelSort: "取消排序"
  },
  Modal: {
    okText: "确定",
    cancelText: "取消",
    justOkText: "知道了"
  },
  Tour: {
    Next: "下一步",
    Previous: "上一步",
    Finish: "结束导览"
  },
  Popconfirm: {
    cancelText: "取消",
    okText: "确定"
  },
  Transfer: {
    titles: ["", ""],
    searchPlaceholder: "请输入搜索内容",
    itemUnit: "项",
    itemsUnit: "项",
    remove: "删除",
    selectCurrent: "全选当页",
    removeCurrent: "删除当页",
    selectAll: "全选所有",
    deselectAll: "取消全选",
    removeAll: "删除全部",
    selectInvert: "反选当页"
  },
  Upload: {
    uploading: "文件上传中",
    removeFile: "删除文件",
    uploadError: "上传错误",
    previewFile: "预览文件",
    downloadFile: "下载文件"
  },
  Empty: {
    description: "暂无数据"
  },
  Icon: {
    icon: "图标"
  },
  Text: {
    edit: "编辑",
    copy: "复制",
    copied: "复制成功",
    expand: "展开",
    collapse: "收起"
  },
  Form: {
    optional: "（可选）",
    defaultValidateMessages: {
      default: "字段验证错误${label}",
      required: "请输入${label}",
      enum: "${label}必须是其中一个[${enum}]",
      whitespace: "${label}不能为空字符",
      date: {
        format: "${label}日期格式无效",
        parse: "${label}不能转换为日期",
        invalid: "${label}是一个无效日期"
      },
      types: {
        string: $a,
        method: $a,
        array: $a,
        object: $a,
        number: $a,
        date: $a,
        boolean: $a,
        integer: $a,
        float: $a,
        regexp: $a,
        email: $a,
        url: $a,
        hex: $a
      },
      string: {
        len: "${label}须为${len}个字符",
        min: "${label}最少${min}个字符",
        max: "${label}最多${max}个字符",
        range: "${label}须在${min}-${max}字符之间"
      },
      number: {
        len: "${label}必须等于${len}",
        min: "${label}最小值为${min}",
        max: "${label}最大值为${max}",
        range: "${label}须在${min}-${max}之间"
      },
      array: {
        len: "须为${len}个${label}",
        min: "最少${min}个${label}",
        max: "最多${max}个${label}",
        range: "${label}数量须在${min}-${max}之间"
      },
      pattern: {
        mismatch: "${label}与模式不匹配${pattern}"
      }
    }
  },
  Image: {
    preview: "预览"
  },
  QRCode: {
    expired: "二维码过期",
    refresh: "点击刷新",
    scanned: "已扫描"
  },
  ColorPicker: {
    presetEmpty: "暂无",
    transparent: "无色",
    singleColor: "单色",
    gradientColor: "渐变色"
  }
};
yj = kS.default = Tj;
var Sy = {}, Cy = {};
Object.defineProperty(Cy, "__esModule", {
  value: !0
});
Cy.default = void 0;
var Sj = {
  // Options
  items_per_page: "/ page",
  jump_to: "Go to",
  jump_to_confirm: "confirm",
  page: "Page",
  // Pagination
  prev_page: "Previous Page",
  next_page: "Next Page",
  prev_5: "Previous 5 Pages",
  next_5: "Next 5 Pages",
  prev_3: "Previous 3 Pages",
  next_3: "Next 3 Pages",
  page_size: "Page Size"
};
Cy.default = Sj;
var Ay = {}, T0 = {}, ky = {}, Cj = Kt.default;
Object.defineProperty(ky, "__esModule", {
  value: !0
});
ky.default = void 0;
var tA = Cj(al), Aj = bs, kj = (0, tA.default)((0, tA.default)({}, Aj.commonLocale), {}, {
  locale: "en_US",
  today: "Today",
  now: "Now",
  backToToday: "Back to today",
  ok: "OK",
  clear: "Clear",
  week: "Week",
  month: "Month",
  year: "Year",
  timeSelect: "select time",
  dateSelect: "select date",
  weekSelect: "Choose a week",
  monthSelect: "Choose a month",
  yearSelect: "Choose a year",
  decadeSelect: "Choose a decade",
  dateFormat: "M/D/YYYY",
  dateTimeFormat: "M/D/YYYY HH:mm:ss",
  previousMonth: "Previous month (PageUp)",
  nextMonth: "Next month (PageDown)",
  previousYear: "Last year (Control + left)",
  nextYear: "Next year (Control + right)",
  previousDecade: "Last decade",
  nextDecade: "Next decade",
  previousCentury: "Last century",
  nextCentury: "Next century"
});
ky.default = kj;
var S0 = {};
Object.defineProperty(S0, "__esModule", {
  value: !0
});
S0.default = void 0;
const Rj = {
  placeholder: "Select time",
  rangePlaceholder: ["Start time", "End time"]
};
S0.default = Rj;
var eO = Kt.default;
Object.defineProperty(T0, "__esModule", {
  value: !0
});
T0.default = void 0;
var Mj = eO(ky), _j = eO(S0);
const Lj = {
  lang: Object.assign({
    placeholder: "Select date",
    yearPlaceholder: "Select year",
    quarterPlaceholder: "Select quarter",
    monthPlaceholder: "Select month",
    weekPlaceholder: "Select week",
    rangePlaceholder: ["Start date", "End date"],
    rangeYearPlaceholder: ["Start year", "End year"],
    rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
    rangeMonthPlaceholder: ["Start month", "End month"],
    rangeWeekPlaceholder: ["Start week", "End week"]
  }, Mj.default),
  timePickerLocale: Object.assign({}, _j.default)
};
T0.default = Lj;
var Nj = Kt.default;
Object.defineProperty(Ay, "__esModule", {
  value: !0
});
Ay.default = void 0;
var Oj = Nj(T0);
Ay.default = Oj.default;
var Ry = Kt.default;
Object.defineProperty(Sy, "__esModule", {
  value: !0
});
var Ij = Sy.default = void 0, Pj = Ry(Cy), Dj = Ry(Ay), $j = Ry(T0), Fj = Ry(S0);
const Fa = "${label} is not a valid ${type}", Bj = {
  locale: "en",
  Pagination: Pj.default,
  DatePicker: $j.default,
  TimePicker: Fj.default,
  Calendar: Dj.default,
  global: {
    placeholder: "Please select"
  },
  Table: {
    filterTitle: "Filter menu",
    filterConfirm: "OK",
    filterReset: "Reset",
    filterEmptyText: "No filters",
    filterCheckAll: "Select all items",
    filterSearchPlaceholder: "Search in filters",
    emptyText: "No data",
    selectAll: "Select current page",
    selectInvert: "Invert current page",
    selectNone: "Clear all data",
    selectionAll: "Select all data",
    sortTitle: "Sort",
    expand: "Expand row",
    collapse: "Collapse row",
    triggerDesc: "Click to sort descending",
    triggerAsc: "Click to sort ascending",
    cancelSort: "Click to cancel sorting"
  },
  Tour: {
    Next: "Next",
    Previous: "Previous",
    Finish: "Finish"
  },
  Modal: {
    okText: "OK",
    cancelText: "Cancel",
    justOkText: "OK"
  },
  Popconfirm: {
    okText: "OK",
    cancelText: "Cancel"
  },
  Transfer: {
    titles: ["", ""],
    searchPlaceholder: "Search here",
    itemUnit: "item",
    itemsUnit: "items",
    remove: "Remove",
    selectCurrent: "Select current page",
    removeCurrent: "Remove current page",
    selectAll: "Select all data",
    deselectAll: "Deselect all data",
    removeAll: "Remove all data",
    selectInvert: "Invert current page"
  },
  Upload: {
    uploading: "Uploading...",
    removeFile: "Remove file",
    uploadError: "Upload error",
    previewFile: "Preview file",
    downloadFile: "Download file"
  },
  Empty: {
    description: "No data"
  },
  Icon: {
    icon: "icon"
  },
  Text: {
    edit: "Edit",
    copy: "Copy",
    copied: "Copied",
    expand: "Expand",
    collapse: "Collapse"
  },
  Form: {
    optional: "(optional)",
    defaultValidateMessages: {
      default: "Field validation error for ${label}",
      required: "Please enter ${label}",
      enum: "${label} must be one of [${enum}]",
      whitespace: "${label} cannot be a blank character",
      date: {
        format: "${label} date format is invalid",
        parse: "${label} cannot be converted to a date",
        invalid: "${label} is an invalid date"
      },
      types: {
        string: Fa,
        method: Fa,
        array: Fa,
        object: Fa,
        number: Fa,
        date: Fa,
        boolean: Fa,
        integer: Fa,
        float: Fa,
        regexp: Fa,
        email: Fa,
        url: Fa,
        hex: Fa
      },
      string: {
        len: "${label} must be ${len} characters",
        min: "${label} must be at least ${min} characters",
        max: "${label} must be up to ${max} characters",
        range: "${label} must be between ${min}-${max} characters"
      },
      number: {
        len: "${label} must be equal to ${len}",
        min: "${label} must be minimum ${min}",
        max: "${label} must be maximum ${max}",
        range: "${label} must be between ${min}-${max}"
      },
      array: {
        len: "Must be ${len} ${label}",
        min: "At least ${min} ${label}",
        max: "At most ${max} ${label}",
        range: "The amount of ${label} must be between ${min}-${max}"
      },
      pattern: {
        mismatch: "${label} does not match the pattern ${pattern}"
      }
    }
  },
  Image: {
    preview: "Preview"
  },
  QRCode: {
    expired: "QR code expired",
    refresh: "Refresh",
    scanned: "Scanned"
  },
  ColorPicker: {
    presetEmpty: "Empty",
    transparent: "Transparent",
    singleColor: "Single",
    gradientColor: "Gradient"
  }
};
Ij = Sy.default = Bj;
var RS = {}, My = {};
Object.defineProperty(My, "__esModule", {
  value: !0
});
My.default = void 0;
var zj = {
  // Options
  items_per_page: "/ Seite",
  jump_to: "Gehe zu",
  jump_to_confirm: "bestätigen",
  page: "Seite",
  // Pagination
  prev_page: "Vorherige Seite",
  next_page: "Nächste Seite",
  prev_5: "5 Seiten zurück",
  next_5: "5 Seiten vor",
  prev_3: "3 Seiten zurück",
  next_3: "3 Seiten vor",
  page_size: "Page Size"
};
My.default = zj;
var _y = {}, C0 = {}, Ly = {}, Gj = Kt.default;
Object.defineProperty(Ly, "__esModule", {
  value: !0
});
Ly.default = void 0;
var rA = Gj(al), Uj = bs, Hj = (0, rA.default)((0, rA.default)({}, Uj.commonLocale), {}, {
  locale: "de_DE",
  today: "Heute",
  now: "Jetzt",
  backToToday: "Zurück zu Heute",
  ok: "OK",
  clear: "Zurücksetzen",
  week: "Woche",
  month: "Monat",
  year: "Jahr",
  timeSelect: "Zeit wählen",
  dateSelect: "Datum wählen",
  monthSelect: "Wähle einen Monat",
  yearSelect: "Wähle ein Jahr",
  decadeSelect: "Wähle ein Jahrzehnt",
  dateFormat: "D.M.YYYY",
  dateTimeFormat: "D.M.YYYY HH:mm:ss",
  previousMonth: "Vorheriger Monat (PageUp)",
  nextMonth: "Nächster Monat (PageDown)",
  previousYear: "Vorheriges Jahr (Ctrl + left)",
  nextYear: "Nächstes Jahr (Ctrl + right)",
  previousDecade: "Vorheriges Jahrzehnt",
  nextDecade: "Nächstes Jahrzehnt",
  previousCentury: "Vorheriges Jahrhundert",
  nextCentury: "Nächstes Jahrhundert"
});
Ly.default = Hj;
var A0 = {};
Object.defineProperty(A0, "__esModule", {
  value: !0
});
A0.default = void 0;
const Vj = {
  placeholder: "Zeit auswählen",
  rangePlaceholder: ["Startzeit", "Endzeit"]
};
A0.default = Vj;
var tO = Kt.default;
Object.defineProperty(C0, "__esModule", {
  value: !0
});
C0.default = void 0;
var qj = tO(Ly), Wj = tO(A0);
const jj = {
  lang: Object.assign({
    placeholder: "Datum auswählen",
    rangePlaceholder: ["Startdatum", "Enddatum"],
    shortWeekDays: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
    shortMonths: ["Jan", "Feb", "Mär", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez"]
  }, qj.default),
  timePickerLocale: Object.assign({}, Wj.default)
};
C0.default = jj;
var Yj = Kt.default;
Object.defineProperty(_y, "__esModule", {
  value: !0
});
_y.default = void 0;
var Xj = Yj(C0);
_y.default = Xj.default;
var Ny = Kt.default;
Object.defineProperty(RS, "__esModule", {
  value: !0
});
var Kj = RS.default = void 0, Zj = Ny(My), Qj = Ny(_y), Jj = Ny(C0), eY = Ny(A0);
const Ba = "${label} ist nicht gültig. ${type} erwartet", tY = {
  locale: "de",
  Pagination: Zj.default,
  DatePicker: Jj.default,
  TimePicker: eY.default,
  Calendar: Qj.default,
  global: {
    placeholder: "Bitte auswählen"
  },
  Table: {
    filterTitle: "Filter-Menü",
    filterConfirm: "OK",
    filterReset: "Zurücksetzen",
    filterEmptyText: "Keine Filter",
    filterSearchPlaceholder: "Suche in Filtern",
    filterCheckAll: "Alle auswählen",
    selectAll: "Selektiere Alle",
    selectInvert: "Selektion Invertieren",
    selectionAll: "Wählen Sie alle Daten aus",
    sortTitle: "Sortieren",
    emptyText: "Keine Daten",
    expand: "Zeile erweitern",
    collapse: "Zeile reduzieren",
    triggerDesc: "Klicken zur absteigenden Sortierung",
    triggerAsc: "Klicken zur aufsteigenden Sortierung",
    cancelSort: "Klicken zum Abbrechen der Sortierung"
  },
  Tour: {
    Next: "Weiter",
    Previous: "Zurück",
    Finish: "Fertig"
  },
  Modal: {
    okText: "OK",
    cancelText: "Abbrechen",
    justOkText: "OK"
  },
  Popconfirm: {
    okText: "OK",
    cancelText: "Abbrechen"
  },
  Transfer: {
    titles: ["", ""],
    searchPlaceholder: "Suchen",
    itemUnit: "Eintrag",
    itemsUnit: "Einträge",
    remove: "Entfernen",
    selectCurrent: "Alle auf aktueller Seite auswählen",
    removeCurrent: "Auswahl auf aktueller Seite aufheben",
    selectAll: "Alle auswählen",
    deselectAll: "Alle abwählen",
    removeAll: "Auswahl aufheben",
    selectInvert: "Auswahl umkehren"
  },
  Upload: {
    uploading: "Hochladen...",
    removeFile: "Datei entfernen",
    uploadError: "Fehler beim Hochladen",
    previewFile: "Dateivorschau",
    downloadFile: "Download-Datei"
  },
  Empty: {
    description: "Keine Daten"
  },
  Text: {
    edit: "Bearbeiten",
    copy: "Kopieren",
    copied: "Kopiert",
    expand: "Erweitern"
  },
  Form: {
    defaultValidateMessages: {
      default: "Feld-Validierungsfehler: ${label}",
      required: "Bitte geben Sie ${label} an",
      enum: "${label} muss eines der folgenden sein [${enum}]",
      whitespace: "${label} darf kein Leerzeichen sein",
      date: {
        format: "${label} ist ein ungültiges Datumsformat",
        parse: "${label} kann nicht in ein Datum umgewandelt werden",
        invalid: "${label} ist ein ungültiges Datum"
      },
      types: {
        string: Ba,
        method: Ba,
        array: Ba,
        object: Ba,
        number: Ba,
        date: Ba,
        boolean: Ba,
        integer: Ba,
        float: Ba,
        regexp: Ba,
        email: Ba,
        url: Ba,
        hex: Ba
      },
      string: {
        len: "${label} muss genau ${len} Zeichen lang sein",
        min: "${label} muss mindestens ${min} Zeichen lang sein",
        max: "${label} darf höchstens ${max} Zeichen lang sein",
        range: "${label} muss zwischen ${min} und ${max} Zeichen lang sein"
      },
      number: {
        len: "${label} muss gleich ${len} sein",
        min: "${label} muss mindestens ${min} sein",
        max: "${label} darf maximal ${max} sein",
        range: "${label} muss zwischen ${min} und ${max} liegen"
      },
      array: {
        len: "Es müssen ${len} ${label} sein",
        min: "Es müssen mindestens ${min} ${label} sein",
        max: "Es dürfen maximal ${max} ${label} sein",
        range: "Die Anzahl an ${label} muss zwischen ${min} und ${max} liegen"
      },
      pattern: {
        mismatch: "${label} entspricht nicht dem ${pattern} Muster"
      }
    }
  },
  Image: {
    preview: "Vorschau"
  },
  QRCode: {
    expired: "QR-Code abgelaufen",
    refresh: "Aktualisieren"
  }
};
Kj = RS.default = tY;
var MS = {}, Oy = {};
Object.defineProperty(Oy, "__esModule", {
  value: !0
});
Oy.default = void 0;
var rY = {
  // Options
  items_per_page: "/ página",
  jump_to: "Ir a",
  jump_to_confirm: "confirmar",
  page: "Página",
  // Pagination
  prev_page: "Página anterior",
  next_page: "Página siguiente",
  prev_5: "5 páginas previas",
  next_5: "5 páginas siguientes",
  prev_3: "3 páginas previas",
  next_3: "3 páginas siguientes",
  page_size: "tamaño de página"
};
Oy.default = rY;
var Iy = {}, k0 = {}, Py = {}, nY = Kt.default;
Object.defineProperty(Py, "__esModule", {
  value: !0
});
Py.default = void 0;
var nA = nY(al), aY = bs, iY = (0, nA.default)((0, nA.default)({}, aY.commonLocale), {}, {
  locale: "es_ES",
  today: "Hoy",
  now: "Ahora",
  backToToday: "Volver a hoy",
  ok: "Aceptar",
  clear: "Limpiar",
  week: "Semana",
  month: "Mes",
  year: "Año",
  timeSelect: "Seleccionar hora",
  dateSelect: "Seleccionar fecha",
  monthSelect: "Elegir un mes",
  yearSelect: "Elegir un año",
  decadeSelect: "Elegir una década",
  dateFormat: "D/M/YYYY",
  dateTimeFormat: "D/M/YYYY HH:mm:ss",
  previousMonth: "Mes anterior (PageUp)",
  nextMonth: "Mes siguiente (PageDown)",
  previousYear: "Año anterior (Control + left)",
  nextYear: "Año siguiente (Control + right)",
  previousDecade: "Década anterior",
  nextDecade: "Década siguiente",
  previousCentury: "Siglo anterior",
  nextCentury: "Siglo siguiente"
});
Py.default = iY;
var R0 = {};
Object.defineProperty(R0, "__esModule", {
  value: !0
});
R0.default = void 0;
const sY = {
  placeholder: "Seleccionar hora"
};
R0.default = sY;
var rO = Kt.default;
Object.defineProperty(k0, "__esModule", {
  value: !0
});
k0.default = void 0;
var oY = rO(Py), lY = rO(R0);
const uY = {
  lang: Object.assign({
    placeholder: "Seleccionar fecha",
    rangePlaceholder: ["Fecha inicial", "Fecha final"],
    shortWeekDays: ["Dom", "Lun", "Mar", "Mié", "Jue", "Vie", "Sáb"],
    shortMonths: ["Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"]
  }, oY.default),
  timePickerLocale: Object.assign({}, lY.default)
};
k0.default = uY;
var cY = Kt.default;
Object.defineProperty(Iy, "__esModule", {
  value: !0
});
Iy.default = void 0;
var fY = cY(k0);
Iy.default = fY.default;
var Dy = Kt.default;
Object.defineProperty(MS, "__esModule", {
  value: !0
});
var hY = MS.default = void 0, dY = Dy(Oy), pY = Dy(Iy), gY = Dy(k0), vY = Dy(R0);
const za = "${label} no es un ${type} válido", mY = {
  locale: "es",
  Pagination: dY.default,
  DatePicker: gY.default,
  TimePicker: vY.default,
  Calendar: pY.default,
  global: {
    placeholder: "Seleccione"
  },
  Table: {
    filterTitle: "Filtrar menú",
    filterConfirm: "Aceptar",
    filterReset: "Reiniciar",
    filterEmptyText: "Sin filtros",
    filterCheckAll: "Seleccionar todo",
    filterSearchPlaceholder: "Buscar en filtros",
    emptyText: "Sin datos",
    selectAll: "Seleccionar todo",
    selectInvert: "Invertir selección",
    selectNone: "Vacíe todo",
    selectionAll: "Seleccionar todos los datos",
    sortTitle: "Ordenar",
    expand: "Expandir fila",
    collapse: "Colapsar fila",
    triggerDesc: "Click para ordenar en orden descendente",
    triggerAsc: "Click para ordenar en orden ascendente",
    cancelSort: "Click para cancelar ordenamiento"
  },
  Tour: {
    Next: "Siguiente",
    Previous: "Anterior",
    Finish: "Finalizar"
  },
  Modal: {
    okText: "Aceptar",
    cancelText: "Cancelar",
    justOkText: "Aceptar"
  },
  Popconfirm: {
    okText: "Aceptar",
    cancelText: "Cancelar"
  },
  Transfer: {
    titles: ["", ""],
    searchPlaceholder: "Buscar aquí",
    itemUnit: "elemento",
    itemsUnit: "elementos",
    remove: "Eliminar",
    selectCurrent: "Seleccionar página actual",
    removeCurrent: "Eliminar página actual",
    selectAll: "Seleccionar todos los datos",
    removeAll: "Eliminar todos los datos",
    selectInvert: "Invertir página actual"
  },
  Upload: {
    uploading: "Subiendo...",
    removeFile: "Eliminar archivo",
    uploadError: "Error al subir el archivo",
    previewFile: "Vista previa",
    downloadFile: "Descargar archivo"
  },
  Empty: {
    description: "No hay datos"
  },
  Icon: {
    icon: "ícono"
  },
  Text: {
    edit: "Editar",
    copy: "Copiar",
    copied: "Copiado",
    expand: "Expandir"
  },
  Form: {
    optional: "(opcional)",
    defaultValidateMessages: {
      default: "Error de validación del campo ${label}",
      required: "Por favor, rellena ${label}",
      enum: "${label} debe ser uno de [${enum}]",
      whitespace: "${label} no puede ser un carácter en blanco",
      date: {
        format: "El formato de fecha de ${label} es inválido",
        parse: "${label} no se puede convertir a una fecha",
        invalid: "${label} es una fecha inválida"
      },
      types: {
        string: za,
        method: za,
        array: za,
        object: za,
        number: za,
        date: za,
        boolean: za,
        integer: za,
        float: za,
        regexp: za,
        email: za,
        url: za,
        hex: za
      },
      string: {
        len: "${label} debe tener ${len} caracteres",
        min: "${label} debe tener al menos ${min} caracteres",
        max: "${label} debe tener hasta ${max} caracteres",
        range: "${label} debe tener entre ${min}-${max} caracteres"
      },
      number: {
        len: "${label} debe ser igual a ${len}",
        min: "${label} valor mínimo es ${min}",
        max: "${label} valor máximo es ${max}",
        range: "${label} debe ser entre ${min}-${max}"
      },
      array: {
        len: "Debe ser ${len} ${label}",
        min: "Al menos ${min} ${label}",
        max: "Como máximo ${max} ${label}",
        range: "El valor de ${label} debe estar entre ${min}-${max}"
      },
      pattern: {
        mismatch: "${label} no coincide con el patrón ${pattern}"
      }
    }
  },
  Image: {
    preview: "Previsualización"
  }
};
hY = MS.default = mY;
var _S = {}, $y = {};
Object.defineProperty($y, "__esModule", {
  value: !0
});
$y.default = void 0;
var yY = {
  // Options
  items_per_page: "/ page",
  jump_to: "Aller à",
  jump_to_confirm: "confirmer",
  page: "Page",
  // Pagination
  prev_page: "Page précédente",
  next_page: "Page suivante",
  prev_5: "5 Pages précédentes",
  next_5: "5 Pages suivantes",
  prev_3: "3 Pages précédentes",
  next_3: "3 Pages suivantes",
  page_size: "taille de la page"
};
$y.default = yY;
var Fy = {}, M0 = {}, By = {}, bY = Kt.default;
Object.defineProperty(By, "__esModule", {
  value: !0
});
By.default = void 0;
var aA = bY(al), xY = bs, wY = (0, aA.default)((0, aA.default)({}, xY.commonLocale), {}, {
  locale: "fr_FR",
  today: "Aujourd'hui",
  now: "Maintenant",
  backToToday: "Aujourd'hui",
  ok: "OK",
  clear: "Rétablir",
  week: "Semaine",
  month: "Mois",
  year: "Année",
  timeSelect: "Sélectionner l'heure",
  dateSelect: "Sélectionner la date",
  monthSelect: "Choisissez un mois",
  yearSelect: "Choisissez une année",
  decadeSelect: "Choisissez une décennie",
  dateFormat: "DD/MM/YYYY",
  dayFormat: "DD",
  dateTimeFormat: "DD/MM/YYYY HH:mm:ss",
  previousMonth: "Mois précédent (PageUp)",
  nextMonth: "Mois suivant (PageDown)",
  previousYear: "Année précédente (Ctrl + gauche)",
  nextYear: "Année prochaine (Ctrl + droite)",
  previousDecade: "Décennie précédente",
  nextDecade: "Décennie suivante",
  previousCentury: "Siècle précédent",
  nextCentury: "Siècle suivant"
});
By.default = wY;
var _0 = {};
Object.defineProperty(_0, "__esModule", {
  value: !0
});
_0.default = void 0;
const EY = {
  placeholder: "Sélectionner l'heure",
  rangePlaceholder: ["Heure de début", "Heure de fin"]
};
_0.default = EY;
var nO = Kt.default;
Object.defineProperty(M0, "__esModule", {
  value: !0
});
M0.default = void 0;
var TY = nO(By), SY = nO(_0);
const CY = {
  lang: Object.assign({
    placeholder: "Sélectionner une date",
    yearPlaceholder: "Sélectionner une année",
    quarterPlaceholder: "Sélectionner un trimestre",
    monthPlaceholder: "Sélectionner un mois",
    weekPlaceholder: "Sélectionner une semaine",
    rangePlaceholder: ["Date de début", "Date de fin"],
    rangeYearPlaceholder: ["Année de début", "Année de fin"],
    rangeMonthPlaceholder: ["Mois de début", "Mois de fin"],
    rangeWeekPlaceholder: ["Semaine de début", "Semaine de fin"]
  }, TY.default),
  timePickerLocale: Object.assign({}, SY.default)
};
M0.default = CY;
var AY = Kt.default;
Object.defineProperty(Fy, "__esModule", {
  value: !0
});
Fy.default = void 0;
var kY = AY(M0);
Fy.default = kY.default;
var zy = Kt.default;
Object.defineProperty(_S, "__esModule", {
  value: !0
});
var RY = _S.default = void 0, MY = zy($y), _Y = zy(Fy), LY = zy(M0), NY = zy(_0);
const Ga = "La valeur du champ ${label} n'est pas valide pour le type ${type}", OY = {
  locale: "fr",
  Pagination: MY.default,
  DatePicker: LY.default,
  TimePicker: NY.default,
  Calendar: _Y.default,
  Table: {
    filterTitle: "Filtrer",
    filterConfirm: "OK",
    filterReset: "Réinitialiser",
    filterEmptyText: "Aucun filtre",
    filterCheckAll: "Tout sélectionner",
    filterSearchPlaceholder: "Chercher dans les filtres",
    emptyText: "Aucune donnée",
    selectAll: "Sélectionner la page actuelle",
    selectInvert: "Inverser la sélection de la page actuelle",
    selectNone: "Désélectionner toutes les données",
    selectionAll: "Sélectionner toutes les données",
    sortTitle: "Trier",
    expand: "Développer la ligne",
    collapse: "Réduire la ligne",
    triggerDesc: "Trier par ordre décroissant",
    triggerAsc: "Trier par ordre croissant",
    cancelSort: "Annuler le tri"
  },
  Tour: {
    Next: "Étape suivante",
    Previous: "Étape précédente",
    Finish: "Fin de la visite guidée"
  },
  Modal: {
    okText: "OK",
    cancelText: "Annuler",
    justOkText: "OK"
  },
  Popconfirm: {
    okText: "OK",
    cancelText: "Annuler"
  },
  Transfer: {
    titles: ["", ""],
    searchPlaceholder: "Rechercher",
    itemUnit: "élément",
    itemsUnit: "éléments",
    remove: "Désélectionner",
    selectCurrent: "Sélectionner la page actuelle",
    removeCurrent: "Désélectionner la page actuelle",
    selectAll: "Sélectionner toutes les données",
    removeAll: "Désélectionner toutes les données",
    selectInvert: "Inverser la sélection de la page actuelle"
  },
  Upload: {
    uploading: "Téléchargement...",
    removeFile: "Effacer le fichier",
    uploadError: "Erreur de téléchargement",
    previewFile: "Fichier de prévisualisation",
    downloadFile: "Télécharger un fichier"
  },
  Empty: {
    description: "Aucune donnée"
  },
  Icon: {
    icon: "icône"
  },
  Text: {
    edit: "Éditer",
    copy: "Copier",
    copied: "Copie effectuée",
    expand: "Développer"
  },
  Form: {
    optional: "(optionnel)",
    defaultValidateMessages: {
      default: "Erreur de validation pour le champ ${label}",
      required: "Le champ ${label} est obligatoire",
      enum: "La valeur du champ ${label} doit être parmi [${enum}]",
      whitespace: "La valeur du champ ${label} ne peut pas être vide",
      date: {
        format: "La valeur du champ ${label} n'est pas au format date",
        parse: "La valeur du champ ${label} ne peut pas être convertie vers une date",
        invalid: "La valeur du champ ${label} n'est pas une date valide"
      },
      types: {
        string: Ga,
        method: Ga,
        array: Ga,
        object: Ga,
        number: Ga,
        date: Ga,
        boolean: Ga,
        integer: Ga,
        float: Ga,
        regexp: Ga,
        email: Ga,
        url: Ga,
        hex: Ga
      },
      string: {
        len: "La taille du champ ${label} doit être de ${len} caractères",
        min: "La taille du champ ${label} doit être au minimum de ${min} caractères",
        max: "La taille du champ ${label} doit être au maximum de ${max} caractères",
        range: "La taille du champ ${label} doit être entre ${min} et ${max} caractères"
      },
      number: {
        len: "La valeur du champ ${label} doit être égale à ${len}",
        min: "La valeur du champ ${label} doit être plus grande que ${min}",
        max: "La valeur du champ ${label} doit être plus petit que ${max}",
        range: "La valeur du champ ${label} doit être entre ${min} et ${max}"
      },
      array: {
        len: "La taille du tableau ${label} doit être de ${len}",
        min: "La taille du tableau ${label} doit être au minimum de ${min}",
        max: "La taille du tableau ${label} doit être au maximum de ${max}",
        range: "La taille du tableau ${label} doit être entre ${min}-${max}"
      },
      pattern: {
        mismatch: "La valeur du champ ${label} ne correspond pas au modèle ${pattern}"
      }
    }
  },
  Image: {
    preview: "Aperçu"
  }
};
RY = _S.default = OY;
var LS = {}, Gy = {};
Object.defineProperty(Gy, "__esModule", {
  value: !0
});
Gy.default = void 0;
var IY = {
  // Options
  items_per_page: "/ الصفحة",
  jump_to: "الذهاب إلى",
  jump_to_confirm: "تأكيد",
  page: "الصفحة",
  // Pagination
  prev_page: "الصفحة السابقة",
  next_page: "الصفحة التالية",
  prev_5: "خمس صفحات سابقة",
  next_5: "خمس صفحات تالية",
  prev_3: "ثلاث صفحات سابقة",
  next_3: "ثلاث صفحات تالية",
  page_size: "مقاس الصفحه"
};
Gy.default = IY;
var Uy = {}, L0 = {}, Hy = {}, PY = Kt.default;
Object.defineProperty(Hy, "__esModule", {
  value: !0
});
Hy.default = void 0;
var iA = PY(al), DY = bs, $Y = (0, iA.default)((0, iA.default)({}, DY.commonLocale), {}, {
  locale: "ar_EG",
  today: "اليوم",
  now: "الأن",
  backToToday: "العودة إلى اليوم",
  ok: "تأكيد",
  clear: "مسح",
  week: "الأسبوع",
  month: "الشهر",
  year: "السنة",
  timeSelect: "اختيار الوقت",
  dateSelect: "اختيار التاريخ",
  monthSelect: "اختيار الشهر",
  yearSelect: "اختيار السنة",
  decadeSelect: "اختيار العقد",
  dateFormat: "M/D/YYYY",
  dateTimeFormat: "M/D/YYYY HH:mm:ss",
  previousMonth: "الشهر السابق (PageUp)",
  nextMonth: "الشهر التالى(PageDown)",
  previousYear: "العام السابق (Control + left)",
  nextYear: "العام التالى (Control + right)",
  previousDecade: "العقد السابق",
  nextDecade: "العقد التالى",
  previousCentury: "القرن السابق",
  nextCentury: "القرن التالى"
});
Hy.default = $Y;
var N0 = {};
Object.defineProperty(N0, "__esModule", {
  value: !0
});
N0.default = void 0;
const FY = {
  placeholder: "اختيار الوقت"
};
N0.default = FY;
var aO = Kt.default;
Object.defineProperty(L0, "__esModule", {
  value: !0
});
L0.default = void 0;
var BY = aO(Hy), zY = aO(N0);
const GY = {
  lang: Object.assign({
    placeholder: "اختيار التاريخ",
    rangePlaceholder: ["البداية", "النهاية"],
    yearFormat: "YYYY",
    monthFormat: "MMMM",
    monthBeforeYear: !0,
    shortWeekDays: ["الأحد", "الإثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت"],
    shortMonths: ["يناير", "فبراير", "مارس", "إبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"]
  }, BY.default),
  timePickerLocale: Object.assign({}, zY.default)
};
L0.default = GY;
var UY = Kt.default;
Object.defineProperty(Uy, "__esModule", {
  value: !0
});
Uy.default = void 0;
var HY = UY(L0);
Uy.default = HY.default;
var Vy = Kt.default;
Object.defineProperty(LS, "__esModule", {
  value: !0
});
var VY = LS.default = void 0, qY = Vy(Gy), WY = Vy(Uy), jY = Vy(L0), YY = Vy(N0);
const Ua = "ليس ${label} من نوع ${type} صالحًا", XY = {
  locale: "ar",
  Pagination: qY.default,
  DatePicker: jY.default,
  TimePicker: YY.default,
  Calendar: WY.default,
  global: {
    placeholder: "يرجى التحديد"
  },
  Table: {
    filterTitle: "الفلاتر",
    filterConfirm: "تأكيد",
    filterReset: "إعادة ضبط",
    selectAll: "اختيار الكل",
    selectInvert: "إلغاء الاختيار",
    selectionAll: "حدد جميع البيانات",
    sortTitle: "رتب",
    expand: "توسيع الصف",
    collapse: "طي الصف",
    triggerDesc: "ترتيب تنازلي",
    triggerAsc: "ترتيب تصاعدي",
    cancelSort: "إلغاء الترتيب"
  },
  Tour: {
    Next: "التالي",
    Previous: "السابق",
    Finish: "إنهاء"
  },
  Modal: {
    okText: "تأكيد",
    cancelText: "إلغاء",
    justOkText: "تأكيد"
  },
  Popconfirm: {
    okText: "تأكيد",
    cancelText: "إلغاء"
  },
  Transfer: {
    titles: ["", ""],
    searchPlaceholder: "ابحث هنا",
    itemUnit: "عنصر",
    itemsUnit: "عناصر"
  },
  Upload: {
    uploading: "جاري الرفع...",
    removeFile: "احذف الملف",
    uploadError: "مشكلة فى الرفع",
    previewFile: "استعرض الملف",
    downloadFile: "تحميل الملف"
  },
  Empty: {
    description: "لا توجد بيانات"
  },
  Icon: {
    icon: "أيقونة"
  },
  Text: {
    edit: "تعديل",
    copy: "نسخ",
    copied: "نقل",
    expand: "وسع"
  },
  Form: {
    defaultValidateMessages: {
      default: "خطأ في حقل الإدخال ${label}",
      required: "يرجى إدخال ${label}",
      enum: "${label} يجب أن يكون واحدا من [${enum}]",
      whitespace: "${label} لا يمكن أن يكون حرفًا فارغًا",
      date: {
        format: "${label} تنسيق التاريخ غير صحيح",
        parse: "${label} لا يمكن تحويلها إلى تاريخ",
        invalid: "تاريخ ${label} غير صحيح"
      },
      types: {
        string: Ua,
        method: Ua,
        array: Ua,
        object: Ua,
        number: Ua,
        date: Ua,
        boolean: Ua,
        integer: Ua,
        float: Ua,
        regexp: Ua,
        email: Ua,
        url: Ua,
        hex: Ua
      },
      string: {
        len: "يجب ${label} ان يكون ${len} أحرف",
        min: "${label} على الأقل ${min} أحرف",
        max: "${label} يصل إلى ${max} أحرف",
        range: "يجب ${label} ان يكون مابين ${min}-${max} أحرف"
      },
      number: {
        len: "${len} ان يساوي ${label} يجب",
        min: "${min} الأدنى هو ${label} حد",
        max: "${max} الأقصى هو ${label} حد",
        range: "${max}-${min} ان يكون مابين ${label} يجب"
      },
      array: {
        len: "يجب أن يكون ${label} طوله ${len}",
        min: "يجب أن يكون ${label} طوله الأدنى ${min}",
        max: "يجب أن يكون ${label} طوله الأقصى ${max}",
        range: "يجب أن يكون ${label} طوله مابين ${min}-${max}"
      },
      pattern: {
        mismatch: "لا يتطابق ${label} مع ${pattern}"
      }
    }
  },
  Image: {
    preview: "معاينة"
  },
  QRCode: {
    expired: "انتهت صلاحية رمز الاستجابة السريعة",
    refresh: "انقر للتحديث",
    scanned: "تم المسح"
  },
  ColorPicker: {
    presetEmpty: "لا يوجد",
    transparent: "شفاف",
    singleColor: "لون واحد",
    gradientColor: "تدرج لوني"
  }
};
VY = LS.default = XY;
var NS = {}, qy = {};
Object.defineProperty(qy, "__esModule", {
  value: !0
});
qy.default = void 0;
var KY = {
  // Options
  items_per_page: "/ sida",
  jump_to: "Gå till",
  jump_to_confirm: "bekräfta",
  page: "Sida",
  // Pagination
  prev_page: "Föreg sida",
  next_page: "Nästa sida",
  prev_5: "Föreg 5 sidor",
  next_5: "Nästa 5 sidor",
  prev_3: "Föreg 3 sidor",
  next_3: "Nästa 3 sidor",
  page_size: "sidstorlek"
};
qy.default = KY;
var Wy = {}, O0 = {}, jy = {}, ZY = Kt.default;
Object.defineProperty(jy, "__esModule", {
  value: !0
});
jy.default = void 0;
var sA = ZY(al), QY = bs, JY = (0, sA.default)((0, sA.default)({}, QY.commonLocale), {}, {
  locale: "sv_SE",
  today: "I dag",
  now: "Nu",
  backToToday: "Till idag",
  ok: "OK",
  clear: "Avbryt",
  week: "Vecka",
  month: "Månad",
  year: "År",
  timeSelect: "Välj tidpunkt",
  dateSelect: "Välj datum",
  monthSelect: "Välj månad",
  yearSelect: "Välj år",
  decadeSelect: "Välj årtionde",
  dateFormat: "YYYY-MM-DD",
  dateTimeFormat: "YYYY-MM-DD H:mm:ss",
  previousMonth: "Förra månaden (PageUp)",
  nextMonth: "Nästa månad (PageDown)",
  previousYear: "Föreg år (Control + left)",
  nextYear: "Nästa år (Control + right)",
  previousDecade: "Föreg årtionde",
  nextDecade: "Nästa årtionde",
  previousCentury: "Föreg århundrade",
  nextCentury: "Nästa århundrade"
});
jy.default = JY;
var I0 = {};
Object.defineProperty(I0, "__esModule", {
  value: !0
});
I0.default = void 0;
const eX = {
  placeholder: "Välj tid"
};
I0.default = eX;
var iO = Kt.default;
Object.defineProperty(O0, "__esModule", {
  value: !0
});
O0.default = void 0;
var tX = iO(jy), rX = iO(I0);
const nX = {
  lang: Object.assign({
    placeholder: "Välj datum",
    yearPlaceholder: "Välj år",
    quarterPlaceholder: "Välj kvartal",
    monthPlaceholder: "Välj månad",
    weekPlaceholder: "Välj vecka",
    rangePlaceholder: ["Startdatum", "Slutdatum"],
    rangeYearPlaceholder: ["Startår", "Slutår"],
    rangeMonthPlaceholder: ["Startmånad", "Slutmånad"],
    rangeWeekPlaceholder: ["Startvecka", "Slutvecka"]
  }, tX.default),
  timePickerLocale: Object.assign({}, rX.default)
};
O0.default = nX;
var aX = Kt.default;
Object.defineProperty(Wy, "__esModule", {
  value: !0
});
Wy.default = void 0;
var iX = aX(O0);
Wy.default = iX.default;
var Yy = Kt.default;
Object.defineProperty(NS, "__esModule", {
  value: !0
});
var sX = NS.default = void 0, oX = Yy(qy), lX = Yy(Wy), uX = Yy(O0), cX = Yy(I0);
const Ha = "${label} är inte en giltig ${type}", fX = {
  locale: "sv",
  Pagination: oX.default,
  DatePicker: uX.default,
  TimePicker: cX.default,
  Calendar: lX.default,
  global: {
    placeholder: "Vänligen välj"
  },
  Table: {
    filterTitle: "Filtermeny",
    filterConfirm: "OK",
    filterReset: "Återställ",
    filterEmptyText: "Inga filter",
    filterCheckAll: "Markera alla objekt",
    filterSearchPlaceholder: "Sök i filter",
    emptyText: "Ingen data",
    selectAll: "Markera nuvarande sida",
    selectInvert: "Invertera nuvarande sida",
    selectNone: "Avmarkera all data",
    selectionAll: "Markera all data",
    sortTitle: "Sortera",
    expand: "Expandera rad",
    collapse: "Komprimera rad",
    triggerDesc: "Klicka för att sortera i fallande ordning",
    triggerAsc: "Klicka för att sortera i stigande ordning",
    cancelSort: "Klicka för att avbryta sortering"
  },
  Tour: {
    Next: "Nästa",
    Previous: "Föregående",
    Finish: "Avsluta"
  },
  Modal: {
    okText: "OK",
    cancelText: "Avbryt",
    justOkText: "OK"
  },
  Popconfirm: {
    okText: "OK",
    cancelText: "Avbryt"
  },
  Transfer: {
    titles: ["", ""],
    searchPlaceholder: "Sök här",
    itemUnit: "objekt",
    itemsUnit: "objekt",
    remove: "Ta bort",
    selectCurrent: "Markera nuvarande sida",
    removeCurrent: "Ta bort nuvarande sida",
    selectAll: "Markera all data",
    removeAll: "Ta bort all data",
    selectInvert: "Invertera nuvarande sida"
  },
  Upload: {
    uploading: "Laddar upp...",
    removeFile: "Ta bort fil",
    uploadError: "Uppladdningsfel",
    previewFile: "Förhandsgranska fil",
    downloadFile: "Ladda ned fil"
  },
  Empty: {
    description: "Ingen data"
  },
  Icon: {
    icon: "ikon"
  },
  Text: {
    edit: "Redigera",
    copy: "Kopiera",
    copied: "Kopierad",
    expand: "Expandera"
  },
  Form: {
    optional: "(valfritt)",
    defaultValidateMessages: {
      default: "Fältvalideringsfel för ${label}",
      required: "Vänligen fyll i ${label}",
      enum: "${label} måste vara en av [${enum}]",
      whitespace: "${label} kan inte vara ett tomt tecken",
      date: {
        format: "${label} datumformatet är ogiltigt",
        parse: "${label} kan inte konverteras till ett datum",
        invalid: "${label} är ett ogiltigt datum"
      },
      types: {
        string: Ha,
        method: Ha,
        array: Ha,
        object: Ha,
        number: Ha,
        date: Ha,
        boolean: Ha,
        integer: Ha,
        float: Ha,
        regexp: Ha,
        email: Ha,
        url: Ha,
        hex: Ha
      },
      string: {
        len: "${label} måste vara ${len} tecken",
        min: "${label} måste vara minst ${min} tecken",
        max: "${label} måste vara högst ${max} tecken",
        range: "${label} måste vara mellan ${min}-${max} tecken"
      },
      number: {
        len: "${label} måste vara lika med ${len}",
        min: "${label} måste vara minst ${min}",
        max: "${label} måste vara högst ${max}",
        range: "${label} måste vara mellan ${min}-${max}"
      },
      array: {
        len: "Måste vara ${len} ${label}",
        min: "Minst ${min} ${label}",
        max: "Högst ${max} ${label}",
        range: "Antal ${label} måste vara mellan ${min}-${max}"
      },
      pattern: {
        mismatch: "${label} stämmer inte överens med mönstret ${pattern}"
      }
    }
  },
  Image: {
    preview: "Förhandsgranska"
  },
  QRCode: {
    expired: "QR-koden har upphört att gälla",
    refresh: "Uppdatera"
  }
};
sX = NS.default = fX;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var gE = function(t, e) {
  return gE = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, n) {
    r.__proto__ = n;
  } || function(r, n) {
    for (var a in n) n.hasOwnProperty(a) && (r[a] = n[a]);
  }, gE(t, e);
};
function hX(t, e) {
  gE(t, e);
  function r() {
    this.constructor = t;
  }
  t.prototype = e === null ? Object.create(e) : (r.prototype = e.prototype, new r());
}
var gd = function() {
  return gd = Object.assign || function(e) {
    for (var r, n = 1, a = arguments.length; n < a; n++) {
      r = arguments[n];
      for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
    }
    return e;
  }, gd.apply(this, arguments);
};
function dX(t, e, r, n) {
  var a, i = !1, s = 0;
  function o() {
    a && clearTimeout(a);
  }
  function l() {
    o(), i = !0;
  }
  typeof e != "boolean" && (n = r, r = e, e = void 0);
  function u() {
    var c = this, f = Date.now() - s, h = arguments;
    if (i)
      return;
    function d() {
      s = Date.now(), r.apply(c, h);
    }
    function p() {
      a = void 0;
    }
    n && !a && d(), o(), n === void 0 && f > t ? d() : e !== !0 && (a = setTimeout(n ? p : d, n === void 0 ? t - f : t));
  }
  return u.cancel = l, u;
}
var dc = {
  Pixel: "Pixel",
  Percent: "Percent"
}, oA = {
  unit: dc.Percent,
  value: 0.8
};
function lA(t) {
  return typeof t == "number" ? {
    unit: dc.Percent,
    value: t * 100
  } : typeof t == "string" ? t.match(/^(\d*(\.\d+)?)px$/) ? {
    unit: dc.Pixel,
    value: parseFloat(t)
  } : t.match(/^(\d*(\.\d+)?)%$/) ? {
    unit: dc.Percent,
    value: parseFloat(t)
  } : (console.warn('scrollThreshold format is invalid. Valid formats: "120px", "50%"...'), oA) : (console.warn("scrollThreshold should be string or number"), oA);
}
var AMe = (
  /** @class */
  function(t) {
    hX(e, t);
    function e(r) {
      var n = t.call(this, r) || this;
      return n.lastScrollTop = 0, n.actionTriggered = !1, n.startY = 0, n.currentY = 0, n.dragging = !1, n.maxPullDownDistance = 0, n.getScrollableTarget = function() {
        return n.props.scrollableTarget instanceof HTMLElement ? n.props.scrollableTarget : typeof n.props.scrollableTarget == "string" ? document.getElementById(n.props.scrollableTarget) : (n.props.scrollableTarget === null && console.warn(`You are trying to pass scrollableTarget but it is null. This might
        happen because the element may not have been added to DOM yet.
        See https://github.com/ankeetmaini/react-infinite-scroll-component/issues/59 for more info.
      `), null);
      }, n.onStart = function(a) {
        n.lastScrollTop || (n.dragging = !0, a instanceof MouseEvent ? n.startY = a.pageY : a instanceof TouchEvent && (n.startY = a.touches[0].pageY), n.currentY = n.startY, n._infScroll && (n._infScroll.style.willChange = "transform", n._infScroll.style.transition = "transform 0.2s cubic-bezier(0,0,0.31,1)"));
      }, n.onMove = function(a) {
        n.dragging && (a instanceof MouseEvent ? n.currentY = a.pageY : a instanceof TouchEvent && (n.currentY = a.touches[0].pageY), !(n.currentY < n.startY) && (n.currentY - n.startY >= Number(n.props.pullDownToRefreshThreshold) && n.setState({
          pullToRefreshThresholdBreached: !0
        }), !(n.currentY - n.startY > n.maxPullDownDistance * 1.5) && n._infScroll && (n._infScroll.style.overflow = "visible", n._infScroll.style.transform = "translate3d(0px, " + (n.currentY - n.startY) + "px, 0px)")));
      }, n.onEnd = function() {
        n.startY = 0, n.currentY = 0, n.dragging = !1, n.state.pullToRefreshThresholdBreached && (n.props.refreshFunction && n.props.refreshFunction(), n.setState({
          pullToRefreshThresholdBreached: !1
        })), requestAnimationFrame(function() {
          n._infScroll && (n._infScroll.style.overflow = "auto", n._infScroll.style.transform = "none", n._infScroll.style.willChange = "unset");
        });
      }, n.onScrollListener = function(a) {
        typeof n.props.onScroll == "function" && setTimeout(function() {
          return n.props.onScroll && n.props.onScroll(a);
        }, 0);
        var i = n.props.height || n._scrollableNode ? a.target : document.documentElement.scrollTop ? document.documentElement : document.body;
        if (!n.actionTriggered) {
          var s = n.props.inverse ? n.isElementAtTop(i, n.props.scrollThreshold) : n.isElementAtBottom(i, n.props.scrollThreshold);
          s && n.props.hasMore && (n.actionTriggered = !0, n.setState({ showLoader: !0 }), n.props.next && n.props.next()), n.lastScrollTop = i.scrollTop;
        }
      }, n.state = {
        showLoader: !1,
        pullToRefreshThresholdBreached: !1,
        prevDataLength: r.dataLength
      }, n.throttledOnScrollListener = dX(150, n.onScrollListener).bind(n), n.onStart = n.onStart.bind(n), n.onMove = n.onMove.bind(n), n.onEnd = n.onEnd.bind(n), n;
    }
    return e.prototype.componentDidMount = function() {
      if (typeof this.props.dataLength > "u")
        throw new Error('mandatory prop "dataLength" is missing. The prop is needed when loading more content. Check README.md for usage');
      if (this._scrollableNode = this.getScrollableTarget(), this.el = this.props.height ? this._infScroll : this._scrollableNode || window, this.el && this.el.addEventListener("scroll", this.throttledOnScrollListener), typeof this.props.initialScrollY == "number" && this.el && this.el instanceof HTMLElement && this.el.scrollHeight > this.props.initialScrollY && this.el.scrollTo(0, this.props.initialScrollY), this.props.pullDownToRefresh && this.el && (this.el.addEventListener("touchstart", this.onStart), this.el.addEventListener("touchmove", this.onMove), this.el.addEventListener("touchend", this.onEnd), this.el.addEventListener("mousedown", this.onStart), this.el.addEventListener("mousemove", this.onMove), this.el.addEventListener("mouseup", this.onEnd), this.maxPullDownDistance = this._pullDown && this._pullDown.firstChild && this._pullDown.firstChild.getBoundingClientRect().height || 0, this.forceUpdate(), typeof this.props.refreshFunction != "function"))
        throw new Error(`Mandatory prop "refreshFunction" missing.
          Pull Down To Refresh functionality will not work
          as expected. Check README.md for usage'`);
    }, e.prototype.componentWillUnmount = function() {
      this.el && (this.el.removeEventListener("scroll", this.throttledOnScrollListener), this.props.pullDownToRefresh && (this.el.removeEventListener("touchstart", this.onStart), this.el.removeEventListener("touchmove", this.onMove), this.el.removeEventListener("touchend", this.onEnd), this.el.removeEventListener("mousedown", this.onStart), this.el.removeEventListener("mousemove", this.onMove), this.el.removeEventListener("mouseup", this.onEnd)));
    }, e.prototype.componentDidUpdate = function(r) {
      this.props.dataLength !== r.dataLength && (this.actionTriggered = !1, this.setState({
        showLoader: !1
      }));
    }, e.getDerivedStateFromProps = function(r, n) {
      var a = r.dataLength !== n.prevDataLength;
      return a ? gd(gd({}, n), { prevDataLength: r.dataLength }) : null;
    }, e.prototype.isElementAtTop = function(r, n) {
      n === void 0 && (n = 0.8);
      var a = r === document.body || r === document.documentElement ? window.screen.availHeight : r.clientHeight, i = lA(n);
      return i.unit === dc.Pixel ? r.scrollTop <= i.value + a - r.scrollHeight + 1 : r.scrollTop <= i.value / 100 + a - r.scrollHeight + 1;
    }, e.prototype.isElementAtBottom = function(r, n) {
      n === void 0 && (n = 0.8);
      var a = r === document.body || r === document.documentElement ? window.screen.availHeight : r.clientHeight, i = lA(n);
      return i.unit === dc.Pixel ? r.scrollTop + a >= r.scrollHeight - i.value : r.scrollTop + a >= i.value / 100 * r.scrollHeight;
    }, e.prototype.render = function() {
      var r = this, n = gd({ height: this.props.height || "auto", overflow: "auto", WebkitOverflowScrolling: "touch" }, this.props.style), a = this.props.hasChildren || !!(this.props.children && this.props.children instanceof Array && this.props.children.length), i = this.props.pullDownToRefresh && this.props.height ? { overflow: "auto" } : {};
      return lt.createElement(
        "div",
        { style: i, className: "infinite-scroll-component__outerdiv" },
        lt.createElement(
          "div",
          { className: "infinite-scroll-component " + (this.props.className || ""), ref: function(s) {
            return r._infScroll = s;
          }, style: n },
          this.props.pullDownToRefresh && lt.createElement(
            "div",
            { style: { position: "relative" }, ref: function(s) {
              return r._pullDown = s;
            } },
            lt.createElement("div", { style: {
              position: "absolute",
              left: 0,
              right: 0,
              top: -1 * this.maxPullDownDistance
            } }, this.state.pullToRefreshThresholdBreached ? this.props.releaseToRefreshContent : this.props.pullDownToRefreshContent)
          ),
          this.props.children,
          !this.state.showLoader && !a && this.props.hasMore && this.props.loader,
          this.state.showLoader && this.props.hasMore && this.props.loader,
          !this.props.hasMore && this.props.endMessage
        )
      );
    }, e;
  }(EH)
);
function Ra() {
  return Ra = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e];
      for (var n in r) ({}).hasOwnProperty.call(r, n) && (t[n] = r[n]);
    }
    return t;
  }, Ra.apply(null, arguments);
}
function Tt(t) {
  "@babel/helpers - typeof";
  return Tt = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Tt(t);
}
function pX(t, e) {
  if (Tt(t) != "object" || !t) return t;
  var r = t[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(t, e);
    if (Tt(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function sO(t) {
  var e = pX(t, "string");
  return Tt(e) == "symbol" ? e : e + "";
}
function pe(t, e, r) {
  return (e = sO(e)) in t ? Object.defineProperty(t, e, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = r, t;
}
function uA(t, e) {
  var r = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(t);
    e && (n = n.filter(function(a) {
      return Object.getOwnPropertyDescriptor(t, a).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function ke(t) {
  for (var e = 1; e < arguments.length; e++) {
    var r = arguments[e] != null ? arguments[e] : {};
    e % 2 ? uA(Object(r), !0).forEach(function(n) {
      pe(t, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : uA(Object(r)).forEach(function(n) {
      Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return t;
}
function oO(t) {
  if (Array.isArray(t)) return t;
}
function gX(t, e) {
  var r = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
  if (r != null) {
    var n, a, i, s, o = [], l = !0, u = !1;
    try {
      if (i = (r = r.call(t)).next, e === 0) {
        if (Object(r) !== r) return;
        l = !1;
      } else for (; !(l = (n = i.call(r)).done) && (o.push(n.value), o.length !== e); l = !0) ;
    } catch (c) {
      u = !0, a = c;
    } finally {
      try {
        if (!l && r.return != null && (s = r.return(), Object(s) !== s)) return;
      } finally {
        if (u) throw a;
      }
    }
    return o;
  }
}
function vE(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var r = 0, n = Array(e); r < e; r++) n[r] = t[r];
  return n;
}
function OS(t, e) {
  if (t) {
    if (typeof t == "string") return vE(t, e);
    var r = {}.toString.call(t).slice(8, -1);
    return r === "Object" && t.constructor && (r = t.constructor.name), r === "Map" || r === "Set" ? Array.from(t) : r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? vE(t, e) : void 0;
  }
}
function lO() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function bt(t, e) {
  return oO(t) || gX(t, e) || OS(t, e) || lO();
}
function cA(t) {
  return t instanceof HTMLElement || t instanceof SVGElement;
}
function vX(t) {
  return t && Tt(t) === "object" && cA(t.nativeElement) ? t.nativeElement : cA(t) ? t : null;
}
function Vg(t) {
  var e = vX(t);
  if (e)
    return e;
  if (t instanceof lt.Component) {
    var r;
    return (r = Z3.findDOMNode) === null || r === void 0 ? void 0 : r.call(Z3, t);
  }
  return null;
}
var mE = { exports: {} }, lr = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var fA;
function mX() {
  if (fA) return lr;
  fA = 1;
  var t = Symbol.for("react.element"), e = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), n = Symbol.for("react.strict_mode"), a = Symbol.for("react.profiler"), i = Symbol.for("react.provider"), s = Symbol.for("react.context"), o = Symbol.for("react.server_context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), f = Symbol.for("react.memo"), h = Symbol.for("react.lazy"), d = Symbol.for("react.offscreen"), p;
  p = Symbol.for("react.module.reference");
  function g(v) {
    if (typeof v == "object" && v !== null) {
      var m = v.$$typeof;
      switch (m) {
        case t:
          switch (v = v.type, v) {
            case r:
            case a:
            case n:
            case u:
            case c:
              return v;
            default:
              switch (v = v && v.$$typeof, v) {
                case o:
                case s:
                case l:
                case h:
                case f:
                case i:
                  return v;
                default:
                  return m;
              }
          }
        case e:
          return m;
      }
    }
  }
  return lr.ContextConsumer = s, lr.ContextProvider = i, lr.Element = t, lr.ForwardRef = l, lr.Fragment = r, lr.Lazy = h, lr.Memo = f, lr.Portal = e, lr.Profiler = a, lr.StrictMode = n, lr.Suspense = u, lr.SuspenseList = c, lr.isAsyncMode = function() {
    return !1;
  }, lr.isConcurrentMode = function() {
    return !1;
  }, lr.isContextConsumer = function(v) {
    return g(v) === s;
  }, lr.isContextProvider = function(v) {
    return g(v) === i;
  }, lr.isElement = function(v) {
    return typeof v == "object" && v !== null && v.$$typeof === t;
  }, lr.isForwardRef = function(v) {
    return g(v) === l;
  }, lr.isFragment = function(v) {
    return g(v) === r;
  }, lr.isLazy = function(v) {
    return g(v) === h;
  }, lr.isMemo = function(v) {
    return g(v) === f;
  }, lr.isPortal = function(v) {
    return g(v) === e;
  }, lr.isProfiler = function(v) {
    return g(v) === a;
  }, lr.isStrictMode = function(v) {
    return g(v) === n;
  }, lr.isSuspense = function(v) {
    return g(v) === u;
  }, lr.isSuspenseList = function(v) {
    return g(v) === c;
  }, lr.isValidElementType = function(v) {
    return typeof v == "string" || typeof v == "function" || v === r || v === a || v === n || v === u || v === c || v === d || typeof v == "object" && v !== null && (v.$$typeof === h || v.$$typeof === f || v.$$typeof === i || v.$$typeof === s || v.$$typeof === l || v.$$typeof === p || v.getModuleId !== void 0);
  }, lr.typeOf = g, lr;
}
var ur = {};
/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hA;
function yX() {
  return hA || (hA = 1, process.env.NODE_ENV !== "production" && function() {
    var t = Symbol.for("react.element"), e = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), n = Symbol.for("react.strict_mode"), a = Symbol.for("react.profiler"), i = Symbol.for("react.provider"), s = Symbol.for("react.context"), o = Symbol.for("react.server_context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), f = Symbol.for("react.memo"), h = Symbol.for("react.lazy"), d = Symbol.for("react.offscreen"), p = !1, g = !1, v = !1, m = !1, b = !1, y;
    y = Symbol.for("react.module.reference");
    function x(J) {
      return !!(typeof J == "string" || typeof J == "function" || J === r || J === a || b || J === n || J === u || J === c || m || J === d || p || g || v || typeof J == "object" && J !== null && (J.$$typeof === h || J.$$typeof === f || J.$$typeof === i || J.$$typeof === s || J.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      J.$$typeof === y || J.getModuleId !== void 0));
    }
    function E(J) {
      if (typeof J == "object" && J !== null) {
        var Ce = J.$$typeof;
        switch (Ce) {
          case t:
            var Ee = J.type;
            switch (Ee) {
              case r:
              case a:
              case n:
              case u:
              case c:
                return Ee;
              default:
                var Te = Ee && Ee.$$typeof;
                switch (Te) {
                  case o:
                  case s:
                  case l:
                  case h:
                  case f:
                  case i:
                    return Te;
                  default:
                    return Ce;
                }
            }
          case e:
            return Ce;
        }
      }
    }
    var S = s, w = i, C = t, k = l, N = r, R = h, _ = f, O = e, T = a, L = n, M = u, A = c, I = !1, D = !1;
    function F(J) {
      return I || (I = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function B(J) {
      return D || (D = !0, console.warn("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function G(J) {
      return E(J) === s;
    }
    function H(J) {
      return E(J) === i;
    }
    function K(J) {
      return typeof J == "object" && J !== null && J.$$typeof === t;
    }
    function j(J) {
      return E(J) === l;
    }
    function Z(J) {
      return E(J) === r;
    }
    function te(J) {
      return E(J) === h;
    }
    function ne(J) {
      return E(J) === f;
    }
    function V(J) {
      return E(J) === e;
    }
    function q(J) {
      return E(J) === a;
    }
    function X(J) {
      return E(J) === n;
    }
    function W(J) {
      return E(J) === u;
    }
    function ue(J) {
      return E(J) === c;
    }
    ur.ContextConsumer = S, ur.ContextProvider = w, ur.Element = C, ur.ForwardRef = k, ur.Fragment = N, ur.Lazy = R, ur.Memo = _, ur.Portal = O, ur.Profiler = T, ur.StrictMode = L, ur.Suspense = M, ur.SuspenseList = A, ur.isAsyncMode = F, ur.isConcurrentMode = B, ur.isContextConsumer = G, ur.isContextProvider = H, ur.isElement = K, ur.isForwardRef = j, ur.isFragment = Z, ur.isLazy = te, ur.isMemo = ne, ur.isPortal = V, ur.isProfiler = q, ur.isStrictMode = X, ur.isSuspense = W, ur.isSuspenseList = ue, ur.isValidElementType = x, ur.typeOf = E;
  }()), ur;
}
process.env.NODE_ENV === "production" ? mE.exports = mX() : mE.exports = yX();
var qg = mE.exports;
function IS(t, e, r) {
  var n = de.useRef({});
  return (!("value" in n.current) || r(n.current.condition, e)) && (n.current.value = t(), n.current.condition = e), n.current.value;
}
var bX = Symbol.for("react.element"), xX = Symbol.for("react.transitional.element"), wX = Symbol.for("react.fragment");
function uO(t) {
  return (
    // Base object type
    t && Tt(t) === "object" && // React Element type
    (t.$$typeof === bX || t.$$typeof === xX) && // React Fragment type
    t.type === wX
  );
}
var EX = Number(H8.split(".")[0]), cO = function(e, r) {
  typeof e == "function" ? e(r) : Tt(e) === "object" && e && "current" in e && (e.current = r);
}, fO = function() {
  for (var e = arguments.length, r = new Array(e), n = 0; n < e; n++)
    r[n] = arguments[n];
  var a = r.filter(Boolean);
  return a.length <= 1 ? a[0] : function(i) {
    r.forEach(function(s) {
      cO(s, i);
    });
  };
}, TX = function() {
  for (var e = arguments.length, r = new Array(e), n = 0; n < e; n++)
    r[n] = arguments[n];
  return IS(function() {
    return fO.apply(void 0, r);
  }, r, function(a, i) {
    return a.length !== i.length || a.every(function(s, o) {
      return s !== i[o];
    });
  });
}, hO = function(e) {
  var r, n;
  if (!e)
    return !1;
  if (dO(e) && EX >= 19)
    return !0;
  var a = qg.isMemo(e) ? e.type.type : e.type;
  return !(typeof a == "function" && !((r = a.prototype) !== null && r !== void 0 && r.render) && a.$$typeof !== qg.ForwardRef || typeof e == "function" && !((n = e.prototype) !== null && n !== void 0 && n.render) && e.$$typeof !== qg.ForwardRef);
};
function dO(t) {
  return /* @__PURE__ */ TH(t) && !uO(t);
}
var pO = function(e) {
  if (e && dO(e)) {
    var r = e;
    return r.props.propertyIsEnumerable("ref") ? r.props.ref : r.ref;
  }
  return null;
};
function SX(t, e) {
  if (t == null) return {};
  var r = {};
  for (var n in t) if ({}.hasOwnProperty.call(t, n)) {
    if (e.indexOf(n) !== -1) continue;
    r[n] = t[n];
  }
  return r;
}
function vi(t, e) {
  if (t == null) return {};
  var r, n, a = SX(t, e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t);
    for (n = 0; n < i.length; n++) r = i[n], e.indexOf(r) === -1 && {}.propertyIsEnumerable.call(t, r) && (a[r] = t[r]);
  }
  return a;
}
var CX = ["children"], gO = /* @__PURE__ */ de.createContext({});
function AX(t) {
  var e = t.children, r = vi(t, CX);
  return /* @__PURE__ */ de.createElement(gO.Provider, {
    value: r
  }, e);
}
function Ln(t, e) {
  if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
}
function dA(t, e) {
  for (var r = 0; r < e.length; r++) {
    var n = e[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, sO(n.key), n);
  }
}
function Nn(t, e, r) {
  return e && dA(t.prototype, e), r && dA(t, r), Object.defineProperty(t, "prototype", {
    writable: !1
  }), t;
}
function Dd(t, e) {
  return Dd = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, n) {
    return r.__proto__ = n, r;
  }, Dd(t, e);
}
function il(t, e) {
  if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(t, "prototype", {
    writable: !1
  }), e && Dd(t, e);
}
function $d(t) {
  return $d = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
    return e.__proto__ || Object.getPrototypeOf(e);
  }, $d(t);
}
function PS() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (PS = function() {
    return !!t;
  })();
}
function $t(t) {
  if (t === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t;
}
function kX(t, e) {
  if (e && (Tt(e) == "object" || typeof e == "function")) return e;
  if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
  return $t(t);
}
function sl(t) {
  var e = PS();
  return function() {
    var r, n = $d(t);
    if (e) {
      var a = $d(this).constructor;
      r = Reflect.construct(n, arguments, a);
    } else r = n.apply(this, arguments);
    return kX(this, r);
  };
}
var RX = /* @__PURE__ */ function(t) {
  il(r, t);
  var e = sl(r);
  function r() {
    return Ln(this, r), e.apply(this, arguments);
  }
  return Nn(r, [{
    key: "render",
    value: function() {
      return this.props.children;
    }
  }]), r;
}(de.Component);
function Fd(t) {
  var e = de.useRef();
  e.current = t;
  var r = de.useCallback(function() {
    for (var n, a = arguments.length, i = new Array(a), s = 0; s < a; s++)
      i[s] = arguments[s];
    return (n = e.current) === null || n === void 0 ? void 0 : n.call.apply(n, [e].concat(i));
  }, []);
  return r;
}
function po() {
  return !!(typeof window < "u" && window.document && window.document.createElement);
}
var pA = process.env.NODE_ENV !== "test" && po() ? de.useLayoutEffect : de.useEffect, zv = function(e, r) {
  var n = de.useRef(!0);
  pA(function() {
    return e(n.current);
  }, r), pA(function() {
    return n.current = !1, function() {
      n.current = !0;
    };
  }, []);
}, gA = function(e, r) {
  zv(function(n) {
    if (!n)
      return e();
  }, r);
};
function Bd(t) {
  var e = de.useRef(!1), r = de.useState(t), n = bt(r, 2), a = n[0], i = n[1];
  de.useEffect(function() {
    return e.current = !1, function() {
      e.current = !0;
    };
  }, []);
  function s(o, l) {
    l && e.current || i(o);
  }
  return [a, s];
}
function Mb(t) {
  return t !== void 0;
}
function DS(t, e) {
  var r = e || {}, n = r.defaultValue, a = r.value, i = r.onChange, s = r.postState, o = Bd(function() {
    return Mb(a) ? a : Mb(n) ? typeof n == "function" ? n() : n : typeof t == "function" ? t() : t;
  }), l = bt(o, 2), u = l[0], c = l[1], f = a !== void 0 ? a : u, h = s ? s(f) : f, d = Fd(i), p = Bd([f]), g = bt(p, 2), v = g[0], m = g[1];
  gA(function() {
    var y = v[0];
    u !== y && d(u, y);
  }, [v]), gA(function() {
    Mb(a) || c(a);
  }, [a]);
  var b = Fd(function(y, x) {
    c(y, x), m([f], x);
  });
  return [h, b];
}
function cs(t, e) {
  for (var r = t, n = 0; n < e.length; n += 1) {
    if (r == null)
      return;
    r = r[e[n]];
  }
  return r;
}
function MX(t) {
  if (Array.isArray(t)) return vE(t);
}
function vO(t) {
  if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
}
function _X() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Ot(t) {
  return MX(t) || vO(t) || OS(t) || _X();
}
function LX(t) {
  return oO(t) || vO(t) || OS(t) || lO();
}
function mO(t, e, r, n) {
  if (!e.length)
    return r;
  var a = LX(e), i = a[0], s = a.slice(1), o;
  return !t && typeof i == "number" ? o = [] : Array.isArray(t) ? o = Ot(t) : o = ke({}, t), n && r === void 0 && s.length === 1 ? delete o[i][s[0]] : o[i] = mO(o[i], s, r, n), o;
}
function Ri(t, e, r) {
  var n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  return e.length && n && r === void 0 && !cs(t, e.slice(0, -1)) ? t : mO(t, e, r, n);
}
function NX(t) {
  return Tt(t) === "object" && t !== null && Object.getPrototypeOf(t) === Object.prototype;
}
function vA(t) {
  return Array.isArray(t) ? [] : {};
}
var OX = typeof Reflect > "u" ? Object.keys : Reflect.ownKeys;
function tc() {
  for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)
    e[r] = arguments[r];
  var n = vA(e[0]);
  return e.forEach(function(a) {
    function i(s, o) {
      var l = new Set(o), u = cs(a, s), c = Array.isArray(u);
      if (c || NX(u)) {
        if (!l.has(u)) {
          l.add(u);
          var f = cs(n, s);
          c ? n = Ri(n, s, []) : (!f || Tt(f) !== "object") && (n = Ri(n, s, vA(u))), OX(u).forEach(function(h) {
            i([].concat(Ot(s), [h]), l);
          });
        }
      } else
        n = Ri(n, s, u);
    }
    i([]);
  }), n;
}
var yE = {}, $S = [], IX = function(e) {
  $S.push(e);
};
function zd(t, e) {
  if (process.env.NODE_ENV !== "production" && !t && console !== void 0) {
    var r = $S.reduce(function(n, a) {
      return a(n ?? "", "warning");
    }, e);
    r && console.error("Warning: ".concat(r));
  }
}
function PX(t, e) {
  if (process.env.NODE_ENV !== "production" && !t && console !== void 0) {
    var r = $S.reduce(function(n, a) {
      return a(n ?? "", "note");
    }, e);
    r && console.warn("Note: ".concat(r));
  }
}
function yO() {
  yE = {};
}
function bO(t, e, r) {
  !e && !yE[r] && (t(!1, r), yE[r] = !0);
}
function qr(t, e) {
  bO(zd, t, e);
}
function DX(t, e) {
  bO(PX, t, e);
}
qr.preMessage = IX;
qr.resetWarned = yO;
qr.noteOnce = DX;
function $X(t) {
  var e = de.useReducer(function(o) {
    return o + 1;
  }, 0), r = bt(e, 2), n = r[1], a = de.useRef(t), i = Fd(function() {
    return a.current;
  }), s = Fd(function(o) {
    a.current = typeof o == "function" ? o(a.current) : o, n();
  });
  return [i, s];
}
var Ao = "none", Ap = "appear", kp = "enter", Rp = "leave", mA = "none", Mi = "prepare", rc = "start", nc = "active", FS = "end", xO = "prepared";
function yA(t, e) {
  var r = {};
  return r[t.toLowerCase()] = e.toLowerCase(), r["Webkit".concat(t)] = "webkit".concat(e), r["Moz".concat(t)] = "moz".concat(e), r["ms".concat(t)] = "MS".concat(e), r["O".concat(t)] = "o".concat(e.toLowerCase()), r;
}
function FX(t, e) {
  var r = {
    animationend: yA("Animation", "AnimationEnd"),
    transitionend: yA("Transition", "TransitionEnd")
  };
  return t && ("AnimationEvent" in e || delete r.animationend.animation, "TransitionEvent" in e || delete r.transitionend.transition), r;
}
var BX = FX(po(), typeof window < "u" ? window : {}), wO = {};
if (po()) {
  var zX = document.createElement("div");
  wO = zX.style;
}
var Mp = {};
function EO(t) {
  if (Mp[t])
    return Mp[t];
  var e = BX[t];
  if (e)
    for (var r = Object.keys(e), n = r.length, a = 0; a < n; a += 1) {
      var i = r[a];
      if (Object.prototype.hasOwnProperty.call(e, i) && i in wO)
        return Mp[t] = e[i], Mp[t];
    }
  return "";
}
var TO = EO("animationend"), SO = EO("transitionend"), CO = !!(TO && SO), bA = TO || "animationend", xA = SO || "transitionend";
function wA(t, e) {
  if (!t) return null;
  if (Tt(t) === "object") {
    var r = e.replace(/-\w/g, function(n) {
      return n[1].toUpperCase();
    });
    return t[r];
  }
  return "".concat(t, "-").concat(e);
}
const GX = function(t) {
  var e = tn();
  function r(a) {
    a && (a.removeEventListener(xA, t), a.removeEventListener(bA, t));
  }
  function n(a) {
    e.current && e.current !== a && r(e.current), a && a !== e.current && (a.addEventListener(xA, t), a.addEventListener(bA, t), e.current = a);
  }
  return de.useEffect(function() {
    return function() {
      r(e.current);
    };
  }, []), [n, r];
};
var AO = po() ? SH : Fi, kO = function(e) {
  return +setTimeout(e, 16);
}, RO = function(e) {
  return clearTimeout(e);
};
typeof window < "u" && "requestAnimationFrame" in window && (kO = function(e) {
  return window.requestAnimationFrame(e);
}, RO = function(e) {
  return window.cancelAnimationFrame(e);
});
var EA = 0, Xy = /* @__PURE__ */ new Map();
function MO(t) {
  Xy.delete(t);
}
var Vc = function(e) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  EA += 1;
  var n = EA;
  function a(i) {
    if (i === 0)
      MO(n), e();
    else {
      var s = kO(function() {
        a(i - 1);
      });
      Xy.set(n, s);
    }
  }
  return a(r), n;
};
Vc.cancel = function(t) {
  var e = Xy.get(t);
  return MO(t), RO(e);
};
process.env.NODE_ENV !== "production" && (Vc.ids = function() {
  return Xy;
});
const UX = function() {
  var t = de.useRef(null);
  function e() {
    Vc.cancel(t.current);
  }
  function r(n) {
    var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
    e();
    var i = Vc(function() {
      a <= 1 ? n({
        isCanceled: function() {
          return i !== t.current;
        }
      }) : r(n, a - 1);
    });
    t.current = i;
  }
  return de.useEffect(function() {
    return function() {
      e();
    };
  }, []), [r, e];
};
var HX = [Mi, rc, nc, FS], VX = [Mi, xO], _O = !1, qX = !0;
function LO(t) {
  return t === nc || t === FS;
}
const WX = function(t, e, r) {
  var n = Bd(mA), a = bt(n, 2), i = a[0], s = a[1], o = UX(), l = bt(o, 2), u = l[0], c = l[1];
  function f() {
    s(Mi, !0);
  }
  var h = e ? VX : HX;
  return AO(function() {
    if (i !== mA && i !== FS) {
      var d = h.indexOf(i), p = h[d + 1], g = r(i);
      g === _O ? s(p, !0) : p && u(function(v) {
        function m() {
          v.isCanceled() || s(p, !0);
        }
        g === !0 ? m() : Promise.resolve(g).then(m);
      });
    }
  }, [t, i]), de.useEffect(function() {
    return function() {
      c();
    };
  }, []), [f, i];
};
function jX(t, e, r, n) {
  var a = n.motionEnter, i = a === void 0 ? !0 : a, s = n.motionAppear, o = s === void 0 ? !0 : s, l = n.motionLeave, u = l === void 0 ? !0 : l, c = n.motionDeadline, f = n.motionLeaveImmediately, h = n.onAppearPrepare, d = n.onEnterPrepare, p = n.onLeavePrepare, g = n.onAppearStart, v = n.onEnterStart, m = n.onLeaveStart, b = n.onAppearActive, y = n.onEnterActive, x = n.onLeaveActive, E = n.onAppearEnd, S = n.onEnterEnd, w = n.onLeaveEnd, C = n.onVisibleChanged, k = Bd(), N = bt(k, 2), R = N[0], _ = N[1], O = $X(Ao), T = bt(O, 2), L = T[0], M = T[1], A = Bd(null), I = bt(A, 2), D = I[0], F = I[1], B = L(), G = tn(!1), H = tn(null);
  function K() {
    return r();
  }
  var j = tn(!1);
  function Z() {
    M(Ao), F(null, !0);
  }
  var te = Fd(function(Ne) {
    var Ie = L();
    if (Ie !== Ao) {
      var Me = K();
      if (!(Ne && !Ne.deadline && Ne.target !== Me)) {
        var _e = j.current, Be;
        Ie === Ap && _e ? Be = E == null ? void 0 : E(Me, Ne) : Ie === kp && _e ? Be = S == null ? void 0 : S(Me, Ne) : Ie === Rp && _e && (Be = w == null ? void 0 : w(Me, Ne)), _e && Be !== !1 && Z();
      }
    }
  }), ne = GX(te), V = bt(ne, 1), q = V[0], X = function(Ie) {
    switch (Ie) {
      case Ap:
        return pe(pe(pe({}, Mi, h), rc, g), nc, b);
      case kp:
        return pe(pe(pe({}, Mi, d), rc, v), nc, y);
      case Rp:
        return pe(pe(pe({}, Mi, p), rc, m), nc, x);
      default:
        return {};
    }
  }, W = de.useMemo(function() {
    return X(B);
  }, [B]), ue = WX(B, !t, function(Ne) {
    if (Ne === Mi) {
      var Ie = W[Mi];
      return Ie ? Ie(K()) : _O;
    }
    if (Ee in W) {
      var Me;
      F(((Me = W[Ee]) === null || Me === void 0 ? void 0 : Me.call(W, K(), null)) || null);
    }
    return Ee === nc && B !== Ao && (q(K()), c > 0 && (clearTimeout(H.current), H.current = setTimeout(function() {
      te({
        deadline: !0
      });
    }, c))), Ee === xO && Z(), qX;
  }), J = bt(ue, 2), Ce = J[0], Ee = J[1], Te = LO(Ee);
  j.current = Te;
  var me = tn(null);
  AO(function() {
    if (!(G.current && me.current === e)) {
      _(e);
      var Ne = G.current;
      G.current = !0;
      var Ie;
      !Ne && e && o && (Ie = Ap), Ne && e && i && (Ie = kp), (Ne && !e && u || !Ne && f && !e && u) && (Ie = Rp);
      var Me = X(Ie);
      Ie && (t || Me[Mi]) ? (M(Ie), Ce()) : M(Ao), me.current = e;
    }
  }, [e]), Fi(function() {
    // Cancel appear
    (B === Ap && !o || // Cancel enter
    B === kp && !i || // Cancel leave
    B === Rp && !u) && M(Ao);
  }, [o, i, u]), Fi(function() {
    return function() {
      G.current = !1, clearTimeout(H.current);
    };
  }, []);
  var we = de.useRef(!1);
  Fi(function() {
    R && (we.current = !0), R !== void 0 && B === Ao && ((we.current || R) && (C == null || C(R)), we.current = !0);
  }, [R, B]);
  var Ae = D;
  return W[Mi] && Ee === rc && (Ae = ke({
    transition: "none"
  }, Ae)), [B, Ee, Ae, R ?? e];
}
function YX(t) {
  var e = t;
  Tt(t) === "object" && (e = t.transitionSupport);
  function r(a, i) {
    return !!(a.motionName && e && i !== !1);
  }
  var n = /* @__PURE__ */ de.forwardRef(function(a, i) {
    var s = a.visible, o = s === void 0 ? !0 : s, l = a.removeOnLeave, u = l === void 0 ? !0 : l, c = a.forceRender, f = a.children, h = a.motionName, d = a.leavedClassName, p = a.eventProps, g = de.useContext(gO), v = g.motion, m = r(a, v), b = tn(), y = tn();
    function x() {
      try {
        return b.current instanceof HTMLElement ? b.current : Vg(y.current);
      } catch {
        return null;
      }
    }
    var E = jX(m, o, x, a), S = bt(E, 4), w = S[0], C = S[1], k = S[2], N = S[3], R = de.useRef(N);
    N && (R.current = !0);
    var _ = de.useCallback(function(I) {
      b.current = I, cO(i, I);
    }, [i]), O, T = ke(ke({}, p), {}, {
      visible: o
    });
    if (!f)
      O = null;
    else if (w === Ao)
      N ? O = f(ke({}, T), _) : !u && R.current && d ? O = f(ke(ke({}, T), {}, {
        className: d
      }), _) : c || !u && !d ? O = f(ke(ke({}, T), {}, {
        style: {
          display: "none"
        }
      }), _) : O = null;
    else {
      var L;
      C === Mi ? L = "prepare" : LO(C) ? L = "active" : C === rc && (L = "start");
      var M = wA(h, "".concat(w, "-").concat(L));
      O = f(ke(ke({}, T), {}, {
        className: fr(wA(h, w), pe(pe({}, M, M && L), h, typeof h == "string")),
        style: k
      }), _);
    }
    if (/* @__PURE__ */ de.isValidElement(O) && hO(O)) {
      var A = pO(O);
      A || (O = /* @__PURE__ */ de.cloneElement(O, {
        ref: _
      }));
    }
    return /* @__PURE__ */ de.createElement(RX, {
      ref: y
    }, O);
  });
  return n.displayName = "CSSMotion", n;
}
const XX = YX(CO);
var bE = "add", xE = "keep", wE = "remove", _b = "removed";
function KX(t) {
  var e;
  return t && Tt(t) === "object" && "key" in t ? e = t : e = {
    key: t
  }, ke(ke({}, e), {}, {
    key: String(e.key)
  });
}
function EE() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  return t.map(KX);
}
function ZX() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], r = [], n = 0, a = e.length, i = EE(t), s = EE(e);
  i.forEach(function(u) {
    for (var c = !1, f = n; f < a; f += 1) {
      var h = s[f];
      if (h.key === u.key) {
        n < f && (r = r.concat(s.slice(n, f).map(function(d) {
          return ke(ke({}, d), {}, {
            status: bE
          });
        })), n = f), r.push(ke(ke({}, h), {}, {
          status: xE
        })), n += 1, c = !0;
        break;
      }
    }
    c || r.push(ke(ke({}, u), {}, {
      status: wE
    }));
  }), n < a && (r = r.concat(s.slice(n).map(function(u) {
    return ke(ke({}, u), {}, {
      status: bE
    });
  })));
  var o = {};
  r.forEach(function(u) {
    var c = u.key;
    o[c] = (o[c] || 0) + 1;
  });
  var l = Object.keys(o).filter(function(u) {
    return o[u] > 1;
  });
  return l.forEach(function(u) {
    r = r.filter(function(c) {
      var f = c.key, h = c.status;
      return f !== u || h !== wE;
    }), r.forEach(function(c) {
      c.key === u && (c.status = xE);
    });
  }), r;
}
var QX = ["component", "children", "onVisibleChanged", "onAllRemoved"], JX = ["status"], eK = ["eventProps", "visible", "children", "motionName", "motionAppear", "motionEnter", "motionLeave", "motionLeaveImmediately", "motionDeadline", "removeOnLeave", "leavedClassName", "onAppearPrepare", "onAppearStart", "onAppearActive", "onAppearEnd", "onEnterStart", "onEnterActive", "onEnterEnd", "onLeaveStart", "onLeaveActive", "onLeaveEnd"];
function tK(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : XX, r = /* @__PURE__ */ function(n) {
    il(i, n);
    var a = sl(i);
    function i() {
      var s;
      Ln(this, i);
      for (var o = arguments.length, l = new Array(o), u = 0; u < o; u++)
        l[u] = arguments[u];
      return s = a.call.apply(a, [this].concat(l)), pe($t(s), "state", {
        keyEntities: []
      }), pe($t(s), "removeKey", function(c) {
        s.setState(function(f) {
          var h = f.keyEntities.map(function(d) {
            return d.key !== c ? d : ke(ke({}, d), {}, {
              status: _b
            });
          });
          return {
            keyEntities: h
          };
        }, function() {
          var f = s.state.keyEntities, h = f.filter(function(d) {
            var p = d.status;
            return p !== _b;
          }).length;
          h === 0 && s.props.onAllRemoved && s.props.onAllRemoved();
        });
      }), s;
    }
    return Nn(i, [{
      key: "render",
      value: function() {
        var o = this, l = this.state.keyEntities, u = this.props, c = u.component, f = u.children, h = u.onVisibleChanged;
        u.onAllRemoved;
        var d = vi(u, QX), p = c || de.Fragment, g = {};
        return eK.forEach(function(v) {
          g[v] = d[v], delete d[v];
        }), delete d.keys, /* @__PURE__ */ de.createElement(p, d, l.map(function(v, m) {
          var b = v.status, y = vi(v, JX), x = b === bE || b === xE;
          return /* @__PURE__ */ de.createElement(e, Ra({}, g, {
            key: y.key,
            visible: x,
            eventProps: y,
            onVisibleChanged: function(S) {
              h == null || h(S, {
                key: y.key
              }), S || o.removeKey(y.key);
            }
          }), function(E, S) {
            return f(ke(ke({}, E), {}, {
              index: m
            }), S);
          });
        }));
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function(o, l) {
        var u = o.keys, c = l.keyEntities, f = EE(u), h = ZX(c, f);
        return {
          keyEntities: h.filter(function(d) {
            var p = c.find(function(g) {
              var v = g.key;
              return d.key === v;
            });
            return !(p && p.status === _b && d.status === wE);
          })
        };
      }
    }]), i;
  }(de.Component);
  return pe(r, "defaultProps", {
    component: "div"
  }), r;
}
tK(CO);
var NO = {}, rK = Kt.default;
Object.defineProperty(NO, "__esModule", {
  value: !0
});
var kMe = NO.default = uK, nK = rK(al), aK = `accept acceptCharset accessKey action allowFullScreen allowTransparency
    alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge
    charSet checked classID className colSpan cols content contentEditable contextMenu
    controls coords crossOrigin data dateTime default defer dir disabled download draggable
    encType form formAction formEncType formMethod formNoValidate formTarget frameBorder
    headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity
    is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media
    mediaGroup method min minLength multiple muted name noValidate nonce open
    optimum pattern placeholder poster preload radioGroup readOnly rel required
    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected
    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style
    summary tabIndex target title type useMap value width wmode wrap`, iK = `onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown
    onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onClick onContextMenu onDoubleClick
    onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown
    onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel
    onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough
    onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata
    onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onError`, sK = "".concat(aK, " ").concat(iK).split(/[\s\n]+/), oK = "aria-", lK = "data-";
function TA(t, e) {
  return t.indexOf(e) === 0;
}
function uK(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r;
  e === !1 ? r = {
    aria: !0,
    data: !0,
    attr: !0
  } : e === !0 ? r = {
    aria: !0
  } : r = (0, nK.default)({}, e);
  var n = {};
  return Object.keys(t).forEach(function(a) {
    // Aria
    (r.aria && (a === "role" || TA(a, oK)) || // Data
    r.data && TA(a, lK) || // Attr
    r.attr && sK.includes(a)) && (n[a] = t[a]);
  }), n;
}
var Ka = {}, BS = {}, OO = { exports: {} };
(function(t) {
  var e = w0.default;
  function r(a) {
    if (typeof WeakMap != "function") return null;
    var i = /* @__PURE__ */ new WeakMap(), s = /* @__PURE__ */ new WeakMap();
    return (r = function(l) {
      return l ? s : i;
    })(a);
  }
  function n(a, i) {
    if (!i && a && a.__esModule) return a;
    if (a === null || e(a) != "object" && typeof a != "function") return {
      default: a
    };
    var s = r(i);
    if (s && s.has(a)) return s.get(a);
    var o = {
      __proto__: null
    }, l = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var u in a) if (u !== "default" && {}.hasOwnProperty.call(a, u)) {
      var c = l ? Object.getOwnPropertyDescriptor(a, u) : null;
      c && (c.get || c.set) ? Object.defineProperty(o, u, c) : o[u] = a[u];
    }
    return o.default = a, s && s.set(a, o), o;
  }
  t.exports = n, t.exports.__esModule = !0, t.exports.default = t.exports;
})(OO);
var Ky = OO.exports, cK = Ky.default;
Object.defineProperty(BS, "__esModule", {
  value: !0
});
BS.default = hK;
var fK = cK(lt);
function hK(t, e, r) {
  var n = fK.useRef({});
  return (!("value" in n.current) || r(n.current.condition, e)) && (n.current.value = t(), n.current.condition = e), n.current.value;
}
var zS = {}, dK = Kt.default;
Object.defineProperty(zS, "__esModule", {
  value: !0
});
zS.default = yK;
var pK = dK(w0), gK = Symbol.for("react.element"), vK = Symbol.for("react.transitional.element"), mK = Symbol.for("react.fragment");
function yK(t) {
  return (
    // Base object type
    t && (0, pK.default)(t) === "object" && // React Element type
    (t.$$typeof === gK || t.$$typeof === vK) && // React Fragment type
    t.type === mK
  );
}
var IO, GS = Kt.default;
Object.defineProperty(Ka, "__esModule", {
  value: !0
});
Ka.useComposeRef = Ka.supportRef = Ka.supportNodeRef = Ka.getNodeRef = Ka.fillRef = IO = Ka.composeRef = void 0;
var bK = GS(w0), PO = lt, Lb = qg, xK = GS(BS), wK = GS(zS), EK = Number(PO.version.split(".")[0]), TK = Ka.fillRef = function(e, r) {
  typeof e == "function" ? e(r) : (0, bK.default)(e) === "object" && e && "current" in e && (e.current = r);
}, SK = IO = Ka.composeRef = function() {
  for (var e = arguments.length, r = new Array(e), n = 0; n < e; n++)
    r[n] = arguments[n];
  var a = r.filter(Boolean);
  return a.length <= 1 ? a[0] : function(i) {
    r.forEach(function(s) {
      TK(s, i);
    });
  };
};
Ka.useComposeRef = function() {
  for (var e = arguments.length, r = new Array(e), n = 0; n < e; n++)
    r[n] = arguments[n];
  return (0, xK.default)(function() {
    return SK.apply(void 0, r);
  }, r, function(a, i) {
    return a.length !== i.length || a.every(function(s, o) {
      return s !== i[o];
    });
  });
};
var CK = Ka.supportRef = function(e) {
  var r, n;
  if (!e)
    return !1;
  if (US(e) && EK >= 19)
    return !0;
  var a = (0, Lb.isMemo)(e) ? e.type.type : e.type;
  return !(typeof a == "function" && !((r = a.prototype) !== null && r !== void 0 && r.render) && a.$$typeof !== Lb.ForwardRef || typeof e == "function" && !((n = e.prototype) !== null && n !== void 0 && n.render) && e.$$typeof !== Lb.ForwardRef);
};
function US(t) {
  return /* @__PURE__ */ (0, PO.isValidElement)(t) && !(0, wK.default)(t);
}
Ka.supportNodeRef = function(e) {
  return US(e) && CK(e);
};
Ka.getNodeRef = function(e) {
  if (e && US(e)) {
    var r = e;
    return r.props.propertyIsEnumerable("ref") ? r.props.ref : r.ref;
  }
  return null;
};
var Ki = {};
Object.defineProperty(Ki, "__esModule", {
  value: !0
});
Ki.call = VS;
var AK = Ki.default = void 0;
Ki.note = $O;
Ki.noteOnce = BO;
Ki.preMessage = void 0;
var RMe = Ki.resetWarned = FO;
Ki.warning = DO;
Ki.warningOnce = P0;
var TE = {}, HS = [], kK = Ki.preMessage = function(e) {
  HS.push(e);
};
function DO(t, e) {
  if (process.env.NODE_ENV !== "production" && !t && console !== void 0) {
    var r = HS.reduce(function(n, a) {
      return a(n ?? "", "warning");
    }, e);
    r && console.error("Warning: ".concat(r));
  }
}
function $O(t, e) {
  if (process.env.NODE_ENV !== "production" && !t && console !== void 0) {
    var r = HS.reduce(function(n, a) {
      return a(n ?? "", "note");
    }, e);
    r && console.warn("Note: ".concat(r));
  }
}
function FO() {
  TE = {};
}
function VS(t, e, r) {
  !e && !TE[r] && (t(!1, r), TE[r] = !0);
}
function P0(t, e) {
  VS(DO, t, e);
}
function BO(t, e) {
  VS($O, t, e);
}
P0.preMessage = kK;
P0.resetWarned = FO;
P0.noteOnce = BO;
AK = Ki.default = P0;
var RK = Sy;
const MMe = /* @__PURE__ */ ho(RK);
function Bi(t) {
  for (var e = 0, r, n = 0, a = t.length; a >= 4; ++n, a -= 4)
    r = t.charCodeAt(n) & 255 | (t.charCodeAt(++n) & 255) << 8 | (t.charCodeAt(++n) & 255) << 16 | (t.charCodeAt(++n) & 255) << 24, r = /* Math.imul(k, m): */
    (r & 65535) * 1540483477 + ((r >>> 16) * 59797 << 16), r ^= /* k >>> r: */
    r >>> 24, e = /* Math.imul(k, m): */
    (r & 65535) * 1540483477 + ((r >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16);
  switch (a) {
    case 3:
      e ^= (t.charCodeAt(n + 2) & 255) << 16;
    case 2:
      e ^= (t.charCodeAt(n + 1) & 255) << 8;
    case 1:
      e ^= t.charCodeAt(n) & 255, e = /* Math.imul(h, m): */
      (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16);
  }
  return e ^= e >>> 13, e = /* Math.imul(h, m): */
  (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16), ((e ^ e >>> 15) >>> 0).toString(36);
}
function D0() {
  return !!(typeof window < "u" && window.document && window.document.createElement);
}
function MK(t, e) {
  if (!t)
    return !1;
  if (t.contains)
    return t.contains(e);
  let r = e;
  for (; r; ) {
    if (r === t)
      return !0;
    r = r.parentNode;
  }
  return !1;
}
const SA = "data-rc-order", CA = "data-rc-priority", _K = "rc-util-key", SE = /* @__PURE__ */ new Map();
function zO({
  mark: t
} = {}) {
  return t ? t.startsWith("data-") ? t : `data-${t}` : _K;
}
function Zy(t) {
  return t.attachTo ? t.attachTo : document.querySelector("head") || document.body;
}
function LK(t) {
  return t === "queue" ? "prependQueue" : t ? "prepend" : "append";
}
function qS(t) {
  return Array.from((SE.get(t) || t).children).filter((e) => e.tagName === "STYLE");
}
function GO(t, e = {}) {
  if (!D0())
    return null;
  const {
    csp: r,
    prepend: n,
    priority: a = 0
  } = e, i = LK(n), s = i === "prependQueue", o = document.createElement("style");
  o.setAttribute(SA, i), s && a && o.setAttribute(CA, `${a}`), r != null && r.nonce && (o.nonce = r == null ? void 0 : r.nonce), o.innerHTML = t;
  const l = Zy(e), {
    firstChild: u
  } = l;
  if (n) {
    if (s) {
      const c = (e.styles || qS(l)).filter((f) => {
        if (!["prepend", "prependQueue"].includes(f.getAttribute(SA)))
          return !1;
        const h = Number(f.getAttribute(CA) || 0);
        return a >= h;
      });
      if (c.length)
        return l.insertBefore(o, c[c.length - 1].nextSibling), o;
    }
    l.insertBefore(o, u);
  } else
    l.appendChild(o);
  return o;
}
function UO(t, e = {}) {
  let {
    styles: r
  } = e;
  return r || (r = qS(Zy(e))), r.find((n) => n.getAttribute(zO(e)) === t);
}
function HO(t, e = {}) {
  const r = UO(t, e);
  r && Zy(e).removeChild(r);
}
function NK(t, e) {
  const r = SE.get(t);
  if (!r || !MK(document, r)) {
    const n = GO("", e), {
      parentNode: a
    } = n;
    SE.set(t, a), t.removeChild(n);
  }
}
function vd(t, e, r = {}) {
  var l, u, c;
  const n = Zy(r), a = qS(n), i = {
    ...r,
    styles: a
  };
  NK(n, i);
  const s = UO(e, i);
  if (s)
    return (l = i.csp) != null && l.nonce && s.nonce !== ((u = i.csp) == null ? void 0 : u.nonce) && (s.nonce = (c = i.csp) == null ? void 0 : c.nonce), s.innerHTML !== t && (s.innerHTML = t), s;
  const o = GO(t, i);
  return o.setAttribute(zO(i), e), o;
}
let CE = {};
const WS = [], OK = (t) => {
  WS.push(t);
};
function VO(t, e) {
  if (process.env.NODE_ENV !== "production" && !t && console !== void 0) {
    const r = WS.reduce((n, a) => a(n ?? "", "warning"), e);
    r && console.error(`Warning: ${r}`);
  }
}
function IK(t, e) {
  if (process.env.NODE_ENV !== "production" && !t && console !== void 0) {
    const r = WS.reduce((n, a) => a(n ?? "", "note"), e);
    r && console.warn(`Note: ${r}`);
  }
}
function PK() {
  CE = {};
}
function qO(t, e, r) {
  !e && !CE[r] && (t(!1, r), CE[r] = !0);
}
function $0(t, e) {
  qO(VO, t, e);
}
function DK(t, e) {
  qO(IK, t, e);
}
$0.preMessage = OK;
$0.resetWarned = PK;
$0.noteOnce = DK;
const $K = "%";
function AE(t) {
  return t.join($K);
}
let AA = 0, FK = class {
  constructor(e) {
    Ye(this, "instanceId");
    /** @private Internal cache map. Do not access this directly */
    Ye(this, "cache", /* @__PURE__ */ new Map());
    /** @private Record update times for each key */
    Ye(this, "updateTimes", /* @__PURE__ */ new Map());
    Ye(this, "extracted", /* @__PURE__ */ new Set());
    this.instanceId = e;
  }
  get(e) {
    return this.opGet(AE(e));
  }
  /** A fast get cache with `get` concat. */
  opGet(e) {
    return this.cache.get(e) || null;
  }
  update(e, r) {
    return this.opUpdate(AE(e), r);
  }
  /** A fast get cache with `get` concat. */
  opUpdate(e, r) {
    const n = this.cache.get(e), a = r(n);
    a === null ? (this.cache.delete(e), this.updateTimes.delete(e)) : (this.cache.set(e, a), this.updateTimes.set(e, AA), AA += 1);
  }
};
const jS = "data-token-hash", Ks = "data-css-hash", BK = "data-cache-path", _o = "__cssinjs_instance__";
function zK() {
  const t = Math.random().toString(12).slice(2);
  if (typeof document < "u" && document.head && document.body) {
    const e = document.body.querySelectorAll(`style[${Ks}]`) || [], {
      firstChild: r
    } = document.head;
    Array.from(e).forEach((a) => {
      a[_o] = a[_o] || t, a[_o] === t && document.head.insertBefore(a, r);
    });
    const n = {};
    Array.from(document.querySelectorAll(`style[${Ks}]`)).forEach((a) => {
      var s;
      const i = a.getAttribute(Ks);
      n[i] ? a[_o] === t && ((s = a.parentNode) == null || s.removeChild(a)) : n[i] = !0;
    });
  }
  return new FK(t);
}
const Qy = /* @__PURE__ */ de.createContext({
  hashPriority: "low",
  cache: zK(),
  defaultCache: !0,
  autoPrefix: !1
});
function GK(t, e) {
  if (t.length !== e.length)
    return !1;
  for (let r = 0; r < t.length; r++)
    if (t[r] !== e[r])
      return !1;
  return !0;
}
var Us;
let UK = (Us = class {
  constructor() {
    Ye(this, "cache");
    Ye(this, "keys");
    Ye(this, "cacheCallTimes");
    this.cache = /* @__PURE__ */ new Map(), this.keys = [], this.cacheCallTimes = 0;
  }
  size() {
    return this.keys.length;
  }
  internalGet(e, r = !1) {
    let n = {
      map: this.cache
    };
    return e.forEach((a) => {
      var i;
      n ? n = (i = n == null ? void 0 : n.map) == null ? void 0 : i.get(a) : n = void 0;
    }), n != null && n.value && r && (n.value[1] = this.cacheCallTimes++), n == null ? void 0 : n.value;
  }
  get(e) {
    var r;
    return (r = this.internalGet(e, !0)) == null ? void 0 : r[0];
  }
  has(e) {
    return !!this.internalGet(e);
  }
  set(e, r) {
    if (!this.has(e)) {
      if (this.size() + 1 > Us.MAX_CACHE_SIZE + Us.MAX_CACHE_OFFSET) {
        const [a] = this.keys.reduce((i, s) => {
          const [, o] = i;
          return this.internalGet(s)[1] < o ? [s, this.internalGet(s)[1]] : i;
        }, [this.keys[0], this.cacheCallTimes]);
        this.delete(a);
      }
      this.keys.push(e);
    }
    let n = this.cache;
    e.forEach((a, i) => {
      if (i === e.length - 1)
        n.set(a, {
          value: [r, this.cacheCallTimes++]
        });
      else {
        const s = n.get(a);
        s ? s.map || (s.map = /* @__PURE__ */ new Map()) : n.set(a, {
          map: /* @__PURE__ */ new Map()
        }), n = n.get(a).map;
      }
    });
  }
  deleteByPath(e, r) {
    var i;
    const n = e.get(r[0]);
    if (r.length === 1)
      return n.map ? e.set(r[0], {
        map: n.map
      }) : e.delete(r[0]), (i = n.value) == null ? void 0 : i[0];
    const a = this.deleteByPath(n.map, r.slice(1));
    return (!n.map || n.map.size === 0) && !n.value && e.delete(r[0]), a;
  }
  delete(e) {
    if (this.has(e))
      return this.keys = this.keys.filter((r) => !GK(r, e)), this.deleteByPath(this.cache, e);
  }
}, Ye(Us, "MAX_CACHE_SIZE", 20), Ye(Us, "MAX_CACHE_OFFSET", 5), Us), kA = 0, WO = class {
  constructor(e) {
    Ye(this, "derivatives");
    Ye(this, "id");
    this.derivatives = Array.isArray(e) ? e : [e], this.id = kA, e.length === 0 && VO(e.length > 0, "[Ant Design CSS-in-JS] Theme should have at least one derivative function."), kA += 1;
  }
  getDerivativeToken(e) {
    return this.derivatives.reduce((r, n) => n(e, r), void 0);
  }
};
const Nb = new UK();
function NMe(t) {
  const e = Array.isArray(t) ? t : [t];
  return Nb.has(e) || Nb.set(e, new WO(e)), Nb.get(e);
}
const HK = /* @__PURE__ */ new WeakMap(), Ob = {};
function VK(t, e) {
  let r = HK;
  for (let n = 0; n < e.length; n += 1) {
    const a = e[n];
    r.has(a) || r.set(a, /* @__PURE__ */ new WeakMap()), r = r.get(a);
  }
  return r.has(Ob) || r.set(Ob, t()), r.get(Ob);
}
const RA = /* @__PURE__ */ new WeakMap();
function md(t) {
  let e = RA.get(t) || "";
  return e || (Object.keys(t).forEach((r) => {
    const n = t[r];
    e += r, n instanceof WO ? e += n.id : n && typeof n == "object" ? e += md(n) : e += n;
  }), e = Bi(e), RA.set(t, e)), e;
}
function qK(t, e) {
  return Bi(`${e}_${md(t)}`);
}
const kE = D0();
function MA(t) {
  return typeof t == "number" ? `${t}px` : t;
}
function WK(t) {
  const {
    hashCls: e,
    hashPriority: r = "low"
  } = t || {};
  if (!e)
    return "";
  const n = `.${e}`;
  return r === "low" ? `:where(${n})` : n;
}
const Wg = (t, e = "") => `--${e ? `${e}-` : ""}${t}`.replace(/([a-z0-9])([A-Z])/g, "$1-$2").replace(/([A-Z]+)([A-Z][a-z0-9]+)/g, "$1-$2").replace(/([a-z])([A-Z0-9])/g, "$1-$2").toLowerCase(), jK = (t, e, r) => {
  const {
    hashCls: n,
    hashPriority: a = "low"
  } = r || {};
  return Object.keys(t).length ? `${WK({
    hashCls: n,
    hashPriority: a
  })}.${e}${r != null && r.scope ? `.${r.scope}` : ""}{${Object.entries(t).map(([i, s]) => `${i}:${s};`).join("")}}` : "";
}, jO = (t, e, r) => {
  const {
    hashCls: n,
    hashPriority: a = "low",
    prefix: i,
    unitless: s,
    ignore: o,
    preserve: l
  } = r || {}, u = {}, c = {};
  return Object.entries(t).forEach(([f, h]) => {
    if (l != null && l[f])
      c[f] = h;
    else if ((typeof h == "string" || typeof h == "number") && !(o != null && o[f])) {
      const d = Wg(f, i);
      u[d] = typeof h == "number" && !(s != null && s[f]) ? `${h}px` : String(h), c[f] = `var(${d})`;
    }
  }), [c, jK(u, e, {
    scope: r == null ? void 0 : r.scope,
    hashCls: n,
    hashPriority: a
  })];
};
function YK() {
  return !1;
}
let RE = !1;
function XK() {
  return RE;
}
const KK = process.env.NODE_ENV === "production" ? YK : XK;
if (process.env.NODE_ENV !== "production" && typeof module < "u" && module && module.hot && typeof window < "u") {
  const t = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : null;
  if (t && typeof t.webpackHotUpdate == "function") {
    const e = t.webpackHotUpdate;
    t.webpackHotUpdate = (...r) => (RE = !0, setTimeout(() => {
      RE = !1;
    }, 0), e(...r));
  }
}
const _p = /* @__PURE__ */ new Map();
function YS(t, e, r, n, a) {
  const {
    cache: i
  } = de.useContext(Qy), s = [t, ...e], o = AE(s), l = KK(), u = (h) => {
    i.opUpdate(o, (d) => {
      const [p = 0, g] = d || [void 0, void 0];
      let v = g;
      process.env.NODE_ENV !== "production" && g && l && (n == null || n(v, l), v = null);
      const m = v || r(), b = [p, m];
      return h ? h(b) : b;
    });
  };
  de.useMemo(
    () => {
      u();
    },
    /* eslint-disable react-hooks/exhaustive-deps */
    [o]
    /* eslint-enable */
  );
  let c = i.opGet(o);
  process.env.NODE_ENV !== "production" && !c && (u(), c = i.opGet(o));
  const f = c[1];
  return CH(() => (u(([h, d]) => [h + 1, d]), _p.has(o) || (a == null || a(f), _p.set(o, !0), Promise.resolve().then(() => {
    _p.delete(o);
  })), () => {
    i.opUpdate(o, (h) => {
      const [d = 0, p] = h || [];
      return d - 1 === 0 ? (n == null || n(p, !1), _p.delete(o), null) : [d - 1, p];
    });
  }), [o]), f;
}
const ZK = {}, QK = process.env.NODE_ENV !== "production" ? "css-dev-only-do-not-override" : "css", Il = /* @__PURE__ */ new Map();
function JK(t) {
  Il.set(t, (Il.get(t) || 0) + 1);
}
function eZ(t, e) {
  typeof document < "u" && document.querySelectorAll(`style[${jS}="${t}"]`).forEach((n) => {
    var a;
    n[_o] === e && ((a = n.parentNode) == null || a.removeChild(n));
  });
}
const tZ = -1;
function rZ(t, e) {
  Il.set(t, (Il.get(t) || 0) - 1);
  const r = /* @__PURE__ */ new Set();
  Il.forEach((n, a) => {
    n <= 0 && r.add(a);
  }), Il.size - r.size > tZ && r.forEach((n) => {
    eZ(n, e), Il.delete(n);
  });
}
const nZ = (t, e, r, n) => {
  let i = {
    ...r.getDerivativeToken(t),
    ...e
  };
  return n && (i = n(i)), i;
}, aZ = "token";
function OMe(t, e, r) {
  const {
    cache: {
      instanceId: n
    },
    container: a,
    hashPriority: i
  } = qi(Qy), {
    salt: s = "",
    override: o = ZK,
    formatToken: l,
    getComputedToken: u,
    cssVar: c
  } = r, f = VK(() => Object.assign({}, ...e), e), h = md(f), d = md(o), p = md(c);
  return YS(aZ, [s, t.id, h, d, p], () => {
    const v = u ? u(f, o, t) : nZ(f, o, t, l), m = {
      ...v
    }, b = `${s}_${c.prefix}`, y = Bi(b), x = `${QK}-${Bi(b)}`;
    m._tokenKey = qK(m, b);
    const [E, S] = jO(v, c.key, {
      prefix: c.prefix,
      ignore: c.ignore,
      unitless: c.unitless,
      preserve: c.preserve,
      hashPriority: i,
      hashCls: c.hashed ? x : void 0
    });
    return E._hashId = y, JK(c.key), [E, x, m, S, c.key];
  }, ([, , , , v]) => {
    rZ(v, n);
  }, ([, , , v, m]) => {
    if (!v)
      return;
    const b = vd(v, Bi(`css-var-${m}`), {
      mark: Ks,
      prepend: "queue",
      attachTo: a,
      priority: -999
    });
    b[_o] = n, b.setAttribute(jS, m);
  });
}
var YO = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, Nr = "-ms-", yd = "-moz-", sr = "-webkit-", XO = "comm", XS = "rule", KS = "decl", iZ = "@import", sZ = "@namespace", KO = "@keyframes", oZ = "@layer", ZO = Math.abs, ZS = String.fromCharCode, ME = Object.assign;
function lZ(t, e) {
  return gn(t, 0) ^ 45 ? (((e << 2 ^ gn(t, 0)) << 2 ^ gn(t, 1)) << 2 ^ gn(t, 2)) << 2 ^ gn(t, 3) : 0;
}
function QO(t) {
  return t.trim();
}
function Ps(t, e) {
  return (t = e.exec(t)) ? t[0] : t;
}
function zt(t, e, r) {
  return t.replace(e, r);
}
function jg(t, e, r) {
  return t.indexOf(e, r);
}
function gn(t, e) {
  return t.charCodeAt(e) | 0;
}
function Xl(t, e, r) {
  return t.slice(e, r);
}
function _i(t) {
  return t.length;
}
function JO(t) {
  return t.length;
}
function xh(t, e) {
  return e.push(t), t;
}
function uZ(t, e) {
  return t.map(e).join("");
}
function _A(t, e) {
  return t.filter(function(r) {
    return !Ps(r, e);
  });
}
var Jy = 1, qc = 1, eI = 0, mi = 0, cn = 0, bf = "";
function e1(t, e, r, n, a, i, s, o) {
  return { value: t, root: e, parent: r, type: n, props: a, children: i, line: Jy, column: qc, length: s, return: "", siblings: o };
}
function ko(t, e) {
  return ME(e1("", null, null, "", null, null, 0, t.siblings), t, { length: -t.length }, e);
}
function Du(t) {
  for (; t.root; )
    t = ko(t.root, { children: [t] });
  xh(t, t.siblings);
}
function cZ() {
  return cn;
}
function fZ() {
  return cn = mi > 0 ? gn(bf, --mi) : 0, qc--, cn === 10 && (qc = 1, Jy--), cn;
}
function zi() {
  return cn = mi < eI ? gn(bf, mi++) : 0, qc++, cn === 10 && (qc = 1, Jy++), cn;
}
function Lo() {
  return gn(bf, mi);
}
function Yg() {
  return mi;
}
function t1(t, e) {
  return Xl(bf, t, e);
}
function Gd(t) {
  switch (t) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function hZ(t) {
  return Jy = qc = 1, eI = _i(bf = t), mi = 0, [];
}
function dZ(t) {
  return bf = "", t;
}
function Ib(t) {
  return QO(t1(mi - 1, _E(t === 91 ? t + 2 : t === 40 ? t + 1 : t)));
}
function pZ(t) {
  for (; (cn = Lo()) && cn < 33; )
    zi();
  return Gd(t) > 2 || Gd(cn) > 3 ? "" : " ";
}
function gZ(t, e) {
  for (; --e && zi() && !(cn < 48 || cn > 102 || cn > 57 && cn < 65 || cn > 70 && cn < 97); )
    ;
  return t1(t, Yg() + (e < 6 && Lo() == 32 && zi() == 32));
}
function _E(t) {
  for (; zi(); )
    switch (cn) {
      case t:
        return mi;
      case 34:
      case 39:
        t !== 34 && t !== 39 && _E(cn);
        break;
      case 40:
        t === 41 && _E(t);
        break;
      case 92:
        zi();
        break;
    }
  return mi;
}
function vZ(t, e) {
  for (; zi() && t + cn !== 57; )
    if (t + cn === 84 && Lo() === 47)
      break;
  return "/*" + t1(e, mi - 1) + "*" + ZS(t === 47 ? t : zi());
}
function mZ(t) {
  for (; !Gd(Lo()); )
    zi();
  return t1(t, mi);
}
function LE(t) {
  return dZ(Xg("", null, null, null, [""], t = hZ(t), 0, [0], t));
}
function Xg(t, e, r, n, a, i, s, o, l) {
  for (var u = 0, c = 0, f = s, h = 0, d = 0, p = 0, g = 1, v = 1, m = 1, b = 0, y = "", x = a, E = i, S = n, w = y; v; )
    switch (p = b, b = zi()) {
      case 40:
        if (p != 108 && gn(w, f - 1) == 58) {
          jg(w += zt(Ib(b), "&", "&\f"), "&\f", ZO(u ? o[u - 1] : 0)) != -1 && (m = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        w += Ib(b);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        w += pZ(p);
        break;
      case 92:
        w += gZ(Yg() - 1, 7);
        continue;
      case 47:
        switch (Lo()) {
          case 42:
          case 47:
            xh(yZ(vZ(zi(), Yg()), e, r, l), l), (Gd(p || 1) == 5 || Gd(Lo() || 1) == 5) && _i(w) && Xl(w, -1, void 0) !== " " && (w += " ");
            break;
          default:
            w += "/";
        }
        break;
      case 123 * g:
        o[u++] = _i(w) * m;
      case 125 * g:
      case 59:
      case 0:
        switch (b) {
          case 0:
          case 125:
            v = 0;
          case 59 + c:
            m == -1 && (w = zt(w, /\f/g, "")), d > 0 && (_i(w) - f || g === 0 && p === 47) && xh(d > 32 ? NA(w + ";", n, r, f - 1, l) : NA(zt(w, " ", "") + ";", n, r, f - 2, l), l);
            break;
          case 59:
            w += ";";
          default:
            if (xh(S = LA(w, e, r, u, c, a, o, y, x = [], E = [], f, i), i), b === 123)
              if (c === 0)
                Xg(w, e, S, S, x, i, f, o, E);
              else {
                switch (h) {
                  case 99:
                    if (gn(w, 3) === 110) break;
                  case 108:
                    if (gn(w, 2) === 97) break;
                  default:
                    c = 0;
                  case 100:
                  case 109:
                  case 115:
                }
                c ? Xg(t, S, S, n && xh(LA(t, S, S, 0, 0, a, o, y, a, x = [], f, E), E), a, E, f, o, n ? x : E) : Xg(w, S, S, S, [""], E, 0, o, E);
              }
        }
        u = c = d = 0, g = m = 1, y = w = "", f = s;
        break;
      case 58:
        f = 1 + _i(w), d = p;
      default:
        if (g < 1) {
          if (b == 123)
            --g;
          else if (b == 125 && g++ == 0 && fZ() == 125)
            continue;
        }
        switch (w += ZS(b), b * g) {
          case 38:
            m = c > 0 ? 1 : (w += "\f", -1);
            break;
          case 44:
            o[u++] = (_i(w) - 1) * m, m = 1;
            break;
          case 64:
            Lo() === 45 && (w += Ib(zi())), h = Lo(), c = f = _i(y = w += mZ(Yg())), b++;
            break;
          case 45:
            p === 45 && _i(w) == 2 && (g = 0);
        }
    }
  return i;
}
function LA(t, e, r, n, a, i, s, o, l, u, c, f) {
  for (var h = a - 1, d = a === 0 ? i : [""], p = JO(d), g = 0, v = 0, m = 0; g < n; ++g)
    for (var b = 0, y = Xl(t, h + 1, h = ZO(v = s[g])), x = t; b < p; ++b)
      (x = QO(v > 0 ? d[b] + " " + y : zt(y, /&\f/g, d[b]))) && (l[m++] = x);
  return e1(t, e, r, a === 0 ? XS : o, l, u, c, f);
}
function yZ(t, e, r, n) {
  return e1(t, e, r, XO, ZS(cZ()), Xl(t, 2, -2), 0, n);
}
function NA(t, e, r, n, a) {
  return e1(t, e, r, KS, Xl(t, 0, n), Xl(t, n + 1, -1), n, a);
}
function tI(t, e, r) {
  switch (lZ(t, e)) {
    case 5103:
      return sr + "print-" + t + t;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
      return sr + t + t;
    case 4855:
      return sr + t.replace("add", "source-over").replace("substract", "source-out").replace("intersect", "source-in").replace("exclude", "xor") + t;
    case 4789:
      return yd + t + t;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return sr + t + yd + t + Nr + t + t;
    case 5936:
      switch (gn(t, e + 11)) {
        case 114:
          return sr + t + Nr + zt(t, /[svh]\w+-[tblr]{2}/, "tb") + t;
        case 108:
          return sr + t + Nr + zt(t, /[svh]\w+-[tblr]{2}/, "tb-rl") + t;
        case 45:
          return sr + t + Nr + zt(t, /[svh]\w+-[tblr]{2}/, "lr") + t;
      }
    case 6828:
    case 4268:
    case 2903:
      return sr + t + Nr + t + t;
    case 6165:
      return sr + t + Nr + "flex-" + t + t;
    case 5187:
      return sr + t + zt(t, /(\w+).+(:[^]+)/, sr + "box-$1$2" + Nr + "flex-$1$2") + t;
    case 5443:
      return sr + t + Nr + "flex-item-" + zt(t, /flex-|-self/g, "") + (Ps(t, /flex-|baseline/) ? "" : Nr + "grid-row-" + zt(t, /flex-|-self/g, "")) + t;
    case 4675:
      return sr + t + Nr + "flex-line-pack" + zt(t, /align-content|flex-|-self/g, "") + t;
    case 5548:
      return sr + t + Nr + zt(t, "shrink", "negative") + t;
    case 5292:
      return sr + t + Nr + zt(t, "basis", "preferred-size") + t;
    case 6060:
      return sr + "box-" + zt(t, "-grow", "") + sr + t + Nr + zt(t, "grow", "positive") + t;
    case 4554:
      return sr + zt(t, /([^-])(transform)/g, "$1" + sr + "$2") + t;
    case 6187:
      return zt(zt(zt(t, /(zoom-|grab)/, sr + "$1"), /(image-set)/, sr + "$1"), t, "") + t;
    case 5495:
    case 3959:
      return zt(t, /(image-set\([^]*)/, sr + "$1$`$1");
    case 4968:
      return zt(zt(t, /(.+:)(flex-)?(.*)/, sr + "box-pack:$3" + Nr + "flex-pack:$3"), /space-between/, "justify") + sr + t + t;
    case 4200:
      if (!Ps(t, /flex-|baseline/)) return Nr + "grid-column-align" + Xl(t, e) + t;
      break;
    case 2592:
    case 3360:
      return Nr + zt(t, "template-", "") + t;
    case 4384:
    case 3616:
      return r && r.some(function(n, a) {
        return e = a, Ps(n.props, /grid-\w+-end/);
      }) ? ~jg(t + (r = r[e].value), "span", 0) ? t : Nr + zt(t, "-start", "") + t + Nr + "grid-row-span:" + (~jg(r, "span", 0) ? Ps(r, /\d+/) : +Ps(r, /\d+/) - +Ps(t, /\d+/)) + ";" : Nr + zt(t, "-start", "") + t;
    case 4896:
    case 4128:
      return r && r.some(function(n) {
        return Ps(n.props, /grid-\w+-start/);
      }) ? t : Nr + zt(zt(t, "-end", "-span"), "span ", "") + t;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return zt(t, /(.+)-inline(.+)/, sr + "$1$2") + t;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (_i(t) - 1 - e > 6)
        switch (gn(t, e + 1)) {
          case 109:
            if (gn(t, e + 4) !== 45)
              break;
          case 102:
            return zt(t, /(.+:)(.+)-([^]+)/, "$1" + sr + "$2-$3$1" + yd + (gn(t, e + 3) == 108 ? "$3" : "$2-$3")) + t;
          case 115:
            return ~jg(t, "stretch", 0) ? tI(zt(t, "stretch", "fill-available"), e, r) + t : t;
        }
      break;
    case 5152:
    case 5920:
      return zt(t, /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/, function(n, a, i, s, o, l, u) {
        return Nr + a + ":" + i + u + (s ? Nr + a + "-span:" + (o ? l : +l - +i) + u : "") + t;
      });
    case 4949:
      if (gn(t, e + 6) === 121)
        return zt(t, ":", ":" + sr) + t;
      break;
    case 6444:
      switch (gn(t, gn(t, 14) === 45 ? 18 : 11)) {
        case 120:
          return zt(t, /(.+:)([^;\s!]+)(;|(\s+)?!.+)?/, "$1" + sr + (gn(t, 14) === 45 ? "inline-" : "") + "box$3$1" + sr + "$2$3$1" + Nr + "$2box$3") + t;
        case 100:
          return zt(t, ":", ":" + Nr) + t;
      }
      break;
    case 5719:
    case 2647:
    case 2135:
    case 3927:
    case 2391:
      return zt(t, "scroll-", "scroll-snap-") + t;
  }
  return t;
}
function Wc(t, e) {
  for (var r = "", n = 0; n < t.length; n++)
    r += e(t[n], n, t, e) || "";
  return r;
}
function NE(t, e, r, n) {
  switch (t.type) {
    case oZ:
      if (t.children.length) break;
    case iZ:
    case sZ:
    case KS:
      return t.return = t.return || t.value;
    case XO:
      return "";
    case KO:
      return t.return = t.value + "{" + Wc(t.children, n) + "}";
    case XS:
      if (!_i(t.value = t.props.join(","))) return "";
  }
  return _i(r = Wc(t.children, n)) ? t.return = t.value + "{" + r + "}" : "";
}
function bZ(t) {
  var e = JO(t);
  return function(r, n, a, i) {
    for (var s = "", o = 0; o < e; o++)
      s += t[o](r, n, a, i) || "";
    return s;
  };
}
function xZ(t, e, r, n) {
  if (t.length > -1 && !t.return)
    switch (t.type) {
      case KS:
        t.return = tI(t.value, t.length, r);
        return;
      case KO:
        return Wc([ko(t, { value: zt(t.value, "@", "@" + sr) })], n);
      case XS:
        if (t.length)
          return uZ(r = t.props, function(a) {
            switch (Ps(a, n = /(::plac\w+|:read-\w+)/)) {
              case ":read-only":
              case ":read-write":
                Du(ko(t, { props: [zt(a, /:(read-\w+)/, ":" + yd + "$1")] })), Du(ko(t, { props: [a] })), ME(t, { props: _A(r, n) });
                break;
              case "::placeholder":
                Du(ko(t, { props: [zt(a, /:(plac\w+)/, ":" + sr + "input-$1")] })), Du(ko(t, { props: [zt(a, /:(plac\w+)/, ":" + yd + "$1")] })), Du(ko(t, { props: [zt(a, /:(plac\w+)/, Nr + "input-$1")] })), Du(ko(t, { props: [a] })), ME(t, { props: _A(r, n) });
                break;
            }
            return "";
          });
    }
}
function rI(t, e) {
  const {
    path: r,
    parentSelectors: n
  } = e;
  $0(!1, `[Ant Design CSS-in-JS] ${r ? `Error in ${r}: ` : ""}${t}${n.length ? ` Selector: ${n.join(" | ")}` : ""}`);
}
const wZ = (t, e, r) => {
  if (t === "content") {
    const n = /(attr|counters?|url|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/;
    (typeof e != "string" || ["normal", "none", "initial", "inherit", "unset"].indexOf(e) === -1 && !n.test(e) && !e.startsWith("var(") && (e.charAt(0) !== e.charAt(e.length - 1) || e.charAt(0) !== '"' && e.charAt(0) !== "'")) && rI(`You seem to be using a value for 'content' without quotes, try replacing it with \`content: '"${e}"'\`.`, r);
  }
}, EZ = (t, e, r) => {
  t === "animation" && r.hashId && e !== "none" && rI(`You seem to be using hashed animation '${e}', in which case 'animationName' with Keyframe as value is recommended.`, r);
}, OA = "data-ant-cssinjs-cache-path", nI = "_FILE_STYLE__";
let Vl, aI = !0;
function TZ() {
  var t;
  if (!Vl && (Vl = {}, D0())) {
    const e = document.createElement("div");
    e.className = OA, e.style.position = "fixed", e.style.visibility = "hidden", e.style.top = "-9999px", document.body.appendChild(e);
    let r = getComputedStyle(e).content || "";
    r = r.replace(/^"/, "").replace(/"$/, ""), r.split(";").forEach((a) => {
      const [i, s] = a.split(":");
      Vl[i] = s;
    });
    const n = document.querySelector(`style[${OA}]`);
    n && (aI = !1, (t = n.parentNode) == null || t.removeChild(n)), document.body.removeChild(e);
  }
}
function SZ(t) {
  return TZ(), !!Vl[t];
}
function CZ(t) {
  const e = Vl[t];
  let r = null;
  if (e && D0())
    if (aI)
      r = nI;
    else {
      const n = document.querySelector(`style[${Ks}="${Vl[t]}"]`);
      n ? r = n.innerHTML : delete Vl[t];
    }
  return [r, e];
}
const iI = "_skip_check_", sI = "_multi_value_";
function Pb(t, e) {
  return (e ? Wc(LE(t), bZ([xZ, NE])) : Wc(LE(t), NE)).replace(/\{%%%\:[^;];}/g, ";");
}
function AZ(t) {
  return typeof t == "object" && t && (iI in t || sI in t);
}
function IA(t, e, r) {
  if (!e)
    return t;
  const n = `.${e}`, a = r === "low" ? `:where(${n})` : n;
  return t.split(",").map((s) => {
    var c;
    const o = s.trim().split(/\s+/);
    let l = o[0] || "";
    const u = ((c = l.match(/^\w+/)) == null ? void 0 : c[0]) || "";
    return l = `${u}${a}${l.slice(u.length)}`, [l, ...o.slice(1)].join(" ");
  }).join(",");
}
const OE = (t, e = {}, {
  root: r,
  injectHash: n,
  parentSelectors: a
} = {
  root: !0,
  parentSelectors: []
}) => {
  const {
    hashId: i,
    layer: s,
    path: o,
    hashPriority: l,
    transformers: u = [],
    linters: c = []
  } = e;
  let f = "", h = {};
  function d(v) {
    const m = v.getName(i);
    if (!h[m]) {
      const [b] = OE(v.style, e, {
        root: !1,
        parentSelectors: a
      });
      h[m] = `@keyframes ${v.getName(i)}${b}`;
    }
  }
  function p(v, m = []) {
    return v.forEach((b) => {
      Array.isArray(b) ? p(b, m) : b && m.push(b);
    }), m;
  }
  return p(Array.isArray(t) ? t : [t]).forEach((v) => {
    const m = typeof v == "string" && !r ? {} : v;
    if (typeof m == "string")
      f += `${m}
`;
    else if (m._keyframe)
      d(m);
    else {
      const b = u.reduce((y, x) => {
        var E;
        return ((E = x == null ? void 0 : x.visit) == null ? void 0 : E.call(x, y)) || y;
      }, m);
      Object.keys(b).forEach((y) => {
        const x = b[y];
        if (typeof x == "object" && x && (y !== "animationName" || !x._keyframe) && !AZ(x)) {
          let E = !1, S = y.trim(), w = !1;
          (r || n) && i ? S.startsWith("@") ? E = !0 : S === "&" ? S = IA("", i, l) : S = IA(y, i, l) : r && !i && (S === "&" || S === "") && (S = "", w = !0);
          const [C, k] = OE(x, e, {
            root: w,
            injectHash: E,
            parentSelectors: [...a, S]
          });
          h = {
            ...h,
            ...k
          }, f += `${S}${C}`;
        } else {
          let E = function(w, C) {
            process.env.NODE_ENV !== "production" && (typeof x != "object" || !(x != null && x[iI])) && [wZ, EZ, ...c].forEach((R) => R(w, C, {
              path: o,
              hashId: i,
              parentSelectors: a
            }));
            const k = w.replace(/[A-Z]/g, (R) => `-${R.toLowerCase()}`);
            let N = C;
            !YO[w] && typeof N == "number" && N !== 0 && (N = `${N}px`), w === "animationName" && (C != null && C._keyframe) && (d(C), N = C.getName(i)), f += `${k}:${N};`;
          };
          const S = (x == null ? void 0 : x.value) ?? x;
          typeof x == "object" && (x != null && x[sI]) && Array.isArray(S) ? S.forEach((w) => {
            E(y, w);
          }) : E(y, S);
        }
      });
    }
  }), r ? s && (f && (f = `@layer ${s.name} {${f}}`), s.dependencies && (h[`@layer ${s.name}`] = s.dependencies.map((v) => `@layer ${v}, ${s.name};`).join(`
`))) : f = `{${f}}`, [f, h];
};
function oI(t, e) {
  return Bi(`${t.join("%")}${e}`);
}
const kZ = "style";
function PA(t, e) {
  const {
    path: r,
    hashId: n,
    layer: a,
    nonce: i,
    clientOnly: s,
    order: o = 0
  } = t, {
    mock: l,
    hashPriority: u,
    container: c,
    transformers: f,
    linters: h,
    cache: d,
    layer: p,
    autoPrefix: g
  } = de.useContext(Qy), v = [n || ""];
  p && v.push("layer"), v.push(...r);
  let m = kE;
  process.env.NODE_ENV !== "production" && l !== void 0 && (m = l === "client"), YS(
    kZ,
    v,
    // Create cache if needed
    () => {
      const b = v.join("|");
      if (SZ(b)) {
        const [C, k] = CZ(b);
        if (C)
          return [C, k, {}, s, o];
      }
      const y = e(), [x, E] = OE(y, {
        hashId: n,
        hashPriority: u,
        layer: p ? a : void 0,
        path: r.join("-"),
        transformers: f,
        linters: h
      }), S = Pb(x, g || !1), w = oI(v, S);
      return [S, w, E, s, o];
    },
    // Remove cache if no need
    (b, y) => {
      const [, x] = b;
      y && kE && HO(x, {
        mark: Ks,
        attachTo: c
      });
    },
    // Effect: Inject style here
    (b) => {
      const [y, x, E, , S] = b;
      if (m && y !== nI) {
        const w = {
          mark: Ks,
          prepend: p ? !1 : "queue",
          attachTo: c,
          priority: S
        }, C = typeof i == "function" ? i() : i;
        C && (w.csp = {
          nonce: C
        });
        const k = [], N = [];
        Object.keys(E).forEach((_) => {
          _.startsWith("@layer") ? k.push(_) : N.push(_);
        }), k.forEach((_) => {
          vd(Pb(E[_], g || !1), `_layer-${_}`, {
            ...w,
            prepend: !0
          });
        });
        const R = vd(y, x, w);
        R[_o] = d.instanceId, process.env.NODE_ENV !== "production" && R.setAttribute(BK, v.join("|")), N.forEach((_) => {
          vd(Pb(E[_], g || !1), `_effect-${_}`, w);
        });
      }
    }
  );
}
const RZ = "cssVar", MZ = (t, e) => {
  const {
    key: r,
    prefix: n,
    unitless: a,
    ignore: i,
    token: s,
    hashId: o,
    scope: l = ""
  } = t, {
    cache: {
      instanceId: u
    },
    container: c,
    hashPriority: f
  } = qi(Qy), {
    _tokenKey: h
  } = s, d = [...t.path, r, l, h];
  return YS(RZ, d, () => {
    const g = e(), [v, m] = jO(g, r, {
      prefix: n,
      unitless: a,
      ignore: i,
      scope: l,
      hashPriority: f,
      hashCls: o
    }), b = oI(d, m);
    return [v, m, b, r];
  }, ([, , g]) => {
    kE && HO(g, {
      mark: Ks,
      attachTo: c
    });
  }, ([, g, v]) => {
    if (!g)
      return;
    const m = vd(g, v, {
      mark: Ks,
      prepend: "queue",
      attachTo: c,
      priority: -999
    });
    m[_o] = u, m.setAttribute(jS, r);
  });
};
class IMe {
  constructor(e, r) {
    Ye(this, "name");
    Ye(this, "style");
    Ye(this, "_keyframe", !0);
    this.name = e, this.style = r;
  }
  getName(e = "") {
    return e ? `${e}-${this.name}` : this.name;
  }
}
function $u(t) {
  return t.notSplit = !0, t;
}
$u(["borderTop", "borderBottom"]), $u(["borderTop"]), $u(["borderBottom"]), $u(["borderLeft", "borderRight"]), $u(["borderLeft"]), $u(["borderRight"]);
var _Z = /* @__PURE__ */ Nn(function t() {
  Ln(this, t);
}), lI = "CALC_UNIT", LZ = new RegExp(lI, "g");
function Db(t) {
  return typeof t == "number" ? "".concat(t).concat(lI) : t;
}
var NZ = /* @__PURE__ */ function(t) {
  il(r, t);
  var e = sl(r);
  function r(n, a) {
    var i;
    Ln(this, r), i = e.call(this), pe($t(i), "result", ""), pe($t(i), "unitlessCssVar", void 0), pe($t(i), "lowPriority", void 0);
    var s = Tt(n);
    return i.unitlessCssVar = a, n instanceof r ? i.result = "(".concat(n.result, ")") : s === "number" ? i.result = Db(n) : s === "string" && (i.result = n), i;
  }
  return Nn(r, [{
    key: "add",
    value: function(a) {
      return a instanceof r ? this.result = "".concat(this.result, " + ").concat(a.getResult()) : (typeof a == "number" || typeof a == "string") && (this.result = "".concat(this.result, " + ").concat(Db(a))), this.lowPriority = !0, this;
    }
  }, {
    key: "sub",
    value: function(a) {
      return a instanceof r ? this.result = "".concat(this.result, " - ").concat(a.getResult()) : (typeof a == "number" || typeof a == "string") && (this.result = "".concat(this.result, " - ").concat(Db(a))), this.lowPriority = !0, this;
    }
  }, {
    key: "mul",
    value: function(a) {
      return this.lowPriority && (this.result = "(".concat(this.result, ")")), a instanceof r ? this.result = "".concat(this.result, " * ").concat(a.getResult(!0)) : (typeof a == "number" || typeof a == "string") && (this.result = "".concat(this.result, " * ").concat(a)), this.lowPriority = !1, this;
    }
  }, {
    key: "div",
    value: function(a) {
      return this.lowPriority && (this.result = "(".concat(this.result, ")")), a instanceof r ? this.result = "".concat(this.result, " / ").concat(a.getResult(!0)) : (typeof a == "number" || typeof a == "string") && (this.result = "".concat(this.result, " / ").concat(a)), this.lowPriority = !1, this;
    }
  }, {
    key: "getResult",
    value: function(a) {
      return this.lowPriority || a ? "(".concat(this.result, ")") : this.result;
    }
  }, {
    key: "equal",
    value: function(a) {
      var i = this, s = a || {}, o = s.unit, l = !0;
      return typeof o == "boolean" ? l = o : Array.from(this.unitlessCssVar).some(function(u) {
        return i.result.includes(u);
      }) && (l = !1), this.result = this.result.replace(LZ, l ? "px" : ""), typeof this.lowPriority < "u" ? "calc(".concat(this.result, ")") : this.result;
    }
  }]), r;
}(_Z), OZ = function(e, r) {
  var n = NZ;
  return function(a) {
    return new n(a, r);
  };
}, DA = function(e, r) {
  return "".concat([r, e.replace(/([A-Z]+)([A-Z][a-z]+)/g, "$1-$2").replace(/([a-z])([A-Z])/g, "$1-$2")].filter(Boolean).join("-"));
};
process.env.NODE_ENV !== "test" && D0() ? de.useLayoutEffect : de.useEffect;
Number(H8.split(".")[0]);
function $A(t, e, r, n) {
  var a = ke({}, e[t]);
  if (n != null && n.deprecatedTokens) {
    var i = n.deprecatedTokens;
    i.forEach(function(o) {
      var l = bt(o, 2), u = l[0], c = l[1];
      if (process.env.NODE_ENV !== "production" && $0(!(a != null && a[u]), "Component Token `".concat(String(u), "` of ").concat(String(t), " is deprecated. Please use `").concat(String(c), "` instead.")), a != null && a[u] || a != null && a[c]) {
        var f;
        (f = a[c]) !== null && f !== void 0 || (a[c] = a == null ? void 0 : a[u]);
      }
    });
  }
  var s = ke(ke({}, r), a);
  return Object.keys(s).forEach(function(o) {
    s[o] === e[o] && delete s[o];
  }), s;
}
var uI = process.env.NODE_ENV !== "production" || typeof CSSINJS_STATISTIC < "u", IE = !0;
function cI() {
  for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)
    e[r] = arguments[r];
  if (!uI)
    return Object.assign.apply(Object, [{}].concat(e));
  IE = !1;
  var n = {};
  return e.forEach(function(a) {
    if (Tt(a) === "object") {
      var i = Object.keys(a);
      i.forEach(function(s) {
        Object.defineProperty(n, s, {
          configurable: !0,
          enumerable: !0,
          get: function() {
            return a[s];
          }
        });
      });
    }
  }), IE = !0, n;
}
var FA = {};
function IZ() {
}
var PZ = function(e) {
  var r, n = e, a = IZ;
  return uI && typeof Proxy < "u" && (r = /* @__PURE__ */ new Set(), n = new Proxy(e, {
    get: function(s, o) {
      if (IE) {
        var l;
        (l = r) === null || l === void 0 || l.add(o);
      }
      return s[o];
    }
  }), a = function(s, o) {
    var l;
    FA[s] = {
      global: Array.from(r),
      component: ke(ke({}, (l = FA[s]) === null || l === void 0 ? void 0 : l.component), o)
    };
  }), {
    token: n,
    keys: r,
    flush: a
  };
};
function BA(t, e, r) {
  if (typeof r == "function") {
    var n;
    return r(cI(e, (n = e[t]) !== null && n !== void 0 ? n : {}));
  }
  return r ?? {};
}
function DZ(t) {
  return {
    max: function() {
      for (var r = arguments.length, n = new Array(r), a = 0; a < r; a++)
        n[a] = arguments[a];
      return "max(".concat(n.map(function(i) {
        return MA(i);
      }).join(","), ")");
    },
    min: function() {
      for (var r = arguments.length, n = new Array(r), a = 0; a < r; a++)
        n[a] = arguments[a];
      return "min(".concat(n.map(function(i) {
        return MA(i);
      }).join(","), ")");
    }
  };
}
var $Z = 1e3 * 60 * 10, FZ = /* @__PURE__ */ function() {
  function t() {
    Ln(this, t), pe(this, "map", /* @__PURE__ */ new Map()), pe(this, "objectIDMap", /* @__PURE__ */ new WeakMap()), pe(this, "nextID", 0), pe(this, "lastAccessBeat", /* @__PURE__ */ new Map()), pe(this, "accessBeat", 0);
  }
  return Nn(t, [{
    key: "set",
    value: function(r, n) {
      this.clear();
      var a = this.getCompositeKey(r);
      this.map.set(a, n), this.lastAccessBeat.set(a, Date.now());
    }
  }, {
    key: "get",
    value: function(r) {
      var n = this.getCompositeKey(r), a = this.map.get(n);
      return this.lastAccessBeat.set(n, Date.now()), this.accessBeat += 1, a;
    }
  }, {
    key: "getCompositeKey",
    value: function(r) {
      var n = this, a = r.map(function(i) {
        return i && Tt(i) === "object" ? "obj_".concat(n.getObjectID(i)) : "".concat(Tt(i), "_").concat(i);
      });
      return a.join("|");
    }
  }, {
    key: "getObjectID",
    value: function(r) {
      if (this.objectIDMap.has(r))
        return this.objectIDMap.get(r);
      var n = this.nextID;
      return this.objectIDMap.set(r, n), this.nextID += 1, n;
    }
  }, {
    key: "clear",
    value: function() {
      var r = this;
      if (this.accessBeat > 1e4) {
        var n = Date.now();
        this.lastAccessBeat.forEach(function(a, i) {
          n - a > $Z && (r.map.delete(i), r.lastAccessBeat.delete(i));
        }), this.accessBeat = 0;
      }
    }
  }]), t;
}(), zA = new FZ();
function BZ(t, e) {
  return lt.useMemo(function() {
    var r = zA.get(e);
    if (r)
      return r;
    var n = t();
    return zA.set(e, n), n;
  }, e);
}
var zZ = function() {
  return {};
};
function PMe(t) {
  var e = t.useCSP, r = e === void 0 ? zZ : e, n = t.useToken, a = t.usePrefix, i = t.getResetStyles, s = t.getCommonStyle, o = t.getCompUnitless;
  function l(h, d, p, g) {
    var v = Array.isArray(h) ? h[0] : h;
    function m(C) {
      return "".concat(String(v)).concat(C.slice(0, 1).toUpperCase()).concat(C.slice(1));
    }
    var b = (g == null ? void 0 : g.unitless) || {}, y = typeof o == "function" ? o(h) : {}, x = ke(ke({}, y), {}, pe({}, m("zIndexPopup"), !0));
    Object.keys(b).forEach(function(C) {
      x[m(C)] = b[C];
    });
    var E = ke(ke({}, g), {}, {
      unitless: x,
      prefixToken: m
    }), S = c(h, d, p, E), w = u(v, p, E);
    return function(C) {
      var k = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : C, N = S(C, k), R = w(k);
      return [N, R];
    };
  }
  function u(h, d, p) {
    var g = p.unitless, v = p.prefixToken, m = p.ignore;
    return function(b) {
      var y = n(), x = y.cssVar, E = y.realToken;
      return MZ({
        path: [h],
        prefix: x.prefix,
        key: x.key,
        unitless: g,
        ignore: m,
        token: E,
        scope: b
      }, function() {
        var S = BA(h, E, d), w = $A(h, E, S, {
          deprecatedTokens: p == null ? void 0 : p.deprecatedTokens
        });
        return S && Object.keys(S).forEach(function(C) {
          w[v(C)] = w[C], delete w[C];
        }), w;
      }), x == null ? void 0 : x.key;
    };
  }
  function c(h, d, p) {
    var g = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, v = Array.isArray(h) ? h : [h, h], m = bt(v, 1), b = m[0], y = v.join("-"), x = t.layer || {
      name: "antd"
    };
    return function(E) {
      var S = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : E, w = n(), C = w.theme, k = w.realToken, N = w.hashId, R = w.token, _ = w.cssVar, O = w.zeroRuntime, T = V8(function() {
        return O;
      }, []);
      if (T)
        return N;
      var L = a(), M = L.rootPrefixCls, A = L.iconPrefixCls, I = r(), D = "css", F = BZ(function() {
        var j = /* @__PURE__ */ new Set();
        return Object.keys(g.unitless || {}).forEach(function(Z) {
          j.add(Wg(Z, _.prefix)), j.add(Wg(Z, DA(b, _.prefix)));
        }), OZ(D, j);
      }, [D, b, _ == null ? void 0 : _.prefix]), B = DZ(), G = B.max, H = B.min, K = {
        theme: C,
        token: R,
        hashId: N,
        nonce: function() {
          return I.nonce;
        },
        clientOnly: g.clientOnly,
        layer: x,
        // antd is always at top of styles
        order: g.order || -999
      };
      return typeof i == "function" && PA(ke(ke({}, K), {}, {
        clientOnly: !1,
        path: ["Shared", M]
      }), function() {
        return i(R, {
          prefix: {
            rootPrefixCls: M,
            iconPrefixCls: A
          },
          csp: I
        });
      }), PA(ke(ke({}, K), {}, {
        path: [y, E, A]
      }), function() {
        if (g.injectStyle === !1)
          return [];
        var j = PZ(R), Z = j.token, te = j.flush, ne = BA(b, k, p), V = ".".concat(E), q = $A(b, k, ne, {
          deprecatedTokens: g.deprecatedTokens
        });
        ne && Tt(ne) === "object" && Object.keys(ne).forEach(function(J) {
          ne[J] = "var(".concat(Wg(J, DA(b, _.prefix)), ")");
        });
        var X = cI(Z, {
          componentCls: V,
          prefixCls: E,
          iconCls: ".".concat(A),
          antCls: ".".concat(M),
          calc: F,
          max: G,
          min: H
        }, ne), W = d(X, {
          hashId: N,
          prefixCls: E,
          rootPrefixCls: M,
          iconPrefixCls: A
        });
        te(b, q);
        var ue = typeof s == "function" ? s(X, E, S, g.resetFont) : null;
        return [g.resetStyle === !1 ? null : ue, W];
      }), N;
    };
  }
  function f(h, d, p) {
    var g = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, v = c(h, d, p, ke({
      resetStyle: !1,
      // Sub Style should default after root one
      order: -998
    }, g)), m = function(y) {
      var x = y.prefixCls, E = y.rootCls, S = E === void 0 ? x : E;
      return v(x, S), null;
    };
    return process.env.NODE_ENV !== "production" && (m.displayName = "SubStyle_".concat(String(Array.isArray(h) ? h.join(".") : h))), m;
  }
  return {
    genStyleHooks: l,
    genSubStyleComponent: f,
    genComponentStyleHook: c
  };
}
const GZ = {
  aliceblue: "9ehhb",
  antiquewhite: "9sgk7",
  aqua: "1ekf",
  aquamarine: "4zsno",
  azure: "9eiv3",
  beige: "9lhp8",
  bisque: "9zg04",
  black: "0",
  blanchedalmond: "9zhe5",
  blue: "73",
  blueviolet: "5e31e",
  brown: "6g016",
  burlywood: "8ouiv",
  cadetblue: "3qba8",
  chartreuse: "4zshs",
  chocolate: "87k0u",
  coral: "9yvyo",
  cornflowerblue: "3xael",
  cornsilk: "9zjz0",
  crimson: "8l4xo",
  cyan: "1ekf",
  darkblue: "3v",
  darkcyan: "rkb",
  darkgoldenrod: "776yz",
  darkgray: "6mbhl",
  darkgreen: "jr4",
  darkgrey: "6mbhl",
  darkkhaki: "7ehkb",
  darkmagenta: "5f91n",
  darkolivegreen: "3bzfz",
  darkorange: "9yygw",
  darkorchid: "5z6x8",
  darkred: "5f8xs",
  darksalmon: "9441m",
  darkseagreen: "5lwgf",
  darkslateblue: "2th1n",
  darkslategray: "1ugcv",
  darkslategrey: "1ugcv",
  darkturquoise: "14up",
  darkviolet: "5rw7n",
  deeppink: "9yavn",
  deepskyblue: "11xb",
  dimgray: "442g9",
  dimgrey: "442g9",
  dodgerblue: "16xof",
  firebrick: "6y7tu",
  floralwhite: "9zkds",
  forestgreen: "1cisi",
  fuchsia: "9y70f",
  gainsboro: "8m8kc",
  ghostwhite: "9pq0v",
  goldenrod: "8j4f4",
  gold: "9zda8",
  gray: "50i2o",
  green: "pa8",
  greenyellow: "6senj",
  grey: "50i2o",
  honeydew: "9eiuo",
  hotpink: "9yrp0",
  indianred: "80gnw",
  indigo: "2xcoy",
  ivory: "9zldc",
  khaki: "9edu4",
  lavenderblush: "9ziet",
  lavender: "90c8q",
  lawngreen: "4vk74",
  lemonchiffon: "9zkct",
  lightblue: "6s73a",
  lightcoral: "9dtog",
  lightcyan: "8s1rz",
  lightgoldenrodyellow: "9sjiq",
  lightgray: "89jo3",
  lightgreen: "5nkwg",
  lightgrey: "89jo3",
  lightpink: "9z6wx",
  lightsalmon: "9z2ii",
  lightseagreen: "19xgq",
  lightskyblue: "5arju",
  lightslategray: "4nwk9",
  lightslategrey: "4nwk9",
  lightsteelblue: "6wau6",
  lightyellow: "9zlcw",
  lime: "1edc",
  limegreen: "1zcxe",
  linen: "9shk6",
  magenta: "9y70f",
  maroon: "4zsow",
  mediumaquamarine: "40eju",
  mediumblue: "5p",
  mediumorchid: "79qkz",
  mediumpurple: "5r3rv",
  mediumseagreen: "2d9ip",
  mediumslateblue: "4tcku",
  mediumspringgreen: "1di2",
  mediumturquoise: "2uabw",
  mediumvioletred: "7rn9h",
  midnightblue: "z980",
  mintcream: "9ljp6",
  mistyrose: "9zg0x",
  moccasin: "9zfzp",
  navajowhite: "9zest",
  navy: "3k",
  oldlace: "9wq92",
  olive: "50hz4",
  olivedrab: "472ub",
  orange: "9z3eo",
  orangered: "9ykg0",
  orchid: "8iu3a",
  palegoldenrod: "9bl4a",
  palegreen: "5yw0o",
  paleturquoise: "6v4ku",
  palevioletred: "8k8lv",
  papayawhip: "9zi6t",
  peachpuff: "9ze0p",
  peru: "80oqn",
  pink: "9z8wb",
  plum: "8nba5",
  powderblue: "6wgdi",
  purple: "4zssg",
  rebeccapurple: "3zk49",
  red: "9y6tc",
  rosybrown: "7cv4f",
  royalblue: "2jvtt",
  saddlebrown: "5fmkz",
  salmon: "9rvci",
  sandybrown: "9jn1c",
  seagreen: "1tdnb",
  seashell: "9zje6",
  sienna: "6973h",
  silver: "7ir40",
  skyblue: "5arjf",
  slateblue: "45e4t",
  slategray: "4e100",
  slategrey: "4e100",
  snow: "9zke2",
  springgreen: "1egv",
  steelblue: "2r1kk",
  tan: "87yx8",
  teal: "pds",
  thistle: "8ggk8",
  tomato: "9yqfb",
  turquoise: "2j4r4",
  violet: "9b10u",
  wheat: "9ld4j",
  white: "9zldr",
  whitesmoke: "9lhpx",
  yellow: "9zl6o",
  yellowgreen: "61fzm"
}, Tn = Math.round;
function $b(t, e) {
  const r = t.replace(/^[^(]*\((.*)/, "$1").replace(/\).*/, "").match(/\d*\.?\d+%?/g) || [], n = r.map((a) => parseFloat(a));
  for (let a = 0; a < 3; a += 1)
    n[a] = e(n[a] || 0, r[a] || "", a);
  return r[3] ? n[3] = r[3].includes("%") ? n[3] / 100 : n[3] : n[3] = 1, n;
}
const GA = (t, e, r) => r === 0 ? t : t / 100;
function Uf(t, e) {
  const r = e || 255;
  return t > r ? r : t < 0 ? 0 : t;
}
let DMe = class fI {
  constructor(e) {
    /**
     * All FastColor objects are valid. So isValid is always true. This property is kept to be compatible with TinyColor.
     */
    Ye(this, "isValid", !0);
    /**
     * Red, R in RGB
     */
    Ye(this, "r", 0);
    /**
     * Green, G in RGB
     */
    Ye(this, "g", 0);
    /**
     * Blue, B in RGB
     */
    Ye(this, "b", 0);
    /**
     * Alpha/Opacity, A in RGBA/HSLA
     */
    Ye(this, "a", 1);
    // HSV privates
    Ye(this, "_h");
    Ye(this, "_s");
    Ye(this, "_l");
    Ye(this, "_v");
    // intermediate variables to calculate HSL/HSV
    Ye(this, "_max");
    Ye(this, "_min");
    Ye(this, "_brightness");
    function r(n) {
      return n[0] in e && n[1] in e && n[2] in e;
    }
    if (e) if (typeof e == "string") {
      let a = function(i) {
        return n.startsWith(i);
      };
      const n = e.trim();
      if (/^#?[A-F\d]{3,8}$/i.test(n))
        this.fromHexString(n);
      else if (a("rgb"))
        this.fromRgbString(n);
      else if (a("hsl"))
        this.fromHslString(n);
      else if (a("hsv") || a("hsb"))
        this.fromHsvString(n);
      else {
        const i = GZ[n.toLowerCase()];
        i && this.fromHexString(
          // Convert 36 hex to 16 hex
          parseInt(i, 36).toString(16).padStart(6, "0")
        );
      }
    } else if (e instanceof fI)
      this.r = e.r, this.g = e.g, this.b = e.b, this.a = e.a, this._h = e._h, this._s = e._s, this._l = e._l, this._v = e._v;
    else if (r("rgb"))
      this.r = Uf(e.r), this.g = Uf(e.g), this.b = Uf(e.b), this.a = typeof e.a == "number" ? Uf(e.a, 1) : 1;
    else if (r("hsl"))
      this.fromHsl(e);
    else if (r("hsv"))
      this.fromHsv(e);
    else
      throw new Error("@ant-design/fast-color: unsupported input " + JSON.stringify(e));
  }
  // ======================= Setter =======================
  setR(e) {
    return this._sc("r", e);
  }
  setG(e) {
    return this._sc("g", e);
  }
  setB(e) {
    return this._sc("b", e);
  }
  setA(e) {
    return this._sc("a", e, 1);
  }
  setHue(e) {
    const r = this.toHsv();
    return r.h = e, this._c(r);
  }
  // ======================= Getter =======================
  /**
   * Returns the perceived luminance of a color, from 0-1.
   * @see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
   */
  getLuminance() {
    function e(i) {
      const s = i / 255;
      return s <= 0.03928 ? s / 12.92 : Math.pow((s + 0.055) / 1.055, 2.4);
    }
    const r = e(this.r), n = e(this.g), a = e(this.b);
    return 0.2126 * r + 0.7152 * n + 0.0722 * a;
  }
  getHue() {
    if (typeof this._h > "u") {
      const e = this.getMax() - this.getMin();
      e === 0 ? this._h = 0 : this._h = Tn(60 * (this.r === this.getMax() ? (this.g - this.b) / e + (this.g < this.b ? 6 : 0) : this.g === this.getMax() ? (this.b - this.r) / e + 2 : (this.r - this.g) / e + 4));
    }
    return this._h;
  }
  getSaturation() {
    if (typeof this._s > "u") {
      const e = this.getMax() - this.getMin();
      e === 0 ? this._s = 0 : this._s = e / this.getMax();
    }
    return this._s;
  }
  getLightness() {
    return typeof this._l > "u" && (this._l = (this.getMax() + this.getMin()) / 510), this._l;
  }
  getValue() {
    return typeof this._v > "u" && (this._v = this.getMax() / 255), this._v;
  }
  /**
   * Returns the perceived brightness of the color, from 0-255.
   * Note: this is not the b of HSB
   * @see http://www.w3.org/TR/AERT#color-contrast
   */
  getBrightness() {
    return typeof this._brightness > "u" && (this._brightness = (this.r * 299 + this.g * 587 + this.b * 114) / 1e3), this._brightness;
  }
  // ======================== Func ========================
  darken(e = 10) {
    const r = this.getHue(), n = this.getSaturation();
    let a = this.getLightness() - e / 100;
    return a < 0 && (a = 0), this._c({
      h: r,
      s: n,
      l: a,
      a: this.a
    });
  }
  lighten(e = 10) {
    const r = this.getHue(), n = this.getSaturation();
    let a = this.getLightness() + e / 100;
    return a > 1 && (a = 1), this._c({
      h: r,
      s: n,
      l: a,
      a: this.a
    });
  }
  /**
   * Mix the current color a given amount with another color, from 0 to 100.
   * 0 means no mixing (return current color).
   */
  mix(e, r = 50) {
    const n = this._c(e), a = r / 100, i = (o) => (n[o] - this[o]) * a + this[o], s = {
      r: Tn(i("r")),
      g: Tn(i("g")),
      b: Tn(i("b")),
      a: Tn(i("a") * 100) / 100
    };
    return this._c(s);
  }
  /**
   * Mix the color with pure white, from 0 to 100.
   * Providing 0 will do nothing, providing 100 will always return white.
   */
  tint(e = 10) {
    return this.mix({
      r: 255,
      g: 255,
      b: 255,
      a: 1
    }, e);
  }
  /**
   * Mix the color with pure black, from 0 to 100.
   * Providing 0 will do nothing, providing 100 will always return black.
   */
  shade(e = 10) {
    return this.mix({
      r: 0,
      g: 0,
      b: 0,
      a: 1
    }, e);
  }
  onBackground(e) {
    const r = this._c(e), n = this.a + r.a * (1 - this.a), a = (i) => Tn((this[i] * this.a + r[i] * r.a * (1 - this.a)) / n);
    return this._c({
      r: a("r"),
      g: a("g"),
      b: a("b"),
      a: n
    });
  }
  // ======================= Status =======================
  isDark() {
    return this.getBrightness() < 128;
  }
  isLight() {
    return this.getBrightness() >= 128;
  }
  // ======================== MISC ========================
  equals(e) {
    return this.r === e.r && this.g === e.g && this.b === e.b && this.a === e.a;
  }
  clone() {
    return this._c(this);
  }
  // ======================= Format =======================
  toHexString() {
    let e = "#";
    const r = (this.r || 0).toString(16);
    e += r.length === 2 ? r : "0" + r;
    const n = (this.g || 0).toString(16);
    e += n.length === 2 ? n : "0" + n;
    const a = (this.b || 0).toString(16);
    if (e += a.length === 2 ? a : "0" + a, typeof this.a == "number" && this.a >= 0 && this.a < 1) {
      const i = Tn(this.a * 255).toString(16);
      e += i.length === 2 ? i : "0" + i;
    }
    return e;
  }
  /** CSS support color pattern */
  toHsl() {
    return {
      h: this.getHue(),
      s: this.getSaturation(),
      l: this.getLightness(),
      a: this.a
    };
  }
  /** CSS support color pattern */
  toHslString() {
    const e = this.getHue(), r = Tn(this.getSaturation() * 100), n = Tn(this.getLightness() * 100);
    return this.a !== 1 ? `hsla(${e},${r}%,${n}%,${this.a})` : `hsl(${e},${r}%,${n}%)`;
  }
  /** Same as toHsb */
  toHsv() {
    return {
      h: this.getHue(),
      s: this.getSaturation(),
      v: this.getValue(),
      a: this.a
    };
  }
  toRgb() {
    return {
      r: this.r,
      g: this.g,
      b: this.b,
      a: this.a
    };
  }
  toRgbString() {
    return this.a !== 1 ? `rgba(${this.r},${this.g},${this.b},${this.a})` : `rgb(${this.r},${this.g},${this.b})`;
  }
  toString() {
    return this.toRgbString();
  }
  // ====================== Privates ======================
  /** Return a new FastColor object with one channel changed */
  _sc(e, r, n) {
    const a = this.clone();
    return a[e] = Uf(r, n), a;
  }
  _c(e) {
    return new this.constructor(e);
  }
  getMax() {
    return typeof this._max > "u" && (this._max = Math.max(this.r, this.g, this.b)), this._max;
  }
  getMin() {
    return typeof this._min > "u" && (this._min = Math.min(this.r, this.g, this.b)), this._min;
  }
  fromHexString(e) {
    const r = e.replace("#", "");
    function n(a, i) {
      return parseInt(r[a] + r[i || a], 16);
    }
    r.length < 6 ? (this.r = n(0), this.g = n(1), this.b = n(2), this.a = r[3] ? n(3) / 255 : 1) : (this.r = n(0, 1), this.g = n(2, 3), this.b = n(4, 5), this.a = r[6] ? n(6, 7) / 255 : 1);
  }
  fromHsl({
    h: e,
    s: r,
    l: n,
    a
  }) {
    if (this._h = e % 360, this._s = r, this._l = n, this.a = typeof a == "number" ? a : 1, r <= 0) {
      const h = Tn(n * 255);
      this.r = h, this.g = h, this.b = h;
    }
    let i = 0, s = 0, o = 0;
    const l = e / 60, u = (1 - Math.abs(2 * n - 1)) * r, c = u * (1 - Math.abs(l % 2 - 1));
    l >= 0 && l < 1 ? (i = u, s = c) : l >= 1 && l < 2 ? (i = c, s = u) : l >= 2 && l < 3 ? (s = u, o = c) : l >= 3 && l < 4 ? (s = c, o = u) : l >= 4 && l < 5 ? (i = c, o = u) : l >= 5 && l < 6 && (i = u, o = c);
    const f = n - u / 2;
    this.r = Tn((i + f) * 255), this.g = Tn((s + f) * 255), this.b = Tn((o + f) * 255);
  }
  fromHsv({
    h: e,
    s: r,
    v: n,
    a
  }) {
    this._h = e % 360, this._s = r, this._v = n, this.a = typeof a == "number" ? a : 1;
    const i = Tn(n * 255);
    if (this.r = i, this.g = i, this.b = i, r <= 0)
      return;
    const s = e / 60, o = Math.floor(s), l = s - o, u = Tn(n * (1 - r) * 255), c = Tn(n * (1 - r * l) * 255), f = Tn(n * (1 - r * (1 - l)) * 255);
    switch (o) {
      case 0:
        this.g = f, this.b = u;
        break;
      case 1:
        this.r = c, this.b = u;
        break;
      case 2:
        this.r = u, this.b = f;
        break;
      case 3:
        this.r = u, this.g = c;
        break;
      case 4:
        this.r = f, this.g = u;
        break;
      case 5:
      default:
        this.g = u, this.b = c;
        break;
    }
  }
  fromHsvString(e) {
    const r = $b(e, GA);
    this.fromHsv({
      h: r[0],
      s: r[1],
      v: r[2],
      a: r[3]
    });
  }
  fromHslString(e) {
    const r = $b(e, GA);
    this.fromHsl({
      h: r[0],
      s: r[1],
      l: r[2],
      a: r[3]
    });
  }
  fromRgbString(e) {
    const r = $b(e, (n, a) => (
      // Convert percentage to number. e.g. 50% -> 128
      a.includes("%") ? Tn(n / 100 * 255) : n
    ));
    this.r = r[0], this.g = r[1], this.b = r[2], this.a = r[3];
  }
};
function UZ(t, e) {
  if (!t)
    return !1;
  if (t.contains)
    return t.contains(e);
  for (var r = e; r; ) {
    if (r === t)
      return !0;
    r = r.parentNode;
  }
  return !1;
}
var UA = "data-rc-order", HA = "data-rc-priority", HZ = "rc-util-key", PE = /* @__PURE__ */ new Map();
function hI() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = t.mark;
  return e ? e.startsWith("data-") ? e : "data-".concat(e) : HZ;
}
function r1(t) {
  if (t.attachTo)
    return t.attachTo;
  var e = document.querySelector("head");
  return e || document.body;
}
function VZ(t) {
  return t === "queue" ? "prependQueue" : t ? "prepend" : "append";
}
function QS(t) {
  return Array.from((PE.get(t) || t).children).filter(function(e) {
    return e.tagName === "STYLE";
  });
}
function dI(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!po())
    return null;
  var r = e.csp, n = e.prepend, a = e.priority, i = a === void 0 ? 0 : a, s = VZ(n), o = s === "prependQueue", l = document.createElement("style");
  l.setAttribute(UA, s), o && i && l.setAttribute(HA, "".concat(i)), r != null && r.nonce && (l.nonce = r == null ? void 0 : r.nonce), l.innerHTML = t;
  var u = r1(e), c = u.firstChild;
  if (n) {
    if (o) {
      var f = (e.styles || QS(u)).filter(function(h) {
        if (!["prepend", "prependQueue"].includes(h.getAttribute(UA)))
          return !1;
        var d = Number(h.getAttribute(HA) || 0);
        return i >= d;
      });
      if (f.length)
        return u.insertBefore(l, f[f.length - 1].nextSibling), l;
    }
    u.insertBefore(l, c);
  } else
    u.appendChild(l);
  return l;
}
function pI(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = r1(e);
  return (e.styles || QS(r)).find(function(n) {
    return n.getAttribute(hI(e)) === t;
  });
}
function gI(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = pI(t, e);
  if (r) {
    var n = r1(e);
    n.removeChild(r);
  }
}
function qZ(t, e) {
  var r = PE.get(t);
  if (!r || !UZ(document, r)) {
    var n = dI("", e), a = n.parentNode;
    PE.set(t, a), t.removeChild(n);
  }
}
function ql(t, e) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, n = r1(r), a = QS(n), i = ke(ke({}, r), {}, {
    styles: a
  });
  qZ(n, i);
  var s = pI(e, i);
  if (s) {
    var o, l;
    if ((o = i.csp) !== null && o !== void 0 && o.nonce && s.nonce !== ((l = i.csp) === null || l === void 0 ? void 0 : l.nonce)) {
      var u;
      s.nonce = (u = i.csp) === null || u === void 0 ? void 0 : u.nonce;
    }
    return s.innerHTML !== t && (s.innerHTML = t), s;
  }
  var c = dI(t, i);
  return c.setAttribute(hI(i), e), c;
}
function DE(t, e) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, n = /* @__PURE__ */ new Set();
  function a(i, s) {
    var o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, l = n.has(i);
    if (qr(!l, "Warning: There may be circular references"), l)
      return !1;
    if (i === s)
      return !0;
    if (r && o > 1)
      return !1;
    n.add(i);
    var u = o + 1;
    if (Array.isArray(i)) {
      if (!Array.isArray(s) || i.length !== s.length)
        return !1;
      for (var c = 0; c < i.length; c++)
        if (!a(i[c], s[c], u))
          return !1;
      return !0;
    }
    if (i && s && Tt(i) === "object" && Tt(s) === "object") {
      var f = Object.keys(i);
      return f.length !== Object.keys(s).length ? !1 : f.every(function(h) {
        return a(i[h], s[h], u);
      });
    }
    return !1;
  }
  return a(t, e);
}
var WZ = "%";
function $E(t) {
  return t.join(WZ);
}
var jZ = /* @__PURE__ */ function() {
  function t(e) {
    Ln(this, t), pe(this, "instanceId", void 0), pe(this, "cache", /* @__PURE__ */ new Map()), this.instanceId = e;
  }
  return Nn(t, [{
    key: "get",
    value: function(r) {
      return this.opGet($E(r));
    }
    /** A fast get cache with `get` concat. */
  }, {
    key: "opGet",
    value: function(r) {
      return this.cache.get(r) || null;
    }
  }, {
    key: "update",
    value: function(r, n) {
      return this.opUpdate($E(r), n);
    }
    /** A fast get cache with `get` concat. */
  }, {
    key: "opUpdate",
    value: function(r, n) {
      var a = this.cache.get(r), i = n(a);
      i === null ? this.cache.delete(r) : this.cache.set(r, i);
    }
  }]), t;
}(), jc = "data-token-hash", Gi = "data-css-hash", YZ = "data-cache-path", No = "__cssinjs_instance__";
function XZ() {
  var t = Math.random().toString(12).slice(2);
  if (typeof document < "u" && document.head && document.body) {
    var e = document.body.querySelectorAll("style[".concat(Gi, "]")) || [], r = document.head.firstChild;
    Array.from(e).forEach(function(a) {
      a[No] = a[No] || t, a[No] === t && document.head.insertBefore(a, r);
    });
    var n = {};
    Array.from(document.querySelectorAll("style[".concat(Gi, "]"))).forEach(function(a) {
      var i = a.getAttribute(Gi);
      if (n[i]) {
        if (a[No] === t) {
          var s;
          (s = a.parentNode) === null || s === void 0 || s.removeChild(a);
        }
      } else
        n[i] = !0;
    });
  }
  return new jZ(t);
}
var F0 = /* @__PURE__ */ de.createContext({
  hashPriority: "low",
  cache: XZ(),
  defaultCache: !0
});
function KZ(t, e) {
  if (t.length !== e.length)
    return !1;
  for (var r = 0; r < t.length; r++)
    if (t[r] !== e[r])
      return !1;
  return !0;
}
var JS = /* @__PURE__ */ function() {
  function t() {
    Ln(this, t), pe(this, "cache", void 0), pe(this, "keys", void 0), pe(this, "cacheCallTimes", void 0), this.cache = /* @__PURE__ */ new Map(), this.keys = [], this.cacheCallTimes = 0;
  }
  return Nn(t, [{
    key: "size",
    value: function() {
      return this.keys.length;
    }
  }, {
    key: "internalGet",
    value: function(r) {
      var n, a, i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, s = {
        map: this.cache
      };
      return r.forEach(function(o) {
        if (!s)
          s = void 0;
        else {
          var l;
          s = (l = s) === null || l === void 0 || (l = l.map) === null || l === void 0 ? void 0 : l.get(o);
        }
      }), (n = s) !== null && n !== void 0 && n.value && i && (s.value[1] = this.cacheCallTimes++), (a = s) === null || a === void 0 ? void 0 : a.value;
    }
  }, {
    key: "get",
    value: function(r) {
      var n;
      return (n = this.internalGet(r, !0)) === null || n === void 0 ? void 0 : n[0];
    }
  }, {
    key: "has",
    value: function(r) {
      return !!this.internalGet(r);
    }
  }, {
    key: "set",
    value: function(r, n) {
      var a = this;
      if (!this.has(r)) {
        if (this.size() + 1 > t.MAX_CACHE_SIZE + t.MAX_CACHE_OFFSET) {
          var i = this.keys.reduce(function(u, c) {
            var f = bt(u, 2), h = f[1];
            return a.internalGet(c)[1] < h ? [c, a.internalGet(c)[1]] : u;
          }, [this.keys[0], this.cacheCallTimes]), s = bt(i, 1), o = s[0];
          this.delete(o);
        }
        this.keys.push(r);
      }
      var l = this.cache;
      r.forEach(function(u, c) {
        if (c === r.length - 1)
          l.set(u, {
            value: [n, a.cacheCallTimes++]
          });
        else {
          var f = l.get(u);
          f ? f.map || (f.map = /* @__PURE__ */ new Map()) : l.set(u, {
            map: /* @__PURE__ */ new Map()
          }), l = l.get(u).map;
        }
      });
    }
  }, {
    key: "deleteByPath",
    value: function(r, n) {
      var a = r.get(n[0]);
      if (n.length === 1) {
        var i;
        return a.map ? r.set(n[0], {
          map: a.map
        }) : r.delete(n[0]), (i = a.value) === null || i === void 0 ? void 0 : i[0];
      }
      var s = this.deleteByPath(a.map, n.slice(1));
      return (!a.map || a.map.size === 0) && !a.value && r.delete(n[0]), s;
    }
  }, {
    key: "delete",
    value: function(r) {
      if (this.has(r))
        return this.keys = this.keys.filter(function(n) {
          return !KZ(n, r);
        }), this.deleteByPath(this.cache, r);
    }
  }]), t;
}();
pe(JS, "MAX_CACHE_SIZE", 20);
pe(JS, "MAX_CACHE_OFFSET", 5);
var VA = 0, vI = /* @__PURE__ */ function() {
  function t(e) {
    Ln(this, t), pe(this, "derivatives", void 0), pe(this, "id", void 0), this.derivatives = Array.isArray(e) ? e : [e], this.id = VA, e.length === 0 && zd(e.length > 0, "[Ant Design CSS-in-JS] Theme should have at least one derivative function."), VA += 1;
  }
  return Nn(t, [{
    key: "getDerivativeToken",
    value: function(r) {
      return this.derivatives.reduce(function(n, a) {
        return a(r, n);
      }, void 0);
    }
  }]), t;
}(), Fb = new JS();
function FE(t) {
  var e = Array.isArray(t) ? t : [t];
  return Fb.has(e) || Fb.set(e, new vI(e)), Fb.get(e);
}
var ZZ = /* @__PURE__ */ new WeakMap(), Bb = {};
function QZ(t, e) {
  for (var r = ZZ, n = 0; n < e.length; n += 1) {
    var a = e[n];
    r.has(a) || r.set(a, /* @__PURE__ */ new WeakMap()), r = r.get(a);
  }
  return r.has(Bb) || r.set(Bb, t()), r.get(Bb);
}
var qA = /* @__PURE__ */ new WeakMap();
function bd(t) {
  var e = qA.get(t) || "";
  return e || (Object.keys(t).forEach(function(r) {
    var n = t[r];
    e += r, n instanceof vI ? e += n.id : n && Tt(n) === "object" ? e += bd(n) : e += n;
  }), e = Bi(e), qA.set(t, e)), e;
}
function WA(t, e) {
  return Bi("".concat(e, "_").concat(bd(t)));
}
var BE = po();
function $r(t) {
  return typeof t == "number" ? "".concat(t, "px") : t;
}
function Gv(t, e, r) {
  var n, a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1;
  if (i)
    return t;
  var s = ke(ke({}, a), {}, (n = {}, pe(n, jc, e), pe(n, Gi, r), n)), o = Object.keys(s).map(function(l) {
    var u = s[l];
    return u ? "".concat(l, '="').concat(u, '"') : null;
  }).filter(function(l) {
    return l;
  }).join(" ");
  return "<style ".concat(o, ">").concat(t, "</style>");
}
var Kg = function(e) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  return "--".concat(r ? "".concat(r, "-") : "").concat(e).replace(/([a-z0-9])([A-Z])/g, "$1-$2").replace(/([A-Z]+)([A-Z][a-z0-9]+)/g, "$1-$2").replace(/([a-z])([A-Z0-9])/g, "$1-$2").toLowerCase();
}, JZ = function(e, r, n) {
  return Object.keys(e).length ? ".".concat(r).concat(n != null && n.scope ? ".".concat(n.scope) : "", "{").concat(Object.entries(e).map(function(a) {
    var i = bt(a, 2), s = i[0], o = i[1];
    return "".concat(s, ":").concat(o, ";");
  }).join(""), "}") : "";
}, mI = function(e, r, n) {
  var a = {}, i = {};
  return Object.entries(e).forEach(function(s) {
    var o, l, u = bt(s, 2), c = u[0], f = u[1];
    if (n != null && (o = n.preserve) !== null && o !== void 0 && o[c])
      i[c] = f;
    else if ((typeof f == "string" || typeof f == "number") && !(n != null && (l = n.ignore) !== null && l !== void 0 && l[c])) {
      var h, d = Kg(c, n == null ? void 0 : n.prefix);
      a[d] = typeof f == "number" && !(n != null && (h = n.unitless) !== null && h !== void 0 && h[c]) ? "".concat(f, "px") : String(f), i[c] = "var(".concat(d, ")");
    }
  }), [i, JZ(a, r, {
    scope: n == null ? void 0 : n.scope
  })];
}, eQ = ke({}, de), jA = eQ.useInsertionEffect, tQ = function(e, r, n) {
  de.useMemo(e, n), zv(function() {
    return r(!0);
  }, n);
}, rQ = jA ? function(t, e, r) {
  return jA(function() {
    return t(), e();
  }, r);
} : tQ, nQ = ke({}, de), aQ = nQ.useInsertionEffect, iQ = function(e) {
  var r = [], n = !1;
  function a(i) {
    if (n) {
      process.env.NODE_ENV !== "production" && zd(!1, "[Ant Design CSS-in-JS] You are registering a cleanup function after unmount, which will not have any effect.");
      return;
    }
    r.push(i);
  }
  return de.useEffect(function() {
    return n = !1, function() {
      n = !0, r.length && r.forEach(function(i) {
        return i();
      });
    };
  }, e), a;
}, sQ = function() {
  return function(e) {
    e();
  };
}, oQ = typeof aQ < "u" ? iQ : sQ;
function lQ() {
  return !1;
}
var zE = !1;
function uQ() {
  return zE;
}
const cQ = process.env.NODE_ENV === "production" ? lQ : uQ;
if (process.env.NODE_ENV !== "production" && typeof module < "u" && module && module.hot && typeof window < "u") {
  var Lp = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : null;
  if (Lp && typeof Lp.webpackHotUpdate == "function") {
    var fQ = Lp.webpackHotUpdate;
    Lp.webpackHotUpdate = function() {
      return zE = !0, setTimeout(function() {
        zE = !1;
      }, 0), fQ.apply(void 0, arguments);
    };
  }
}
function e5(t, e, r, n, a) {
  var i = de.useContext(F0), s = i.cache, o = [t].concat(Ot(e)), l = $E(o), u = oQ([l]), c = cQ(), f = function(g) {
    s.opUpdate(l, function(v) {
      var m = v || [void 0, void 0], b = bt(m, 2), y = b[0], x = y === void 0 ? 0 : y, E = b[1], S = E;
      process.env.NODE_ENV !== "production" && E && c && (n == null || n(S, c), S = null);
      var w = S || r(), C = [x, w];
      return g ? g(C) : C;
    });
  };
  de.useMemo(
    function() {
      f();
    },
    /* eslint-disable react-hooks/exhaustive-deps */
    [l]
    /* eslint-enable */
  );
  var h = s.opGet(l);
  process.env.NODE_ENV !== "production" && !h && (f(), h = s.opGet(l));
  var d = h[1];
  return rQ(function() {
    a == null || a(d);
  }, function(p) {
    return f(function(g) {
      var v = bt(g, 2), m = v[0], b = v[1];
      return p && m === 0 && (a == null || a(d)), [m + 1, b];
    }), function() {
      s.opUpdate(l, function(g) {
        var v = g || [], m = bt(v, 2), b = m[0], y = b === void 0 ? 0 : b, x = m[1], E = y - 1;
        return E === 0 ? (u(function() {
          (p || !s.opGet(l)) && (n == null || n(x, !1));
        }), null) : [y - 1, x];
      });
    };
  }, [l]), d;
}
var hQ = {}, dQ = process.env.NODE_ENV !== "production" ? "css-dev-only-do-not-override" : "css", Pl = /* @__PURE__ */ new Map();
function pQ(t) {
  Pl.set(t, (Pl.get(t) || 0) + 1);
}
function gQ(t, e) {
  if (typeof document < "u") {
    var r = document.querySelectorAll("style[".concat(jc, '="').concat(t, '"]'));
    r.forEach(function(n) {
      if (n[No] === e) {
        var a;
        (a = n.parentNode) === null || a === void 0 || a.removeChild(n);
      }
    });
  }
}
var vQ = 0;
function mQ(t, e) {
  Pl.set(t, (Pl.get(t) || 0) - 1);
  var r = Array.from(Pl.keys()), n = r.filter(function(a) {
    var i = Pl.get(a) || 0;
    return i <= 0;
  });
  r.length - n.length > vQ && n.forEach(function(a) {
    gQ(a, e), Pl.delete(a);
  });
}
var yQ = function(e, r, n, a) {
  var i = n.getDerivativeToken(e), s = ke(ke({}, i), r);
  return a && (s = a(s)), s;
}, yI = "token";
function bQ(t, e) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, n = qi(F0), a = n.cache.instanceId, i = n.container, s = r.salt, o = s === void 0 ? "" : s, l = r.override, u = l === void 0 ? hQ : l, c = r.formatToken, f = r.getComputedToken, h = r.cssVar, d = QZ(function() {
    return Object.assign.apply(Object, [{}].concat(Ot(e)));
  }, e), p = bd(d), g = bd(u), v = h ? bd(h) : "", m = e5(yI, [o, t.id, p, g, v], function() {
    var b, y = f ? f(d, u, t) : yQ(d, u, t, c), x = ke({}, y), E = "";
    if (h) {
      var S = mI(y, h.key, {
        prefix: h.prefix,
        ignore: h.ignore,
        unitless: h.unitless,
        preserve: h.preserve
      }), w = bt(S, 2);
      y = w[0], E = w[1];
    }
    var C = WA(y, o);
    y._tokenKey = C, x._tokenKey = WA(x, o);
    var k = (b = h == null ? void 0 : h.key) !== null && b !== void 0 ? b : C;
    y._themeKey = k, pQ(k);
    var N = "".concat(dQ, "-").concat(Bi(C));
    return y._hashId = N, [y, N, x, E, (h == null ? void 0 : h.key) || ""];
  }, function(b) {
    mQ(b[0]._themeKey, a);
  }, function(b) {
    var y = bt(b, 4), x = y[0], E = y[3];
    if (h && E) {
      var S = ql(E, Bi("css-variables-".concat(x._themeKey)), {
        mark: Gi,
        prepend: "queue",
        attachTo: i,
        priority: -999
      });
      S[No] = a, S.setAttribute(jc, x._themeKey);
    }
  });
  return m;
}
var xQ = function(e, r, n) {
  var a = bt(e, 5), i = a[2], s = a[3], o = a[4], l = n || {}, u = l.plain;
  if (!s)
    return null;
  var c = i._tokenKey, f = -999, h = {
    "data-rc-order": "prependQueue",
    "data-rc-priority": "".concat(f)
  }, d = Gv(s, o, c, h, u);
  return [f, c, d];
};
function bI(t, e) {
  var r = e.path, n = e.parentSelectors;
  qr(!1, "[Ant Design CSS-in-JS] ".concat(r ? "Error in ".concat(r, ": ") : "").concat(t).concat(n.length ? " Selector: ".concat(n.join(" | ")) : ""));
}
var wQ = function(e, r, n) {
  if (e === "content") {
    var a = /(attr|counters?|url|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/, i = ["normal", "none", "initial", "inherit", "unset"];
    (typeof r != "string" || i.indexOf(r) === -1 && !a.test(r) && (r.charAt(0) !== r.charAt(r.length - 1) || r.charAt(0) !== '"' && r.charAt(0) !== "'")) && bI("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"".concat(r, "\"'`."), n);
  }
}, EQ = function(e, r, n) {
  e === "animation" && n.hashId && r !== "none" && bI("You seem to be using hashed animation '".concat(r, "', in which case 'animationName' with Keyframe as value is recommended."), n);
}, YA = "data-ant-cssinjs-cache-path", xI = "_FILE_STYLE__", Wl, wI = !0;
function TQ() {
  if (!Wl && (Wl = {}, po())) {
    var t = document.createElement("div");
    t.className = YA, t.style.position = "fixed", t.style.visibility = "hidden", t.style.top = "-9999px", document.body.appendChild(t);
    var e = getComputedStyle(t).content || "";
    e = e.replace(/^"/, "").replace(/"$/, ""), e.split(";").forEach(function(a) {
      var i = a.split(":"), s = bt(i, 2), o = s[0], l = s[1];
      Wl[o] = l;
    });
    var r = document.querySelector("style[".concat(YA, "]"));
    if (r) {
      var n;
      wI = !1, (n = r.parentNode) === null || n === void 0 || n.removeChild(r);
    }
    document.body.removeChild(t);
  }
}
function SQ(t) {
  return TQ(), !!Wl[t];
}
function CQ(t) {
  var e = Wl[t], r = null;
  if (e && po())
    if (wI)
      r = xI;
    else {
      var n = document.querySelector("style[".concat(Gi, '="').concat(Wl[t], '"]'));
      n ? r = n.innerHTML : delete Wl[t];
    }
  return [r, e];
}
var EI = "_skip_check_", TI = "_multi_value_";
function Zg(t) {
  var e = Wc(LE(t), NE);
  return e.replace(/\{%%%\:[^;];}/g, ";");
}
function AQ(t) {
  return Tt(t) === "object" && t && (EI in t || TI in t);
}
function XA(t, e, r) {
  if (!e)
    return t;
  var n = ".".concat(e), a = r === "low" ? ":where(".concat(n, ")") : n, i = t.split(",").map(function(s) {
    var o, l = s.trim().split(/\s+/), u = l[0] || "", c = ((o = u.match(/^\w+/)) === null || o === void 0 ? void 0 : o[0]) || "";
    return u = "".concat(c).concat(a).concat(u.slice(c.length)), [u].concat(Ot(l.slice(1))).join(" ");
  });
  return i.join(",");
}
var kQ = function t(e) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
    root: !0,
    parentSelectors: []
  }, a = n.root, i = n.injectHash, s = n.parentSelectors, o = r.hashId, l = r.layer, u = r.path, c = r.hashPriority, f = r.transformers, h = f === void 0 ? [] : f, d = r.linters, p = d === void 0 ? [] : d, g = "", v = {};
  function m(x) {
    var E = x.getName(o);
    if (!v[E]) {
      var S = t(x.style, r, {
        root: !1,
        parentSelectors: s
      }), w = bt(S, 1), C = w[0];
      v[E] = "@keyframes ".concat(x.getName(o)).concat(C);
    }
  }
  function b(x) {
    var E = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    return x.forEach(function(S) {
      Array.isArray(S) ? b(S, E) : S && E.push(S);
    }), E;
  }
  var y = b(Array.isArray(e) ? e : [e]);
  return y.forEach(function(x) {
    var E = typeof x == "string" && !a ? {} : x;
    if (typeof E == "string")
      g += "".concat(E, `
`);
    else if (E._keyframe)
      m(E);
    else {
      var S = h.reduce(function(w, C) {
        var k;
        return (C == null || (k = C.visit) === null || k === void 0 ? void 0 : k.call(C, w)) || w;
      }, E);
      Object.keys(S).forEach(function(w) {
        var C = S[w];
        if (Tt(C) === "object" && C && (w !== "animationName" || !C._keyframe) && !AQ(C)) {
          var k = !1, N = w.trim(), R = !1;
          (a || i) && o ? N.startsWith("@") ? k = !0 : N === "&" ? N = XA("", o, c) : N = XA(w, o, c) : a && !o && (N === "&" || N === "") && (N = "", R = !0);
          var _ = t(C, r, {
            root: R,
            injectHash: k,
            parentSelectors: [].concat(Ot(s), [N])
          }), O = bt(_, 2), T = O[0], L = O[1];
          v = ke(ke({}, v), L), g += "".concat(N).concat(T);
        } else {
          let I = function(D, F) {
            process.env.NODE_ENV !== "production" && (Tt(C) !== "object" || !(C != null && C[EI])) && [wQ, EQ].concat(Ot(p)).forEach(function(H) {
              return H(D, F, {
                path: u,
                hashId: o,
                parentSelectors: s
              });
            });
            var B = D.replace(/[A-Z]/g, function(H) {
              return "-".concat(H.toLowerCase());
            }), G = F;
            !YO[D] && typeof G == "number" && G !== 0 && (G = "".concat(G, "px")), D === "animationName" && F !== null && F !== void 0 && F._keyframe && (m(F), G = F.getName(o)), g += "".concat(B, ":").concat(G, ";");
          };
          var M, A = (M = C == null ? void 0 : C.value) !== null && M !== void 0 ? M : C;
          Tt(C) === "object" && C !== null && C !== void 0 && C[TI] && Array.isArray(A) ? A.forEach(function(D) {
            I(w, D);
          }) : I(w, A);
        }
      });
    }
  }), a ? l && (g && (g = "@layer ".concat(l.name, " {").concat(g, "}")), l.dependencies && (v["@layer ".concat(l.name)] = l.dependencies.map(function(x) {
    return "@layer ".concat(x, ", ").concat(l.name, ";");
  }).join(`
`))) : g = "{".concat(g, "}"), [g, v];
};
function SI(t, e) {
  return Bi("".concat(t.join("%")).concat(e));
}
function RQ() {
  return null;
}
var CI = "style";
function GE(t, e) {
  var r = t.token, n = t.path, a = t.hashId, i = t.layer, s = t.nonce, o = t.clientOnly, l = t.order, u = l === void 0 ? 0 : l, c = de.useContext(F0), f = c.autoClear, h = c.mock, d = c.defaultCache, p = c.hashPriority, g = c.container, v = c.ssrInline, m = c.transformers, b = c.linters, y = c.cache, x = c.layer, E = r._tokenKey, S = [E];
  x && S.push("layer"), S.push.apply(S, Ot(n));
  var w = BE;
  process.env.NODE_ENV !== "production" && h !== void 0 && (w = h === "client");
  var C = e5(
    CI,
    S,
    // Create cache if needed
    function() {
      var O = S.join("|");
      if (SQ(O)) {
        var T = CQ(O), L = bt(T, 2), M = L[0], A = L[1];
        if (M)
          return [M, E, A, {}, o, u];
      }
      var I = e(), D = kQ(I, {
        hashId: a,
        hashPriority: p,
        layer: x ? i : void 0,
        path: n.join("-"),
        transformers: m,
        linters: b
      }), F = bt(D, 2), B = F[0], G = F[1], H = Zg(B), K = SI(S, H);
      return [H, E, K, G, o, u];
    },
    // Remove cache if no need
    function(O, T) {
      var L = bt(O, 3), M = L[2];
      (T || f) && BE && gI(M, {
        mark: Gi
      });
    },
    // Effect: Inject style here
    function(O) {
      var T = bt(O, 4), L = T[0];
      T[1];
      var M = T[2], A = T[3];
      if (w && L !== xI) {
        var I = {
          mark: Gi,
          prepend: x ? !1 : "queue",
          attachTo: g,
          priority: u
        }, D = typeof s == "function" ? s() : s;
        D && (I.csp = {
          nonce: D
        });
        var F = [], B = [];
        Object.keys(A).forEach(function(H) {
          H.startsWith("@layer") ? F.push(H) : B.push(H);
        }), F.forEach(function(H) {
          ql(Zg(A[H]), "_layer-".concat(H), ke(ke({}, I), {}, {
            prepend: !0
          }));
        });
        var G = ql(L, M, I);
        G[No] = y.instanceId, G.setAttribute(jc, E), process.env.NODE_ENV !== "production" && G.setAttribute(YZ, S.join("|")), B.forEach(function(H) {
          ql(Zg(A[H]), "_effect-".concat(H), I);
        });
      }
    }
  ), k = bt(C, 3), N = k[0], R = k[1], _ = k[2];
  return function(O) {
    var T;
    if (!v || w || !d)
      T = /* @__PURE__ */ de.createElement(RQ, null);
    else {
      var L;
      T = /* @__PURE__ */ de.createElement("style", Ra({}, (L = {}, pe(L, jc, R), pe(L, Gi, _), L), {
        dangerouslySetInnerHTML: {
          __html: N
        }
      }));
    }
    return /* @__PURE__ */ de.createElement(de.Fragment, null, T, O);
  };
}
var MQ = function(e, r, n) {
  var a = bt(e, 6), i = a[0], s = a[1], o = a[2], l = a[3], u = a[4], c = a[5], f = n || {}, h = f.plain;
  if (u)
    return null;
  var d = i, p = {
    "data-rc-order": "prependQueue",
    "data-rc-priority": "".concat(c)
  };
  return d = Gv(i, s, o, p, h), l && Object.keys(l).forEach(function(g) {
    if (!r[g]) {
      r[g] = !0;
      var v = Zg(l[g]), m = Gv(v, s, "_effect-".concat(g), p, h);
      g.startsWith("@layer") ? d = m + d : d += m;
    }
  }), [c, o, d];
}, AI = "cssVar", _Q = function(e, r) {
  var n = e.key, a = e.prefix, i = e.unitless, s = e.ignore, o = e.token, l = e.scope, u = l === void 0 ? "" : l, c = qi(F0), f = c.cache.instanceId, h = c.container, d = o._tokenKey, p = [].concat(Ot(e.path), [n, u, d]), g = e5(AI, p, function() {
    var v = r(), m = mI(v, n, {
      prefix: a,
      unitless: i,
      ignore: s,
      scope: u
    }), b = bt(m, 2), y = b[0], x = b[1], E = SI(p, x);
    return [y, x, E, n];
  }, function(v) {
    var m = bt(v, 3), b = m[2];
    BE && gI(b, {
      mark: Gi
    });
  }, function(v) {
    var m = bt(v, 3), b = m[1], y = m[2];
    if (b) {
      var x = ql(b, y, {
        mark: Gi,
        prepend: "queue",
        attachTo: h,
        priority: -999
      });
      x[No] = f, x.setAttribute(jc, n);
    }
  });
  return g;
}, LQ = function(e, r, n) {
  var a = bt(e, 4), i = a[1], s = a[2], o = a[3], l = n || {}, u = l.plain;
  if (!i)
    return null;
  var c = -999, f = {
    "data-rc-order": "prependQueue",
    "data-rc-priority": "".concat(c)
  }, h = Gv(i, o, s, f, u);
  return [c, s, h];
}, Hf;
Hf = {}, pe(Hf, CI, MQ), pe(Hf, yI, xQ), pe(Hf, AI, LQ);
function Fu(t) {
  return t.notSplit = !0, t;
}
Fu(["borderTop", "borderBottom"]), Fu(["borderTop"]), Fu(["borderBottom"]), Fu(["borderLeft", "borderRight"]), Fu(["borderLeft"]), Fu(["borderRight"]);
const NQ = "5.24.5", kI = {
  blue: "#1677FF",
  purple: "#722ED1",
  cyan: "#13C2C2",
  green: "#52C41A",
  magenta: "#EB2F96",
  /**
   * @deprecated Use magenta instead
   */
  pink: "#EB2F96",
  red: "#F5222D",
  orange: "#FA8C16",
  yellow: "#FADB14",
  volcano: "#FA541C",
  geekblue: "#2F54EB",
  gold: "#FAAD14",
  lime: "#A0D911"
}, Ud = Object.assign(Object.assign({}, kI), {
  // Color
  colorPrimary: "#1677ff",
  colorSuccess: "#52c41a",
  colorWarning: "#faad14",
  colorError: "#ff4d4f",
  colorInfo: "#1677ff",
  colorLink: "",
  colorTextBase: "",
  colorBgBase: "",
  // Font
  fontFamily: `-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
'Noto Color Emoji'`,
  fontFamilyCode: "'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace",
  fontSize: 14,
  // Line
  lineWidth: 1,
  lineType: "solid",
  // Motion
  motionUnit: 0.1,
  motionBase: 0,
  motionEaseOutCirc: "cubic-bezier(0.08, 0.82, 0.17, 1)",
  motionEaseInOutCirc: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
  motionEaseOut: "cubic-bezier(0.215, 0.61, 0.355, 1)",
  motionEaseInOut: "cubic-bezier(0.645, 0.045, 0.355, 1)",
  motionEaseOutBack: "cubic-bezier(0.12, 0.4, 0.29, 1.46)",
  motionEaseInBack: "cubic-bezier(0.71, -0.46, 0.88, 0.6)",
  motionEaseInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
  motionEaseOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
  // Radius
  borderRadius: 6,
  // Size
  sizeUnit: 4,
  sizeStep: 4,
  sizePopupArrow: 16,
  // Control Base
  controlHeight: 32,
  // zIndex
  zIndexBase: 0,
  zIndexPopupBase: 1e3,
  // Image
  opacityImage: 1,
  // Wireframe
  wireframe: !1,
  // Motion
  motion: !0
}), Sn = Math.round;
function zb(t, e) {
  const r = t.replace(/^[^(]*\((.*)/, "$1").replace(/\).*/, "").match(/\d*\.?\d+%?/g) || [], n = r.map((a) => parseFloat(a));
  for (let a = 0; a < 3; a += 1)
    n[a] = e(n[a] || 0, r[a] || "", a);
  return r[3] ? n[3] = r[3].includes("%") ? n[3] / 100 : n[3] : n[3] = 1, n;
}
const KA = (t, e, r) => r === 0 ? t : t / 100;
function Vf(t, e) {
  const r = e || 255;
  return t > r ? r : t < 0 ? 0 : t;
}
class rn {
  constructor(e) {
    pe(this, "isValid", !0), pe(this, "r", 0), pe(this, "g", 0), pe(this, "b", 0), pe(this, "a", 1), pe(this, "_h", void 0), pe(this, "_s", void 0), pe(this, "_l", void 0), pe(this, "_v", void 0), pe(this, "_max", void 0), pe(this, "_min", void 0), pe(this, "_brightness", void 0);
    function r(n) {
      return n[0] in e && n[1] in e && n[2] in e;
    }
    if (e) if (typeof e == "string") {
      let a = function(i) {
        return n.startsWith(i);
      };
      const n = e.trim();
      /^#?[A-F\d]{3,8}$/i.test(n) ? this.fromHexString(n) : a("rgb") ? this.fromRgbString(n) : a("hsl") ? this.fromHslString(n) : (a("hsv") || a("hsb")) && this.fromHsvString(n);
    } else if (e instanceof rn)
      this.r = e.r, this.g = e.g, this.b = e.b, this.a = e.a, this._h = e._h, this._s = e._s, this._l = e._l, this._v = e._v;
    else if (r("rgb"))
      this.r = Vf(e.r), this.g = Vf(e.g), this.b = Vf(e.b), this.a = typeof e.a == "number" ? Vf(e.a, 1) : 1;
    else if (r("hsl"))
      this.fromHsl(e);
    else if (r("hsv"))
      this.fromHsv(e);
    else
      throw new Error("@ant-design/fast-color: unsupported input " + JSON.stringify(e));
  }
  // ======================= Setter =======================
  setR(e) {
    return this._sc("r", e);
  }
  setG(e) {
    return this._sc("g", e);
  }
  setB(e) {
    return this._sc("b", e);
  }
  setA(e) {
    return this._sc("a", e, 1);
  }
  setHue(e) {
    const r = this.toHsv();
    return r.h = e, this._c(r);
  }
  // ======================= Getter =======================
  /**
   * Returns the perceived luminance of a color, from 0-1.
   * @see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
   */
  getLuminance() {
    function e(i) {
      const s = i / 255;
      return s <= 0.03928 ? s / 12.92 : Math.pow((s + 0.055) / 1.055, 2.4);
    }
    const r = e(this.r), n = e(this.g), a = e(this.b);
    return 0.2126 * r + 0.7152 * n + 0.0722 * a;
  }
  getHue() {
    if (typeof this._h > "u") {
      const e = this.getMax() - this.getMin();
      e === 0 ? this._h = 0 : this._h = Sn(60 * (this.r === this.getMax() ? (this.g - this.b) / e + (this.g < this.b ? 6 : 0) : this.g === this.getMax() ? (this.b - this.r) / e + 2 : (this.r - this.g) / e + 4));
    }
    return this._h;
  }
  getSaturation() {
    if (typeof this._s > "u") {
      const e = this.getMax() - this.getMin();
      e === 0 ? this._s = 0 : this._s = e / this.getMax();
    }
    return this._s;
  }
  getLightness() {
    return typeof this._l > "u" && (this._l = (this.getMax() + this.getMin()) / 510), this._l;
  }
  getValue() {
    return typeof this._v > "u" && (this._v = this.getMax() / 255), this._v;
  }
  /**
   * Returns the perceived brightness of the color, from 0-255.
   * Note: this is not the b of HSB
   * @see http://www.w3.org/TR/AERT#color-contrast
   */
  getBrightness() {
    return typeof this._brightness > "u" && (this._brightness = (this.r * 299 + this.g * 587 + this.b * 114) / 1e3), this._brightness;
  }
  // ======================== Func ========================
  darken(e = 10) {
    const r = this.getHue(), n = this.getSaturation();
    let a = this.getLightness() - e / 100;
    return a < 0 && (a = 0), this._c({
      h: r,
      s: n,
      l: a,
      a: this.a
    });
  }
  lighten(e = 10) {
    const r = this.getHue(), n = this.getSaturation();
    let a = this.getLightness() + e / 100;
    return a > 1 && (a = 1), this._c({
      h: r,
      s: n,
      l: a,
      a: this.a
    });
  }
  /**
   * Mix the current color a given amount with another color, from 0 to 100.
   * 0 means no mixing (return current color).
   */
  mix(e, r = 50) {
    const n = this._c(e), a = r / 100, i = (o) => (n[o] - this[o]) * a + this[o], s = {
      r: Sn(i("r")),
      g: Sn(i("g")),
      b: Sn(i("b")),
      a: Sn(i("a") * 100) / 100
    };
    return this._c(s);
  }
  /**
   * Mix the color with pure white, from 0 to 100.
   * Providing 0 will do nothing, providing 100 will always return white.
   */
  tint(e = 10) {
    return this.mix({
      r: 255,
      g: 255,
      b: 255,
      a: 1
    }, e);
  }
  /**
   * Mix the color with pure black, from 0 to 100.
   * Providing 0 will do nothing, providing 100 will always return black.
   */
  shade(e = 10) {
    return this.mix({
      r: 0,
      g: 0,
      b: 0,
      a: 1
    }, e);
  }
  onBackground(e) {
    const r = this._c(e), n = this.a + r.a * (1 - this.a), a = (i) => Sn((this[i] * this.a + r[i] * r.a * (1 - this.a)) / n);
    return this._c({
      r: a("r"),
      g: a("g"),
      b: a("b"),
      a: n
    });
  }
  // ======================= Status =======================
  isDark() {
    return this.getBrightness() < 128;
  }
  isLight() {
    return this.getBrightness() >= 128;
  }
  // ======================== MISC ========================
  equals(e) {
    return this.r === e.r && this.g === e.g && this.b === e.b && this.a === e.a;
  }
  clone() {
    return this._c(this);
  }
  // ======================= Format =======================
  toHexString() {
    let e = "#";
    const r = (this.r || 0).toString(16);
    e += r.length === 2 ? r : "0" + r;
    const n = (this.g || 0).toString(16);
    e += n.length === 2 ? n : "0" + n;
    const a = (this.b || 0).toString(16);
    if (e += a.length === 2 ? a : "0" + a, typeof this.a == "number" && this.a >= 0 && this.a < 1) {
      const i = Sn(this.a * 255).toString(16);
      e += i.length === 2 ? i : "0" + i;
    }
    return e;
  }
  /** CSS support color pattern */
  toHsl() {
    return {
      h: this.getHue(),
      s: this.getSaturation(),
      l: this.getLightness(),
      a: this.a
    };
  }
  /** CSS support color pattern */
  toHslString() {
    const e = this.getHue(), r = Sn(this.getSaturation() * 100), n = Sn(this.getLightness() * 100);
    return this.a !== 1 ? `hsla(${e},${r}%,${n}%,${this.a})` : `hsl(${e},${r}%,${n}%)`;
  }
  /** Same as toHsb */
  toHsv() {
    return {
      h: this.getHue(),
      s: this.getSaturation(),
      v: this.getValue(),
      a: this.a
    };
  }
  toRgb() {
    return {
      r: this.r,
      g: this.g,
      b: this.b,
      a: this.a
    };
  }
  toRgbString() {
    return this.a !== 1 ? `rgba(${this.r},${this.g},${this.b},${this.a})` : `rgb(${this.r},${this.g},${this.b})`;
  }
  toString() {
    return this.toRgbString();
  }
  // ====================== Privates ======================
  /** Return a new FastColor object with one channel changed */
  _sc(e, r, n) {
    const a = this.clone();
    return a[e] = Vf(r, n), a;
  }
  _c(e) {
    return new this.constructor(e);
  }
  getMax() {
    return typeof this._max > "u" && (this._max = Math.max(this.r, this.g, this.b)), this._max;
  }
  getMin() {
    return typeof this._min > "u" && (this._min = Math.min(this.r, this.g, this.b)), this._min;
  }
  fromHexString(e) {
    const r = e.replace("#", "");
    function n(a, i) {
      return parseInt(r[a] + r[i || a], 16);
    }
    r.length < 6 ? (this.r = n(0), this.g = n(1), this.b = n(2), this.a = r[3] ? n(3) / 255 : 1) : (this.r = n(0, 1), this.g = n(2, 3), this.b = n(4, 5), this.a = r[6] ? n(6, 7) / 255 : 1);
  }
  fromHsl({
    h: e,
    s: r,
    l: n,
    a
  }) {
    if (this._h = e % 360, this._s = r, this._l = n, this.a = typeof a == "number" ? a : 1, r <= 0) {
      const h = Sn(n * 255);
      this.r = h, this.g = h, this.b = h;
    }
    let i = 0, s = 0, o = 0;
    const l = e / 60, u = (1 - Math.abs(2 * n - 1)) * r, c = u * (1 - Math.abs(l % 2 - 1));
    l >= 0 && l < 1 ? (i = u, s = c) : l >= 1 && l < 2 ? (i = c, s = u) : l >= 2 && l < 3 ? (s = u, o = c) : l >= 3 && l < 4 ? (s = c, o = u) : l >= 4 && l < 5 ? (i = c, o = u) : l >= 5 && l < 6 && (i = u, o = c);
    const f = n - u / 2;
    this.r = Sn((i + f) * 255), this.g = Sn((s + f) * 255), this.b = Sn((o + f) * 255);
  }
  fromHsv({
    h: e,
    s: r,
    v: n,
    a
  }) {
    this._h = e % 360, this._s = r, this._v = n, this.a = typeof a == "number" ? a : 1;
    const i = Sn(n * 255);
    if (this.r = i, this.g = i, this.b = i, r <= 0)
      return;
    const s = e / 60, o = Math.floor(s), l = s - o, u = Sn(n * (1 - r) * 255), c = Sn(n * (1 - r * l) * 255), f = Sn(n * (1 - r * (1 - l)) * 255);
    switch (o) {
      case 0:
        this.g = f, this.b = u;
        break;
      case 1:
        this.r = c, this.b = u;
        break;
      case 2:
        this.r = u, this.b = f;
        break;
      case 3:
        this.r = u, this.g = c;
        break;
      case 4:
        this.r = f, this.g = u;
        break;
      case 5:
      default:
        this.g = u, this.b = c;
        break;
    }
  }
  fromHsvString(e) {
    const r = zb(e, KA);
    this.fromHsv({
      h: r[0],
      s: r[1],
      v: r[2],
      a: r[3]
    });
  }
  fromHslString(e) {
    const r = zb(e, KA);
    this.fromHsl({
      h: r[0],
      s: r[1],
      l: r[2],
      a: r[3]
    });
  }
  fromRgbString(e) {
    const r = zb(e, (n, a) => (
      // Convert percentage to number. e.g. 50% -> 128
      a.includes("%") ? Sn(n / 100 * 255) : n
    ));
    this.r = r[0], this.g = r[1], this.b = r[2], this.a = r[3];
  }
}
var Np = 2, ZA = 0.16, OQ = 0.05, IQ = 0.05, PQ = 0.15, RI = 5, MI = 4, DQ = [{
  index: 7,
  amount: 15
}, {
  index: 6,
  amount: 25
}, {
  index: 5,
  amount: 30
}, {
  index: 5,
  amount: 45
}, {
  index: 5,
  amount: 65
}, {
  index: 5,
  amount: 85
}, {
  index: 4,
  amount: 90
}, {
  index: 3,
  amount: 95
}, {
  index: 2,
  amount: 97
}, {
  index: 1,
  amount: 98
}];
function QA(t, e, r) {
  var n;
  return Math.round(t.h) >= 60 && Math.round(t.h) <= 240 ? n = r ? Math.round(t.h) - Np * e : Math.round(t.h) + Np * e : n = r ? Math.round(t.h) + Np * e : Math.round(t.h) - Np * e, n < 0 ? n += 360 : n >= 360 && (n -= 360), n;
}
function JA(t, e, r) {
  if (t.h === 0 && t.s === 0)
    return t.s;
  var n;
  return r ? n = t.s - ZA * e : e === MI ? n = t.s + ZA : n = t.s + OQ * e, n > 1 && (n = 1), r && e === RI && n > 0.1 && (n = 0.1), n < 0.06 && (n = 0.06), Math.round(n * 100) / 100;
}
function ek(t, e, r) {
  var n;
  return r ? n = t.v + IQ * e : n = t.v - PQ * e, n = Math.max(0, Math.min(1, n)), Math.round(n * 100) / 100;
}
function Hd(t) {
  for (var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = [], n = new rn(t), a = n.toHsv(), i = RI; i > 0; i -= 1) {
    var s = new rn({
      h: QA(a, i, !0),
      s: JA(a, i, !0),
      v: ek(a, i, !0)
    });
    r.push(s);
  }
  r.push(n);
  for (var o = 1; o <= MI; o += 1) {
    var l = new rn({
      h: QA(a, o),
      s: JA(a, o),
      v: ek(a, o)
    });
    r.push(l);
  }
  return e.theme === "dark" ? DQ.map(function(u) {
    var c = u.index, f = u.amount;
    return new rn(e.backgroundColor || "#141414").mix(r[c], f).toHexString();
  }) : r.map(function(u) {
    return u.toHexString();
  });
}
var Gb = {
  red: "#F5222D",
  volcano: "#FA541C",
  orange: "#FA8C16",
  gold: "#FAAD14",
  yellow: "#FADB14",
  lime: "#A0D911",
  green: "#52C41A",
  cyan: "#13C2C2",
  blue: "#1677FF",
  geekblue: "#2F54EB",
  purple: "#722ED1",
  magenta: "#EB2F96",
  grey: "#666666"
}, UE = ["#fff1f0", "#ffccc7", "#ffa39e", "#ff7875", "#ff4d4f", "#f5222d", "#cf1322", "#a8071a", "#820014", "#5c0011"];
UE.primary = UE[5];
var HE = ["#fff2e8", "#ffd8bf", "#ffbb96", "#ff9c6e", "#ff7a45", "#fa541c", "#d4380d", "#ad2102", "#871400", "#610b00"];
HE.primary = HE[5];
var VE = ["#fff7e6", "#ffe7ba", "#ffd591", "#ffc069", "#ffa940", "#fa8c16", "#d46b08", "#ad4e00", "#873800", "#612500"];
VE.primary = VE[5];
var qE = ["#fffbe6", "#fff1b8", "#ffe58f", "#ffd666", "#ffc53d", "#faad14", "#d48806", "#ad6800", "#874d00", "#613400"];
qE.primary = qE[5];
var WE = ["#feffe6", "#ffffb8", "#fffb8f", "#fff566", "#ffec3d", "#fadb14", "#d4b106", "#ad8b00", "#876800", "#614700"];
WE.primary = WE[5];
var jE = ["#fcffe6", "#f4ffb8", "#eaff8f", "#d3f261", "#bae637", "#a0d911", "#7cb305", "#5b8c00", "#3f6600", "#254000"];
jE.primary = jE[5];
var YE = ["#f6ffed", "#d9f7be", "#b7eb8f", "#95de64", "#73d13d", "#52c41a", "#389e0d", "#237804", "#135200", "#092b00"];
YE.primary = YE[5];
var XE = ["#e6fffb", "#b5f5ec", "#87e8de", "#5cdbd3", "#36cfc9", "#13c2c2", "#08979c", "#006d75", "#00474f", "#002329"];
XE.primary = XE[5];
var Uv = ["#e6f4ff", "#bae0ff", "#91caff", "#69b1ff", "#4096ff", "#1677ff", "#0958d9", "#003eb3", "#002c8c", "#001d66"];
Uv.primary = Uv[5];
var KE = ["#f0f5ff", "#d6e4ff", "#adc6ff", "#85a5ff", "#597ef7", "#2f54eb", "#1d39c4", "#10239e", "#061178", "#030852"];
KE.primary = KE[5];
var ZE = ["#f9f0ff", "#efdbff", "#d3adf7", "#b37feb", "#9254de", "#722ed1", "#531dab", "#391085", "#22075e", "#120338"];
ZE.primary = ZE[5];
var QE = ["#fff0f6", "#ffd6e7", "#ffadd2", "#ff85c0", "#f759ab", "#eb2f96", "#c41d7f", "#9e1068", "#780650", "#520339"];
QE.primary = QE[5];
var JE = ["#a6a6a6", "#999999", "#8c8c8c", "#808080", "#737373", "#666666", "#404040", "#1a1a1a", "#000000", "#000000"];
JE.primary = JE[5];
var Ub = {
  red: UE,
  volcano: HE,
  orange: VE,
  gold: qE,
  yellow: WE,
  lime: jE,
  green: YE,
  cyan: XE,
  blue: Uv,
  geekblue: KE,
  purple: ZE,
  magenta: QE,
  grey: JE
};
function $Q(t, e) {
  let {
    generateColorPalettes: r,
    generateNeutralColorPalettes: n
  } = e;
  const {
    colorSuccess: a,
    colorWarning: i,
    colorError: s,
    colorInfo: o,
    colorPrimary: l,
    colorBgBase: u,
    colorTextBase: c
  } = t, f = r(l), h = r(a), d = r(i), p = r(s), g = r(o), v = n(u, c), m = t.colorLink || t.colorInfo, b = r(m), y = new rn(p[1]).mix(new rn(p[3]), 50).toHexString();
  return Object.assign(Object.assign({}, v), {
    colorPrimaryBg: f[1],
    colorPrimaryBgHover: f[2],
    colorPrimaryBorder: f[3],
    colorPrimaryBorderHover: f[4],
    colorPrimaryHover: f[5],
    colorPrimary: f[6],
    colorPrimaryActive: f[7],
    colorPrimaryTextHover: f[8],
    colorPrimaryText: f[9],
    colorPrimaryTextActive: f[10],
    colorSuccessBg: h[1],
    colorSuccessBgHover: h[2],
    colorSuccessBorder: h[3],
    colorSuccessBorderHover: h[4],
    colorSuccessHover: h[4],
    colorSuccess: h[6],
    colorSuccessActive: h[7],
    colorSuccessTextHover: h[8],
    colorSuccessText: h[9],
    colorSuccessTextActive: h[10],
    colorErrorBg: p[1],
    colorErrorBgHover: p[2],
    colorErrorBgFilledHover: y,
    colorErrorBgActive: p[3],
    colorErrorBorder: p[3],
    colorErrorBorderHover: p[4],
    colorErrorHover: p[5],
    colorError: p[6],
    colorErrorActive: p[7],
    colorErrorTextHover: p[8],
    colorErrorText: p[9],
    colorErrorTextActive: p[10],
    colorWarningBg: d[1],
    colorWarningBgHover: d[2],
    colorWarningBorder: d[3],
    colorWarningBorderHover: d[4],
    colorWarningHover: d[4],
    colorWarning: d[6],
    colorWarningActive: d[7],
    colorWarningTextHover: d[8],
    colorWarningText: d[9],
    colorWarningTextActive: d[10],
    colorInfoBg: g[1],
    colorInfoBgHover: g[2],
    colorInfoBorder: g[3],
    colorInfoBorderHover: g[4],
    colorInfoHover: g[4],
    colorInfo: g[6],
    colorInfoActive: g[7],
    colorInfoTextHover: g[8],
    colorInfoText: g[9],
    colorInfoTextActive: g[10],
    colorLinkHover: b[4],
    colorLink: b[6],
    colorLinkActive: b[7],
    colorBgMask: new rn("#000").setA(0.45).toRgbString(),
    colorWhite: "#fff"
  });
}
const FQ = (t) => {
  let e = t, r = t, n = t, a = t;
  return t < 6 && t >= 5 ? e = t + 1 : t < 16 && t >= 6 ? e = t + 2 : t >= 16 && (e = 16), t < 7 && t >= 5 ? r = 4 : t < 8 && t >= 7 ? r = 5 : t < 14 && t >= 8 ? r = 6 : t < 16 && t >= 14 ? r = 7 : t >= 16 && (r = 8), t < 6 && t >= 2 ? n = 1 : t >= 6 && (n = 2), t > 4 && t < 8 ? a = 4 : t >= 8 && (a = 6), {
    borderRadius: t,
    borderRadiusXS: n,
    borderRadiusSM: r,
    borderRadiusLG: e,
    borderRadiusOuter: a
  };
};
function BQ(t) {
  const {
    motionUnit: e,
    motionBase: r,
    borderRadius: n,
    lineWidth: a
  } = t;
  return Object.assign({
    // motion
    motionDurationFast: `${(r + e).toFixed(1)}s`,
    motionDurationMid: `${(r + e * 2).toFixed(1)}s`,
    motionDurationSlow: `${(r + e * 3).toFixed(1)}s`,
    // line
    lineWidthBold: a + 1
  }, FQ(n));
}
const zQ = (t) => {
  const {
    controlHeight: e
  } = t;
  return {
    controlHeightSM: e * 0.75,
    controlHeightXS: e * 0.5,
    controlHeightLG: e * 1.25
  };
};
function GQ(t) {
  return (t + 8) / t;
}
function UQ(t) {
  const e = Array.from({
    length: 10
  }).map((r, n) => {
    const a = n - 1, i = t * Math.pow(Math.E, a / 5), s = n > 1 ? Math.floor(i) : Math.ceil(i);
    return Math.floor(s / 2) * 2;
  });
  return e[1] = t, e.map((r) => ({
    size: r,
    lineHeight: GQ(r)
  }));
}
const HQ = (t) => {
  const e = UQ(t), r = e.map((c) => c.size), n = e.map((c) => c.lineHeight), a = r[1], i = r[0], s = r[2], o = n[1], l = n[0], u = n[2];
  return {
    fontSizeSM: i,
    fontSize: a,
    fontSizeLG: s,
    fontSizeXL: r[3],
    fontSizeHeading1: r[6],
    fontSizeHeading2: r[5],
    fontSizeHeading3: r[4],
    fontSizeHeading4: r[3],
    fontSizeHeading5: r[2],
    lineHeight: o,
    lineHeightLG: u,
    lineHeightSM: l,
    fontHeight: Math.round(o * a),
    fontHeightLG: Math.round(u * s),
    fontHeightSM: Math.round(l * i),
    lineHeightHeading1: n[6],
    lineHeightHeading2: n[5],
    lineHeightHeading3: n[4],
    lineHeightHeading4: n[3],
    lineHeightHeading5: n[2]
  };
};
function VQ(t) {
  const {
    sizeUnit: e,
    sizeStep: r
  } = t;
  return {
    sizeXXL: e * (r + 8),
    // 48
    sizeXL: e * (r + 4),
    // 32
    sizeLG: e * (r + 2),
    // 24
    sizeMD: e * (r + 1),
    // 20
    sizeMS: e * r,
    // 16
    size: e * r,
    // 16
    sizeSM: e * (r - 1),
    // 12
    sizeXS: e * (r - 2),
    // 8
    sizeXXS: e * (r - 3)
    // 4
  };
}
const li = (t, e) => new rn(t).setA(e).toRgbString(), qf = (t, e) => new rn(t).darken(e).toHexString(), qQ = (t) => {
  const e = Hd(t);
  return {
    1: e[0],
    2: e[1],
    3: e[2],
    4: e[3],
    5: e[4],
    6: e[5],
    7: e[6],
    8: e[4],
    9: e[5],
    10: e[6]
    // 8: colors[7],
    // 9: colors[8],
    // 10: colors[9],
  };
}, WQ = (t, e) => {
  const r = t || "#fff", n = e || "#000";
  return {
    colorBgBase: r,
    colorTextBase: n,
    colorText: li(n, 0.88),
    colorTextSecondary: li(n, 0.65),
    colorTextTertiary: li(n, 0.45),
    colorTextQuaternary: li(n, 0.25),
    colorFill: li(n, 0.15),
    colorFillSecondary: li(n, 0.06),
    colorFillTertiary: li(n, 0.04),
    colorFillQuaternary: li(n, 0.02),
    colorBgSolid: li(n, 1),
    colorBgSolidHover: li(n, 0.75),
    colorBgSolidActive: li(n, 0.95),
    colorBgLayout: qf(r, 4),
    colorBgContainer: qf(r, 0),
    colorBgElevated: qf(r, 0),
    colorBgSpotlight: li(n, 0.85),
    colorBgBlur: "transparent",
    colorBorder: qf(r, 15),
    colorBorderSecondary: qf(r, 6)
  };
};
function jQ(t) {
  Gb.pink = Gb.magenta, Ub.pink = Ub.magenta;
  const e = Object.keys(kI).map((r) => {
    const n = t[r] === Gb[r] ? Ub[r] : Hd(t[r]);
    return Array.from({
      length: 10
    }, () => 1).reduce((a, i, s) => (a[`${r}-${s + 1}`] = n[s], a[`${r}${s + 1}`] = n[s], a), {});
  }).reduce((r, n) => (r = Object.assign(Object.assign({}, r), n), r), {});
  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, t), e), $Q(t, {
    generateColorPalettes: qQ,
    generateNeutralColorPalettes: WQ
  })), HQ(t.fontSize)), VQ(t)), zQ(t)), BQ(t));
}
const _I = FE(jQ), eT = {
  token: Ud,
  override: {
    override: Ud
  },
  hashed: !0
}, LI = /* @__PURE__ */ lt.createContext(eT);
function Hb(t) {
  return t >= 0 && t <= 255;
}
function Op(t, e) {
  const {
    r,
    g: n,
    b: a,
    a: i
  } = new rn(t).toRgb();
  if (i < 1)
    return t;
  const {
    r: s,
    g: o,
    b: l
  } = new rn(e).toRgb();
  for (let u = 0.01; u <= 1; u += 0.01) {
    const c = Math.round((r - s * (1 - u)) / u), f = Math.round((n - o * (1 - u)) / u), h = Math.round((a - l * (1 - u)) / u);
    if (Hb(c) && Hb(f) && Hb(h))
      return new rn({
        r: c,
        g: f,
        b: h,
        a: Math.round(u * 100) / 100
      }).toRgbString();
  }
  return new rn({
    r,
    g: n,
    b: a,
    a: 1
  }).toRgbString();
}
var YQ = function(t, e) {
  var r = {};
  for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function") for (var a = 0, n = Object.getOwnPropertySymbols(t); a < n.length; a++)
    e.indexOf(n[a]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[a]) && (r[n[a]] = t[n[a]]);
  return r;
};
function NI(t) {
  const {
    override: e
  } = t, r = YQ(t, ["override"]), n = Object.assign({}, e);
  Object.keys(Ud).forEach((h) => {
    delete n[h];
  });
  const a = Object.assign(Object.assign({}, r), n), i = 480, s = 576, o = 768, l = 992, u = 1200, c = 1600;
  if (a.motion === !1) {
    const h = "0s";
    a.motionDurationFast = h, a.motionDurationMid = h, a.motionDurationSlow = h;
  }
  return Object.assign(Object.assign(Object.assign({}, a), {
    // ============== Background ============== //
    colorFillContent: a.colorFillSecondary,
    colorFillContentHover: a.colorFill,
    colorFillAlter: a.colorFillQuaternary,
    colorBgContainerDisabled: a.colorFillTertiary,
    // ============== Split ============== //
    colorBorderBg: a.colorBgContainer,
    colorSplit: Op(a.colorBorderSecondary, a.colorBgContainer),
    // ============== Text ============== //
    colorTextPlaceholder: a.colorTextQuaternary,
    colorTextDisabled: a.colorTextQuaternary,
    colorTextHeading: a.colorText,
    colorTextLabel: a.colorTextSecondary,
    colorTextDescription: a.colorTextTertiary,
    colorTextLightSolid: a.colorWhite,
    colorHighlight: a.colorError,
    colorBgTextHover: a.colorFillSecondary,
    colorBgTextActive: a.colorFill,
    colorIcon: a.colorTextTertiary,
    colorIconHover: a.colorText,
    colorErrorOutline: Op(a.colorErrorBg, a.colorBgContainer),
    colorWarningOutline: Op(a.colorWarningBg, a.colorBgContainer),
    // Font
    fontSizeIcon: a.fontSizeSM,
    // Line
    lineWidthFocus: a.lineWidth * 3,
    // Control
    lineWidth: a.lineWidth,
    controlOutlineWidth: a.lineWidth * 2,
    // Checkbox size and expand icon size
    controlInteractiveSize: a.controlHeight / 2,
    controlItemBgHover: a.colorFillTertiary,
    controlItemBgActive: a.colorPrimaryBg,
    controlItemBgActiveHover: a.colorPrimaryBgHover,
    controlItemBgActiveDisabled: a.colorFill,
    controlTmpOutline: a.colorFillQuaternary,
    controlOutline: Op(a.colorPrimaryBg, a.colorBgContainer),
    lineType: a.lineType,
    borderRadius: a.borderRadius,
    borderRadiusXS: a.borderRadiusXS,
    borderRadiusSM: a.borderRadiusSM,
    borderRadiusLG: a.borderRadiusLG,
    fontWeightStrong: 600,
    opacityLoading: 0.65,
    linkDecoration: "none",
    linkHoverDecoration: "none",
    linkFocusDecoration: "none",
    controlPaddingHorizontal: 12,
    controlPaddingHorizontalSM: 8,
    paddingXXS: a.sizeXXS,
    paddingXS: a.sizeXS,
    paddingSM: a.sizeSM,
    padding: a.size,
    paddingMD: a.sizeMD,
    paddingLG: a.sizeLG,
    paddingXL: a.sizeXL,
    paddingContentHorizontalLG: a.sizeLG,
    paddingContentVerticalLG: a.sizeMS,
    paddingContentHorizontal: a.sizeMS,
    paddingContentVertical: a.sizeSM,
    paddingContentHorizontalSM: a.size,
    paddingContentVerticalSM: a.sizeXS,
    marginXXS: a.sizeXXS,
    marginXS: a.sizeXS,
    marginSM: a.sizeSM,
    margin: a.size,
    marginMD: a.sizeMD,
    marginLG: a.sizeLG,
    marginXL: a.sizeXL,
    marginXXL: a.sizeXXL,
    boxShadow: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowSecondary: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowTertiary: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
    screenXS: i,
    screenXSMin: i,
    screenXSMax: s - 1,
    screenSM: s,
    screenSMMin: s,
    screenSMMax: o - 1,
    screenMD: o,
    screenMDMin: o,
    screenMDMax: l - 1,
    screenLG: l,
    screenLGMin: l,
    screenLGMax: u - 1,
    screenXL: u,
    screenXLMin: u,
    screenXLMax: c - 1,
    screenXXL: c,
    screenXXLMin: c,
    boxShadowPopoverArrow: "2px 2px 5px rgba(0, 0, 0, 0.05)",
    boxShadowCard: `
      0 1px 2px -2px ${new rn("rgba(0, 0, 0, 0.16)").toRgbString()},
      0 3px 6px 0 ${new rn("rgba(0, 0, 0, 0.12)").toRgbString()},
      0 5px 12px 4px ${new rn("rgba(0, 0, 0, 0.09)").toRgbString()}
    `,
    boxShadowDrawerRight: `
      -6px 0 16px 0 rgba(0, 0, 0, 0.08),
      -3px 0 6px -4px rgba(0, 0, 0, 0.12),
      -9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerLeft: `
      6px 0 16px 0 rgba(0, 0, 0, 0.08),
      3px 0 6px -4px rgba(0, 0, 0, 0.12),
      9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerUp: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerDown: `
      0 -6px 16px 0 rgba(0, 0, 0, 0.08),
      0 -3px 6px -4px rgba(0, 0, 0, 0.12),
      0 -9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowTabsOverflowLeft: "inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowRight: "inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowTop: "inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowBottom: "inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)"
  }), n);
}
var tk = function(t, e) {
  var r = {};
  for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function") for (var a = 0, n = Object.getOwnPropertySymbols(t); a < n.length; a++)
    e.indexOf(n[a]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[a]) && (r[n[a]] = t[n[a]]);
  return r;
};
const OI = {
  lineHeight: !0,
  lineHeightSM: !0,
  lineHeightLG: !0,
  lineHeightHeading1: !0,
  lineHeightHeading2: !0,
  lineHeightHeading3: !0,
  lineHeightHeading4: !0,
  lineHeightHeading5: !0,
  opacityLoading: !0,
  fontWeightStrong: !0,
  zIndexPopupBase: !0,
  zIndexBase: !0,
  opacityImage: !0
}, XQ = {
  size: !0,
  sizeSM: !0,
  sizeLG: !0,
  sizeMD: !0,
  sizeXS: !0,
  sizeXXS: !0,
  sizeMS: !0,
  sizeXL: !0,
  sizeXXL: !0,
  sizeUnit: !0,
  sizeStep: !0,
  motionBase: !0,
  motionUnit: !0
}, KQ = {
  screenXS: !0,
  screenXSMin: !0,
  screenXSMax: !0,
  screenSM: !0,
  screenSMMin: !0,
  screenSMMax: !0,
  screenMD: !0,
  screenMDMin: !0,
  screenMDMax: !0,
  screenLG: !0,
  screenLGMin: !0,
  screenLGMax: !0,
  screenXL: !0,
  screenXLMin: !0,
  screenXLMax: !0,
  screenXXL: !0,
  screenXXLMin: !0
}, II = (t, e, r) => {
  const n = r.getDerivativeToken(t), {
    override: a
  } = e, i = tk(e, ["override"]);
  let s = Object.assign(Object.assign({}, n), {
    override: a
  });
  return s = NI(s), i && Object.entries(i).forEach((o) => {
    let [l, u] = o;
    const {
      theme: c
    } = u, f = tk(u, ["theme"]);
    let h = f;
    c && (h = II(Object.assign(Object.assign({}, s), f), {
      override: f
    }, c)), s[l] = h;
  }), s;
};
function n1() {
  const {
    token: t,
    hashed: e,
    theme: r,
    override: n,
    cssVar: a
  } = lt.useContext(LI), i = `${NQ}-${e || ""}`, s = r || _I, [o, l, u] = bQ(s, [Ud, t], {
    salt: i,
    override: n,
    getComputedToken: II,
    // formatToken will not be consumed after 1.15.0 with getComputedToken.
    // But token will break if @ant-design/cssinjs is under 1.15.0 without it
    formatToken: NI,
    cssVar: a && {
      prefix: a.prefix,
      key: a.key,
      unitless: OI,
      ignore: XQ,
      preserve: KQ
    }
  });
  return [s, u, e ? l : "", o, a];
}
function ZQ(t, e) {
  var r = Object.assign({}, t);
  return Array.isArray(e) && e.forEach(function(n) {
    delete r[n];
  }), r;
}
var QQ = `accept acceptCharset accessKey action allowFullScreen allowTransparency
    alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge
    charSet checked classID className colSpan cols content contentEditable contextMenu
    controls coords crossOrigin data dateTime default defer dir disabled download draggable
    encType form formAction formEncType formMethod formNoValidate formTarget frameBorder
    headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity
    is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media
    mediaGroup method min minLength multiple muted name noValidate nonce open
    optimum pattern placeholder poster preload radioGroup readOnly rel required
    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected
    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style
    summary tabIndex target title type useMap value width wmode wrap`, JQ = `onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown
    onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onClick onContextMenu onDoubleClick
    onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown
    onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel
    onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough
    onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata
    onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onError`, eJ = "".concat(QQ, " ").concat(JQ).split(/[\s\n]+/), tJ = "aria-", rJ = "data-";
function rk(t, e) {
  return t.indexOf(e) === 0;
}
function $Me(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r;
  e === !1 ? r = {
    aria: !0,
    data: !0,
    attr: !0
  } : e === !0 ? r = {
    aria: !0
  } : r = ke({}, e);
  var n = {};
  return Object.keys(t).forEach(function(a) {
    // Aria
    (r.aria && (a === "role" || rk(a, tJ)) || // Data
    r.data && rk(a, rJ) || // Attr
    r.attr && eJ.includes(a)) && (n[a] = t[a]);
  }), n;
}
function nJ(t, e) {
  if (t == null) return {};
  var r = {};
  for (var n in t) if ({}.hasOwnProperty.call(t, n)) {
    if (e.indexOf(n) !== -1) continue;
    r[n] = t[n];
  }
  return r;
}
function aJ(t, e) {
  if (t == null) return {};
  var r, n, a = nJ(t, e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t);
    for (n = 0; n < i.length; n++) r = i[n], e.indexOf(r) === -1 && {}.propertyIsEnumerable.call(t, r) && (a[r] = t[r]);
  }
  return a;
}
function tT(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var r = 0, n = Array(e); r < e; r++) n[r] = t[r];
  return n;
}
function iJ(t) {
  if (Array.isArray(t)) return tT(t);
}
function sJ(t) {
  if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
}
function oJ(t, e) {
  if (t) {
    if (typeof t == "string") return tT(t, e);
    var r = {}.toString.call(t).slice(8, -1);
    return r === "Object" && t.constructor && (r = t.constructor.name), r === "Map" || r === "Set" ? Array.from(t) : r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? tT(t, e) : void 0;
  }
}
function lJ() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function rT(t) {
  return iJ(t) || sJ(t) || oJ(t) || lJ();
}
function Vd(t) {
  "@babel/helpers - typeof";
  return Vd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Vd(t);
}
function uJ(t, e) {
  if (Vd(t) != "object" || !t) return t;
  var r = t[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(t, e);
    if (Vd(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function cJ(t) {
  var e = uJ(t, "string");
  return Vd(e) == "symbol" ? e : e + "";
}
function PI(t, e, r) {
  return (e = cJ(e)) in t ? Object.defineProperty(t, e, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = r, t;
}
function nT() {
  return nT = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e];
      for (var n in r) ({}).hasOwnProperty.call(r, n) && (t[n] = r[n]);
    }
    return t;
  }, nT.apply(null, arguments);
}
function nk(t, e) {
  var r = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(t);
    e && (n = n.filter(function(a) {
      return Object.getOwnPropertyDescriptor(t, a).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function ac(t) {
  for (var e = 1; e < arguments.length; e++) {
    var r = arguments[e] != null ? arguments[e] : {};
    e % 2 ? nk(Object(r), !0).forEach(function(n) {
      PI(t, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : nk(Object(r)).forEach(function(n) {
      Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return t;
}
function fJ(t) {
  var e = t.length;
  if (e === 0 || e === 1) return t;
  if (e === 2)
    return [t[0], t[1], "".concat(t[0], ".").concat(t[1]), "".concat(t[1], ".").concat(t[0])];
  if (e === 3)
    return [t[0], t[1], t[2], "".concat(t[0], ".").concat(t[1]), "".concat(t[0], ".").concat(t[2]), "".concat(t[1], ".").concat(t[0]), "".concat(t[1], ".").concat(t[2]), "".concat(t[2], ".").concat(t[0]), "".concat(t[2], ".").concat(t[1]), "".concat(t[0], ".").concat(t[1], ".").concat(t[2]), "".concat(t[0], ".").concat(t[2], ".").concat(t[1]), "".concat(t[1], ".").concat(t[0], ".").concat(t[2]), "".concat(t[1], ".").concat(t[2], ".").concat(t[0]), "".concat(t[2], ".").concat(t[0], ".").concat(t[1]), "".concat(t[2], ".").concat(t[1], ".").concat(t[0])];
  if (e >= 4)
    return [t[0], t[1], t[2], t[3], "".concat(t[0], ".").concat(t[1]), "".concat(t[0], ".").concat(t[2]), "".concat(t[0], ".").concat(t[3]), "".concat(t[1], ".").concat(t[0]), "".concat(t[1], ".").concat(t[2]), "".concat(t[1], ".").concat(t[3]), "".concat(t[2], ".").concat(t[0]), "".concat(t[2], ".").concat(t[1]), "".concat(t[2], ".").concat(t[3]), "".concat(t[3], ".").concat(t[0]), "".concat(t[3], ".").concat(t[1]), "".concat(t[3], ".").concat(t[2]), "".concat(t[0], ".").concat(t[1], ".").concat(t[2]), "".concat(t[0], ".").concat(t[1], ".").concat(t[3]), "".concat(t[0], ".").concat(t[2], ".").concat(t[1]), "".concat(t[0], ".").concat(t[2], ".").concat(t[3]), "".concat(t[0], ".").concat(t[3], ".").concat(t[1]), "".concat(t[0], ".").concat(t[3], ".").concat(t[2]), "".concat(t[1], ".").concat(t[0], ".").concat(t[2]), "".concat(t[1], ".").concat(t[0], ".").concat(t[3]), "".concat(t[1], ".").concat(t[2], ".").concat(t[0]), "".concat(t[1], ".").concat(t[2], ".").concat(t[3]), "".concat(t[1], ".").concat(t[3], ".").concat(t[0]), "".concat(t[1], ".").concat(t[3], ".").concat(t[2]), "".concat(t[2], ".").concat(t[0], ".").concat(t[1]), "".concat(t[2], ".").concat(t[0], ".").concat(t[3]), "".concat(t[2], ".").concat(t[1], ".").concat(t[0]), "".concat(t[2], ".").concat(t[1], ".").concat(t[3]), "".concat(t[2], ".").concat(t[3], ".").concat(t[0]), "".concat(t[2], ".").concat(t[3], ".").concat(t[1]), "".concat(t[3], ".").concat(t[0], ".").concat(t[1]), "".concat(t[3], ".").concat(t[0], ".").concat(t[2]), "".concat(t[3], ".").concat(t[1], ".").concat(t[0]), "".concat(t[3], ".").concat(t[1], ".").concat(t[2]), "".concat(t[3], ".").concat(t[2], ".").concat(t[0]), "".concat(t[3], ".").concat(t[2], ".").concat(t[1]), "".concat(t[0], ".").concat(t[1], ".").concat(t[2], ".").concat(t[3]), "".concat(t[0], ".").concat(t[1], ".").concat(t[3], ".").concat(t[2]), "".concat(t[0], ".").concat(t[2], ".").concat(t[1], ".").concat(t[3]), "".concat(t[0], ".").concat(t[2], ".").concat(t[3], ".").concat(t[1]), "".concat(t[0], ".").concat(t[3], ".").concat(t[1], ".").concat(t[2]), "".concat(t[0], ".").concat(t[3], ".").concat(t[2], ".").concat(t[1]), "".concat(t[1], ".").concat(t[0], ".").concat(t[2], ".").concat(t[3]), "".concat(t[1], ".").concat(t[0], ".").concat(t[3], ".").concat(t[2]), "".concat(t[1], ".").concat(t[2], ".").concat(t[0], ".").concat(t[3]), "".concat(t[1], ".").concat(t[2], ".").concat(t[3], ".").concat(t[0]), "".concat(t[1], ".").concat(t[3], ".").concat(t[0], ".").concat(t[2]), "".concat(t[1], ".").concat(t[3], ".").concat(t[2], ".").concat(t[0]), "".concat(t[2], ".").concat(t[0], ".").concat(t[1], ".").concat(t[3]), "".concat(t[2], ".").concat(t[0], ".").concat(t[3], ".").concat(t[1]), "".concat(t[2], ".").concat(t[1], ".").concat(t[0], ".").concat(t[3]), "".concat(t[2], ".").concat(t[1], ".").concat(t[3], ".").concat(t[0]), "".concat(t[2], ".").concat(t[3], ".").concat(t[0], ".").concat(t[1]), "".concat(t[2], ".").concat(t[3], ".").concat(t[1], ".").concat(t[0]), "".concat(t[3], ".").concat(t[0], ".").concat(t[1], ".").concat(t[2]), "".concat(t[3], ".").concat(t[0], ".").concat(t[2], ".").concat(t[1]), "".concat(t[3], ".").concat(t[1], ".").concat(t[0], ".").concat(t[2]), "".concat(t[3], ".").concat(t[1], ".").concat(t[2], ".").concat(t[0]), "".concat(t[3], ".").concat(t[2], ".").concat(t[0], ".").concat(t[1]), "".concat(t[3], ".").concat(t[2], ".").concat(t[1], ".").concat(t[0])];
}
var Vb = {};
function hJ(t) {
  if (t.length === 0 || t.length === 1) return t;
  var e = t.join(".");
  return Vb[e] || (Vb[e] = fJ(t)), Vb[e];
}
function dJ(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = arguments.length > 2 ? arguments[2] : void 0, n = t.filter(function(i) {
    return i !== "token";
  }), a = hJ(n);
  return a.reduce(function(i, s) {
    return ac(ac({}, i), r[s]);
  }, e);
}
function ak(t) {
  return t.join(" ");
}
function pJ(t, e) {
  var r = 0;
  return function(n) {
    return r += 1, n.map(function(a, i) {
      return DI({
        node: a,
        stylesheet: t,
        useInlineStyles: e,
        key: "code-segment-".concat(r, "-").concat(i)
      });
    });
  };
}
function DI(t) {
  var e = t.node, r = t.stylesheet, n = t.style, a = n === void 0 ? {} : n, i = t.useInlineStyles, s = t.key, o = e.properties, l = e.type, u = e.tagName, c = e.value;
  if (l === "text")
    return c;
  if (u) {
    var f = pJ(r, i), h;
    if (!i)
      h = ac(ac({}, o), {}, {
        className: ak(o.className)
      });
    else {
      var d = Object.keys(r).reduce(function(m, b) {
        return b.split(".").forEach(function(y) {
          m.includes(y) || m.push(y);
        }), m;
      }, []), p = o.className && o.className.includes("token") ? ["token"] : [], g = o.className && p.concat(o.className.filter(function(m) {
        return !d.includes(m);
      }));
      h = ac(ac({}, o), {}, {
        className: ak(g) || void 0,
        style: dJ(o.className, Object.assign({}, o.style, a), r)
      });
    }
    var v = f(e.children);
    return /* @__PURE__ */ lt.createElement(u, nT({
      key: s
    }, h), v);
  }
}
const gJ = function(t, e) {
  var r = t.listLanguages();
  return r.indexOf(e) !== -1;
};
var vJ = ["language", "children", "style", "customStyle", "codeTagProps", "useInlineStyles", "showLineNumbers", "showInlineLineNumbers", "startingLineNumber", "lineNumberContainerStyle", "lineNumberStyle", "wrapLines", "wrapLongLines", "lineProps", "renderer", "PreTag", "CodeTag", "code", "astGenerator"];
function ik(t, e) {
  var r = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(t);
    e && (n = n.filter(function(a) {
      return Object.getOwnPropertyDescriptor(t, a).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function Oo(t) {
  for (var e = 1; e < arguments.length; e++) {
    var r = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ik(Object(r), !0).forEach(function(n) {
      PI(t, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : ik(Object(r)).forEach(function(n) {
      Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return t;
}
var mJ = /\n/g;
function yJ(t) {
  return t.match(mJ);
}
function bJ(t) {
  var e = t.lines, r = t.startingLineNumber, n = t.style;
  return e.map(function(a, i) {
    var s = i + r;
    return /* @__PURE__ */ lt.createElement("span", {
      key: "line-".concat(i),
      className: "react-syntax-highlighter-line-number",
      style: typeof n == "function" ? n(s) : n
    }, "".concat(s, `
`));
  });
}
function xJ(t) {
  var e = t.codeString, r = t.codeStyle, n = t.containerStyle, a = n === void 0 ? {
    float: "left",
    paddingRight: "10px"
  } : n, i = t.numberStyle, s = i === void 0 ? {} : i, o = t.startingLineNumber;
  return /* @__PURE__ */ lt.createElement("code", {
    style: Object.assign({}, r, a)
  }, bJ({
    lines: e.replace(/\n$/, "").split(`
`),
    style: s,
    startingLineNumber: o
  }));
}
function wJ(t) {
  return "".concat(t.toString().length, ".25em");
}
function $I(t, e) {
  return {
    type: "element",
    tagName: "span",
    properties: {
      key: "line-number--".concat(t),
      className: ["comment", "linenumber", "react-syntax-highlighter-line-number"],
      style: e
    },
    children: [{
      type: "text",
      value: t
    }]
  };
}
function FI(t, e, r) {
  var n = {
    display: "inline-block",
    minWidth: wJ(r),
    paddingRight: "1em",
    textAlign: "right",
    userSelect: "none"
  }, a = typeof t == "function" ? t(e) : t, i = Oo(Oo({}, n), a);
  return i;
}
function Qg(t) {
  var e = t.children, r = t.lineNumber, n = t.lineNumberStyle, a = t.largestLineNumber, i = t.showInlineLineNumbers, s = t.lineProps, o = s === void 0 ? {} : s, l = t.className, u = l === void 0 ? [] : l, c = t.showLineNumbers, f = t.wrapLongLines, h = t.wrapLines, d = h === void 0 ? !1 : h, p = d ? Oo({}, typeof o == "function" ? o(r) : o) : {};
  if (p.className = p.className ? [].concat(rT(p.className.trim().split(/\s+/)), rT(u)) : u, r && i) {
    var g = FI(n, r, a);
    e.unshift($I(r, g));
  }
  return f & c && (p.style = Oo({
    display: "flex"
  }, p.style)), {
    type: "element",
    tagName: "span",
    properties: p,
    children: e
  };
}
function BI(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  t.length === void 0 && (t = [t]);
  for (var n = 0; n < t.length; n++) {
    var a = t[n];
    if (a.type === "text")
      r.push(Qg({
        children: [a],
        className: rT(new Set(e))
      }));
    else if (a.children) {
      var i, s = e.concat(((i = a.properties) === null || i === void 0 ? void 0 : i.className) || []);
      BI(a.children, s).forEach(function(o) {
        return r.push(o);
      });
    }
  }
  return r;
}
function EJ(t, e, r, n, a, i, s, o, l) {
  var u, c = BI(t.value), f = [], h = -1, d = 0;
  function p(E, S) {
    var w = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    return Qg({
      children: E,
      lineNumber: S,
      lineNumberStyle: o,
      largestLineNumber: s,
      showInlineLineNumbers: a,
      lineProps: r,
      className: w,
      showLineNumbers: n,
      wrapLongLines: l,
      wrapLines: e
    });
  }
  function g(E, S) {
    if (n && S && a) {
      var w = FI(o, S, s);
      E.unshift($I(S, w));
    }
    return E;
  }
  function v(E, S) {
    var w = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    return e || w.length > 0 ? p(E, S, w) : g(E, S);
  }
  for (var m = function() {
    var S = c[d], w = S.children[0].value, C = yJ(w);
    if (C) {
      var k = w.split(`
`);
      k.forEach(function(N, R) {
        var _ = n && f.length + i, O = {
          type: "text",
          value: "".concat(N, `
`)
        };
        if (R === 0) {
          var T = c.slice(h + 1, d).concat(Qg({
            children: [O],
            className: S.properties.className
          })), L = v(T, _);
          f.push(L);
        } else if (R === k.length - 1) {
          var M = c[d + 1] && c[d + 1].children && c[d + 1].children[0], A = {
            type: "text",
            value: "".concat(N)
          };
          if (M) {
            var I = Qg({
              children: [A],
              className: S.properties.className
            });
            c.splice(d + 1, 0, I);
          } else {
            var D = [A], F = v(D, _, S.properties.className);
            f.push(F);
          }
        } else {
          var B = [O], G = v(B, _, S.properties.className);
          f.push(G);
        }
      }), h = d;
    }
    d++;
  }; d < c.length; )
    m();
  if (h !== c.length - 1) {
    var b = c.slice(h + 1, c.length);
    if (b && b.length) {
      var y = n && f.length + i, x = v(b, y);
      f.push(x);
    }
  }
  return e ? f : (u = []).concat.apply(u, f);
}
function TJ(t) {
  var e = t.rows, r = t.stylesheet, n = t.useInlineStyles;
  return e.map(function(a, i) {
    return DI({
      node: a,
      stylesheet: r,
      useInlineStyles: n,
      key: "code-segment-".concat(i)
    });
  });
}
function zI(t) {
  return t && typeof t.highlightAuto < "u";
}
function SJ(t) {
  var e = t.astGenerator, r = t.language, n = t.code, a = t.defaultCodeValue;
  if (zI(e)) {
    var i = gJ(e, r);
    return r === "text" ? {
      value: a,
      language: "text"
    } : i ? e.highlight(r, n) : e.highlightAuto(n);
  }
  try {
    return r && r !== "text" ? {
      value: e.highlight(n, r)
    } : {
      value: a
    };
  } catch {
    return {
      value: a
    };
  }
}
function GI(t, e) {
  return function(n) {
    var a, i, s = n.language, o = n.children, l = n.style, u = l === void 0 ? e : l, c = n.customStyle, f = c === void 0 ? {} : c, h = n.codeTagProps, d = h === void 0 ? {
      className: s ? "language-".concat(s) : void 0,
      style: Oo(Oo({}, u['code[class*="language-"]']), u['code[class*="language-'.concat(s, '"]')])
    } : h, p = n.useInlineStyles, g = p === void 0 ? !0 : p, v = n.showLineNumbers, m = v === void 0 ? !1 : v, b = n.showInlineLineNumbers, y = b === void 0 ? !0 : b, x = n.startingLineNumber, E = x === void 0 ? 1 : x, S = n.lineNumberContainerStyle, w = n.lineNumberStyle, C = w === void 0 ? {} : w, k = n.wrapLines, N = n.wrapLongLines, R = N === void 0 ? !1 : N, _ = n.lineProps, O = _ === void 0 ? {} : _, T = n.renderer, L = n.PreTag, M = L === void 0 ? "pre" : L, A = n.CodeTag, I = A === void 0 ? "code" : A, D = n.code, F = D === void 0 ? (Array.isArray(o) ? o[0] : o) || "" : D, B = n.astGenerator, G = aJ(n, vJ);
    B = B || t;
    var H = m ? /* @__PURE__ */ lt.createElement(xJ, {
      containerStyle: S,
      codeStyle: d.style || {},
      numberStyle: C,
      startingLineNumber: E,
      codeString: F
    }) : null, K = u.hljs || u['pre[class*="language-"]'] || {
      backgroundColor: "#fff"
    }, j = zI(B) ? "hljs" : "prismjs", Z = g ? Object.assign({}, G, {
      style: Object.assign({}, K, f)
    }) : Object.assign({}, G, {
      className: G.className ? "".concat(j, " ").concat(G.className) : j,
      style: Object.assign({}, f)
    });
    if (R ? d.style = Oo({
      whiteSpace: "pre-wrap"
    }, d.style) : d.style = Oo({
      whiteSpace: "pre"
    }, d.style), !B)
      return /* @__PURE__ */ lt.createElement(M, Z, H, /* @__PURE__ */ lt.createElement(I, d, F));
    (k === void 0 && T || R) && (k = !0), T = T || TJ;
    var te = [{
      type: "text",
      value: F
    }], ne = SJ({
      astGenerator: B,
      language: s,
      code: F,
      defaultCodeValue: te
    });
    ne.language === null && (ne.value = te);
    var V = (a = (i = F.match(/\n/g)) === null || i === void 0 ? void 0 : i.length) !== null && a !== void 0 ? a : 0, q = E + V, X = EJ(ne, k, O, m, y, E, q, C, R);
    return /* @__PURE__ */ lt.createElement(M, Z, /* @__PURE__ */ lt.createElement(I, d, !y && H, T({
      rows: X,
      stylesheet: u,
      useInlineStyles: g
    })));
  };
}
const CJ = {
  hljs: {
    display: "block",
    overflowX: "auto",
    padding: "0.5em",
    background: "#F0F0F0",
    color: "#444"
  },
  "hljs-subst": {
    color: "#444"
  },
  "hljs-comment": {
    color: "#888888"
  },
  "hljs-keyword": {
    fontWeight: "bold"
  },
  "hljs-attribute": {
    fontWeight: "bold"
  },
  "hljs-selector-tag": {
    fontWeight: "bold"
  },
  "hljs-meta-keyword": {
    fontWeight: "bold"
  },
  "hljs-doctag": {
    fontWeight: "bold"
  },
  "hljs-name": {
    fontWeight: "bold"
  },
  "hljs-type": {
    color: "#880000"
  },
  "hljs-string": {
    color: "#880000"
  },
  "hljs-number": {
    color: "#880000"
  },
  "hljs-selector-id": {
    color: "#880000"
  },
  "hljs-selector-class": {
    color: "#880000"
  },
  "hljs-quote": {
    color: "#880000"
  },
  "hljs-template-tag": {
    color: "#880000"
  },
  "hljs-deletion": {
    color: "#880000"
  },
  "hljs-title": {
    color: "#880000",
    fontWeight: "bold"
  },
  "hljs-section": {
    color: "#880000",
    fontWeight: "bold"
  },
  "hljs-regexp": {
    color: "#BC6060"
  },
  "hljs-symbol": {
    color: "#BC6060"
  },
  "hljs-variable": {
    color: "#BC6060"
  },
  "hljs-template-variable": {
    color: "#BC6060"
  },
  "hljs-link": {
    color: "#BC6060"
  },
  "hljs-selector-attr": {
    color: "#BC6060"
  },
  "hljs-selector-pseudo": {
    color: "#BC6060"
  },
  "hljs-literal": {
    color: "#78A960"
  },
  "hljs-built_in": {
    color: "#397300"
  },
  "hljs-bullet": {
    color: "#397300"
  },
  "hljs-code": {
    color: "#397300"
  },
  "hljs-addition": {
    color: "#397300"
  },
  "hljs-meta": {
    color: "#1f7199"
  },
  "hljs-meta-string": {
    color: "#4d99bf"
  },
  "hljs-emphasis": {
    fontStyle: "italic"
  },
  "hljs-strong": {
    fontWeight: "bold"
  }
};
var xf = {}, UI = { exports: {} };
(function(t) {
  (function() {
    var e;
    e = t.exports = a, e.format = a, e.vsprintf = n, typeof console < "u" && typeof console.log == "function" && (e.printf = r);
    function r() {
      console.log(a.apply(null, arguments));
    }
    function n(i, s) {
      return a.apply(null, [i].concat(s));
    }
    function a(i) {
      for (var s = 1, o = [].slice.call(arguments), l = 0, u = i.length, c = "", f, h = !1, d, p, g = !1, v, m = function() {
        return o[s++];
      }, b = function() {
        for (var y = ""; /\d/.test(i[l]); )
          y += i[l++], f = i[l];
        return y.length > 0 ? parseInt(y) : null;
      }; l < u; ++l)
        if (f = i[l], h)
          switch (h = !1, f == "." ? (g = !1, f = i[++l]) : f == "0" && i[l + 1] == "." ? (g = !0, l += 2, f = i[l]) : g = !0, v = b(), f) {
            case "b":
              c += parseInt(m(), 10).toString(2);
              break;
            case "c":
              d = m(), typeof d == "string" || d instanceof String ? c += d : c += String.fromCharCode(parseInt(d, 10));
              break;
            case "d":
              c += parseInt(m(), 10);
              break;
            case "f":
              p = String(parseFloat(m()).toFixed(v || 6)), c += g ? p : p.replace(/^0/, "");
              break;
            case "j":
              c += JSON.stringify(m());
              break;
            case "o":
              c += "0" + parseInt(m(), 10).toString(8);
              break;
            case "s":
              c += m();
              break;
            case "x":
              c += "0x" + parseInt(m(), 10).toString(16);
              break;
            case "X":
              c += "0x" + parseInt(m(), 10).toString(16).toUpperCase();
              break;
            default:
              c += f;
              break;
          }
        else f === "%" ? h = !0 : c += f;
      return c;
    }
  })();
})(UI);
var AJ = UI.exports, kJ = AJ, ol = ll(Error), RJ = ol;
ol.eval = ll(EvalError);
ol.range = ll(RangeError);
ol.reference = ll(ReferenceError);
ol.syntax = ll(SyntaxError);
ol.type = ll(TypeError);
ol.uri = ll(URIError);
ol.create = ll;
function ll(t) {
  return e.displayName = t.displayName || t.name, e;
  function e(r) {
    return r && (r = kJ.apply(null, arguments)), new t(r);
  }
}
var us = kH, Jg = RJ;
xf.highlight = HI;
xf.highlightAuto = _J;
xf.registerLanguage = LJ;
xf.listLanguages = NJ;
xf.registerAlias = OJ;
go.prototype.addText = DJ;
go.prototype.addKeyword = IJ;
go.prototype.addSublanguage = PJ;
go.prototype.openNode = $J;
go.prototype.closeNode = FJ;
go.prototype.closeAllNodes = VI;
go.prototype.finalize = VI;
go.prototype.toHTML = BJ;
var MJ = "hljs-";
function HI(t, e, r) {
  var n = us.configure({}), a = r || {}, i = a.prefix, s;
  if (typeof t != "string")
    throw Jg("Expected `string` for name, got `%s`", t);
  if (!us.getLanguage(t))
    throw Jg("Unknown language: `%s` is not registered", t);
  if (typeof e != "string")
    throw Jg("Expected `string` for value, got `%s`", e);
  if (i == null && (i = MJ), us.configure({ __emitter: go, classPrefix: i }), s = us.highlight(e, { language: t, ignoreIllegals: !0 }), us.configure(n || {}), s.errorRaised)
    throw s.errorRaised;
  return {
    relevance: s.relevance,
    language: s.language,
    value: s.emitter.rootNode.children
  };
}
function _J(t, e) {
  var r = e || {}, n = r.subset || us.listLanguages();
  r.prefix;
  var a = n.length, i = -1, s, o, l, u;
  if (typeof t != "string")
    throw Jg("Expected `string` for value, got `%s`", t);
  for (o = { relevance: 0, language: null, value: [] }, s = { relevance: 0, language: null, value: [] }; ++i < a; )
    u = n[i], us.getLanguage(u) && (l = HI(u, t, e), l.language = u, l.relevance > o.relevance && (o = l), l.relevance > s.relevance && (o = s, s = l));
  return o.language && (s.secondBest = o), s;
}
function LJ(t, e) {
  us.registerLanguage(t, e);
}
function NJ() {
  return us.listLanguages();
}
function OJ(t, e) {
  var r = t, n;
  e && (r = {}, r[t] = e);
  for (n in r)
    us.registerAliases(r[n], { languageName: n });
}
function go(t) {
  this.options = t, this.rootNode = { children: [] }, this.stack = [this.rootNode];
}
function IJ(t, e) {
  this.openNode(e), this.addText(t), this.closeNode();
}
function PJ(t, e) {
  var r = this.stack, n = r[r.length - 1], a = t.rootNode.children, i = e ? {
    type: "element",
    tagName: "span",
    properties: { className: [e] },
    children: a
  } : a;
  n.children = n.children.concat(i);
}
function DJ(t) {
  var e = this.stack, r, n;
  t !== "" && (r = e[e.length - 1], n = r.children[r.children.length - 1], n && n.type === "text" ? n.value += t : r.children.push({ type: "text", value: t }));
}
function $J(t) {
  var e = this.stack, r = this.options.classPrefix + t, n = e[e.length - 1], a = {
    type: "element",
    tagName: "span",
    properties: { className: [r] },
    children: []
  };
  n.children.push(a), e.push(a);
}
function FJ() {
  this.stack.pop();
}
function BJ() {
  return "";
}
function VI() {
}
var fe = xf, zJ = fe;
fe.registerLanguage("1c", RH());
fe.registerLanguage("abnf", MH());
fe.registerLanguage(
  "accesslog",
  _H()
);
fe.registerLanguage(
  "actionscript",
  LH()
);
fe.registerLanguage("ada", NH());
fe.registerLanguage(
  "angelscript",
  OH()
);
fe.registerLanguage("apache", IH());
fe.registerLanguage(
  "applescript",
  PH()
);
fe.registerLanguage("arcade", DH());
fe.registerLanguage("arduino", $H());
fe.registerLanguage("armasm", FH());
fe.registerLanguage("xml", BH());
fe.registerLanguage("asciidoc", zH());
fe.registerLanguage("aspectj", GH());
fe.registerLanguage(
  "autohotkey",
  UH()
);
fe.registerLanguage("autoit", HH());
fe.registerLanguage("avrasm", VH());
fe.registerLanguage("awk", qH());
fe.registerLanguage("axapta", WH());
fe.registerLanguage("bash", jH());
fe.registerLanguage("basic", YH());
fe.registerLanguage("bnf", XH());
fe.registerLanguage(
  "brainfuck",
  KH()
);
fe.registerLanguage("c-like", ZH());
fe.registerLanguage("c", QH());
fe.registerLanguage("cal", JH());
fe.registerLanguage(
  "capnproto",
  eV()
);
fe.registerLanguage("ceylon", tV());
fe.registerLanguage("clean", rV());
fe.registerLanguage("clojure", nV());
fe.registerLanguage(
  "clojure-repl",
  aV()
);
fe.registerLanguage("cmake", iV());
fe.registerLanguage(
  "coffeescript",
  sV()
);
fe.registerLanguage("coq", oV());
fe.registerLanguage("cos", lV());
fe.registerLanguage("cpp", uV());
fe.registerLanguage("crmsh", cV());
fe.registerLanguage("crystal", fV());
fe.registerLanguage("csharp", hV());
fe.registerLanguage("csp", dV());
fe.registerLanguage("css", pV());
fe.registerLanguage("d", gV());
fe.registerLanguage("markdown", vV());
fe.registerLanguage("dart", mV());
fe.registerLanguage("delphi", yV());
fe.registerLanguage("diff", bV());
fe.registerLanguage("django", xV());
fe.registerLanguage("dns", wV());
fe.registerLanguage(
  "dockerfile",
  EV()
);
fe.registerLanguage("dos", TV());
fe.registerLanguage("dsconfig", SV());
fe.registerLanguage("dts", CV());
fe.registerLanguage("dust", AV());
fe.registerLanguage("ebnf", kV());
fe.registerLanguage("elixir", RV());
fe.registerLanguage("elm", MV());
fe.registerLanguage("ruby", _V());
fe.registerLanguage("erb", LV());
fe.registerLanguage(
  "erlang-repl",
  NV()
);
fe.registerLanguage("erlang", OV());
fe.registerLanguage("excel", IV());
fe.registerLanguage("fix", PV());
fe.registerLanguage("flix", DV());
fe.registerLanguage("fortran", $V());
fe.registerLanguage("fsharp", FV());
fe.registerLanguage("gams", BV());
fe.registerLanguage("gauss", zV());
fe.registerLanguage("gcode", GV());
fe.registerLanguage("gherkin", UV());
fe.registerLanguage("glsl", HV());
fe.registerLanguage("gml", VV());
fe.registerLanguage("go", qV());
fe.registerLanguage("golo", WV());
fe.registerLanguage("gradle", jV());
fe.registerLanguage("groovy", YV());
fe.registerLanguage("haml", XV());
fe.registerLanguage(
  "handlebars",
  KV()
);
fe.registerLanguage("haskell", ZV());
fe.registerLanguage("haxe", QV());
fe.registerLanguage("hsp", JV());
fe.registerLanguage("htmlbars", eq());
fe.registerLanguage("http", tq());
fe.registerLanguage("hy", rq());
fe.registerLanguage("inform7", nq());
fe.registerLanguage("ini", aq());
fe.registerLanguage("irpf90", iq());
fe.registerLanguage("isbl", sq());
fe.registerLanguage("java", oq());
fe.registerLanguage(
  "javascript",
  lq()
);
fe.registerLanguage(
  "jboss-cli",
  uq()
);
fe.registerLanguage("json", cq());
fe.registerLanguage("julia", fq());
fe.registerLanguage(
  "julia-repl",
  hq()
);
fe.registerLanguage("kotlin", dq());
fe.registerLanguage("lasso", pq());
fe.registerLanguage("latex", gq());
fe.registerLanguage("ldif", vq());
fe.registerLanguage("leaf", mq());
fe.registerLanguage("less", yq());
fe.registerLanguage("lisp", bq());
fe.registerLanguage(
  "livecodeserver",
  xq()
);
fe.registerLanguage(
  "livescript",
  wq()
);
fe.registerLanguage("llvm", Eq());
fe.registerLanguage("lsl", Tq());
fe.registerLanguage("lua", Sq());
fe.registerLanguage("makefile", Cq());
fe.registerLanguage(
  "mathematica",
  Aq()
);
fe.registerLanguage("matlab", kq());
fe.registerLanguage("maxima", Rq());
fe.registerLanguage("mel", Mq());
fe.registerLanguage("mercury", _q());
fe.registerLanguage("mipsasm", Lq());
fe.registerLanguage("mizar", Nq());
fe.registerLanguage("perl", Oq());
fe.registerLanguage(
  "mojolicious",
  Iq()
);
fe.registerLanguage("monkey", Pq());
fe.registerLanguage(
  "moonscript",
  Dq()
);
fe.registerLanguage("n1ql", $q());
fe.registerLanguage("nginx", Fq());
fe.registerLanguage("nim", Bq());
fe.registerLanguage("nix", zq());
fe.registerLanguage(
  "node-repl",
  Gq()
);
fe.registerLanguage("nsis", Uq());
fe.registerLanguage(
  "objectivec",
  Hq()
);
fe.registerLanguage("ocaml", Vq());
fe.registerLanguage("openscad", qq());
fe.registerLanguage("oxygene", Wq());
fe.registerLanguage("parser3", jq());
fe.registerLanguage("pf", Yq());
fe.registerLanguage("pgsql", Xq());
fe.registerLanguage("php", Kq());
fe.registerLanguage(
  "php-template",
  Zq()
);
fe.registerLanguage(
  "plaintext",
  Qq()
);
fe.registerLanguage("pony", Jq());
fe.registerLanguage(
  "powershell",
  eW()
);
fe.registerLanguage(
  "processing",
  tW()
);
fe.registerLanguage("profile", rW());
fe.registerLanguage("prolog", nW());
fe.registerLanguage(
  "properties",
  aW()
);
fe.registerLanguage("protobuf", iW());
fe.registerLanguage("puppet", sW());
fe.registerLanguage(
  "purebasic",
  oW()
);
fe.registerLanguage("python", lW());
fe.registerLanguage(
  "python-repl",
  uW()
);
fe.registerLanguage("q", cW());
fe.registerLanguage("qml", fW());
fe.registerLanguage("r", hW());
fe.registerLanguage("reasonml", dW());
fe.registerLanguage("rib", pW());
fe.registerLanguage("roboconf", gW());
fe.registerLanguage("routeros", vW());
fe.registerLanguage("rsl", mW());
fe.registerLanguage(
  "ruleslanguage",
  yW()
);
fe.registerLanguage("rust", bW());
fe.registerLanguage("sas", xW());
fe.registerLanguage("scala", wW());
fe.registerLanguage("scheme", EW());
fe.registerLanguage("scilab", TW());
fe.registerLanguage("scss", SW());
fe.registerLanguage("shell", CW());
fe.registerLanguage("smali", AW());
fe.registerLanguage(
  "smalltalk",
  kW()
);
fe.registerLanguage("sml", RW());
fe.registerLanguage("sqf", MW());
fe.registerLanguage("sql_more", _W());
fe.registerLanguage("sql", LW());
fe.registerLanguage("stan", NW());
fe.registerLanguage("stata", OW());
fe.registerLanguage("step21", IW());
fe.registerLanguage("stylus", PW());
fe.registerLanguage("subunit", DW());
fe.registerLanguage("swift", $W());
fe.registerLanguage(
  "taggerscript",
  FW()
);
fe.registerLanguage("yaml", BW());
fe.registerLanguage("tap", zW());
fe.registerLanguage("tcl", GW());
fe.registerLanguage("thrift", UW());
fe.registerLanguage("tp", HW());
fe.registerLanguage("twig", VW());
fe.registerLanguage(
  "typescript",
  qW()
);
fe.registerLanguage("vala", WW());
fe.registerLanguage("vbnet", jW());
fe.registerLanguage("vbscript", YW());
fe.registerLanguage(
  "vbscript-html",
  XW()
);
fe.registerLanguage("verilog", KW());
fe.registerLanguage("vhdl", ZW());
fe.registerLanguage("vim", QW());
fe.registerLanguage("x86asm", JW());
fe.registerLanguage("xl", ej());
fe.registerLanguage("xquery", tj());
fe.registerLanguage("zephir", rj());
const GJ = /* @__PURE__ */ ho(zJ), UJ = ["1c", "abnf", "accesslog", "actionscript", "ada", "angelscript", "apache", "applescript", "arcade", "arduino", "armasm", "asciidoc", "aspectj", "autohotkey", "autoit", "avrasm", "awk", "axapta", "bash", "basic", "bnf", "brainfuck", "c-like", "c", "cal", "capnproto", "ceylon", "clean", "clojure-repl", "clojure", "cmake", "coffeescript", "coq", "cos", "cpp", "crmsh", "crystal", "csharp", "csp", "css", "d", "dart", "delphi", "diff", "django", "dns", "dockerfile", "dos", "dsconfig", "dts", "dust", "ebnf", "elixir", "elm", "erb", "erlang-repl", "erlang", "excel", "fix", "flix", "fortran", "fsharp", "gams", "gauss", "gcode", "gherkin", "glsl", "gml", "go", "golo", "gradle", "groovy", "haml", "handlebars", "haskell", "haxe", "hsp", "htmlbars", "http", "hy", "inform7", "ini", "irpf90", "isbl", "java", "javascript", "jboss-cli", "json", "julia-repl", "julia", "kotlin", "lasso", "latex", "ldif", "leaf", "less", "lisp", "livecodeserver", "livescript", "llvm", "lsl", "lua", "makefile", "markdown", "mathematica", "matlab", "maxima", "mel", "mercury", "mipsasm", "mizar", "mojolicious", "monkey", "moonscript", "n1ql", "nginx", "nim", "nix", "node-repl", "nsis", "objectivec", "ocaml", "openscad", "oxygene", "parser3", "perl", "pf", "pgsql", "php-template", "php", "plaintext", "pony", "powershell", "processing", "profile", "prolog", "properties", "protobuf", "puppet", "purebasic", "python-repl", "python", "q", "qml", "r", "reasonml", "rib", "roboconf", "routeros", "rsl", "ruby", "ruleslanguage", "rust", "sas", "scala", "scheme", "scilab", "scss", "shell", "smali", "smalltalk", "sml", "sqf", "sql", "sql_more", "stan", "stata", "step21", "stylus", "subunit", "swift", "taggerscript", "tap", "tcl", "thrift", "tp", "twig", "typescript", "vala", "vbnet", "vbscript-html", "vbscript", "verilog", "vhdl", "vim", "x86asm", "xl", "xml", "xquery", "yaml", "zephir"];
var HJ = GI(GJ, CJ);
HJ.supportedLanguages = UJ;
const VJ = ["abap", "abnf", "actionscript", "ada", "agda", "al", "antlr4", "apacheconf", "apex", "apl", "applescript", "aql", "arduino", "arff", "armasm", "arturo", "asciidoc", "asm6502", "asmatmel", "aspnet", "autohotkey", "autoit", "avisynth", "avro-idl", "awk", "bash", "basic", "batch", "bbcode", "bbj", "bicep", "birb", "bison", "bnf", "bqn", "brainfuck", "brightscript", "bro", "bsl", "c", "cfscript", "chaiscript", "cil", "cilkc", "cilkcpp", "clike", "clojure", "cmake", "cobol", "coffeescript", "concurnas", "cooklang", "coq", "cpp", "crystal", "csharp", "cshtml", "csp", "css-extras", "css", "csv", "cue", "cypher", "d", "dart", "dataweave", "dax", "dhall", "diff", "django", "dns-zone-file", "docker", "dot", "ebnf", "editorconfig", "eiffel", "ejs", "elixir", "elm", "erb", "erlang", "etlua", "excel-formula", "factor", "false", "firestore-security-rules", "flow", "fortran", "fsharp", "ftl", "gap", "gcode", "gdscript", "gedcom", "gettext", "gherkin", "git", "glsl", "gml", "gn", "go-module", "go", "gradle", "graphql", "groovy", "haml", "handlebars", "haskell", "haxe", "hcl", "hlsl", "hoon", "hpkp", "hsts", "http", "ichigojam", "icon", "icu-message-format", "idris", "iecst", "ignore", "inform7", "ini", "io", "j", "java", "javadoc", "javadoclike", "javascript", "javastacktrace", "jexl", "jolie", "jq", "js-extras", "js-templates", "jsdoc", "json", "json5", "jsonp", "jsstacktrace", "jsx", "julia", "keepalived", "keyman", "kotlin", "kumir", "kusto", "latex", "latte", "less", "lilypond", "linker-script", "liquid", "lisp", "livescript", "llvm", "log", "lolcode", "lua", "magma", "makefile", "markdown", "markup-templating", "markup", "mata", "matlab", "maxscript", "mel", "mermaid", "metafont", "mizar", "mongodb", "monkey", "moonscript", "n1ql", "n4js", "nand2tetris-hdl", "naniscript", "nasm", "neon", "nevod", "nginx", "nim", "nix", "nsis", "objectivec", "ocaml", "odin", "opencl", "openqasm", "oz", "parigp", "parser", "pascal", "pascaligo", "pcaxis", "peoplecode", "perl", "php-extras", "php", "phpdoc", "plant-uml", "plsql", "powerquery", "powershell", "processing", "prolog", "promql", "properties", "protobuf", "psl", "pug", "puppet", "pure", "purebasic", "purescript", "python", "q", "qml", "qore", "qsharp", "r", "racket", "reason", "regex", "rego", "renpy", "rescript", "rest", "rip", "roboconf", "robotframework", "ruby", "rust", "sas", "sass", "scala", "scheme", "scss", "shell-session", "smali", "smalltalk", "smarty", "sml", "solidity", "solution-file", "soy", "sparql", "splunk-spl", "sqf", "sql", "squirrel", "stan", "stata", "stylus", "supercollider", "swift", "systemd", "t4-cs", "t4-templating", "t4-vb", "tap", "tcl", "textile", "toml", "tremor", "tsx", "tt2", "turtle", "twig", "typescript", "typoscript", "unrealscript", "uorazor", "uri", "v", "vala", "vbnet", "velocity", "verilog", "vhdl", "vim", "visual-basic", "warpscript", "wasm", "web-idl", "wgsl", "wiki", "wolfram", "wren", "xeora", "xml-doc", "xojo", "xquery", "yaml", "yang", "zig"];
let B0 = class {
  /**
   * @param {SchemaType['property']} property
   *   Property.
   * @param {SchemaType['normal']} normal
   *   Normal.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Schema.
   */
  constructor(e, r, n) {
    this.normal = r, this.property = e, n && (this.space = n);
  }
};
B0.prototype.normal = {};
B0.prototype.property = {};
B0.prototype.space = void 0;
function qI(t, e) {
  const r = {}, n = {};
  for (const a of t)
    Object.assign(r, a.property), Object.assign(n, a.normal);
  return new B0(r, n, e);
}
function qd(t) {
  return t.toLowerCase();
}
let Na = class {
  /**
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @returns
   *   Info.
   */
  constructor(e, r) {
    this.attribute = r, this.property = e;
  }
};
Na.prototype.attribute = "";
Na.prototype.booleanish = !1;
Na.prototype.boolean = !1;
Na.prototype.commaOrSpaceSeparated = !1;
Na.prototype.commaSeparated = !1;
Na.prototype.defined = !1;
Na.prototype.mustUseProperty = !1;
Na.prototype.number = !1;
Na.prototype.overloadedBoolean = !1;
Na.prototype.property = "";
Na.prototype.spaceSeparated = !1;
Na.prototype.space = void 0;
let qJ = 0;
const Ft = vu(), sn = vu(), aT = vu(), qe = vu(), Rr = vu(), pc = vu(), Ya = vu();
function vu() {
  return 2 ** ++qJ;
}
const iT = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: Ft,
  booleanish: sn,
  commaOrSpaceSeparated: Ya,
  commaSeparated: pc,
  number: qe,
  overloadedBoolean: aT,
  spaceSeparated: Rr
}, Symbol.toStringTag, { value: "Module" })), qb = (
  /** @type {ReadonlyArray<keyof typeof types>} */
  Object.keys(iT)
);
class t5 extends Na {
  /**
   * @constructor
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @param {number | null | undefined} [mask]
   *   Mask.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Info.
   */
  constructor(e, r, n, a) {
    let i = -1;
    if (super(e, r), sk(this, "space", a), typeof n == "number")
      for (; ++i < qb.length; ) {
        const s = qb[i];
        sk(this, qb[i], (n & iT[s]) === iT[s]);
      }
  }
}
t5.prototype.defined = !0;
function sk(t, e, r) {
  r && (t[e] = r);
}
function wf(t) {
  const e = {}, r = {};
  for (const [n, a] of Object.entries(t.properties)) {
    const i = new t5(
      n,
      t.transform(t.attributes || {}, n),
      a,
      t.space
    );
    t.mustUseProperty && t.mustUseProperty.includes(n) && (i.mustUseProperty = !0), e[n] = i, r[qd(n)] = n, r[qd(i.attribute)] = n;
  }
  return new B0(e, r, t.space);
}
const WI = wf({
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: sn,
    ariaAutoComplete: null,
    ariaBusy: sn,
    ariaChecked: sn,
    ariaColCount: qe,
    ariaColIndex: qe,
    ariaColSpan: qe,
    ariaControls: Rr,
    ariaCurrent: null,
    ariaDescribedBy: Rr,
    ariaDetails: null,
    ariaDisabled: sn,
    ariaDropEffect: Rr,
    ariaErrorMessage: null,
    ariaExpanded: sn,
    ariaFlowTo: Rr,
    ariaGrabbed: sn,
    ariaHasPopup: null,
    ariaHidden: sn,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: Rr,
    ariaLevel: qe,
    ariaLive: null,
    ariaModal: sn,
    ariaMultiLine: sn,
    ariaMultiSelectable: sn,
    ariaOrientation: null,
    ariaOwns: Rr,
    ariaPlaceholder: null,
    ariaPosInSet: qe,
    ariaPressed: sn,
    ariaReadOnly: sn,
    ariaRelevant: null,
    ariaRequired: sn,
    ariaRoleDescription: Rr,
    ariaRowCount: qe,
    ariaRowIndex: qe,
    ariaRowSpan: qe,
    ariaSelected: sn,
    ariaSetSize: qe,
    ariaSort: null,
    ariaValueMax: qe,
    ariaValueMin: qe,
    ariaValueNow: qe,
    ariaValueText: null,
    role: null
  },
  transform(t, e) {
    return e === "role" ? e : "aria-" + e.slice(4).toLowerCase();
  }
});
function jI(t, e) {
  return e in t ? t[e] : e;
}
function YI(t, e) {
  return jI(t, e.toLowerCase());
}
const WJ = wf({
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: pc,
    acceptCharset: Rr,
    accessKey: Rr,
    action: null,
    allow: null,
    allowFullScreen: Ft,
    allowPaymentRequest: Ft,
    allowUserMedia: Ft,
    alt: null,
    as: null,
    async: Ft,
    autoCapitalize: null,
    autoComplete: Rr,
    autoFocus: Ft,
    autoPlay: Ft,
    blocking: Rr,
    capture: null,
    charSet: null,
    checked: Ft,
    cite: null,
    className: Rr,
    cols: qe,
    colSpan: null,
    content: null,
    contentEditable: sn,
    controls: Ft,
    controlsList: Rr,
    coords: qe | pc,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: Ft,
    defer: Ft,
    dir: null,
    dirName: null,
    disabled: Ft,
    download: aT,
    draggable: sn,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: Ft,
    formTarget: null,
    headers: Rr,
    height: qe,
    hidden: aT,
    high: qe,
    href: null,
    hrefLang: null,
    htmlFor: Rr,
    httpEquiv: Rr,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: Ft,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: Ft,
    itemId: null,
    itemProp: Rr,
    itemRef: Rr,
    itemScope: Ft,
    itemType: Rr,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: Ft,
    low: qe,
    manifest: null,
    max: null,
    maxLength: qe,
    media: null,
    method: null,
    min: null,
    minLength: qe,
    multiple: Ft,
    muted: Ft,
    name: null,
    nonce: null,
    noModule: Ft,
    noValidate: Ft,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: Ft,
    optimum: qe,
    pattern: null,
    ping: Rr,
    placeholder: null,
    playsInline: Ft,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: Ft,
    referrerPolicy: null,
    rel: Rr,
    required: Ft,
    reversed: Ft,
    rows: qe,
    rowSpan: qe,
    sandbox: Rr,
    scope: null,
    scoped: Ft,
    seamless: Ft,
    selected: Ft,
    shadowRootClonable: Ft,
    shadowRootDelegatesFocus: Ft,
    shadowRootMode: null,
    shape: null,
    size: qe,
    sizes: null,
    slot: null,
    span: qe,
    spellCheck: sn,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: qe,
    step: null,
    style: null,
    tabIndex: qe,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: Ft,
    useMap: null,
    value: sn,
    width: qe,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: Rr,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: qe,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: qe,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: Ft,
    // Lists. Use CSS to reduce space between items instead
    declare: Ft,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: qe,
    // `<img>` and `<object>`
    leftMargin: qe,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: qe,
    // `<body>`
    marginWidth: qe,
    // `<body>`
    noResize: Ft,
    // `<frame>`
    noHref: Ft,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: Ft,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: Ft,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: qe,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: sn,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: qe,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: qe,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: Ft,
    disableRemotePlayback: Ft,
    prefix: null,
    property: null,
    results: qe,
    security: null,
    unselectable: null
  },
  space: "html",
  transform: YI
}), jJ = wf({
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  properties: {
    about: Ya,
    accentHeight: qe,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: qe,
    amplitude: qe,
    arabicForm: null,
    ascent: qe,
    attributeName: null,
    attributeType: null,
    azimuth: qe,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: qe,
    by: null,
    calcMode: null,
    capHeight: qe,
    className: Rr,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: qe,
    diffuseConstant: qe,
    direction: null,
    display: null,
    dur: null,
    divisor: qe,
    dominantBaseline: null,
    download: Ft,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: qe,
    enableBackground: null,
    end: null,
    event: null,
    exponent: qe,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: qe,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: pc,
    g2: pc,
    glyphName: pc,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: qe,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: qe,
    horizOriginX: qe,
    horizOriginY: qe,
    id: null,
    ideographic: qe,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: qe,
    k: qe,
    k1: qe,
    k2: qe,
    k3: qe,
    k4: qe,
    kernelMatrix: Ya,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: qe,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: qe,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: qe,
    overlineThickness: qe,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: qe,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: Rr,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: qe,
    pointsAtY: qe,
    pointsAtZ: qe,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: Ya,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: Ya,
    rev: Ya,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: Ya,
    requiredFeatures: Ya,
    requiredFonts: Ya,
    requiredFormats: Ya,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: qe,
    specularExponent: qe,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: qe,
    strikethroughThickness: qe,
    string: null,
    stroke: null,
    strokeDashArray: Ya,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: qe,
    strokeOpacity: qe,
    strokeWidth: null,
    style: null,
    surfaceScale: qe,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: Ya,
    tabIndex: qe,
    tableValues: null,
    target: null,
    targetX: qe,
    targetY: qe,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: Ya,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: qe,
    underlineThickness: qe,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: qe,
    values: null,
    vAlphabetic: qe,
    vMathematical: qe,
    vectorEffect: null,
    vHanging: qe,
    vIdeographic: qe,
    version: null,
    vertAdvY: qe,
    vertOriginX: qe,
    vertOriginY: qe,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: qe,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  },
  space: "svg",
  transform: jI
}), XI = wf({
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  },
  space: "xlink",
  transform(t, e) {
    return "xlink:" + e.slice(5).toLowerCase();
  }
}), KI = wf({
  attributes: { xmlnsxlink: "xmlns:xlink" },
  properties: { xmlnsXLink: null, xmlns: null },
  space: "xmlns",
  transform: YI
}), ZI = wf({
  properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
  space: "xml",
  transform(t, e) {
    return "xml:" + e.slice(3).toLowerCase();
  }
}), YJ = /[A-Z]/g, ok = /-[a-z]/g, XJ = /^data[-\w.:]+$/i;
function KJ(t, e) {
  const r = qd(e);
  let n = e, a = Na;
  if (r in t.normal)
    return t.property[t.normal[r]];
  if (r.length > 4 && r.slice(0, 4) === "data" && XJ.test(e)) {
    if (e.charAt(4) === "-") {
      const i = e.slice(5).replace(ok, QJ);
      n = "data" + i.charAt(0).toUpperCase() + i.slice(1);
    } else {
      const i = e.slice(4);
      if (!ok.test(i)) {
        let s = i.replace(YJ, ZJ);
        s.charAt(0) !== "-" && (s = "-" + s), e = "data" + s;
      }
    }
    a = t5;
  }
  return new a(n, e);
}
function ZJ(t) {
  return "-" + t.toLowerCase();
}
function QJ(t) {
  return t.charAt(1).toUpperCase();
}
const JJ = qI([WI, WJ, XI, KI, ZI], "html"), eee = qI([WI, jJ, XI, KI, ZI], "svg");
function lk(t) {
  const e = [], r = String(t || "");
  let n = r.indexOf(","), a = 0, i = !1;
  for (; !i; ) {
    n === -1 && (n = r.length, i = !0);
    const s = r.slice(a, n).trim();
    (s || !i) && e.push(s), a = n + 1, n = r.indexOf(",", a);
  }
  return e;
}
const uk = /[#.]/g;
function tee(t, e) {
  const r = t || "", n = {};
  let a = 0, i, s;
  for (; a < r.length; ) {
    uk.lastIndex = a;
    const o = uk.exec(r), l = r.slice(a, o ? o.index : r.length);
    l && (i ? i === "#" ? n.id = l : Array.isArray(n.className) ? n.className.push(l) : n.className = [l] : s = l, a += l.length), o && (i = o[0], a++);
  }
  return {
    type: "element",
    // @ts-expect-error: tag name is parsed.
    tagName: s || e || "div",
    properties: n,
    children: []
  };
}
function ck(t) {
  const e = String(t || "").trim();
  return e ? e.split(/[ \t\n\r\f]+/g) : [];
}
function QI(t, e, r) {
  const n = r ? iee(r) : void 0;
  function a(i, s, ...o) {
    let l;
    if (i == null) {
      l = { type: "root", children: [] };
      const u = (
        /** @type {Child} */
        s
      );
      o.unshift(u);
    } else {
      l = tee(i, e);
      const u = l.tagName.toLowerCase(), c = n ? n.get(u) : void 0;
      if (l.tagName = c || u, ree(s))
        o.unshift(s);
      else
        for (const [f, h] of Object.entries(s))
          nee(t, l.properties, f, h);
    }
    for (const u of o)
      sT(l.children, u);
    return l.type === "element" && l.tagName === "template" && (l.content = { type: "root", children: l.children }, l.children = []), l;
  }
  return a;
}
function ree(t) {
  if (t === null || typeof t != "object" || Array.isArray(t))
    return !0;
  if (typeof t.type != "string") return !1;
  const e = (
    /** @type {Record<string, unknown>} */
    t
  ), r = Object.keys(t);
  for (const n of r) {
    const a = e[n];
    if (a && typeof a == "object") {
      if (!Array.isArray(a)) return !0;
      const i = (
        /** @type {ReadonlyArray<unknown>} */
        a
      );
      for (const s of i)
        if (typeof s != "number" && typeof s != "string")
          return !0;
    }
  }
  return !!("children" in t && Array.isArray(t.children));
}
function nee(t, e, r, n) {
  const a = KJ(t, r);
  let i;
  if (n != null) {
    if (typeof n == "number") {
      if (Number.isNaN(n)) return;
      i = n;
    } else typeof n == "boolean" ? i = n : typeof n == "string" ? a.spaceSeparated ? i = ck(n) : a.commaSeparated ? i = lk(n) : a.commaOrSpaceSeparated ? i = ck(lk(n).join(" ")) : i = fk(a, a.property, n) : Array.isArray(n) ? i = [...n] : i = a.property === "style" ? aee(n) : String(n);
    if (Array.isArray(i)) {
      const s = [];
      for (const o of i)
        s.push(
          /** @type {number | string} */
          fk(a, a.property, o)
        );
      i = s;
    }
    a.property === "className" && Array.isArray(e.className) && (i = e.className.concat(
      /** @type {Array<number | string> | number | string} */
      i
    )), e[a.property] = i;
  }
}
function sT(t, e) {
  if (e != null) if (typeof e == "number" || typeof e == "string")
    t.push({ type: "text", value: String(e) });
  else if (Array.isArray(e))
    for (const r of e)
      sT(t, r);
  else if (typeof e == "object" && "type" in e)
    e.type === "root" ? sT(t, e.children) : t.push(e);
  else
    throw new Error("Expected node, nodes, or string, got `" + e + "`");
}
function fk(t, e, r) {
  if (typeof r == "string") {
    if (t.number && r && !Number.isNaN(Number(r)))
      return Number(r);
    if ((t.boolean || t.overloadedBoolean) && (r === "" || qd(r) === qd(e)))
      return !0;
  }
  return r;
}
function aee(t) {
  const e = [];
  for (const [r, n] of Object.entries(t))
    e.push([r, n].join(": "));
  return e.join("; ");
}
function iee(t) {
  const e = /* @__PURE__ */ new Map();
  for (const r of t)
    e.set(r.toLowerCase(), r);
  return e;
}
const see = [
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "solidColor",
  "textArea",
  "textPath"
], zMe = QI(JJ, "div");
QI(eee, "g", see);
const oee = [
  "AElig",
  "AMP",
  "Aacute",
  "Acirc",
  "Agrave",
  "Aring",
  "Atilde",
  "Auml",
  "COPY",
  "Ccedil",
  "ETH",
  "Eacute",
  "Ecirc",
  "Egrave",
  "Euml",
  "GT",
  "Iacute",
  "Icirc",
  "Igrave",
  "Iuml",
  "LT",
  "Ntilde",
  "Oacute",
  "Ocirc",
  "Ograve",
  "Oslash",
  "Otilde",
  "Ouml",
  "QUOT",
  "REG",
  "THORN",
  "Uacute",
  "Ucirc",
  "Ugrave",
  "Uuml",
  "Yacute",
  "aacute",
  "acirc",
  "acute",
  "aelig",
  "agrave",
  "amp",
  "aring",
  "atilde",
  "auml",
  "brvbar",
  "ccedil",
  "cedil",
  "cent",
  "copy",
  "curren",
  "deg",
  "divide",
  "eacute",
  "ecirc",
  "egrave",
  "eth",
  "euml",
  "frac12",
  "frac14",
  "frac34",
  "gt",
  "iacute",
  "icirc",
  "iexcl",
  "igrave",
  "iquest",
  "iuml",
  "laquo",
  "lt",
  "macr",
  "micro",
  "middot",
  "nbsp",
  "not",
  "ntilde",
  "oacute",
  "ocirc",
  "ograve",
  "ordf",
  "ordm",
  "oslash",
  "otilde",
  "ouml",
  "para",
  "plusmn",
  "pound",
  "quot",
  "raquo",
  "reg",
  "sect",
  "shy",
  "sup1",
  "sup2",
  "sup3",
  "szlig",
  "thorn",
  "times",
  "uacute",
  "ucirc",
  "ugrave",
  "uml",
  "uuml",
  "yacute",
  "yen",
  "yuml"
], hk = {
  0: "�",
  128: "€",
  130: "‚",
  131: "ƒ",
  132: "„",
  133: "…",
  134: "†",
  135: "‡",
  136: "ˆ",
  137: "‰",
  138: "Š",
  139: "‹",
  140: "Œ",
  142: "Ž",
  145: "‘",
  146: "’",
  147: "“",
  148: "”",
  149: "•",
  150: "–",
  151: "—",
  152: "˜",
  153: "™",
  154: "š",
  155: "›",
  156: "œ",
  158: "ž",
  159: "Ÿ"
};
function JI(t) {
  const e = typeof t == "string" ? t.charCodeAt(0) : t;
  return e >= 48 && e <= 57;
}
function lee(t) {
  const e = typeof t == "string" ? t.charCodeAt(0) : t;
  return e >= 97 && e <= 102 || e >= 65 && e <= 70 || e >= 48 && e <= 57;
}
function uee(t) {
  const e = typeof t == "string" ? t.charCodeAt(0) : t;
  return e >= 97 && e <= 122 || e >= 65 && e <= 90;
}
function dk(t) {
  return uee(t) || JI(t);
}
const pk = document.createElement("i");
function gk(t) {
  const e = "&" + t + ";";
  pk.innerHTML = e;
  const r = pk.textContent;
  return (
    // @ts-expect-error: TypeScript is wrong that `textContent` on elements can
    // yield `null`.
    r.charCodeAt(r.length - 1) === 59 && t !== "semi" || r === e ? !1 : r
  );
}
const cee = [
  "",
  /* 1: Non terminated (named) */
  "Named character references must be terminated by a semicolon",
  /* 2: Non terminated (numeric) */
  "Numeric character references must be terminated by a semicolon",
  /* 3: Empty (named) */
  "Named character references cannot be empty",
  /* 4: Empty (numeric) */
  "Numeric character references cannot be empty",
  /* 5: Unknown (named) */
  "Named character references must be known",
  /* 6: Disallowed (numeric) */
  "Numeric character references cannot be disallowed",
  /* 7: Prohibited (numeric) */
  "Numeric character references cannot be outside the permissible Unicode range"
];
function GMe(t, e) {
  const r = {}, n = typeof r.additional == "string" ? r.additional.charCodeAt(0) : r.additional, a = [];
  let i = 0, s = -1, o = "", l, u;
  r.position && ("start" in r.position || "indent" in r.position ? (u = r.position.indent, l = r.position.start) : l = r.position);
  let c = (l ? l.line : 0) || 1, f = (l ? l.column : 0) || 1, h = p(), d;
  for (i--; ++i <= t.length; )
    if (d === 10 && (f = (u ? u[s] : 0) || 1), d = t.charCodeAt(i), d === 38) {
      const m = t.charCodeAt(i + 1);
      if (m === 9 || m === 10 || m === 12 || m === 32 || m === 38 || m === 60 || Number.isNaN(m) || n && m === n) {
        o += String.fromCharCode(d), f++;
        continue;
      }
      const b = i + 1;
      let y = b, x = b, E;
      if (m === 35) {
        x = ++y;
        const O = t.charCodeAt(x);
        O === 88 || O === 120 ? (E = "hexadecimal", x = ++y) : E = "decimal";
      } else
        E = "named";
      let S = "", w = "", C = "";
      const k = E === "named" ? dk : E === "decimal" ? JI : lee;
      for (x--; ++x <= t.length; ) {
        const O = t.charCodeAt(x);
        if (!k(O))
          break;
        C += String.fromCharCode(O), E === "named" && oee.includes(C) && (S = C, w = gk(C));
      }
      let N = t.charCodeAt(x) === 59;
      if (N) {
        x++;
        const O = E === "named" ? gk(C) : !1;
        O && (S = C, w = O);
      }
      let R = 1 + x - b, _ = "";
      if (!(!N && r.nonTerminated === !1)) if (!C)
        E !== "named" && g(4, R);
      else if (E === "named") {
        if (N && !w)
          g(5, 1);
        else if (S !== C && (x = y + S.length, R = 1 + x - y, N = !1), !N) {
          const O = S ? 1 : 3;
          if (r.attribute) {
            const T = t.charCodeAt(x);
            T === 61 ? (g(O, R), w = "") : dk(T) ? w = "" : g(O, R);
          } else
            g(O, R);
        }
        _ = w;
      } else {
        N || g(2, R);
        let O = Number.parseInt(
          C,
          E === "hexadecimal" ? 16 : 10
        );
        if (fee(O))
          g(7, R), _ = "�";
        else if (O in hk)
          g(6, R), _ = hk[O];
        else {
          let T = "";
          hee(O) && g(6, R), O > 65535 && (O -= 65536, T += String.fromCharCode(
            O >>> 10 | 55296
          ), O = 56320 | O & 1023), _ = T + String.fromCharCode(O);
        }
      }
      if (_) {
        v(), h = p(), i = x - 1, f += x - b + 1, a.push(_);
        const O = p();
        O.offset++, r.reference && r.reference.call(
          r.referenceContext || void 0,
          _,
          { start: h, end: O },
          t.slice(b - 1, x)
        ), h = O;
      } else
        C = t.slice(b - 1, x), o += C, f += C.length, i = x - 1;
    } else
      d === 10 && (c++, s++, f = 0), Number.isNaN(d) ? v() : (o += String.fromCharCode(d), f++);
  return a.join("");
  function p() {
    return {
      line: c,
      column: f,
      offset: i + ((l ? l.offset : 0) || 0)
    };
  }
  function g(m, b) {
    let y;
    r.warning && (y = p(), y.column += b, y.offset += b, r.warning.call(
      r.warningContext || void 0,
      cee[m],
      y,
      m
    ));
  }
  function v() {
    o && (a.push(o), r.text && r.text.call(r.textContext || void 0, o, {
      start: h,
      end: p()
    }), o = "");
  }
}
function fee(t) {
  return t >= 55296 && t <= 57343 || t > 1114111;
}
function hee(t) {
  return t >= 1 && t <= 8 || t === 11 || t >= 13 && t <= 31 || t >= 127 && t <= 159 || t >= 64976 && t <= 65007 || (t & 65535) === 65535 || (t & 65535) === 65534;
}
const dee = {
  'code[class*="language-"]': {
    color: "black",
    background: "none",
    textShadow: "0 1px white",
    fontFamily: "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
    fontSize: "1em",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    wordWrap: "normal",
    lineHeight: "1.5",
    MozTabSize: "4",
    OTabSize: "4",
    tabSize: "4",
    WebkitHyphens: "none",
    MozHyphens: "none",
    msHyphens: "none",
    hyphens: "none"
  },
  'pre[class*="language-"]': {
    color: "black",
    background: "#f5f2f0",
    textShadow: "0 1px white",
    fontFamily: "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
    fontSize: "1em",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    wordWrap: "normal",
    lineHeight: "1.5",
    MozTabSize: "4",
    OTabSize: "4",
    tabSize: "4",
    WebkitHyphens: "none",
    MozHyphens: "none",
    msHyphens: "none",
    hyphens: "none",
    padding: "1em",
    margin: ".5em 0",
    overflow: "auto"
  },
  'pre[class*="language-"]::-moz-selection': {
    textShadow: "none",
    background: "#b3d4fc"
  },
  'pre[class*="language-"] ::-moz-selection': {
    textShadow: "none",
    background: "#b3d4fc"
  },
  'code[class*="language-"]::-moz-selection': {
    textShadow: "none",
    background: "#b3d4fc"
  },
  'code[class*="language-"] ::-moz-selection': {
    textShadow: "none",
    background: "#b3d4fc"
  },
  'pre[class*="language-"]::selection': {
    textShadow: "none",
    background: "#b3d4fc"
  },
  'pre[class*="language-"] ::selection': {
    textShadow: "none",
    background: "#b3d4fc"
  },
  'code[class*="language-"]::selection': {
    textShadow: "none",
    background: "#b3d4fc"
  },
  'code[class*="language-"] ::selection': {
    textShadow: "none",
    background: "#b3d4fc"
  },
  ':not(pre) > code[class*="language-"]': {
    background: "#f5f2f0",
    padding: ".1em",
    borderRadius: ".3em",
    whiteSpace: "normal"
  },
  comment: {
    color: "slategray"
  },
  prolog: {
    color: "slategray"
  },
  doctype: {
    color: "slategray"
  },
  cdata: {
    color: "slategray"
  },
  punctuation: {
    color: "#999"
  },
  namespace: {
    Opacity: ".7"
  },
  property: {
    color: "#905"
  },
  tag: {
    color: "#905"
  },
  boolean: {
    color: "#905"
  },
  number: {
    color: "#905"
  },
  constant: {
    color: "#905"
  },
  symbol: {
    color: "#905"
  },
  deleted: {
    color: "#905"
  },
  selector: {
    color: "#690"
  },
  "attr-name": {
    color: "#690"
  },
  string: {
    color: "#690"
  },
  char: {
    color: "#690"
  },
  builtin: {
    color: "#690"
  },
  inserted: {
    color: "#690"
  },
  operator: {
    color: "#9a6e3a",
    background: "hsla(0, 0%, 100%, .5)"
  },
  entity: {
    color: "#9a6e3a",
    background: "hsla(0, 0%, 100%, .5)",
    cursor: "help"
  },
  url: {
    color: "#9a6e3a",
    background: "hsla(0, 0%, 100%, .5)"
  },
  ".language-css .token.string": {
    color: "#9a6e3a",
    background: "hsla(0, 0%, 100%, .5)"
  },
  ".style .token.string": {
    color: "#9a6e3a",
    background: "hsla(0, 0%, 100%, .5)"
  },
  atrule: {
    color: "#07a"
  },
  "attr-value": {
    color: "#07a"
  },
  keyword: {
    color: "#07a"
  },
  function: {
    color: "#DD4A68"
  },
  "class-name": {
    color: "#DD4A68"
  },
  regex: {
    color: "#e90"
  },
  important: {
    color: "#e90",
    fontWeight: "bold"
  },
  variable: {
    color: "#e90"
  },
  bold: {
    fontWeight: "bold"
  },
  italic: {
    fontStyle: "italic"
  }
};
var pee = GI(nj, dee);
pee.supportedLanguages = VJ;
const UMe = {
  'code[class*="language-"]': {
    background: "hsl(230, 1%, 98%)",
    color: "hsl(230, 8%, 24%)",
    fontFamily: '"Fira Code", "Fira Mono", Menlo, Consolas, "DejaVu Sans Mono", monospace',
    direction: "ltr",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    lineHeight: "1.5",
    MozTabSize: "2",
    OTabSize: "2",
    tabSize: "2",
    WebkitHyphens: "none",
    MozHyphens: "none",
    msHyphens: "none",
    hyphens: "none"
  },
  'pre[class*="language-"]': {
    background: "hsl(230, 1%, 98%)",
    color: "hsl(230, 8%, 24%)",
    fontFamily: '"Fira Code", "Fira Mono", Menlo, Consolas, "DejaVu Sans Mono", monospace',
    direction: "ltr",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    lineHeight: "1.5",
    MozTabSize: "2",
    OTabSize: "2",
    tabSize: "2",
    WebkitHyphens: "none",
    MozHyphens: "none",
    msHyphens: "none",
    hyphens: "none",
    padding: "1em",
    margin: "0.5em 0",
    overflow: "auto",
    borderRadius: "0.3em"
  },
  'code[class*="language-"]::-moz-selection': {
    background: "hsl(230, 1%, 90%)",
    color: "inherit"
  },
  'code[class*="language-"] *::-moz-selection': {
    background: "hsl(230, 1%, 90%)",
    color: "inherit"
  },
  'pre[class*="language-"] *::-moz-selection': {
    background: "hsl(230, 1%, 90%)",
    color: "inherit"
  },
  'code[class*="language-"]::selection': {
    background: "hsl(230, 1%, 90%)",
    color: "inherit"
  },
  'code[class*="language-"] *::selection': {
    background: "hsl(230, 1%, 90%)",
    color: "inherit"
  },
  'pre[class*="language-"] *::selection': {
    background: "hsl(230, 1%, 90%)",
    color: "inherit"
  },
  ':not(pre) > code[class*="language-"]': {
    padding: "0.2em 0.3em",
    borderRadius: "0.3em",
    whiteSpace: "normal"
  },
  comment: {
    color: "hsl(230, 4%, 64%)",
    fontStyle: "italic"
  },
  prolog: {
    color: "hsl(230, 4%, 64%)"
  },
  cdata: {
    color: "hsl(230, 4%, 64%)"
  },
  doctype: {
    color: "hsl(230, 8%, 24%)"
  },
  punctuation: {
    color: "hsl(230, 8%, 24%)"
  },
  entity: {
    color: "hsl(230, 8%, 24%)",
    cursor: "help"
  },
  "attr-name": {
    color: "hsl(35, 99%, 36%)"
  },
  "class-name": {
    color: "hsl(35, 99%, 36%)"
  },
  boolean: {
    color: "hsl(35, 99%, 36%)"
  },
  constant: {
    color: "hsl(35, 99%, 36%)"
  },
  number: {
    color: "hsl(35, 99%, 36%)"
  },
  atrule: {
    color: "hsl(35, 99%, 36%)"
  },
  keyword: {
    color: "hsl(301, 63%, 40%)"
  },
  property: {
    color: "hsl(5, 74%, 59%)"
  },
  tag: {
    color: "hsl(5, 74%, 59%)"
  },
  symbol: {
    color: "hsl(5, 74%, 59%)"
  },
  deleted: {
    color: "hsl(5, 74%, 59%)"
  },
  important: {
    color: "hsl(5, 74%, 59%)"
  },
  selector: {
    color: "hsl(119, 34%, 47%)"
  },
  string: {
    color: "hsl(119, 34%, 47%)"
  },
  char: {
    color: "hsl(119, 34%, 47%)"
  },
  builtin: {
    color: "hsl(119, 34%, 47%)"
  },
  inserted: {
    color: "hsl(119, 34%, 47%)"
  },
  regex: {
    color: "hsl(119, 34%, 47%)"
  },
  "attr-value": {
    color: "hsl(119, 34%, 47%)"
  },
  "attr-value > .token.punctuation": {
    color: "hsl(119, 34%, 47%)"
  },
  variable: {
    color: "hsl(221, 87%, 60%)"
  },
  operator: {
    color: "hsl(221, 87%, 60%)"
  },
  function: {
    color: "hsl(221, 87%, 60%)"
  },
  url: {
    color: "hsl(198, 99%, 37%)"
  },
  "attr-value > .token.punctuation.attr-equals": {
    color: "hsl(230, 8%, 24%)"
  },
  "special-attr > .token.attr-value > .token.value.css": {
    color: "hsl(230, 8%, 24%)"
  },
  ".language-css .token.selector": {
    color: "hsl(5, 74%, 59%)"
  },
  ".language-css .token.property": {
    color: "hsl(230, 8%, 24%)"
  },
  ".language-css .token.function": {
    color: "hsl(198, 99%, 37%)"
  },
  ".language-css .token.url > .token.function": {
    color: "hsl(198, 99%, 37%)"
  },
  ".language-css .token.url > .token.string.url": {
    color: "hsl(119, 34%, 47%)"
  },
  ".language-css .token.important": {
    color: "hsl(301, 63%, 40%)"
  },
  ".language-css .token.atrule .token.rule": {
    color: "hsl(301, 63%, 40%)"
  },
  ".language-javascript .token.operator": {
    color: "hsl(301, 63%, 40%)"
  },
  ".language-javascript .token.template-string > .token.interpolation > .token.interpolation-punctuation.punctuation": {
    color: "hsl(344, 84%, 43%)"
  },
  ".language-json .token.operator": {
    color: "hsl(230, 8%, 24%)"
  },
  ".language-json .token.null.keyword": {
    color: "hsl(35, 99%, 36%)"
  },
  ".language-markdown .token.url": {
    color: "hsl(230, 8%, 24%)"
  },
  ".language-markdown .token.url > .token.operator": {
    color: "hsl(230, 8%, 24%)"
  },
  ".language-markdown .token.url-reference.url > .token.string": {
    color: "hsl(230, 8%, 24%)"
  },
  ".language-markdown .token.url > .token.content": {
    color: "hsl(221, 87%, 60%)"
  },
  ".language-markdown .token.url > .token.url": {
    color: "hsl(198, 99%, 37%)"
  },
  ".language-markdown .token.url-reference.url": {
    color: "hsl(198, 99%, 37%)"
  },
  ".language-markdown .token.blockquote.punctuation": {
    color: "hsl(230, 4%, 64%)",
    fontStyle: "italic"
  },
  ".language-markdown .token.hr.punctuation": {
    color: "hsl(230, 4%, 64%)",
    fontStyle: "italic"
  },
  ".language-markdown .token.code-snippet": {
    color: "hsl(119, 34%, 47%)"
  },
  ".language-markdown .token.bold .token.content": {
    color: "hsl(35, 99%, 36%)"
  },
  ".language-markdown .token.italic .token.content": {
    color: "hsl(301, 63%, 40%)"
  },
  ".language-markdown .token.strike .token.content": {
    color: "hsl(5, 74%, 59%)"
  },
  ".language-markdown .token.strike .token.punctuation": {
    color: "hsl(5, 74%, 59%)"
  },
  ".language-markdown .token.list.punctuation": {
    color: "hsl(5, 74%, 59%)"
  },
  ".language-markdown .token.title.important > .token.punctuation": {
    color: "hsl(5, 74%, 59%)"
  },
  bold: {
    fontWeight: "bold"
  },
  italic: {
    fontStyle: "italic"
  },
  namespace: {
    Opacity: "0.8"
  },
  "token.tab:not(:empty):before": {
    color: "hsla(230, 8%, 24%, 0.2)"
  },
  "token.cr:before": {
    color: "hsla(230, 8%, 24%, 0.2)"
  },
  "token.lf:before": {
    color: "hsla(230, 8%, 24%, 0.2)"
  },
  "token.space:before": {
    color: "hsla(230, 8%, 24%, 0.2)"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item": {
    marginRight: "0.4em"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > button": {
    background: "hsl(230, 1%, 90%)",
    color: "hsl(230, 6%, 44%)",
    padding: "0.1em 0.4em",
    borderRadius: "0.3em"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > a": {
    background: "hsl(230, 1%, 90%)",
    color: "hsl(230, 6%, 44%)",
    padding: "0.1em 0.4em",
    borderRadius: "0.3em"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > span": {
    background: "hsl(230, 1%, 90%)",
    color: "hsl(230, 6%, 44%)",
    padding: "0.1em 0.4em",
    borderRadius: "0.3em"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > button:hover": {
    background: "hsl(230, 1%, 78%)",
    color: "hsl(230, 8%, 24%)"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > button:focus": {
    background: "hsl(230, 1%, 78%)",
    color: "hsl(230, 8%, 24%)"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > a:hover": {
    background: "hsl(230, 1%, 78%)",
    color: "hsl(230, 8%, 24%)"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > a:focus": {
    background: "hsl(230, 1%, 78%)",
    color: "hsl(230, 8%, 24%)"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > span:hover": {
    background: "hsl(230, 1%, 78%)",
    color: "hsl(230, 8%, 24%)"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > span:focus": {
    background: "hsl(230, 1%, 78%)",
    color: "hsl(230, 8%, 24%)"
  },
  ".line-highlight.line-highlight": {
    background: "hsla(230, 8%, 24%, 0.05)"
  },
  ".line-highlight.line-highlight:before": {
    background: "hsl(230, 1%, 90%)",
    color: "hsl(230, 8%, 24%)",
    padding: "0.1em 0.6em",
    borderRadius: "0.3em",
    boxShadow: "0 2px 0 0 rgba(0, 0, 0, 0.2)"
  },
  ".line-highlight.line-highlight[data-end]:after": {
    background: "hsl(230, 1%, 90%)",
    color: "hsl(230, 8%, 24%)",
    padding: "0.1em 0.6em",
    borderRadius: "0.3em",
    boxShadow: "0 2px 0 0 rgba(0, 0, 0, 0.2)"
  },
  "pre[id].linkable-line-numbers.linkable-line-numbers span.line-numbers-rows > span:hover:before": {
    backgroundColor: "hsla(230, 8%, 24%, 0.05)"
  },
  ".line-numbers.line-numbers .line-numbers-rows": {
    borderRightColor: "hsla(230, 8%, 24%, 0.2)"
  },
  ".command-line .command-line-prompt": {
    borderRightColor: "hsla(230, 8%, 24%, 0.2)"
  },
  ".line-numbers .line-numbers-rows > span:before": {
    color: "hsl(230, 1%, 62%)"
  },
  ".command-line .command-line-prompt > span:before": {
    color: "hsl(230, 1%, 62%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-1": {
    color: "hsl(5, 74%, 59%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-5": {
    color: "hsl(5, 74%, 59%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-9": {
    color: "hsl(5, 74%, 59%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-2": {
    color: "hsl(119, 34%, 47%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-6": {
    color: "hsl(119, 34%, 47%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-10": {
    color: "hsl(119, 34%, 47%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-3": {
    color: "hsl(221, 87%, 60%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-7": {
    color: "hsl(221, 87%, 60%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-11": {
    color: "hsl(221, 87%, 60%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-4": {
    color: "hsl(301, 63%, 40%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-8": {
    color: "hsl(301, 63%, 40%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-12": {
    color: "hsl(301, 63%, 40%)"
  },
  "pre.diff-highlight > code .token.token.deleted:not(.prefix)": {
    backgroundColor: "hsla(353, 100%, 66%, 0.15)"
  },
  "pre > code.diff-highlight .token.token.deleted:not(.prefix)": {
    backgroundColor: "hsla(353, 100%, 66%, 0.15)"
  },
  "pre.diff-highlight > code .token.token.deleted:not(.prefix)::-moz-selection": {
    backgroundColor: "hsla(353, 95%, 66%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.deleted:not(.prefix) *::-moz-selection": {
    backgroundColor: "hsla(353, 95%, 66%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.deleted:not(.prefix)::-moz-selection": {
    backgroundColor: "hsla(353, 95%, 66%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.deleted:not(.prefix) *::-moz-selection": {
    backgroundColor: "hsla(353, 95%, 66%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.deleted:not(.prefix)::selection": {
    backgroundColor: "hsla(353, 95%, 66%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.deleted:not(.prefix) *::selection": {
    backgroundColor: "hsla(353, 95%, 66%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.deleted:not(.prefix)::selection": {
    backgroundColor: "hsla(353, 95%, 66%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.deleted:not(.prefix) *::selection": {
    backgroundColor: "hsla(353, 95%, 66%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.inserted:not(.prefix)": {
    backgroundColor: "hsla(137, 100%, 55%, 0.15)"
  },
  "pre > code.diff-highlight .token.token.inserted:not(.prefix)": {
    backgroundColor: "hsla(137, 100%, 55%, 0.15)"
  },
  "pre.diff-highlight > code .token.token.inserted:not(.prefix)::-moz-selection": {
    backgroundColor: "hsla(135, 73%, 55%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.inserted:not(.prefix) *::-moz-selection": {
    backgroundColor: "hsla(135, 73%, 55%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.inserted:not(.prefix)::-moz-selection": {
    backgroundColor: "hsla(135, 73%, 55%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.inserted:not(.prefix) *::-moz-selection": {
    backgroundColor: "hsla(135, 73%, 55%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.inserted:not(.prefix)::selection": {
    backgroundColor: "hsla(135, 73%, 55%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.inserted:not(.prefix) *::selection": {
    backgroundColor: "hsla(135, 73%, 55%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.inserted:not(.prefix)::selection": {
    backgroundColor: "hsla(135, 73%, 55%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.inserted:not(.prefix) *::selection": {
    backgroundColor: "hsla(135, 73%, 55%, 0.25)"
  },
  ".prism-previewer.prism-previewer:before": {
    borderColor: "hsl(0, 0, 95%)"
  },
  ".prism-previewer-gradient.prism-previewer-gradient div": {
    borderColor: "hsl(0, 0, 95%)",
    borderRadius: "0.3em"
  },
  ".prism-previewer-color.prism-previewer-color:before": {
    borderRadius: "0.3em"
  },
  ".prism-previewer-easing.prism-previewer-easing:before": {
    borderRadius: "0.3em"
  },
  ".prism-previewer.prism-previewer:after": {
    borderTopColor: "hsl(0, 0, 95%)"
  },
  ".prism-previewer-flipped.prism-previewer-flipped.after": {
    borderBottomColor: "hsl(0, 0, 95%)"
  },
  ".prism-previewer-angle.prism-previewer-angle:before": {
    background: "hsl(0, 0%, 100%)"
  },
  ".prism-previewer-time.prism-previewer-time:before": {
    background: "hsl(0, 0%, 100%)"
  },
  ".prism-previewer-easing.prism-previewer-easing": {
    background: "hsl(0, 0%, 100%)"
  },
  ".prism-previewer-angle.prism-previewer-angle circle": {
    stroke: "hsl(230, 8%, 24%)",
    strokeOpacity: "1"
  },
  ".prism-previewer-time.prism-previewer-time circle": {
    stroke: "hsl(230, 8%, 24%)",
    strokeOpacity: "1"
  },
  ".prism-previewer-easing.prism-previewer-easing circle": {
    stroke: "hsl(230, 8%, 24%)",
    fill: "transparent"
  },
  ".prism-previewer-easing.prism-previewer-easing path": {
    stroke: "hsl(230, 8%, 24%)"
  },
  ".prism-previewer-easing.prism-previewer-easing line": {
    stroke: "hsl(230, 8%, 24%)"
  }
};
var eP = {}, tP = { exports: {} }, rP = { exports: {} };
(function(t) {
  function e(r) {
    if (Array.isArray(r)) return r;
  }
  t.exports = e, t.exports.__esModule = !0, t.exports.default = t.exports;
})(rP);
var gee = rP.exports, nP = { exports: {} };
(function(t) {
  function e(r, n) {
    var a = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
    if (a != null) {
      var i, s, o, l, u = [], c = !0, f = !1;
      try {
        if (o = (a = a.call(r)).next, n === 0) {
          if (Object(a) !== a) return;
          c = !1;
        } else for (; !(c = (i = o.call(a)).done) && (u.push(i.value), u.length !== n); c = !0) ;
      } catch (h) {
        f = !0, s = h;
      } finally {
        try {
          if (!c && a.return != null && (l = a.return(), Object(l) !== l)) return;
        } finally {
          if (f) throw s;
        }
      }
      return u;
    }
  }
  t.exports = e, t.exports.__esModule = !0, t.exports.default = t.exports;
})(nP);
var vee = nP.exports, aP = { exports: {} }, iP = { exports: {} };
(function(t) {
  function e(r, n) {
    (n == null || n > r.length) && (n = r.length);
    for (var a = 0, i = Array(n); a < n; a++) i[a] = r[a];
    return i;
  }
  t.exports = e, t.exports.__esModule = !0, t.exports.default = t.exports;
})(iP);
var mee = iP.exports;
(function(t) {
  var e = mee;
  function r(n, a) {
    if (n) {
      if (typeof n == "string") return e(n, a);
      var i = {}.toString.call(n).slice(8, -1);
      return i === "Object" && n.constructor && (i = n.constructor.name), i === "Map" || i === "Set" ? Array.from(n) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? e(n, a) : void 0;
    }
  }
  t.exports = r, t.exports.__esModule = !0, t.exports.default = t.exports;
})(aP);
var yee = aP.exports, sP = { exports: {} };
(function(t) {
  function e() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  t.exports = e, t.exports.__esModule = !0, t.exports.default = t.exports;
})(sP);
var bee = sP.exports;
(function(t) {
  var e = gee, r = vee, n = yee, a = bee;
  function i(s, o) {
    return e(s) || r(s, o) || n(s, o) || a();
  }
  t.exports = i, t.exports.__esModule = !0, t.exports.default = t.exports;
})(tP);
var oP = tP.exports, r5 = {}, xee = Ky.default;
Object.defineProperty(r5, "__esModule", {
  value: !0
});
r5.default = wee;
var vk = xee(lt);
function wee(t) {
  var e = vk.useRef();
  e.current = t;
  var r = vk.useCallback(function() {
    for (var n, a = arguments.length, i = new Array(a), s = 0; s < a; s++)
      i[s] = arguments[s];
    return (n = e.current) === null || n === void 0 ? void 0 : n.call.apply(n, [e].concat(i));
  }, []);
  return r;
}
var Yc = {}, n5 = {};
Object.defineProperty(n5, "__esModule", {
  value: !0
});
n5.default = Eee;
function Eee() {
  return !!(typeof window < "u" && window.document && window.document.createElement);
}
var Tee = Kt.default, See = Ky.default;
Object.defineProperty(Yc, "__esModule", {
  value: !0
});
Yc.useLayoutUpdateEffect = Yc.default = void 0;
var oT = See(lt), Cee = Tee(n5), mk = process.env.NODE_ENV !== "test" && (0, Cee.default)() ? oT.useLayoutEffect : oT.useEffect, lP = function(e, r) {
  var n = oT.useRef(!0);
  mk(function() {
    return e(n.current);
  }, r), mk(function() {
    return n.current = !1, function() {
      n.current = !0;
    };
  }, []);
};
Yc.useLayoutUpdateEffect = function(e, r) {
  lP(function(n) {
    if (!n)
      return e();
  }, r);
};
Yc.default = lP;
var a5 = {}, Aee = Ky.default, kee = Kt.default;
Object.defineProperty(a5, "__esModule", {
  value: !0
});
a5.default = Mee;
var Ree = kee(oP), Wb = Aee(lt);
function Mee(t) {
  var e = Wb.useRef(!1), r = Wb.useState(t), n = (0, Ree.default)(r, 2), a = n[0], i = n[1];
  Wb.useEffect(function() {
    return e.current = !1, function() {
      e.current = !0;
    };
  }, []);
  function s(o, l) {
    l && e.current || i(o);
  }
  return [a, s];
}
var i5 = Kt.default;
Object.defineProperty(eP, "__esModule", {
  value: !0
});
var HMe = eP.default = _ee, yk = i5(oP), bk = i5(r5), xk = Yc, wk = i5(a5);
function jb(t) {
  return t !== void 0;
}
function _ee(t, e) {
  var r = e || {}, n = r.defaultValue, a = r.value, i = r.onChange, s = r.postState, o = (0, wk.default)(function() {
    return jb(a) ? a : jb(n) ? typeof n == "function" ? n() : n : typeof t == "function" ? t() : t;
  }), l = (0, yk.default)(o, 2), u = l[0], c = l[1], f = a !== void 0 ? a : u, h = s ? s(f) : f, d = (0, bk.default)(i), p = (0, wk.default)([f]), g = (0, yk.default)(p, 2), v = g[0], m = g[1];
  (0, xk.useLayoutUpdateEffect)(function() {
    var y = v[0];
    u !== y && d(u, y);
  }, [v]), (0, xk.useLayoutUpdateEffect)(function() {
    jb(a) || c(a);
  }, [a]);
  var b = (0, bk.default)(function(y, x) {
    c(y, x), m([f], x);
  });
  return [h, b];
}
var s5 = {};
Object.defineProperty(s5, "__esModule", {
  value: !0
});
var Lee = s5.default = void 0, Rt = {
  /**
   * MAC_ENTER
   */
  MAC_ENTER: 3,
  /**
   * BACKSPACE
   */
  BACKSPACE: 8,
  /**
   * TAB
   */
  TAB: 9,
  /**
   * NUMLOCK on FF/Safari Mac
   */
  NUM_CENTER: 12,
  // NUMLOCK on FF/Safari Mac
  /**
   * ENTER
   */
  ENTER: 13,
  /**
   * SHIFT
   */
  SHIFT: 16,
  /**
   * CTRL
   */
  CTRL: 17,
  /**
   * ALT
   */
  ALT: 18,
  /**
   * PAUSE
   */
  PAUSE: 19,
  /**
   * CAPS_LOCK
   */
  CAPS_LOCK: 20,
  /**
   * ESC
   */
  ESC: 27,
  /**
   * SPACE
   */
  SPACE: 32,
  /**
   * PAGE_UP
   */
  PAGE_UP: 33,
  // also NUM_NORTH_EAST
  /**
   * PAGE_DOWN
   */
  PAGE_DOWN: 34,
  // also NUM_SOUTH_EAST
  /**
   * END
   */
  END: 35,
  // also NUM_SOUTH_WEST
  /**
   * HOME
   */
  HOME: 36,
  // also NUM_NORTH_WEST
  /**
   * LEFT
   */
  LEFT: 37,
  // also NUM_WEST
  /**
   * UP
   */
  UP: 38,
  // also NUM_NORTH
  /**
   * RIGHT
   */
  RIGHT: 39,
  // also NUM_EAST
  /**
   * DOWN
   */
  DOWN: 40,
  // also NUM_SOUTH
  /**
   * PRINT_SCREEN
   */
  PRINT_SCREEN: 44,
  /**
   * INSERT
   */
  INSERT: 45,
  // also NUM_INSERT
  /**
   * DELETE
   */
  DELETE: 46,
  // also NUM_DELETE
  /**
   * ZERO
   */
  ZERO: 48,
  /**
   * ONE
   */
  ONE: 49,
  /**
   * TWO
   */
  TWO: 50,
  /**
   * THREE
   */
  THREE: 51,
  /**
   * FOUR
   */
  FOUR: 52,
  /**
   * FIVE
   */
  FIVE: 53,
  /**
   * SIX
   */
  SIX: 54,
  /**
   * SEVEN
   */
  SEVEN: 55,
  /**
   * EIGHT
   */
  EIGHT: 56,
  /**
   * NINE
   */
  NINE: 57,
  /**
   * QUESTION_MARK
   */
  QUESTION_MARK: 63,
  // needs localization
  /**
   * A
   */
  A: 65,
  /**
   * B
   */
  B: 66,
  /**
   * C
   */
  C: 67,
  /**
   * D
   */
  D: 68,
  /**
   * E
   */
  E: 69,
  /**
   * F
   */
  F: 70,
  /**
   * G
   */
  G: 71,
  /**
   * H
   */
  H: 72,
  /**
   * I
   */
  I: 73,
  /**
   * J
   */
  J: 74,
  /**
   * K
   */
  K: 75,
  /**
   * L
   */
  L: 76,
  /**
   * M
   */
  M: 77,
  /**
   * N
   */
  N: 78,
  /**
   * O
   */
  O: 79,
  /**
   * P
   */
  P: 80,
  /**
   * Q
   */
  Q: 81,
  /**
   * R
   */
  R: 82,
  /**
   * S
   */
  S: 83,
  /**
   * T
   */
  T: 84,
  /**
   * U
   */
  U: 85,
  /**
   * V
   */
  V: 86,
  /**
   * W
   */
  W: 87,
  /**
   * X
   */
  X: 88,
  /**
   * Y
   */
  Y: 89,
  /**
   * Z
   */
  Z: 90,
  /**
   * META
   */
  META: 91,
  // WIN_KEY_LEFT
  /**
   * WIN_KEY_RIGHT
   */
  WIN_KEY_RIGHT: 92,
  /**
   * CONTEXT_MENU
   */
  CONTEXT_MENU: 93,
  /**
   * NUM_ZERO
   */
  NUM_ZERO: 96,
  /**
   * NUM_ONE
   */
  NUM_ONE: 97,
  /**
   * NUM_TWO
   */
  NUM_TWO: 98,
  /**
   * NUM_THREE
   */
  NUM_THREE: 99,
  /**
   * NUM_FOUR
   */
  NUM_FOUR: 100,
  /**
   * NUM_FIVE
   */
  NUM_FIVE: 101,
  /**
   * NUM_SIX
   */
  NUM_SIX: 102,
  /**
   * NUM_SEVEN
   */
  NUM_SEVEN: 103,
  /**
   * NUM_EIGHT
   */
  NUM_EIGHT: 104,
  /**
   * NUM_NINE
   */
  NUM_NINE: 105,
  /**
   * NUM_MULTIPLY
   */
  NUM_MULTIPLY: 106,
  /**
   * NUM_PLUS
   */
  NUM_PLUS: 107,
  /**
   * NUM_MINUS
   */
  NUM_MINUS: 109,
  /**
   * NUM_PERIOD
   */
  NUM_PERIOD: 110,
  /**
   * NUM_DIVISION
   */
  NUM_DIVISION: 111,
  /**
   * F1
   */
  F1: 112,
  /**
   * F2
   */
  F2: 113,
  /**
   * F3
   */
  F3: 114,
  /**
   * F4
   */
  F4: 115,
  /**
   * F5
   */
  F5: 116,
  /**
   * F6
   */
  F6: 117,
  /**
   * F7
   */
  F7: 118,
  /**
   * F8
   */
  F8: 119,
  /**
   * F9
   */
  F9: 120,
  /**
   * F10
   */
  F10: 121,
  /**
   * F11
   */
  F11: 122,
  /**
   * F12
   */
  F12: 123,
  /**
   * NUMLOCK
   */
  NUMLOCK: 144,
  /**
   * SEMICOLON
   */
  SEMICOLON: 186,
  // needs localization
  /**
   * DASH
   */
  DASH: 189,
  // needs localization
  /**
   * EQUALS
   */
  EQUALS: 187,
  // needs localization
  /**
   * COMMA
   */
  COMMA: 188,
  // needs localization
  /**
   * PERIOD
   */
  PERIOD: 190,
  // needs localization
  /**
   * SLASH
   */
  SLASH: 191,
  // needs localization
  /**
   * APOSTROPHE
   */
  APOSTROPHE: 192,
  // needs localization
  /**
   * SINGLE_QUOTE
   */
  SINGLE_QUOTE: 222,
  // needs localization
  /**
   * OPEN_SQUARE_BRACKET
   */
  OPEN_SQUARE_BRACKET: 219,
  // needs localization
  /**
   * BACKSLASH
   */
  BACKSLASH: 220,
  // needs localization
  /**
   * CLOSE_SQUARE_BRACKET
   */
  CLOSE_SQUARE_BRACKET: 221,
  // needs localization
  /**
   * WIN_KEY
   */
  WIN_KEY: 224,
  /**
   * MAC_FF_META
   */
  MAC_FF_META: 224,
  // Firefox (Gecko) fires this for the meta key instead of 91
  /**
   * WIN_IME
   */
  WIN_IME: 229,
  // ======================== Function ========================
  /**
   * whether text and modified key is entered at the same time.
   */
  isTextModifyingKeyEvent: function(e) {
    var r = e.keyCode;
    if (e.altKey && !e.ctrlKey || e.metaKey || // Function keys don't generate text
    r >= Rt.F1 && r <= Rt.F12)
      return !1;
    switch (r) {
      case Rt.ALT:
      case Rt.CAPS_LOCK:
      case Rt.CONTEXT_MENU:
      case Rt.CTRL:
      case Rt.DOWN:
      case Rt.END:
      case Rt.ESC:
      case Rt.HOME:
      case Rt.INSERT:
      case Rt.LEFT:
      case Rt.MAC_FF_META:
      case Rt.META:
      case Rt.NUMLOCK:
      case Rt.NUM_CENTER:
      case Rt.PAGE_DOWN:
      case Rt.PAGE_UP:
      case Rt.PAUSE:
      case Rt.PRINT_SCREEN:
      case Rt.RIGHT:
      case Rt.SHIFT:
      case Rt.UP:
      case Rt.WIN_KEY:
      case Rt.WIN_KEY_RIGHT:
        return !1;
      default:
        return !0;
    }
  },
  /**
   * whether character is entered.
   */
  isCharacterKey: function(e) {
    if (e >= Rt.ZERO && e <= Rt.NINE || e >= Rt.NUM_ZERO && e <= Rt.NUM_MULTIPLY || e >= Rt.A && e <= Rt.Z || window.navigator.userAgent.indexOf("WebKit") !== -1 && e === 0)
      return !0;
    switch (e) {
      case Rt.SPACE:
      case Rt.QUESTION_MARK:
      case Rt.NUM_PLUS:
      case Rt.NUM_MINUS:
      case Rt.NUM_PERIOD:
      case Rt.NUM_DIVISION:
      case Rt.SEMICOLON:
      case Rt.DASH:
      case Rt.EQUALS:
      case Rt.COMMA:
      case Rt.PERIOD:
      case Rt.SLASH:
      case Rt.APOSTROPHE:
      case Rt.SINGLE_QUOTE:
      case Rt.OPEN_SQUARE_BRACKET:
      case Rt.BACKSLASH:
      case Rt.CLOSE_SQUARE_BRACKET:
        return !0;
      default:
        return !1;
    }
  }
};
Lee = s5.default = Rt;
var uP = "Expected a function", Ek = NaN, Nee = "[object Symbol]", Oee = /^\s+|\s+$/g, Iee = /^[-+]0x[0-9a-f]+$/i, Pee = /^0b[01]+$/i, Dee = /^0o[0-7]+$/i, $ee = parseInt, Fee = typeof Jt == "object" && Jt && Jt.Object === Object && Jt, Bee = typeof self == "object" && self && self.Object === Object && self, zee = Fee || Bee || Function("return this")(), Gee = Object.prototype, Uee = Gee.toString, Hee = Math.max, Vee = Math.min, Yb = function() {
  return zee.Date.now();
};
function qee(t, e, r) {
  var n, a, i, s, o, l, u = 0, c = !1, f = !1, h = !0;
  if (typeof t != "function")
    throw new TypeError(uP);
  e = Tk(e) || 0, Hv(r) && (c = !!r.leading, f = "maxWait" in r, i = f ? Hee(Tk(r.maxWait) || 0, e) : i, h = "trailing" in r ? !!r.trailing : h);
  function d(S) {
    var w = n, C = a;
    return n = a = void 0, u = S, s = t.apply(C, w), s;
  }
  function p(S) {
    return u = S, o = setTimeout(m, e), c ? d(S) : s;
  }
  function g(S) {
    var w = S - l, C = S - u, k = e - w;
    return f ? Vee(k, i - C) : k;
  }
  function v(S) {
    var w = S - l, C = S - u;
    return l === void 0 || w >= e || w < 0 || f && C >= i;
  }
  function m() {
    var S = Yb();
    if (v(S))
      return b(S);
    o = setTimeout(m, g(S));
  }
  function b(S) {
    return o = void 0, h && n ? d(S) : (n = a = void 0, s);
  }
  function y() {
    o !== void 0 && clearTimeout(o), u = 0, n = l = a = o = void 0;
  }
  function x() {
    return o === void 0 ? s : b(Yb());
  }
  function E() {
    var S = Yb(), w = v(S);
    if (n = arguments, a = this, l = S, w) {
      if (o === void 0)
        return p(l);
      if (f)
        return o = setTimeout(m, e), d(l);
    }
    return o === void 0 && (o = setTimeout(m, e)), s;
  }
  return E.cancel = y, E.flush = x, E;
}
function Wee(t, e, r) {
  var n = !0, a = !0;
  if (typeof t != "function")
    throw new TypeError(uP);
  return Hv(r) && (n = "leading" in r ? !!r.leading : n, a = "trailing" in r ? !!r.trailing : a), qee(t, e, {
    leading: n,
    maxWait: e,
    trailing: a
  });
}
function Hv(t) {
  var e = typeof t;
  return !!t && (e == "object" || e == "function");
}
function jee(t) {
  return !!t && typeof t == "object";
}
function Yee(t) {
  return typeof t == "symbol" || jee(t) && Uee.call(t) == Nee;
}
function Tk(t) {
  if (typeof t == "number")
    return t;
  if (Yee(t))
    return Ek;
  if (Hv(t)) {
    var e = typeof t.valueOf == "function" ? t.valueOf() : t;
    t = Hv(e) ? e + "" : e;
  }
  if (typeof t != "string")
    return t === 0 ? t : +t;
  t = t.replace(Oee, "");
  var r = Pee.test(t);
  return r || Dee.test(t) ? $ee(t.slice(2), r ? 2 : 8) : Iee.test(t) ? Ek : +t;
}
var Xee = Wee;
const VMe = /* @__PURE__ */ ho(Xee), ev = {
  /* CLAMP */
  min: {
    r: 0,
    g: 0,
    b: 0,
    s: 0,
    l: 0,
    a: 0
  },
  max: {
    r: 255,
    g: 255,
    b: 255,
    h: 360,
    s: 100,
    l: 100,
    a: 1
  },
  clamp: {
    r: (t) => t >= 255 ? 255 : t < 0 ? 0 : t,
    g: (t) => t >= 255 ? 255 : t < 0 ? 0 : t,
    b: (t) => t >= 255 ? 255 : t < 0 ? 0 : t,
    h: (t) => t % 360,
    s: (t) => t >= 100 ? 100 : t < 0 ? 0 : t,
    l: (t) => t >= 100 ? 100 : t < 0 ? 0 : t,
    a: (t) => t >= 1 ? 1 : t < 0 ? 0 : t
  },
  /* CONVERSION */
  //SOURCE: https://planetcalc.com/7779
  toLinear: (t) => {
    const e = t / 255;
    return t > 0.03928 ? Math.pow((e + 0.055) / 1.055, 2.4) : e / 12.92;
  },
  //SOURCE: https://gist.github.com/mjackson/5311256
  hue2rgb: (t, e, r) => (r < 0 && (r += 1), r > 1 && (r -= 1), r < 1 / 6 ? t + (e - t) * 6 * r : r < 1 / 2 ? e : r < 2 / 3 ? t + (e - t) * (2 / 3 - r) * 6 : t),
  hsl2rgb: ({ h: t, s: e, l: r }, n) => {
    if (!e)
      return r * 2.55;
    t /= 360, e /= 100, r /= 100;
    const a = r < 0.5 ? r * (1 + e) : r + e - r * e, i = 2 * r - a;
    switch (n) {
      case "r":
        return ev.hue2rgb(i, a, t + 1 / 3) * 255;
      case "g":
        return ev.hue2rgb(i, a, t) * 255;
      case "b":
        return ev.hue2rgb(i, a, t - 1 / 3) * 255;
    }
  },
  rgb2hsl: ({ r: t, g: e, b: r }, n) => {
    t /= 255, e /= 255, r /= 255;
    const a = Math.max(t, e, r), i = Math.min(t, e, r), s = (a + i) / 2;
    if (n === "l")
      return s * 100;
    if (a === i)
      return 0;
    const o = a - i, l = s > 0.5 ? o / (2 - a - i) : o / (a + i);
    if (n === "s")
      return l * 100;
    switch (a) {
      case t:
        return ((e - r) / o + (e < r ? 6 : 0)) * 60;
      case e:
        return ((r - t) / o + 2) * 60;
      case r:
        return ((t - e) / o + 4) * 60;
      default:
        return -1;
    }
  }
}, Kee = {
  /* API */
  clamp: (t, e, r) => e > r ? Math.min(e, Math.max(r, t)) : Math.min(r, Math.max(e, t)),
  round: (t) => Math.round(t * 1e10) / 1e10
}, Zee = {
  /* API */
  dec2hex: (t) => {
    const e = Math.round(t).toString(16);
    return e.length > 1 ? e : `0${e}`;
  }
}, Nt = {
  channel: ev,
  lang: Kee,
  unit: Zee
}, Ro = {};
for (let t = 0; t <= 255; t++)
  Ro[t] = Nt.unit.dec2hex(t);
const Yn = {
  ALL: 0,
  RGB: 1,
  HSL: 2
};
let Qee = class {
  constructor() {
    this.type = Yn.ALL;
  }
  /* API */
  get() {
    return this.type;
  }
  set(e) {
    if (this.type && this.type !== e)
      throw new Error("Cannot change both RGB and HSL channels at the same time");
    this.type = e;
  }
  reset() {
    this.type = Yn.ALL;
  }
  is(e) {
    return this.type === e;
  }
};
class Jee {
  /* CONSTRUCTOR */
  constructor(e, r) {
    this.color = r, this.changed = !1, this.data = e, this.type = new Qee();
  }
  /* API */
  set(e, r) {
    return this.color = r, this.changed = !1, this.data = e, this.type.type = Yn.ALL, this;
  }
  /* HELPERS */
  _ensureHSL() {
    const e = this.data, { h: r, s: n, l: a } = e;
    r === void 0 && (e.h = Nt.channel.rgb2hsl(e, "h")), n === void 0 && (e.s = Nt.channel.rgb2hsl(e, "s")), a === void 0 && (e.l = Nt.channel.rgb2hsl(e, "l"));
  }
  _ensureRGB() {
    const e = this.data, { r, g: n, b: a } = e;
    r === void 0 && (e.r = Nt.channel.hsl2rgb(e, "r")), n === void 0 && (e.g = Nt.channel.hsl2rgb(e, "g")), a === void 0 && (e.b = Nt.channel.hsl2rgb(e, "b"));
  }
  /* GETTERS */
  get r() {
    const e = this.data, r = e.r;
    return !this.type.is(Yn.HSL) && r !== void 0 ? r : (this._ensureHSL(), Nt.channel.hsl2rgb(e, "r"));
  }
  get g() {
    const e = this.data, r = e.g;
    return !this.type.is(Yn.HSL) && r !== void 0 ? r : (this._ensureHSL(), Nt.channel.hsl2rgb(e, "g"));
  }
  get b() {
    const e = this.data, r = e.b;
    return !this.type.is(Yn.HSL) && r !== void 0 ? r : (this._ensureHSL(), Nt.channel.hsl2rgb(e, "b"));
  }
  get h() {
    const e = this.data, r = e.h;
    return !this.type.is(Yn.RGB) && r !== void 0 ? r : (this._ensureRGB(), Nt.channel.rgb2hsl(e, "h"));
  }
  get s() {
    const e = this.data, r = e.s;
    return !this.type.is(Yn.RGB) && r !== void 0 ? r : (this._ensureRGB(), Nt.channel.rgb2hsl(e, "s"));
  }
  get l() {
    const e = this.data, r = e.l;
    return !this.type.is(Yn.RGB) && r !== void 0 ? r : (this._ensureRGB(), Nt.channel.rgb2hsl(e, "l"));
  }
  get a() {
    return this.data.a;
  }
  /* SETTERS */
  set r(e) {
    this.type.set(Yn.RGB), this.changed = !0, this.data.r = e;
  }
  set g(e) {
    this.type.set(Yn.RGB), this.changed = !0, this.data.g = e;
  }
  set b(e) {
    this.type.set(Yn.RGB), this.changed = !0, this.data.b = e;
  }
  set h(e) {
    this.type.set(Yn.HSL), this.changed = !0, this.data.h = e;
  }
  set s(e) {
    this.type.set(Yn.HSL), this.changed = !0, this.data.s = e;
  }
  set l(e) {
    this.type.set(Yn.HSL), this.changed = !0, this.data.l = e;
  }
  set a(e) {
    this.changed = !0, this.data.a = e;
  }
}
const a1 = new Jee({ r: 0, g: 0, b: 0, a: 0 }, "transparent"), gc = {
  /* VARIABLES */
  re: /^#((?:[a-f0-9]{2}){2,4}|[a-f0-9]{3})$/i,
  /* API */
  parse: (t) => {
    if (t.charCodeAt(0) !== 35)
      return;
    const e = t.match(gc.re);
    if (!e)
      return;
    const r = e[1], n = parseInt(r, 16), a = r.length, i = a % 4 === 0, s = a > 4, o = s ? 1 : 17, l = s ? 8 : 4, u = i ? 0 : -1, c = s ? 255 : 15;
    return a1.set({
      r: (n >> l * (u + 3) & c) * o,
      g: (n >> l * (u + 2) & c) * o,
      b: (n >> l * (u + 1) & c) * o,
      a: i ? (n & c) * o / 255 : 1
    }, t);
  },
  stringify: (t) => {
    const { r: e, g: r, b: n, a } = t;
    return a < 1 ? `#${Ro[Math.round(e)]}${Ro[Math.round(r)]}${Ro[Math.round(n)]}${Ro[Math.round(a * 255)]}` : `#${Ro[Math.round(e)]}${Ro[Math.round(r)]}${Ro[Math.round(n)]}`;
  }
}, Bl = {
  /* VARIABLES */
  re: /^hsla?\(\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?(?:deg|grad|rad|turn)?)\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?%)\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?%)(?:\s*?(?:,|\/)\s*?\+?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?(%)?))?\s*?\)$/i,
  hueRe: /^(.+?)(deg|grad|rad|turn)$/i,
  /* HELPERS */
  _hue2deg: (t) => {
    const e = t.match(Bl.hueRe);
    if (e) {
      const [, r, n] = e;
      switch (n) {
        case "grad":
          return Nt.channel.clamp.h(parseFloat(r) * 0.9);
        case "rad":
          return Nt.channel.clamp.h(parseFloat(r) * 180 / Math.PI);
        case "turn":
          return Nt.channel.clamp.h(parseFloat(r) * 360);
      }
    }
    return Nt.channel.clamp.h(parseFloat(t));
  },
  /* API */
  parse: (t) => {
    const e = t.charCodeAt(0);
    if (e !== 104 && e !== 72)
      return;
    const r = t.match(Bl.re);
    if (!r)
      return;
    const [, n, a, i, s, o] = r;
    return a1.set({
      h: Bl._hue2deg(n),
      s: Nt.channel.clamp.s(parseFloat(a)),
      l: Nt.channel.clamp.l(parseFloat(i)),
      a: s ? Nt.channel.clamp.a(o ? parseFloat(s) / 100 : parseFloat(s)) : 1
    }, t);
  },
  stringify: (t) => {
    const { h: e, s: r, l: n, a } = t;
    return a < 1 ? `hsla(${Nt.lang.round(e)}, ${Nt.lang.round(r)}%, ${Nt.lang.round(n)}%, ${a})` : `hsl(${Nt.lang.round(e)}, ${Nt.lang.round(r)}%, ${Nt.lang.round(n)}%)`;
  }
}, xd = {
  /* VARIABLES */
  colors: {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyanaqua: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    gold: "#ffd700",
    goldenrod: "#daa520",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavender: "#e6e6fa",
    lavenderblush: "#fff0f5",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    rebeccapurple: "#663399",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    transparent: "#00000000",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
  },
  /* API */
  parse: (t) => {
    t = t.toLowerCase();
    const e = xd.colors[t];
    if (e)
      return gc.parse(e);
  },
  stringify: (t) => {
    const e = gc.stringify(t);
    for (const r in xd.colors)
      if (xd.colors[r] === e)
        return r;
  }
}, wh = {
  /* VARIABLES */
  re: /^rgba?\(\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))(?:\s*?(?:,|\/)\s*?\+?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?)))?\s*?\)$/i,
  /* API */
  parse: (t) => {
    const e = t.charCodeAt(0);
    if (e !== 114 && e !== 82)
      return;
    const r = t.match(wh.re);
    if (!r)
      return;
    const [, n, a, i, s, o, l, u, c] = r;
    return a1.set({
      r: Nt.channel.clamp.r(a ? parseFloat(n) * 2.55 : parseFloat(n)),
      g: Nt.channel.clamp.g(s ? parseFloat(i) * 2.55 : parseFloat(i)),
      b: Nt.channel.clamp.b(l ? parseFloat(o) * 2.55 : parseFloat(o)),
      a: u ? Nt.channel.clamp.a(c ? parseFloat(u) / 100 : parseFloat(u)) : 1
    }, t);
  },
  stringify: (t) => {
    const { r: e, g: r, b: n, a } = t;
    return a < 1 ? `rgba(${Nt.lang.round(e)}, ${Nt.lang.round(r)}, ${Nt.lang.round(n)}, ${Nt.lang.round(a)})` : `rgb(${Nt.lang.round(e)}, ${Nt.lang.round(r)}, ${Nt.lang.round(n)})`;
  }
}, Wi = {
  /* VARIABLES */
  format: {
    keyword: xd,
    hex: gc,
    rgb: wh,
    rgba: wh,
    hsl: Bl,
    hsla: Bl
  },
  /* API */
  parse: (t) => {
    if (typeof t != "string")
      return t;
    const e = gc.parse(t) || wh.parse(t) || Bl.parse(t) || xd.parse(t);
    if (e)
      return e;
    throw new Error(`Unsupported color format: "${t}"`);
  },
  stringify: (t) => !t.changed && t.color ? t.color : t.type.is(Yn.HSL) || t.data.r === void 0 ? Bl.stringify(t) : t.a < 1 || !Number.isInteger(t.r) || !Number.isInteger(t.g) || !Number.isInteger(t.b) ? wh.stringify(t) : gc.stringify(t)
}, cP = (t, e) => {
  const r = Wi.parse(t);
  for (const n in e)
    r[n] = Nt.channel.clamp[n](e[n]);
  return Wi.stringify(r);
}, ete = (t, e, r = 0, n = 1) => {
  if (typeof t != "number")
    return cP(t, { a: e });
  const a = a1.set({
    r: Nt.channel.clamp.r(t),
    g: Nt.channel.clamp.g(e),
    b: Nt.channel.clamp.b(r),
    a: Nt.channel.clamp.a(n)
  });
  return Wi.stringify(a);
}, WMe = (t, e) => Nt.lang.round(Wi.parse(t)[e]), tte = (t) => {
  const { r: e, g: r, b: n } = Wi.parse(t), a = 0.2126 * Nt.channel.toLinear(e) + 0.7152 * Nt.channel.toLinear(r) + 0.0722 * Nt.channel.toLinear(n);
  return Nt.lang.round(a);
}, rte = (t) => tte(t) >= 0.5, jMe = (t) => !rte(t), fP = (t, e, r) => {
  const n = Wi.parse(t), a = n[e], i = Nt.channel.clamp[e](a + r);
  return a !== i && (n[e] = i), Wi.stringify(n);
}, YMe = (t, e) => fP(t, "l", e), XMe = (t, e) => fP(t, "l", -e), KMe = (t, e) => {
  const r = Wi.parse(t), n = {};
  for (const a in e)
    e[a] && (n[a] = r[a] + e[a]);
  return cP(t, n);
}, nte = (t, e, r = 50) => {
  const { r: n, g: a, b: i, a: s } = Wi.parse(t), { r: o, g: l, b: u, a: c } = Wi.parse(e), f = r / 100, h = f * 2 - 1, d = s - c, g = ((h * d === -1 ? h : (h + d) / (1 + h * d)) + 1) / 2, v = 1 - g, m = n * g + o * v, b = a * g + l * v, y = i * g + u * v, x = s * f + c * (1 - f);
  return ete(m, b, y, x);
}, ZMe = (t, e = 100) => {
  const r = Wi.parse(t);
  return r.r = 255 - r.r, r.g = 255 - r.g, r.b = 255 - r.b, nte(r, t, e);
};
/*! @license DOMPurify 3.3.0 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.3.0/LICENSE */
const {
  entries: hP,
  setPrototypeOf: Sk,
  isFrozen: ate,
  getPrototypeOf: ite,
  getOwnPropertyDescriptor: ste
} = Object;
let {
  freeze: fa,
  seal: yi,
  create: lT
} = Object, {
  apply: uT,
  construct: cT
} = typeof Reflect < "u" && Reflect;
fa || (fa = function(e) {
  return e;
});
yi || (yi = function(e) {
  return e;
});
uT || (uT = function(e, r) {
  for (var n = arguments.length, a = new Array(n > 2 ? n - 2 : 0), i = 2; i < n; i++)
    a[i - 2] = arguments[i];
  return e.apply(r, a);
});
cT || (cT = function(e) {
  for (var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), a = 1; a < r; a++)
    n[a - 1] = arguments[a];
  return new e(...n);
});
const Ip = ha(Array.prototype.forEach), ote = ha(Array.prototype.lastIndexOf), Ck = ha(Array.prototype.pop), Wf = ha(Array.prototype.push), lte = ha(Array.prototype.splice), tv = ha(String.prototype.toLowerCase), Xb = ha(String.prototype.toString), Kb = ha(String.prototype.match), jf = ha(String.prototype.replace), ute = ha(String.prototype.indexOf), cte = ha(String.prototype.trim), ki = ha(Object.prototype.hasOwnProperty), ia = ha(RegExp.prototype.test), Yf = fte(TypeError);
function ha(t) {
  return function(e) {
    e instanceof RegExp && (e.lastIndex = 0);
    for (var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), a = 1; a < r; a++)
      n[a - 1] = arguments[a];
    return uT(t, e, n);
  };
}
function fte(t) {
  return function() {
    for (var e = arguments.length, r = new Array(e), n = 0; n < e; n++)
      r[n] = arguments[n];
    return cT(t, r);
  };
}
function qt(t, e) {
  let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : tv;
  Sk && Sk(t, null);
  let n = e.length;
  for (; n--; ) {
    let a = e[n];
    if (typeof a == "string") {
      const i = r(a);
      i !== a && (ate(e) || (e[n] = i), a = i);
    }
    t[a] = !0;
  }
  return t;
}
function hte(t) {
  for (let e = 0; e < t.length; e++)
    ki(t, e) || (t[e] = null);
  return t;
}
function Os(t) {
  const e = lT(null);
  for (const [r, n] of hP(t))
    ki(t, r) && (Array.isArray(n) ? e[r] = hte(n) : n && typeof n == "object" && n.constructor === Object ? e[r] = Os(n) : e[r] = n);
  return e;
}
function Xf(t, e) {
  for (; t !== null; ) {
    const n = ste(t, e);
    if (n) {
      if (n.get)
        return ha(n.get);
      if (typeof n.value == "function")
        return ha(n.value);
    }
    t = ite(t);
  }
  function r() {
    return null;
  }
  return r;
}
const Ak = fa(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "search", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), Zb = fa(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "enterkeyhint", "exportparts", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "inputmode", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "part", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), Qb = fa(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), dte = fa(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), Jb = fa(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), pte = fa(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), kk = fa(["#text"]), Rk = fa(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "exportparts", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inert", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "part", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "slot", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), ex = fa(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "mask-type", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), Mk = fa(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), Pp = fa(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), gte = yi(/\{\{[\w\W]*|[\w\W]*\}\}/gm), vte = yi(/<%[\w\W]*|[\w\W]*%>/gm), mte = yi(/\$\{[\w\W]*/gm), yte = yi(/^data-[\-\w.\u00B7-\uFFFF]+$/), bte = yi(/^aria-[\-\w]+$/), dP = yi(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), xte = yi(/^(?:\w+script|data):/i), wte = yi(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), pP = yi(/^html$/i), Ete = yi(/^[a-z][.\w]*(-[.\w]+)+$/i);
var _k = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ARIA_ATTR: bte,
  ATTR_WHITESPACE: wte,
  CUSTOM_ELEMENT: Ete,
  DATA_ATTR: yte,
  DOCTYPE_NAME: pP,
  ERB_EXPR: vte,
  IS_ALLOWED_URI: dP,
  IS_SCRIPT_OR_DATA: xte,
  MUSTACHE_EXPR: gte,
  TMPLIT_EXPR: mte
});
const Kf = {
  element: 1,
  text: 3,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9
}, Tte = function() {
  return typeof window > "u" ? null : window;
}, Ste = function(e, r) {
  if (typeof e != "object" || typeof e.createPolicy != "function")
    return null;
  let n = null;
  const a = "data-tt-policy-suffix";
  r && r.hasAttribute(a) && (n = r.getAttribute(a));
  const i = "dompurify" + (n ? "#" + n : "");
  try {
    return e.createPolicy(i, {
      createHTML(s) {
        return s;
      },
      createScriptURL(s) {
        return s;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + i + " could not be created."), null;
  }
}, Lk = function() {
  return {
    afterSanitizeAttributes: [],
    afterSanitizeElements: [],
    afterSanitizeShadowDOM: [],
    beforeSanitizeAttributes: [],
    beforeSanitizeElements: [],
    beforeSanitizeShadowDOM: [],
    uponSanitizeAttribute: [],
    uponSanitizeElement: [],
    uponSanitizeShadowNode: []
  };
};
function gP() {
  let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Tte();
  const e = (ze) => gP(ze);
  if (e.version = "3.3.0", e.removed = [], !t || !t.document || t.document.nodeType !== Kf.document || !t.Element)
    return e.isSupported = !1, e;
  let {
    document: r
  } = t;
  const n = r, a = n.currentScript, {
    DocumentFragment: i,
    HTMLTemplateElement: s,
    Node: o,
    Element: l,
    NodeFilter: u,
    NamedNodeMap: c = t.NamedNodeMap || t.MozNamedAttrMap,
    HTMLFormElement: f,
    DOMParser: h,
    trustedTypes: d
  } = t, p = l.prototype, g = Xf(p, "cloneNode"), v = Xf(p, "remove"), m = Xf(p, "nextSibling"), b = Xf(p, "childNodes"), y = Xf(p, "parentNode");
  if (typeof s == "function") {
    const ze = r.createElement("template");
    ze.content && ze.content.ownerDocument && (r = ze.content.ownerDocument);
  }
  let x, E = "";
  const {
    implementation: S,
    createNodeIterator: w,
    createDocumentFragment: C,
    getElementsByTagName: k
  } = r, {
    importNode: N
  } = n;
  let R = Lk();
  e.isSupported = typeof hP == "function" && typeof y == "function" && S && S.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: _,
    ERB_EXPR: O,
    TMPLIT_EXPR: T,
    DATA_ATTR: L,
    ARIA_ATTR: M,
    IS_SCRIPT_OR_DATA: A,
    ATTR_WHITESPACE: I,
    CUSTOM_ELEMENT: D
  } = _k;
  let {
    IS_ALLOWED_URI: F
  } = _k, B = null;
  const G = qt({}, [...Ak, ...Zb, ...Qb, ...Jb, ...kk]);
  let H = null;
  const K = qt({}, [...Rk, ...ex, ...Mk, ...Pp]);
  let j = Object.seal(lT(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), Z = null, te = null;
  const ne = Object.seal(lT(null, {
    tagCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    }
  }));
  let V = !0, q = !0, X = !1, W = !0, ue = !1, J = !0, Ce = !1, Ee = !1, Te = !1, me = !1, we = !1, Ae = !1, Ne = !0, Ie = !1;
  const Me = "user-content-";
  let _e = !0, Be = !1, st = {}, ct = null;
  const dt = qt({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let ft = null;
  const rt = qt({}, ["audio", "video", "img", "source", "image", "track"]);
  let je = null;
  const ae = qt({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), z = "http://www.w3.org/1998/Math/MathML", Q = "http://www.w3.org/2000/svg", se = "http://www.w3.org/1999/xhtml";
  let oe = se, he = !1, Le = null;
  const ge = qt({}, [z, Q, se], Xb);
  let Se = qt({}, ["mi", "mo", "mn", "ms", "mtext"]), xe = qt({}, ["annotation-xml"]);
  const $e = qt({}, ["title", "style", "font", "a", "script"]);
  let Ze = null;
  const We = ["application/xhtml+xml", "text/html"], He = "text/html";
  let Pe = null, De = null;
  const mt = r.createElement("form"), Ke = function(le) {
    return le instanceof RegExp || le instanceof Function;
  }, et = function() {
    let le = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!(De && De === le)) {
      if ((!le || typeof le != "object") && (le = {}), le = Os(le), Ze = // eslint-disable-next-line unicorn/prefer-includes
      We.indexOf(le.PARSER_MEDIA_TYPE) === -1 ? He : le.PARSER_MEDIA_TYPE, Pe = Ze === "application/xhtml+xml" ? Xb : tv, B = ki(le, "ALLOWED_TAGS") ? qt({}, le.ALLOWED_TAGS, Pe) : G, H = ki(le, "ALLOWED_ATTR") ? qt({}, le.ALLOWED_ATTR, Pe) : K, Le = ki(le, "ALLOWED_NAMESPACES") ? qt({}, le.ALLOWED_NAMESPACES, Xb) : ge, je = ki(le, "ADD_URI_SAFE_ATTR") ? qt(Os(ae), le.ADD_URI_SAFE_ATTR, Pe) : ae, ft = ki(le, "ADD_DATA_URI_TAGS") ? qt(Os(rt), le.ADD_DATA_URI_TAGS, Pe) : rt, ct = ki(le, "FORBID_CONTENTS") ? qt({}, le.FORBID_CONTENTS, Pe) : dt, Z = ki(le, "FORBID_TAGS") ? qt({}, le.FORBID_TAGS, Pe) : Os({}), te = ki(le, "FORBID_ATTR") ? qt({}, le.FORBID_ATTR, Pe) : Os({}), st = ki(le, "USE_PROFILES") ? le.USE_PROFILES : !1, V = le.ALLOW_ARIA_ATTR !== !1, q = le.ALLOW_DATA_ATTR !== !1, X = le.ALLOW_UNKNOWN_PROTOCOLS || !1, W = le.ALLOW_SELF_CLOSE_IN_ATTR !== !1, ue = le.SAFE_FOR_TEMPLATES || !1, J = le.SAFE_FOR_XML !== !1, Ce = le.WHOLE_DOCUMENT || !1, me = le.RETURN_DOM || !1, we = le.RETURN_DOM_FRAGMENT || !1, Ae = le.RETURN_TRUSTED_TYPE || !1, Te = le.FORCE_BODY || !1, Ne = le.SANITIZE_DOM !== !1, Ie = le.SANITIZE_NAMED_PROPS || !1, _e = le.KEEP_CONTENT !== !1, Be = le.IN_PLACE || !1, F = le.ALLOWED_URI_REGEXP || dP, oe = le.NAMESPACE || se, Se = le.MATHML_TEXT_INTEGRATION_POINTS || Se, xe = le.HTML_INTEGRATION_POINTS || xe, j = le.CUSTOM_ELEMENT_HANDLING || {}, le.CUSTOM_ELEMENT_HANDLING && Ke(le.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (j.tagNameCheck = le.CUSTOM_ELEMENT_HANDLING.tagNameCheck), le.CUSTOM_ELEMENT_HANDLING && Ke(le.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (j.attributeNameCheck = le.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), le.CUSTOM_ELEMENT_HANDLING && typeof le.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (j.allowCustomizedBuiltInElements = le.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), ue && (q = !1), we && (me = !0), st && (B = qt({}, kk), H = [], st.html === !0 && (qt(B, Ak), qt(H, Rk)), st.svg === !0 && (qt(B, Zb), qt(H, ex), qt(H, Pp)), st.svgFilters === !0 && (qt(B, Qb), qt(H, ex), qt(H, Pp)), st.mathMl === !0 && (qt(B, Jb), qt(H, Mk), qt(H, Pp))), le.ADD_TAGS && (typeof le.ADD_TAGS == "function" ? ne.tagCheck = le.ADD_TAGS : (B === G && (B = Os(B)), qt(B, le.ADD_TAGS, Pe))), le.ADD_ATTR && (typeof le.ADD_ATTR == "function" ? ne.attributeCheck = le.ADD_ATTR : (H === K && (H = Os(H)), qt(H, le.ADD_ATTR, Pe))), le.ADD_URI_SAFE_ATTR && qt(je, le.ADD_URI_SAFE_ATTR, Pe), le.FORBID_CONTENTS && (ct === dt && (ct = Os(ct)), qt(ct, le.FORBID_CONTENTS, Pe)), _e && (B["#text"] = !0), Ce && qt(B, ["html", "head", "body"]), B.table && (qt(B, ["tbody"]), delete Z.tbody), le.TRUSTED_TYPES_POLICY) {
        if (typeof le.TRUSTED_TYPES_POLICY.createHTML != "function")
          throw Yf('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        if (typeof le.TRUSTED_TYPES_POLICY.createScriptURL != "function")
          throw Yf('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        x = le.TRUSTED_TYPES_POLICY, E = x.createHTML("");
      } else
        x === void 0 && (x = Ste(d, a)), x !== null && typeof E == "string" && (E = x.createHTML(""));
      fa && fa(le), De = le;
    }
  }, Pt = qt({}, [...Zb, ...Qb, ...dte]), vt = qt({}, [...Jb, ...pte]), nt = function(le) {
    let Oe = y(le);
    (!Oe || !Oe.tagName) && (Oe = {
      namespaceURI: oe,
      tagName: "template"
    });
    const at = tv(le.tagName), Ht = tv(Oe.tagName);
    return Le[le.namespaceURI] ? le.namespaceURI === Q ? Oe.namespaceURI === se ? at === "svg" : Oe.namespaceURI === z ? at === "svg" && (Ht === "annotation-xml" || Se[Ht]) : !!Pt[at] : le.namespaceURI === z ? Oe.namespaceURI === se ? at === "math" : Oe.namespaceURI === Q ? at === "math" && xe[Ht] : !!vt[at] : le.namespaceURI === se ? Oe.namespaceURI === Q && !xe[Ht] || Oe.namespaceURI === z && !Se[Ht] ? !1 : !vt[at] && ($e[at] || !Pt[at]) : !!(Ze === "application/xhtml+xml" && Le[le.namespaceURI]) : !1;
  }, Dt = function(le) {
    Wf(e.removed, {
      element: le
    });
    try {
      y(le).removeChild(le);
    } catch {
      v(le);
    }
  }, Gt = function(le, Oe) {
    try {
      Wf(e.removed, {
        attribute: Oe.getAttributeNode(le),
        from: Oe
      });
    } catch {
      Wf(e.removed, {
        attribute: null,
        from: Oe
      });
    }
    if (Oe.removeAttribute(le), le === "is")
      if (me || we)
        try {
          Dt(Oe);
        } catch {
        }
      else
        try {
          Oe.setAttribute(le, "");
        } catch {
        }
  }, yt = function(le) {
    let Oe = null, at = null;
    if (Te)
      le = "<remove></remove>" + le;
    else {
      const yr = Kb(le, /^[\r\n\t ]+/);
      at = yr && yr[0];
    }
    Ze === "application/xhtml+xml" && oe === se && (le = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + le + "</body></html>");
    const Ht = x ? x.createHTML(le) : le;
    if (oe === se)
      try {
        Oe = new h().parseFromString(Ht, Ze);
      } catch {
      }
    if (!Oe || !Oe.documentElement) {
      Oe = S.createDocument(oe, "template", null);
      try {
        Oe.documentElement.innerHTML = he ? E : Ht;
      } catch {
      }
    }
    const Vt = Oe.body || Oe.documentElement;
    return le && at && Vt.insertBefore(r.createTextNode(at), Vt.childNodes[0] || null), oe === se ? k.call(Oe, Ce ? "html" : "body")[0] : Ce ? Oe.documentElement : Vt;
  }, ee = function(le) {
    return w.call(
      le.ownerDocument || le,
      le,
      // eslint-disable-next-line no-bitwise
      u.SHOW_ELEMENT | u.SHOW_COMMENT | u.SHOW_TEXT | u.SHOW_PROCESSING_INSTRUCTION | u.SHOW_CDATA_SECTION,
      null
    );
  }, Re = function(le) {
    return le instanceof f && (typeof le.nodeName != "string" || typeof le.textContent != "string" || typeof le.removeChild != "function" || !(le.attributes instanceof c) || typeof le.removeAttribute != "function" || typeof le.setAttribute != "function" || typeof le.namespaceURI != "string" || typeof le.insertBefore != "function" || typeof le.hasChildNodes != "function");
  }, Ge = function(le) {
    return typeof o == "function" && le instanceof o;
  };
  function ot(ze, le, Oe) {
    Ip(ze, (at) => {
      at.call(e, le, Oe, De);
    });
  }
  const kt = function(le) {
    let Oe = null;
    if (ot(R.beforeSanitizeElements, le, null), Re(le))
      return Dt(le), !0;
    const at = Pe(le.nodeName);
    if (ot(R.uponSanitizeElement, le, {
      tagName: at,
      allowedTags: B
    }), J && le.hasChildNodes() && !Ge(le.firstElementChild) && ia(/<[/\w!]/g, le.innerHTML) && ia(/<[/\w!]/g, le.textContent) || le.nodeType === Kf.progressingInstruction || J && le.nodeType === Kf.comment && ia(/<[/\w]/g, le.data))
      return Dt(le), !0;
    if (!(ne.tagCheck instanceof Function && ne.tagCheck(at)) && (!B[at] || Z[at])) {
      if (!Z[at] && pt(at) && (j.tagNameCheck instanceof RegExp && ia(j.tagNameCheck, at) || j.tagNameCheck instanceof Function && j.tagNameCheck(at)))
        return !1;
      if (_e && !ct[at]) {
        const Ht = y(le) || le.parentNode, Vt = b(le) || le.childNodes;
        if (Vt && Ht) {
          const yr = Vt.length;
          for (let jr = yr - 1; jr >= 0; --jr) {
            const qn = g(Vt[jr], !0);
            qn.__removalCount = (le.__removalCount || 0) + 1, Ht.insertBefore(qn, m(le));
          }
        }
      }
      return Dt(le), !0;
    }
    return le instanceof l && !nt(le) || (at === "noscript" || at === "noembed" || at === "noframes") && ia(/<\/no(script|embed|frames)/i, le.innerHTML) ? (Dt(le), !0) : (ue && le.nodeType === Kf.text && (Oe = le.textContent, Ip([_, O, T], (Ht) => {
      Oe = jf(Oe, Ht, " ");
    }), le.textContent !== Oe && (Wf(e.removed, {
      element: le.cloneNode()
    }), le.textContent = Oe)), ot(R.afterSanitizeElements, le, null), !1);
  }, wt = function(le, Oe, at) {
    if (Ne && (Oe === "id" || Oe === "name") && (at in r || at in mt))
      return !1;
    if (!(q && !te[Oe] && ia(L, Oe))) {
      if (!(V && ia(M, Oe))) {
        if (!(ne.attributeCheck instanceof Function && ne.attributeCheck(Oe, le))) {
          if (!H[Oe] || te[Oe]) {
            if (
              // First condition does a very basic check if a) it's basically a valid custom element tagname AND
              // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
              // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
              !(pt(le) && (j.tagNameCheck instanceof RegExp && ia(j.tagNameCheck, le) || j.tagNameCheck instanceof Function && j.tagNameCheck(le)) && (j.attributeNameCheck instanceof RegExp && ia(j.attributeNameCheck, Oe) || j.attributeNameCheck instanceof Function && j.attributeNameCheck(Oe, le)) || // Alternative, second condition checks if it's an `is`-attribute, AND
              // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
              Oe === "is" && j.allowCustomizedBuiltInElements && (j.tagNameCheck instanceof RegExp && ia(j.tagNameCheck, at) || j.tagNameCheck instanceof Function && j.tagNameCheck(at)))
            ) return !1;
          } else if (!je[Oe]) {
            if (!ia(F, jf(at, I, ""))) {
              if (!((Oe === "src" || Oe === "xlink:href" || Oe === "href") && le !== "script" && ute(at, "data:") === 0 && ft[le])) {
                if (!(X && !ia(A, jf(at, I, "")))) {
                  if (at)
                    return !1;
                }
              }
            }
          }
        }
      }
    }
    return !0;
  }, pt = function(le) {
    return le !== "annotation-xml" && Kb(le, D);
  }, gt = function(le) {
    ot(R.beforeSanitizeAttributes, le, null);
    const {
      attributes: Oe
    } = le;
    if (!Oe || Re(le))
      return;
    const at = {
      attrName: "",
      attrValue: "",
      keepAttr: !0,
      allowedAttributes: H,
      forceKeepAttr: void 0
    };
    let Ht = Oe.length;
    for (; Ht--; ) {
      const Vt = Oe[Ht], {
        name: yr,
        namespaceURI: jr,
        value: qn
      } = Vt, aa = Pe(yr), Ci = qn;
      let Lr = yr === "value" ? Ci : cte(Ci);
      if (at.attrName = aa, at.attrValue = Lr, at.keepAttr = !0, at.forceKeepAttr = void 0, ot(R.uponSanitizeAttribute, le, at), Lr = at.attrValue, Ie && (aa === "id" || aa === "name") && (Gt(yr, le), Lr = Me + Lr), J && ia(/((--!?|])>)|<\/(style|title|textarea)/i, Lr)) {
        Gt(yr, le);
        continue;
      }
      if (aa === "attributename" && Kb(Lr, "href")) {
        Gt(yr, le);
        continue;
      }
      if (at.forceKeepAttr)
        continue;
      if (!at.keepAttr) {
        Gt(yr, le);
        continue;
      }
      if (!W && ia(/\/>/i, Lr)) {
        Gt(yr, le);
        continue;
      }
      ue && Ip([_, O, T], (It) => {
        Lr = jf(Lr, It, " ");
      });
      const zr = Pe(le.nodeName);
      if (!wt(zr, aa, Lr)) {
        Gt(yr, le);
        continue;
      }
      if (x && typeof d == "object" && typeof d.getAttributeType == "function" && !jr)
        switch (d.getAttributeType(zr, aa)) {
          case "TrustedHTML": {
            Lr = x.createHTML(Lr);
            break;
          }
          case "TrustedScriptURL": {
            Lr = x.createScriptURL(Lr);
            break;
          }
        }
      if (Lr !== Ci)
        try {
          jr ? le.setAttributeNS(jr, yr, Lr) : le.setAttribute(yr, Lr), Re(le) ? Dt(le) : Ck(e.removed);
        } catch {
          Gt(yr, le);
        }
    }
    ot(R.afterSanitizeAttributes, le, null);
  }, or = function ze(le) {
    let Oe = null;
    const at = ee(le);
    for (ot(R.beforeSanitizeShadowDOM, le, null); Oe = at.nextNode(); )
      ot(R.uponSanitizeShadowNode, Oe, null), kt(Oe), gt(Oe), Oe.content instanceof i && ze(Oe.content);
    ot(R.afterSanitizeShadowDOM, le, null);
  };
  return e.sanitize = function(ze) {
    let le = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, Oe = null, at = null, Ht = null, Vt = null;
    if (he = !ze, he && (ze = "<!-->"), typeof ze != "string" && !Ge(ze))
      if (typeof ze.toString == "function") {
        if (ze = ze.toString(), typeof ze != "string")
          throw Yf("dirty is not a string, aborting");
      } else
        throw Yf("toString is not a function");
    if (!e.isSupported)
      return ze;
    if (Ee || et(le), e.removed = [], typeof ze == "string" && (Be = !1), Be) {
      if (ze.nodeName) {
        const qn = Pe(ze.nodeName);
        if (!B[qn] || Z[qn])
          throw Yf("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (ze instanceof o)
      Oe = yt("<!---->"), at = Oe.ownerDocument.importNode(ze, !0), at.nodeType === Kf.element && at.nodeName === "BODY" || at.nodeName === "HTML" ? Oe = at : Oe.appendChild(at);
    else {
      if (!me && !ue && !Ce && // eslint-disable-next-line unicorn/prefer-includes
      ze.indexOf("<") === -1)
        return x && Ae ? x.createHTML(ze) : ze;
      if (Oe = yt(ze), !Oe)
        return me ? null : Ae ? E : "";
    }
    Oe && Te && Dt(Oe.firstChild);
    const yr = ee(Be ? ze : Oe);
    for (; Ht = yr.nextNode(); )
      kt(Ht), gt(Ht), Ht.content instanceof i && or(Ht.content);
    if (Be)
      return ze;
    if (me) {
      if (we)
        for (Vt = C.call(Oe.ownerDocument); Oe.firstChild; )
          Vt.appendChild(Oe.firstChild);
      else
        Vt = Oe;
      return (H.shadowroot || H.shadowrootmode) && (Vt = N.call(n, Vt, !0)), Vt;
    }
    let jr = Ce ? Oe.outerHTML : Oe.innerHTML;
    return Ce && B["!doctype"] && Oe.ownerDocument && Oe.ownerDocument.doctype && Oe.ownerDocument.doctype.name && ia(pP, Oe.ownerDocument.doctype.name) && (jr = "<!DOCTYPE " + Oe.ownerDocument.doctype.name + `>
` + jr), ue && Ip([_, O, T], (qn) => {
      jr = jf(jr, qn, " ");
    }), x && Ae ? x.createHTML(jr) : jr;
  }, e.setConfig = function() {
    let ze = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    et(ze), Ee = !0;
  }, e.clearConfig = function() {
    De = null, Ee = !1;
  }, e.isValidAttribute = function(ze, le, Oe) {
    De || et({});
    const at = Pe(ze), Ht = Pe(le);
    return wt(at, Ht, Oe);
  }, e.addHook = function(ze, le) {
    typeof le == "function" && Wf(R[ze], le);
  }, e.removeHook = function(ze, le) {
    if (le !== void 0) {
      const Oe = ote(R[ze], le);
      return Oe === -1 ? void 0 : lte(R[ze], Oe, 1)[0];
    }
    return Ck(R[ze]);
  }, e.removeHooks = function(ze) {
    R[ze] = [];
  }, e.removeAllHooks = function() {
    R = Lk();
  }, e;
}
var QMe = gP();
function rv(t, e) {
  return t == null || e == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function Cte(t, e) {
  return t == null || e == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function o5(t) {
  let e, r, n;
  t.length !== 2 ? (e = rv, r = (o, l) => rv(t(o), l), n = (o, l) => t(o) - l) : (e = t === rv || t === Cte ? t : Ate, r = t, n = t);
  function a(o, l, u = 0, c = o.length) {
    if (u < c) {
      if (e(l, l) !== 0) return c;
      do {
        const f = u + c >>> 1;
        r(o[f], l) < 0 ? u = f + 1 : c = f;
      } while (u < c);
    }
    return u;
  }
  function i(o, l, u = 0, c = o.length) {
    if (u < c) {
      if (e(l, l) !== 0) return c;
      do {
        const f = u + c >>> 1;
        r(o[f], l) <= 0 ? u = f + 1 : c = f;
      } while (u < c);
    }
    return u;
  }
  function s(o, l, u = 0, c = o.length) {
    const f = a(o, l, u, c - 1);
    return f > u && n(o[f - 1], l) > -n(o[f], l) ? f - 1 : f;
  }
  return { left: a, center: s, right: i };
}
function Ate() {
  return 0;
}
function kte(t) {
  return t === null ? NaN : +t;
}
const Rte = o5(rv), Mte = Rte.right;
o5(kte).center;
class Nk extends Map {
  constructor(e, r = Nte) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: r } }), e != null) for (const [n, a] of e) this.set(n, a);
  }
  get(e) {
    return super.get(Ok(this, e));
  }
  has(e) {
    return super.has(Ok(this, e));
  }
  set(e, r) {
    return super.set(_te(this, e), r);
  }
  delete(e) {
    return super.delete(Lte(this, e));
  }
}
function Ok({ _intern: t, _key: e }, r) {
  const n = e(r);
  return t.has(n) ? t.get(n) : r;
}
function _te({ _intern: t, _key: e }, r) {
  const n = e(r);
  return t.has(n) ? t.get(n) : (t.set(n, r), r);
}
function Lte({ _intern: t, _key: e }, r) {
  const n = e(r);
  return t.has(n) && (r = t.get(n), t.delete(n)), r;
}
function Nte(t) {
  return t !== null && typeof t == "object" ? t.valueOf() : t;
}
const Ote = Math.sqrt(50), Ite = Math.sqrt(10), Pte = Math.sqrt(2);
function Vv(t, e, r) {
  const n = (e - t) / Math.max(0, r), a = Math.floor(Math.log10(n)), i = n / Math.pow(10, a), s = i >= Ote ? 10 : i >= Ite ? 5 : i >= Pte ? 2 : 1;
  let o, l, u;
  return a < 0 ? (u = Math.pow(10, -a) / s, o = Math.round(t * u), l = Math.round(e * u), o / u < t && ++o, l / u > e && --l, u = -u) : (u = Math.pow(10, a) * s, o = Math.round(t / u), l = Math.round(e / u), o * u < t && ++o, l * u > e && --l), l < o && 0.5 <= r && r < 2 ? Vv(t, e, r * 2) : [o, l, u];
}
function Dte(t, e, r) {
  if (e = +e, t = +t, r = +r, !(r > 0)) return [];
  if (t === e) return [t];
  const n = e < t, [a, i, s] = n ? Vv(e, t, r) : Vv(t, e, r);
  if (!(i >= a)) return [];
  const o = i - a + 1, l = new Array(o);
  if (n)
    if (s < 0) for (let u = 0; u < o; ++u) l[u] = (i - u) / -s;
    else for (let u = 0; u < o; ++u) l[u] = (i - u) * s;
  else if (s < 0) for (let u = 0; u < o; ++u) l[u] = (a + u) / -s;
  else for (let u = 0; u < o; ++u) l[u] = (a + u) * s;
  return l;
}
function fT(t, e, r) {
  return e = +e, t = +t, r = +r, Vv(t, e, r)[2];
}
function hT(t, e, r) {
  e = +e, t = +t, r = +r;
  const n = e < t, a = n ? fT(e, t, r) : fT(t, e, r);
  return (n ? -1 : 1) * (a < 0 ? 1 / -a : a);
}
function JMe(t, e) {
  let r;
  if (e === void 0)
    for (const n of t)
      n != null && (r < n || r === void 0 && n >= n) && (r = n);
  else {
    let n = -1;
    for (let a of t)
      (a = e(a, ++n, t)) != null && (r < a || r === void 0 && a >= a) && (r = a);
  }
  return r;
}
function e_e(t, e) {
  let r;
  if (e === void 0)
    for (const n of t)
      n != null && (r > n || r === void 0 && n >= n) && (r = n);
  else {
    let n = -1;
    for (let a of t)
      (a = e(a, ++n, t)) != null && (r > a || r === void 0 && a >= a) && (r = a);
  }
  return r;
}
function $te(t, e, r) {
  t = +t, e = +e, r = (a = arguments.length) < 2 ? (e = t, t = 0, 1) : a < 3 ? 1 : +r;
  for (var n = -1, a = Math.max(0, Math.ceil((e - t) / r)) | 0, i = new Array(a); ++n < a; )
    i[n] = t + n * r;
  return i;
}
function Fte(t) {
  return t;
}
var nv = 1, tx = 2, dT = 3, Dp = 4, Ik = 1e-6;
function Bte(t) {
  return "translate(" + t + ",0)";
}
function zte(t) {
  return "translate(0," + t + ")";
}
function Gte(t) {
  return (e) => +t(e);
}
function Ute(t, e) {
  return e = Math.max(0, t.bandwidth() - e * 2) / 2, t.round() && (e = Math.round(e)), (r) => +t(r) + e;
}
function Hte() {
  return !this.__axis;
}
function vP(t, e) {
  var r = [], n = null, a = null, i = 6, s = 6, o = 3, l = typeof window < "u" && window.devicePixelRatio > 1 ? 0 : 0.5, u = t === nv || t === Dp ? -1 : 1, c = t === Dp || t === tx ? "x" : "y", f = t === nv || t === dT ? Bte : zte;
  function h(d) {
    var p = n ?? (e.ticks ? e.ticks.apply(e, r) : e.domain()), g = a ?? (e.tickFormat ? e.tickFormat.apply(e, r) : Fte), v = Math.max(i, 0) + o, m = e.range(), b = +m[0] + l, y = +m[m.length - 1] + l, x = (e.bandwidth ? Ute : Gte)(e.copy(), l), E = d.selection ? d.selection() : d, S = E.selectAll(".domain").data([null]), w = E.selectAll(".tick").data(p, e).order(), C = w.exit(), k = w.enter().append("g").attr("class", "tick"), N = w.select("line"), R = w.select("text");
    S = S.merge(S.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor")), w = w.merge(k), N = N.merge(k.append("line").attr("stroke", "currentColor").attr(c + "2", u * i)), R = R.merge(k.append("text").attr("fill", "currentColor").attr(c, u * v).attr("dy", t === nv ? "0em" : t === dT ? "0.71em" : "0.32em")), d !== E && (S = S.transition(d), w = w.transition(d), N = N.transition(d), R = R.transition(d), C = C.transition(d).attr("opacity", Ik).attr("transform", function(_) {
      return isFinite(_ = x(_)) ? f(_ + l) : this.getAttribute("transform");
    }), k.attr("opacity", Ik).attr("transform", function(_) {
      var O = this.parentNode.__axis;
      return f((O && isFinite(O = O(_)) ? O : x(_)) + l);
    })), C.remove(), S.attr("d", t === Dp || t === tx ? s ? "M" + u * s + "," + b + "H" + l + "V" + y + "H" + u * s : "M" + l + "," + b + "V" + y : s ? "M" + b + "," + u * s + "V" + l + "H" + y + "V" + u * s : "M" + b + "," + l + "H" + y), w.attr("opacity", 1).attr("transform", function(_) {
      return f(x(_) + l);
    }), N.attr(c + "2", u * i), R.attr(c, u * v).text(g), E.filter(Hte).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", t === tx ? "start" : t === Dp ? "end" : "middle"), E.each(function() {
      this.__axis = x;
    });
  }
  return h.scale = function(d) {
    return arguments.length ? (e = d, h) : e;
  }, h.ticks = function() {
    return r = Array.from(arguments), h;
  }, h.tickArguments = function(d) {
    return arguments.length ? (r = d == null ? [] : Array.from(d), h) : r.slice();
  }, h.tickValues = function(d) {
    return arguments.length ? (n = d == null ? null : Array.from(d), h) : n && n.slice();
  }, h.tickFormat = function(d) {
    return arguments.length ? (a = d, h) : a;
  }, h.tickSize = function(d) {
    return arguments.length ? (i = s = +d, h) : i;
  }, h.tickSizeInner = function(d) {
    return arguments.length ? (i = +d, h) : i;
  }, h.tickSizeOuter = function(d) {
    return arguments.length ? (s = +d, h) : s;
  }, h.tickPadding = function(d) {
    return arguments.length ? (o = +d, h) : o;
  }, h.offset = function(d) {
    return arguments.length ? (l = +d, h) : l;
  }, h;
}
function t_e(t) {
  return vP(nv, t);
}
function r_e(t) {
  return vP(dT, t);
}
var Vte = { value: () => {
} };
function mP() {
  for (var t = 0, e = arguments.length, r = {}, n; t < e; ++t) {
    if (!(n = arguments[t] + "") || n in r || /[\s.]/.test(n)) throw new Error("illegal type: " + n);
    r[n] = [];
  }
  return new av(r);
}
function av(t) {
  this._ = t;
}
function qte(t, e) {
  return t.trim().split(/^|\s+/).map(function(r) {
    var n = "", a = r.indexOf(".");
    if (a >= 0 && (n = r.slice(a + 1), r = r.slice(0, a)), r && !e.hasOwnProperty(r)) throw new Error("unknown type: " + r);
    return { type: r, name: n };
  });
}
av.prototype = mP.prototype = {
  constructor: av,
  on: function(t, e) {
    var r = this._, n = qte(t + "", r), a, i = -1, s = n.length;
    if (arguments.length < 2) {
      for (; ++i < s; ) if ((a = (t = n[i]).type) && (a = Wte(r[a], t.name))) return a;
      return;
    }
    if (e != null && typeof e != "function") throw new Error("invalid callback: " + e);
    for (; ++i < s; )
      if (a = (t = n[i]).type) r[a] = Pk(r[a], t.name, e);
      else if (e == null) for (a in r) r[a] = Pk(r[a], t.name, null);
    return this;
  },
  copy: function() {
    var t = {}, e = this._;
    for (var r in e) t[r] = e[r].slice();
    return new av(t);
  },
  call: function(t, e) {
    if ((a = arguments.length - 2) > 0) for (var r = new Array(a), n = 0, a, i; n < a; ++n) r[n] = arguments[n + 2];
    if (!this._.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    for (i = this._[t], n = 0, a = i.length; n < a; ++n) i[n].value.apply(e, r);
  },
  apply: function(t, e, r) {
    if (!this._.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    for (var n = this._[t], a = 0, i = n.length; a < i; ++a) n[a].value.apply(e, r);
  }
};
function Wte(t, e) {
  for (var r = 0, n = t.length, a; r < n; ++r)
    if ((a = t[r]).name === e)
      return a.value;
}
function Pk(t, e, r) {
  for (var n = 0, a = t.length; n < a; ++n)
    if (t[n].name === e) {
      t[n] = Vte, t = t.slice(0, n).concat(t.slice(n + 1));
      break;
    }
  return r != null && t.push({ name: e, value: r }), t;
}
var pT = "http://www.w3.org/1999/xhtml";
const Dk = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: pT,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function i1(t) {
  var e = t += "", r = e.indexOf(":");
  return r >= 0 && (e = t.slice(0, r)) !== "xmlns" && (t = t.slice(r + 1)), Dk.hasOwnProperty(e) ? { space: Dk[e], local: t } : t;
}
function jte(t) {
  return function() {
    var e = this.ownerDocument, r = this.namespaceURI;
    return r === pT && e.documentElement.namespaceURI === pT ? e.createElement(t) : e.createElementNS(r, t);
  };
}
function Yte(t) {
  return function() {
    return this.ownerDocument.createElementNS(t.space, t.local);
  };
}
function yP(t) {
  var e = i1(t);
  return (e.local ? Yte : jte)(e);
}
function Xte() {
}
function l5(t) {
  return t == null ? Xte : function() {
    return this.querySelector(t);
  };
}
function Kte(t) {
  typeof t != "function" && (t = l5(t));
  for (var e = this._groups, r = e.length, n = new Array(r), a = 0; a < r; ++a)
    for (var i = e[a], s = i.length, o = n[a] = new Array(s), l, u, c = 0; c < s; ++c)
      (l = i[c]) && (u = t.call(l, l.__data__, c, i)) && ("__data__" in l && (u.__data__ = l.__data__), o[c] = u);
  return new ni(n, this._parents);
}
function Zte(t) {
  return t == null ? [] : Array.isArray(t) ? t : Array.from(t);
}
function Qte() {
  return [];
}
function bP(t) {
  return t == null ? Qte : function() {
    return this.querySelectorAll(t);
  };
}
function Jte(t) {
  return function() {
    return Zte(t.apply(this, arguments));
  };
}
function ere(t) {
  typeof t == "function" ? t = Jte(t) : t = bP(t);
  for (var e = this._groups, r = e.length, n = [], a = [], i = 0; i < r; ++i)
    for (var s = e[i], o = s.length, l, u = 0; u < o; ++u)
      (l = s[u]) && (n.push(t.call(l, l.__data__, u, s)), a.push(l));
  return new ni(n, a);
}
function xP(t) {
  return function() {
    return this.matches(t);
  };
}
function wP(t) {
  return function(e) {
    return e.matches(t);
  };
}
var tre = Array.prototype.find;
function rre(t) {
  return function() {
    return tre.call(this.children, t);
  };
}
function nre() {
  return this.firstElementChild;
}
function are(t) {
  return this.select(t == null ? nre : rre(typeof t == "function" ? t : wP(t)));
}
var ire = Array.prototype.filter;
function sre() {
  return Array.from(this.children);
}
function ore(t) {
  return function() {
    return ire.call(this.children, t);
  };
}
function lre(t) {
  return this.selectAll(t == null ? sre : ore(typeof t == "function" ? t : wP(t)));
}
function ure(t) {
  typeof t != "function" && (t = xP(t));
  for (var e = this._groups, r = e.length, n = new Array(r), a = 0; a < r; ++a)
    for (var i = e[a], s = i.length, o = n[a] = [], l, u = 0; u < s; ++u)
      (l = i[u]) && t.call(l, l.__data__, u, i) && o.push(l);
  return new ni(n, this._parents);
}
function EP(t) {
  return new Array(t.length);
}
function cre() {
  return new ni(this._enter || this._groups.map(EP), this._parents);
}
function qv(t, e) {
  this.ownerDocument = t.ownerDocument, this.namespaceURI = t.namespaceURI, this._next = null, this._parent = t, this.__data__ = e;
}
qv.prototype = {
  constructor: qv,
  appendChild: function(t) {
    return this._parent.insertBefore(t, this._next);
  },
  insertBefore: function(t, e) {
    return this._parent.insertBefore(t, e);
  },
  querySelector: function(t) {
    return this._parent.querySelector(t);
  },
  querySelectorAll: function(t) {
    return this._parent.querySelectorAll(t);
  }
};
function fre(t) {
  return function() {
    return t;
  };
}
function hre(t, e, r, n, a, i) {
  for (var s = 0, o, l = e.length, u = i.length; s < u; ++s)
    (o = e[s]) ? (o.__data__ = i[s], n[s] = o) : r[s] = new qv(t, i[s]);
  for (; s < l; ++s)
    (o = e[s]) && (a[s] = o);
}
function dre(t, e, r, n, a, i, s) {
  var o, l, u = /* @__PURE__ */ new Map(), c = e.length, f = i.length, h = new Array(c), d;
  for (o = 0; o < c; ++o)
    (l = e[o]) && (h[o] = d = s.call(l, l.__data__, o, e) + "", u.has(d) ? a[o] = l : u.set(d, l));
  for (o = 0; o < f; ++o)
    d = s.call(t, i[o], o, i) + "", (l = u.get(d)) ? (n[o] = l, l.__data__ = i[o], u.delete(d)) : r[o] = new qv(t, i[o]);
  for (o = 0; o < c; ++o)
    (l = e[o]) && u.get(h[o]) === l && (a[o] = l);
}
function pre(t) {
  return t.__data__;
}
function gre(t, e) {
  if (!arguments.length) return Array.from(this, pre);
  var r = e ? dre : hre, n = this._parents, a = this._groups;
  typeof t != "function" && (t = fre(t));
  for (var i = a.length, s = new Array(i), o = new Array(i), l = new Array(i), u = 0; u < i; ++u) {
    var c = n[u], f = a[u], h = f.length, d = vre(t.call(c, c && c.__data__, u, n)), p = d.length, g = o[u] = new Array(p), v = s[u] = new Array(p), m = l[u] = new Array(h);
    r(c, f, g, v, m, d, e);
    for (var b = 0, y = 0, x, E; b < p; ++b)
      if (x = g[b]) {
        for (b >= y && (y = b + 1); !(E = v[y]) && ++y < p; ) ;
        x._next = E || null;
      }
  }
  return s = new ni(s, n), s._enter = o, s._exit = l, s;
}
function vre(t) {
  return typeof t == "object" && "length" in t ? t : Array.from(t);
}
function mre() {
  return new ni(this._exit || this._groups.map(EP), this._parents);
}
function yre(t, e, r) {
  var n = this.enter(), a = this, i = this.exit();
  return typeof t == "function" ? (n = t(n), n && (n = n.selection())) : n = n.append(t + ""), e != null && (a = e(a), a && (a = a.selection())), r == null ? i.remove() : r(i), n && a ? n.merge(a).order() : a;
}
function bre(t) {
  for (var e = t.selection ? t.selection() : t, r = this._groups, n = e._groups, a = r.length, i = n.length, s = Math.min(a, i), o = new Array(a), l = 0; l < s; ++l)
    for (var u = r[l], c = n[l], f = u.length, h = o[l] = new Array(f), d, p = 0; p < f; ++p)
      (d = u[p] || c[p]) && (h[p] = d);
  for (; l < a; ++l)
    o[l] = r[l];
  return new ni(o, this._parents);
}
function xre() {
  for (var t = this._groups, e = -1, r = t.length; ++e < r; )
    for (var n = t[e], a = n.length - 1, i = n[a], s; --a >= 0; )
      (s = n[a]) && (i && s.compareDocumentPosition(i) ^ 4 && i.parentNode.insertBefore(s, i), i = s);
  return this;
}
function wre(t) {
  t || (t = Ere);
  function e(f, h) {
    return f && h ? t(f.__data__, h.__data__) : !f - !h;
  }
  for (var r = this._groups, n = r.length, a = new Array(n), i = 0; i < n; ++i) {
    for (var s = r[i], o = s.length, l = a[i] = new Array(o), u, c = 0; c < o; ++c)
      (u = s[c]) && (l[c] = u);
    l.sort(e);
  }
  return new ni(a, this._parents).order();
}
function Ere(t, e) {
  return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function Tre() {
  var t = arguments[0];
  return arguments[0] = this, t.apply(null, arguments), this;
}
function Sre() {
  return Array.from(this);
}
function Cre() {
  for (var t = this._groups, e = 0, r = t.length; e < r; ++e)
    for (var n = t[e], a = 0, i = n.length; a < i; ++a) {
      var s = n[a];
      if (s) return s;
    }
  return null;
}
function Are() {
  let t = 0;
  for (const e of this) ++t;
  return t;
}
function kre() {
  return !this.node();
}
function Rre(t) {
  for (var e = this._groups, r = 0, n = e.length; r < n; ++r)
    for (var a = e[r], i = 0, s = a.length, o; i < s; ++i)
      (o = a[i]) && t.call(o, o.__data__, i, a);
  return this;
}
function Mre(t) {
  return function() {
    this.removeAttribute(t);
  };
}
function _re(t) {
  return function() {
    this.removeAttributeNS(t.space, t.local);
  };
}
function Lre(t, e) {
  return function() {
    this.setAttribute(t, e);
  };
}
function Nre(t, e) {
  return function() {
    this.setAttributeNS(t.space, t.local, e);
  };
}
function Ore(t, e) {
  return function() {
    var r = e.apply(this, arguments);
    r == null ? this.removeAttribute(t) : this.setAttribute(t, r);
  };
}
function Ire(t, e) {
  return function() {
    var r = e.apply(this, arguments);
    r == null ? this.removeAttributeNS(t.space, t.local) : this.setAttributeNS(t.space, t.local, r);
  };
}
function Pre(t, e) {
  var r = i1(t);
  if (arguments.length < 2) {
    var n = this.node();
    return r.local ? n.getAttributeNS(r.space, r.local) : n.getAttribute(r);
  }
  return this.each((e == null ? r.local ? _re : Mre : typeof e == "function" ? r.local ? Ire : Ore : r.local ? Nre : Lre)(r, e));
}
function TP(t) {
  return t.ownerDocument && t.ownerDocument.defaultView || t.document && t || t.defaultView;
}
function Dre(t) {
  return function() {
    this.style.removeProperty(t);
  };
}
function $re(t, e, r) {
  return function() {
    this.style.setProperty(t, e, r);
  };
}
function Fre(t, e, r) {
  return function() {
    var n = e.apply(this, arguments);
    n == null ? this.style.removeProperty(t) : this.style.setProperty(t, n, r);
  };
}
function Bre(t, e, r) {
  return arguments.length > 1 ? this.each((e == null ? Dre : typeof e == "function" ? Fre : $re)(t, e, r ?? "")) : Xc(this.node(), t);
}
function Xc(t, e) {
  return t.style.getPropertyValue(e) || TP(t).getComputedStyle(t, null).getPropertyValue(e);
}
function zre(t) {
  return function() {
    delete this[t];
  };
}
function Gre(t, e) {
  return function() {
    this[t] = e;
  };
}
function Ure(t, e) {
  return function() {
    var r = e.apply(this, arguments);
    r == null ? delete this[t] : this[t] = r;
  };
}
function Hre(t, e) {
  return arguments.length > 1 ? this.each((e == null ? zre : typeof e == "function" ? Ure : Gre)(t, e)) : this.node()[t];
}
function SP(t) {
  return t.trim().split(/^|\s+/);
}
function u5(t) {
  return t.classList || new CP(t);
}
function CP(t) {
  this._node = t, this._names = SP(t.getAttribute("class") || "");
}
CP.prototype = {
  add: function(t) {
    var e = this._names.indexOf(t);
    e < 0 && (this._names.push(t), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(t) {
    var e = this._names.indexOf(t);
    e >= 0 && (this._names.splice(e, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(t) {
    return this._names.indexOf(t) >= 0;
  }
};
function AP(t, e) {
  for (var r = u5(t), n = -1, a = e.length; ++n < a; ) r.add(e[n]);
}
function kP(t, e) {
  for (var r = u5(t), n = -1, a = e.length; ++n < a; ) r.remove(e[n]);
}
function Vre(t) {
  return function() {
    AP(this, t);
  };
}
function qre(t) {
  return function() {
    kP(this, t);
  };
}
function Wre(t, e) {
  return function() {
    (e.apply(this, arguments) ? AP : kP)(this, t);
  };
}
function jre(t, e) {
  var r = SP(t + "");
  if (arguments.length < 2) {
    for (var n = u5(this.node()), a = -1, i = r.length; ++a < i; ) if (!n.contains(r[a])) return !1;
    return !0;
  }
  return this.each((typeof e == "function" ? Wre : e ? Vre : qre)(r, e));
}
function Yre() {
  this.textContent = "";
}
function Xre(t) {
  return function() {
    this.textContent = t;
  };
}
function Kre(t) {
  return function() {
    var e = t.apply(this, arguments);
    this.textContent = e ?? "";
  };
}
function Zre(t) {
  return arguments.length ? this.each(t == null ? Yre : (typeof t == "function" ? Kre : Xre)(t)) : this.node().textContent;
}
function Qre() {
  this.innerHTML = "";
}
function Jre(t) {
  return function() {
    this.innerHTML = t;
  };
}
function ene(t) {
  return function() {
    var e = t.apply(this, arguments);
    this.innerHTML = e ?? "";
  };
}
function tne(t) {
  return arguments.length ? this.each(t == null ? Qre : (typeof t == "function" ? ene : Jre)(t)) : this.node().innerHTML;
}
function rne() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function nne() {
  return this.each(rne);
}
function ane() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function ine() {
  return this.each(ane);
}
function sne(t) {
  var e = typeof t == "function" ? t : yP(t);
  return this.select(function() {
    return this.appendChild(e.apply(this, arguments));
  });
}
function one() {
  return null;
}
function lne(t, e) {
  var r = typeof t == "function" ? t : yP(t), n = e == null ? one : typeof e == "function" ? e : l5(e);
  return this.select(function() {
    return this.insertBefore(r.apply(this, arguments), n.apply(this, arguments) || null);
  });
}
function une() {
  var t = this.parentNode;
  t && t.removeChild(this);
}
function cne() {
  return this.each(une);
}
function fne() {
  var t = this.cloneNode(!1), e = this.parentNode;
  return e ? e.insertBefore(t, this.nextSibling) : t;
}
function hne() {
  var t = this.cloneNode(!0), e = this.parentNode;
  return e ? e.insertBefore(t, this.nextSibling) : t;
}
function dne(t) {
  return this.select(t ? hne : fne);
}
function pne(t) {
  return arguments.length ? this.property("__data__", t) : this.node().__data__;
}
function gne(t) {
  return function(e) {
    t.call(this, e, this.__data__);
  };
}
function vne(t) {
  return t.trim().split(/^|\s+/).map(function(e) {
    var r = "", n = e.indexOf(".");
    return n >= 0 && (r = e.slice(n + 1), e = e.slice(0, n)), { type: e, name: r };
  });
}
function mne(t) {
  return function() {
    var e = this.__on;
    if (e) {
      for (var r = 0, n = -1, a = e.length, i; r < a; ++r)
        i = e[r], (!t.type || i.type === t.type) && i.name === t.name ? this.removeEventListener(i.type, i.listener, i.options) : e[++n] = i;
      ++n ? e.length = n : delete this.__on;
    }
  };
}
function yne(t, e, r) {
  return function() {
    var n = this.__on, a, i = gne(e);
    if (n) {
      for (var s = 0, o = n.length; s < o; ++s)
        if ((a = n[s]).type === t.type && a.name === t.name) {
          this.removeEventListener(a.type, a.listener, a.options), this.addEventListener(a.type, a.listener = i, a.options = r), a.value = e;
          return;
        }
    }
    this.addEventListener(t.type, i, r), a = { type: t.type, name: t.name, value: e, listener: i, options: r }, n ? n.push(a) : this.__on = [a];
  };
}
function bne(t, e, r) {
  var n = vne(t + ""), a, i = n.length, s;
  if (arguments.length < 2) {
    var o = this.node().__on;
    if (o) {
      for (var l = 0, u = o.length, c; l < u; ++l)
        for (a = 0, c = o[l]; a < i; ++a)
          if ((s = n[a]).type === c.type && s.name === c.name)
            return c.value;
    }
    return;
  }
  for (o = e ? yne : mne, a = 0; a < i; ++a) this.each(o(n[a], e, r));
  return this;
}
function RP(t, e, r) {
  var n = TP(t), a = n.CustomEvent;
  typeof a == "function" ? a = new a(e, r) : (a = n.document.createEvent("Event"), r ? (a.initEvent(e, r.bubbles, r.cancelable), a.detail = r.detail) : a.initEvent(e, !1, !1)), t.dispatchEvent(a);
}
function xne(t, e) {
  return function() {
    return RP(this, t, e);
  };
}
function wne(t, e) {
  return function() {
    return RP(this, t, e.apply(this, arguments));
  };
}
function Ene(t, e) {
  return this.each((typeof e == "function" ? wne : xne)(t, e));
}
function* Tne() {
  for (var t = this._groups, e = 0, r = t.length; e < r; ++e)
    for (var n = t[e], a = 0, i = n.length, s; a < i; ++a)
      (s = n[a]) && (yield s);
}
var MP = [null];
function ni(t, e) {
  this._groups = t, this._parents = e;
}
function z0() {
  return new ni([[document.documentElement]], MP);
}
function Sne() {
  return this;
}
ni.prototype = z0.prototype = {
  constructor: ni,
  select: Kte,
  selectAll: ere,
  selectChild: are,
  selectChildren: lre,
  filter: ure,
  data: gre,
  enter: cre,
  exit: mre,
  join: yre,
  merge: bre,
  selection: Sne,
  order: xre,
  sort: wre,
  call: Tre,
  nodes: Sre,
  node: Cre,
  size: Are,
  empty: kre,
  each: Rre,
  attr: Pre,
  style: Bre,
  property: Hre,
  classed: jre,
  text: Zre,
  html: tne,
  raise: nne,
  lower: ine,
  append: sne,
  insert: lne,
  remove: cne,
  clone: dne,
  datum: pne,
  on: bne,
  dispatch: Ene,
  [Symbol.iterator]: Tne
};
function n_e(t) {
  return typeof t == "string" ? new ni([[document.querySelector(t)]], [document.documentElement]) : new ni([[t]], MP);
}
function G0(t, e, r) {
  t.prototype = e.prototype = r, r.constructor = t;
}
function s1(t, e) {
  var r = Object.create(t.prototype);
  for (var n in e) r[n] = e[n];
  return r;
}
function mu() {
}
var Wd = 0.7, Wv = 1 / Wd, vc = "\\s*([+-]?\\d+)\\s*", jd = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", gs = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", Cne = /^#([0-9a-f]{3,8})$/, Ane = new RegExp(`^rgb\\(${vc},${vc},${vc}\\)$`), kne = new RegExp(`^rgb\\(${gs},${gs},${gs}\\)$`), Rne = new RegExp(`^rgba\\(${vc},${vc},${vc},${jd}\\)$`), Mne = new RegExp(`^rgba\\(${gs},${gs},${gs},${jd}\\)$`), _ne = new RegExp(`^hsl\\(${jd},${gs},${gs}\\)$`), Lne = new RegExp(`^hsla\\(${jd},${gs},${gs},${jd}\\)$`), $k = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
G0(mu, Kl, {
  copy(t) {
    return Object.assign(new this.constructor(), this, t);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: Fk,
  // Deprecated! Use color.formatHex.
  formatHex: Fk,
  formatHex8: Nne,
  formatHsl: One,
  formatRgb: Bk,
  toString: Bk
});
function Fk() {
  return this.rgb().formatHex();
}
function Nne() {
  return this.rgb().formatHex8();
}
function One() {
  return LP(this).formatHsl();
}
function Bk() {
  return this.rgb().formatRgb();
}
function Kl(t) {
  var e, r;
  return t = (t + "").trim().toLowerCase(), (e = Cne.exec(t)) ? (r = e[1].length, e = parseInt(e[1], 16), r === 6 ? zk(e) : r === 3 ? new Qn(e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, (e & 15) << 4 | e & 15, 1) : r === 8 ? $p(e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, (e & 255) / 255) : r === 4 ? $p(e >> 12 & 15 | e >> 8 & 240, e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, ((e & 15) << 4 | e & 15) / 255) : null) : (e = Ane.exec(t)) ? new Qn(e[1], e[2], e[3], 1) : (e = kne.exec(t)) ? new Qn(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, 1) : (e = Rne.exec(t)) ? $p(e[1], e[2], e[3], e[4]) : (e = Mne.exec(t)) ? $p(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, e[4]) : (e = _ne.exec(t)) ? Hk(e[1], e[2] / 100, e[3] / 100, 1) : (e = Lne.exec(t)) ? Hk(e[1], e[2] / 100, e[3] / 100, e[4]) : $k.hasOwnProperty(t) ? zk($k[t]) : t === "transparent" ? new Qn(NaN, NaN, NaN, 0) : null;
}
function zk(t) {
  return new Qn(t >> 16 & 255, t >> 8 & 255, t & 255, 1);
}
function $p(t, e, r, n) {
  return n <= 0 && (t = e = r = NaN), new Qn(t, e, r, n);
}
function _P(t) {
  return t instanceof mu || (t = Kl(t)), t ? (t = t.rgb(), new Qn(t.r, t.g, t.b, t.opacity)) : new Qn();
}
function gT(t, e, r, n) {
  return arguments.length === 1 ? _P(t) : new Qn(t, e, r, n ?? 1);
}
function Qn(t, e, r, n) {
  this.r = +t, this.g = +e, this.b = +r, this.opacity = +n;
}
G0(Qn, gT, s1(mu, {
  brighter(t) {
    return t = t == null ? Wv : Math.pow(Wv, t), new Qn(this.r * t, this.g * t, this.b * t, this.opacity);
  },
  darker(t) {
    return t = t == null ? Wd : Math.pow(Wd, t), new Qn(this.r * t, this.g * t, this.b * t, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Qn(jl(this.r), jl(this.g), jl(this.b), jv(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: Gk,
  // Deprecated! Use color.formatHex.
  formatHex: Gk,
  formatHex8: Ine,
  formatRgb: Uk,
  toString: Uk
}));
function Gk() {
  return `#${zl(this.r)}${zl(this.g)}${zl(this.b)}`;
}
function Ine() {
  return `#${zl(this.r)}${zl(this.g)}${zl(this.b)}${zl((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function Uk() {
  const t = jv(this.opacity);
  return `${t === 1 ? "rgb(" : "rgba("}${jl(this.r)}, ${jl(this.g)}, ${jl(this.b)}${t === 1 ? ")" : `, ${t})`}`;
}
function jv(t) {
  return isNaN(t) ? 1 : Math.max(0, Math.min(1, t));
}
function jl(t) {
  return Math.max(0, Math.min(255, Math.round(t) || 0));
}
function zl(t) {
  return t = jl(t), (t < 16 ? "0" : "") + t.toString(16);
}
function Hk(t, e, r, n) {
  return n <= 0 ? t = e = r = NaN : r <= 0 || r >= 1 ? t = e = NaN : e <= 0 && (t = NaN), new Di(t, e, r, n);
}
function LP(t) {
  if (t instanceof Di) return new Di(t.h, t.s, t.l, t.opacity);
  if (t instanceof mu || (t = Kl(t)), !t) return new Di();
  if (t instanceof Di) return t;
  t = t.rgb();
  var e = t.r / 255, r = t.g / 255, n = t.b / 255, a = Math.min(e, r, n), i = Math.max(e, r, n), s = NaN, o = i - a, l = (i + a) / 2;
  return o ? (e === i ? s = (r - n) / o + (r < n) * 6 : r === i ? s = (n - e) / o + 2 : s = (e - r) / o + 4, o /= l < 0.5 ? i + a : 2 - i - a, s *= 60) : o = l > 0 && l < 1 ? 0 : s, new Di(s, o, l, t.opacity);
}
function Pne(t, e, r, n) {
  return arguments.length === 1 ? LP(t) : new Di(t, e, r, n ?? 1);
}
function Di(t, e, r, n) {
  this.h = +t, this.s = +e, this.l = +r, this.opacity = +n;
}
G0(Di, Pne, s1(mu, {
  brighter(t) {
    return t = t == null ? Wv : Math.pow(Wv, t), new Di(this.h, this.s, this.l * t, this.opacity);
  },
  darker(t) {
    return t = t == null ? Wd : Math.pow(Wd, t), new Di(this.h, this.s, this.l * t, this.opacity);
  },
  rgb() {
    var t = this.h % 360 + (this.h < 0) * 360, e = isNaN(t) || isNaN(this.s) ? 0 : this.s, r = this.l, n = r + (r < 0.5 ? r : 1 - r) * e, a = 2 * r - n;
    return new Qn(
      rx(t >= 240 ? t - 240 : t + 120, a, n),
      rx(t, a, n),
      rx(t < 120 ? t + 240 : t - 120, a, n),
      this.opacity
    );
  },
  clamp() {
    return new Di(Vk(this.h), Fp(this.s), Fp(this.l), jv(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const t = jv(this.opacity);
    return `${t === 1 ? "hsl(" : "hsla("}${Vk(this.h)}, ${Fp(this.s) * 100}%, ${Fp(this.l) * 100}%${t === 1 ? ")" : `, ${t})`}`;
  }
}));
function Vk(t) {
  return t = (t || 0) % 360, t < 0 ? t + 360 : t;
}
function Fp(t) {
  return Math.max(0, Math.min(1, t || 0));
}
function rx(t, e, r) {
  return (t < 60 ? e + (r - e) * t / 60 : t < 180 ? r : t < 240 ? e + (r - e) * (240 - t) / 60 : e) * 255;
}
const Dne = Math.PI / 180, $ne = 180 / Math.PI, Yv = 18, NP = 0.96422, OP = 1, IP = 0.82521, PP = 4 / 29, mc = 6 / 29, DP = 3 * mc * mc, Fne = mc * mc * mc;
function $P(t) {
  if (t instanceof vs) return new vs(t.l, t.a, t.b, t.opacity);
  if (t instanceof Hs) return FP(t);
  t instanceof Qn || (t = _P(t));
  var e = sx(t.r), r = sx(t.g), n = sx(t.b), a = nx((0.2225045 * e + 0.7168786 * r + 0.0606169 * n) / OP), i, s;
  return e === r && r === n ? i = s = a : (i = nx((0.4360747 * e + 0.3850649 * r + 0.1430804 * n) / NP), s = nx((0.0139322 * e + 0.0971045 * r + 0.7141733 * n) / IP)), new vs(116 * a - 16, 500 * (i - a), 200 * (a - s), t.opacity);
}
function Bne(t, e, r, n) {
  return arguments.length === 1 ? $P(t) : new vs(t, e, r, n ?? 1);
}
function vs(t, e, r, n) {
  this.l = +t, this.a = +e, this.b = +r, this.opacity = +n;
}
G0(vs, Bne, s1(mu, {
  brighter(t) {
    return new vs(this.l + Yv * (t ?? 1), this.a, this.b, this.opacity);
  },
  darker(t) {
    return new vs(this.l - Yv * (t ?? 1), this.a, this.b, this.opacity);
  },
  rgb() {
    var t = (this.l + 16) / 116, e = isNaN(this.a) ? t : t + this.a / 500, r = isNaN(this.b) ? t : t - this.b / 200;
    return e = NP * ax(e), t = OP * ax(t), r = IP * ax(r), new Qn(
      ix(3.1338561 * e - 1.6168667 * t - 0.4906146 * r),
      ix(-0.9787684 * e + 1.9161415 * t + 0.033454 * r),
      ix(0.0719453 * e - 0.2289914 * t + 1.4052427 * r),
      this.opacity
    );
  }
}));
function nx(t) {
  return t > Fne ? Math.pow(t, 1 / 3) : t / DP + PP;
}
function ax(t) {
  return t > mc ? t * t * t : DP * (t - PP);
}
function ix(t) {
  return 255 * (t <= 31308e-7 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - 0.055);
}
function sx(t) {
  return (t /= 255) <= 0.04045 ? t / 12.92 : Math.pow((t + 0.055) / 1.055, 2.4);
}
function zne(t) {
  if (t instanceof Hs) return new Hs(t.h, t.c, t.l, t.opacity);
  if (t instanceof vs || (t = $P(t)), t.a === 0 && t.b === 0) return new Hs(NaN, 0 < t.l && t.l < 100 ? 0 : NaN, t.l, t.opacity);
  var e = Math.atan2(t.b, t.a) * $ne;
  return new Hs(e < 0 ? e + 360 : e, Math.sqrt(t.a * t.a + t.b * t.b), t.l, t.opacity);
}
function vT(t, e, r, n) {
  return arguments.length === 1 ? zne(t) : new Hs(t, e, r, n ?? 1);
}
function Hs(t, e, r, n) {
  this.h = +t, this.c = +e, this.l = +r, this.opacity = +n;
}
function FP(t) {
  if (isNaN(t.h)) return new vs(t.l, 0, 0, t.opacity);
  var e = t.h * Dne;
  return new vs(t.l, Math.cos(e) * t.c, Math.sin(e) * t.c, t.opacity);
}
G0(Hs, vT, s1(mu, {
  brighter(t) {
    return new Hs(this.h, this.c, this.l + Yv * (t ?? 1), this.opacity);
  },
  darker(t) {
    return new Hs(this.h, this.c, this.l - Yv * (t ?? 1), this.opacity);
  },
  rgb() {
    return FP(this).rgb();
  }
}));
const o1 = (t) => () => t;
function BP(t, e) {
  return function(r) {
    return t + r * e;
  };
}
function Gne(t, e, r) {
  return t = Math.pow(t, r), e = Math.pow(e, r) - t, r = 1 / r, function(n) {
    return Math.pow(t + n * e, r);
  };
}
function Une(t, e) {
  var r = e - t;
  return r ? BP(t, r > 180 || r < -180 ? r - 360 * Math.round(r / 360) : r) : o1(isNaN(t) ? e : t);
}
function Hne(t) {
  return (t = +t) == 1 ? wd : function(e, r) {
    return r - e ? Gne(e, r, t) : o1(isNaN(e) ? r : e);
  };
}
function wd(t, e) {
  var r = e - t;
  return r ? BP(t, r) : o1(isNaN(t) ? e : t);
}
const Xv = function t(e) {
  var r = Hne(e);
  function n(a, i) {
    var s = r((a = gT(a)).r, (i = gT(i)).r), o = r(a.g, i.g), l = r(a.b, i.b), u = wd(a.opacity, i.opacity);
    return function(c) {
      return a.r = s(c), a.g = o(c), a.b = l(c), a.opacity = u(c), a + "";
    };
  }
  return n.gamma = t, n;
}(1);
function Vne(t, e) {
  e || (e = []);
  var r = t ? Math.min(e.length, t.length) : 0, n = e.slice(), a;
  return function(i) {
    for (a = 0; a < r; ++a) n[a] = t[a] * (1 - i) + e[a] * i;
    return n;
  };
}
function qne(t) {
  return ArrayBuffer.isView(t) && !(t instanceof DataView);
}
function Wne(t, e) {
  var r = e ? e.length : 0, n = t ? Math.min(r, t.length) : 0, a = new Array(n), i = new Array(r), s;
  for (s = 0; s < n; ++s) a[s] = c5(t[s], e[s]);
  for (; s < r; ++s) i[s] = e[s];
  return function(o) {
    for (s = 0; s < n; ++s) i[s] = a[s](o);
    return i;
  };
}
function jne(t, e) {
  var r = /* @__PURE__ */ new Date();
  return t = +t, e = +e, function(n) {
    return r.setTime(t * (1 - n) + e * n), r;
  };
}
function Oi(t, e) {
  return t = +t, e = +e, function(r) {
    return t * (1 - r) + e * r;
  };
}
function Yne(t, e) {
  var r = {}, n = {}, a;
  (t === null || typeof t != "object") && (t = {}), (e === null || typeof e != "object") && (e = {});
  for (a in e)
    a in t ? r[a] = c5(t[a], e[a]) : n[a] = e[a];
  return function(i) {
    for (a in r) n[a] = r[a](i);
    return n;
  };
}
var mT = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, ox = new RegExp(mT.source, "g");
function Xne(t) {
  return function() {
    return t;
  };
}
function Kne(t) {
  return function(e) {
    return t(e) + "";
  };
}
function zP(t, e) {
  var r = mT.lastIndex = ox.lastIndex = 0, n, a, i, s = -1, o = [], l = [];
  for (t = t + "", e = e + ""; (n = mT.exec(t)) && (a = ox.exec(e)); )
    (i = a.index) > r && (i = e.slice(r, i), o[s] ? o[s] += i : o[++s] = i), (n = n[0]) === (a = a[0]) ? o[s] ? o[s] += a : o[++s] = a : (o[++s] = null, l.push({ i: s, x: Oi(n, a) })), r = ox.lastIndex;
  return r < e.length && (i = e.slice(r), o[s] ? o[s] += i : o[++s] = i), o.length < 2 ? l[0] ? Kne(l[0].x) : Xne(e) : (e = l.length, function(u) {
    for (var c = 0, f; c < e; ++c) o[(f = l[c]).i] = f.x(u);
    return o.join("");
  });
}
function c5(t, e) {
  var r = typeof e, n;
  return e == null || r === "boolean" ? o1(e) : (r === "number" ? Oi : r === "string" ? (n = Kl(e)) ? (e = n, Xv) : zP : e instanceof Kl ? Xv : e instanceof Date ? jne : qne(e) ? Vne : Array.isArray(e) ? Wne : typeof e.valueOf != "function" && typeof e.toString != "function" || isNaN(e) ? Yne : Oi)(t, e);
}
function Zne(t, e) {
  return t = +t, e = +e, function(r) {
    return Math.round(t * (1 - r) + e * r);
  };
}
var qk = 180 / Math.PI, yT = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function GP(t, e, r, n, a, i) {
  var s, o, l;
  return (s = Math.sqrt(t * t + e * e)) && (t /= s, e /= s), (l = t * r + e * n) && (r -= t * l, n -= e * l), (o = Math.sqrt(r * r + n * n)) && (r /= o, n /= o, l /= o), t * n < e * r && (t = -t, e = -e, l = -l, s = -s), {
    translateX: a,
    translateY: i,
    rotate: Math.atan2(e, t) * qk,
    skewX: Math.atan(l) * qk,
    scaleX: s,
    scaleY: o
  };
}
var Bp;
function Qne(t) {
  const e = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(t + "");
  return e.isIdentity ? yT : GP(e.a, e.b, e.c, e.d, e.e, e.f);
}
function Jne(t) {
  return t == null || (Bp || (Bp = document.createElementNS("http://www.w3.org/2000/svg", "g")), Bp.setAttribute("transform", t), !(t = Bp.transform.baseVal.consolidate())) ? yT : (t = t.matrix, GP(t.a, t.b, t.c, t.d, t.e, t.f));
}
function UP(t, e, r, n) {
  function a(u) {
    return u.length ? u.pop() + " " : "";
  }
  function i(u, c, f, h, d, p) {
    if (u !== f || c !== h) {
      var g = d.push("translate(", null, e, null, r);
      p.push({ i: g - 4, x: Oi(u, f) }, { i: g - 2, x: Oi(c, h) });
    } else (f || h) && d.push("translate(" + f + e + h + r);
  }
  function s(u, c, f, h) {
    u !== c ? (u - c > 180 ? c += 360 : c - u > 180 && (u += 360), h.push({ i: f.push(a(f) + "rotate(", null, n) - 2, x: Oi(u, c) })) : c && f.push(a(f) + "rotate(" + c + n);
  }
  function o(u, c, f, h) {
    u !== c ? h.push({ i: f.push(a(f) + "skewX(", null, n) - 2, x: Oi(u, c) }) : c && f.push(a(f) + "skewX(" + c + n);
  }
  function l(u, c, f, h, d, p) {
    if (u !== f || c !== h) {
      var g = d.push(a(d) + "scale(", null, ",", null, ")");
      p.push({ i: g - 4, x: Oi(u, f) }, { i: g - 2, x: Oi(c, h) });
    } else (f !== 1 || h !== 1) && d.push(a(d) + "scale(" + f + "," + h + ")");
  }
  return function(u, c) {
    var f = [], h = [];
    return u = t(u), c = t(c), i(u.translateX, u.translateY, c.translateX, c.translateY, f, h), s(u.rotate, c.rotate, f, h), o(u.skewX, c.skewX, f, h), l(u.scaleX, u.scaleY, c.scaleX, c.scaleY, f, h), u = c = null, function(d) {
      for (var p = -1, g = h.length, v; ++p < g; ) f[(v = h[p]).i] = v.x(d);
      return f.join("");
    };
  };
}
var eae = UP(Qne, "px, ", "px)", "deg)"), tae = UP(Jne, ", ", ")", ")");
function rae(t) {
  return function(e, r) {
    var n = t((e = vT(e)).h, (r = vT(r)).h), a = wd(e.c, r.c), i = wd(e.l, r.l), s = wd(e.opacity, r.opacity);
    return function(o) {
      return e.h = n(o), e.c = a(o), e.l = i(o), e.opacity = s(o), e + "";
    };
  };
}
const a_e = rae(Une);
var Kc = 0, Eh = 0, Zf = 0, HP = 1e3, Kv, Th, Zv = 0, Zl = 0, l1 = 0, Yd = typeof performance == "object" && performance.now ? performance : Date, VP = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(t) {
  setTimeout(t, 17);
};
function f5() {
  return Zl || (VP(nae), Zl = Yd.now() + l1);
}
function nae() {
  Zl = 0;
}
function Qv() {
  this._call = this._time = this._next = null;
}
Qv.prototype = qP.prototype = {
  constructor: Qv,
  restart: function(t, e, r) {
    if (typeof t != "function") throw new TypeError("callback is not a function");
    r = (r == null ? f5() : +r) + (e == null ? 0 : +e), !this._next && Th !== this && (Th ? Th._next = this : Kv = this, Th = this), this._call = t, this._time = r, bT();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, bT());
  }
};
function qP(t, e, r) {
  var n = new Qv();
  return n.restart(t, e, r), n;
}
function aae() {
  f5(), ++Kc;
  for (var t = Kv, e; t; )
    (e = Zl - t._time) >= 0 && t._call.call(void 0, e), t = t._next;
  --Kc;
}
function Wk() {
  Zl = (Zv = Yd.now()) + l1, Kc = Eh = 0;
  try {
    aae();
  } finally {
    Kc = 0, sae(), Zl = 0;
  }
}
function iae() {
  var t = Yd.now(), e = t - Zv;
  e > HP && (l1 -= e, Zv = t);
}
function sae() {
  for (var t, e = Kv, r, n = 1 / 0; e; )
    e._call ? (n > e._time && (n = e._time), t = e, e = e._next) : (r = e._next, e._next = null, e = t ? t._next = r : Kv = r);
  Th = t, bT(n);
}
function bT(t) {
  if (!Kc) {
    Eh && (Eh = clearTimeout(Eh));
    var e = t - Zl;
    e > 24 ? (t < 1 / 0 && (Eh = setTimeout(Wk, t - Yd.now() - l1)), Zf && (Zf = clearInterval(Zf))) : (Zf || (Zv = Yd.now(), Zf = setInterval(iae, HP)), Kc = 1, VP(Wk));
  }
}
function jk(t, e, r) {
  var n = new Qv();
  return e = e == null ? 0 : +e, n.restart((a) => {
    n.stop(), t(a + e);
  }, e, r), n;
}
var oae = mP("start", "end", "cancel", "interrupt"), lae = [], WP = 0, Yk = 1, xT = 2, iv = 3, Xk = 4, wT = 5, sv = 6;
function u1(t, e, r, n, a, i) {
  var s = t.__transition;
  if (!s) t.__transition = {};
  else if (r in s) return;
  uae(t, r, {
    name: e,
    index: n,
    // For context during callback.
    group: a,
    // For context during callback.
    on: oae,
    tween: lae,
    time: i.time,
    delay: i.delay,
    duration: i.duration,
    ease: i.ease,
    timer: null,
    state: WP
  });
}
function h5(t, e) {
  var r = Zi(t, e);
  if (r.state > WP) throw new Error("too late; already scheduled");
  return r;
}
function xs(t, e) {
  var r = Zi(t, e);
  if (r.state > iv) throw new Error("too late; already running");
  return r;
}
function Zi(t, e) {
  var r = t.__transition;
  if (!r || !(r = r[e])) throw new Error("transition not found");
  return r;
}
function uae(t, e, r) {
  var n = t.__transition, a;
  n[e] = r, r.timer = qP(i, 0, r.time);
  function i(u) {
    r.state = Yk, r.timer.restart(s, r.delay, r.time), r.delay <= u && s(u - r.delay);
  }
  function s(u) {
    var c, f, h, d;
    if (r.state !== Yk) return l();
    for (c in n)
      if (d = n[c], d.name === r.name) {
        if (d.state === iv) return jk(s);
        d.state === Xk ? (d.state = sv, d.timer.stop(), d.on.call("interrupt", t, t.__data__, d.index, d.group), delete n[c]) : +c < e && (d.state = sv, d.timer.stop(), d.on.call("cancel", t, t.__data__, d.index, d.group), delete n[c]);
      }
    if (jk(function() {
      r.state === iv && (r.state = Xk, r.timer.restart(o, r.delay, r.time), o(u));
    }), r.state = xT, r.on.call("start", t, t.__data__, r.index, r.group), r.state === xT) {
      for (r.state = iv, a = new Array(h = r.tween.length), c = 0, f = -1; c < h; ++c)
        (d = r.tween[c].value.call(t, t.__data__, r.index, r.group)) && (a[++f] = d);
      a.length = f + 1;
    }
  }
  function o(u) {
    for (var c = u < r.duration ? r.ease.call(null, u / r.duration) : (r.timer.restart(l), r.state = wT, 1), f = -1, h = a.length; ++f < h; )
      a[f].call(t, c);
    r.state === wT && (r.on.call("end", t, t.__data__, r.index, r.group), l());
  }
  function l() {
    r.state = sv, r.timer.stop(), delete n[e];
    for (var u in n) return;
    delete t.__transition;
  }
}
function cae(t, e) {
  var r = t.__transition, n, a, i = !0, s;
  if (r) {
    e = e == null ? null : e + "";
    for (s in r) {
      if ((n = r[s]).name !== e) {
        i = !1;
        continue;
      }
      a = n.state > xT && n.state < wT, n.state = sv, n.timer.stop(), n.on.call(a ? "interrupt" : "cancel", t, t.__data__, n.index, n.group), delete r[s];
    }
    i && delete t.__transition;
  }
}
function fae(t) {
  return this.each(function() {
    cae(this, t);
  });
}
function hae(t, e) {
  var r, n;
  return function() {
    var a = xs(this, t), i = a.tween;
    if (i !== r) {
      n = r = i;
      for (var s = 0, o = n.length; s < o; ++s)
        if (n[s].name === e) {
          n = n.slice(), n.splice(s, 1);
          break;
        }
    }
    a.tween = n;
  };
}
function dae(t, e, r) {
  var n, a;
  if (typeof r != "function") throw new Error();
  return function() {
    var i = xs(this, t), s = i.tween;
    if (s !== n) {
      a = (n = s).slice();
      for (var o = { name: e, value: r }, l = 0, u = a.length; l < u; ++l)
        if (a[l].name === e) {
          a[l] = o;
          break;
        }
      l === u && a.push(o);
    }
    i.tween = a;
  };
}
function pae(t, e) {
  var r = this._id;
  if (t += "", arguments.length < 2) {
    for (var n = Zi(this.node(), r).tween, a = 0, i = n.length, s; a < i; ++a)
      if ((s = n[a]).name === t)
        return s.value;
    return null;
  }
  return this.each((e == null ? hae : dae)(r, t, e));
}
function d5(t, e, r) {
  var n = t._id;
  return t.each(function() {
    var a = xs(this, n);
    (a.value || (a.value = {}))[e] = r.apply(this, arguments);
  }), function(a) {
    return Zi(a, n).value[e];
  };
}
function jP(t, e) {
  var r;
  return (typeof e == "number" ? Oi : e instanceof Kl ? Xv : (r = Kl(e)) ? (e = r, Xv) : zP)(t, e);
}
function gae(t) {
  return function() {
    this.removeAttribute(t);
  };
}
function vae(t) {
  return function() {
    this.removeAttributeNS(t.space, t.local);
  };
}
function mae(t, e, r) {
  var n, a = r + "", i;
  return function() {
    var s = this.getAttribute(t);
    return s === a ? null : s === n ? i : i = e(n = s, r);
  };
}
function yae(t, e, r) {
  var n, a = r + "", i;
  return function() {
    var s = this.getAttributeNS(t.space, t.local);
    return s === a ? null : s === n ? i : i = e(n = s, r);
  };
}
function bae(t, e, r) {
  var n, a, i;
  return function() {
    var s, o = r(this), l;
    return o == null ? void this.removeAttribute(t) : (s = this.getAttribute(t), l = o + "", s === l ? null : s === n && l === a ? i : (a = l, i = e(n = s, o)));
  };
}
function xae(t, e, r) {
  var n, a, i;
  return function() {
    var s, o = r(this), l;
    return o == null ? void this.removeAttributeNS(t.space, t.local) : (s = this.getAttributeNS(t.space, t.local), l = o + "", s === l ? null : s === n && l === a ? i : (a = l, i = e(n = s, o)));
  };
}
function wae(t, e) {
  var r = i1(t), n = r === "transform" ? tae : jP;
  return this.attrTween(t, typeof e == "function" ? (r.local ? xae : bae)(r, n, d5(this, "attr." + t, e)) : e == null ? (r.local ? vae : gae)(r) : (r.local ? yae : mae)(r, n, e));
}
function Eae(t, e) {
  return function(r) {
    this.setAttribute(t, e.call(this, r));
  };
}
function Tae(t, e) {
  return function(r) {
    this.setAttributeNS(t.space, t.local, e.call(this, r));
  };
}
function Sae(t, e) {
  var r, n;
  function a() {
    var i = e.apply(this, arguments);
    return i !== n && (r = (n = i) && Tae(t, i)), r;
  }
  return a._value = e, a;
}
function Cae(t, e) {
  var r, n;
  function a() {
    var i = e.apply(this, arguments);
    return i !== n && (r = (n = i) && Eae(t, i)), r;
  }
  return a._value = e, a;
}
function Aae(t, e) {
  var r = "attr." + t;
  if (arguments.length < 2) return (r = this.tween(r)) && r._value;
  if (e == null) return this.tween(r, null);
  if (typeof e != "function") throw new Error();
  var n = i1(t);
  return this.tween(r, (n.local ? Sae : Cae)(n, e));
}
function kae(t, e) {
  return function() {
    h5(this, t).delay = +e.apply(this, arguments);
  };
}
function Rae(t, e) {
  return e = +e, function() {
    h5(this, t).delay = e;
  };
}
function Mae(t) {
  var e = this._id;
  return arguments.length ? this.each((typeof t == "function" ? kae : Rae)(e, t)) : Zi(this.node(), e).delay;
}
function _ae(t, e) {
  return function() {
    xs(this, t).duration = +e.apply(this, arguments);
  };
}
function Lae(t, e) {
  return e = +e, function() {
    xs(this, t).duration = e;
  };
}
function Nae(t) {
  var e = this._id;
  return arguments.length ? this.each((typeof t == "function" ? _ae : Lae)(e, t)) : Zi(this.node(), e).duration;
}
function Oae(t, e) {
  if (typeof e != "function") throw new Error();
  return function() {
    xs(this, t).ease = e;
  };
}
function Iae(t) {
  var e = this._id;
  return arguments.length ? this.each(Oae(e, t)) : Zi(this.node(), e).ease;
}
function Pae(t, e) {
  return function() {
    var r = e.apply(this, arguments);
    if (typeof r != "function") throw new Error();
    xs(this, t).ease = r;
  };
}
function Dae(t) {
  if (typeof t != "function") throw new Error();
  return this.each(Pae(this._id, t));
}
function $ae(t) {
  typeof t != "function" && (t = xP(t));
  for (var e = this._groups, r = e.length, n = new Array(r), a = 0; a < r; ++a)
    for (var i = e[a], s = i.length, o = n[a] = [], l, u = 0; u < s; ++u)
      (l = i[u]) && t.call(l, l.__data__, u, i) && o.push(l);
  return new eo(n, this._parents, this._name, this._id);
}
function Fae(t) {
  if (t._id !== this._id) throw new Error();
  for (var e = this._groups, r = t._groups, n = e.length, a = r.length, i = Math.min(n, a), s = new Array(n), o = 0; o < i; ++o)
    for (var l = e[o], u = r[o], c = l.length, f = s[o] = new Array(c), h, d = 0; d < c; ++d)
      (h = l[d] || u[d]) && (f[d] = h);
  for (; o < n; ++o)
    s[o] = e[o];
  return new eo(s, this._parents, this._name, this._id);
}
function Bae(t) {
  return (t + "").trim().split(/^|\s+/).every(function(e) {
    var r = e.indexOf(".");
    return r >= 0 && (e = e.slice(0, r)), !e || e === "start";
  });
}
function zae(t, e, r) {
  var n, a, i = Bae(e) ? h5 : xs;
  return function() {
    var s = i(this, t), o = s.on;
    o !== n && (a = (n = o).copy()).on(e, r), s.on = a;
  };
}
function Gae(t, e) {
  var r = this._id;
  return arguments.length < 2 ? Zi(this.node(), r).on.on(t) : this.each(zae(r, t, e));
}
function Uae(t) {
  return function() {
    var e = this.parentNode;
    for (var r in this.__transition) if (+r !== t) return;
    e && e.removeChild(this);
  };
}
function Hae() {
  return this.on("end.remove", Uae(this._id));
}
function Vae(t) {
  var e = this._name, r = this._id;
  typeof t != "function" && (t = l5(t));
  for (var n = this._groups, a = n.length, i = new Array(a), s = 0; s < a; ++s)
    for (var o = n[s], l = o.length, u = i[s] = new Array(l), c, f, h = 0; h < l; ++h)
      (c = o[h]) && (f = t.call(c, c.__data__, h, o)) && ("__data__" in c && (f.__data__ = c.__data__), u[h] = f, u1(u[h], e, r, h, u, Zi(c, r)));
  return new eo(i, this._parents, e, r);
}
function qae(t) {
  var e = this._name, r = this._id;
  typeof t != "function" && (t = bP(t));
  for (var n = this._groups, a = n.length, i = [], s = [], o = 0; o < a; ++o)
    for (var l = n[o], u = l.length, c, f = 0; f < u; ++f)
      if (c = l[f]) {
        for (var h = t.call(c, c.__data__, f, l), d, p = Zi(c, r), g = 0, v = h.length; g < v; ++g)
          (d = h[g]) && u1(d, e, r, g, h, p);
        i.push(h), s.push(c);
      }
  return new eo(i, s, e, r);
}
var Wae = z0.prototype.constructor;
function jae() {
  return new Wae(this._groups, this._parents);
}
function Yae(t, e) {
  var r, n, a;
  return function() {
    var i = Xc(this, t), s = (this.style.removeProperty(t), Xc(this, t));
    return i === s ? null : i === r && s === n ? a : a = e(r = i, n = s);
  };
}
function YP(t) {
  return function() {
    this.style.removeProperty(t);
  };
}
function Xae(t, e, r) {
  var n, a = r + "", i;
  return function() {
    var s = Xc(this, t);
    return s === a ? null : s === n ? i : i = e(n = s, r);
  };
}
function Kae(t, e, r) {
  var n, a, i;
  return function() {
    var s = Xc(this, t), o = r(this), l = o + "";
    return o == null && (l = o = (this.style.removeProperty(t), Xc(this, t))), s === l ? null : s === n && l === a ? i : (a = l, i = e(n = s, o));
  };
}
function Zae(t, e) {
  var r, n, a, i = "style." + e, s = "end." + i, o;
  return function() {
    var l = xs(this, t), u = l.on, c = l.value[i] == null ? o || (o = YP(e)) : void 0;
    (u !== r || a !== c) && (n = (r = u).copy()).on(s, a = c), l.on = n;
  };
}
function Qae(t, e, r) {
  var n = (t += "") == "transform" ? eae : jP;
  return e == null ? this.styleTween(t, Yae(t, n)).on("end.style." + t, YP(t)) : typeof e == "function" ? this.styleTween(t, Kae(t, n, d5(this, "style." + t, e))).each(Zae(this._id, t)) : this.styleTween(t, Xae(t, n, e), r).on("end.style." + t, null);
}
function Jae(t, e, r) {
  return function(n) {
    this.style.setProperty(t, e.call(this, n), r);
  };
}
function eie(t, e, r) {
  var n, a;
  function i() {
    var s = e.apply(this, arguments);
    return s !== a && (n = (a = s) && Jae(t, s, r)), n;
  }
  return i._value = e, i;
}
function tie(t, e, r) {
  var n = "style." + (t += "");
  if (arguments.length < 2) return (n = this.tween(n)) && n._value;
  if (e == null) return this.tween(n, null);
  if (typeof e != "function") throw new Error();
  return this.tween(n, eie(t, e, r ?? ""));
}
function rie(t) {
  return function() {
    this.textContent = t;
  };
}
function nie(t) {
  return function() {
    var e = t(this);
    this.textContent = e ?? "";
  };
}
function aie(t) {
  return this.tween("text", typeof t == "function" ? nie(d5(this, "text", t)) : rie(t == null ? "" : t + ""));
}
function iie(t) {
  return function(e) {
    this.textContent = t.call(this, e);
  };
}
function sie(t) {
  var e, r;
  function n() {
    var a = t.apply(this, arguments);
    return a !== r && (e = (r = a) && iie(a)), e;
  }
  return n._value = t, n;
}
function oie(t) {
  var e = "text";
  if (arguments.length < 1) return (e = this.tween(e)) && e._value;
  if (t == null) return this.tween(e, null);
  if (typeof t != "function") throw new Error();
  return this.tween(e, sie(t));
}
function lie() {
  for (var t = this._name, e = this._id, r = XP(), n = this._groups, a = n.length, i = 0; i < a; ++i)
    for (var s = n[i], o = s.length, l, u = 0; u < o; ++u)
      if (l = s[u]) {
        var c = Zi(l, e);
        u1(l, t, r, u, s, {
          time: c.time + c.delay + c.duration,
          delay: 0,
          duration: c.duration,
          ease: c.ease
        });
      }
  return new eo(n, this._parents, t, r);
}
function uie() {
  var t, e, r = this, n = r._id, a = r.size();
  return new Promise(function(i, s) {
    var o = { value: s }, l = { value: function() {
      --a === 0 && i();
    } };
    r.each(function() {
      var u = xs(this, n), c = u.on;
      c !== t && (e = (t = c).copy(), e._.cancel.push(o), e._.interrupt.push(o), e._.end.push(l)), u.on = e;
    }), a === 0 && i();
  });
}
var cie = 0;
function eo(t, e, r, n) {
  this._groups = t, this._parents = e, this._name = r, this._id = n;
}
function XP() {
  return ++cie;
}
var _s = z0.prototype;
eo.prototype = {
  constructor: eo,
  select: Vae,
  selectAll: qae,
  selectChild: _s.selectChild,
  selectChildren: _s.selectChildren,
  filter: $ae,
  merge: Fae,
  selection: jae,
  transition: lie,
  call: _s.call,
  nodes: _s.nodes,
  node: _s.node,
  size: _s.size,
  empty: _s.empty,
  each: _s.each,
  on: Gae,
  attr: wae,
  attrTween: Aae,
  style: Qae,
  styleTween: tie,
  text: aie,
  textTween: oie,
  remove: Hae,
  tween: pae,
  delay: Mae,
  duration: Nae,
  ease: Iae,
  easeVarying: Dae,
  end: uie,
  [Symbol.iterator]: _s[Symbol.iterator]
};
function fie(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}
var hie = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: fie
};
function die(t, e) {
  for (var r; !(r = t.__transition) || !(r = r[e]); )
    if (!(t = t.parentNode))
      throw new Error(`transition ${e} not found`);
  return r;
}
function pie(t) {
  var e, r;
  t instanceof eo ? (e = t._id, t = t._name) : (e = XP(), (r = hie).time = f5(), t = t == null ? null : t + "");
  for (var n = this._groups, a = n.length, i = 0; i < a; ++i)
    for (var s = n[i], o = s.length, l, u = 0; u < o; ++u)
      (l = s[u]) && u1(l, t, e, u, s, r || die(l, e));
  return new eo(n, this._parents, t, e);
}
z0.prototype.interrupt = fae;
z0.prototype.transition = pie;
const ET = Math.PI, TT = 2 * ET, Ml = 1e-6, gie = TT - Ml;
function KP(t) {
  this._ += t[0];
  for (let e = 1, r = t.length; e < r; ++e)
    this._ += arguments[e] + t[e];
}
function vie(t) {
  let e = Math.floor(t);
  if (!(e >= 0)) throw new Error(`invalid digits: ${t}`);
  if (e > 15) return KP;
  const r = 10 ** e;
  return function(n) {
    this._ += n[0];
    for (let a = 1, i = n.length; a < i; ++a)
      this._ += Math.round(arguments[a] * r) / r + n[a];
  };
}
let mie = class {
  constructor(e) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "", this._append = e == null ? KP : vie(e);
  }
  moveTo(e, r) {
    this._append`M${this._x0 = this._x1 = +e},${this._y0 = this._y1 = +r}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(e, r) {
    this._append`L${this._x1 = +e},${this._y1 = +r}`;
  }
  quadraticCurveTo(e, r, n, a) {
    this._append`Q${+e},${+r},${this._x1 = +n},${this._y1 = +a}`;
  }
  bezierCurveTo(e, r, n, a, i, s) {
    this._append`C${+e},${+r},${+n},${+a},${this._x1 = +i},${this._y1 = +s}`;
  }
  arcTo(e, r, n, a, i) {
    if (e = +e, r = +r, n = +n, a = +a, i = +i, i < 0) throw new Error(`negative radius: ${i}`);
    let s = this._x1, o = this._y1, l = n - e, u = a - r, c = s - e, f = o - r, h = c * c + f * f;
    if (this._x1 === null)
      this._append`M${this._x1 = e},${this._y1 = r}`;
    else if (h > Ml) if (!(Math.abs(f * l - u * c) > Ml) || !i)
      this._append`L${this._x1 = e},${this._y1 = r}`;
    else {
      let d = n - s, p = a - o, g = l * l + u * u, v = d * d + p * p, m = Math.sqrt(g), b = Math.sqrt(h), y = i * Math.tan((ET - Math.acos((g + h - v) / (2 * m * b))) / 2), x = y / b, E = y / m;
      Math.abs(x - 1) > Ml && this._append`L${e + x * c},${r + x * f}`, this._append`A${i},${i},0,0,${+(f * d > c * p)},${this._x1 = e + E * l},${this._y1 = r + E * u}`;
    }
  }
  arc(e, r, n, a, i, s) {
    if (e = +e, r = +r, n = +n, s = !!s, n < 0) throw new Error(`negative radius: ${n}`);
    let o = n * Math.cos(a), l = n * Math.sin(a), u = e + o, c = r + l, f = 1 ^ s, h = s ? a - i : i - a;
    this._x1 === null ? this._append`M${u},${c}` : (Math.abs(this._x1 - u) > Ml || Math.abs(this._y1 - c) > Ml) && this._append`L${u},${c}`, n && (h < 0 && (h = h % TT + TT), h > gie ? this._append`A${n},${n},0,1,${f},${e - o},${r - l}A${n},${n},0,1,${f},${this._x1 = u},${this._y1 = c}` : h > Ml && this._append`A${n},${n},0,${+(h >= ET)},${f},${this._x1 = e + n * Math.cos(i)},${this._y1 = r + n * Math.sin(i)}`);
  }
  rect(e, r, n, a) {
    this._append`M${this._x0 = this._x1 = +e},${this._y0 = this._y1 = +r}h${n = +n}v${+a}h${-n}Z`;
  }
  toString() {
    return this._;
  }
};
function yie(t) {
  return Math.abs(t = Math.round(t)) >= 1e21 ? t.toLocaleString("en").replace(/,/g, "") : t.toString(10);
}
function Jv(t, e) {
  if ((r = (t = e ? t.toExponential(e - 1) : t.toExponential()).indexOf("e")) < 0) return null;
  var r, n = t.slice(0, r);
  return [
    n.length > 1 ? n[0] + n.slice(2) : n,
    +t.slice(r + 1)
  ];
}
function Zc(t) {
  return t = Jv(Math.abs(t)), t ? t[1] : NaN;
}
function bie(t, e) {
  return function(r, n) {
    for (var a = r.length, i = [], s = 0, o = t[0], l = 0; a > 0 && o > 0 && (l + o + 1 > n && (o = Math.max(1, n - l)), i.push(r.substring(a -= o, a + o)), !((l += o + 1) > n)); )
      o = t[s = (s + 1) % t.length];
    return i.reverse().join(e);
  };
}
function xie(t) {
  return function(e) {
    return e.replace(/[0-9]/g, function(r) {
      return t[+r];
    });
  };
}
var wie = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function em(t) {
  if (!(e = wie.exec(t))) throw new Error("invalid format: " + t);
  var e;
  return new p5({
    fill: e[1],
    align: e[2],
    sign: e[3],
    symbol: e[4],
    zero: e[5],
    width: e[6],
    comma: e[7],
    precision: e[8] && e[8].slice(1),
    trim: e[9],
    type: e[10]
  });
}
em.prototype = p5.prototype;
function p5(t) {
  this.fill = t.fill === void 0 ? " " : t.fill + "", this.align = t.align === void 0 ? ">" : t.align + "", this.sign = t.sign === void 0 ? "-" : t.sign + "", this.symbol = t.symbol === void 0 ? "" : t.symbol + "", this.zero = !!t.zero, this.width = t.width === void 0 ? void 0 : +t.width, this.comma = !!t.comma, this.precision = t.precision === void 0 ? void 0 : +t.precision, this.trim = !!t.trim, this.type = t.type === void 0 ? "" : t.type + "";
}
p5.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function Eie(t) {
  e: for (var e = t.length, r = 1, n = -1, a; r < e; ++r)
    switch (t[r]) {
      case ".":
        n = a = r;
        break;
      case "0":
        n === 0 && (n = r), a = r;
        break;
      default:
        if (!+t[r]) break e;
        n > 0 && (n = 0);
        break;
    }
  return n > 0 ? t.slice(0, n) + t.slice(a + 1) : t;
}
var ZP;
function Tie(t, e) {
  var r = Jv(t, e);
  if (!r) return t + "";
  var n = r[0], a = r[1], i = a - (ZP = Math.max(-8, Math.min(8, Math.floor(a / 3))) * 3) + 1, s = n.length;
  return i === s ? n : i > s ? n + new Array(i - s + 1).join("0") : i > 0 ? n.slice(0, i) + "." + n.slice(i) : "0." + new Array(1 - i).join("0") + Jv(t, Math.max(0, e + i - 1))[0];
}
function Kk(t, e) {
  var r = Jv(t, e);
  if (!r) return t + "";
  var n = r[0], a = r[1];
  return a < 0 ? "0." + new Array(-a).join("0") + n : n.length > a + 1 ? n.slice(0, a + 1) + "." + n.slice(a + 1) : n + new Array(a - n.length + 2).join("0");
}
const Zk = {
  "%": (t, e) => (t * 100).toFixed(e),
  b: (t) => Math.round(t).toString(2),
  c: (t) => t + "",
  d: yie,
  e: (t, e) => t.toExponential(e),
  f: (t, e) => t.toFixed(e),
  g: (t, e) => t.toPrecision(e),
  o: (t) => Math.round(t).toString(8),
  p: (t, e) => Kk(t * 100, e),
  r: Kk,
  s: Tie,
  X: (t) => Math.round(t).toString(16).toUpperCase(),
  x: (t) => Math.round(t).toString(16)
};
function Qk(t) {
  return t;
}
var Jk = Array.prototype.map, eR = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function Sie(t) {
  var e = t.grouping === void 0 || t.thousands === void 0 ? Qk : bie(Jk.call(t.grouping, Number), t.thousands + ""), r = t.currency === void 0 ? "" : t.currency[0] + "", n = t.currency === void 0 ? "" : t.currency[1] + "", a = t.decimal === void 0 ? "." : t.decimal + "", i = t.numerals === void 0 ? Qk : xie(Jk.call(t.numerals, String)), s = t.percent === void 0 ? "%" : t.percent + "", o = t.minus === void 0 ? "−" : t.minus + "", l = t.nan === void 0 ? "NaN" : t.nan + "";
  function u(f) {
    f = em(f);
    var h = f.fill, d = f.align, p = f.sign, g = f.symbol, v = f.zero, m = f.width, b = f.comma, y = f.precision, x = f.trim, E = f.type;
    E === "n" ? (b = !0, E = "g") : Zk[E] || (y === void 0 && (y = 12), x = !0, E = "g"), (v || h === "0" && d === "=") && (v = !0, h = "0", d = "=");
    var S = g === "$" ? r : g === "#" && /[boxX]/.test(E) ? "0" + E.toLowerCase() : "", w = g === "$" ? n : /[%p]/.test(E) ? s : "", C = Zk[E], k = /[defgprs%]/.test(E);
    y = y === void 0 ? 6 : /[gprs]/.test(E) ? Math.max(1, Math.min(21, y)) : Math.max(0, Math.min(20, y));
    function N(R) {
      var _ = S, O = w, T, L, M;
      if (E === "c")
        O = C(R) + O, R = "";
      else {
        R = +R;
        var A = R < 0 || 1 / R < 0;
        if (R = isNaN(R) ? l : C(Math.abs(R), y), x && (R = Eie(R)), A && +R == 0 && p !== "+" && (A = !1), _ = (A ? p === "(" ? p : o : p === "-" || p === "(" ? "" : p) + _, O = (E === "s" ? eR[8 + ZP / 3] : "") + O + (A && p === "(" ? ")" : ""), k) {
          for (T = -1, L = R.length; ++T < L; )
            if (M = R.charCodeAt(T), 48 > M || M > 57) {
              O = (M === 46 ? a + R.slice(T + 1) : R.slice(T)) + O, R = R.slice(0, T);
              break;
            }
        }
      }
      b && !v && (R = e(R, 1 / 0));
      var I = _.length + R.length + O.length, D = I < m ? new Array(m - I + 1).join(h) : "";
      switch (b && v && (R = e(D + R, D.length ? m - O.length : 1 / 0), D = ""), d) {
        case "<":
          R = _ + R + O + D;
          break;
        case "=":
          R = _ + D + R + O;
          break;
        case "^":
          R = D.slice(0, I = D.length >> 1) + _ + R + O + D.slice(I);
          break;
        default:
          R = D + _ + R + O;
          break;
      }
      return i(R);
    }
    return N.toString = function() {
      return f + "";
    }, N;
  }
  function c(f, h) {
    var d = u((f = em(f), f.type = "f", f)), p = Math.max(-8, Math.min(8, Math.floor(Zc(h) / 3))) * 3, g = Math.pow(10, -p), v = eR[8 + p / 3];
    return function(m) {
      return d(g * m) + v;
    };
  }
  return {
    format: u,
    formatPrefix: c
  };
}
var zp, QP, JP;
Cie({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function Cie(t) {
  return zp = Sie(t), QP = zp.format, JP = zp.formatPrefix, zp;
}
function Aie(t) {
  return Math.max(0, -Zc(Math.abs(t)));
}
function kie(t, e) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(Zc(e) / 3))) * 3 - Zc(Math.abs(t)));
}
function Rie(t, e) {
  return t = Math.abs(t), e = Math.abs(e) - t, Math.max(0, Zc(e) - Zc(t)) + 1;
}
function Mie(t) {
  var e = 0, r = t.children, n = r && r.length;
  if (!n) e = 1;
  else for (; --n >= 0; ) e += r[n].value;
  t.value = e;
}
function _ie() {
  return this.eachAfter(Mie);
}
function Lie(t, e) {
  let r = -1;
  for (const n of this)
    t.call(e, n, ++r, this);
  return this;
}
function Nie(t, e) {
  for (var r = this, n = [r], a, i, s = -1; r = n.pop(); )
    if (t.call(e, r, ++s, this), a = r.children)
      for (i = a.length - 1; i >= 0; --i)
        n.push(a[i]);
  return this;
}
function Oie(t, e) {
  for (var r = this, n = [r], a = [], i, s, o, l = -1; r = n.pop(); )
    if (a.push(r), i = r.children)
      for (s = 0, o = i.length; s < o; ++s)
        n.push(i[s]);
  for (; r = a.pop(); )
    t.call(e, r, ++l, this);
  return this;
}
function Iie(t, e) {
  let r = -1;
  for (const n of this)
    if (t.call(e, n, ++r, this))
      return n;
}
function Pie(t) {
  return this.eachAfter(function(e) {
    for (var r = +t(e.data) || 0, n = e.children, a = n && n.length; --a >= 0; ) r += n[a].value;
    e.value = r;
  });
}
function Die(t) {
  return this.eachBefore(function(e) {
    e.children && e.children.sort(t);
  });
}
function $ie(t) {
  for (var e = this, r = Fie(e, t), n = [e]; e !== r; )
    e = e.parent, n.push(e);
  for (var a = n.length; t !== r; )
    n.splice(a, 0, t), t = t.parent;
  return n;
}
function Fie(t, e) {
  if (t === e) return t;
  var r = t.ancestors(), n = e.ancestors(), a = null;
  for (t = r.pop(), e = n.pop(); t === e; )
    a = t, t = r.pop(), e = n.pop();
  return a;
}
function Bie() {
  for (var t = this, e = [t]; t = t.parent; )
    e.push(t);
  return e;
}
function zie() {
  return Array.from(this);
}
function Gie() {
  var t = [];
  return this.eachBefore(function(e) {
    e.children || t.push(e);
  }), t;
}
function Uie() {
  var t = this, e = [];
  return t.each(function(r) {
    r !== t && e.push({ source: r.parent, target: r });
  }), e;
}
function* Hie() {
  var t = this, e, r = [t], n, a, i;
  do
    for (e = r.reverse(), r = []; t = e.pop(); )
      if (yield t, n = t.children)
        for (a = 0, i = n.length; a < i; ++a)
          r.push(n[a]);
  while (r.length);
}
function e9(t, e) {
  t instanceof Map ? (t = [void 0, t], e === void 0 && (e = Wie)) : e === void 0 && (e = qie);
  for (var r = new tm(t), n, a = [r], i, s, o, l; n = a.pop(); )
    if ((s = e(n.data)) && (l = (s = Array.from(s)).length))
      for (n.children = s, o = l - 1; o >= 0; --o)
        a.push(i = s[o] = new tm(s[o])), i.parent = n, i.depth = n.depth + 1;
  return r.eachBefore(Yie);
}
function Vie() {
  return e9(this).eachBefore(jie);
}
function qie(t) {
  return t.children;
}
function Wie(t) {
  return Array.isArray(t) ? t[1] : null;
}
function jie(t) {
  t.data.value !== void 0 && (t.value = t.data.value), t.data = t.data.data;
}
function Yie(t) {
  var e = 0;
  do
    t.height = e;
  while ((t = t.parent) && t.height < ++e);
}
function tm(t) {
  this.data = t, this.depth = this.height = 0, this.parent = null;
}
tm.prototype = e9.prototype = {
  constructor: tm,
  count: _ie,
  each: Lie,
  eachAfter: Oie,
  eachBefore: Nie,
  find: Iie,
  sum: Pie,
  sort: Die,
  path: $ie,
  ancestors: Bie,
  descendants: zie,
  leaves: Gie,
  links: Uie,
  copy: Vie,
  [Symbol.iterator]: Hie
};
function Xie(t) {
  if (typeof t != "function") throw new Error();
  return t;
}
function Qf() {
  return 0;
}
function Jf(t) {
  return function() {
    return t;
  };
}
function Kie(t) {
  t.x0 = Math.round(t.x0), t.y0 = Math.round(t.y0), t.x1 = Math.round(t.x1), t.y1 = Math.round(t.y1);
}
function Zie(t, e, r, n, a) {
  for (var i = t.children, s, o = -1, l = i.length, u = t.value && (n - e) / t.value; ++o < l; )
    s = i[o], s.y0 = r, s.y1 = a, s.x0 = e, s.x1 = e += s.value * u;
}
function Qie(t, e, r, n, a) {
  for (var i = t.children, s, o = -1, l = i.length, u = t.value && (a - r) / t.value; ++o < l; )
    s = i[o], s.x0 = e, s.x1 = n, s.y0 = r, s.y1 = r += s.value * u;
}
var Jie = (1 + Math.sqrt(5)) / 2;
function ese(t, e, r, n, a, i) {
  for (var s = [], o = e.children, l, u, c = 0, f = 0, h = o.length, d, p, g = e.value, v, m, b, y, x, E, S; c < h; ) {
    d = a - r, p = i - n;
    do
      v = o[f++].value;
    while (!v && f < h);
    for (m = b = v, E = Math.max(p / d, d / p) / (g * t), S = v * v * E, x = Math.max(b / S, S / m); f < h; ++f) {
      if (v += u = o[f].value, u < m && (m = u), u > b && (b = u), S = v * v * E, y = Math.max(b / S, S / m), y > x) {
        v -= u;
        break;
      }
      x = y;
    }
    s.push(l = { value: v, dice: d < p, children: o.slice(c, f) }), l.dice ? Zie(l, r, n, a, g ? n += p * v / g : i) : Qie(l, r, n, g ? r += d * v / g : a, i), g -= v, c = f;
  }
  return s;
}
const tse = function t(e) {
  function r(n, a, i, s, o) {
    ese(e, n, a, i, s, o);
  }
  return r.ratio = function(n) {
    return t((n = +n) > 1 ? n : 1);
  }, r;
}(Jie);
function s_e() {
  var t = tse, e = !1, r = 1, n = 1, a = [0], i = Qf, s = Qf, o = Qf, l = Qf, u = Qf;
  function c(h) {
    return h.x0 = h.y0 = 0, h.x1 = r, h.y1 = n, h.eachBefore(f), a = [0], e && h.eachBefore(Kie), h;
  }
  function f(h) {
    var d = a[h.depth], p = h.x0 + d, g = h.y0 + d, v = h.x1 - d, m = h.y1 - d;
    v < p && (p = v = (p + v) / 2), m < g && (g = m = (g + m) / 2), h.x0 = p, h.y0 = g, h.x1 = v, h.y1 = m, h.children && (d = a[h.depth + 1] = i(h) / 2, p += u(h) - d, g += s(h) - d, v -= o(h) - d, m -= l(h) - d, v < p && (p = v = (p + v) / 2), m < g && (g = m = (g + m) / 2), t(h, p, g, v, m));
  }
  return c.round = function(h) {
    return arguments.length ? (e = !!h, c) : e;
  }, c.size = function(h) {
    return arguments.length ? (r = +h[0], n = +h[1], c) : [r, n];
  }, c.tile = function(h) {
    return arguments.length ? (t = Xie(h), c) : t;
  }, c.padding = function(h) {
    return arguments.length ? c.paddingInner(h).paddingOuter(h) : c.paddingInner();
  }, c.paddingInner = function(h) {
    return arguments.length ? (i = typeof h == "function" ? h : Jf(+h), c) : i;
  }, c.paddingOuter = function(h) {
    return arguments.length ? c.paddingTop(h).paddingRight(h).paddingBottom(h).paddingLeft(h) : c.paddingTop();
  }, c.paddingTop = function(h) {
    return arguments.length ? (s = typeof h == "function" ? h : Jf(+h), c) : s;
  }, c.paddingRight = function(h) {
    return arguments.length ? (o = typeof h == "function" ? h : Jf(+h), c) : o;
  }, c.paddingBottom = function(h) {
    return arguments.length ? (l = typeof h == "function" ? h : Jf(+h), c) : l;
  }, c.paddingLeft = function(h) {
    return arguments.length ? (u = typeof h == "function" ? h : Jf(+h), c) : u;
  }, c;
}
function c1(t, e) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(t);
      break;
    default:
      this.range(e).domain(t);
      break;
  }
  return this;
}
const tR = Symbol("implicit");
function t9() {
  var t = new Nk(), e = [], r = [], n = tR;
  function a(i) {
    let s = t.get(i);
    if (s === void 0) {
      if (n !== tR) return n;
      t.set(i, s = e.push(i) - 1);
    }
    return r[s % r.length];
  }
  return a.domain = function(i) {
    if (!arguments.length) return e.slice();
    e = [], t = new Nk();
    for (const s of i)
      t.has(s) || t.set(s, e.push(s) - 1);
    return a;
  }, a.range = function(i) {
    return arguments.length ? (r = Array.from(i), a) : r.slice();
  }, a.unknown = function(i) {
    return arguments.length ? (n = i, a) : n;
  }, a.copy = function() {
    return t9(e, r).unknown(n);
  }, c1.apply(a, arguments), a;
}
function rse() {
  var t = t9().unknown(void 0), e = t.domain, r = t.range, n = 0, a = 1, i, s, o = !1, l = 0, u = 0, c = 0.5;
  delete t.unknown;
  function f() {
    var h = e().length, d = a < n, p = d ? a : n, g = d ? n : a;
    i = (g - p) / Math.max(1, h - l + u * 2), o && (i = Math.floor(i)), p += (g - p - i * (h - l)) * c, s = i * (1 - l), o && (p = Math.round(p), s = Math.round(s));
    var v = $te(h).map(function(m) {
      return p + i * m;
    });
    return r(d ? v.reverse() : v);
  }
  return t.domain = function(h) {
    return arguments.length ? (e(h), f()) : e();
  }, t.range = function(h) {
    return arguments.length ? ([n, a] = h, n = +n, a = +a, f()) : [n, a];
  }, t.rangeRound = function(h) {
    return [n, a] = h, n = +n, a = +a, o = !0, f();
  }, t.bandwidth = function() {
    return s;
  }, t.step = function() {
    return i;
  }, t.round = function(h) {
    return arguments.length ? (o = !!h, f()) : o;
  }, t.padding = function(h) {
    return arguments.length ? (l = Math.min(1, u = +h), f()) : l;
  }, t.paddingInner = function(h) {
    return arguments.length ? (l = Math.min(1, h), f()) : l;
  }, t.paddingOuter = function(h) {
    return arguments.length ? (u = +h, f()) : u;
  }, t.align = function(h) {
    return arguments.length ? (c = Math.max(0, Math.min(1, h)), f()) : c;
  }, t.copy = function() {
    return rse(e(), [n, a]).round(o).paddingInner(l).paddingOuter(u).align(c);
  }, c1.apply(f(), arguments);
}
function nse(t) {
  return function() {
    return t;
  };
}
function ase(t) {
  return +t;
}
var rR = [0, 1];
function ic(t) {
  return t;
}
function ST(t, e) {
  return (e -= t = +t) ? function(r) {
    return (r - t) / e;
  } : nse(isNaN(e) ? NaN : 0.5);
}
function ise(t, e) {
  var r;
  return t > e && (r = t, t = e, e = r), function(n) {
    return Math.max(t, Math.min(e, n));
  };
}
function sse(t, e, r) {
  var n = t[0], a = t[1], i = e[0], s = e[1];
  return a < n ? (n = ST(a, n), i = r(s, i)) : (n = ST(n, a), i = r(i, s)), function(o) {
    return i(n(o));
  };
}
function ose(t, e, r) {
  var n = Math.min(t.length, e.length) - 1, a = new Array(n), i = new Array(n), s = -1;
  for (t[n] < t[0] && (t = t.slice().reverse(), e = e.slice().reverse()); ++s < n; )
    a[s] = ST(t[s], t[s + 1]), i[s] = r(e[s], e[s + 1]);
  return function(o) {
    var l = Mte(t, o, 1, n) - 1;
    return i[l](a[l](o));
  };
}
function r9(t, e) {
  return e.domain(t.domain()).range(t.range()).interpolate(t.interpolate()).clamp(t.clamp()).unknown(t.unknown());
}
function lse() {
  var t = rR, e = rR, r = c5, n, a, i, s = ic, o, l, u;
  function c() {
    var h = Math.min(t.length, e.length);
    return s !== ic && (s = ise(t[0], t[h - 1])), o = h > 2 ? ose : sse, l = u = null, f;
  }
  function f(h) {
    return h == null || isNaN(h = +h) ? i : (l || (l = o(t.map(n), e, r)))(n(s(h)));
  }
  return f.invert = function(h) {
    return s(a((u || (u = o(e, t.map(n), Oi)))(h)));
  }, f.domain = function(h) {
    return arguments.length ? (t = Array.from(h, ase), c()) : t.slice();
  }, f.range = function(h) {
    return arguments.length ? (e = Array.from(h), c()) : e.slice();
  }, f.rangeRound = function(h) {
    return e = Array.from(h), r = Zne, c();
  }, f.clamp = function(h) {
    return arguments.length ? (s = h ? !0 : ic, c()) : s !== ic;
  }, f.interpolate = function(h) {
    return arguments.length ? (r = h, c()) : r;
  }, f.unknown = function(h) {
    return arguments.length ? (i = h, f) : i;
  }, function(h, d) {
    return n = h, a = d, c();
  };
}
function n9() {
  return lse()(ic, ic);
}
function use(t, e, r, n) {
  var a = hT(t, e, r), i;
  switch (n = em(n ?? ",f"), n.type) {
    case "s": {
      var s = Math.max(Math.abs(t), Math.abs(e));
      return n.precision == null && !isNaN(i = kie(a, s)) && (n.precision = i), JP(n, s);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      n.precision == null && !isNaN(i = Rie(a, Math.max(Math.abs(t), Math.abs(e)))) && (n.precision = i - (n.type === "e"));
      break;
    }
    case "f":
    case "%": {
      n.precision == null && !isNaN(i = Aie(a)) && (n.precision = i - (n.type === "%") * 2);
      break;
    }
  }
  return QP(n);
}
function cse(t) {
  var e = t.domain;
  return t.ticks = function(r) {
    var n = e();
    return Dte(n[0], n[n.length - 1], r ?? 10);
  }, t.tickFormat = function(r, n) {
    var a = e();
    return use(a[0], a[a.length - 1], r ?? 10, n);
  }, t.nice = function(r) {
    r == null && (r = 10);
    var n = e(), a = 0, i = n.length - 1, s = n[a], o = n[i], l, u, c = 10;
    for (o < s && (u = s, s = o, o = u, u = a, a = i, i = u); c-- > 0; ) {
      if (u = fT(s, o, r), u === l)
        return n[a] = s, n[i] = o, e(n);
      if (u > 0)
        s = Math.floor(s / u) * u, o = Math.ceil(o / u) * u;
      else if (u < 0)
        s = Math.ceil(s * u) / u, o = Math.floor(o * u) / u;
      else
        break;
      l = u;
    }
    return t;
  }, t;
}
function fse() {
  var t = n9();
  return t.copy = function() {
    return r9(t, fse());
  }, c1.apply(t, arguments), cse(t);
}
function hse(t, e) {
  t = t.slice();
  var r = 0, n = t.length - 1, a = t[r], i = t[n], s;
  return i < a && (s = r, r = n, n = s, s = a, a = i, i = s), t[r] = e.floor(a), t[n] = e.ceil(i), t;
}
const lx = /* @__PURE__ */ new Date(), ux = /* @__PURE__ */ new Date();
function wn(t, e, r, n) {
  function a(i) {
    return t(i = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+i)), i;
  }
  return a.floor = (i) => (t(i = /* @__PURE__ */ new Date(+i)), i), a.ceil = (i) => (t(i = new Date(i - 1)), e(i, 1), t(i), i), a.round = (i) => {
    const s = a(i), o = a.ceil(i);
    return i - s < o - i ? s : o;
  }, a.offset = (i, s) => (e(i = /* @__PURE__ */ new Date(+i), s == null ? 1 : Math.floor(s)), i), a.range = (i, s, o) => {
    const l = [];
    if (i = a.ceil(i), o = o == null ? 1 : Math.floor(o), !(i < s) || !(o > 0)) return l;
    let u;
    do
      l.push(u = /* @__PURE__ */ new Date(+i)), e(i, o), t(i);
    while (u < i && i < s);
    return l;
  }, a.filter = (i) => wn((s) => {
    if (s >= s) for (; t(s), !i(s); ) s.setTime(s - 1);
  }, (s, o) => {
    if (s >= s)
      if (o < 0) for (; ++o <= 0; )
        for (; e(s, -1), !i(s); )
          ;
      else for (; --o >= 0; )
        for (; e(s, 1), !i(s); )
          ;
  }), r && (a.count = (i, s) => (lx.setTime(+i), ux.setTime(+s), t(lx), t(ux), Math.floor(r(lx, ux))), a.every = (i) => (i = Math.floor(i), !isFinite(i) || !(i > 0) ? null : i > 1 ? a.filter(n ? (s) => n(s) % i === 0 : (s) => a.count(0, s) % i === 0) : a)), a;
}
const rm = wn(() => {
}, (t, e) => {
  t.setTime(+t + e);
}, (t, e) => e - t);
rm.every = (t) => (t = Math.floor(t), !isFinite(t) || !(t > 0) ? null : t > 1 ? wn((e) => {
  e.setTime(Math.floor(e / t) * t);
}, (e, r) => {
  e.setTime(+e + r * t);
}, (e, r) => (r - e) / t) : rm);
rm.range;
const Vs = 1e3, di = Vs * 60, qs = di * 60, to = qs * 24, g5 = to * 7, nR = to * 30, cx = to * 365, sc = wn((t) => {
  t.setTime(t - t.getMilliseconds());
}, (t, e) => {
  t.setTime(+t + e * Vs);
}, (t, e) => (e - t) / Vs, (t) => t.getUTCSeconds());
sc.range;
const v5 = wn((t) => {
  t.setTime(t - t.getMilliseconds() - t.getSeconds() * Vs);
}, (t, e) => {
  t.setTime(+t + e * di);
}, (t, e) => (e - t) / di, (t) => t.getMinutes());
v5.range;
const dse = wn((t) => {
  t.setUTCSeconds(0, 0);
}, (t, e) => {
  t.setTime(+t + e * di);
}, (t, e) => (e - t) / di, (t) => t.getUTCMinutes());
dse.range;
const m5 = wn((t) => {
  t.setTime(t - t.getMilliseconds() - t.getSeconds() * Vs - t.getMinutes() * di);
}, (t, e) => {
  t.setTime(+t + e * qs);
}, (t, e) => (e - t) / qs, (t) => t.getHours());
m5.range;
const pse = wn((t) => {
  t.setUTCMinutes(0, 0, 0);
}, (t, e) => {
  t.setTime(+t + e * qs);
}, (t, e) => (e - t) / qs, (t) => t.getUTCHours());
pse.range;
const U0 = wn(
  (t) => t.setHours(0, 0, 0, 0),
  (t, e) => t.setDate(t.getDate() + e),
  (t, e) => (e - t - (e.getTimezoneOffset() - t.getTimezoneOffset()) * di) / to,
  (t) => t.getDate() - 1
);
U0.range;
const y5 = wn((t) => {
  t.setUTCHours(0, 0, 0, 0);
}, (t, e) => {
  t.setUTCDate(t.getUTCDate() + e);
}, (t, e) => (e - t) / to, (t) => t.getUTCDate() - 1);
y5.range;
const gse = wn((t) => {
  t.setUTCHours(0, 0, 0, 0);
}, (t, e) => {
  t.setUTCDate(t.getUTCDate() + e);
}, (t, e) => (e - t) / to, (t) => Math.floor(t / to));
gse.range;
function yu(t) {
  return wn((e) => {
    e.setDate(e.getDate() - (e.getDay() + 7 - t) % 7), e.setHours(0, 0, 0, 0);
  }, (e, r) => {
    e.setDate(e.getDate() + r * 7);
  }, (e, r) => (r - e - (r.getTimezoneOffset() - e.getTimezoneOffset()) * di) / g5);
}
const f1 = yu(0), nm = yu(1), vse = yu(2), mse = yu(3), Qc = yu(4), yse = yu(5), bse = yu(6);
f1.range;
nm.range;
vse.range;
mse.range;
Qc.range;
yse.range;
bse.range;
function bu(t) {
  return wn((e) => {
    e.setUTCDate(e.getUTCDate() - (e.getUTCDay() + 7 - t) % 7), e.setUTCHours(0, 0, 0, 0);
  }, (e, r) => {
    e.setUTCDate(e.getUTCDate() + r * 7);
  }, (e, r) => (r - e) / g5);
}
const a9 = bu(0), am = bu(1), xse = bu(2), wse = bu(3), Jc = bu(4), Ese = bu(5), Tse = bu(6);
a9.range;
am.range;
xse.range;
wse.range;
Jc.range;
Ese.range;
Tse.range;
const b5 = wn((t) => {
  t.setDate(1), t.setHours(0, 0, 0, 0);
}, (t, e) => {
  t.setMonth(t.getMonth() + e);
}, (t, e) => e.getMonth() - t.getMonth() + (e.getFullYear() - t.getFullYear()) * 12, (t) => t.getMonth());
b5.range;
const Sse = wn((t) => {
  t.setUTCDate(1), t.setUTCHours(0, 0, 0, 0);
}, (t, e) => {
  t.setUTCMonth(t.getUTCMonth() + e);
}, (t, e) => e.getUTCMonth() - t.getUTCMonth() + (e.getUTCFullYear() - t.getUTCFullYear()) * 12, (t) => t.getUTCMonth());
Sse.range;
const ro = wn((t) => {
  t.setMonth(0, 1), t.setHours(0, 0, 0, 0);
}, (t, e) => {
  t.setFullYear(t.getFullYear() + e);
}, (t, e) => e.getFullYear() - t.getFullYear(), (t) => t.getFullYear());
ro.every = (t) => !isFinite(t = Math.floor(t)) || !(t > 0) ? null : wn((e) => {
  e.setFullYear(Math.floor(e.getFullYear() / t) * t), e.setMonth(0, 1), e.setHours(0, 0, 0, 0);
}, (e, r) => {
  e.setFullYear(e.getFullYear() + r * t);
});
ro.range;
const Ql = wn((t) => {
  t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
}, (t, e) => {
  t.setUTCFullYear(t.getUTCFullYear() + e);
}, (t, e) => e.getUTCFullYear() - t.getUTCFullYear(), (t) => t.getUTCFullYear());
Ql.every = (t) => !isFinite(t = Math.floor(t)) || !(t > 0) ? null : wn((e) => {
  e.setUTCFullYear(Math.floor(e.getUTCFullYear() / t) * t), e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0);
}, (e, r) => {
  e.setUTCFullYear(e.getUTCFullYear() + r * t);
});
Ql.range;
function Cse(t, e, r, n, a, i) {
  const s = [
    [sc, 1, Vs],
    [sc, 5, 5 * Vs],
    [sc, 15, 15 * Vs],
    [sc, 30, 30 * Vs],
    [i, 1, di],
    [i, 5, 5 * di],
    [i, 15, 15 * di],
    [i, 30, 30 * di],
    [a, 1, qs],
    [a, 3, 3 * qs],
    [a, 6, 6 * qs],
    [a, 12, 12 * qs],
    [n, 1, to],
    [n, 2, 2 * to],
    [r, 1, g5],
    [e, 1, nR],
    [e, 3, 3 * nR],
    [t, 1, cx]
  ];
  function o(u, c, f) {
    const h = c < u;
    h && ([u, c] = [c, u]);
    const d = f && typeof f.range == "function" ? f : l(u, c, f), p = d ? d.range(u, +c + 1) : [];
    return h ? p.reverse() : p;
  }
  function l(u, c, f) {
    const h = Math.abs(c - u) / f, d = o5(([, , v]) => v).right(s, h);
    if (d === s.length) return t.every(hT(u / cx, c / cx, f));
    if (d === 0) return rm.every(Math.max(hT(u, c, f), 1));
    const [p, g] = s[h / s[d - 1][2] < s[d][2] / h ? d - 1 : d];
    return p.every(g);
  }
  return [o, l];
}
const [Ase, kse] = Cse(ro, b5, f1, U0, m5, v5);
function fx(t) {
  if (0 <= t.y && t.y < 100) {
    var e = new Date(-1, t.m, t.d, t.H, t.M, t.S, t.L);
    return e.setFullYear(t.y), e;
  }
  return new Date(t.y, t.m, t.d, t.H, t.M, t.S, t.L);
}
function hx(t) {
  if (0 <= t.y && t.y < 100) {
    var e = new Date(Date.UTC(-1, t.m, t.d, t.H, t.M, t.S, t.L));
    return e.setUTCFullYear(t.y), e;
  }
  return new Date(Date.UTC(t.y, t.m, t.d, t.H, t.M, t.S, t.L));
}
function eh(t, e, r) {
  return { y: t, m: e, d: r, H: 0, M: 0, S: 0, L: 0 };
}
function Rse(t) {
  var e = t.dateTime, r = t.date, n = t.time, a = t.periods, i = t.days, s = t.shortDays, o = t.months, l = t.shortMonths, u = th(a), c = rh(a), f = th(i), h = rh(i), d = th(s), p = rh(s), g = th(o), v = rh(o), m = th(l), b = rh(l), y = {
    a: A,
    A: I,
    b: D,
    B: F,
    c: null,
    d: uR,
    e: uR,
    f: Zse,
    g: ooe,
    G: uoe,
    H: Yse,
    I: Xse,
    j: Kse,
    L: i9,
    m: Qse,
    M: Jse,
    p: B,
    q: G,
    Q: hR,
    s: dR,
    S: eoe,
    u: toe,
    U: roe,
    V: noe,
    w: aoe,
    W: ioe,
    x: null,
    X: null,
    y: soe,
    Y: loe,
    Z: coe,
    "%": fR
  }, x = {
    a: H,
    A: K,
    b: j,
    B: Z,
    c: null,
    d: cR,
    e: cR,
    f: poe,
    g: Soe,
    G: Aoe,
    H: foe,
    I: hoe,
    j: doe,
    L: o9,
    m: goe,
    M: voe,
    p: te,
    q: ne,
    Q: hR,
    s: dR,
    S: moe,
    u: yoe,
    U: boe,
    V: xoe,
    w: woe,
    W: Eoe,
    x: null,
    X: null,
    y: Toe,
    Y: Coe,
    Z: koe,
    "%": fR
  }, E = {
    a: N,
    A: R,
    b: _,
    B: O,
    c: T,
    d: oR,
    e: oR,
    f: Vse,
    g: sR,
    G: iR,
    H: lR,
    I: lR,
    j: zse,
    L: Hse,
    m: Bse,
    M: Gse,
    p: k,
    q: Fse,
    Q: Wse,
    s: jse,
    S: Use,
    u: Ose,
    U: Ise,
    V: Pse,
    w: Nse,
    W: Dse,
    x: L,
    X: M,
    y: sR,
    Y: iR,
    Z: $se,
    "%": qse
  };
  y.x = S(r, y), y.X = S(n, y), y.c = S(e, y), x.x = S(r, x), x.X = S(n, x), x.c = S(e, x);
  function S(V, q) {
    return function(X) {
      var W = [], ue = -1, J = 0, Ce = V.length, Ee, Te, me;
      for (X instanceof Date || (X = /* @__PURE__ */ new Date(+X)); ++ue < Ce; )
        V.charCodeAt(ue) === 37 && (W.push(V.slice(J, ue)), (Te = aR[Ee = V.charAt(++ue)]) != null ? Ee = V.charAt(++ue) : Te = Ee === "e" ? " " : "0", (me = q[Ee]) && (Ee = me(X, Te)), W.push(Ee), J = ue + 1);
      return W.push(V.slice(J, ue)), W.join("");
    };
  }
  function w(V, q) {
    return function(X) {
      var W = eh(1900, void 0, 1), ue = C(W, V, X += "", 0), J, Ce;
      if (ue != X.length) return null;
      if ("Q" in W) return new Date(W.Q);
      if ("s" in W) return new Date(W.s * 1e3 + ("L" in W ? W.L : 0));
      if (q && !("Z" in W) && (W.Z = 0), "p" in W && (W.H = W.H % 12 + W.p * 12), W.m === void 0 && (W.m = "q" in W ? W.q : 0), "V" in W) {
        if (W.V < 1 || W.V > 53) return null;
        "w" in W || (W.w = 1), "Z" in W ? (J = hx(eh(W.y, 0, 1)), Ce = J.getUTCDay(), J = Ce > 4 || Ce === 0 ? am.ceil(J) : am(J), J = y5.offset(J, (W.V - 1) * 7), W.y = J.getUTCFullYear(), W.m = J.getUTCMonth(), W.d = J.getUTCDate() + (W.w + 6) % 7) : (J = fx(eh(W.y, 0, 1)), Ce = J.getDay(), J = Ce > 4 || Ce === 0 ? nm.ceil(J) : nm(J), J = U0.offset(J, (W.V - 1) * 7), W.y = J.getFullYear(), W.m = J.getMonth(), W.d = J.getDate() + (W.w + 6) % 7);
      } else ("W" in W || "U" in W) && ("w" in W || (W.w = "u" in W ? W.u % 7 : "W" in W ? 1 : 0), Ce = "Z" in W ? hx(eh(W.y, 0, 1)).getUTCDay() : fx(eh(W.y, 0, 1)).getDay(), W.m = 0, W.d = "W" in W ? (W.w + 6) % 7 + W.W * 7 - (Ce + 5) % 7 : W.w + W.U * 7 - (Ce + 6) % 7);
      return "Z" in W ? (W.H += W.Z / 100 | 0, W.M += W.Z % 100, hx(W)) : fx(W);
    };
  }
  function C(V, q, X, W) {
    for (var ue = 0, J = q.length, Ce = X.length, Ee, Te; ue < J; ) {
      if (W >= Ce) return -1;
      if (Ee = q.charCodeAt(ue++), Ee === 37) {
        if (Ee = q.charAt(ue++), Te = E[Ee in aR ? q.charAt(ue++) : Ee], !Te || (W = Te(V, X, W)) < 0) return -1;
      } else if (Ee != X.charCodeAt(W++))
        return -1;
    }
    return W;
  }
  function k(V, q, X) {
    var W = u.exec(q.slice(X));
    return W ? (V.p = c.get(W[0].toLowerCase()), X + W[0].length) : -1;
  }
  function N(V, q, X) {
    var W = d.exec(q.slice(X));
    return W ? (V.w = p.get(W[0].toLowerCase()), X + W[0].length) : -1;
  }
  function R(V, q, X) {
    var W = f.exec(q.slice(X));
    return W ? (V.w = h.get(W[0].toLowerCase()), X + W[0].length) : -1;
  }
  function _(V, q, X) {
    var W = m.exec(q.slice(X));
    return W ? (V.m = b.get(W[0].toLowerCase()), X + W[0].length) : -1;
  }
  function O(V, q, X) {
    var W = g.exec(q.slice(X));
    return W ? (V.m = v.get(W[0].toLowerCase()), X + W[0].length) : -1;
  }
  function T(V, q, X) {
    return C(V, e, q, X);
  }
  function L(V, q, X) {
    return C(V, r, q, X);
  }
  function M(V, q, X) {
    return C(V, n, q, X);
  }
  function A(V) {
    return s[V.getDay()];
  }
  function I(V) {
    return i[V.getDay()];
  }
  function D(V) {
    return l[V.getMonth()];
  }
  function F(V) {
    return o[V.getMonth()];
  }
  function B(V) {
    return a[+(V.getHours() >= 12)];
  }
  function G(V) {
    return 1 + ~~(V.getMonth() / 3);
  }
  function H(V) {
    return s[V.getUTCDay()];
  }
  function K(V) {
    return i[V.getUTCDay()];
  }
  function j(V) {
    return l[V.getUTCMonth()];
  }
  function Z(V) {
    return o[V.getUTCMonth()];
  }
  function te(V) {
    return a[+(V.getUTCHours() >= 12)];
  }
  function ne(V) {
    return 1 + ~~(V.getUTCMonth() / 3);
  }
  return {
    format: function(V) {
      var q = S(V += "", y);
      return q.toString = function() {
        return V;
      }, q;
    },
    parse: function(V) {
      var q = w(V += "", !1);
      return q.toString = function() {
        return V;
      }, q;
    },
    utcFormat: function(V) {
      var q = S(V += "", x);
      return q.toString = function() {
        return V;
      }, q;
    },
    utcParse: function(V) {
      var q = w(V += "", !0);
      return q.toString = function() {
        return V;
      }, q;
    }
  };
}
var aR = { "-": "", _: " ", 0: "0" }, On = /^\s*\d+/, Mse = /^%/, _se = /[\\^$*+?|[\]().{}]/g;
function nr(t, e, r) {
  var n = t < 0 ? "-" : "", a = (n ? -t : t) + "", i = a.length;
  return n + (i < r ? new Array(r - i + 1).join(e) + a : a);
}
function Lse(t) {
  return t.replace(_se, "\\$&");
}
function th(t) {
  return new RegExp("^(?:" + t.map(Lse).join("|") + ")", "i");
}
function rh(t) {
  return new Map(t.map((e, r) => [e.toLowerCase(), r]));
}
function Nse(t, e, r) {
  var n = On.exec(e.slice(r, r + 1));
  return n ? (t.w = +n[0], r + n[0].length) : -1;
}
function Ose(t, e, r) {
  var n = On.exec(e.slice(r, r + 1));
  return n ? (t.u = +n[0], r + n[0].length) : -1;
}
function Ise(t, e, r) {
  var n = On.exec(e.slice(r, r + 2));
  return n ? (t.U = +n[0], r + n[0].length) : -1;
}
function Pse(t, e, r) {
  var n = On.exec(e.slice(r, r + 2));
  return n ? (t.V = +n[0], r + n[0].length) : -1;
}
function Dse(t, e, r) {
  var n = On.exec(e.slice(r, r + 2));
  return n ? (t.W = +n[0], r + n[0].length) : -1;
}
function iR(t, e, r) {
  var n = On.exec(e.slice(r, r + 4));
  return n ? (t.y = +n[0], r + n[0].length) : -1;
}
function sR(t, e, r) {
  var n = On.exec(e.slice(r, r + 2));
  return n ? (t.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), r + n[0].length) : -1;
}
function $se(t, e, r) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(e.slice(r, r + 6));
  return n ? (t.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), r + n[0].length) : -1;
}
function Fse(t, e, r) {
  var n = On.exec(e.slice(r, r + 1));
  return n ? (t.q = n[0] * 3 - 3, r + n[0].length) : -1;
}
function Bse(t, e, r) {
  var n = On.exec(e.slice(r, r + 2));
  return n ? (t.m = n[0] - 1, r + n[0].length) : -1;
}
function oR(t, e, r) {
  var n = On.exec(e.slice(r, r + 2));
  return n ? (t.d = +n[0], r + n[0].length) : -1;
}
function zse(t, e, r) {
  var n = On.exec(e.slice(r, r + 3));
  return n ? (t.m = 0, t.d = +n[0], r + n[0].length) : -1;
}
function lR(t, e, r) {
  var n = On.exec(e.slice(r, r + 2));
  return n ? (t.H = +n[0], r + n[0].length) : -1;
}
function Gse(t, e, r) {
  var n = On.exec(e.slice(r, r + 2));
  return n ? (t.M = +n[0], r + n[0].length) : -1;
}
function Use(t, e, r) {
  var n = On.exec(e.slice(r, r + 2));
  return n ? (t.S = +n[0], r + n[0].length) : -1;
}
function Hse(t, e, r) {
  var n = On.exec(e.slice(r, r + 3));
  return n ? (t.L = +n[0], r + n[0].length) : -1;
}
function Vse(t, e, r) {
  var n = On.exec(e.slice(r, r + 6));
  return n ? (t.L = Math.floor(n[0] / 1e3), r + n[0].length) : -1;
}
function qse(t, e, r) {
  var n = Mse.exec(e.slice(r, r + 1));
  return n ? r + n[0].length : -1;
}
function Wse(t, e, r) {
  var n = On.exec(e.slice(r));
  return n ? (t.Q = +n[0], r + n[0].length) : -1;
}
function jse(t, e, r) {
  var n = On.exec(e.slice(r));
  return n ? (t.s = +n[0], r + n[0].length) : -1;
}
function uR(t, e) {
  return nr(t.getDate(), e, 2);
}
function Yse(t, e) {
  return nr(t.getHours(), e, 2);
}
function Xse(t, e) {
  return nr(t.getHours() % 12 || 12, e, 2);
}
function Kse(t, e) {
  return nr(1 + U0.count(ro(t), t), e, 3);
}
function i9(t, e) {
  return nr(t.getMilliseconds(), e, 3);
}
function Zse(t, e) {
  return i9(t, e) + "000";
}
function Qse(t, e) {
  return nr(t.getMonth() + 1, e, 2);
}
function Jse(t, e) {
  return nr(t.getMinutes(), e, 2);
}
function eoe(t, e) {
  return nr(t.getSeconds(), e, 2);
}
function toe(t) {
  var e = t.getDay();
  return e === 0 ? 7 : e;
}
function roe(t, e) {
  return nr(f1.count(ro(t) - 1, t), e, 2);
}
function s9(t) {
  var e = t.getDay();
  return e >= 4 || e === 0 ? Qc(t) : Qc.ceil(t);
}
function noe(t, e) {
  return t = s9(t), nr(Qc.count(ro(t), t) + (ro(t).getDay() === 4), e, 2);
}
function aoe(t) {
  return t.getDay();
}
function ioe(t, e) {
  return nr(nm.count(ro(t) - 1, t), e, 2);
}
function soe(t, e) {
  return nr(t.getFullYear() % 100, e, 2);
}
function ooe(t, e) {
  return t = s9(t), nr(t.getFullYear() % 100, e, 2);
}
function loe(t, e) {
  return nr(t.getFullYear() % 1e4, e, 4);
}
function uoe(t, e) {
  var r = t.getDay();
  return t = r >= 4 || r === 0 ? Qc(t) : Qc.ceil(t), nr(t.getFullYear() % 1e4, e, 4);
}
function coe(t) {
  var e = t.getTimezoneOffset();
  return (e > 0 ? "-" : (e *= -1, "+")) + nr(e / 60 | 0, "0", 2) + nr(e % 60, "0", 2);
}
function cR(t, e) {
  return nr(t.getUTCDate(), e, 2);
}
function foe(t, e) {
  return nr(t.getUTCHours(), e, 2);
}
function hoe(t, e) {
  return nr(t.getUTCHours() % 12 || 12, e, 2);
}
function doe(t, e) {
  return nr(1 + y5.count(Ql(t), t), e, 3);
}
function o9(t, e) {
  return nr(t.getUTCMilliseconds(), e, 3);
}
function poe(t, e) {
  return o9(t, e) + "000";
}
function goe(t, e) {
  return nr(t.getUTCMonth() + 1, e, 2);
}
function voe(t, e) {
  return nr(t.getUTCMinutes(), e, 2);
}
function moe(t, e) {
  return nr(t.getUTCSeconds(), e, 2);
}
function yoe(t) {
  var e = t.getUTCDay();
  return e === 0 ? 7 : e;
}
function boe(t, e) {
  return nr(a9.count(Ql(t) - 1, t), e, 2);
}
function l9(t) {
  var e = t.getUTCDay();
  return e >= 4 || e === 0 ? Jc(t) : Jc.ceil(t);
}
function xoe(t, e) {
  return t = l9(t), nr(Jc.count(Ql(t), t) + (Ql(t).getUTCDay() === 4), e, 2);
}
function woe(t) {
  return t.getUTCDay();
}
function Eoe(t, e) {
  return nr(am.count(Ql(t) - 1, t), e, 2);
}
function Toe(t, e) {
  return nr(t.getUTCFullYear() % 100, e, 2);
}
function Soe(t, e) {
  return t = l9(t), nr(t.getUTCFullYear() % 100, e, 2);
}
function Coe(t, e) {
  return nr(t.getUTCFullYear() % 1e4, e, 4);
}
function Aoe(t, e) {
  var r = t.getUTCDay();
  return t = r >= 4 || r === 0 ? Jc(t) : Jc.ceil(t), nr(t.getUTCFullYear() % 1e4, e, 4);
}
function koe() {
  return "+0000";
}
function fR() {
  return "%";
}
function hR(t) {
  return +t;
}
function dR(t) {
  return Math.floor(+t / 1e3);
}
var Bu, u9;
Roe({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function Roe(t) {
  return Bu = Rse(t), u9 = Bu.format, Bu.parse, Bu.utcFormat, Bu.utcParse, Bu;
}
function Moe(t) {
  return new Date(t);
}
function _oe(t) {
  return t instanceof Date ? +t : +/* @__PURE__ */ new Date(+t);
}
function c9(t, e, r, n, a, i, s, o, l, u) {
  var c = n9(), f = c.invert, h = c.domain, d = u(".%L"), p = u(":%S"), g = u("%I:%M"), v = u("%I %p"), m = u("%a %d"), b = u("%b %d"), y = u("%B"), x = u("%Y");
  function E(S) {
    return (l(S) < S ? d : o(S) < S ? p : s(S) < S ? g : i(S) < S ? v : n(S) < S ? a(S) < S ? m : b : r(S) < S ? y : x)(S);
  }
  return c.invert = function(S) {
    return new Date(f(S));
  }, c.domain = function(S) {
    return arguments.length ? h(Array.from(S, _oe)) : h().map(Moe);
  }, c.ticks = function(S) {
    var w = h();
    return t(w[0], w[w.length - 1], S ?? 10);
  }, c.tickFormat = function(S, w) {
    return w == null ? E : u(w);
  }, c.nice = function(S) {
    var w = h();
    return (!S || typeof S.range != "function") && (S = e(w[0], w[w.length - 1], S ?? 10)), S ? h(hse(w, S)) : c;
  }, c.copy = function() {
    return r9(c, c9(t, e, r, n, a, i, s, o, l, u));
  }, c;
}
function o_e() {
  return c1.apply(c9(Ase, kse, ro, b5, f1, U0, m5, v5, sc, u9).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
function Loe(t) {
  for (var e = t.length / 6 | 0, r = new Array(e), n = 0; n < e; ) r[n] = "#" + t.slice(n * 6, ++n * 6);
  return r;
}
const l_e = Loe("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");
function en(t) {
  return function() {
    return t;
  };
}
const pR = Math.abs, jn = Math.atan2, Tl = Math.cos, Noe = Math.max, dx = Math.min, ts = Math.sin, oc = Math.sqrt, Xn = 1e-12, Xd = Math.PI, im = Xd / 2, ov = 2 * Xd;
function Ooe(t) {
  return t > 1 ? 0 : t < -1 ? Xd : Math.acos(t);
}
function gR(t) {
  return t >= 1 ? im : t <= -1 ? -im : Math.asin(t);
}
function f9(t) {
  let e = 3;
  return t.digits = function(r) {
    if (!arguments.length) return e;
    if (r == null)
      e = null;
    else {
      const n = Math.floor(r);
      if (!(n >= 0)) throw new RangeError(`invalid digits: ${r}`);
      e = n;
    }
    return t;
  }, () => new mie(e);
}
function Ioe(t) {
  return t.innerRadius;
}
function Poe(t) {
  return t.outerRadius;
}
function Doe(t) {
  return t.startAngle;
}
function $oe(t) {
  return t.endAngle;
}
function Foe(t) {
  return t && t.padAngle;
}
function Boe(t, e, r, n, a, i, s, o) {
  var l = r - t, u = n - e, c = s - a, f = o - i, h = f * l - c * u;
  if (!(h * h < Xn))
    return h = (c * (e - i) - f * (t - a)) / h, [t + h * l, e + h * u];
}
function Gp(t, e, r, n, a, i, s) {
  var o = t - r, l = e - n, u = (s ? i : -i) / oc(o * o + l * l), c = u * l, f = -u * o, h = t + c, d = e + f, p = r + c, g = n + f, v = (h + p) / 2, m = (d + g) / 2, b = p - h, y = g - d, x = b * b + y * y, E = a - i, S = h * g - p * d, w = (y < 0 ? -1 : 1) * oc(Noe(0, E * E * x - S * S)), C = (S * y - b * w) / x, k = (-S * b - y * w) / x, N = (S * y + b * w) / x, R = (-S * b + y * w) / x, _ = C - v, O = k - m, T = N - v, L = R - m;
  return _ * _ + O * O > T * T + L * L && (C = N, k = R), {
    cx: C,
    cy: k,
    x01: -c,
    y01: -f,
    x11: C * (a / E - 1),
    y11: k * (a / E - 1)
  };
}
function u_e() {
  var t = Ioe, e = Poe, r = en(0), n = null, a = Doe, i = $oe, s = Foe, o = null, l = f9(u);
  function u() {
    var c, f, h = +t.apply(this, arguments), d = +e.apply(this, arguments), p = a.apply(this, arguments) - im, g = i.apply(this, arguments) - im, v = pR(g - p), m = g > p;
    if (o || (o = c = l()), d < h && (f = d, d = h, h = f), !(d > Xn)) o.moveTo(0, 0);
    else if (v > ov - Xn)
      o.moveTo(d * Tl(p), d * ts(p)), o.arc(0, 0, d, p, g, !m), h > Xn && (o.moveTo(h * Tl(g), h * ts(g)), o.arc(0, 0, h, g, p, m));
    else {
      var b = p, y = g, x = p, E = g, S = v, w = v, C = s.apply(this, arguments) / 2, k = C > Xn && (n ? +n.apply(this, arguments) : oc(h * h + d * d)), N = dx(pR(d - h) / 2, +r.apply(this, arguments)), R = N, _ = N, O, T;
      if (k > Xn) {
        var L = gR(k / h * ts(C)), M = gR(k / d * ts(C));
        (S -= L * 2) > Xn ? (L *= m ? 1 : -1, x += L, E -= L) : (S = 0, x = E = (p + g) / 2), (w -= M * 2) > Xn ? (M *= m ? 1 : -1, b += M, y -= M) : (w = 0, b = y = (p + g) / 2);
      }
      var A = d * Tl(b), I = d * ts(b), D = h * Tl(E), F = h * ts(E);
      if (N > Xn) {
        var B = d * Tl(y), G = d * ts(y), H = h * Tl(x), K = h * ts(x), j;
        if (v < Xd)
          if (j = Boe(A, I, H, K, B, G, D, F)) {
            var Z = A - j[0], te = I - j[1], ne = B - j[0], V = G - j[1], q = 1 / ts(Ooe((Z * ne + te * V) / (oc(Z * Z + te * te) * oc(ne * ne + V * V))) / 2), X = oc(j[0] * j[0] + j[1] * j[1]);
            R = dx(N, (h - X) / (q - 1)), _ = dx(N, (d - X) / (q + 1));
          } else
            R = _ = 0;
      }
      w > Xn ? _ > Xn ? (O = Gp(H, K, A, I, d, _, m), T = Gp(B, G, D, F, d, _, m), o.moveTo(O.cx + O.x01, O.cy + O.y01), _ < N ? o.arc(O.cx, O.cy, _, jn(O.y01, O.x01), jn(T.y01, T.x01), !m) : (o.arc(O.cx, O.cy, _, jn(O.y01, O.x01), jn(O.y11, O.x11), !m), o.arc(0, 0, d, jn(O.cy + O.y11, O.cx + O.x11), jn(T.cy + T.y11, T.cx + T.x11), !m), o.arc(T.cx, T.cy, _, jn(T.y11, T.x11), jn(T.y01, T.x01), !m))) : (o.moveTo(A, I), o.arc(0, 0, d, b, y, !m)) : o.moveTo(A, I), !(h > Xn) || !(S > Xn) ? o.lineTo(D, F) : R > Xn ? (O = Gp(D, F, B, G, h, -R, m), T = Gp(A, I, H, K, h, -R, m), o.lineTo(O.cx + O.x01, O.cy + O.y01), R < N ? o.arc(O.cx, O.cy, R, jn(O.y01, O.x01), jn(T.y01, T.x01), !m) : (o.arc(O.cx, O.cy, R, jn(O.y01, O.x01), jn(O.y11, O.x11), !m), o.arc(0, 0, h, jn(O.cy + O.y11, O.cx + O.x11), jn(T.cy + T.y11, T.cx + T.x11), m), o.arc(T.cx, T.cy, R, jn(T.y11, T.x11), jn(T.y01, T.x01), !m))) : o.arc(0, 0, h, E, x, m);
    }
    if (o.closePath(), c) return o = null, c + "" || null;
  }
  return u.centroid = function() {
    var c = (+t.apply(this, arguments) + +e.apply(this, arguments)) / 2, f = (+a.apply(this, arguments) + +i.apply(this, arguments)) / 2 - Xd / 2;
    return [Tl(f) * c, ts(f) * c];
  }, u.innerRadius = function(c) {
    return arguments.length ? (t = typeof c == "function" ? c : en(+c), u) : t;
  }, u.outerRadius = function(c) {
    return arguments.length ? (e = typeof c == "function" ? c : en(+c), u) : e;
  }, u.cornerRadius = function(c) {
    return arguments.length ? (r = typeof c == "function" ? c : en(+c), u) : r;
  }, u.padRadius = function(c) {
    return arguments.length ? (n = c == null ? null : typeof c == "function" ? c : en(+c), u) : n;
  }, u.startAngle = function(c) {
    return arguments.length ? (a = typeof c == "function" ? c : en(+c), u) : a;
  }, u.endAngle = function(c) {
    return arguments.length ? (i = typeof c == "function" ? c : en(+c), u) : i;
  }, u.padAngle = function(c) {
    return arguments.length ? (s = typeof c == "function" ? c : en(+c), u) : s;
  }, u.context = function(c) {
    return arguments.length ? (o = c ?? null, u) : o;
  }, u;
}
function h9(t) {
  return typeof t == "object" && "length" in t ? t : Array.from(t);
}
function d9(t) {
  this._context = t;
}
d9.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t, e) {
    switch (t = +t, e = +e, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(t, e);
        break;
    }
  }
};
function zoe(t) {
  return new d9(t);
}
function Goe(t) {
  return t[0];
}
function Uoe(t) {
  return t[1];
}
function c_e(t, e) {
  var r = en(!0), n = null, a = zoe, i = null, s = f9(o);
  t = typeof t == "function" ? t : t === void 0 ? Goe : en(t), e = typeof e == "function" ? e : e === void 0 ? Uoe : en(e);
  function o(l) {
    var u, c = (l = h9(l)).length, f, h = !1, d;
    for (n == null && (i = a(d = s())), u = 0; u <= c; ++u)
      !(u < c && r(f = l[u], u, l)) === h && ((h = !h) ? i.lineStart() : i.lineEnd()), h && i.point(+t(f, u, l), +e(f, u, l));
    if (d) return i = null, d + "" || null;
  }
  return o.x = function(l) {
    return arguments.length ? (t = typeof l == "function" ? l : en(+l), o) : t;
  }, o.y = function(l) {
    return arguments.length ? (e = typeof l == "function" ? l : en(+l), o) : e;
  }, o.defined = function(l) {
    return arguments.length ? (r = typeof l == "function" ? l : en(!!l), o) : r;
  }, o.curve = function(l) {
    return arguments.length ? (a = l, n != null && (i = a(n)), o) : a;
  }, o.context = function(l) {
    return arguments.length ? (l == null ? n = i = null : i = a(n = l), o) : n;
  }, o;
}
function Hoe(t, e) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function Voe(t) {
  return t;
}
function f_e() {
  var t = Voe, e = Hoe, r = null, n = en(0), a = en(ov), i = en(0);
  function s(o) {
    var l, u = (o = h9(o)).length, c, f, h = 0, d = new Array(u), p = new Array(u), g = +n.apply(this, arguments), v = Math.min(ov, Math.max(-ov, a.apply(this, arguments) - g)), m, b = Math.min(Math.abs(v) / u, i.apply(this, arguments)), y = b * (v < 0 ? -1 : 1), x;
    for (l = 0; l < u; ++l)
      (x = p[d[l] = l] = +t(o[l], l, o)) > 0 && (h += x);
    for (e != null ? d.sort(function(E, S) {
      return e(p[E], p[S]);
    }) : r != null && d.sort(function(E, S) {
      return r(o[E], o[S]);
    }), l = 0, f = h ? (v - u * y) / h : 0; l < u; ++l, g = m)
      c = d[l], x = p[c], m = g + (x > 0 ? x * f : 0) + y, p[c] = {
        data: o[c],
        index: l,
        value: x,
        startAngle: g,
        endAngle: m,
        padAngle: b
      };
    return p;
  }
  return s.value = function(o) {
    return arguments.length ? (t = typeof o == "function" ? o : en(+o), s) : t;
  }, s.sortValues = function(o) {
    return arguments.length ? (e = o, r = null, s) : e;
  }, s.sort = function(o) {
    return arguments.length ? (r = o, e = null, s) : r;
  }, s.startAngle = function(o) {
    return arguments.length ? (n = typeof o == "function" ? o : en(+o), s) : n;
  }, s.endAngle = function(o) {
    return arguments.length ? (a = typeof o == "function" ? o : en(+o), s) : a;
  }, s.padAngle = function(o) {
    return arguments.length ? (i = typeof o == "function" ? o : en(+o), s) : i;
  }, s;
}
class p9 {
  constructor(e, r) {
    this._context = e, this._x = r;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  }
  point(e, r) {
    switch (e = +e, r = +r, this._point) {
      case 0: {
        this._point = 1, this._line ? this._context.lineTo(e, r) : this._context.moveTo(e, r);
        break;
      }
      case 1:
        this._point = 2;
      default: {
        this._x ? this._context.bezierCurveTo(this._x0 = (this._x0 + e) / 2, this._y0, this._x0, r, e, r) : this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + r) / 2, e, this._y0, e, r);
        break;
      }
    }
    this._x0 = e, this._y0 = r;
  }
}
function h_e(t) {
  return new p9(t, !0);
}
function d_e(t) {
  return new p9(t, !1);
}
function zo() {
}
function sm(t, e, r) {
  t._context.bezierCurveTo(
    (2 * t._x0 + t._x1) / 3,
    (2 * t._y0 + t._y1) / 3,
    (t._x0 + 2 * t._x1) / 3,
    (t._y0 + 2 * t._y1) / 3,
    (t._x0 + 4 * t._x1 + e) / 6,
    (t._y0 + 4 * t._y1 + r) / 6
  );
}
function h1(t) {
  this._context = t;
}
h1.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        sm(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t, e) {
    switch (t = +t, e = +e, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        sm(this, t, e);
        break;
    }
    this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = e;
  }
};
function p_e(t) {
  return new h1(t);
}
function g9(t) {
  this._context = t;
}
g9.prototype = {
  areaStart: zo,
  areaEnd: zo,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2), this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(t, e) {
    switch (t = +t, e = +e, this._point) {
      case 0:
        this._point = 1, this._x2 = t, this._y2 = e;
        break;
      case 1:
        this._point = 2, this._x3 = t, this._y3 = e;
        break;
      case 2:
        this._point = 3, this._x4 = t, this._y4 = e, this._context.moveTo((this._x0 + 4 * this._x1 + t) / 6, (this._y0 + 4 * this._y1 + e) / 6);
        break;
      default:
        sm(this, t, e);
        break;
    }
    this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = e;
  }
};
function g_e(t) {
  return new g9(t);
}
function v9(t) {
  this._context = t;
}
v9.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t, e) {
    switch (t = +t, e = +e, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var r = (this._x0 + 4 * this._x1 + t) / 6, n = (this._y0 + 4 * this._y1 + e) / 6;
        this._line ? this._context.lineTo(r, n) : this._context.moveTo(r, n);
        break;
      case 3:
        this._point = 4;
      default:
        sm(this, t, e);
        break;
    }
    this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = e;
  }
};
function v_e(t) {
  return new v9(t);
}
function m9(t, e) {
  this._basis = new h1(t), this._beta = e;
}
m9.prototype = {
  lineStart: function() {
    this._x = [], this._y = [], this._basis.lineStart();
  },
  lineEnd: function() {
    var t = this._x, e = this._y, r = t.length - 1;
    if (r > 0)
      for (var n = t[0], a = e[0], i = t[r] - n, s = e[r] - a, o = -1, l; ++o <= r; )
        l = o / r, this._basis.point(
          this._beta * t[o] + (1 - this._beta) * (n + l * i),
          this._beta * e[o] + (1 - this._beta) * (a + l * s)
        );
    this._x = this._y = null, this._basis.lineEnd();
  },
  point: function(t, e) {
    this._x.push(+t), this._y.push(+e);
  }
};
const m_e = function t(e) {
  function r(n) {
    return e === 1 ? new h1(n) : new m9(n, e);
  }
  return r.beta = function(n) {
    return t(+n);
  }, r;
}(0.85);
function om(t, e, r) {
  t._context.bezierCurveTo(
    t._x1 + t._k * (t._x2 - t._x0),
    t._y1 + t._k * (t._y2 - t._y0),
    t._x2 + t._k * (t._x1 - e),
    t._y2 + t._k * (t._y1 - r),
    t._x2,
    t._y2
  );
}
function x5(t, e) {
  this._context = t, this._k = (1 - e) / 6;
}
x5.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        om(this, this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t, e) {
    switch (t = +t, e = +e, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e);
        break;
      case 1:
        this._point = 2, this._x1 = t, this._y1 = e;
        break;
      case 2:
        this._point = 3;
      default:
        om(this, t, e);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
  }
};
const y_e = function t(e) {
  function r(n) {
    return new x5(n, e);
  }
  return r.tension = function(n) {
    return t(+n);
  }, r;
}(0);
function w5(t, e) {
  this._context = t, this._k = (1 - e) / 6;
}
w5.prototype = {
  areaStart: zo,
  areaEnd: zo,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(t, e) {
    switch (t = +t, e = +e, this._point) {
      case 0:
        this._point = 1, this._x3 = t, this._y3 = e;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = t, this._y4 = e);
        break;
      case 2:
        this._point = 3, this._x5 = t, this._y5 = e;
        break;
      default:
        om(this, t, e);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
  }
};
const b_e = function t(e) {
  function r(n) {
    return new w5(n, e);
  }
  return r.tension = function(n) {
    return t(+n);
  }, r;
}(0);
function E5(t, e) {
  this._context = t, this._k = (1 - e) / 6;
}
E5.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t, e) {
    switch (t = +t, e = +e, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        om(this, t, e);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
  }
};
const x_e = function t(e) {
  function r(n) {
    return new E5(n, e);
  }
  return r.tension = function(n) {
    return t(+n);
  }, r;
}(0);
function T5(t, e, r) {
  var n = t._x1, a = t._y1, i = t._x2, s = t._y2;
  if (t._l01_a > Xn) {
    var o = 2 * t._l01_2a + 3 * t._l01_a * t._l12_a + t._l12_2a, l = 3 * t._l01_a * (t._l01_a + t._l12_a);
    n = (n * o - t._x0 * t._l12_2a + t._x2 * t._l01_2a) / l, a = (a * o - t._y0 * t._l12_2a + t._y2 * t._l01_2a) / l;
  }
  if (t._l23_a > Xn) {
    var u = 2 * t._l23_2a + 3 * t._l23_a * t._l12_a + t._l12_2a, c = 3 * t._l23_a * (t._l23_a + t._l12_a);
    i = (i * u + t._x1 * t._l23_2a - e * t._l12_2a) / c, s = (s * u + t._y1 * t._l23_2a - r * t._l12_2a) / c;
  }
  t._context.bezierCurveTo(n, a, i, s, t._x2, t._y2);
}
function y9(t, e) {
  this._context = t, this._alpha = e;
}
y9.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t, e) {
    if (t = +t, e = +e, this._point) {
      var r = this._x2 - t, n = this._y2 - e;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(r * r + n * n, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        T5(this, t, e);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
  }
};
const w_e = function t(e) {
  function r(n) {
    return e ? new y9(n, e) : new x5(n, 0);
  }
  return r.alpha = function(n) {
    return t(+n);
  }, r;
}(0.5);
function b9(t, e) {
  this._context = t, this._alpha = e;
}
b9.prototype = {
  areaStart: zo,
  areaEnd: zo,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(t, e) {
    if (t = +t, e = +e, this._point) {
      var r = this._x2 - t, n = this._y2 - e;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(r * r + n * n, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._x3 = t, this._y3 = e;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = t, this._y4 = e);
        break;
      case 2:
        this._point = 3, this._x5 = t, this._y5 = e;
        break;
      default:
        T5(this, t, e);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
  }
};
const E_e = function t(e) {
  function r(n) {
    return e ? new b9(n, e) : new w5(n, 0);
  }
  return r.alpha = function(n) {
    return t(+n);
  }, r;
}(0.5);
function x9(t, e) {
  this._context = t, this._alpha = e;
}
x9.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t, e) {
    if (t = +t, e = +e, this._point) {
      var r = this._x2 - t, n = this._y2 - e;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(r * r + n * n, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        T5(this, t, e);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
  }
};
const T_e = function t(e) {
  function r(n) {
    return e ? new x9(n, e) : new E5(n, 0);
  }
  return r.alpha = function(n) {
    return t(+n);
  }, r;
}(0.5);
function w9(t) {
  this._context = t;
}
w9.prototype = {
  areaStart: zo,
  areaEnd: zo,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    this._point && this._context.closePath();
  },
  point: function(t, e) {
    t = +t, e = +e, this._point ? this._context.lineTo(t, e) : (this._point = 1, this._context.moveTo(t, e));
  }
};
function S_e(t) {
  return new w9(t);
}
function vR(t) {
  return t < 0 ? -1 : 1;
}
function mR(t, e, r) {
  var n = t._x1 - t._x0, a = e - t._x1, i = (t._y1 - t._y0) / (n || a < 0 && -0), s = (r - t._y1) / (a || n < 0 && -0), o = (i * a + s * n) / (n + a);
  return (vR(i) + vR(s)) * Math.min(Math.abs(i), Math.abs(s), 0.5 * Math.abs(o)) || 0;
}
function yR(t, e) {
  var r = t._x1 - t._x0;
  return r ? (3 * (t._y1 - t._y0) / r - e) / 2 : e;
}
function px(t, e, r) {
  var n = t._x0, a = t._y0, i = t._x1, s = t._y1, o = (i - n) / 3;
  t._context.bezierCurveTo(n + o, a + o * e, i - o, s - o * r, i, s);
}
function lm(t) {
  this._context = t;
}
lm.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        px(this, this._t0, yR(this, this._t0));
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t, e) {
    var r = NaN;
    if (t = +t, e = +e, !(t === this._x1 && e === this._y1)) {
      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, px(this, yR(this, r = mR(this, t, e)), r);
          break;
        default:
          px(this, this._t0, r = mR(this, t, e));
          break;
      }
      this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = e, this._t0 = r;
    }
  }
};
function E9(t) {
  this._context = new T9(t);
}
(E9.prototype = Object.create(lm.prototype)).point = function(t, e) {
  lm.prototype.point.call(this, e, t);
};
function T9(t) {
  this._context = t;
}
T9.prototype = {
  moveTo: function(t, e) {
    this._context.moveTo(e, t);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(t, e) {
    this._context.lineTo(e, t);
  },
  bezierCurveTo: function(t, e, r, n, a, i) {
    this._context.bezierCurveTo(e, t, n, r, i, a);
  }
};
function C_e(t) {
  return new lm(t);
}
function A_e(t) {
  return new E9(t);
}
function S9(t) {
  this._context = t;
}
S9.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [], this._y = [];
  },
  lineEnd: function() {
    var t = this._x, e = this._y, r = t.length;
    if (r)
      if (this._line ? this._context.lineTo(t[0], e[0]) : this._context.moveTo(t[0], e[0]), r === 2)
        this._context.lineTo(t[1], e[1]);
      else
        for (var n = bR(t), a = bR(e), i = 0, s = 1; s < r; ++i, ++s)
          this._context.bezierCurveTo(n[0][i], a[0][i], n[1][i], a[1][i], t[s], e[s]);
    (this._line || this._line !== 0 && r === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null;
  },
  point: function(t, e) {
    this._x.push(+t), this._y.push(+e);
  }
};
function bR(t) {
  var e, r = t.length - 1, n, a = new Array(r), i = new Array(r), s = new Array(r);
  for (a[0] = 0, i[0] = 2, s[0] = t[0] + 2 * t[1], e = 1; e < r - 1; ++e) a[e] = 1, i[e] = 4, s[e] = 4 * t[e] + 2 * t[e + 1];
  for (a[r - 1] = 2, i[r - 1] = 7, s[r - 1] = 8 * t[r - 1] + t[r], e = 1; e < r; ++e) n = a[e] / i[e - 1], i[e] -= n, s[e] -= n * s[e - 1];
  for (a[r - 1] = s[r - 1] / i[r - 1], e = r - 2; e >= 0; --e) a[e] = (s[e] - a[e + 1]) / i[e];
  for (i[r - 1] = (t[r] + a[r - 1]) / 2, e = 0; e < r - 1; ++e) i[e] = 2 * t[e + 1] - a[e + 1];
  return [a, i];
}
function k_e(t) {
  return new S9(t);
}
function d1(t, e) {
  this._context = t, this._t = e;
}
d1.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN, this._point = 0;
  },
  lineEnd: function() {
    0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
  },
  point: function(t, e) {
    switch (t = +t, e = +e, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0)
          this._context.lineTo(this._x, e), this._context.lineTo(t, e);
        else {
          var r = this._x * (1 - this._t) + t * this._t;
          this._context.lineTo(r, this._y), this._context.lineTo(r, e);
        }
        break;
      }
    }
    this._x = t, this._y = e;
  }
};
function R_e(t) {
  return new d1(t, 0.5);
}
function M_e(t) {
  return new d1(t, 0);
}
function __e(t) {
  return new d1(t, 1);
}
function Sh(t, e, r) {
  this.k = t, this.x = e, this.y = r;
}
Sh.prototype = {
  constructor: Sh,
  scale: function(t) {
    return t === 1 ? this : new Sh(this.k * t, this.x, this.y);
  },
  translate: function(t, e) {
    return t === 0 & e === 0 ? this : new Sh(this.k, this.x + this.k * t, this.y + this.k * e);
  },
  apply: function(t) {
    return [t[0] * this.k + this.x, t[1] * this.k + this.y];
  },
  applyX: function(t) {
    return t * this.k + this.x;
  },
  applyY: function(t) {
    return t * this.k + this.y;
  },
  invert: function(t) {
    return [(t[0] - this.x) / this.k, (t[1] - this.y) / this.k];
  },
  invertX: function(t) {
    return (t - this.x) / this.k;
  },
  invertY: function(t) {
    return (t - this.y) / this.k;
  },
  rescaleX: function(t) {
    return t.copy().domain(t.range().map(this.invertX, this).map(t.invert, t));
  },
  rescaleY: function(t) {
    return t.copy().domain(t.range().map(this.invertY, this).map(t.invert, t));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
Sh.prototype;
var S5 = {}, An = {};
Object.defineProperty(An, "__esModule", { value: !0 });
An.BLANK_URL = An.relativeFirstCharacters = An.whitespaceEscapeCharsRegex = An.urlSchemeRegex = An.ctrlCharactersRegex = An.htmlCtrlEntityRegex = An.htmlEntitiesRegex = An.invalidProtocolRegex = void 0;
An.invalidProtocolRegex = /^([^\w]*)(javascript|data|vbscript)/im;
An.htmlEntitiesRegex = /&#(\w+)(^\w|;)?/g;
An.htmlCtrlEntityRegex = /&(newline|tab);/gi;
An.ctrlCharactersRegex = /[\u0000-\u001F\u007F-\u009F\u2000-\u200D\uFEFF]/gim;
An.urlSchemeRegex = /^.+(:|&colon;)/gim;
An.whitespaceEscapeCharsRegex = /(\\|%5[cC])((%(6[eE]|72|74))|[nrt])/g;
An.relativeFirstCharacters = [".", "/"];
An.BLANK_URL = "about:blank";
Object.defineProperty(S5, "__esModule", { value: !0 });
var qoe = S5.sanitizeUrl = void 0, Kn = An;
function Woe(t) {
  return Kn.relativeFirstCharacters.indexOf(t[0]) > -1;
}
function joe(t) {
  var e = t.replace(Kn.ctrlCharactersRegex, "");
  return e.replace(Kn.htmlEntitiesRegex, function(r, n) {
    return String.fromCharCode(n);
  });
}
function Yoe(t) {
  return URL.canParse(t);
}
function xR(t) {
  try {
    return decodeURIComponent(t);
  } catch {
    return t;
  }
}
function Xoe(t) {
  if (!t)
    return Kn.BLANK_URL;
  var e, r = xR(t.trim());
  do
    r = joe(r).replace(Kn.htmlCtrlEntityRegex, "").replace(Kn.ctrlCharactersRegex, "").replace(Kn.whitespaceEscapeCharsRegex, "").trim(), r = xR(r), e = r.match(Kn.ctrlCharactersRegex) || r.match(Kn.htmlEntitiesRegex) || r.match(Kn.htmlCtrlEntityRegex) || r.match(Kn.whitespaceEscapeCharsRegex);
  while (e && e.length > 0);
  var n = r;
  if (!n)
    return Kn.BLANK_URL;
  if (Woe(n))
    return n;
  var a = n.trimStart(), i = a.match(Kn.urlSchemeRegex);
  if (!i)
    return n;
  var s = i[0].toLowerCase().trim();
  if (Kn.invalidProtocolRegex.test(s))
    return Kn.BLANK_URL;
  var o = a.replace(/\\/g, "/");
  if (s === "mailto:" || s.includes("://"))
    return o;
  if (s === "http:" || s === "https:") {
    if (!Yoe(o))
      return Kn.BLANK_URL;
    var l = new URL(o);
    return l.protocol = l.protocol.toLowerCase(), l.hostname = l.hostname.toLowerCase(), l.toString();
  }
  return o;
}
qoe = S5.sanitizeUrl = Xoe;
var C9 = typeof global == "object" && global && global.Object === Object && global, Koe = typeof self == "object" && self && self.Object === Object && self, ws = C9 || Koe || Function("return this")(), bi = ws.Symbol, A9 = Object.prototype, Zoe = A9.hasOwnProperty, Qoe = A9.toString, nh = bi ? bi.toStringTag : void 0;
function Joe(t) {
  var e = Zoe.call(t, nh), r = t[nh];
  try {
    t[nh] = void 0;
    var n = !0;
  } catch {
  }
  var a = Qoe.call(t);
  return n && (e ? t[nh] = r : delete t[nh]), a;
}
var ele = Object.prototype, tle = ele.toString;
function rle(t) {
  return tle.call(t);
}
var nle = "[object Null]", ale = "[object Undefined]", wR = bi ? bi.toStringTag : void 0;
function vo(t) {
  return t == null ? t === void 0 ? ale : nle : wR && wR in Object(t) ? Joe(t) : rle(t);
}
function Ma(t) {
  var e = typeof t;
  return t != null && (e == "object" || e == "function");
}
var ile = "[object AsyncFunction]", sle = "[object Function]", ole = "[object GeneratorFunction]", lle = "[object Proxy]";
function xi(t) {
  if (!Ma(t))
    return !1;
  var e = vo(t);
  return e == sle || e == ole || e == ile || e == lle;
}
var gx = ws["__core-js_shared__"], ER = function() {
  var t = /[^.]+$/.exec(gx && gx.keys && gx.keys.IE_PROTO || "");
  return t ? "Symbol(src)_1." + t : "";
}();
function ule(t) {
  return !!ER && ER in t;
}
var cle = Function.prototype, fle = cle.toString;
function xu(t) {
  if (t != null) {
    try {
      return fle.call(t);
    } catch {
    }
    try {
      return t + "";
    } catch {
    }
  }
  return "";
}
var hle = /[\\^$.*+?()[\]{}|]/g, dle = /^\[object .+?Constructor\]$/, ple = Function.prototype, gle = Object.prototype, vle = ple.toString, mle = gle.hasOwnProperty, yle = RegExp(
  "^" + vle.call(mle).replace(hle, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function ble(t) {
  if (!Ma(t) || ule(t))
    return !1;
  var e = xi(t) ? yle : dle;
  return e.test(xu(t));
}
function xle(t, e) {
  return t == null ? void 0 : t[e];
}
function wu(t, e) {
  var r = xle(t, e);
  return ble(r) ? r : void 0;
}
var Kd = wu(Object, "create");
function wle() {
  this.__data__ = Kd ? Kd(null) : {}, this.size = 0;
}
function Ele(t) {
  var e = this.has(t) && delete this.__data__[t];
  return this.size -= e ? 1 : 0, e;
}
var Tle = "__lodash_hash_undefined__", Sle = Object.prototype, Cle = Sle.hasOwnProperty;
function Ale(t) {
  var e = this.__data__;
  if (Kd) {
    var r = e[t];
    return r === Tle ? void 0 : r;
  }
  return Cle.call(e, t) ? e[t] : void 0;
}
var kle = Object.prototype, Rle = kle.hasOwnProperty;
function Mle(t) {
  var e = this.__data__;
  return Kd ? e[t] !== void 0 : Rle.call(e, t);
}
var _le = "__lodash_hash_undefined__";
function Lle(t, e) {
  var r = this.__data__;
  return this.size += this.has(t) ? 0 : 1, r[t] = Kd && e === void 0 ? _le : e, this;
}
function Jl(t) {
  var e = -1, r = t == null ? 0 : t.length;
  for (this.clear(); ++e < r; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
Jl.prototype.clear = wle;
Jl.prototype.delete = Ele;
Jl.prototype.get = Ale;
Jl.prototype.has = Mle;
Jl.prototype.set = Lle;
function Nle() {
  this.__data__ = [], this.size = 0;
}
function Ef(t, e) {
  return t === e || t !== t && e !== e;
}
function p1(t, e) {
  for (var r = t.length; r--; )
    if (Ef(t[r][0], e))
      return r;
  return -1;
}
var Ole = Array.prototype, Ile = Ole.splice;
function Ple(t) {
  var e = this.__data__, r = p1(e, t);
  if (r < 0)
    return !1;
  var n = e.length - 1;
  return r == n ? e.pop() : Ile.call(e, r, 1), --this.size, !0;
}
function Dle(t) {
  var e = this.__data__, r = p1(e, t);
  return r < 0 ? void 0 : e[r][1];
}
function $le(t) {
  return p1(this.__data__, t) > -1;
}
function Fle(t, e) {
  var r = this.__data__, n = p1(r, t);
  return n < 0 ? (++this.size, r.push([t, e])) : r[n][1] = e, this;
}
function mo(t) {
  var e = -1, r = t == null ? 0 : t.length;
  for (this.clear(); ++e < r; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
mo.prototype.clear = Nle;
mo.prototype.delete = Ple;
mo.prototype.get = Dle;
mo.prototype.has = $le;
mo.prototype.set = Fle;
var Zd = wu(ws, "Map");
function Ble() {
  this.size = 0, this.__data__ = {
    hash: new Jl(),
    map: new (Zd || mo)(),
    string: new Jl()
  };
}
function zle(t) {
  var e = typeof t;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null;
}
function g1(t, e) {
  var r = t.__data__;
  return zle(e) ? r[typeof e == "string" ? "string" : "hash"] : r.map;
}
function Gle(t) {
  var e = g1(this, t).delete(t);
  return this.size -= e ? 1 : 0, e;
}
function Ule(t) {
  return g1(this, t).get(t);
}
function Hle(t) {
  return g1(this, t).has(t);
}
function Vle(t, e) {
  var r = g1(this, t), n = r.size;
  return r.set(t, e), this.size += r.size == n ? 0 : 1, this;
}
function yo(t) {
  var e = -1, r = t == null ? 0 : t.length;
  for (this.clear(); ++e < r; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
yo.prototype.clear = Ble;
yo.prototype.delete = Gle;
yo.prototype.get = Ule;
yo.prototype.has = Hle;
yo.prototype.set = Vle;
var qle = "Expected a function";
function C5(t, e) {
  if (typeof t != "function" || e != null && typeof e != "function")
    throw new TypeError(qle);
  var r = function() {
    var n = arguments, a = e ? e.apply(this, n) : n[0], i = r.cache;
    if (i.has(a))
      return i.get(a);
    var s = t.apply(this, n);
    return r.cache = i.set(a, s) || i, s;
  };
  return r.cache = new (C5.Cache || yo)(), r;
}
C5.Cache = yo;
function Wle() {
  this.__data__ = new mo(), this.size = 0;
}
function jle(t) {
  var e = this.__data__, r = e.delete(t);
  return this.size = e.size, r;
}
function Yle(t) {
  return this.__data__.get(t);
}
function Xle(t) {
  return this.__data__.has(t);
}
var Kle = 200;
function Zle(t, e) {
  var r = this.__data__;
  if (r instanceof mo) {
    var n = r.__data__;
    if (!Zd || n.length < Kle - 1)
      return n.push([t, e]), this.size = ++r.size, this;
    r = this.__data__ = new yo(n);
  }
  return r.set(t, e), this.size = r.size, this;
}
function Ui(t) {
  var e = this.__data__ = new mo(t);
  this.size = e.size;
}
Ui.prototype.clear = Wle;
Ui.prototype.delete = jle;
Ui.prototype.get = Yle;
Ui.prototype.has = Xle;
Ui.prototype.set = Zle;
var um = function() {
  try {
    var t = wu(Object, "defineProperty");
    return t({}, "", {}), t;
  } catch {
  }
}();
function H0(t, e, r) {
  e == "__proto__" && um ? um(t, e, {
    configurable: !0,
    enumerable: !0,
    value: r,
    writable: !0
  }) : t[e] = r;
}
function CT(t, e, r) {
  (r !== void 0 && !Ef(t[e], r) || r === void 0 && !(e in t)) && H0(t, e, r);
}
function Qle(t) {
  return function(e, r, n) {
    for (var a = -1, i = Object(e), s = n(e), o = s.length; o--; ) {
      var l = s[++a];
      if (r(i[l], l, i) === !1)
        break;
    }
    return e;
  };
}
var A5 = Qle(), k9 = typeof exports == "object" && exports && !exports.nodeType && exports, TR = k9 && typeof module == "object" && module && !module.nodeType && module, Jle = TR && TR.exports === k9, SR = Jle ? ws.Buffer : void 0, CR = SR ? SR.allocUnsafe : void 0;
function R9(t, e) {
  if (e)
    return t.slice();
  var r = t.length, n = CR ? CR(r) : new t.constructor(r);
  return t.copy(n), n;
}
var cm = ws.Uint8Array;
function k5(t) {
  var e = new t.constructor(t.byteLength);
  return new cm(e).set(new cm(t)), e;
}
function M9(t, e) {
  var r = e ? k5(t.buffer) : t.buffer;
  return new t.constructor(r, t.byteOffset, t.length);
}
function _9(t, e) {
  var r = -1, n = t.length;
  for (e || (e = Array(n)); ++r < n; )
    e[r] = t[r];
  return e;
}
var AR = Object.create, eue = /* @__PURE__ */ function() {
  function t() {
  }
  return function(e) {
    if (!Ma(e))
      return {};
    if (AR)
      return AR(e);
    t.prototype = e;
    var r = new t();
    return t.prototype = void 0, r;
  };
}();
function L9(t, e) {
  return function(r) {
    return t(e(r));
  };
}
var R5 = L9(Object.getPrototypeOf, Object), tue = Object.prototype;
function V0(t) {
  var e = t && t.constructor, r = typeof e == "function" && e.prototype || tue;
  return t === r;
}
function N9(t) {
  return typeof t.constructor == "function" && !V0(t) ? eue(R5(t)) : {};
}
function wi(t) {
  return t != null && typeof t == "object";
}
var rue = "[object Arguments]";
function kR(t) {
  return wi(t) && vo(t) == rue;
}
var O9 = Object.prototype, nue = O9.hasOwnProperty, aue = O9.propertyIsEnumerable, ef = kR(/* @__PURE__ */ function() {
  return arguments;
}()) ? kR : function(t) {
  return wi(t) && nue.call(t, "callee") && !aue.call(t, "callee");
}, jt = Array.isArray, iue = 9007199254740991;
function M5(t) {
  return typeof t == "number" && t > -1 && t % 1 == 0 && t <= iue;
}
function Es(t) {
  return t != null && M5(t.length) && !xi(t);
}
function fm(t) {
  return wi(t) && Es(t);
}
function sue() {
  return !1;
}
var I9 = typeof exports == "object" && exports && !exports.nodeType && exports, RR = I9 && typeof module == "object" && module && !module.nodeType && module, oue = RR && RR.exports === I9, MR = oue ? ws.Buffer : void 0, lue = MR ? MR.isBuffer : void 0, tf = lue || sue, uue = "[object Object]", cue = Function.prototype, fue = Object.prototype, P9 = cue.toString, hue = fue.hasOwnProperty, due = P9.call(Object);
function pue(t) {
  if (!wi(t) || vo(t) != uue)
    return !1;
  var e = R5(t);
  if (e === null)
    return !0;
  var r = hue.call(e, "constructor") && e.constructor;
  return typeof r == "function" && r instanceof r && P9.call(r) == due;
}
var gue = "[object Arguments]", vue = "[object Array]", mue = "[object Boolean]", yue = "[object Date]", bue = "[object Error]", xue = "[object Function]", wue = "[object Map]", Eue = "[object Number]", Tue = "[object Object]", Sue = "[object RegExp]", Cue = "[object Set]", Aue = "[object String]", kue = "[object WeakMap]", Rue = "[object ArrayBuffer]", Mue = "[object DataView]", _ue = "[object Float32Array]", Lue = "[object Float64Array]", Nue = "[object Int8Array]", Oue = "[object Int16Array]", Iue = "[object Int32Array]", Pue = "[object Uint8Array]", Due = "[object Uint8ClampedArray]", $ue = "[object Uint16Array]", Fue = "[object Uint32Array]", Or = {};
Or[_ue] = Or[Lue] = Or[Nue] = Or[Oue] = Or[Iue] = Or[Pue] = Or[Due] = Or[$ue] = Or[Fue] = !0;
Or[gue] = Or[vue] = Or[Rue] = Or[mue] = Or[Mue] = Or[yue] = Or[bue] = Or[xue] = Or[wue] = Or[Eue] = Or[Tue] = Or[Sue] = Or[Cue] = Or[Aue] = Or[kue] = !1;
function Bue(t) {
  return wi(t) && M5(t.length) && !!Or[vo(t)];
}
function q0(t) {
  return function(e) {
    return t(e);
  };
}
var D9 = typeof exports == "object" && exports && !exports.nodeType && exports, Ed = D9 && typeof module == "object" && module && !module.nodeType && module, zue = Ed && Ed.exports === D9, vx = zue && C9.process, Go = function() {
  try {
    var t = Ed && Ed.require && Ed.require("util").types;
    return t || vx && vx.binding && vx.binding("util");
  } catch {
  }
}(), _R = Go && Go.isTypedArray, v1 = _R ? q0(_R) : Bue;
function AT(t, e) {
  if (!(e === "constructor" && typeof t[e] == "function") && e != "__proto__")
    return t[e];
}
var Gue = Object.prototype, Uue = Gue.hasOwnProperty;
function W0(t, e, r) {
  var n = t[e];
  (!(Uue.call(t, e) && Ef(n, r)) || r === void 0 && !(e in t)) && H0(t, e, r);
}
function Tf(t, e, r, n) {
  var a = !r;
  r || (r = {});
  for (var i = -1, s = e.length; ++i < s; ) {
    var o = e[i], l = void 0;
    l === void 0 && (l = t[o]), a ? H0(r, o, l) : W0(r, o, l);
  }
  return r;
}
function Hue(t, e) {
  for (var r = -1, n = Array(t); ++r < t; )
    n[r] = e(r);
  return n;
}
var Vue = 9007199254740991, que = /^(?:0|[1-9]\d*)$/;
function m1(t, e) {
  var r = typeof t;
  return e = e ?? Vue, !!e && (r == "number" || r != "symbol" && que.test(t)) && t > -1 && t % 1 == 0 && t < e;
}
var Wue = Object.prototype, jue = Wue.hasOwnProperty;
function $9(t, e) {
  var r = jt(t), n = !r && ef(t), a = !r && !n && tf(t), i = !r && !n && !a && v1(t), s = r || n || a || i, o = s ? Hue(t.length, String) : [], l = o.length;
  for (var u in t)
    (e || jue.call(t, u)) && !(s && // Safari 9 has enumerable `arguments.length` in strict mode.
    (u == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    a && (u == "offset" || u == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    i && (u == "buffer" || u == "byteLength" || u == "byteOffset") || // Skip index properties.
    m1(u, l))) && o.push(u);
  return o;
}
function Yue(t) {
  var e = [];
  if (t != null)
    for (var r in Object(t))
      e.push(r);
  return e;
}
var Xue = Object.prototype, Kue = Xue.hasOwnProperty;
function Zue(t) {
  if (!Ma(t))
    return Yue(t);
  var e = V0(t), r = [];
  for (var n in t)
    n == "constructor" && (e || !Kue.call(t, n)) || r.push(n);
  return r;
}
function Eu(t) {
  return Es(t) ? $9(t, !0) : Zue(t);
}
function Que(t) {
  return Tf(t, Eu(t));
}
function Jue(t, e, r, n, a, i, s) {
  var o = AT(t, r), l = AT(e, r), u = s.get(l);
  if (u) {
    CT(t, r, u);
    return;
  }
  var c = i ? i(o, l, r + "", t, e, s) : void 0, f = c === void 0;
  if (f) {
    var h = jt(l), d = !h && tf(l), p = !h && !d && v1(l);
    c = l, h || d || p ? jt(o) ? c = o : fm(o) ? c = _9(o) : d ? (f = !1, c = R9(l, !0)) : p ? (f = !1, c = M9(l, !0)) : c = [] : pue(l) || ef(l) ? (c = o, ef(o) ? c = Que(o) : (!Ma(o) || xi(o)) && (c = N9(l))) : f = !1;
  }
  f && (s.set(l, c), a(c, l, n, i, s), s.delete(l)), CT(t, r, c);
}
function F9(t, e, r, n, a) {
  t !== e && A5(e, function(i, s) {
    if (a || (a = new Ui()), Ma(i))
      Jue(t, e, s, r, F9, n, a);
    else {
      var o = n ? n(AT(t, s), i, s + "", t, e, a) : void 0;
      o === void 0 && (o = i), CT(t, s, o);
    }
  }, Eu);
}
function no(t) {
  return t;
}
function ece(t, e, r) {
  switch (r.length) {
    case 0:
      return t.call(e);
    case 1:
      return t.call(e, r[0]);
    case 2:
      return t.call(e, r[0], r[1]);
    case 3:
      return t.call(e, r[0], r[1], r[2]);
  }
  return t.apply(e, r);
}
var LR = Math.max;
function B9(t, e, r) {
  return e = LR(e === void 0 ? t.length - 1 : e, 0), function() {
    for (var n = arguments, a = -1, i = LR(n.length - e, 0), s = Array(i); ++a < i; )
      s[a] = n[e + a];
    a = -1;
    for (var o = Array(e + 1); ++a < e; )
      o[a] = n[a];
    return o[e] = r(s), ece(t, this, o);
  };
}
function lc(t) {
  return function() {
    return t;
  };
}
var tce = um ? function(t, e) {
  return um(t, "toString", {
    configurable: !0,
    enumerable: !1,
    value: lc(e),
    writable: !0
  });
} : no, rce = 800, nce = 16, ace = Date.now;
function ice(t) {
  var e = 0, r = 0;
  return function() {
    var n = ace(), a = nce - (n - r);
    if (r = n, a > 0) {
      if (++e >= rce)
        return arguments[0];
    } else
      e = 0;
    return t.apply(void 0, arguments);
  };
}
var z9 = ice(tce);
function j0(t, e) {
  return z9(B9(t, e, no), t + "");
}
function Qd(t, e, r) {
  if (!Ma(r))
    return !1;
  var n = typeof e;
  return (n == "number" ? Es(r) && m1(e, r.length) : n == "string" && e in r) ? Ef(r[e], t) : !1;
}
function G9(t) {
  return j0(function(e, r) {
    var n = -1, a = r.length, i = a > 1 ? r[a - 1] : void 0, s = a > 2 ? r[2] : void 0;
    for (i = t.length > 3 && typeof i == "function" ? (a--, i) : void 0, s && Qd(r[0], r[1], s) && (i = a < 3 ? void 0 : i, a = 1), e = Object(e); ++n < a; ) {
      var o = r[n];
      o && t(e, o, n, i);
    }
    return e;
  });
}
var kT = G9(function(t, e, r) {
  F9(t, e, r);
});
const sce = Object.freeze({
  left: 0,
  top: 0,
  width: 16,
  height: 16
}), hm = Object.freeze({
  rotate: 0,
  vFlip: !1,
  hFlip: !1
}), U9 = Object.freeze({
  ...sce,
  ...hm
}), oce = Object.freeze({
  ...U9,
  body: "",
  hidden: !1
}), lce = Object.freeze({
  width: null,
  height: null
}), uce = Object.freeze({
  ...lce,
  ...hm
}), L_e = (t, e, r, n = "") => {
  const a = t.split(":");
  if (t.slice(0, 1) === "@") {
    if (a.length < 2 || a.length > 3) return null;
    n = a.shift().slice(1);
  }
  if (a.length > 3 || !a.length) return null;
  if (a.length > 1) {
    const o = a.pop(), l = a.pop(), u = {
      provider: a.length > 0 ? a[0] : n,
      prefix: l,
      name: o
    };
    return mx(u) ? u : null;
  }
  const i = a[0], s = i.split("-");
  if (s.length > 1) {
    const o = {
      provider: n,
      prefix: s.shift(),
      name: s.join("-")
    };
    return mx(o) ? o : null;
  }
  if (r && n === "") {
    const o = {
      provider: n,
      prefix: "",
      name: i
    };
    return mx(o, r) ? o : null;
  }
  return null;
}, mx = (t, e) => t ? !!((e && t.prefix === "" || t.prefix) && t.name) : !1;
function cce(t, e) {
  const r = {};
  !t.hFlip != !e.hFlip && (r.hFlip = !0), !t.vFlip != !e.vFlip && (r.vFlip = !0);
  const n = ((t.rotate || 0) + (e.rotate || 0)) % 4;
  return n && (r.rotate = n), r;
}
function NR(t, e) {
  const r = cce(t, e);
  for (const n in oce) n in hm ? n in t && !(n in r) && (r[n] = hm[n]) : n in e ? r[n] = e[n] : n in t && (r[n] = t[n]);
  return r;
}
function fce(t, e) {
  const r = t.icons, n = t.aliases || /* @__PURE__ */ Object.create(null), a = /* @__PURE__ */ Object.create(null);
  function i(s) {
    if (r[s]) return a[s] = [];
    if (!(s in a)) {
      a[s] = null;
      const o = n[s] && n[s].parent, l = o && i(o);
      l && (a[s] = [o].concat(l));
    }
    return a[s];
  }
  return (e || Object.keys(r).concat(Object.keys(n))).forEach(i), a;
}
function OR(t, e, r) {
  const n = t.icons, a = t.aliases || /* @__PURE__ */ Object.create(null);
  let i = {};
  function s(o) {
    i = NR(n[o] || a[o], i);
  }
  return s(e), r.forEach(s), NR(t, i);
}
function N_e(t, e) {
  if (t.icons[e]) return OR(t, e, []);
  const r = fce(t, [e])[e];
  return r ? OR(t, e, r) : null;
}
const hce = /(-?[0-9.]*[0-9]+[0-9.]*)/g, dce = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function IR(t, e, r) {
  if (e === 1) return t;
  if (r = r || 100, typeof t == "number") return Math.ceil(t * e * r) / r;
  if (typeof t != "string") return t;
  const n = t.split(hce);
  if (n === null || !n.length) return t;
  const a = [];
  let i = n.shift(), s = dce.test(i);
  for (; ; ) {
    if (s) {
      const o = parseFloat(i);
      isNaN(o) ? a.push(i) : a.push(Math.ceil(o * e * r) / r);
    } else a.push(i);
    if (i = n.shift(), i === void 0) return a.join("");
    s = !s;
  }
}
function pce(t, e = "defs") {
  let r = "";
  const n = t.indexOf("<" + e);
  for (; n >= 0; ) {
    const a = t.indexOf(">", n), i = t.indexOf("</" + e);
    if (a === -1 || i === -1) break;
    const s = t.indexOf(">", i);
    if (s === -1) break;
    r += t.slice(a + 1, i).trim(), t = t.slice(0, n).trim() + t.slice(s + 1);
  }
  return {
    defs: r,
    content: t
  };
}
function gce(t, e) {
  return t ? "<defs>" + t + "</defs>" + e : e;
}
function vce(t, e, r) {
  const n = pce(t);
  return gce(n.defs, e + n.content + r);
}
const mce = (t) => t === "unset" || t === "undefined" || t === "none";
function O_e(t, e) {
  const r = {
    ...U9,
    ...t
  }, n = {
    ...uce,
    ...e
  }, a = {
    left: r.left,
    top: r.top,
    width: r.width,
    height: r.height
  };
  let i = r.body;
  [r, n].forEach((g) => {
    const v = [], m = g.hFlip, b = g.vFlip;
    let y = g.rotate;
    m ? b ? y += 2 : (v.push("translate(" + (a.width + a.left).toString() + " " + (0 - a.top).toString() + ")"), v.push("scale(-1 1)"), a.top = a.left = 0) : b && (v.push("translate(" + (0 - a.left).toString() + " " + (a.height + a.top).toString() + ")"), v.push("scale(1 -1)"), a.top = a.left = 0);
    let x;
    switch (y < 0 && (y -= Math.floor(y / 4) * 4), y = y % 4, y) {
      case 1:
        x = a.height / 2 + a.top, v.unshift("rotate(90 " + x.toString() + " " + x.toString() + ")");
        break;
      case 2:
        v.unshift("rotate(180 " + (a.width / 2 + a.left).toString() + " " + (a.height / 2 + a.top).toString() + ")");
        break;
      case 3:
        x = a.width / 2 + a.left, v.unshift("rotate(-90 " + x.toString() + " " + x.toString() + ")");
        break;
    }
    y % 2 === 1 && (a.left !== a.top && (x = a.left, a.left = a.top, a.top = x), a.width !== a.height && (x = a.width, a.width = a.height, a.height = x)), v.length && (i = vce(i, '<g transform="' + v.join(" ") + '">', "</g>"));
  });
  const s = n.width, o = n.height, l = a.width, u = a.height;
  let c, f;
  s === null ? (f = o === null ? "1em" : o === "auto" ? u : o, c = IR(f, l / u)) : (c = s === "auto" ? l : s, f = o === null ? IR(c, u / l) : o === "auto" ? u : o);
  const h = {}, d = (g, v) => {
    mce(v) || (h[g] = v.toString());
  };
  d("width", c), d("height", f);
  const p = [
    a.left,
    a.top,
    l,
    u
  ];
  return h.viewBox = p.join(" "), {
    attributes: h,
    viewBox: p,
    body: i
  };
}
const yce = /\sid="(\S+)"/g, PR = /* @__PURE__ */ new Map();
function bce(t) {
  t = t.replace(/[0-9]+$/, "") || "a";
  const e = PR.get(t) || 0;
  return PR.set(t, e + 1), e ? `${t}${e}` : t;
}
function I_e(t) {
  const e = [];
  let r;
  for (; r = yce.exec(t); ) e.push(r[1]);
  if (!e.length) return t;
  const n = "suffix" + (Math.random() * 16777216 | Date.now()).toString(16);
  return e.forEach((a) => {
    const i = bce(a), s = a.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    t = t.replace(new RegExp('([#;"])(' + s + ')([")]|\\.[a-z])', "g"), "$1" + i + n + "$3");
  }), t = t.replace(new RegExp(n, "g"), ""), t;
}
function P_e(t, e) {
  let r = t.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
  for (const n in e) r += " " + n + '="' + e[n] + '"';
  return '<svg xmlns="http://www.w3.org/2000/svg"' + r + ">" + t + "</svg>";
}
function _5() {
  return { async: !1, breaks: !1, extensions: null, gfm: !0, hooks: null, pedantic: !1, renderer: null, silent: !1, tokenizer: null, walkTokens: null };
}
var Tu = _5();
function H9(t) {
  Tu = t;
}
var Td = { exec: () => null };
function ar(t, e = "") {
  let r = typeof t == "string" ? t : t.source, n = { replace: (a, i) => {
    let s = typeof i == "string" ? i : i.source;
    return s = s.replace(la.caret, "$1"), r = r.replace(a, s), n;
  }, getRegex: () => new RegExp(r, e) };
  return n;
}
var xce = (() => {
  try {
    return !!new RegExp("(?<=1)(?<!1)");
  } catch {
    return !1;
  }
})(), la = { codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm, outputLinkReplace: /\\([\[\]])/g, indentCodeCompensation: /^(\s+)(?:```)/, beginningSpace: /^\s+/, endingHash: /#$/, startingSpaceChar: /^ /, endingSpaceChar: / $/, nonSpaceChar: /[^ ]/, newLineCharGlobal: /\n/g, tabCharGlobal: /\t/g, multipleSpaceGlobal: /\s+/g, blankLine: /^[ \t]*$/, doubleBlankLine: /\n[ \t]*\n[ \t]*$/, blockquoteStart: /^ {0,3}>/, blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g, blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm, listReplaceTabs: /^\t+/, listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g, listIsTask: /^\[[ xX]\] /, listReplaceTask: /^\[[ xX]\] +/, anyLine: /\n.*\n/, hrefBrackets: /^<(.*)>$/, tableDelimiter: /[:|]/, tableAlignChars: /^\||\| *$/g, tableRowBlankLine: /\n[ \t]*$/, tableAlignRight: /^ *-+: *$/, tableAlignCenter: /^ *:-+: *$/, tableAlignLeft: /^ *:-+ *$/, startATag: /^<a /i, endATag: /^<\/a>/i, startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i, endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i, startAngleBracket: /^</, endAngleBracket: />$/, pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/, unicodeAlphaNumeric: /[\p{L}\p{N}]/u, escapeTest: /[&<>"']/, escapeReplace: /[&<>"']/g, escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/, escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g, unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig, caret: /(^|[^\[])\^/g, percentDecode: /%25/g, findPipe: /\|/g, splitPipe: / \|/, slashPipe: /\\\|/g, carriageReturn: /\r\n|\r/g, spaceLine: /^ +$/gm, notSpaceStart: /^\S*/, endingNewline: /\n$/, listItemRegex: (t) => new RegExp(`^( {0,3}${t})((?:[	 ][^\\n]*)?(?:\\n|$))`), nextBulletRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`), hrRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`), fencesBeginRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}(?:\`\`\`|~~~)`), headingBeginRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}#`), htmlBeginRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}<(?:[a-z].*>|!--)`, "i") }, wce = /^(?:[ \t]*(?:\n|$))+/, Ece = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/, Tce = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/, Y0 = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/, Sce = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/, L5 = /(?:[*+-]|\d{1,9}[.)])/, V9 = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/, q9 = ar(V9).replace(/bull/g, L5).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/\|table/g, "").getRegex(), Cce = ar(V9).replace(/bull/g, L5).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/).getRegex(), N5 = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/, Ace = /^[^\n]+/, O5 = /(?!\s*\])(?:\\[\s\S]|[^\[\]\\])+/, kce = ar(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label", O5).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(), Rce = ar(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, L5).getRegex(), y1 = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", I5 = /<!--(?:-?>|[\s\S]*?(?:-->|$))/, Mce = ar("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))", "i").replace("comment", I5).replace("tag", y1).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), W9 = ar(N5).replace("hr", Y0).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", y1).getRegex(), _ce = ar(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", W9).getRegex(), P5 = { blockquote: _ce, code: Ece, def: kce, fences: Tce, heading: Sce, hr: Y0, html: Mce, lheading: q9, list: Rce, newline: wce, paragraph: W9, table: Td, text: Ace }, DR = ar("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", Y0).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", "(?: {4}| {0,3}	)[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", y1).getRegex(), Lce = { ...P5, lheading: Cce, table: DR, paragraph: ar(N5).replace("hr", Y0).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", DR).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", y1).getRegex() }, Nce = { ...P5, html: ar(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", I5).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(), def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/, heading: /^(#{1,6})(.*)(?:\n+|$)/, fences: Td, lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/, paragraph: ar(N5).replace("hr", Y0).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", q9).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex() }, Oce = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/, Ice = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, j9 = /^( {2,}|\\)\n(?!\s*$)/, Pce = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/, b1 = /[\p{P}\p{S}]/u, D5 = /[\s\p{P}\p{S}]/u, Y9 = /[^\s\p{P}\p{S}]/u, Dce = ar(/^((?![*_])punctSpace)/, "u").replace(/punctSpace/g, D5).getRegex(), X9 = /(?!~)[\p{P}\p{S}]/u, $ce = /(?!~)[\s\p{P}\p{S}]/u, Fce = /(?:[^\s\p{P}\p{S}]|~)/u, Bce = ar(/link|precode-code|html/, "g").replace("link", /\[(?:[^\[\]`]|(?<a>`+)[^`]+\k<a>(?!`))*?\]\((?:\\[\s\S]|[^\\\(\)]|\((?:\\[\s\S]|[^\\\(\)])*\))*\)/).replace("precode-", xce ? "(?<!`)()" : "(^^|[^`])").replace("code", /(?<b>`+)[^`]+\k<b>(?!`)/).replace("html", /<(?! )[^<>]*?>/).getRegex(), K9 = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/, zce = ar(K9, "u").replace(/punct/g, b1).getRegex(), Gce = ar(K9, "u").replace(/punct/g, X9).getRegex(), Z9 = "^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)", Uce = ar(Z9, "gu").replace(/notPunctSpace/g, Y9).replace(/punctSpace/g, D5).replace(/punct/g, b1).getRegex(), Hce = ar(Z9, "gu").replace(/notPunctSpace/g, Fce).replace(/punctSpace/g, $ce).replace(/punct/g, X9).getRegex(), Vce = ar("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)", "gu").replace(/notPunctSpace/g, Y9).replace(/punctSpace/g, D5).replace(/punct/g, b1).getRegex(), qce = ar(/\\(punct)/, "gu").replace(/punct/g, b1).getRegex(), Wce = ar(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(), jce = ar(I5).replace("(?:-->|$)", "-->").getRegex(), Yce = ar("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", jce).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(), dm = /(?:\[(?:\\[\s\S]|[^\[\]\\])*\]|\\[\s\S]|`+[^`]*?`+(?!`)|[^\[\]\\`])*?/, Xce = ar(/^!?\[(label)\]\(\s*(href)(?:(?:[ \t]*(?:\n[ \t]*)?)(title))?\s*\)/).replace("label", dm).replace("href", /<(?:\\.|[^\n<>\\])+>|[^ \t\n\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(), Q9 = ar(/^!?\[(label)\]\[(ref)\]/).replace("label", dm).replace("ref", O5).getRegex(), J9 = ar(/^!?\[(ref)\](?:\[\])?/).replace("ref", O5).getRegex(), Kce = ar("reflink|nolink(?!\\()", "g").replace("reflink", Q9).replace("nolink", J9).getRegex(), $R = /[hH][tT][tT][pP][sS]?|[fF][tT][pP]/, $5 = { _backpedal: Td, anyPunctuation: qce, autolink: Wce, blockSkip: Bce, br: j9, code: Ice, del: Td, emStrongLDelim: zce, emStrongRDelimAst: Uce, emStrongRDelimUnd: Vce, escape: Oce, link: Xce, nolink: J9, punctuation: Dce, reflink: Q9, reflinkSearch: Kce, tag: Yce, text: Pce, url: Td }, Zce = { ...$5, link: ar(/^!?\[(label)\]\((.*?)\)/).replace("label", dm).getRegex(), reflink: ar(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", dm).getRegex() }, RT = { ...$5, emStrongRDelimAst: Hce, emStrongLDelim: Gce, url: ar(/^((?:protocol):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/).replace("protocol", $R).replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(), _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/, del: /^(~~?)(?=[^\s~])((?:\\[\s\S]|[^\\])*?(?:\\[\s\S]|[^\s~\\]))\1(?=[^~]|$)/, text: ar(/^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|protocol:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/).replace("protocol", $R).getRegex() }, Qce = { ...RT, br: ar(j9).replace("{2,}", "*").getRegex(), text: ar(RT.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex() }, Up = { normal: P5, gfm: Lce, pedantic: Nce }, ah = { normal: $5, gfm: RT, breaks: Qce, pedantic: Zce }, Jce = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, FR = (t) => Jce[t];
function as(t, e) {
  if (e) {
    if (la.escapeTest.test(t)) return t.replace(la.escapeReplace, FR);
  } else if (la.escapeTestNoEncode.test(t)) return t.replace(la.escapeReplaceNoEncode, FR);
  return t;
}
function BR(t) {
  try {
    t = encodeURI(t).replace(la.percentDecode, "%");
  } catch {
    return null;
  }
  return t;
}
function zR(t, e) {
  var i;
  let r = t.replace(la.findPipe, (s, o, l) => {
    let u = !1, c = o;
    for (; --c >= 0 && l[c] === "\\"; ) u = !u;
    return u ? "|" : " |";
  }), n = r.split(la.splitPipe), a = 0;
  if (n[0].trim() || n.shift(), n.length > 0 && !((i = n.at(-1)) != null && i.trim()) && n.pop(), e) if (n.length > e) n.splice(e);
  else for (; n.length < e; ) n.push("");
  for (; a < n.length; a++) n[a] = n[a].trim().replace(la.slashPipe, "|");
  return n;
}
function ih(t, e, r) {
  let n = t.length;
  if (n === 0) return "";
  let a = 0;
  for (; a < n && t.charAt(n - a - 1) === e; )
    a++;
  return t.slice(0, n - a);
}
function efe(t, e) {
  if (t.indexOf(e[1]) === -1) return -1;
  let r = 0;
  for (let n = 0; n < t.length; n++) if (t[n] === "\\") n++;
  else if (t[n] === e[0]) r++;
  else if (t[n] === e[1] && (r--, r < 0)) return n;
  return r > 0 ? -2 : -1;
}
function GR(t, e, r, n, a) {
  let i = e.href, s = e.title || null, o = t[1].replace(a.other.outputLinkReplace, "$1");
  n.state.inLink = !0;
  let l = { type: t[0].charAt(0) === "!" ? "image" : "link", raw: r, href: i, title: s, text: o, tokens: n.inlineTokens(o) };
  return n.state.inLink = !1, l;
}
function tfe(t, e, r) {
  let n = t.match(r.other.indentCodeCompensation);
  if (n === null) return e;
  let a = n[1];
  return e.split(`
`).map((i) => {
    let s = i.match(r.other.beginningSpace);
    if (s === null) return i;
    let [o] = s;
    return o.length >= a.length ? i.slice(a.length) : i;
  }).join(`
`);
}
var pm = class {
  constructor(e) {
    Ye(this, "options");
    Ye(this, "rules");
    Ye(this, "lexer");
    this.options = e || Tu;
  }
  space(e) {
    let r = this.rules.block.newline.exec(e);
    if (r && r[0].length > 0) return { type: "space", raw: r[0] };
  }
  code(e) {
    let r = this.rules.block.code.exec(e);
    if (r) {
      let n = r[0].replace(this.rules.other.codeRemoveIndent, "");
      return { type: "code", raw: r[0], codeBlockStyle: "indented", text: this.options.pedantic ? n : ih(n, `
`) };
    }
  }
  fences(e) {
    let r = this.rules.block.fences.exec(e);
    if (r) {
      let n = r[0], a = tfe(n, r[3] || "", this.rules);
      return { type: "code", raw: n, lang: r[2] ? r[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : r[2], text: a };
    }
  }
  heading(e) {
    let r = this.rules.block.heading.exec(e);
    if (r) {
      let n = r[2].trim();
      if (this.rules.other.endingHash.test(n)) {
        let a = ih(n, "#");
        (this.options.pedantic || !a || this.rules.other.endingSpaceChar.test(a)) && (n = a.trim());
      }
      return { type: "heading", raw: r[0], depth: r[1].length, text: n, tokens: this.lexer.inline(n) };
    }
  }
  hr(e) {
    let r = this.rules.block.hr.exec(e);
    if (r) return { type: "hr", raw: ih(r[0], `
`) };
  }
  blockquote(e) {
    let r = this.rules.block.blockquote.exec(e);
    if (r) {
      let n = ih(r[0], `
`).split(`
`), a = "", i = "", s = [];
      for (; n.length > 0; ) {
        let o = !1, l = [], u;
        for (u = 0; u < n.length; u++) if (this.rules.other.blockquoteStart.test(n[u])) l.push(n[u]), o = !0;
        else if (!o) l.push(n[u]);
        else break;
        n = n.slice(u);
        let c = l.join(`
`), f = c.replace(this.rules.other.blockquoteSetextReplace, `
    $1`).replace(this.rules.other.blockquoteSetextReplace2, "");
        a = a ? `${a}
${c}` : c, i = i ? `${i}
${f}` : f;
        let h = this.lexer.state.top;
        if (this.lexer.state.top = !0, this.lexer.blockTokens(f, s, !0), this.lexer.state.top = h, n.length === 0) break;
        let d = s.at(-1);
        if ((d == null ? void 0 : d.type) === "code") break;
        if ((d == null ? void 0 : d.type) === "blockquote") {
          let p = d, g = p.raw + `
` + n.join(`
`), v = this.blockquote(g);
          s[s.length - 1] = v, a = a.substring(0, a.length - p.raw.length) + v.raw, i = i.substring(0, i.length - p.text.length) + v.text;
          break;
        } else if ((d == null ? void 0 : d.type) === "list") {
          let p = d, g = p.raw + `
` + n.join(`
`), v = this.list(g);
          s[s.length - 1] = v, a = a.substring(0, a.length - d.raw.length) + v.raw, i = i.substring(0, i.length - p.raw.length) + v.raw, n = g.substring(s.at(-1).raw.length).split(`
`);
          continue;
        }
      }
      return { type: "blockquote", raw: a, tokens: s, text: i };
    }
  }
  list(e) {
    let r = this.rules.block.list.exec(e);
    if (r) {
      let n = r[1].trim(), a = n.length > 1, i = { type: "list", raw: "", ordered: a, start: a ? +n.slice(0, -1) : "", loose: !1, items: [] };
      n = a ? `\\d{1,9}\\${n.slice(-1)}` : `\\${n}`, this.options.pedantic && (n = a ? n : "[*+-]");
      let s = this.rules.other.listItemRegex(n), o = !1;
      for (; e; ) {
        let u = !1, c = "", f = "";
        if (!(r = s.exec(e)) || this.rules.block.hr.test(e)) break;
        c = r[0], e = e.substring(c.length);
        let h = r[2].split(`
`, 1)[0].replace(this.rules.other.listReplaceTabs, (b) => " ".repeat(3 * b.length)), d = e.split(`
`, 1)[0], p = !h.trim(), g = 0;
        if (this.options.pedantic ? (g = 2, f = h.trimStart()) : p ? g = r[1].length + 1 : (g = r[2].search(this.rules.other.nonSpaceChar), g = g > 4 ? 1 : g, f = h.slice(g), g += r[1].length), p && this.rules.other.blankLine.test(d) && (c += d + `
`, e = e.substring(d.length + 1), u = !0), !u) {
          let b = this.rules.other.nextBulletRegex(g), y = this.rules.other.hrRegex(g), x = this.rules.other.fencesBeginRegex(g), E = this.rules.other.headingBeginRegex(g), S = this.rules.other.htmlBeginRegex(g);
          for (; e; ) {
            let w = e.split(`
`, 1)[0], C;
            if (d = w, this.options.pedantic ? (d = d.replace(this.rules.other.listReplaceNesting, "  "), C = d) : C = d.replace(this.rules.other.tabCharGlobal, "    "), x.test(d) || E.test(d) || S.test(d) || b.test(d) || y.test(d)) break;
            if (C.search(this.rules.other.nonSpaceChar) >= g || !d.trim()) f += `
` + C.slice(g);
            else {
              if (p || h.replace(this.rules.other.tabCharGlobal, "    ").search(this.rules.other.nonSpaceChar) >= 4 || x.test(h) || E.test(h) || y.test(h)) break;
              f += `
` + d;
            }
            !p && !d.trim() && (p = !0), c += w + `
`, e = e.substring(w.length + 1), h = C.slice(g);
          }
        }
        i.loose || (o ? i.loose = !0 : this.rules.other.doubleBlankLine.test(c) && (o = !0));
        let v = null, m;
        this.options.gfm && (v = this.rules.other.listIsTask.exec(f), v && (m = v[0] !== "[ ] ", f = f.replace(this.rules.other.listReplaceTask, ""))), i.items.push({ type: "list_item", raw: c, task: !!v, checked: m, loose: !1, text: f, tokens: [] }), i.raw += c;
      }
      let l = i.items.at(-1);
      if (l) l.raw = l.raw.trimEnd(), l.text = l.text.trimEnd();
      else return;
      i.raw = i.raw.trimEnd();
      for (let u = 0; u < i.items.length; u++) if (this.lexer.state.top = !1, i.items[u].tokens = this.lexer.blockTokens(i.items[u].text, []), !i.loose) {
        let c = i.items[u].tokens.filter((h) => h.type === "space"), f = c.length > 0 && c.some((h) => this.rules.other.anyLine.test(h.raw));
        i.loose = f;
      }
      if (i.loose) for (let u = 0; u < i.items.length; u++) i.items[u].loose = !0;
      return i;
    }
  }
  html(e) {
    let r = this.rules.block.html.exec(e);
    if (r) return { type: "html", block: !0, raw: r[0], pre: r[1] === "pre" || r[1] === "script" || r[1] === "style", text: r[0] };
  }
  def(e) {
    let r = this.rules.block.def.exec(e);
    if (r) {
      let n = r[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, " "), a = r[2] ? r[2].replace(this.rules.other.hrefBrackets, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "", i = r[3] ? r[3].substring(1, r[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : r[3];
      return { type: "def", tag: n, raw: r[0], href: a, title: i };
    }
  }
  table(e) {
    var o;
    let r = this.rules.block.table.exec(e);
    if (!r || !this.rules.other.tableDelimiter.test(r[2])) return;
    let n = zR(r[1]), a = r[2].replace(this.rules.other.tableAlignChars, "").split("|"), i = (o = r[3]) != null && o.trim() ? r[3].replace(this.rules.other.tableRowBlankLine, "").split(`
`) : [], s = { type: "table", raw: r[0], header: [], align: [], rows: [] };
    if (n.length === a.length) {
      for (let l of a) this.rules.other.tableAlignRight.test(l) ? s.align.push("right") : this.rules.other.tableAlignCenter.test(l) ? s.align.push("center") : this.rules.other.tableAlignLeft.test(l) ? s.align.push("left") : s.align.push(null);
      for (let l = 0; l < n.length; l++) s.header.push({ text: n[l], tokens: this.lexer.inline(n[l]), header: !0, align: s.align[l] });
      for (let l of i) s.rows.push(zR(l, s.header.length).map((u, c) => ({ text: u, tokens: this.lexer.inline(u), header: !1, align: s.align[c] })));
      return s;
    }
  }
  lheading(e) {
    let r = this.rules.block.lheading.exec(e);
    if (r) return { type: "heading", raw: r[0], depth: r[2].charAt(0) === "=" ? 1 : 2, text: r[1], tokens: this.lexer.inline(r[1]) };
  }
  paragraph(e) {
    let r = this.rules.block.paragraph.exec(e);
    if (r) {
      let n = r[1].charAt(r[1].length - 1) === `
` ? r[1].slice(0, -1) : r[1];
      return { type: "paragraph", raw: r[0], text: n, tokens: this.lexer.inline(n) };
    }
  }
  text(e) {
    let r = this.rules.block.text.exec(e);
    if (r) return { type: "text", raw: r[0], text: r[0], tokens: this.lexer.inline(r[0]) };
  }
  escape(e) {
    let r = this.rules.inline.escape.exec(e);
    if (r) return { type: "escape", raw: r[0], text: r[1] };
  }
  tag(e) {
    let r = this.rules.inline.tag.exec(e);
    if (r) return !this.lexer.state.inLink && this.rules.other.startATag.test(r[0]) ? this.lexer.state.inLink = !0 : this.lexer.state.inLink && this.rules.other.endATag.test(r[0]) && (this.lexer.state.inLink = !1), !this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(r[0]) ? this.lexer.state.inRawBlock = !0 : this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(r[0]) && (this.lexer.state.inRawBlock = !1), { type: "html", raw: r[0], inLink: this.lexer.state.inLink, inRawBlock: this.lexer.state.inRawBlock, block: !1, text: r[0] };
  }
  link(e) {
    let r = this.rules.inline.link.exec(e);
    if (r) {
      let n = r[2].trim();
      if (!this.options.pedantic && this.rules.other.startAngleBracket.test(n)) {
        if (!this.rules.other.endAngleBracket.test(n)) return;
        let s = ih(n.slice(0, -1), "\\");
        if ((n.length - s.length) % 2 === 0) return;
      } else {
        let s = efe(r[2], "()");
        if (s === -2) return;
        if (s > -1) {
          let o = (r[0].indexOf("!") === 0 ? 5 : 4) + r[1].length + s;
          r[2] = r[2].substring(0, s), r[0] = r[0].substring(0, o).trim(), r[3] = "";
        }
      }
      let a = r[2], i = "";
      if (this.options.pedantic) {
        let s = this.rules.other.pedanticHrefTitle.exec(a);
        s && (a = s[1], i = s[3]);
      } else i = r[3] ? r[3].slice(1, -1) : "";
      return a = a.trim(), this.rules.other.startAngleBracket.test(a) && (this.options.pedantic && !this.rules.other.endAngleBracket.test(n) ? a = a.slice(1) : a = a.slice(1, -1)), GR(r, { href: a && a.replace(this.rules.inline.anyPunctuation, "$1"), title: i && i.replace(this.rules.inline.anyPunctuation, "$1") }, r[0], this.lexer, this.rules);
    }
  }
  reflink(e, r) {
    let n;
    if ((n = this.rules.inline.reflink.exec(e)) || (n = this.rules.inline.nolink.exec(e))) {
      let a = (n[2] || n[1]).replace(this.rules.other.multipleSpaceGlobal, " "), i = r[a.toLowerCase()];
      if (!i) {
        let s = n[0].charAt(0);
        return { type: "text", raw: s, text: s };
      }
      return GR(n, i, n[0], this.lexer, this.rules);
    }
  }
  emStrong(e, r, n = "") {
    let a = this.rules.inline.emStrongLDelim.exec(e);
    if (!(!a || a[3] && n.match(this.rules.other.unicodeAlphaNumeric)) && (!(a[1] || a[2]) || !n || this.rules.inline.punctuation.exec(n))) {
      let i = [...a[0]].length - 1, s, o, l = i, u = 0, c = a[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
      for (c.lastIndex = 0, r = r.slice(-1 * e.length + i); (a = c.exec(r)) != null; ) {
        if (s = a[1] || a[2] || a[3] || a[4] || a[5] || a[6], !s) continue;
        if (o = [...s].length, a[3] || a[4]) {
          l += o;
          continue;
        } else if ((a[5] || a[6]) && i % 3 && !((i + o) % 3)) {
          u += o;
          continue;
        }
        if (l -= o, l > 0) continue;
        o = Math.min(o, o + l + u);
        let f = [...a[0]][0].length, h = e.slice(0, i + a.index + f + o);
        if (Math.min(i, o) % 2) {
          let p = h.slice(1, -1);
          return { type: "em", raw: h, text: p, tokens: this.lexer.inlineTokens(p) };
        }
        let d = h.slice(2, -2);
        return { type: "strong", raw: h, text: d, tokens: this.lexer.inlineTokens(d) };
      }
    }
  }
  codespan(e) {
    let r = this.rules.inline.code.exec(e);
    if (r) {
      let n = r[2].replace(this.rules.other.newLineCharGlobal, " "), a = this.rules.other.nonSpaceChar.test(n), i = this.rules.other.startingSpaceChar.test(n) && this.rules.other.endingSpaceChar.test(n);
      return a && i && (n = n.substring(1, n.length - 1)), { type: "codespan", raw: r[0], text: n };
    }
  }
  br(e) {
    let r = this.rules.inline.br.exec(e);
    if (r) return { type: "br", raw: r[0] };
  }
  del(e) {
    let r = this.rules.inline.del.exec(e);
    if (r) return { type: "del", raw: r[0], text: r[2], tokens: this.lexer.inlineTokens(r[2]) };
  }
  autolink(e) {
    let r = this.rules.inline.autolink.exec(e);
    if (r) {
      let n, a;
      return r[2] === "@" ? (n = r[1], a = "mailto:" + n) : (n = r[1], a = n), { type: "link", raw: r[0], text: n, href: a, tokens: [{ type: "text", raw: n, text: n }] };
    }
  }
  url(e) {
    var n;
    let r;
    if (r = this.rules.inline.url.exec(e)) {
      let a, i;
      if (r[2] === "@") a = r[0], i = "mailto:" + a;
      else {
        let s;
        do
          s = r[0], r[0] = ((n = this.rules.inline._backpedal.exec(r[0])) == null ? void 0 : n[0]) ?? "";
        while (s !== r[0]);
        a = r[0], r[1] === "www." ? i = "http://" + r[0] : i = r[0];
      }
      return { type: "link", raw: r[0], text: a, href: i, tokens: [{ type: "text", raw: a, text: a }] };
    }
  }
  inlineText(e) {
    let r = this.rules.inline.text.exec(e);
    if (r) {
      let n = this.lexer.state.inRawBlock;
      return { type: "text", raw: r[0], text: r[0], escaped: n };
    }
  }
}, Ii = class MT {
  constructor(e) {
    Ye(this, "tokens");
    Ye(this, "options");
    Ye(this, "state");
    Ye(this, "tokenizer");
    Ye(this, "inlineQueue");
    this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = e || Tu, this.options.tokenizer = this.options.tokenizer || new pm(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = { inLink: !1, inRawBlock: !1, top: !0 };
    let r = { other: la, block: Up.normal, inline: ah.normal };
    this.options.pedantic ? (r.block = Up.pedantic, r.inline = ah.pedantic) : this.options.gfm && (r.block = Up.gfm, this.options.breaks ? r.inline = ah.breaks : r.inline = ah.gfm), this.tokenizer.rules = r;
  }
  static get rules() {
    return { block: Up, inline: ah };
  }
  static lex(e, r) {
    return new MT(r).lex(e);
  }
  static lexInline(e, r) {
    return new MT(r).inlineTokens(e);
  }
  lex(e) {
    e = e.replace(la.carriageReturn, `
`), this.blockTokens(e, this.tokens);
    for (let r = 0; r < this.inlineQueue.length; r++) {
      let n = this.inlineQueue[r];
      this.inlineTokens(n.src, n.tokens);
    }
    return this.inlineQueue = [], this.tokens;
  }
  blockTokens(e, r = [], n = !1) {
    var a, i, s;
    for (this.options.pedantic && (e = e.replace(la.tabCharGlobal, "    ").replace(la.spaceLine, "")); e; ) {
      let o;
      if ((i = (a = this.options.extensions) == null ? void 0 : a.block) != null && i.some((u) => (o = u.call({ lexer: this }, e, r)) ? (e = e.substring(o.raw.length), r.push(o), !0) : !1)) continue;
      if (o = this.tokenizer.space(e)) {
        e = e.substring(o.raw.length);
        let u = r.at(-1);
        o.raw.length === 1 && u !== void 0 ? u.raw += `
` : r.push(o);
        continue;
      }
      if (o = this.tokenizer.code(e)) {
        e = e.substring(o.raw.length);
        let u = r.at(-1);
        (u == null ? void 0 : u.type) === "paragraph" || (u == null ? void 0 : u.type) === "text" ? (u.raw += (u.raw.endsWith(`
`) ? "" : `
`) + o.raw, u.text += `
` + o.text, this.inlineQueue.at(-1).src = u.text) : r.push(o);
        continue;
      }
      if (o = this.tokenizer.fences(e)) {
        e = e.substring(o.raw.length), r.push(o);
        continue;
      }
      if (o = this.tokenizer.heading(e)) {
        e = e.substring(o.raw.length), r.push(o);
        continue;
      }
      if (o = this.tokenizer.hr(e)) {
        e = e.substring(o.raw.length), r.push(o);
        continue;
      }
      if (o = this.tokenizer.blockquote(e)) {
        e = e.substring(o.raw.length), r.push(o);
        continue;
      }
      if (o = this.tokenizer.list(e)) {
        e = e.substring(o.raw.length), r.push(o);
        continue;
      }
      if (o = this.tokenizer.html(e)) {
        e = e.substring(o.raw.length), r.push(o);
        continue;
      }
      if (o = this.tokenizer.def(e)) {
        e = e.substring(o.raw.length);
        let u = r.at(-1);
        (u == null ? void 0 : u.type) === "paragraph" || (u == null ? void 0 : u.type) === "text" ? (u.raw += (u.raw.endsWith(`
`) ? "" : `
`) + o.raw, u.text += `
` + o.raw, this.inlineQueue.at(-1).src = u.text) : this.tokens.links[o.tag] || (this.tokens.links[o.tag] = { href: o.href, title: o.title }, r.push(o));
        continue;
      }
      if (o = this.tokenizer.table(e)) {
        e = e.substring(o.raw.length), r.push(o);
        continue;
      }
      if (o = this.tokenizer.lheading(e)) {
        e = e.substring(o.raw.length), r.push(o);
        continue;
      }
      let l = e;
      if ((s = this.options.extensions) != null && s.startBlock) {
        let u = 1 / 0, c = e.slice(1), f;
        this.options.extensions.startBlock.forEach((h) => {
          f = h.call({ lexer: this }, c), typeof f == "number" && f >= 0 && (u = Math.min(u, f));
        }), u < 1 / 0 && u >= 0 && (l = e.substring(0, u + 1));
      }
      if (this.state.top && (o = this.tokenizer.paragraph(l))) {
        let u = r.at(-1);
        n && (u == null ? void 0 : u.type) === "paragraph" ? (u.raw += (u.raw.endsWith(`
`) ? "" : `
`) + o.raw, u.text += `
` + o.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = u.text) : r.push(o), n = l.length !== e.length, e = e.substring(o.raw.length);
        continue;
      }
      if (o = this.tokenizer.text(e)) {
        e = e.substring(o.raw.length);
        let u = r.at(-1);
        (u == null ? void 0 : u.type) === "text" ? (u.raw += (u.raw.endsWith(`
`) ? "" : `
`) + o.raw, u.text += `
` + o.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = u.text) : r.push(o);
        continue;
      }
      if (e) {
        let u = "Infinite loop on byte: " + e.charCodeAt(0);
        if (this.options.silent) {
          console.error(u);
          break;
        } else throw new Error(u);
      }
    }
    return this.state.top = !0, r;
  }
  inline(e, r = []) {
    return this.inlineQueue.push({ src: e, tokens: r }), r;
  }
  inlineTokens(e, r = []) {
    var l, u, c, f, h;
    let n = e, a = null;
    if (this.tokens.links) {
      let d = Object.keys(this.tokens.links);
      if (d.length > 0) for (; (a = this.tokenizer.rules.inline.reflinkSearch.exec(n)) != null; ) d.includes(a[0].slice(a[0].lastIndexOf("[") + 1, -1)) && (n = n.slice(0, a.index) + "[" + "a".repeat(a[0].length - 2) + "]" + n.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
    }
    for (; (a = this.tokenizer.rules.inline.anyPunctuation.exec(n)) != null; ) n = n.slice(0, a.index) + "++" + n.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
    let i;
    for (; (a = this.tokenizer.rules.inline.blockSkip.exec(n)) != null; ) i = a[2] ? a[2].length : 0, n = n.slice(0, a.index + i) + "[" + "a".repeat(a[0].length - i - 2) + "]" + n.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    n = ((u = (l = this.options.hooks) == null ? void 0 : l.emStrongMask) == null ? void 0 : u.call({ lexer: this }, n)) ?? n;
    let s = !1, o = "";
    for (; e; ) {
      s || (o = ""), s = !1;
      let d;
      if ((f = (c = this.options.extensions) == null ? void 0 : c.inline) != null && f.some((g) => (d = g.call({ lexer: this }, e, r)) ? (e = e.substring(d.raw.length), r.push(d), !0) : !1)) continue;
      if (d = this.tokenizer.escape(e)) {
        e = e.substring(d.raw.length), r.push(d);
        continue;
      }
      if (d = this.tokenizer.tag(e)) {
        e = e.substring(d.raw.length), r.push(d);
        continue;
      }
      if (d = this.tokenizer.link(e)) {
        e = e.substring(d.raw.length), r.push(d);
        continue;
      }
      if (d = this.tokenizer.reflink(e, this.tokens.links)) {
        e = e.substring(d.raw.length);
        let g = r.at(-1);
        d.type === "text" && (g == null ? void 0 : g.type) === "text" ? (g.raw += d.raw, g.text += d.text) : r.push(d);
        continue;
      }
      if (d = this.tokenizer.emStrong(e, n, o)) {
        e = e.substring(d.raw.length), r.push(d);
        continue;
      }
      if (d = this.tokenizer.codespan(e)) {
        e = e.substring(d.raw.length), r.push(d);
        continue;
      }
      if (d = this.tokenizer.br(e)) {
        e = e.substring(d.raw.length), r.push(d);
        continue;
      }
      if (d = this.tokenizer.del(e)) {
        e = e.substring(d.raw.length), r.push(d);
        continue;
      }
      if (d = this.tokenizer.autolink(e)) {
        e = e.substring(d.raw.length), r.push(d);
        continue;
      }
      if (!this.state.inLink && (d = this.tokenizer.url(e))) {
        e = e.substring(d.raw.length), r.push(d);
        continue;
      }
      let p = e;
      if ((h = this.options.extensions) != null && h.startInline) {
        let g = 1 / 0, v = e.slice(1), m;
        this.options.extensions.startInline.forEach((b) => {
          m = b.call({ lexer: this }, v), typeof m == "number" && m >= 0 && (g = Math.min(g, m));
        }), g < 1 / 0 && g >= 0 && (p = e.substring(0, g + 1));
      }
      if (d = this.tokenizer.inlineText(p)) {
        e = e.substring(d.raw.length), d.raw.slice(-1) !== "_" && (o = d.raw.slice(-1)), s = !0;
        let g = r.at(-1);
        (g == null ? void 0 : g.type) === "text" ? (g.raw += d.raw, g.text += d.text) : r.push(d);
        continue;
      }
      if (e) {
        let g = "Infinite loop on byte: " + e.charCodeAt(0);
        if (this.options.silent) {
          console.error(g);
          break;
        } else throw new Error(g);
      }
    }
    return r;
  }
}, gm = class {
  constructor(e) {
    Ye(this, "options");
    Ye(this, "parser");
    this.options = e || Tu;
  }
  space(e) {
    return "";
  }
  code({ text: e, lang: r, escaped: n }) {
    var s;
    let a = (s = (r || "").match(la.notSpaceStart)) == null ? void 0 : s[0], i = e.replace(la.endingNewline, "") + `
`;
    return a ? '<pre><code class="language-' + as(a) + '">' + (n ? i : as(i, !0)) + `</code></pre>
` : "<pre><code>" + (n ? i : as(i, !0)) + `</code></pre>
`;
  }
  blockquote({ tokens: e }) {
    return `<blockquote>
${this.parser.parse(e)}</blockquote>
`;
  }
  html({ text: e }) {
    return e;
  }
  def(e) {
    return "";
  }
  heading({ tokens: e, depth: r }) {
    return `<h${r}>${this.parser.parseInline(e)}</h${r}>
`;
  }
  hr(e) {
    return `<hr>
`;
  }
  list(e) {
    let r = e.ordered, n = e.start, a = "";
    for (let o = 0; o < e.items.length; o++) {
      let l = e.items[o];
      a += this.listitem(l);
    }
    let i = r ? "ol" : "ul", s = r && n !== 1 ? ' start="' + n + '"' : "";
    return "<" + i + s + `>
` + a + "</" + i + `>
`;
  }
  listitem(e) {
    var n;
    let r = "";
    if (e.task) {
      let a = this.checkbox({ checked: !!e.checked });
      e.loose ? ((n = e.tokens[0]) == null ? void 0 : n.type) === "paragraph" ? (e.tokens[0].text = a + " " + e.tokens[0].text, e.tokens[0].tokens && e.tokens[0].tokens.length > 0 && e.tokens[0].tokens[0].type === "text" && (e.tokens[0].tokens[0].text = a + " " + as(e.tokens[0].tokens[0].text), e.tokens[0].tokens[0].escaped = !0)) : e.tokens.unshift({ type: "text", raw: a + " ", text: a + " ", escaped: !0 }) : r += a + " ";
    }
    return r += this.parser.parse(e.tokens, !!e.loose), `<li>${r}</li>
`;
  }
  checkbox({ checked: e }) {
    return "<input " + (e ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
  }
  paragraph({ tokens: e }) {
    return `<p>${this.parser.parseInline(e)}</p>
`;
  }
  table(e) {
    let r = "", n = "";
    for (let i = 0; i < e.header.length; i++) n += this.tablecell(e.header[i]);
    r += this.tablerow({ text: n });
    let a = "";
    for (let i = 0; i < e.rows.length; i++) {
      let s = e.rows[i];
      n = "";
      for (let o = 0; o < s.length; o++) n += this.tablecell(s[o]);
      a += this.tablerow({ text: n });
    }
    return a && (a = `<tbody>${a}</tbody>`), `<table>
<thead>
` + r + `</thead>
` + a + `</table>
`;
  }
  tablerow({ text: e }) {
    return `<tr>
${e}</tr>
`;
  }
  tablecell(e) {
    let r = this.parser.parseInline(e.tokens), n = e.header ? "th" : "td";
    return (e.align ? `<${n} align="${e.align}">` : `<${n}>`) + r + `</${n}>
`;
  }
  strong({ tokens: e }) {
    return `<strong>${this.parser.parseInline(e)}</strong>`;
  }
  em({ tokens: e }) {
    return `<em>${this.parser.parseInline(e)}</em>`;
  }
  codespan({ text: e }) {
    return `<code>${as(e, !0)}</code>`;
  }
  br(e) {
    return "<br>";
  }
  del({ tokens: e }) {
    return `<del>${this.parser.parseInline(e)}</del>`;
  }
  link({ href: e, title: r, tokens: n }) {
    let a = this.parser.parseInline(n), i = BR(e);
    if (i === null) return a;
    e = i;
    let s = '<a href="' + e + '"';
    return r && (s += ' title="' + as(r) + '"'), s += ">" + a + "</a>", s;
  }
  image({ href: e, title: r, text: n, tokens: a }) {
    a && (n = this.parser.parseInline(a, this.parser.textRenderer));
    let i = BR(e);
    if (i === null) return as(n);
    e = i;
    let s = `<img src="${e}" alt="${n}"`;
    return r && (s += ` title="${as(r)}"`), s += ">", s;
  }
  text(e) {
    return "tokens" in e && e.tokens ? this.parser.parseInline(e.tokens) : "escaped" in e && e.escaped ? e.text : as(e.text);
  }
}, F5 = class {
  strong({ text: e }) {
    return e;
  }
  em({ text: e }) {
    return e;
  }
  codespan({ text: e }) {
    return e;
  }
  del({ text: e }) {
    return e;
  }
  html({ text: e }) {
    return e;
  }
  text({ text: e }) {
    return e;
  }
  link({ text: e }) {
    return "" + e;
  }
  image({ text: e }) {
    return "" + e;
  }
  br() {
    return "";
  }
}, Pi = class _T {
  constructor(e) {
    Ye(this, "options");
    Ye(this, "renderer");
    Ye(this, "textRenderer");
    this.options = e || Tu, this.options.renderer = this.options.renderer || new gm(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.renderer.parser = this, this.textRenderer = new F5();
  }
  static parse(e, r) {
    return new _T(r).parse(e);
  }
  static parseInline(e, r) {
    return new _T(r).parseInline(e);
  }
  parse(e, r = !0) {
    var a, i;
    let n = "";
    for (let s = 0; s < e.length; s++) {
      let o = e[s];
      if ((i = (a = this.options.extensions) == null ? void 0 : a.renderers) != null && i[o.type]) {
        let u = o, c = this.options.extensions.renderers[u.type].call({ parser: this }, u);
        if (c !== !1 || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "def", "paragraph", "text"].includes(u.type)) {
          n += c || "";
          continue;
        }
      }
      let l = o;
      switch (l.type) {
        case "space": {
          n += this.renderer.space(l);
          continue;
        }
        case "hr": {
          n += this.renderer.hr(l);
          continue;
        }
        case "heading": {
          n += this.renderer.heading(l);
          continue;
        }
        case "code": {
          n += this.renderer.code(l);
          continue;
        }
        case "table": {
          n += this.renderer.table(l);
          continue;
        }
        case "blockquote": {
          n += this.renderer.blockquote(l);
          continue;
        }
        case "list": {
          n += this.renderer.list(l);
          continue;
        }
        case "html": {
          n += this.renderer.html(l);
          continue;
        }
        case "def": {
          n += this.renderer.def(l);
          continue;
        }
        case "paragraph": {
          n += this.renderer.paragraph(l);
          continue;
        }
        case "text": {
          let u = l, c = this.renderer.text(u);
          for (; s + 1 < e.length && e[s + 1].type === "text"; ) u = e[++s], c += `
` + this.renderer.text(u);
          r ? n += this.renderer.paragraph({ type: "paragraph", raw: c, text: c, tokens: [{ type: "text", raw: c, text: c, escaped: !0 }] }) : n += c;
          continue;
        }
        default: {
          let u = 'Token with "' + l.type + '" type was not found.';
          if (this.options.silent) return console.error(u), "";
          throw new Error(u);
        }
      }
    }
    return n;
  }
  parseInline(e, r = this.renderer) {
    var a, i;
    let n = "";
    for (let s = 0; s < e.length; s++) {
      let o = e[s];
      if ((i = (a = this.options.extensions) == null ? void 0 : a.renderers) != null && i[o.type]) {
        let u = this.options.extensions.renderers[o.type].call({ parser: this }, o);
        if (u !== !1 || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(o.type)) {
          n += u || "";
          continue;
        }
      }
      let l = o;
      switch (l.type) {
        case "escape": {
          n += r.text(l);
          break;
        }
        case "html": {
          n += r.html(l);
          break;
        }
        case "link": {
          n += r.link(l);
          break;
        }
        case "image": {
          n += r.image(l);
          break;
        }
        case "strong": {
          n += r.strong(l);
          break;
        }
        case "em": {
          n += r.em(l);
          break;
        }
        case "codespan": {
          n += r.codespan(l);
          break;
        }
        case "br": {
          n += r.br(l);
          break;
        }
        case "del": {
          n += r.del(l);
          break;
        }
        case "text": {
          n += r.text(l);
          break;
        }
        default: {
          let u = 'Token with "' + l.type + '" type was not found.';
          if (this.options.silent) return console.error(u), "";
          throw new Error(u);
        }
      }
    }
    return n;
  }
}, Hg, Ch = (Hg = class {
  constructor(e) {
    Ye(this, "options");
    Ye(this, "block");
    this.options = e || Tu;
  }
  preprocess(e) {
    return e;
  }
  postprocess(e) {
    return e;
  }
  processAllTokens(e) {
    return e;
  }
  emStrongMask(e) {
    return e;
  }
  provideLexer() {
    return this.block ? Ii.lex : Ii.lexInline;
  }
  provideParser() {
    return this.block ? Pi.parse : Pi.parseInline;
  }
}, Ye(Hg, "passThroughHooks", /* @__PURE__ */ new Set(["preprocess", "postprocess", "processAllTokens", "emStrongMask"])), Ye(Hg, "passThroughHooksRespectAsync", /* @__PURE__ */ new Set(["preprocess", "postprocess", "processAllTokens"])), Hg), rfe = class {
  constructor(...e) {
    Ye(this, "defaults", _5());
    Ye(this, "options", this.setOptions);
    Ye(this, "parse", this.parseMarkdown(!0));
    Ye(this, "parseInline", this.parseMarkdown(!1));
    Ye(this, "Parser", Pi);
    Ye(this, "Renderer", gm);
    Ye(this, "TextRenderer", F5);
    Ye(this, "Lexer", Ii);
    Ye(this, "Tokenizer", pm);
    Ye(this, "Hooks", Ch);
    this.use(...e);
  }
  walkTokens(e, r) {
    var a, i;
    let n = [];
    for (let s of e) switch (n = n.concat(r.call(this, s)), s.type) {
      case "table": {
        let o = s;
        for (let l of o.header) n = n.concat(this.walkTokens(l.tokens, r));
        for (let l of o.rows) for (let u of l) n = n.concat(this.walkTokens(u.tokens, r));
        break;
      }
      case "list": {
        let o = s;
        n = n.concat(this.walkTokens(o.items, r));
        break;
      }
      default: {
        let o = s;
        (i = (a = this.defaults.extensions) == null ? void 0 : a.childTokens) != null && i[o.type] ? this.defaults.extensions.childTokens[o.type].forEach((l) => {
          let u = o[l].flat(1 / 0);
          n = n.concat(this.walkTokens(u, r));
        }) : o.tokens && (n = n.concat(this.walkTokens(o.tokens, r)));
      }
    }
    return n;
  }
  use(...e) {
    let r = this.defaults.extensions || { renderers: {}, childTokens: {} };
    return e.forEach((n) => {
      let a = { ...n };
      if (a.async = this.defaults.async || a.async || !1, n.extensions && (n.extensions.forEach((i) => {
        if (!i.name) throw new Error("extension name required");
        if ("renderer" in i) {
          let s = r.renderers[i.name];
          s ? r.renderers[i.name] = function(...o) {
            let l = i.renderer.apply(this, o);
            return l === !1 && (l = s.apply(this, o)), l;
          } : r.renderers[i.name] = i.renderer;
        }
        if ("tokenizer" in i) {
          if (!i.level || i.level !== "block" && i.level !== "inline") throw new Error("extension level must be 'block' or 'inline'");
          let s = r[i.level];
          s ? s.unshift(i.tokenizer) : r[i.level] = [i.tokenizer], i.start && (i.level === "block" ? r.startBlock ? r.startBlock.push(i.start) : r.startBlock = [i.start] : i.level === "inline" && (r.startInline ? r.startInline.push(i.start) : r.startInline = [i.start]));
        }
        "childTokens" in i && i.childTokens && (r.childTokens[i.name] = i.childTokens);
      }), a.extensions = r), n.renderer) {
        let i = this.defaults.renderer || new gm(this.defaults);
        for (let s in n.renderer) {
          if (!(s in i)) throw new Error(`renderer '${s}' does not exist`);
          if (["options", "parser"].includes(s)) continue;
          let o = s, l = n.renderer[o], u = i[o];
          i[o] = (...c) => {
            let f = l.apply(i, c);
            return f === !1 && (f = u.apply(i, c)), f || "";
          };
        }
        a.renderer = i;
      }
      if (n.tokenizer) {
        let i = this.defaults.tokenizer || new pm(this.defaults);
        for (let s in n.tokenizer) {
          if (!(s in i)) throw new Error(`tokenizer '${s}' does not exist`);
          if (["options", "rules", "lexer"].includes(s)) continue;
          let o = s, l = n.tokenizer[o], u = i[o];
          i[o] = (...c) => {
            let f = l.apply(i, c);
            return f === !1 && (f = u.apply(i, c)), f;
          };
        }
        a.tokenizer = i;
      }
      if (n.hooks) {
        let i = this.defaults.hooks || new Ch();
        for (let s in n.hooks) {
          if (!(s in i)) throw new Error(`hook '${s}' does not exist`);
          if (["options", "block"].includes(s)) continue;
          let o = s, l = n.hooks[o], u = i[o];
          Ch.passThroughHooks.has(s) ? i[o] = (c) => {
            if (this.defaults.async && Ch.passThroughHooksRespectAsync.has(s)) return (async () => {
              let h = await l.call(i, c);
              return u.call(i, h);
            })();
            let f = l.call(i, c);
            return u.call(i, f);
          } : i[o] = (...c) => {
            if (this.defaults.async) return (async () => {
              let h = await l.apply(i, c);
              return h === !1 && (h = await u.apply(i, c)), h;
            })();
            let f = l.apply(i, c);
            return f === !1 && (f = u.apply(i, c)), f;
          };
        }
        a.hooks = i;
      }
      if (n.walkTokens) {
        let i = this.defaults.walkTokens, s = n.walkTokens;
        a.walkTokens = function(o) {
          let l = [];
          return l.push(s.call(this, o)), i && (l = l.concat(i.call(this, o))), l;
        };
      }
      this.defaults = { ...this.defaults, ...a };
    }), this;
  }
  setOptions(e) {
    return this.defaults = { ...this.defaults, ...e }, this;
  }
  lexer(e, r) {
    return Ii.lex(e, r ?? this.defaults);
  }
  parser(e, r) {
    return Pi.parse(e, r ?? this.defaults);
  }
  parseMarkdown(e) {
    return (r, n) => {
      let a = { ...n }, i = { ...this.defaults, ...a }, s = this.onError(!!i.silent, !!i.async);
      if (this.defaults.async === !0 && a.async === !1) return s(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
      if (typeof r > "u" || r === null) return s(new Error("marked(): input parameter is undefined or null"));
      if (typeof r != "string") return s(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(r) + ", string expected"));
      if (i.hooks && (i.hooks.options = i, i.hooks.block = e), i.async) return (async () => {
        let o = i.hooks ? await i.hooks.preprocess(r) : r, l = await (i.hooks ? await i.hooks.provideLexer() : e ? Ii.lex : Ii.lexInline)(o, i), u = i.hooks ? await i.hooks.processAllTokens(l) : l;
        i.walkTokens && await Promise.all(this.walkTokens(u, i.walkTokens));
        let c = await (i.hooks ? await i.hooks.provideParser() : e ? Pi.parse : Pi.parseInline)(u, i);
        return i.hooks ? await i.hooks.postprocess(c) : c;
      })().catch(s);
      try {
        i.hooks && (r = i.hooks.preprocess(r));
        let o = (i.hooks ? i.hooks.provideLexer() : e ? Ii.lex : Ii.lexInline)(r, i);
        i.hooks && (o = i.hooks.processAllTokens(o)), i.walkTokens && this.walkTokens(o, i.walkTokens);
        let l = (i.hooks ? i.hooks.provideParser() : e ? Pi.parse : Pi.parseInline)(o, i);
        return i.hooks && (l = i.hooks.postprocess(l)), l;
      } catch (o) {
        return s(o);
      }
    };
  }
  onError(e, r) {
    return (n) => {
      if (n.message += `
Please report this to https://github.com/markedjs/marked.`, e) {
        let a = "<p>An error occurred:</p><pre>" + as(n.message + "", !0) + "</pre>";
        return r ? Promise.resolve(a) : a;
      }
      if (r) return Promise.reject(n);
      throw n;
    };
  }
}, eu = new rfe();
function Er(t, e) {
  return eu.parse(t, e);
}
Er.options = Er.setOptions = function(t) {
  return eu.setOptions(t), Er.defaults = eu.defaults, H9(Er.defaults), Er;
};
Er.getDefaults = _5;
Er.defaults = Tu;
Er.use = function(...t) {
  return eu.use(...t), Er.defaults = eu.defaults, H9(Er.defaults), Er;
};
Er.walkTokens = function(t, e) {
  return eu.walkTokens(t, e);
};
Er.parseInline = eu.parseInline;
Er.Parser = Pi;
Er.parser = Pi.parse;
Er.Renderer = gm;
Er.TextRenderer = F5;
Er.Lexer = Ii;
Er.lexer = Ii.lex;
Er.Tokenizer = pm;
Er.Hooks = Ch;
Er.parse = Er;
Er.options;
Er.setOptions;
Er.use;
Er.walkTokens;
Er.parseInline;
Pi.parse;
Ii.lex;
function G_e(t) {
  for (var e = [], r = 1; r < arguments.length; r++)
    e[r - 1] = arguments[r];
  var n = Array.from(typeof t == "string" ? [t] : t);
  n[n.length - 1] = n[n.length - 1].replace(/\r?\n([\t ]*)$/, "");
  var a = n.reduce(function(o, l) {
    var u = l.match(/\n([\t ]+|(?!\s).)/g);
    return u ? o.concat(u.map(function(c) {
      var f, h;
      return (h = (f = c.match(/[\t ]/g)) === null || f === void 0 ? void 0 : f.length) !== null && h !== void 0 ? h : 0;
    })) : o;
  }, []);
  if (a.length) {
    var i = new RegExp(`
[	 ]{` + Math.min.apply(Math, a) + "}", "g");
    n = n.map(function(o) {
      return o.replace(i, `
`);
    });
  }
  n[0] = n[0].replace(/^\r?\n/, "");
  var s = n[0];
  return e.forEach(function(o, l) {
    var u = s.match(/(?:^|\n)( *)$/), c = u ? u[1] : "", f = o;
    typeof o == "string" && o.includes(`
`) && (f = String(o).split(`
`).map(function(h, d) {
      return d === 0 ? h : "" + c + h;
    }).join(`
`)), s += f + n[l + 1];
  }), s;
}
function yx(t, e, r) {
  if (t && t.length) {
    const [n, a] = e, i = Math.PI / 180 * r, s = Math.cos(i), o = Math.sin(i);
    for (const l of t) {
      const [u, c] = l;
      l[0] = (u - n) * s - (c - a) * o + n, l[1] = (u - n) * o + (c - a) * s + a;
    }
  }
}
function nfe(t, e) {
  return t[0] === e[0] && t[1] === e[1];
}
function afe(t, e, r, n = 1) {
  const a = r, i = Math.max(e, 0.1), s = t[0] && t[0][0] && typeof t[0][0] == "number" ? [t] : t, o = [0, 0];
  if (a) for (const u of s) yx(u, o, a);
  const l = function(u, c, f) {
    const h = [];
    for (const b of u) {
      const y = [...b];
      nfe(y[0], y[y.length - 1]) || y.push([y[0][0], y[0][1]]), y.length > 2 && h.push(y);
    }
    const d = [];
    c = Math.max(c, 0.1);
    const p = [];
    for (const b of h) for (let y = 0; y < b.length - 1; y++) {
      const x = b[y], E = b[y + 1];
      if (x[1] !== E[1]) {
        const S = Math.min(x[1], E[1]);
        p.push({ ymin: S, ymax: Math.max(x[1], E[1]), x: S === x[1] ? x[0] : E[0], islope: (E[0] - x[0]) / (E[1] - x[1]) });
      }
    }
    if (p.sort((b, y) => b.ymin < y.ymin ? -1 : b.ymin > y.ymin ? 1 : b.x < y.x ? -1 : b.x > y.x ? 1 : b.ymax === y.ymax ? 0 : (b.ymax - y.ymax) / Math.abs(b.ymax - y.ymax)), !p.length) return d;
    let g = [], v = p[0].ymin, m = 0;
    for (; g.length || p.length; ) {
      if (p.length) {
        let b = -1;
        for (let y = 0; y < p.length && !(p[y].ymin > v); y++) b = y;
        p.splice(0, b + 1).forEach((y) => {
          g.push({ s: v, edge: y });
        });
      }
      if (g = g.filter((b) => !(b.edge.ymax <= v)), g.sort((b, y) => b.edge.x === y.edge.x ? 0 : (b.edge.x - y.edge.x) / Math.abs(b.edge.x - y.edge.x)), (f !== 1 || m % c == 0) && g.length > 1) for (let b = 0; b < g.length; b += 2) {
        const y = b + 1;
        if (y >= g.length) break;
        const x = g[b].edge, E = g[y].edge;
        d.push([[Math.round(x.x), v], [Math.round(E.x), v]]);
      }
      v += f, g.forEach((b) => {
        b.edge.x = b.edge.x + f * b.edge.islope;
      }), m++;
    }
    return d;
  }(s, i, n);
  if (a) {
    for (const u of s) yx(u, o, -a);
    (function(u, c, f) {
      const h = [];
      u.forEach((d) => h.push(...d)), yx(h, c, f);
    })(l, o, -a);
  }
  return l;
}
function X0(t, e) {
  var r;
  const n = e.hachureAngle + 90;
  let a = e.hachureGap;
  a < 0 && (a = 4 * e.strokeWidth), a = Math.round(Math.max(a, 0.1));
  let i = 1;
  return e.roughness >= 1 && (((r = e.randomizer) === null || r === void 0 ? void 0 : r.next()) || Math.random()) > 0.7 && (i = a), afe(t, a, n, i || 1);
}
class B5 {
  constructor(e) {
    this.helper = e;
  }
  fillPolygons(e, r) {
    return this._fillPolygons(e, r);
  }
  _fillPolygons(e, r) {
    const n = X0(e, r);
    return { type: "fillSketch", ops: this.renderLines(n, r) };
  }
  renderLines(e, r) {
    const n = [];
    for (const a of e) n.push(...this.helper.doubleLineOps(a[0][0], a[0][1], a[1][0], a[1][1], r));
    return n;
  }
}
function x1(t) {
  const e = t[0], r = t[1];
  return Math.sqrt(Math.pow(e[0] - r[0], 2) + Math.pow(e[1] - r[1], 2));
}
class ife extends B5 {
  fillPolygons(e, r) {
    let n = r.hachureGap;
    n < 0 && (n = 4 * r.strokeWidth), n = Math.max(n, 0.1);
    const a = X0(e, Object.assign({}, r, { hachureGap: n })), i = Math.PI / 180 * r.hachureAngle, s = [], o = 0.5 * n * Math.cos(i), l = 0.5 * n * Math.sin(i);
    for (const [u, c] of a) x1([u, c]) && s.push([[u[0] - o, u[1] + l], [...c]], [[u[0] + o, u[1] - l], [...c]]);
    return { type: "fillSketch", ops: this.renderLines(s, r) };
  }
}
class sfe extends B5 {
  fillPolygons(e, r) {
    const n = this._fillPolygons(e, r), a = Object.assign({}, r, { hachureAngle: r.hachureAngle + 90 }), i = this._fillPolygons(e, a);
    return n.ops = n.ops.concat(i.ops), n;
  }
}
let ofe = class {
  constructor(e) {
    this.helper = e;
  }
  fillPolygons(e, r) {
    const n = X0(e, r = Object.assign({}, r, { hachureAngle: 0 }));
    return this.dotsOnLines(n, r);
  }
  dotsOnLines(e, r) {
    const n = [];
    let a = r.hachureGap;
    a < 0 && (a = 4 * r.strokeWidth), a = Math.max(a, 0.1);
    let i = r.fillWeight;
    i < 0 && (i = r.strokeWidth / 2);
    const s = a / 4;
    for (const o of e) {
      const l = x1(o), u = l / a, c = Math.ceil(u) - 1, f = l - c * a, h = (o[0][0] + o[1][0]) / 2 - a / 4, d = Math.min(o[0][1], o[1][1]);
      for (let p = 0; p < c; p++) {
        const g = d + f + p * a, v = h - s + 2 * Math.random() * s, m = g - s + 2 * Math.random() * s, b = this.helper.ellipse(v, m, i, i, r);
        n.push(...b.ops);
      }
    }
    return { type: "fillSketch", ops: n };
  }
};
class lfe {
  constructor(e) {
    this.helper = e;
  }
  fillPolygons(e, r) {
    const n = X0(e, r);
    return { type: "fillSketch", ops: this.dashedLine(n, r) };
  }
  dashedLine(e, r) {
    const n = r.dashOffset < 0 ? r.hachureGap < 0 ? 4 * r.strokeWidth : r.hachureGap : r.dashOffset, a = r.dashGap < 0 ? r.hachureGap < 0 ? 4 * r.strokeWidth : r.hachureGap : r.dashGap, i = [];
    return e.forEach((s) => {
      const o = x1(s), l = Math.floor(o / (n + a)), u = (o + a - l * (n + a)) / 2;
      let c = s[0], f = s[1];
      c[0] > f[0] && (c = s[1], f = s[0]);
      const h = Math.atan((f[1] - c[1]) / (f[0] - c[0]));
      for (let d = 0; d < l; d++) {
        const p = d * (n + a), g = p + n, v = [c[0] + p * Math.cos(h) + u * Math.cos(h), c[1] + p * Math.sin(h) + u * Math.sin(h)], m = [c[0] + g * Math.cos(h) + u * Math.cos(h), c[1] + g * Math.sin(h) + u * Math.sin(h)];
        i.push(...this.helper.doubleLineOps(v[0], v[1], m[0], m[1], r));
      }
    }), i;
  }
}
class ufe {
  constructor(e) {
    this.helper = e;
  }
  fillPolygons(e, r) {
    const n = r.hachureGap < 0 ? 4 * r.strokeWidth : r.hachureGap, a = r.zigzagOffset < 0 ? n : r.zigzagOffset, i = X0(e, r = Object.assign({}, r, { hachureGap: n + a }));
    return { type: "fillSketch", ops: this.zigzagLines(i, a, r) };
  }
  zigzagLines(e, r, n) {
    const a = [];
    return e.forEach((i) => {
      const s = x1(i), o = Math.round(s / (2 * r));
      let l = i[0], u = i[1];
      l[0] > u[0] && (l = i[1], u = i[0]);
      const c = Math.atan((u[1] - l[1]) / (u[0] - l[0]));
      for (let f = 0; f < o; f++) {
        const h = 2 * f * r, d = 2 * (f + 1) * r, p = Math.sqrt(2 * Math.pow(r, 2)), g = [l[0] + h * Math.cos(c), l[1] + h * Math.sin(c)], v = [l[0] + d * Math.cos(c), l[1] + d * Math.sin(c)], m = [g[0] + p * Math.cos(c + Math.PI / 4), g[1] + p * Math.sin(c + Math.PI / 4)];
        a.push(...this.helper.doubleLineOps(g[0], g[1], m[0], m[1], n), ...this.helper.doubleLineOps(m[0], m[1], v[0], v[1], n));
      }
    }), a;
  }
}
const xa = {};
let cfe = class {
  constructor(e) {
    this.seed = e;
  }
  next() {
    return this.seed ? (2 ** 31 - 1 & (this.seed = Math.imul(48271, this.seed))) / 2 ** 31 : Math.random();
  }
};
const ffe = 0, bx = 1, UR = 2, Hp = { A: 7, a: 7, C: 6, c: 6, H: 1, h: 1, L: 2, l: 2, M: 2, m: 2, Q: 4, q: 4, S: 4, s: 4, T: 2, t: 2, V: 1, v: 1, Z: 0, z: 0 };
function xx(t, e) {
  return t.type === e;
}
function z5(t) {
  const e = [], r = function(s) {
    const o = new Array();
    for (; s !== ""; ) if (s.match(/^([ \t\r\n,]+)/)) s = s.substr(RegExp.$1.length);
    else if (s.match(/^([aAcChHlLmMqQsStTvVzZ])/)) o[o.length] = { type: ffe, text: RegExp.$1 }, s = s.substr(RegExp.$1.length);
    else {
      if (!s.match(/^(([-+]?[0-9]+(\.[0-9]*)?|[-+]?\.[0-9]+)([eE][-+]?[0-9]+)?)/)) return [];
      o[o.length] = { type: bx, text: `${parseFloat(RegExp.$1)}` }, s = s.substr(RegExp.$1.length);
    }
    return o[o.length] = { type: UR, text: "" }, o;
  }(t);
  let n = "BOD", a = 0, i = r[a];
  for (; !xx(i, UR); ) {
    let s = 0;
    const o = [];
    if (n === "BOD") {
      if (i.text !== "M" && i.text !== "m") return z5("M0,0" + t);
      a++, s = Hp[i.text], n = i.text;
    } else xx(i, bx) ? s = Hp[n] : (a++, s = Hp[i.text], n = i.text);
    if (!(a + s < r.length)) throw new Error("Path data ended short");
    for (let l = a; l < a + s; l++) {
      const u = r[l];
      if (!xx(u, bx)) throw new Error("Param not a number: " + n + "," + u.text);
      o[o.length] = +u.text;
    }
    if (typeof Hp[n] != "number") throw new Error("Bad segment: " + n);
    {
      const l = { key: n, data: o };
      e.push(l), a += s, i = r[a], n === "M" && (n = "L"), n === "m" && (n = "l");
    }
  }
  return e;
}
function eD(t) {
  let e = 0, r = 0, n = 0, a = 0;
  const i = [];
  for (const { key: s, data: o } of t) switch (s) {
    case "M":
      i.push({ key: "M", data: [...o] }), [e, r] = o, [n, a] = o;
      break;
    case "m":
      e += o[0], r += o[1], i.push({ key: "M", data: [e, r] }), n = e, a = r;
      break;
    case "L":
      i.push({ key: "L", data: [...o] }), [e, r] = o;
      break;
    case "l":
      e += o[0], r += o[1], i.push({ key: "L", data: [e, r] });
      break;
    case "C":
      i.push({ key: "C", data: [...o] }), e = o[4], r = o[5];
      break;
    case "c": {
      const l = o.map((u, c) => c % 2 ? u + r : u + e);
      i.push({ key: "C", data: l }), e = l[4], r = l[5];
      break;
    }
    case "Q":
      i.push({ key: "Q", data: [...o] }), e = o[2], r = o[3];
      break;
    case "q": {
      const l = o.map((u, c) => c % 2 ? u + r : u + e);
      i.push({ key: "Q", data: l }), e = l[2], r = l[3];
      break;
    }
    case "A":
      i.push({ key: "A", data: [...o] }), e = o[5], r = o[6];
      break;
    case "a":
      e += o[5], r += o[6], i.push({ key: "A", data: [o[0], o[1], o[2], o[3], o[4], e, r] });
      break;
    case "H":
      i.push({ key: "H", data: [...o] }), e = o[0];
      break;
    case "h":
      e += o[0], i.push({ key: "H", data: [e] });
      break;
    case "V":
      i.push({ key: "V", data: [...o] }), r = o[0];
      break;
    case "v":
      r += o[0], i.push({ key: "V", data: [r] });
      break;
    case "S":
      i.push({ key: "S", data: [...o] }), e = o[2], r = o[3];
      break;
    case "s": {
      const l = o.map((u, c) => c % 2 ? u + r : u + e);
      i.push({ key: "S", data: l }), e = l[2], r = l[3];
      break;
    }
    case "T":
      i.push({ key: "T", data: [...o] }), e = o[0], r = o[1];
      break;
    case "t":
      e += o[0], r += o[1], i.push({ key: "T", data: [e, r] });
      break;
    case "Z":
    case "z":
      i.push({ key: "Z", data: [] }), e = n, r = a;
  }
  return i;
}
function tD(t) {
  const e = [];
  let r = "", n = 0, a = 0, i = 0, s = 0, o = 0, l = 0;
  for (const { key: u, data: c } of t) {
    switch (u) {
      case "M":
        e.push({ key: "M", data: [...c] }), [n, a] = c, [i, s] = c;
        break;
      case "C":
        e.push({ key: "C", data: [...c] }), n = c[4], a = c[5], o = c[2], l = c[3];
        break;
      case "L":
        e.push({ key: "L", data: [...c] }), [n, a] = c;
        break;
      case "H":
        n = c[0], e.push({ key: "L", data: [n, a] });
        break;
      case "V":
        a = c[0], e.push({ key: "L", data: [n, a] });
        break;
      case "S": {
        let f = 0, h = 0;
        r === "C" || r === "S" ? (f = n + (n - o), h = a + (a - l)) : (f = n, h = a), e.push({ key: "C", data: [f, h, ...c] }), o = c[0], l = c[1], n = c[2], a = c[3];
        break;
      }
      case "T": {
        const [f, h] = c;
        let d = 0, p = 0;
        r === "Q" || r === "T" ? (d = n + (n - o), p = a + (a - l)) : (d = n, p = a);
        const g = n + 2 * (d - n) / 3, v = a + 2 * (p - a) / 3, m = f + 2 * (d - f) / 3, b = h + 2 * (p - h) / 3;
        e.push({ key: "C", data: [g, v, m, b, f, h] }), o = d, l = p, n = f, a = h;
        break;
      }
      case "Q": {
        const [f, h, d, p] = c, g = n + 2 * (f - n) / 3, v = a + 2 * (h - a) / 3, m = d + 2 * (f - d) / 3, b = p + 2 * (h - p) / 3;
        e.push({ key: "C", data: [g, v, m, b, d, p] }), o = f, l = h, n = d, a = p;
        break;
      }
      case "A": {
        const f = Math.abs(c[0]), h = Math.abs(c[1]), d = c[2], p = c[3], g = c[4], v = c[5], m = c[6];
        f === 0 || h === 0 ? (e.push({ key: "C", data: [n, a, v, m, v, m] }), n = v, a = m) : (n !== v || a !== m) && (rD(n, a, v, m, f, h, d, p, g).forEach(function(b) {
          e.push({ key: "C", data: b });
        }), n = v, a = m);
        break;
      }
      case "Z":
        e.push({ key: "Z", data: [] }), n = i, a = s;
    }
    r = u;
  }
  return e;
}
function sh(t, e, r) {
  return [t * Math.cos(r) - e * Math.sin(r), t * Math.sin(r) + e * Math.cos(r)];
}
function rD(t, e, r, n, a, i, s, o, l, u) {
  const c = (f = s, Math.PI * f / 180);
  var f;
  let h = [], d = 0, p = 0, g = 0, v = 0;
  if (u) [d, p, g, v] = u;
  else {
    [t, e] = sh(t, e, -c), [r, n] = sh(r, n, -c);
    const O = (t - r) / 2, T = (e - n) / 2;
    let L = O * O / (a * a) + T * T / (i * i);
    L > 1 && (L = Math.sqrt(L), a *= L, i *= L);
    const M = a * a, A = i * i, I = M * A - M * T * T - A * O * O, D = M * T * T + A * O * O, F = (o === l ? -1 : 1) * Math.sqrt(Math.abs(I / D));
    g = F * a * T / i + (t + r) / 2, v = F * -i * O / a + (e + n) / 2, d = Math.asin(parseFloat(((e - v) / i).toFixed(9))), p = Math.asin(parseFloat(((n - v) / i).toFixed(9))), t < g && (d = Math.PI - d), r < g && (p = Math.PI - p), d < 0 && (d = 2 * Math.PI + d), p < 0 && (p = 2 * Math.PI + p), l && d > p && (d -= 2 * Math.PI), !l && p > d && (p -= 2 * Math.PI);
  }
  let m = p - d;
  if (Math.abs(m) > 120 * Math.PI / 180) {
    const O = p, T = r, L = n;
    p = l && p > d ? d + 120 * Math.PI / 180 * 1 : d + 120 * Math.PI / 180 * -1, h = rD(r = g + a * Math.cos(p), n = v + i * Math.sin(p), T, L, a, i, s, 0, l, [p, O, g, v]);
  }
  m = p - d;
  const b = Math.cos(d), y = Math.sin(d), x = Math.cos(p), E = Math.sin(p), S = Math.tan(m / 4), w = 4 / 3 * a * S, C = 4 / 3 * i * S, k = [t, e], N = [t + w * y, e - C * b], R = [r + w * E, n - C * x], _ = [r, n];
  if (N[0] = 2 * k[0] - N[0], N[1] = 2 * k[1] - N[1], u) return [N, R, _].concat(h);
  {
    h = [N, R, _].concat(h);
    const O = [];
    for (let T = 0; T < h.length; T += 3) {
      const L = sh(h[T][0], h[T][1], c), M = sh(h[T + 1][0], h[T + 1][1], c), A = sh(h[T + 2][0], h[T + 2][1], c);
      O.push([L[0], L[1], M[0], M[1], A[0], A[1]]);
    }
    return O;
  }
}
const hfe = { randOffset: function(t, e) {
  return Mt(t, e);
}, randOffsetWithRange: function(t, e, r) {
  return vm(t, e, r);
}, ellipse: function(t, e, r, n, a) {
  const i = aD(r, n, a);
  return LT(t, e, a, i).opset;
}, doubleLineOps: function(t, e, r, n, a) {
  return Uo(t, e, r, n, a, !0);
} };
function nD(t, e, r, n, a) {
  return { type: "path", ops: Uo(t, e, r, n, a) };
}
function lv(t, e, r) {
  const n = (t || []).length;
  if (n > 2) {
    const a = [];
    for (let i = 0; i < n - 1; i++) a.push(...Uo(t[i][0], t[i][1], t[i + 1][0], t[i + 1][1], r));
    return e && a.push(...Uo(t[n - 1][0], t[n - 1][1], t[0][0], t[0][1], r)), { type: "path", ops: a };
  }
  return n === 2 ? nD(t[0][0], t[0][1], t[1][0], t[1][1], r) : { type: "path", ops: [] };
}
function dfe(t, e, r, n, a) {
  return function(i, s) {
    return lv(i, !0, s);
  }([[t, e], [t + r, e], [t + r, e + n], [t, e + n]], a);
}
function HR(t, e) {
  if (t.length) {
    const r = typeof t[0][0] == "number" ? [t] : t, n = Vp(r[0], 1 * (1 + 0.2 * e.roughness), e), a = e.disableMultiStroke ? [] : Vp(r[0], 1.5 * (1 + 0.22 * e.roughness), WR(e));
    for (let i = 1; i < r.length; i++) {
      const s = r[i];
      if (s.length) {
        const o = Vp(s, 1 * (1 + 0.2 * e.roughness), e), l = e.disableMultiStroke ? [] : Vp(s, 1.5 * (1 + 0.22 * e.roughness), WR(e));
        for (const u of o) u.op !== "move" && n.push(u);
        for (const u of l) u.op !== "move" && a.push(u);
      }
    }
    return { type: "path", ops: n.concat(a) };
  }
  return { type: "path", ops: [] };
}
function aD(t, e, r) {
  const n = Math.sqrt(2 * Math.PI * Math.sqrt((Math.pow(t / 2, 2) + Math.pow(e / 2, 2)) / 2)), a = Math.ceil(Math.max(r.curveStepCount, r.curveStepCount / Math.sqrt(200) * n)), i = 2 * Math.PI / a;
  let s = Math.abs(t / 2), o = Math.abs(e / 2);
  const l = 1 - r.curveFitting;
  return s += Mt(s * l, r), o += Mt(o * l, r), { increment: i, rx: s, ry: o };
}
function LT(t, e, r, n) {
  const [a, i] = jR(n.increment, t, e, n.rx, n.ry, 1, n.increment * vm(0.1, vm(0.4, 1, r), r), r);
  let s = mm(a, null, r);
  if (!r.disableMultiStroke && r.roughness !== 0) {
    const [o] = jR(n.increment, t, e, n.rx, n.ry, 1.5, 0, r), l = mm(o, null, r);
    s = s.concat(l);
  }
  return { estimatedPoints: i, opset: { type: "path", ops: s } };
}
function VR(t, e, r, n, a, i, s, o, l) {
  const u = t, c = e;
  let f = Math.abs(r / 2), h = Math.abs(n / 2);
  f += Mt(0.01 * f, l), h += Mt(0.01 * h, l);
  let d = a, p = i;
  for (; d < 0; ) d += 2 * Math.PI, p += 2 * Math.PI;
  p - d > 2 * Math.PI && (d = 0, p = 2 * Math.PI);
  const g = 2 * Math.PI / l.curveStepCount, v = Math.min(g / 2, (p - d) / 2), m = YR(v, u, c, f, h, d, p, 1, l);
  if (!l.disableMultiStroke) {
    const b = YR(v, u, c, f, h, d, p, 1.5, l);
    m.push(...b);
  }
  return s && (o ? m.push(...Uo(u, c, u + f * Math.cos(d), c + h * Math.sin(d), l), ...Uo(u, c, u + f * Math.cos(p), c + h * Math.sin(p), l)) : m.push({ op: "lineTo", data: [u, c] }, { op: "lineTo", data: [u + f * Math.cos(d), c + h * Math.sin(d)] })), { type: "path", ops: m };
}
function qR(t, e) {
  const r = tD(eD(z5(t))), n = [];
  let a = [0, 0], i = [0, 0];
  for (const { key: s, data: o } of r) switch (s) {
    case "M":
      i = [o[0], o[1]], a = [o[0], o[1]];
      break;
    case "L":
      n.push(...Uo(i[0], i[1], o[0], o[1], e)), i = [o[0], o[1]];
      break;
    case "C": {
      const [l, u, c, f, h, d] = o;
      n.push(...pfe(l, u, c, f, h, d, i, e)), i = [h, d];
      break;
    }
    case "Z":
      n.push(...Uo(i[0], i[1], a[0], a[1], e)), i = [a[0], a[1]];
  }
  return { type: "path", ops: n };
}
function wx(t, e) {
  const r = [];
  for (const n of t) if (n.length) {
    const a = e.maxRandomnessOffset || 0, i = n.length;
    if (i > 2) {
      r.push({ op: "move", data: [n[0][0] + Mt(a, e), n[0][1] + Mt(a, e)] });
      for (let s = 1; s < i; s++) r.push({ op: "lineTo", data: [n[s][0] + Mt(a, e), n[s][1] + Mt(a, e)] });
    }
  }
  return { type: "fillPath", ops: r };
}
function zu(t, e) {
  return function(r, n) {
    let a = r.fillStyle || "hachure";
    if (!xa[a]) switch (a) {
      case "zigzag":
        xa[a] || (xa[a] = new ife(n));
        break;
      case "cross-hatch":
        xa[a] || (xa[a] = new sfe(n));
        break;
      case "dots":
        xa[a] || (xa[a] = new ofe(n));
        break;
      case "dashed":
        xa[a] || (xa[a] = new lfe(n));
        break;
      case "zigzag-line":
        xa[a] || (xa[a] = new ufe(n));
        break;
      default:
        a = "hachure", xa[a] || (xa[a] = new B5(n));
    }
    return xa[a];
  }(e, hfe).fillPolygons(t, e);
}
function WR(t) {
  const e = Object.assign({}, t);
  return e.randomizer = void 0, t.seed && (e.seed = t.seed + 1), e;
}
function iD(t) {
  return t.randomizer || (t.randomizer = new cfe(t.seed || 0)), t.randomizer.next();
}
function vm(t, e, r, n = 1) {
  return r.roughness * n * (iD(r) * (e - t) + t);
}
function Mt(t, e, r = 1) {
  return vm(-t, t, e, r);
}
function Uo(t, e, r, n, a, i = !1) {
  const s = i ? a.disableMultiStrokeFill : a.disableMultiStroke, o = NT(t, e, r, n, a, !0, !1);
  if (s) return o;
  const l = NT(t, e, r, n, a, !0, !0);
  return o.concat(l);
}
function NT(t, e, r, n, a, i, s) {
  const o = Math.pow(t - r, 2) + Math.pow(e - n, 2), l = Math.sqrt(o);
  let u = 1;
  u = l < 200 ? 1 : l > 500 ? 0.4 : -16668e-7 * l + 1.233334;
  let c = a.maxRandomnessOffset || 0;
  c * c * 100 > o && (c = l / 10);
  const f = c / 2, h = 0.2 + 0.2 * iD(a);
  let d = a.bowing * a.maxRandomnessOffset * (n - e) / 200, p = a.bowing * a.maxRandomnessOffset * (t - r) / 200;
  d = Mt(d, a, u), p = Mt(p, a, u);
  const g = [], v = () => Mt(f, a, u), m = () => Mt(c, a, u), b = a.preserveVertices;
  return s ? g.push({ op: "move", data: [t + (b ? 0 : v()), e + (b ? 0 : v())] }) : g.push({ op: "move", data: [t + (b ? 0 : Mt(c, a, u)), e + (b ? 0 : Mt(c, a, u))] }), s ? g.push({ op: "bcurveTo", data: [d + t + (r - t) * h + v(), p + e + (n - e) * h + v(), d + t + 2 * (r - t) * h + v(), p + e + 2 * (n - e) * h + v(), r + (b ? 0 : v()), n + (b ? 0 : v())] }) : g.push({ op: "bcurveTo", data: [d + t + (r - t) * h + m(), p + e + (n - e) * h + m(), d + t + 2 * (r - t) * h + m(), p + e + 2 * (n - e) * h + m(), r + (b ? 0 : m()), n + (b ? 0 : m())] }), g;
}
function Vp(t, e, r) {
  if (!t.length) return [];
  const n = [];
  n.push([t[0][0] + Mt(e, r), t[0][1] + Mt(e, r)]), n.push([t[0][0] + Mt(e, r), t[0][1] + Mt(e, r)]);
  for (let a = 1; a < t.length; a++) n.push([t[a][0] + Mt(e, r), t[a][1] + Mt(e, r)]), a === t.length - 1 && n.push([t[a][0] + Mt(e, r), t[a][1] + Mt(e, r)]);
  return mm(n, null, r);
}
function mm(t, e, r) {
  const n = t.length, a = [];
  if (n > 3) {
    const i = [], s = 1 - r.curveTightness;
    a.push({ op: "move", data: [t[1][0], t[1][1]] });
    for (let o = 1; o + 2 < n; o++) {
      const l = t[o];
      i[0] = [l[0], l[1]], i[1] = [l[0] + (s * t[o + 1][0] - s * t[o - 1][0]) / 6, l[1] + (s * t[o + 1][1] - s * t[o - 1][1]) / 6], i[2] = [t[o + 1][0] + (s * t[o][0] - s * t[o + 2][0]) / 6, t[o + 1][1] + (s * t[o][1] - s * t[o + 2][1]) / 6], i[3] = [t[o + 1][0], t[o + 1][1]], a.push({ op: "bcurveTo", data: [i[1][0], i[1][1], i[2][0], i[2][1], i[3][0], i[3][1]] });
    }
  } else n === 3 ? (a.push({ op: "move", data: [t[1][0], t[1][1]] }), a.push({ op: "bcurveTo", data: [t[1][0], t[1][1], t[2][0], t[2][1], t[2][0], t[2][1]] })) : n === 2 && a.push(...NT(t[0][0], t[0][1], t[1][0], t[1][1], r, !0, !0));
  return a;
}
function jR(t, e, r, n, a, i, s, o) {
  const l = [], u = [];
  if (o.roughness === 0) {
    t /= 4, u.push([e + n * Math.cos(-t), r + a * Math.sin(-t)]);
    for (let c = 0; c <= 2 * Math.PI; c += t) {
      const f = [e + n * Math.cos(c), r + a * Math.sin(c)];
      l.push(f), u.push(f);
    }
    u.push([e + n * Math.cos(0), r + a * Math.sin(0)]), u.push([e + n * Math.cos(t), r + a * Math.sin(t)]);
  } else {
    const c = Mt(0.5, o) - Math.PI / 2;
    u.push([Mt(i, o) + e + 0.9 * n * Math.cos(c - t), Mt(i, o) + r + 0.9 * a * Math.sin(c - t)]);
    const f = 2 * Math.PI + c - 0.01;
    for (let h = c; h < f; h += t) {
      const d = [Mt(i, o) + e + n * Math.cos(h), Mt(i, o) + r + a * Math.sin(h)];
      l.push(d), u.push(d);
    }
    u.push([Mt(i, o) + e + n * Math.cos(c + 2 * Math.PI + 0.5 * s), Mt(i, o) + r + a * Math.sin(c + 2 * Math.PI + 0.5 * s)]), u.push([Mt(i, o) + e + 0.98 * n * Math.cos(c + s), Mt(i, o) + r + 0.98 * a * Math.sin(c + s)]), u.push([Mt(i, o) + e + 0.9 * n * Math.cos(c + 0.5 * s), Mt(i, o) + r + 0.9 * a * Math.sin(c + 0.5 * s)]);
  }
  return [u, l];
}
function YR(t, e, r, n, a, i, s, o, l) {
  const u = i + Mt(0.1, l), c = [];
  c.push([Mt(o, l) + e + 0.9 * n * Math.cos(u - t), Mt(o, l) + r + 0.9 * a * Math.sin(u - t)]);
  for (let f = u; f <= s; f += t) c.push([Mt(o, l) + e + n * Math.cos(f), Mt(o, l) + r + a * Math.sin(f)]);
  return c.push([e + n * Math.cos(s), r + a * Math.sin(s)]), c.push([e + n * Math.cos(s), r + a * Math.sin(s)]), mm(c, null, l);
}
function pfe(t, e, r, n, a, i, s, o) {
  const l = [], u = [o.maxRandomnessOffset || 1, (o.maxRandomnessOffset || 1) + 0.3];
  let c = [0, 0];
  const f = o.disableMultiStroke ? 1 : 2, h = o.preserveVertices;
  for (let d = 0; d < f; d++) d === 0 ? l.push({ op: "move", data: [s[0], s[1]] }) : l.push({ op: "move", data: [s[0] + (h ? 0 : Mt(u[0], o)), s[1] + (h ? 0 : Mt(u[0], o))] }), c = h ? [a, i] : [a + Mt(u[d], o), i + Mt(u[d], o)], l.push({ op: "bcurveTo", data: [t + Mt(u[d], o), e + Mt(u[d], o), r + Mt(u[d], o), n + Mt(u[d], o), c[0], c[1]] });
  return l;
}
function oh(t) {
  return [...t];
}
function XR(t, e = 0) {
  const r = t.length;
  if (r < 3) throw new Error("A curve must have at least three points.");
  const n = [];
  if (r === 3) n.push(oh(t[0]), oh(t[1]), oh(t[2]), oh(t[2]));
  else {
    const a = [];
    a.push(t[0], t[0]);
    for (let o = 1; o < t.length; o++) a.push(t[o]), o === t.length - 1 && a.push(t[o]);
    const i = [], s = 1 - e;
    n.push(oh(a[0]));
    for (let o = 1; o + 2 < a.length; o++) {
      const l = a[o];
      i[0] = [l[0], l[1]], i[1] = [l[0] + (s * a[o + 1][0] - s * a[o - 1][0]) / 6, l[1] + (s * a[o + 1][1] - s * a[o - 1][1]) / 6], i[2] = [a[o + 1][0] + (s * a[o][0] - s * a[o + 2][0]) / 6, a[o + 1][1] + (s * a[o][1] - s * a[o + 2][1]) / 6], i[3] = [a[o + 1][0], a[o + 1][1]], n.push(i[1], i[2], i[3]);
    }
  }
  return n;
}
function uv(t, e) {
  return Math.pow(t[0] - e[0], 2) + Math.pow(t[1] - e[1], 2);
}
function gfe(t, e, r) {
  const n = uv(e, r);
  if (n === 0) return uv(t, e);
  let a = ((t[0] - e[0]) * (r[0] - e[0]) + (t[1] - e[1]) * (r[1] - e[1])) / n;
  return a = Math.max(0, Math.min(1, a)), uv(t, _l(e, r, a));
}
function _l(t, e, r) {
  return [t[0] + (e[0] - t[0]) * r, t[1] + (e[1] - t[1]) * r];
}
function OT(t, e, r, n) {
  const a = n || [];
  if (function(o, l) {
    const u = o[l + 0], c = o[l + 1], f = o[l + 2], h = o[l + 3];
    let d = 3 * c[0] - 2 * u[0] - h[0];
    d *= d;
    let p = 3 * c[1] - 2 * u[1] - h[1];
    p *= p;
    let g = 3 * f[0] - 2 * h[0] - u[0];
    g *= g;
    let v = 3 * f[1] - 2 * h[1] - u[1];
    return v *= v, d < g && (d = g), p < v && (p = v), d + p;
  }(t, e) < r) {
    const o = t[e + 0];
    a.length ? (i = a[a.length - 1], s = o, Math.sqrt(uv(i, s)) > 1 && a.push(o)) : a.push(o), a.push(t[e + 3]);
  } else {
    const l = t[e + 0], u = t[e + 1], c = t[e + 2], f = t[e + 3], h = _l(l, u, 0.5), d = _l(u, c, 0.5), p = _l(c, f, 0.5), g = _l(h, d, 0.5), v = _l(d, p, 0.5), m = _l(g, v, 0.5);
    OT([l, h, g, m], 0, r, a), OT([m, v, p, f], 0, r, a);
  }
  var i, s;
  return a;
}
function vfe(t, e) {
  return ym(t, 0, t.length, e);
}
function ym(t, e, r, n, a) {
  const i = a || [], s = t[e], o = t[r - 1];
  let l = 0, u = 1;
  for (let c = e + 1; c < r - 1; ++c) {
    const f = gfe(t[c], s, o);
    f > l && (l = f, u = c);
  }
  return Math.sqrt(l) > n ? (ym(t, e, u + 1, n, i), ym(t, u, r, n, i)) : (i.length || i.push(s), i.push(o)), i;
}
function Ex(t, e = 0.15, r) {
  const n = [], a = (t.length - 1) / 3;
  for (let i = 0; i < a; i++)
    OT(t, 3 * i, e, n);
  return r && r > 0 ? ym(n, 0, n.length, r) : n;
}
const Va = "none";
class bm {
  constructor(e) {
    this.defaultOptions = { maxRandomnessOffset: 2, roughness: 1, bowing: 1, stroke: "#000", strokeWidth: 1, curveTightness: 0, curveFitting: 0.95, curveStepCount: 9, fillStyle: "hachure", fillWeight: -1, hachureAngle: -41, hachureGap: -1, dashOffset: -1, dashGap: -1, zigzagOffset: -1, seed: 0, disableMultiStroke: !1, disableMultiStrokeFill: !1, preserveVertices: !1, fillShapeRoughnessGain: 0.8 }, this.config = e || {}, this.config.options && (this.defaultOptions = this._o(this.config.options));
  }
  static newSeed() {
    return Math.floor(Math.random() * 2 ** 31);
  }
  _o(e) {
    return e ? Object.assign({}, this.defaultOptions, e) : this.defaultOptions;
  }
  _d(e, r, n) {
    return { shape: e, sets: r || [], options: n || this.defaultOptions };
  }
  line(e, r, n, a, i) {
    const s = this._o(i);
    return this._d("line", [nD(e, r, n, a, s)], s);
  }
  rectangle(e, r, n, a, i) {
    const s = this._o(i), o = [], l = dfe(e, r, n, a, s);
    if (s.fill) {
      const u = [[e, r], [e + n, r], [e + n, r + a], [e, r + a]];
      s.fillStyle === "solid" ? o.push(wx([u], s)) : o.push(zu([u], s));
    }
    return s.stroke !== Va && o.push(l), this._d("rectangle", o, s);
  }
  ellipse(e, r, n, a, i) {
    const s = this._o(i), o = [], l = aD(n, a, s), u = LT(e, r, s, l);
    if (s.fill) if (s.fillStyle === "solid") {
      const c = LT(e, r, s, l).opset;
      c.type = "fillPath", o.push(c);
    } else o.push(zu([u.estimatedPoints], s));
    return s.stroke !== Va && o.push(u.opset), this._d("ellipse", o, s);
  }
  circle(e, r, n, a) {
    const i = this.ellipse(e, r, n, n, a);
    return i.shape = "circle", i;
  }
  linearPath(e, r) {
    const n = this._o(r);
    return this._d("linearPath", [lv(e, !1, n)], n);
  }
  arc(e, r, n, a, i, s, o = !1, l) {
    const u = this._o(l), c = [], f = VR(e, r, n, a, i, s, o, !0, u);
    if (o && u.fill) if (u.fillStyle === "solid") {
      const h = Object.assign({}, u);
      h.disableMultiStroke = !0;
      const d = VR(e, r, n, a, i, s, !0, !1, h);
      d.type = "fillPath", c.push(d);
    } else c.push(function(h, d, p, g, v, m, b) {
      const y = h, x = d;
      let E = Math.abs(p / 2), S = Math.abs(g / 2);
      E += Mt(0.01 * E, b), S += Mt(0.01 * S, b);
      let w = v, C = m;
      for (; w < 0; ) w += 2 * Math.PI, C += 2 * Math.PI;
      C - w > 2 * Math.PI && (w = 0, C = 2 * Math.PI);
      const k = (C - w) / b.curveStepCount, N = [];
      for (let R = w; R <= C; R += k) N.push([y + E * Math.cos(R), x + S * Math.sin(R)]);
      return N.push([y + E * Math.cos(C), x + S * Math.sin(C)]), N.push([y, x]), zu([N], b);
    }(e, r, n, a, i, s, u));
    return u.stroke !== Va && c.push(f), this._d("arc", c, u);
  }
  curve(e, r) {
    const n = this._o(r), a = [], i = HR(e, n);
    if (n.fill && n.fill !== Va) if (n.fillStyle === "solid") {
      const s = HR(e, Object.assign(Object.assign({}, n), { disableMultiStroke: !0, roughness: n.roughness ? n.roughness + n.fillShapeRoughnessGain : 0 }));
      a.push({ type: "fillPath", ops: this._mergedShape(s.ops) });
    } else {
      const s = [], o = e;
      if (o.length) {
        const l = typeof o[0][0] == "number" ? [o] : o;
        for (const u of l) u.length < 3 ? s.push(...u) : u.length === 3 ? s.push(...Ex(XR([u[0], u[0], u[1], u[2]]), 10, (1 + n.roughness) / 2)) : s.push(...Ex(XR(u), 10, (1 + n.roughness) / 2));
      }
      s.length && a.push(zu([s], n));
    }
    return n.stroke !== Va && a.push(i), this._d("curve", a, n);
  }
  polygon(e, r) {
    const n = this._o(r), a = [], i = lv(e, !0, n);
    return n.fill && (n.fillStyle === "solid" ? a.push(wx([e], n)) : a.push(zu([e], n))), n.stroke !== Va && a.push(i), this._d("polygon", a, n);
  }
  path(e, r) {
    const n = this._o(r), a = [];
    if (!e) return this._d("path", a, n);
    e = (e || "").replace(/\n/g, " ").replace(/(-\s)/g, "-").replace("/(ss)/g", " ");
    const i = n.fill && n.fill !== "transparent" && n.fill !== Va, s = n.stroke !== Va, o = !!(n.simplification && n.simplification < 1), l = function(c, f, h) {
      const d = tD(eD(z5(c))), p = [];
      let g = [], v = [0, 0], m = [];
      const b = () => {
        m.length >= 4 && g.push(...Ex(m, f)), m = [];
      }, y = () => {
        b(), g.length && (p.push(g), g = []);
      };
      for (const { key: E, data: S } of d) switch (E) {
        case "M":
          y(), v = [S[0], S[1]], g.push(v);
          break;
        case "L":
          b(), g.push([S[0], S[1]]);
          break;
        case "C":
          if (!m.length) {
            const w = g.length ? g[g.length - 1] : v;
            m.push([w[0], w[1]]);
          }
          m.push([S[0], S[1]]), m.push([S[2], S[3]]), m.push([S[4], S[5]]);
          break;
        case "Z":
          b(), g.push([v[0], v[1]]);
      }
      if (y(), !h) return p;
      const x = [];
      for (const E of p) {
        const S = vfe(E, h);
        S.length && x.push(S);
      }
      return x;
    }(e, 1, o ? 4 - 4 * (n.simplification || 1) : (1 + n.roughness) / 2), u = qR(e, n);
    if (i) if (n.fillStyle === "solid") if (l.length === 1) {
      const c = qR(e, Object.assign(Object.assign({}, n), { disableMultiStroke: !0, roughness: n.roughness ? n.roughness + n.fillShapeRoughnessGain : 0 }));
      a.push({ type: "fillPath", ops: this._mergedShape(c.ops) });
    } else a.push(wx(l, n));
    else a.push(zu(l, n));
    return s && (o ? l.forEach((c) => {
      a.push(lv(c, !1, n));
    }) : a.push(u)), this._d("path", a, n);
  }
  opsToPath(e, r) {
    let n = "";
    for (const a of e.ops) {
      const i = typeof r == "number" && r >= 0 ? a.data.map((s) => +s.toFixed(r)) : a.data;
      switch (a.op) {
        case "move":
          n += `M${i[0]} ${i[1]} `;
          break;
        case "bcurveTo":
          n += `C${i[0]} ${i[1]}, ${i[2]} ${i[3]}, ${i[4]} ${i[5]} `;
          break;
        case "lineTo":
          n += `L${i[0]} ${i[1]} `;
      }
    }
    return n.trim();
  }
  toPaths(e) {
    const r = e.sets || [], n = e.options || this.defaultOptions, a = [];
    for (const i of r) {
      let s = null;
      switch (i.type) {
        case "path":
          s = { d: this.opsToPath(i), stroke: n.stroke, strokeWidth: n.strokeWidth, fill: Va };
          break;
        case "fillPath":
          s = { d: this.opsToPath(i), stroke: Va, strokeWidth: 0, fill: n.fill || Va };
          break;
        case "fillSketch":
          s = this.fillSketch(i, n);
      }
      s && a.push(s);
    }
    return a;
  }
  fillSketch(e, r) {
    let n = r.fillWeight;
    return n < 0 && (n = r.strokeWidth / 2), { d: this.opsToPath(e), stroke: r.fill || Va, strokeWidth: n, fill: Va };
  }
  _mergedShape(e) {
    return e.filter((r, n) => n === 0 || r.op !== "move");
  }
}
class mfe {
  constructor(e, r) {
    this.canvas = e, this.ctx = this.canvas.getContext("2d"), this.gen = new bm(r);
  }
  draw(e) {
    const r = e.sets || [], n = e.options || this.getDefaultOptions(), a = this.ctx, i = e.options.fixedDecimalPlaceDigits;
    for (const s of r) switch (s.type) {
      case "path":
        a.save(), a.strokeStyle = n.stroke === "none" ? "transparent" : n.stroke, a.lineWidth = n.strokeWidth, n.strokeLineDash && a.setLineDash(n.strokeLineDash), n.strokeLineDashOffset && (a.lineDashOffset = n.strokeLineDashOffset), this._drawToContext(a, s, i), a.restore();
        break;
      case "fillPath": {
        a.save(), a.fillStyle = n.fill || "";
        const o = e.shape === "curve" || e.shape === "polygon" || e.shape === "path" ? "evenodd" : "nonzero";
        this._drawToContext(a, s, i, o), a.restore();
        break;
      }
      case "fillSketch":
        this.fillSketch(a, s, n);
    }
  }
  fillSketch(e, r, n) {
    let a = n.fillWeight;
    a < 0 && (a = n.strokeWidth / 2), e.save(), n.fillLineDash && e.setLineDash(n.fillLineDash), n.fillLineDashOffset && (e.lineDashOffset = n.fillLineDashOffset), e.strokeStyle = n.fill || "", e.lineWidth = a, this._drawToContext(e, r, n.fixedDecimalPlaceDigits), e.restore();
  }
  _drawToContext(e, r, n, a = "nonzero") {
    e.beginPath();
    for (const i of r.ops) {
      const s = typeof n == "number" && n >= 0 ? i.data.map((o) => +o.toFixed(n)) : i.data;
      switch (i.op) {
        case "move":
          e.moveTo(s[0], s[1]);
          break;
        case "bcurveTo":
          e.bezierCurveTo(s[0], s[1], s[2], s[3], s[4], s[5]);
          break;
        case "lineTo":
          e.lineTo(s[0], s[1]);
      }
    }
    r.type === "fillPath" ? e.fill(a) : e.stroke();
  }
  get generator() {
    return this.gen;
  }
  getDefaultOptions() {
    return this.gen.defaultOptions;
  }
  line(e, r, n, a, i) {
    const s = this.gen.line(e, r, n, a, i);
    return this.draw(s), s;
  }
  rectangle(e, r, n, a, i) {
    const s = this.gen.rectangle(e, r, n, a, i);
    return this.draw(s), s;
  }
  ellipse(e, r, n, a, i) {
    const s = this.gen.ellipse(e, r, n, a, i);
    return this.draw(s), s;
  }
  circle(e, r, n, a) {
    const i = this.gen.circle(e, r, n, a);
    return this.draw(i), i;
  }
  linearPath(e, r) {
    const n = this.gen.linearPath(e, r);
    return this.draw(n), n;
  }
  polygon(e, r) {
    const n = this.gen.polygon(e, r);
    return this.draw(n), n;
  }
  arc(e, r, n, a, i, s, o = !1, l) {
    const u = this.gen.arc(e, r, n, a, i, s, o, l);
    return this.draw(u), u;
  }
  curve(e, r) {
    const n = this.gen.curve(e, r);
    return this.draw(n), n;
  }
  path(e, r) {
    const n = this.gen.path(e, r);
    return this.draw(n), n;
  }
}
const qp = "http://www.w3.org/2000/svg";
class yfe {
  constructor(e, r) {
    this.svg = e, this.gen = new bm(r);
  }
  draw(e) {
    const r = e.sets || [], n = e.options || this.getDefaultOptions(), a = this.svg.ownerDocument || window.document, i = a.createElementNS(qp, "g"), s = e.options.fixedDecimalPlaceDigits;
    for (const o of r) {
      let l = null;
      switch (o.type) {
        case "path":
          l = a.createElementNS(qp, "path"), l.setAttribute("d", this.opsToPath(o, s)), l.setAttribute("stroke", n.stroke), l.setAttribute("stroke-width", n.strokeWidth + ""), l.setAttribute("fill", "none"), n.strokeLineDash && l.setAttribute("stroke-dasharray", n.strokeLineDash.join(" ").trim()), n.strokeLineDashOffset && l.setAttribute("stroke-dashoffset", `${n.strokeLineDashOffset}`);
          break;
        case "fillPath":
          l = a.createElementNS(qp, "path"), l.setAttribute("d", this.opsToPath(o, s)), l.setAttribute("stroke", "none"), l.setAttribute("stroke-width", "0"), l.setAttribute("fill", n.fill || ""), e.shape !== "curve" && e.shape !== "polygon" || l.setAttribute("fill-rule", "evenodd");
          break;
        case "fillSketch":
          l = this.fillSketch(a, o, n);
      }
      l && i.appendChild(l);
    }
    return i;
  }
  fillSketch(e, r, n) {
    let a = n.fillWeight;
    a < 0 && (a = n.strokeWidth / 2);
    const i = e.createElementNS(qp, "path");
    return i.setAttribute("d", this.opsToPath(r, n.fixedDecimalPlaceDigits)), i.setAttribute("stroke", n.fill || ""), i.setAttribute("stroke-width", a + ""), i.setAttribute("fill", "none"), n.fillLineDash && i.setAttribute("stroke-dasharray", n.fillLineDash.join(" ").trim()), n.fillLineDashOffset && i.setAttribute("stroke-dashoffset", `${n.fillLineDashOffset}`), i;
  }
  get generator() {
    return this.gen;
  }
  getDefaultOptions() {
    return this.gen.defaultOptions;
  }
  opsToPath(e, r) {
    return this.gen.opsToPath(e, r);
  }
  line(e, r, n, a, i) {
    const s = this.gen.line(e, r, n, a, i);
    return this.draw(s);
  }
  rectangle(e, r, n, a, i) {
    const s = this.gen.rectangle(e, r, n, a, i);
    return this.draw(s);
  }
  ellipse(e, r, n, a, i) {
    const s = this.gen.ellipse(e, r, n, a, i);
    return this.draw(s);
  }
  circle(e, r, n, a) {
    const i = this.gen.circle(e, r, n, a);
    return this.draw(i);
  }
  linearPath(e, r) {
    const n = this.gen.linearPath(e, r);
    return this.draw(n);
  }
  polygon(e, r) {
    const n = this.gen.polygon(e, r);
    return this.draw(n);
  }
  arc(e, r, n, a, i, s, o = !1, l) {
    const u = this.gen.arc(e, r, n, a, i, s, o, l);
    return this.draw(u);
  }
  curve(e, r) {
    const n = this.gen.curve(e, r);
    return this.draw(n);
  }
  path(e, r) {
    const n = this.gen.path(e, r);
    return this.draw(n);
  }
}
var V_e = { canvas: (t, e) => new mfe(t, e), svg: (t, e) => new yfe(t, e), generator: (t) => new bm(t), newSeed: () => bm.newSeed() }, bfe = L9(Object.keys, Object), xfe = Object.prototype, wfe = xfe.hasOwnProperty;
function sD(t) {
  if (!V0(t))
    return bfe(t);
  var e = [];
  for (var r in Object(t))
    wfe.call(t, r) && r != "constructor" && e.push(r);
  return e;
}
var IT = wu(ws, "DataView"), PT = wu(ws, "Promise"), yc = wu(ws, "Set"), DT = wu(ws, "WeakMap"), KR = "[object Map]", Efe = "[object Object]", ZR = "[object Promise]", QR = "[object Set]", JR = "[object WeakMap]", e6 = "[object DataView]", Tfe = xu(IT), Sfe = xu(Zd), Cfe = xu(PT), Afe = xu(yc), kfe = xu(DT), fi = vo;
(IT && fi(new IT(new ArrayBuffer(1))) != e6 || Zd && fi(new Zd()) != KR || PT && fi(PT.resolve()) != ZR || yc && fi(new yc()) != QR || DT && fi(new DT()) != JR) && (fi = function(t) {
  var e = vo(t), r = e == Efe ? t.constructor : void 0, n = r ? xu(r) : "";
  if (n)
    switch (n) {
      case Tfe:
        return e6;
      case Sfe:
        return KR;
      case Cfe:
        return ZR;
      case Afe:
        return QR;
      case kfe:
        return JR;
    }
  return e;
});
var Rfe = "[object Map]", Mfe = "[object Set]", _fe = Object.prototype, Lfe = _fe.hasOwnProperty;
function mr(t) {
  if (t == null)
    return !0;
  if (Es(t) && (jt(t) || typeof t == "string" || typeof t.splice == "function" || tf(t) || v1(t) || ef(t)))
    return !t.length;
  var e = fi(t);
  if (e == Rfe || e == Mfe)
    return !t.size;
  if (V0(t))
    return !sD(t).length;
  for (var r in t)
    if (Lfe.call(t, r))
      return !1;
  return !0;
}
var oD = {};
Object.defineProperty(oD, "__esModule", {
  value: !0
});
var q_e = oD.default = Nfe;
function Nfe(t, e) {
  for (var r = t, n = 0; n < e.length; n += 1) {
    if (r == null)
      return;
    r = r[e[n]];
  }
  return r;
}
function G5() {
  return {
    async: !1,
    breaks: !1,
    extensions: null,
    gfm: !0,
    hooks: null,
    pedantic: !1,
    renderer: null,
    silent: !1,
    tokenizer: null,
    walkTokens: null
  };
}
var Su = G5();
function lD(t) {
  Su = t;
}
var Sd = { exec: () => null };
function gr(t, e = "") {
  let r = typeof t == "string" ? t : t.source;
  const n = {
    replace: (a, i) => {
      let s = typeof i == "string" ? i : i.source;
      return s = s.replace(ua.caret, "$1"), r = r.replace(a, s), n;
    },
    getRegex: () => new RegExp(r, e)
  };
  return n;
}
var ua = {
  codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm,
  outputLinkReplace: /\\([\[\]])/g,
  indentCodeCompensation: /^(\s+)(?:```)/,
  beginningSpace: /^\s+/,
  endingHash: /#$/,
  startingSpaceChar: /^ /,
  endingSpaceChar: / $/,
  nonSpaceChar: /[^ ]/,
  newLineCharGlobal: /\n/g,
  tabCharGlobal: /\t/g,
  multipleSpaceGlobal: /\s+/g,
  blankLine: /^[ \t]*$/,
  doubleBlankLine: /\n[ \t]*\n[ \t]*$/,
  blockquoteStart: /^ {0,3}>/,
  blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g,
  blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm,
  listReplaceTabs: /^\t+/,
  listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g,
  listIsTask: /^\[[ xX]\] /,
  listReplaceTask: /^\[[ xX]\] +/,
  anyLine: /\n.*\n/,
  hrefBrackets: /^<(.*)>$/,
  tableDelimiter: /[:|]/,
  tableAlignChars: /^\||\| *$/g,
  tableRowBlankLine: /\n[ \t]*$/,
  tableAlignRight: /^ *-+: *$/,
  tableAlignCenter: /^ *:-+: *$/,
  tableAlignLeft: /^ *:-+ *$/,
  startATag: /^<a /i,
  endATag: /^<\/a>/i,
  startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i,
  endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i,
  startAngleBracket: /^</,
  endAngleBracket: />$/,
  pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/,
  unicodeAlphaNumeric: /[\p{L}\p{N}]/u,
  escapeTest: /[&<>"']/,
  escapeReplace: /[&<>"']/g,
  escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,
  escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g,
  unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig,
  caret: /(^|[^\[])\^/g,
  percentDecode: /%25/g,
  findPipe: /\|/g,
  splitPipe: / \|/,
  slashPipe: /\\\|/g,
  carriageReturn: /\r\n|\r/g,
  spaceLine: /^ +$/gm,
  notSpaceStart: /^\S*/,
  endingNewline: /\n$/,
  listItemRegex: (t) => new RegExp(`^( {0,3}${t})((?:[	 ][^\\n]*)?(?:\\n|$))`),
  nextBulletRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`),
  hrRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`),
  fencesBeginRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}(?:\`\`\`|~~~)`),
  headingBeginRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}#`),
  htmlBeginRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}<(?:[a-z].*>|!--)`, "i")
}, Ofe = /^(?:[ \t]*(?:\n|$))+/, Ife = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/, Pfe = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/, K0 = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/, Dfe = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/, U5 = /(?:[*+-]|\d{1,9}[.)])/, uD = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/, cD = gr(uD).replace(/bull/g, U5).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/\|table/g, "").getRegex(), $fe = gr(uD).replace(/bull/g, U5).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/).getRegex(), H5 = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/, Ffe = /^[^\n]+/, V5 = /(?!\s*\])(?:\\.|[^\[\]\\])+/, Bfe = gr(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label", V5).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(), zfe = gr(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, U5).getRegex(), w1 = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", q5 = /<!--(?:-?>|[\s\S]*?(?:-->|$))/, Gfe = gr(
  "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))",
  "i"
).replace("comment", q5).replace("tag", w1).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), fD = gr(H5).replace("hr", K0).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", w1).getRegex(), Ufe = gr(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", fD).getRegex(), W5 = {
  blockquote: Ufe,
  code: Ife,
  def: Bfe,
  fences: Pfe,
  heading: Dfe,
  hr: K0,
  html: Gfe,
  lheading: cD,
  list: zfe,
  newline: Ofe,
  paragraph: fD,
  table: Sd,
  text: Ffe
}, t6 = gr(
  "^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
).replace("hr", K0).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", "(?: {4}| {0,3}	)[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", w1).getRegex(), Hfe = {
  ...W5,
  lheading: $fe,
  table: t6,
  paragraph: gr(H5).replace("hr", K0).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", t6).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", w1).getRegex()
}, Vfe = {
  ...W5,
  html: gr(
    `^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`
  ).replace("comment", q5).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: Sd,
  // fences not supported
  lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  paragraph: gr(H5).replace("hr", K0).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", cD).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex()
}, qfe = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/, Wfe = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, hD = /^( {2,}|\\)\n(?!\s*$)/, jfe = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/, E1 = /[\p{P}\p{S}]/u, j5 = /[\s\p{P}\p{S}]/u, dD = /[^\s\p{P}\p{S}]/u, Yfe = gr(/^((?![*_])punctSpace)/, "u").replace(/punctSpace/g, j5).getRegex(), pD = /(?!~)[\p{P}\p{S}]/u, Xfe = /(?!~)[\s\p{P}\p{S}]/u, Kfe = /(?:[^\s\p{P}\p{S}]|~)/u, Zfe = /\[[^[\]]*?\]\((?:\\.|[^\\\(\)]|\((?:\\.|[^\\\(\)])*\))*\)|`[^`]*?`|<[^<>]*?>/g, gD = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/, Qfe = gr(gD, "u").replace(/punct/g, E1).getRegex(), Jfe = gr(gD, "u").replace(/punct/g, pD).getRegex(), vD = "^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)", ehe = gr(vD, "gu").replace(/notPunctSpace/g, dD).replace(/punctSpace/g, j5).replace(/punct/g, E1).getRegex(), the = gr(vD, "gu").replace(/notPunctSpace/g, Kfe).replace(/punctSpace/g, Xfe).replace(/punct/g, pD).getRegex(), rhe = gr(
  "^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)",
  "gu"
).replace(/notPunctSpace/g, dD).replace(/punctSpace/g, j5).replace(/punct/g, E1).getRegex(), nhe = gr(/\\(punct)/, "gu").replace(/punct/g, E1).getRegex(), ahe = gr(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(), ihe = gr(q5).replace("(?:-->|$)", "-->").getRegex(), she = gr(
  "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>"
).replace("comment", ihe).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(), xm = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/, ohe = gr(/^!?\[(label)\]\(\s*(href)(?:(?:[ \t]*(?:\n[ \t]*)?)(title))?\s*\)/).replace("label", xm).replace("href", /<(?:\\.|[^\n<>\\])+>|[^ \t\n\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(), mD = gr(/^!?\[(label)\]\[(ref)\]/).replace("label", xm).replace("ref", V5).getRegex(), yD = gr(/^!?\[(ref)\](?:\[\])?/).replace("ref", V5).getRegex(), lhe = gr("reflink|nolink(?!\\()", "g").replace("reflink", mD).replace("nolink", yD).getRegex(), Y5 = {
  _backpedal: Sd,
  // only used for GFM url
  anyPunctuation: nhe,
  autolink: ahe,
  blockSkip: Zfe,
  br: hD,
  code: Wfe,
  del: Sd,
  emStrongLDelim: Qfe,
  emStrongRDelimAst: ehe,
  emStrongRDelimUnd: rhe,
  escape: qfe,
  link: ohe,
  nolink: yD,
  punctuation: Yfe,
  reflink: mD,
  reflinkSearch: lhe,
  tag: she,
  text: jfe,
  url: Sd
}, uhe = {
  ...Y5,
  link: gr(/^!?\[(label)\]\((.*?)\)/).replace("label", xm).getRegex(),
  reflink: gr(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", xm).getRegex()
}, $T = {
  ...Y5,
  emStrongRDelimAst: the,
  emStrongLDelim: Jfe,
  url: gr(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),
  _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])((?:\\.|[^\\])*?(?:\\.|[^\s~\\]))\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
}, che = {
  ...$T,
  br: gr(hD).replace("{2,}", "*").getRegex(),
  text: gr($T.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
}, Wp = {
  normal: W5,
  gfm: Hfe,
  pedantic: Vfe
}, lh = {
  normal: Y5,
  gfm: $T,
  breaks: che,
  pedantic: uhe
}, fhe = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
}, r6 = (t) => fhe[t];
function is(t, e) {
  if (e) {
    if (ua.escapeTest.test(t))
      return t.replace(ua.escapeReplace, r6);
  } else if (ua.escapeTestNoEncode.test(t))
    return t.replace(ua.escapeReplaceNoEncode, r6);
  return t;
}
function n6(t) {
  try {
    t = encodeURI(t).replace(ua.percentDecode, "%");
  } catch {
    return null;
  }
  return t;
}
function a6(t, e) {
  var i;
  const r = t.replace(ua.findPipe, (s, o, l) => {
    let u = !1, c = o;
    for (; --c >= 0 && l[c] === "\\"; ) u = !u;
    return u ? "|" : " |";
  }), n = r.split(ua.splitPipe);
  let a = 0;
  if (n[0].trim() || n.shift(), n.length > 0 && !((i = n.at(-1)) != null && i.trim()) && n.pop(), e)
    if (n.length > e)
      n.splice(e);
    else
      for (; n.length < e; ) n.push("");
  for (; a < n.length; a++)
    n[a] = n[a].trim().replace(ua.slashPipe, "|");
  return n;
}
function uh(t, e, r) {
  const n = t.length;
  if (n === 0)
    return "";
  let a = 0;
  for (; a < n && t.charAt(n - a - 1) === e; )
    a++;
  return t.slice(0, n - a);
}
function hhe(t, e) {
  if (t.indexOf(e[1]) === -1)
    return -1;
  let r = 0;
  for (let n = 0; n < t.length; n++)
    if (t[n] === "\\")
      n++;
    else if (t[n] === e[0])
      r++;
    else if (t[n] === e[1] && (r--, r < 0))
      return n;
  return r > 0 ? -2 : -1;
}
function i6(t, e, r, n, a) {
  const i = e.href, s = e.title || null, o = t[1].replace(a.other.outputLinkReplace, "$1");
  n.state.inLink = !0;
  const l = {
    type: t[0].charAt(0) === "!" ? "image" : "link",
    raw: r,
    href: i,
    title: s,
    text: o,
    tokens: n.inlineTokens(o)
  };
  return n.state.inLink = !1, l;
}
function dhe(t, e, r) {
  const n = t.match(r.other.indentCodeCompensation);
  if (n === null)
    return e;
  const a = n[1];
  return e.split(`
`).map((i) => {
    const s = i.match(r.other.beginningSpace);
    if (s === null)
      return i;
    const [o] = s;
    return o.length >= a.length ? i.slice(a.length) : i;
  }).join(`
`);
}
var wm = class {
  // set by the lexer
  constructor(t) {
    Ye(this, "options");
    Ye(this, "rules");
    // set by the lexer
    Ye(this, "lexer");
    this.options = t || Su;
  }
  space(t) {
    const e = this.rules.block.newline.exec(t);
    if (e && e[0].length > 0)
      return {
        type: "space",
        raw: e[0]
      };
  }
  code(t) {
    const e = this.rules.block.code.exec(t);
    if (e) {
      const r = e[0].replace(this.rules.other.codeRemoveIndent, "");
      return {
        type: "code",
        raw: e[0],
        codeBlockStyle: "indented",
        text: this.options.pedantic ? r : uh(r, `
`)
      };
    }
  }
  fences(t) {
    const e = this.rules.block.fences.exec(t);
    if (e) {
      const r = e[0], n = dhe(r, e[3] || "", this.rules);
      return {
        type: "code",
        raw: r,
        lang: e[2] ? e[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : e[2],
        text: n
      };
    }
  }
  heading(t) {
    const e = this.rules.block.heading.exec(t);
    if (e) {
      let r = e[2].trim();
      if (this.rules.other.endingHash.test(r)) {
        const n = uh(r, "#");
        (this.options.pedantic || !n || this.rules.other.endingSpaceChar.test(n)) && (r = n.trim());
      }
      return {
        type: "heading",
        raw: e[0],
        depth: e[1].length,
        text: r,
        tokens: this.lexer.inline(r)
      };
    }
  }
  hr(t) {
    const e = this.rules.block.hr.exec(t);
    if (e)
      return {
        type: "hr",
        raw: uh(e[0], `
`)
      };
  }
  blockquote(t) {
    const e = this.rules.block.blockquote.exec(t);
    if (e) {
      let r = uh(e[0], `
`).split(`
`), n = "", a = "";
      const i = [];
      for (; r.length > 0; ) {
        let s = !1;
        const o = [];
        let l;
        for (l = 0; l < r.length; l++)
          if (this.rules.other.blockquoteStart.test(r[l]))
            o.push(r[l]), s = !0;
          else if (!s)
            o.push(r[l]);
          else
            break;
        r = r.slice(l);
        const u = o.join(`
`), c = u.replace(this.rules.other.blockquoteSetextReplace, `
    $1`).replace(this.rules.other.blockquoteSetextReplace2, "");
        n = n ? `${n}
${u}` : u, a = a ? `${a}
${c}` : c;
        const f = this.lexer.state.top;
        if (this.lexer.state.top = !0, this.lexer.blockTokens(c, i, !0), this.lexer.state.top = f, r.length === 0)
          break;
        const h = i.at(-1);
        if ((h == null ? void 0 : h.type) === "code")
          break;
        if ((h == null ? void 0 : h.type) === "blockquote") {
          const d = h, p = d.raw + `
` + r.join(`
`), g = this.blockquote(p);
          i[i.length - 1] = g, n = n.substring(0, n.length - d.raw.length) + g.raw, a = a.substring(0, a.length - d.text.length) + g.text;
          break;
        } else if ((h == null ? void 0 : h.type) === "list") {
          const d = h, p = d.raw + `
` + r.join(`
`), g = this.list(p);
          i[i.length - 1] = g, n = n.substring(0, n.length - h.raw.length) + g.raw, a = a.substring(0, a.length - d.raw.length) + g.raw, r = p.substring(i.at(-1).raw.length).split(`
`);
          continue;
        }
      }
      return {
        type: "blockquote",
        raw: n,
        tokens: i,
        text: a
      };
    }
  }
  list(t) {
    let e = this.rules.block.list.exec(t);
    if (e) {
      let r = e[1].trim();
      const n = r.length > 1, a = {
        type: "list",
        raw: "",
        ordered: n,
        start: n ? +r.slice(0, -1) : "",
        loose: !1,
        items: []
      };
      r = n ? `\\d{1,9}\\${r.slice(-1)}` : `\\${r}`, this.options.pedantic && (r = n ? r : "[*+-]");
      const i = this.rules.other.listItemRegex(r);
      let s = !1;
      for (; t; ) {
        let l = !1, u = "", c = "";
        if (!(e = i.exec(t)) || this.rules.block.hr.test(t))
          break;
        u = e[0], t = t.substring(u.length);
        let f = e[2].split(`
`, 1)[0].replace(this.rules.other.listReplaceTabs, (m) => " ".repeat(3 * m.length)), h = t.split(`
`, 1)[0], d = !f.trim(), p = 0;
        if (this.options.pedantic ? (p = 2, c = f.trimStart()) : d ? p = e[1].length + 1 : (p = e[2].search(this.rules.other.nonSpaceChar), p = p > 4 ? 1 : p, c = f.slice(p), p += e[1].length), d && this.rules.other.blankLine.test(h) && (u += h + `
`, t = t.substring(h.length + 1), l = !0), !l) {
          const m = this.rules.other.nextBulletRegex(p), b = this.rules.other.hrRegex(p), y = this.rules.other.fencesBeginRegex(p), x = this.rules.other.headingBeginRegex(p), E = this.rules.other.htmlBeginRegex(p);
          for (; t; ) {
            const S = t.split(`
`, 1)[0];
            let w;
            if (h = S, this.options.pedantic ? (h = h.replace(this.rules.other.listReplaceNesting, "  "), w = h) : w = h.replace(this.rules.other.tabCharGlobal, "    "), y.test(h) || x.test(h) || E.test(h) || m.test(h) || b.test(h))
              break;
            if (w.search(this.rules.other.nonSpaceChar) >= p || !h.trim())
              c += `
` + w.slice(p);
            else {
              if (d || f.replace(this.rules.other.tabCharGlobal, "    ").search(this.rules.other.nonSpaceChar) >= 4 || y.test(f) || x.test(f) || b.test(f))
                break;
              c += `
` + h;
            }
            !d && !h.trim() && (d = !0), u += S + `
`, t = t.substring(S.length + 1), f = w.slice(p);
          }
        }
        a.loose || (s ? a.loose = !0 : this.rules.other.doubleBlankLine.test(u) && (s = !0));
        let g = null, v;
        this.options.gfm && (g = this.rules.other.listIsTask.exec(c), g && (v = g[0] !== "[ ] ", c = c.replace(this.rules.other.listReplaceTask, ""))), a.items.push({
          type: "list_item",
          raw: u,
          task: !!g,
          checked: v,
          loose: !1,
          text: c,
          tokens: []
        }), a.raw += u;
      }
      const o = a.items.at(-1);
      if (o)
        o.raw = o.raw.trimEnd(), o.text = o.text.trimEnd();
      else
        return;
      a.raw = a.raw.trimEnd();
      for (let l = 0; l < a.items.length; l++)
        if (this.lexer.state.top = !1, a.items[l].tokens = this.lexer.blockTokens(a.items[l].text, []), !a.loose) {
          const u = a.items[l].tokens.filter((f) => f.type === "space"), c = u.length > 0 && u.some((f) => this.rules.other.anyLine.test(f.raw));
          a.loose = c;
        }
      if (a.loose)
        for (let l = 0; l < a.items.length; l++)
          a.items[l].loose = !0;
      return a;
    }
  }
  html(t) {
    const e = this.rules.block.html.exec(t);
    if (e)
      return {
        type: "html",
        block: !0,
        raw: e[0],
        pre: e[1] === "pre" || e[1] === "script" || e[1] === "style",
        text: e[0]
      };
  }
  def(t) {
    const e = this.rules.block.def.exec(t);
    if (e) {
      const r = e[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, " "), n = e[2] ? e[2].replace(this.rules.other.hrefBrackets, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "", a = e[3] ? e[3].substring(1, e[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : e[3];
      return {
        type: "def",
        tag: r,
        raw: e[0],
        href: n,
        title: a
      };
    }
  }
  table(t) {
    var s;
    const e = this.rules.block.table.exec(t);
    if (!e || !this.rules.other.tableDelimiter.test(e[2]))
      return;
    const r = a6(e[1]), n = e[2].replace(this.rules.other.tableAlignChars, "").split("|"), a = (s = e[3]) != null && s.trim() ? e[3].replace(this.rules.other.tableRowBlankLine, "").split(`
`) : [], i = {
      type: "table",
      raw: e[0],
      header: [],
      align: [],
      rows: []
    };
    if (r.length === n.length) {
      for (const o of n)
        this.rules.other.tableAlignRight.test(o) ? i.align.push("right") : this.rules.other.tableAlignCenter.test(o) ? i.align.push("center") : this.rules.other.tableAlignLeft.test(o) ? i.align.push("left") : i.align.push(null);
      for (let o = 0; o < r.length; o++)
        i.header.push({
          text: r[o],
          tokens: this.lexer.inline(r[o]),
          header: !0,
          align: i.align[o]
        });
      for (const o of a)
        i.rows.push(a6(o, i.header.length).map((l, u) => ({
          text: l,
          tokens: this.lexer.inline(l),
          header: !1,
          align: i.align[u]
        })));
      return i;
    }
  }
  lheading(t) {
    const e = this.rules.block.lheading.exec(t);
    if (e)
      return {
        type: "heading",
        raw: e[0],
        depth: e[2].charAt(0) === "=" ? 1 : 2,
        text: e[1],
        tokens: this.lexer.inline(e[1])
      };
  }
  paragraph(t) {
    const e = this.rules.block.paragraph.exec(t);
    if (e) {
      const r = e[1].charAt(e[1].length - 1) === `
` ? e[1].slice(0, -1) : e[1];
      return {
        type: "paragraph",
        raw: e[0],
        text: r,
        tokens: this.lexer.inline(r)
      };
    }
  }
  text(t) {
    const e = this.rules.block.text.exec(t);
    if (e)
      return {
        type: "text",
        raw: e[0],
        text: e[0],
        tokens: this.lexer.inline(e[0])
      };
  }
  escape(t) {
    const e = this.rules.inline.escape.exec(t);
    if (e)
      return {
        type: "escape",
        raw: e[0],
        text: e[1]
      };
  }
  tag(t) {
    const e = this.rules.inline.tag.exec(t);
    if (e)
      return !this.lexer.state.inLink && this.rules.other.startATag.test(e[0]) ? this.lexer.state.inLink = !0 : this.lexer.state.inLink && this.rules.other.endATag.test(e[0]) && (this.lexer.state.inLink = !1), !this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(e[0]) ? this.lexer.state.inRawBlock = !0 : this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(e[0]) && (this.lexer.state.inRawBlock = !1), {
        type: "html",
        raw: e[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        block: !1,
        text: e[0]
      };
  }
  link(t) {
    const e = this.rules.inline.link.exec(t);
    if (e) {
      const r = e[2].trim();
      if (!this.options.pedantic && this.rules.other.startAngleBracket.test(r)) {
        if (!this.rules.other.endAngleBracket.test(r))
          return;
        const i = uh(r.slice(0, -1), "\\");
        if ((r.length - i.length) % 2 === 0)
          return;
      } else {
        const i = hhe(e[2], "()");
        if (i === -2)
          return;
        if (i > -1) {
          const o = (e[0].indexOf("!") === 0 ? 5 : 4) + e[1].length + i;
          e[2] = e[2].substring(0, i), e[0] = e[0].substring(0, o).trim(), e[3] = "";
        }
      }
      let n = e[2], a = "";
      if (this.options.pedantic) {
        const i = this.rules.other.pedanticHrefTitle.exec(n);
        i && (n = i[1], a = i[3]);
      } else
        a = e[3] ? e[3].slice(1, -1) : "";
      return n = n.trim(), this.rules.other.startAngleBracket.test(n) && (this.options.pedantic && !this.rules.other.endAngleBracket.test(r) ? n = n.slice(1) : n = n.slice(1, -1)), i6(e, {
        href: n && n.replace(this.rules.inline.anyPunctuation, "$1"),
        title: a && a.replace(this.rules.inline.anyPunctuation, "$1")
      }, e[0], this.lexer, this.rules);
    }
  }
  reflink(t, e) {
    let r;
    if ((r = this.rules.inline.reflink.exec(t)) || (r = this.rules.inline.nolink.exec(t))) {
      const n = (r[2] || r[1]).replace(this.rules.other.multipleSpaceGlobal, " "), a = e[n.toLowerCase()];
      if (!a) {
        const i = r[0].charAt(0);
        return {
          type: "text",
          raw: i,
          text: i
        };
      }
      return i6(r, a, r[0], this.lexer, this.rules);
    }
  }
  emStrong(t, e, r = "") {
    let n = this.rules.inline.emStrongLDelim.exec(t);
    if (!n || n[3] && r.match(this.rules.other.unicodeAlphaNumeric)) return;
    if (!(n[1] || n[2] || "") || !r || this.rules.inline.punctuation.exec(r)) {
      const i = [...n[0]].length - 1;
      let s, o, l = i, u = 0;
      const c = n[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
      for (c.lastIndex = 0, e = e.slice(-1 * t.length + i); (n = c.exec(e)) != null; ) {
        if (s = n[1] || n[2] || n[3] || n[4] || n[5] || n[6], !s) continue;
        if (o = [...s].length, n[3] || n[4]) {
          l += o;
          continue;
        } else if ((n[5] || n[6]) && i % 3 && !((i + o) % 3)) {
          u += o;
          continue;
        }
        if (l -= o, l > 0) continue;
        o = Math.min(o, o + l + u);
        const f = [...n[0]][0].length, h = t.slice(0, i + n.index + f + o);
        if (Math.min(i, o) % 2) {
          const p = h.slice(1, -1);
          return {
            type: "em",
            raw: h,
            text: p,
            tokens: this.lexer.inlineTokens(p)
          };
        }
        const d = h.slice(2, -2);
        return {
          type: "strong",
          raw: h,
          text: d,
          tokens: this.lexer.inlineTokens(d)
        };
      }
    }
  }
  codespan(t) {
    const e = this.rules.inline.code.exec(t);
    if (e) {
      let r = e[2].replace(this.rules.other.newLineCharGlobal, " ");
      const n = this.rules.other.nonSpaceChar.test(r), a = this.rules.other.startingSpaceChar.test(r) && this.rules.other.endingSpaceChar.test(r);
      return n && a && (r = r.substring(1, r.length - 1)), {
        type: "codespan",
        raw: e[0],
        text: r
      };
    }
  }
  br(t) {
    const e = this.rules.inline.br.exec(t);
    if (e)
      return {
        type: "br",
        raw: e[0]
      };
  }
  del(t) {
    const e = this.rules.inline.del.exec(t);
    if (e)
      return {
        type: "del",
        raw: e[0],
        text: e[2],
        tokens: this.lexer.inlineTokens(e[2])
      };
  }
  autolink(t) {
    const e = this.rules.inline.autolink.exec(t);
    if (e) {
      let r, n;
      return e[2] === "@" ? (r = e[1], n = "mailto:" + r) : (r = e[1], n = r), {
        type: "link",
        raw: e[0],
        text: r,
        href: n,
        tokens: [
          {
            type: "text",
            raw: r,
            text: r
          }
        ]
      };
    }
  }
  url(t) {
    var r;
    let e;
    if (e = this.rules.inline.url.exec(t)) {
      let n, a;
      if (e[2] === "@")
        n = e[0], a = "mailto:" + n;
      else {
        let i;
        do
          i = e[0], e[0] = ((r = this.rules.inline._backpedal.exec(e[0])) == null ? void 0 : r[0]) ?? "";
        while (i !== e[0]);
        n = e[0], e[1] === "www." ? a = "http://" + e[0] : a = e[0];
      }
      return {
        type: "link",
        raw: e[0],
        text: n,
        href: a,
        tokens: [
          {
            type: "text",
            raw: n,
            text: n
          }
        ]
      };
    }
  }
  inlineText(t) {
    const e = this.rules.inline.text.exec(t);
    if (e) {
      const r = this.lexer.state.inRawBlock;
      return {
        type: "text",
        raw: e[0],
        text: e[0],
        escaped: r
      };
    }
  }
}, Ws = class FT {
  constructor(e) {
    Ye(this, "tokens");
    Ye(this, "options");
    Ye(this, "state");
    Ye(this, "tokenizer");
    Ye(this, "inlineQueue");
    this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = e || Su, this.options.tokenizer = this.options.tokenizer || new wm(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = {
      inLink: !1,
      inRawBlock: !1,
      top: !0
    };
    const r = {
      other: ua,
      block: Wp.normal,
      inline: lh.normal
    };
    this.options.pedantic ? (r.block = Wp.pedantic, r.inline = lh.pedantic) : this.options.gfm && (r.block = Wp.gfm, this.options.breaks ? r.inline = lh.breaks : r.inline = lh.gfm), this.tokenizer.rules = r;
  }
  /**
   * Expose Rules
   */
  static get rules() {
    return {
      block: Wp,
      inline: lh
    };
  }
  /**
   * Static Lex Method
   */
  static lex(e, r) {
    return new FT(r).lex(e);
  }
  /**
   * Static Lex Inline Method
   */
  static lexInline(e, r) {
    return new FT(r).inlineTokens(e);
  }
  /**
   * Preprocessing
   */
  lex(e) {
    e = e.replace(ua.carriageReturn, `
`), this.blockTokens(e, this.tokens);
    for (let r = 0; r < this.inlineQueue.length; r++) {
      const n = this.inlineQueue[r];
      this.inlineTokens(n.src, n.tokens);
    }
    return this.inlineQueue = [], this.tokens;
  }
  blockTokens(e, r = [], n = !1) {
    var a, i, s;
    for (this.options.pedantic && (e = e.replace(ua.tabCharGlobal, "    ").replace(ua.spaceLine, "")); e; ) {
      let o;
      if ((i = (a = this.options.extensions) == null ? void 0 : a.block) != null && i.some((u) => (o = u.call({ lexer: this }, e, r)) ? (e = e.substring(o.raw.length), r.push(o), !0) : !1))
        continue;
      if (o = this.tokenizer.space(e)) {
        e = e.substring(o.raw.length);
        const u = r.at(-1);
        o.raw.length === 1 && u !== void 0 ? u.raw += `
` : r.push(o);
        continue;
      }
      if (o = this.tokenizer.code(e)) {
        e = e.substring(o.raw.length);
        const u = r.at(-1);
        (u == null ? void 0 : u.type) === "paragraph" || (u == null ? void 0 : u.type) === "text" ? (u.raw += `
` + o.raw, u.text += `
` + o.text, this.inlineQueue.at(-1).src = u.text) : r.push(o);
        continue;
      }
      if (o = this.tokenizer.fences(e)) {
        e = e.substring(o.raw.length), r.push(o);
        continue;
      }
      if (o = this.tokenizer.heading(e)) {
        e = e.substring(o.raw.length), r.push(o);
        continue;
      }
      if (o = this.tokenizer.hr(e)) {
        e = e.substring(o.raw.length), r.push(o);
        continue;
      }
      if (o = this.tokenizer.blockquote(e)) {
        e = e.substring(o.raw.length), r.push(o);
        continue;
      }
      if (o = this.tokenizer.list(e)) {
        e = e.substring(o.raw.length), r.push(o);
        continue;
      }
      if (o = this.tokenizer.html(e)) {
        e = e.substring(o.raw.length), r.push(o);
        continue;
      }
      if (o = this.tokenizer.def(e)) {
        e = e.substring(o.raw.length);
        const u = r.at(-1);
        (u == null ? void 0 : u.type) === "paragraph" || (u == null ? void 0 : u.type) === "text" ? (u.raw += `
` + o.raw, u.text += `
` + o.raw, this.inlineQueue.at(-1).src = u.text) : this.tokens.links[o.tag] || (this.tokens.links[o.tag] = {
          href: o.href,
          title: o.title
        });
        continue;
      }
      if (o = this.tokenizer.table(e)) {
        e = e.substring(o.raw.length), r.push(o);
        continue;
      }
      if (o = this.tokenizer.lheading(e)) {
        e = e.substring(o.raw.length), r.push(o);
        continue;
      }
      let l = e;
      if ((s = this.options.extensions) != null && s.startBlock) {
        let u = 1 / 0;
        const c = e.slice(1);
        let f;
        this.options.extensions.startBlock.forEach((h) => {
          f = h.call({ lexer: this }, c), typeof f == "number" && f >= 0 && (u = Math.min(u, f));
        }), u < 1 / 0 && u >= 0 && (l = e.substring(0, u + 1));
      }
      if (this.state.top && (o = this.tokenizer.paragraph(l))) {
        const u = r.at(-1);
        n && (u == null ? void 0 : u.type) === "paragraph" ? (u.raw += `
` + o.raw, u.text += `
` + o.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = u.text) : r.push(o), n = l.length !== e.length, e = e.substring(o.raw.length);
        continue;
      }
      if (o = this.tokenizer.text(e)) {
        e = e.substring(o.raw.length);
        const u = r.at(-1);
        (u == null ? void 0 : u.type) === "text" ? (u.raw += `
` + o.raw, u.text += `
` + o.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = u.text) : r.push(o);
        continue;
      }
      if (e) {
        const u = "Infinite loop on byte: " + e.charCodeAt(0);
        if (this.options.silent) {
          console.error(u);
          break;
        } else
          throw new Error(u);
      }
    }
    return this.state.top = !0, r;
  }
  inline(e, r = []) {
    return this.inlineQueue.push({ src: e, tokens: r }), r;
  }
  /**
   * Lexing/Compiling
   */
  inlineTokens(e, r = []) {
    var o, l, u;
    let n = e, a = null;
    if (this.tokens.links) {
      const c = Object.keys(this.tokens.links);
      if (c.length > 0)
        for (; (a = this.tokenizer.rules.inline.reflinkSearch.exec(n)) != null; )
          c.includes(a[0].slice(a[0].lastIndexOf("[") + 1, -1)) && (n = n.slice(0, a.index) + "[" + "a".repeat(a[0].length - 2) + "]" + n.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
    }
    for (; (a = this.tokenizer.rules.inline.anyPunctuation.exec(n)) != null; )
      n = n.slice(0, a.index) + "++" + n.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
    for (; (a = this.tokenizer.rules.inline.blockSkip.exec(n)) != null; )
      n = n.slice(0, a.index) + "[" + "a".repeat(a[0].length - 2) + "]" + n.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    let i = !1, s = "";
    for (; e; ) {
      i || (s = ""), i = !1;
      let c;
      if ((l = (o = this.options.extensions) == null ? void 0 : o.inline) != null && l.some((h) => (c = h.call({ lexer: this }, e, r)) ? (e = e.substring(c.raw.length), r.push(c), !0) : !1))
        continue;
      if (c = this.tokenizer.escape(e)) {
        e = e.substring(c.raw.length), r.push(c);
        continue;
      }
      if (c = this.tokenizer.tag(e)) {
        e = e.substring(c.raw.length), r.push(c);
        continue;
      }
      if (c = this.tokenizer.link(e)) {
        e = e.substring(c.raw.length), r.push(c);
        continue;
      }
      if (c = this.tokenizer.reflink(e, this.tokens.links)) {
        e = e.substring(c.raw.length);
        const h = r.at(-1);
        c.type === "text" && (h == null ? void 0 : h.type) === "text" ? (h.raw += c.raw, h.text += c.text) : r.push(c);
        continue;
      }
      if (c = this.tokenizer.emStrong(e, n, s)) {
        e = e.substring(c.raw.length), r.push(c);
        continue;
      }
      if (c = this.tokenizer.codespan(e)) {
        e = e.substring(c.raw.length), r.push(c);
        continue;
      }
      if (c = this.tokenizer.br(e)) {
        e = e.substring(c.raw.length), r.push(c);
        continue;
      }
      if (c = this.tokenizer.del(e)) {
        e = e.substring(c.raw.length), r.push(c);
        continue;
      }
      if (c = this.tokenizer.autolink(e)) {
        e = e.substring(c.raw.length), r.push(c);
        continue;
      }
      if (!this.state.inLink && (c = this.tokenizer.url(e))) {
        e = e.substring(c.raw.length), r.push(c);
        continue;
      }
      let f = e;
      if ((u = this.options.extensions) != null && u.startInline) {
        let h = 1 / 0;
        const d = e.slice(1);
        let p;
        this.options.extensions.startInline.forEach((g) => {
          p = g.call({ lexer: this }, d), typeof p == "number" && p >= 0 && (h = Math.min(h, p));
        }), h < 1 / 0 && h >= 0 && (f = e.substring(0, h + 1));
      }
      if (c = this.tokenizer.inlineText(f)) {
        e = e.substring(c.raw.length), c.raw.slice(-1) !== "_" && (s = c.raw.slice(-1)), i = !0;
        const h = r.at(-1);
        (h == null ? void 0 : h.type) === "text" ? (h.raw += c.raw, h.text += c.text) : r.push(c);
        continue;
      }
      if (e) {
        const h = "Infinite loop on byte: " + e.charCodeAt(0);
        if (this.options.silent) {
          console.error(h);
          break;
        } else
          throw new Error(h);
      }
    }
    return r;
  }
}, Em = class {
  // set by the parser
  constructor(t) {
    Ye(this, "options");
    Ye(this, "parser");
    this.options = t || Su;
  }
  space(t) {
    return "";
  }
  code({ text: t, lang: e, escaped: r }) {
    var i;
    const n = (i = (e || "").match(ua.notSpaceStart)) == null ? void 0 : i[0], a = t.replace(ua.endingNewline, "") + `
`;
    return n ? '<pre><code class="language-' + is(n) + '">' + (r ? a : is(a, !0)) + `</code></pre>
` : "<pre><code>" + (r ? a : is(a, !0)) + `</code></pre>
`;
  }
  blockquote({ tokens: t }) {
    return `<blockquote>
${this.parser.parse(t)}</blockquote>
`;
  }
  html({ text: t }) {
    return t;
  }
  heading({ tokens: t, depth: e }) {
    return `<h${e}>${this.parser.parseInline(t)}</h${e}>
`;
  }
  hr(t) {
    return `<hr>
`;
  }
  list(t) {
    const e = t.ordered, r = t.start;
    let n = "";
    for (let s = 0; s < t.items.length; s++) {
      const o = t.items[s];
      n += this.listitem(o);
    }
    const a = e ? "ol" : "ul", i = e && r !== 1 ? ' start="' + r + '"' : "";
    return "<" + a + i + `>
` + n + "</" + a + `>
`;
  }
  listitem(t) {
    var r;
    let e = "";
    if (t.task) {
      const n = this.checkbox({ checked: !!t.checked });
      t.loose ? ((r = t.tokens[0]) == null ? void 0 : r.type) === "paragraph" ? (t.tokens[0].text = n + " " + t.tokens[0].text, t.tokens[0].tokens && t.tokens[0].tokens.length > 0 && t.tokens[0].tokens[0].type === "text" && (t.tokens[0].tokens[0].text = n + " " + is(t.tokens[0].tokens[0].text), t.tokens[0].tokens[0].escaped = !0)) : t.tokens.unshift({
        type: "text",
        raw: n + " ",
        text: n + " ",
        escaped: !0
      }) : e += n + " ";
    }
    return e += this.parser.parse(t.tokens, !!t.loose), `<li>${e}</li>
`;
  }
  checkbox({ checked: t }) {
    return "<input " + (t ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
  }
  paragraph({ tokens: t }) {
    return `<p>${this.parser.parseInline(t)}</p>
`;
  }
  table(t) {
    let e = "", r = "";
    for (let a = 0; a < t.header.length; a++)
      r += this.tablecell(t.header[a]);
    e += this.tablerow({ text: r });
    let n = "";
    for (let a = 0; a < t.rows.length; a++) {
      const i = t.rows[a];
      r = "";
      for (let s = 0; s < i.length; s++)
        r += this.tablecell(i[s]);
      n += this.tablerow({ text: r });
    }
    return n && (n = `<tbody>${n}</tbody>`), `<table>
<thead>
` + e + `</thead>
` + n + `</table>
`;
  }
  tablerow({ text: t }) {
    return `<tr>
${t}</tr>
`;
  }
  tablecell(t) {
    const e = this.parser.parseInline(t.tokens), r = t.header ? "th" : "td";
    return (t.align ? `<${r} align="${t.align}">` : `<${r}>`) + e + `</${r}>
`;
  }
  /**
   * span level renderer
   */
  strong({ tokens: t }) {
    return `<strong>${this.parser.parseInline(t)}</strong>`;
  }
  em({ tokens: t }) {
    return `<em>${this.parser.parseInline(t)}</em>`;
  }
  codespan({ text: t }) {
    return `<code>${is(t, !0)}</code>`;
  }
  br(t) {
    return "<br>";
  }
  del({ tokens: t }) {
    return `<del>${this.parser.parseInline(t)}</del>`;
  }
  link({ href: t, title: e, tokens: r }) {
    const n = this.parser.parseInline(r), a = n6(t);
    if (a === null)
      return n;
    t = a;
    let i = '<a href="' + t + '"';
    return e && (i += ' title="' + is(e) + '"'), i += ">" + n + "</a>", i;
  }
  image({ href: t, title: e, text: r, tokens: n }) {
    n && (r = this.parser.parseInline(n, this.parser.textRenderer));
    const a = n6(t);
    if (a === null)
      return is(r);
    t = a;
    let i = `<img src="${t}" alt="${r}"`;
    return e && (i += ` title="${is(e)}"`), i += ">", i;
  }
  text(t) {
    return "tokens" in t && t.tokens ? this.parser.parseInline(t.tokens) : "escaped" in t && t.escaped ? t.text : is(t.text);
  }
}, X5 = class {
  // no need for block level renderers
  strong({ text: t }) {
    return t;
  }
  em({ text: t }) {
    return t;
  }
  codespan({ text: t }) {
    return t;
  }
  del({ text: t }) {
    return t;
  }
  html({ text: t }) {
    return t;
  }
  text({ text: t }) {
    return t;
  }
  link({ text: t }) {
    return "" + t;
  }
  image({ text: t }) {
    return "" + t;
  }
  br() {
    return "";
  }
}, js = class BT {
  constructor(e) {
    Ye(this, "options");
    Ye(this, "renderer");
    Ye(this, "textRenderer");
    this.options = e || Su, this.options.renderer = this.options.renderer || new Em(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.renderer.parser = this, this.textRenderer = new X5();
  }
  /**
   * Static Parse Method
   */
  static parse(e, r) {
    return new BT(r).parse(e);
  }
  /**
   * Static Parse Inline Method
   */
  static parseInline(e, r) {
    return new BT(r).parseInline(e);
  }
  /**
   * Parse Loop
   */
  parse(e, r = !0) {
    var a, i;
    let n = "";
    for (let s = 0; s < e.length; s++) {
      const o = e[s];
      if ((i = (a = this.options.extensions) == null ? void 0 : a.renderers) != null && i[o.type]) {
        const u = o, c = this.options.extensions.renderers[u.type].call({ parser: this }, u);
        if (c !== !1 || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(u.type)) {
          n += c || "";
          continue;
        }
      }
      const l = o;
      switch (l.type) {
        case "space": {
          n += this.renderer.space(l);
          continue;
        }
        case "hr": {
          n += this.renderer.hr(l);
          continue;
        }
        case "heading": {
          n += this.renderer.heading(l);
          continue;
        }
        case "code": {
          n += this.renderer.code(l);
          continue;
        }
        case "table": {
          n += this.renderer.table(l);
          continue;
        }
        case "blockquote": {
          n += this.renderer.blockquote(l);
          continue;
        }
        case "list": {
          n += this.renderer.list(l);
          continue;
        }
        case "html": {
          n += this.renderer.html(l);
          continue;
        }
        case "paragraph": {
          n += this.renderer.paragraph(l);
          continue;
        }
        case "text": {
          let u = l, c = this.renderer.text(u);
          for (; s + 1 < e.length && e[s + 1].type === "text"; )
            u = e[++s], c += `
` + this.renderer.text(u);
          r ? n += this.renderer.paragraph({
            type: "paragraph",
            raw: c,
            text: c,
            tokens: [{ type: "text", raw: c, text: c, escaped: !0 }]
          }) : n += c;
          continue;
        }
        default: {
          const u = 'Token with "' + l.type + '" type was not found.';
          if (this.options.silent)
            return console.error(u), "";
          throw new Error(u);
        }
      }
    }
    return n;
  }
  /**
   * Parse Inline Tokens
   */
  parseInline(e, r = this.renderer) {
    var a, i;
    let n = "";
    for (let s = 0; s < e.length; s++) {
      const o = e[s];
      if ((i = (a = this.options.extensions) == null ? void 0 : a.renderers) != null && i[o.type]) {
        const u = this.options.extensions.renderers[o.type].call({ parser: this }, o);
        if (u !== !1 || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(o.type)) {
          n += u || "";
          continue;
        }
      }
      const l = o;
      switch (l.type) {
        case "escape": {
          n += r.text(l);
          break;
        }
        case "html": {
          n += r.html(l);
          break;
        }
        case "link": {
          n += r.link(l);
          break;
        }
        case "image": {
          n += r.image(l);
          break;
        }
        case "strong": {
          n += r.strong(l);
          break;
        }
        case "em": {
          n += r.em(l);
          break;
        }
        case "codespan": {
          n += r.codespan(l);
          break;
        }
        case "br": {
          n += r.br(l);
          break;
        }
        case "del": {
          n += r.del(l);
          break;
        }
        case "text": {
          n += r.text(l);
          break;
        }
        default: {
          const u = 'Token with "' + l.type + '" type was not found.';
          if (this.options.silent)
            return console.error(u), "";
          throw new Error(u);
        }
      }
    }
    return n;
  }
}, hE, cv = (hE = class {
  constructor(t) {
    Ye(this, "options");
    Ye(this, "block");
    this.options = t || Su;
  }
  /**
   * Process markdown before marked
   */
  preprocess(t) {
    return t;
  }
  /**
   * Process HTML after marked is finished
   */
  postprocess(t) {
    return t;
  }
  /**
   * Process all tokens before walk tokens
   */
  processAllTokens(t) {
    return t;
  }
  /**
   * Provide function to tokenize markdown
   */
  provideLexer() {
    return this.block ? Ws.lex : Ws.lexInline;
  }
  /**
   * Provide function to parse tokens
   */
  provideParser() {
    return this.block ? js.parse : js.parseInline;
  }
}, Ye(hE, "passThroughHooks", /* @__PURE__ */ new Set([
  "preprocess",
  "postprocess",
  "processAllTokens"
])), hE), phe = class {
  constructor(...t) {
    Ye(this, "defaults", G5());
    Ye(this, "options", this.setOptions);
    Ye(this, "parse", this.parseMarkdown(!0));
    Ye(this, "parseInline", this.parseMarkdown(!1));
    Ye(this, "Parser", js);
    Ye(this, "Renderer", Em);
    Ye(this, "TextRenderer", X5);
    Ye(this, "Lexer", Ws);
    Ye(this, "Tokenizer", wm);
    Ye(this, "Hooks", cv);
    this.use(...t);
  }
  /**
   * Run callback for every token
   */
  walkTokens(t, e) {
    var n, a;
    let r = [];
    for (const i of t)
      switch (r = r.concat(e.call(this, i)), i.type) {
        case "table": {
          const s = i;
          for (const o of s.header)
            r = r.concat(this.walkTokens(o.tokens, e));
          for (const o of s.rows)
            for (const l of o)
              r = r.concat(this.walkTokens(l.tokens, e));
          break;
        }
        case "list": {
          const s = i;
          r = r.concat(this.walkTokens(s.items, e));
          break;
        }
        default: {
          const s = i;
          (a = (n = this.defaults.extensions) == null ? void 0 : n.childTokens) != null && a[s.type] ? this.defaults.extensions.childTokens[s.type].forEach((o) => {
            const l = s[o].flat(1 / 0);
            r = r.concat(this.walkTokens(l, e));
          }) : s.tokens && (r = r.concat(this.walkTokens(s.tokens, e)));
        }
      }
    return r;
  }
  use(...t) {
    const e = this.defaults.extensions || { renderers: {}, childTokens: {} };
    return t.forEach((r) => {
      const n = { ...r };
      if (n.async = this.defaults.async || n.async || !1, r.extensions && (r.extensions.forEach((a) => {
        if (!a.name)
          throw new Error("extension name required");
        if ("renderer" in a) {
          const i = e.renderers[a.name];
          i ? e.renderers[a.name] = function(...s) {
            let o = a.renderer.apply(this, s);
            return o === !1 && (o = i.apply(this, s)), o;
          } : e.renderers[a.name] = a.renderer;
        }
        if ("tokenizer" in a) {
          if (!a.level || a.level !== "block" && a.level !== "inline")
            throw new Error("extension level must be 'block' or 'inline'");
          const i = e[a.level];
          i ? i.unshift(a.tokenizer) : e[a.level] = [a.tokenizer], a.start && (a.level === "block" ? e.startBlock ? e.startBlock.push(a.start) : e.startBlock = [a.start] : a.level === "inline" && (e.startInline ? e.startInline.push(a.start) : e.startInline = [a.start]));
        }
        "childTokens" in a && a.childTokens && (e.childTokens[a.name] = a.childTokens);
      }), n.extensions = e), r.renderer) {
        const a = this.defaults.renderer || new Em(this.defaults);
        for (const i in r.renderer) {
          if (!(i in a))
            throw new Error(`renderer '${i}' does not exist`);
          if (["options", "parser"].includes(i))
            continue;
          const s = i, o = r.renderer[s], l = a[s];
          a[s] = (...u) => {
            let c = o.apply(a, u);
            return c === !1 && (c = l.apply(a, u)), c || "";
          };
        }
        n.renderer = a;
      }
      if (r.tokenizer) {
        const a = this.defaults.tokenizer || new wm(this.defaults);
        for (const i in r.tokenizer) {
          if (!(i in a))
            throw new Error(`tokenizer '${i}' does not exist`);
          if (["options", "rules", "lexer"].includes(i))
            continue;
          const s = i, o = r.tokenizer[s], l = a[s];
          a[s] = (...u) => {
            let c = o.apply(a, u);
            return c === !1 && (c = l.apply(a, u)), c;
          };
        }
        n.tokenizer = a;
      }
      if (r.hooks) {
        const a = this.defaults.hooks || new cv();
        for (const i in r.hooks) {
          if (!(i in a))
            throw new Error(`hook '${i}' does not exist`);
          if (["options", "block"].includes(i))
            continue;
          const s = i, o = r.hooks[s], l = a[s];
          cv.passThroughHooks.has(i) ? a[s] = (u) => {
            if (this.defaults.async)
              return Promise.resolve(o.call(a, u)).then((f) => l.call(a, f));
            const c = o.call(a, u);
            return l.call(a, c);
          } : a[s] = (...u) => {
            let c = o.apply(a, u);
            return c === !1 && (c = l.apply(a, u)), c;
          };
        }
        n.hooks = a;
      }
      if (r.walkTokens) {
        const a = this.defaults.walkTokens, i = r.walkTokens;
        n.walkTokens = function(s) {
          let o = [];
          return o.push(i.call(this, s)), a && (o = o.concat(a.call(this, s))), o;
        };
      }
      this.defaults = { ...this.defaults, ...n };
    }), this;
  }
  setOptions(t) {
    return this.defaults = { ...this.defaults, ...t }, this;
  }
  lexer(t, e) {
    return Ws.lex(t, e ?? this.defaults);
  }
  parser(t, e) {
    return js.parse(t, e ?? this.defaults);
  }
  parseMarkdown(t) {
    return (r, n) => {
      const a = { ...n }, i = { ...this.defaults, ...a }, s = this.onError(!!i.silent, !!i.async);
      if (this.defaults.async === !0 && a.async === !1)
        return s(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
      if (typeof r > "u" || r === null)
        return s(new Error("marked(): input parameter is undefined or null"));
      if (typeof r != "string")
        return s(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(r) + ", string expected"));
      i.hooks && (i.hooks.options = i, i.hooks.block = t);
      const o = i.hooks ? i.hooks.provideLexer() : t ? Ws.lex : Ws.lexInline, l = i.hooks ? i.hooks.provideParser() : t ? js.parse : js.parseInline;
      if (i.async)
        return Promise.resolve(i.hooks ? i.hooks.preprocess(r) : r).then((u) => o(u, i)).then((u) => i.hooks ? i.hooks.processAllTokens(u) : u).then((u) => i.walkTokens ? Promise.all(this.walkTokens(u, i.walkTokens)).then(() => u) : u).then((u) => l(u, i)).then((u) => i.hooks ? i.hooks.postprocess(u) : u).catch(s);
      try {
        i.hooks && (r = i.hooks.preprocess(r));
        let u = o(r, i);
        i.hooks && (u = i.hooks.processAllTokens(u)), i.walkTokens && this.walkTokens(u, i.walkTokens);
        let c = l(u, i);
        return i.hooks && (c = i.hooks.postprocess(c)), c;
      } catch (u) {
        return s(u);
      }
    };
  }
  onError(t, e) {
    return (r) => {
      if (r.message += `
Please report this to https://github.com/markedjs/marked.`, t) {
        const n = "<p>An error occurred:</p><pre>" + is(r.message + "", !0) + "</pre>";
        return e ? Promise.resolve(n) : n;
      }
      if (e)
        return Promise.reject(r);
      throw r;
    };
  }
}, tu = new phe();
function Tr(t, e) {
  return tu.parse(t, e);
}
Tr.options = Tr.setOptions = function(t) {
  return tu.setOptions(t), Tr.defaults = tu.defaults, lD(Tr.defaults), Tr;
};
Tr.getDefaults = G5;
Tr.defaults = Su;
Tr.use = function(...t) {
  return tu.use(...t), Tr.defaults = tu.defaults, lD(Tr.defaults), Tr;
};
Tr.walkTokens = function(t, e) {
  return tu.walkTokens(t, e);
};
Tr.parseInline = tu.parseInline;
Tr.Parser = js;
Tr.parser = js.parse;
Tr.Renderer = Em;
Tr.TextRenderer = X5;
Tr.Lexer = Ws;
Tr.lexer = Ws.lex;
Tr.Tokenizer = wm;
Tr.Hooks = cv;
Tr.parse = Tr;
Tr.options;
Tr.setOptions;
Tr.use;
Tr.walkTokens;
Tr.parseInline;
js.parse;
Ws.lex;
var bD = {}, K5 = {}, Z5 = {}, Cu = {}, Q5 = {}, J5 = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.Doctype = t.CDATA = t.Tag = t.Style = t.Script = t.Comment = t.Directive = t.Text = t.Root = t.isTag = t.ElementType = void 0;
  var e;
  (function(n) {
    n.Root = "root", n.Text = "text", n.Directive = "directive", n.Comment = "comment", n.Script = "script", n.Style = "style", n.Tag = "tag", n.CDATA = "cdata", n.Doctype = "doctype";
  })(e = t.ElementType || (t.ElementType = {}));
  function r(n) {
    return n.type === e.Tag || n.type === e.Script || n.type === e.Style;
  }
  t.isTag = r, t.Root = e.Root, t.Text = e.Text, t.Directive = e.Directive, t.Comment = e.Comment, t.Script = e.Script, t.Style = e.Style, t.Tag = e.Tag, t.CDATA = e.CDATA, t.Doctype = e.Doctype;
})(J5);
var Wt = {}, ul = Jt && Jt.__extends || /* @__PURE__ */ function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, a) {
      n.__proto__ = a;
    } || function(n, a) {
      for (var i in a) Object.prototype.hasOwnProperty.call(a, i) && (n[i] = a[i]);
    }, t(e, r);
  };
  return function(e, r) {
    if (typeof r != "function" && r !== null)
      throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    t(e, r);
    function n() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
  };
}(), Cd = Jt && Jt.__assign || function() {
  return Cd = Object.assign || function(t) {
    for (var e, r = 1, n = arguments.length; r < n; r++) {
      e = arguments[r];
      for (var a in e) Object.prototype.hasOwnProperty.call(e, a) && (t[a] = e[a]);
    }
    return t;
  }, Cd.apply(this, arguments);
};
Object.defineProperty(Wt, "__esModule", { value: !0 });
Wt.cloneNode = Wt.hasChildren = Wt.isDocument = Wt.isDirective = Wt.isComment = Wt.isText = Wt.isCDATA = Wt.isTag = Wt.Element = Wt.Document = Wt.CDATA = Wt.NodeWithChildren = Wt.ProcessingInstruction = Wt.Comment = Wt.Text = Wt.DataNode = Wt.Node = void 0;
var Aa = J5, eC = (
  /** @class */
  function() {
    function t() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(t.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(e) {
        this.parent = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(e) {
        this.prev = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(e) {
        this.next = e;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.cloneNode = function(e) {
      return e === void 0 && (e = !1), tC(this, e);
    }, t;
  }()
);
Wt.Node = eC;
var T1 = (
  /** @class */
  function(t) {
    ul(e, t);
    function e(r) {
      var n = t.call(this) || this;
      return n.data = r, n;
    }
    return Object.defineProperty(e.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(r) {
        this.data = r;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(eC)
);
Wt.DataNode = T1;
var xD = (
  /** @class */
  function(t) {
    ul(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = Aa.ElementType.Text, r;
    }
    return Object.defineProperty(e.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(T1)
);
Wt.Text = xD;
var wD = (
  /** @class */
  function(t) {
    ul(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = Aa.ElementType.Comment, r;
    }
    return Object.defineProperty(e.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(T1)
);
Wt.Comment = wD;
var ED = (
  /** @class */
  function(t) {
    ul(e, t);
    function e(r, n) {
      var a = t.call(this, n) || this;
      return a.name = r, a.type = Aa.ElementType.Directive, a;
    }
    return Object.defineProperty(e.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(T1)
);
Wt.ProcessingInstruction = ED;
var S1 = (
  /** @class */
  function(t) {
    ul(e, t);
    function e(r) {
      var n = t.call(this) || this;
      return n.children = r, n;
    }
    return Object.defineProperty(e.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var r;
        return (r = this.children[0]) !== null && r !== void 0 ? r : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(r) {
        this.children = r;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(eC)
);
Wt.NodeWithChildren = S1;
var TD = (
  /** @class */
  function(t) {
    ul(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = Aa.ElementType.CDATA, r;
    }
    return Object.defineProperty(e.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(S1)
);
Wt.CDATA = TD;
var SD = (
  /** @class */
  function(t) {
    ul(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = Aa.ElementType.Root, r;
    }
    return Object.defineProperty(e.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(S1)
);
Wt.Document = SD;
var CD = (
  /** @class */
  function(t) {
    ul(e, t);
    function e(r, n, a, i) {
      a === void 0 && (a = []), i === void 0 && (i = r === "script" ? Aa.ElementType.Script : r === "style" ? Aa.ElementType.Style : Aa.ElementType.Tag);
      var s = t.call(this, a) || this;
      return s.name = r, s.attribs = n, s.type = i, s;
    }
    return Object.defineProperty(e.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(r) {
        this.name = r;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "attributes", {
      get: function() {
        var r = this;
        return Object.keys(this.attribs).map(function(n) {
          var a, i;
          return {
            name: n,
            value: r.attribs[n],
            namespace: (a = r["x-attribsNamespace"]) === null || a === void 0 ? void 0 : a[n],
            prefix: (i = r["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[n]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(S1)
);
Wt.Element = CD;
function AD(t) {
  return (0, Aa.isTag)(t);
}
Wt.isTag = AD;
function kD(t) {
  return t.type === Aa.ElementType.CDATA;
}
Wt.isCDATA = kD;
function RD(t) {
  return t.type === Aa.ElementType.Text;
}
Wt.isText = RD;
function MD(t) {
  return t.type === Aa.ElementType.Comment;
}
Wt.isComment = MD;
function _D(t) {
  return t.type === Aa.ElementType.Directive;
}
Wt.isDirective = _D;
function LD(t) {
  return t.type === Aa.ElementType.Root;
}
Wt.isDocument = LD;
function ghe(t) {
  return Object.prototype.hasOwnProperty.call(t, "children");
}
Wt.hasChildren = ghe;
function tC(t, e) {
  e === void 0 && (e = !1);
  var r;
  if (RD(t))
    r = new xD(t.data);
  else if (MD(t))
    r = new wD(t.data);
  else if (AD(t)) {
    var n = e ? Tx(t.children) : [], a = new CD(t.name, Cd({}, t.attribs), n);
    n.forEach(function(l) {
      return l.parent = a;
    }), t.namespace != null && (a.namespace = t.namespace), t["x-attribsNamespace"] && (a["x-attribsNamespace"] = Cd({}, t["x-attribsNamespace"])), t["x-attribsPrefix"] && (a["x-attribsPrefix"] = Cd({}, t["x-attribsPrefix"])), r = a;
  } else if (kD(t)) {
    var n = e ? Tx(t.children) : [], i = new TD(n);
    n.forEach(function(u) {
      return u.parent = i;
    }), r = i;
  } else if (LD(t)) {
    var n = e ? Tx(t.children) : [], s = new SD(n);
    n.forEach(function(u) {
      return u.parent = s;
    }), t["x-mode"] && (s["x-mode"] = t["x-mode"]), r = s;
  } else if (_D(t)) {
    var o = new ED(t.name, t.data);
    t["x-name"] != null && (o["x-name"] = t["x-name"], o["x-publicId"] = t["x-publicId"], o["x-systemId"] = t["x-systemId"]), r = o;
  } else
    throw new Error("Not implemented yet: ".concat(t.type));
  return r.startIndex = t.startIndex, r.endIndex = t.endIndex, t.sourceCodeLocation != null && (r.sourceCodeLocation = t.sourceCodeLocation), r;
}
Wt.cloneNode = tC;
function Tx(t) {
  for (var e = t.map(function(n) {
    return tC(n, !0);
  }), r = 1; r < e.length; r++)
    e[r].prev = e[r - 1], e[r - 1].next = e[r];
  return e;
}
(function(t) {
  var e = Jt && Jt.__createBinding || (Object.create ? function(o, l, u, c) {
    c === void 0 && (c = u);
    var f = Object.getOwnPropertyDescriptor(l, u);
    (!f || ("get" in f ? !l.__esModule : f.writable || f.configurable)) && (f = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(o, c, f);
  } : function(o, l, u, c) {
    c === void 0 && (c = u), o[c] = l[u];
  }), r = Jt && Jt.__exportStar || function(o, l) {
    for (var u in o) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && e(l, o, u);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.DomHandler = void 0;
  var n = J5, a = Wt;
  r(Wt, t);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, s = (
    /** @class */
    function() {
      function o(l, u, c) {
        this.dom = [], this.root = new a.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return o.prototype.onparserinit = function(l) {
        this.parser = l;
      }, o.prototype.onreset = function() {
        this.dom = [], this.root = new a.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, o.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, o.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, o.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, o.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? n.ElementType.Tag : void 0, f = new a.Element(l, u, void 0, c);
        this.addNode(f), this.tagStack.push(f);
      }, o.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === n.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new a.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, o.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === n.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new a.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, o.prototype.oncommentend = function() {
        this.lastNode = null;
      }, o.prototype.oncdatastart = function() {
        var l = new a.Text(""), u = new a.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, o.prototype.oncdataend = function() {
        this.lastNode = null;
      }, o.prototype.onprocessinginstruction = function(l, u) {
        var c = new a.ProcessingInstruction(l, u);
        this.addNode(c);
      }, o.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, o.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, o;
    }()
  );
  t.DomHandler = s, t.default = s;
})(Q5);
var ND = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.CARRIAGE_RETURN_PLACEHOLDER_REGEX = t.CARRIAGE_RETURN_PLACEHOLDER = t.CARRIAGE_RETURN_REGEX = t.CARRIAGE_RETURN = t.CASE_SENSITIVE_TAG_NAMES_MAP = t.CASE_SENSITIVE_TAG_NAMES = void 0, t.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], t.CASE_SENSITIVE_TAG_NAMES_MAP = t.CASE_SENSITIVE_TAG_NAMES.reduce(function(e, r) {
    return e[r.toLowerCase()] = r, e;
  }, {}), t.CARRIAGE_RETURN = "\r", t.CARRIAGE_RETURN_REGEX = new RegExp(t.CARRIAGE_RETURN, "g"), t.CARRIAGE_RETURN_PLACEHOLDER = "__HTML_DOM_PARSER_CARRIAGE_RETURN_PLACEHOLDER_".concat(Date.now(), "__"), t.CARRIAGE_RETURN_PLACEHOLDER_REGEX = new RegExp(t.CARRIAGE_RETURN_PLACEHOLDER, "g");
})(ND);
Object.defineProperty(Cu, "__esModule", { value: !0 });
Cu.formatAttributes = OD;
Cu.escapeSpecialCharacters = yhe;
Cu.revertEscapedCharacters = ID;
Cu.formatDOM = PD;
var jp = Q5, Jd = ND;
function vhe(t) {
  return Jd.CASE_SENSITIVE_TAG_NAMES_MAP[t];
}
function OD(t) {
  for (var e = {}, r = 0, n = t.length; r < n; r++) {
    var a = t[r];
    e[a.name] = a.value;
  }
  return e;
}
function mhe(t) {
  t = t.toLowerCase();
  var e = vhe(t);
  return e || t;
}
function yhe(t) {
  return t.replace(Jd.CARRIAGE_RETURN_REGEX, Jd.CARRIAGE_RETURN_PLACEHOLDER);
}
function ID(t) {
  return t.replace(Jd.CARRIAGE_RETURN_PLACEHOLDER_REGEX, Jd.CARRIAGE_RETURN);
}
function PD(t, e, r) {
  e === void 0 && (e = null);
  for (var n = [], a, i = 0, s = t.length; i < s; i++) {
    var o = t[i];
    switch (o.nodeType) {
      case 1: {
        var l = mhe(o.nodeName);
        a = new jp.Element(l, OD(o.attributes)), a.children = PD(
          // template children are on content
          l === "template" ? o.content.childNodes : o.childNodes,
          a
        );
        break;
      }
      case 3:
        a = new jp.Text(ID(o.nodeValue));
        break;
      case 8:
        a = new jp.Comment(o.nodeValue);
        break;
      default:
        continue;
    }
    var u = n[i - 1] || null;
    u && (u.next = a), a.parent = e, a.prev = u, a.next = null, n.push(a);
  }
  return r && (a = new jp.ProcessingInstruction(r.substring(0, r.indexOf(" ")).toLowerCase(), r), a.next = n[0] || null, a.parent = e, n.unshift(a), n[1] && (n[1].prev = n[0])), n;
}
Object.defineProperty(Z5, "__esModule", { value: !0 });
Z5.default = The;
var bhe = Cu, s6 = "html", o6 = "head", Yp = "body", xhe = /<([a-zA-Z]+[0-9]?)/, l6 = /<head[^]*>/i, u6 = /<body[^]*>/i, Tm = function(t, e) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, zT = function(t, e) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, c6 = typeof window == "object" && window.DOMParser;
if (typeof c6 == "function") {
  var whe = new c6(), Ehe = "text/html";
  zT = function(t, e) {
    return e && (t = "<".concat(e, ">").concat(t, "</").concat(e, ">")), whe.parseFromString(t, Ehe);
  }, Tm = zT;
}
if (typeof document == "object" && document.implementation) {
  var Xp = document.implementation.createHTMLDocument();
  Tm = function(t, e) {
    if (e) {
      var r = Xp.documentElement.querySelector(e);
      return r && (r.innerHTML = t), Xp;
    }
    return Xp.documentElement.innerHTML = t, Xp;
  };
}
var Kp = typeof document == "object" && document.createElement("template"), GT;
Kp && Kp.content && (GT = function(t) {
  return Kp.innerHTML = t, Kp.content.childNodes;
});
function The(t) {
  var e, r;
  t = (0, bhe.escapeSpecialCharacters)(t);
  var n = t.match(xhe), a = n && n[1] ? n[1].toLowerCase() : "";
  switch (a) {
    case s6: {
      var i = zT(t);
      if (!l6.test(t)) {
        var s = i.querySelector(o6);
        (e = s == null ? void 0 : s.parentNode) === null || e === void 0 || e.removeChild(s);
      }
      if (!u6.test(t)) {
        var s = i.querySelector(Yp);
        (r = s == null ? void 0 : s.parentNode) === null || r === void 0 || r.removeChild(s);
      }
      return i.querySelectorAll(s6);
    }
    case o6:
    case Yp: {
      var o = Tm(t).querySelectorAll(a);
      return u6.test(t) && l6.test(t) ? o[0].parentNode.childNodes : o;
    }
    default: {
      if (GT)
        return GT(t);
      var s = Tm(t, Yp).querySelector(Yp);
      return s.childNodes;
    }
  }
}
var She = Jt && Jt.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(K5, "__esModule", { value: !0 });
K5.default = Rhe;
var Che = She(Z5), Ahe = Cu, khe = /<(![a-zA-Z\s]+)>/;
function Rhe(t) {
  if (typeof t != "string")
    throw new TypeError("First argument must be a string");
  if (!t)
    return [];
  var e = t.match(khe), r = e ? e[1] : void 0;
  return (0, Ahe.formatDOM)((0, Che.default)(t), null, r);
}
var C1 = {}, Qi = {}, A1 = {}, Mhe = 0;
A1.SAME = Mhe;
var _he = 1;
A1.CAMELCASE = _he;
A1.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const DD = 0, cl = 1, k1 = 2, R1 = 3, rC = 4, $D = 5, FD = 6;
function Lhe(t) {
  return Un.hasOwnProperty(t) ? Un[t] : null;
}
function va(t, e, r, n, a, i, s) {
  this.acceptsBooleans = e === k1 || e === R1 || e === rC, this.attributeName = n, this.attributeNamespace = a, this.mustUseProperty = r, this.propertyName = t, this.type = e, this.sanitizeURL = i, this.removeEmptyString = s;
}
const Un = {}, Nhe = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
Nhe.forEach((t) => {
  Un[t] = new va(
    t,
    DD,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([t, e]) => {
  Un[t] = new va(
    t,
    cl,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((t) => {
  Un[t] = new va(
    t,
    k1,
    !1,
    // mustUseProperty
    t.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((t) => {
  Un[t] = new va(
    t,
    k1,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((t) => {
  Un[t] = new va(
    t,
    R1,
    !1,
    // mustUseProperty
    t.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((t) => {
  Un[t] = new va(
    t,
    R1,
    !0,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((t) => {
  Un[t] = new va(
    t,
    rC,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((t) => {
  Un[t] = new va(
    t,
    FD,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((t) => {
  Un[t] = new va(
    t,
    $D,
    !1,
    // mustUseProperty
    t.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const nC = /[\-\:]([a-z])/g, aC = (t) => t[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((t) => {
  const e = t.replace(nC, aC);
  Un[e] = new va(
    e,
    cl,
    !1,
    // mustUseProperty
    t,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((t) => {
  const e = t.replace(nC, aC);
  Un[e] = new va(
    e,
    cl,
    !1,
    // mustUseProperty
    t,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((t) => {
  const e = t.replace(nC, aC);
  Un[e] = new va(
    e,
    cl,
    !1,
    // mustUseProperty
    t,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((t) => {
  Un[t] = new va(
    t,
    cl,
    !1,
    // mustUseProperty
    t.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const Ohe = "xlinkHref";
Un[Ohe] = new va(
  "xlinkHref",
  cl,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((t) => {
  Un[t] = new va(
    t,
    cl,
    !1,
    // mustUseProperty
    t.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: Ihe,
  SAME: Phe,
  possibleStandardNames: f6
} = A1, Dhe = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", $he = Dhe + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", Fhe = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + $he + "]*$")
), Bhe = Object.keys(
  f6
).reduce((t, e) => {
  const r = f6[e];
  return r === Phe ? t[e] = e : r === Ihe ? t[e.toLowerCase()] = e : t[e] = r, t;
}, {});
Qi.BOOLEAN = R1;
Qi.BOOLEANISH_STRING = k1;
Qi.NUMERIC = $D;
Qi.OVERLOADED_BOOLEAN = rC;
Qi.POSITIVE_NUMERIC = FD;
Qi.RESERVED = DD;
Qi.STRING = cl;
Qi.getPropertyInfo = Lhe;
Qi.isCustomAttribute = Fhe;
Qi.possibleStandardNames = Bhe;
var iC = {}, sC = {}, h6 = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, zhe = /\n/g, Ghe = /^\s*/, Uhe = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, Hhe = /^:\s*/, Vhe = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, qhe = /^[;\s]*/, Whe = /^\s+|\s+$/g, jhe = `
`, d6 = "/", p6 = "*", Dl = "", Yhe = "comment", Xhe = "declaration";
function Khe(t, e) {
  if (typeof t != "string")
    throw new TypeError("First argument must be a string");
  if (!t) return [];
  e = e || {};
  var r = 1, n = 1;
  function a(p) {
    var g = p.match(zhe);
    g && (r += g.length);
    var v = p.lastIndexOf(jhe);
    n = ~v ? p.length - v : n + p.length;
  }
  function i() {
    var p = { line: r, column: n };
    return function(g) {
      return g.position = new s(p), u(), g;
    };
  }
  function s(p) {
    this.start = p, this.end = { line: r, column: n }, this.source = e.source;
  }
  s.prototype.content = t;
  function o(p) {
    var g = new Error(
      e.source + ":" + r + ":" + n + ": " + p
    );
    if (g.reason = p, g.filename = e.source, g.line = r, g.column = n, g.source = t, !e.silent) throw g;
  }
  function l(p) {
    var g = p.exec(t);
    if (g) {
      var v = g[0];
      return a(v), t = t.slice(v.length), g;
    }
  }
  function u() {
    l(Ghe);
  }
  function c(p) {
    var g;
    for (p = p || []; g = f(); )
      g !== !1 && p.push(g);
    return p;
  }
  function f() {
    var p = i();
    if (!(d6 != t.charAt(0) || p6 != t.charAt(1))) {
      for (var g = 2; Dl != t.charAt(g) && (p6 != t.charAt(g) || d6 != t.charAt(g + 1)); )
        ++g;
      if (g += 2, Dl === t.charAt(g - 1))
        return o("End of comment missing");
      var v = t.slice(2, g - 2);
      return n += 2, a(v), t = t.slice(g), n += 2, p({
        type: Yhe,
        comment: v
      });
    }
  }
  function h() {
    var p = i(), g = l(Uhe);
    if (g) {
      if (f(), !l(Hhe)) return o("property missing ':'");
      var v = l(Vhe), m = p({
        type: Xhe,
        property: g6(g[0].replace(h6, Dl)),
        value: v ? g6(v[0].replace(h6, Dl)) : Dl
      });
      return l(qhe), m;
    }
  }
  function d() {
    var p = [];
    c(p);
    for (var g; g = h(); )
      g !== !1 && (p.push(g), c(p));
    return p;
  }
  return u(), d();
}
function g6(t) {
  return t ? t.replace(Whe, Dl) : Dl;
}
var Zhe = Khe, Qhe = Jt && Jt.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(sC, "__esModule", { value: !0 });
sC.default = ede;
const Jhe = Qhe(Zhe);
function ede(t, e) {
  let r = null;
  if (!t || typeof t != "string")
    return r;
  const n = (0, Jhe.default)(t), a = typeof e == "function";
  return n.forEach((i) => {
    if (i.type !== "declaration")
      return;
    const { property: s, value: o } = i;
    a ? e(s, o, i) : o && (r = r || {}, r[s] = o);
  }), r;
}
var M1 = {};
Object.defineProperty(M1, "__esModule", { value: !0 });
M1.camelCase = void 0;
var tde = /^--[a-zA-Z0-9_-]+$/, rde = /-([a-z])/g, nde = /^[^-]+$/, ade = /^-(webkit|moz|ms|o|khtml)-/, ide = /^-(ms)-/, sde = function(t) {
  return !t || nde.test(t) || tde.test(t);
}, ode = function(t, e) {
  return e.toUpperCase();
}, v6 = function(t, e) {
  return "".concat(e, "-");
}, lde = function(t, e) {
  return e === void 0 && (e = {}), sde(t) ? t : (t = t.toLowerCase(), e.reactCompat ? t = t.replace(ide, v6) : t = t.replace(ade, v6), t.replace(rde, ode));
};
M1.camelCase = lde;
var ude = Jt && Jt.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
}, cde = ude(sC), fde = M1;
function UT(t, e) {
  var r = {};
  return !t || typeof t != "string" || (0, cde.default)(t, function(n, a) {
    n && a && (r[(0, fde.camelCase)(n, e)] = a);
  }), r;
}
UT.default = UT;
var hde = UT;
(function(t) {
  var e = Jt && Jt.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.returnFirstArg = t.canTextBeChildOfNode = t.ELEMENTS_WITH_NO_TEXT_CHILDREN = t.PRESERVE_CUSTOM_ATTRIBUTES = void 0, t.isCustomComponent = i, t.setStyleProp = o;
  var r = lt, n = e(hde), a = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, f) {
    return c.includes("-") ? !a.has(c) : !!(f && typeof f.is == "string");
  }
  var s = {
    reactCompat: !0
  };
  function o(c, f) {
    if (typeof c == "string") {
      if (!c.trim()) {
        f.style = {};
        return;
      }
      try {
        f.style = (0, n.default)(c, s);
      } catch {
        f.style = {};
      }
    }
  }
  t.PRESERVE_CUSTOM_ATTRIBUTES = Number(r.version.split(".")[0]) >= 16, t.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !t.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  t.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  t.returnFirstArg = u;
})(iC);
Object.defineProperty(C1, "__esModule", { value: !0 });
C1.default = vde;
var Ah = Qi, m6 = iC, dde = ["checked", "value"], pde = ["input", "select", "textarea"], gde = {
  reset: !0,
  submit: !0
};
function vde(t, e) {
  t === void 0 && (t = {});
  var r = {}, n = !!(t.type && gde[t.type]);
  for (var a in t) {
    var i = t[a];
    if ((0, Ah.isCustomAttribute)(a)) {
      r[a] = i;
      continue;
    }
    var s = a.toLowerCase(), o = y6(s);
    if (o) {
      var l = (0, Ah.getPropertyInfo)(o);
      switch (dde.includes(o) && pde.includes(e) && !n && (o = y6("default" + s)), r[o] = i, l && l.type) {
        case Ah.BOOLEAN:
          r[o] = !0;
          break;
        case Ah.OVERLOADED_BOOLEAN:
          i === "" && (r[o] = !0);
          break;
      }
      continue;
    }
    m6.PRESERVE_CUSTOM_ATTRIBUTES && (r[a] = i);
  }
  return (0, m6.setStyleProp)(t.style, r), r;
}
function y6(t) {
  return Ah.possibleStandardNames[t];
}
var oC = {}, mde = Jt && Jt.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(oC, "__esModule", { value: !0 });
oC.default = BD;
var Sx = lt, yde = mde(C1), Ad = iC, bde = {
  cloneElement: Sx.cloneElement,
  createElement: Sx.createElement,
  isValidElement: Sx.isValidElement
};
function BD(t, e) {
  e === void 0 && (e = {});
  for (var r = [], n = typeof e.replace == "function", a = e.transform || Ad.returnFirstArg, i = e.library || bde, s = i.cloneElement, o = i.createElement, l = i.isValidElement, u = t.length, c = 0; c < u; c++) {
    var f = t[c];
    if (n) {
      var h = e.replace(f, c);
      if (l(h)) {
        u > 1 && (h = s(h, {
          key: h.key || c
        })), r.push(a(h, f, c));
        continue;
      }
    }
    if (f.type === "text") {
      var d = !f.data.trim().length;
      if (d && f.parent && !(0, Ad.canTextBeChildOfNode)(f.parent) || e.trim && d)
        continue;
      r.push(a(f.data, f, c));
      continue;
    }
    var p = f, g = {};
    xde(p) ? ((0, Ad.setStyleProp)(p.attribs.style, p.attribs), g = p.attribs) : p.attribs && (g = (0, yde.default)(p.attribs, p.name));
    var v = void 0;
    switch (f.type) {
      case "script":
      case "style":
        f.children[0] && (g.dangerouslySetInnerHTML = {
          __html: f.children[0].data
        });
        break;
      case "tag":
        f.name === "textarea" && f.children[0] ? g.defaultValue = f.children[0].data : f.children && f.children.length && (v = BD(f.children, e));
        break;
      default:
        continue;
    }
    u > 1 && (g.key = c), r.push(a(o(f.name, g, v), f, c));
  }
  return r.length === 1 ? r[0] : r;
}
function xde(t) {
  return Ad.PRESERVE_CUSTOM_ATTRIBUTES && t.type === "tag" && (0, Ad.isCustomComponent)(t.name, t.attribs);
}
(function(t) {
  var e = Jt && Jt.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.htmlToDOM = t.domToReact = t.attributesToProps = t.Text = t.ProcessingInstruction = t.Element = t.Comment = void 0, t.default = o;
  var r = e(K5);
  t.htmlToDOM = r.default;
  var n = e(C1);
  t.attributesToProps = n.default;
  var a = e(oC);
  t.domToReact = a.default;
  var i = Q5;
  Object.defineProperty(t, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(t, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(t, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(t, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var s = { lowerCaseAttributeNames: !1 };
  function o(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, a.default)((0, r.default)(l, (u == null ? void 0 : u.htmlparser2) || s), u) : [];
  }
})(bD);
const b6 = /* @__PURE__ */ ho(bD), W_e = b6.default || b6;
function wde(t) {
  return !!(t.addonBefore || t.addonAfter);
}
function Ede(t) {
  return !!(t.prefix || t.suffix || t.allowClear);
}
function x6(t, e, r) {
  var n = e.cloneNode(!0), a = Object.create(t, {
    target: {
      value: n
    },
    currentTarget: {
      value: n
    }
  });
  return n.value = r, typeof e.selectionStart == "number" && typeof e.selectionEnd == "number" && (n.selectionStart = e.selectionStart, n.selectionEnd = e.selectionEnd), n.setSelectionRange = function() {
    e.setSelectionRange.apply(e, arguments);
  }, a;
}
function Sm(t, e, r, n) {
  if (r) {
    var a = e;
    if (e.type === "click") {
      a = x6(e, t, ""), r(a);
      return;
    }
    if (t.type !== "file" && n !== void 0) {
      a = x6(e, t, n), r(a);
      return;
    }
    r(a);
  }
}
function zD(t, e) {
  if (t) {
    t.focus(e);
    var r = e || {}, n = r.cursor;
    if (n) {
      var a = t.value.length;
      switch (n) {
        case "start":
          t.setSelectionRange(0, 0);
          break;
        case "end":
          t.setSelectionRange(a, a);
          break;
        default:
          t.setSelectionRange(0, a);
      }
    }
  }
}
var GD = /* @__PURE__ */ lt.forwardRef(function(t, e) {
  var r, n, a, i = t.inputElement, s = t.children, o = t.prefixCls, l = t.prefix, u = t.suffix, c = t.addonBefore, f = t.addonAfter, h = t.className, d = t.style, p = t.disabled, g = t.readOnly, v = t.focused, m = t.triggerFocus, b = t.allowClear, y = t.value, x = t.handleReset, E = t.hidden, S = t.classes, w = t.classNames, C = t.dataAttrs, k = t.styles, N = t.components, R = t.onClear, _ = s ?? i, O = (N == null ? void 0 : N.affixWrapper) || "span", T = (N == null ? void 0 : N.groupWrapper) || "span", L = (N == null ? void 0 : N.wrapper) || "span", M = (N == null ? void 0 : N.groupAddon) || "span", A = tn(null), I = function(Ce) {
    var Ee;
    (Ee = A.current) !== null && Ee !== void 0 && Ee.contains(Ce.target) && (m == null || m());
  }, D = Ede(t), F = /* @__PURE__ */ AH(_, {
    value: y,
    className: fr((r = _.props) === null || r === void 0 ? void 0 : r.className, !D && (w == null ? void 0 : w.variant)) || null
  }), B = tn(null);
  if (lt.useImperativeHandle(e, function() {
    return {
      nativeElement: B.current || A.current
    };
  }), D) {
    var G = null;
    if (b) {
      var H = !p && !g && y, K = "".concat(o, "-clear-icon"), j = Tt(b) === "object" && b !== null && b !== void 0 && b.clearIcon ? b.clearIcon : "✖";
      G = /* @__PURE__ */ lt.createElement("button", {
        type: "button",
        tabIndex: -1,
        onClick: function(Ce) {
          x == null || x(Ce), R == null || R();
        },
        onMouseDown: function(Ce) {
          return Ce.preventDefault();
        },
        className: fr(K, pe(pe({}, "".concat(K, "-hidden"), !H), "".concat(K, "-has-suffix"), !!u))
      }, j);
    }
    var Z = "".concat(o, "-affix-wrapper"), te = fr(Z, pe(pe(pe(pe(pe({}, "".concat(o, "-disabled"), p), "".concat(Z, "-disabled"), p), "".concat(Z, "-focused"), v), "".concat(Z, "-readonly"), g), "".concat(Z, "-input-with-clear-btn"), u && b && y), S == null ? void 0 : S.affixWrapper, w == null ? void 0 : w.affixWrapper, w == null ? void 0 : w.variant), ne = (u || b) && /* @__PURE__ */ lt.createElement("span", {
      className: fr("".concat(o, "-suffix"), w == null ? void 0 : w.suffix),
      style: k == null ? void 0 : k.suffix
    }, G, u);
    F = /* @__PURE__ */ lt.createElement(O, Ra({
      className: te,
      style: k == null ? void 0 : k.affixWrapper,
      onClick: I
    }, C == null ? void 0 : C.affixWrapper, {
      ref: A
    }), l && /* @__PURE__ */ lt.createElement("span", {
      className: fr("".concat(o, "-prefix"), w == null ? void 0 : w.prefix),
      style: k == null ? void 0 : k.prefix
    }, l), F, ne);
  }
  if (wde(t)) {
    var V = "".concat(o, "-group"), q = "".concat(V, "-addon"), X = "".concat(V, "-wrapper"), W = fr("".concat(o, "-wrapper"), V, S == null ? void 0 : S.wrapper, w == null ? void 0 : w.wrapper), ue = fr(X, pe({}, "".concat(X, "-disabled"), p), S == null ? void 0 : S.group, w == null ? void 0 : w.groupWrapper);
    F = /* @__PURE__ */ lt.createElement(T, {
      className: ue,
      ref: B
    }, /* @__PURE__ */ lt.createElement(L, {
      className: W
    }, c && /* @__PURE__ */ lt.createElement(M, {
      className: q
    }, c), F, f && /* @__PURE__ */ lt.createElement(M, {
      className: q
    }, f)));
  }
  return /* @__PURE__ */ lt.cloneElement(F, {
    className: fr((n = F.props) === null || n === void 0 ? void 0 : n.className, h) || null,
    style: ke(ke({}, (a = F.props) === null || a === void 0 ? void 0 : a.style), d),
    hidden: E
  });
}), Tde = ["show"];
function UD(t, e) {
  return de.useMemo(function() {
    var r = {};
    e && (r.show = Tt(e) === "object" && e.formatter ? e.formatter : !!e), r = ke(ke({}, r), t);
    var n = r, a = n.show, i = vi(n, Tde);
    return ke(ke({}, i), {}, {
      show: !!a,
      showFormatter: typeof a == "function" ? a : void 0,
      strategy: i.strategy || function(s) {
        return s.length;
      }
    });
  }, [t, e]);
}
var Sde = ["autoComplete", "onChange", "onFocus", "onBlur", "onPressEnter", "onKeyDown", "onKeyUp", "prefixCls", "disabled", "htmlSize", "className", "maxLength", "suffix", "showCount", "count", "type", "classes", "classNames", "styles", "onCompositionStart", "onCompositionEnd"], Cde = /* @__PURE__ */ CS(function(t, e) {
  var r = t.autoComplete, n = t.onChange, a = t.onFocus, i = t.onBlur, s = t.onPressEnter, o = t.onKeyDown, l = t.onKeyUp, u = t.prefixCls, c = u === void 0 ? "rc-input" : u, f = t.disabled, h = t.htmlSize, d = t.className, p = t.maxLength, g = t.suffix, v = t.showCount, m = t.count, b = t.type, y = b === void 0 ? "text" : b, x = t.classes, E = t.classNames, S = t.styles, w = t.onCompositionStart, C = t.onCompositionEnd, k = vi(t, Sde), N = dE(!1), R = bt(N, 2), _ = R[0], O = R[1], T = tn(!1), L = tn(!1), M = tn(null), A = tn(null), I = function(_e) {
    M.current && zD(M.current, _e);
  }, D = DS(t.defaultValue, {
    value: t.value
  }), F = bt(D, 2), B = F[0], G = F[1], H = B == null ? "" : String(B), K = dE(null), j = bt(K, 2), Z = j[0], te = j[1], ne = UD(m, v), V = ne.max || p, q = ne.strategy(H), X = !!V && q > V;
  q8(e, function() {
    var Me;
    return {
      focus: I,
      blur: function() {
        var Be;
        (Be = M.current) === null || Be === void 0 || Be.blur();
      },
      setSelectionRange: function(Be, st, ct) {
        var dt;
        (dt = M.current) === null || dt === void 0 || dt.setSelectionRange(Be, st, ct);
      },
      select: function() {
        var Be;
        (Be = M.current) === null || Be === void 0 || Be.select();
      },
      input: M.current,
      nativeElement: ((Me = A.current) === null || Me === void 0 ? void 0 : Me.nativeElement) || M.current
    };
  }), Fi(function() {
    L.current && (L.current = !1), O(function(Me) {
      return Me && f ? !1 : Me;
    });
  }, [f]);
  var W = function(_e, Be, st) {
    var ct = Be;
    if (!T.current && ne.exceedFormatter && ne.max && ne.strategy(Be) > ne.max) {
      if (ct = ne.exceedFormatter(Be, {
        max: ne.max
      }), Be !== ct) {
        var dt, ft;
        te([((dt = M.current) === null || dt === void 0 ? void 0 : dt.selectionStart) || 0, ((ft = M.current) === null || ft === void 0 ? void 0 : ft.selectionEnd) || 0]);
      }
    } else if (st.source === "compositionEnd")
      return;
    G(ct), M.current && Sm(M.current, _e, n, ct);
  };
  Fi(function() {
    if (Z) {
      var Me;
      (Me = M.current) === null || Me === void 0 || Me.setSelectionRange.apply(Me, Ot(Z));
    }
  }, [Z]);
  var ue = function(_e) {
    W(_e, _e.target.value, {
      source: "change"
    });
  }, J = function(_e) {
    T.current = !1, W(_e, _e.currentTarget.value, {
      source: "compositionEnd"
    }), C == null || C(_e);
  }, Ce = function(_e) {
    s && _e.key === "Enter" && !L.current && (L.current = !0, s(_e)), o == null || o(_e);
  }, Ee = function(_e) {
    _e.key === "Enter" && (L.current = !1), l == null || l(_e);
  }, Te = function(_e) {
    O(!0), a == null || a(_e);
  }, me = function(_e) {
    L.current && (L.current = !1), O(!1), i == null || i(_e);
  }, we = function(_e) {
    G(""), I(), M.current && Sm(M.current, _e, n);
  }, Ae = X && "".concat(c, "-out-of-range"), Ne = function() {
    var _e = ZQ(t, [
      "prefixCls",
      "onPressEnter",
      "addonBefore",
      "addonAfter",
      "prefix",
      "suffix",
      "allowClear",
      // Input elements must be either controlled or uncontrolled,
      // specify either the value prop, or the defaultValue prop, but not both.
      "defaultValue",
      "showCount",
      "count",
      "classes",
      "htmlSize",
      "styles",
      "classNames",
      "onClear"
    ]);
    return /* @__PURE__ */ lt.createElement("input", Ra({
      autoComplete: r
    }, _e, {
      onChange: ue,
      onFocus: Te,
      onBlur: me,
      onKeyDown: Ce,
      onKeyUp: Ee,
      className: fr(c, pe({}, "".concat(c, "-disabled"), f), E == null ? void 0 : E.input),
      style: S == null ? void 0 : S.input,
      ref: M,
      size: h,
      type: y,
      onCompositionStart: function(st) {
        T.current = !0, w == null || w(st);
      },
      onCompositionEnd: J
    }));
  }, Ie = function() {
    var _e = Number(V) > 0;
    if (g || ne.show) {
      var Be = ne.showFormatter ? ne.showFormatter({
        value: H,
        count: q,
        maxLength: V
      }) : "".concat(q).concat(_e ? " / ".concat(V) : "");
      return /* @__PURE__ */ lt.createElement(lt.Fragment, null, ne.show && /* @__PURE__ */ lt.createElement("span", {
        className: fr("".concat(c, "-show-count-suffix"), pe({}, "".concat(c, "-show-count-has-suffix"), !!g), E == null ? void 0 : E.count),
        style: ke({}, S == null ? void 0 : S.count)
      }, Be), g);
    }
    return null;
  };
  return /* @__PURE__ */ lt.createElement(GD, Ra({}, k, {
    prefixCls: c,
    className: fr(d, Ae),
    handleReset: we,
    value: H,
    focused: _,
    triggerFocus: I,
    suffix: Ie(),
    disabled: f,
    classes: x,
    classNames: E,
    styles: S
  }), Ne());
});
function Cm(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = [];
  return lt.Children.forEach(t, function(n) {
    n == null && !e.keepEmpty || (Array.isArray(n) ? r = r.concat(Cm(n)) : uO(n) && n.props ? r = r.concat(Cm(n.props.children, e)) : r.push(n));
  }), r;
}
var HT = /* @__PURE__ */ de.createContext(null);
function Ade(t) {
  var e = t.children, r = t.onBatchResize, n = de.useRef(0), a = de.useRef([]), i = de.useContext(HT), s = de.useCallback(function(o, l, u) {
    n.current += 1;
    var c = n.current;
    a.current.push({
      size: o,
      element: l,
      data: u
    }), Promise.resolve().then(function() {
      c === n.current && (r == null || r(a.current), a.current = []);
    }), i == null || i(o, l, u);
  }, [r, i]);
  return /* @__PURE__ */ de.createElement(HT.Provider, {
    value: s
  }, e);
}
var HD = function() {
  if (typeof Map < "u")
    return Map;
  function t(e, r) {
    var n = -1;
    return e.some(function(a, i) {
      return a[0] === r ? (n = i, !0) : !1;
    }), n;
  }
  return (
    /** @class */
    function() {
      function e() {
        this.__entries__ = [];
      }
      return Object.defineProperty(e.prototype, "size", {
        /**
         * @returns {boolean}
         */
        get: function() {
          return this.__entries__.length;
        },
        enumerable: !0,
        configurable: !0
      }), e.prototype.get = function(r) {
        var n = t(this.__entries__, r), a = this.__entries__[n];
        return a && a[1];
      }, e.prototype.set = function(r, n) {
        var a = t(this.__entries__, r);
        ~a ? this.__entries__[a][1] = n : this.__entries__.push([r, n]);
      }, e.prototype.delete = function(r) {
        var n = this.__entries__, a = t(n, r);
        ~a && n.splice(a, 1);
      }, e.prototype.has = function(r) {
        return !!~t(this.__entries__, r);
      }, e.prototype.clear = function() {
        this.__entries__.splice(0);
      }, e.prototype.forEach = function(r, n) {
        n === void 0 && (n = null);
        for (var a = 0, i = this.__entries__; a < i.length; a++) {
          var s = i[a];
          r.call(n, s[1], s[0]);
        }
      }, e;
    }()
  );
}(), VT = typeof window < "u" && typeof document < "u" && window.document === document, Am = function() {
  return typeof global < "u" && global.Math === Math ? global : typeof self < "u" && self.Math === Math ? self : typeof window < "u" && window.Math === Math ? window : Function("return this")();
}(), kde = function() {
  return typeof requestAnimationFrame == "function" ? requestAnimationFrame.bind(Am) : function(t) {
    return setTimeout(function() {
      return t(Date.now());
    }, 1e3 / 60);
  };
}(), Rde = 2;
function Mde(t, e) {
  var r = !1, n = !1, a = 0;
  function i() {
    r && (r = !1, t()), n && o();
  }
  function s() {
    kde(i);
  }
  function o() {
    var l = Date.now();
    if (r) {
      if (l - a < Rde)
        return;
      n = !0;
    } else
      r = !0, n = !1, setTimeout(s, e);
    a = l;
  }
  return o;
}
var _de = 20, Lde = ["top", "right", "bottom", "left", "width", "height", "size", "weight"], Nde = typeof MutationObserver < "u", Ode = (
  /** @class */
  function() {
    function t() {
      this.connected_ = !1, this.mutationEventsAdded_ = !1, this.mutationsObserver_ = null, this.observers_ = [], this.onTransitionEnd_ = this.onTransitionEnd_.bind(this), this.refresh = Mde(this.refresh.bind(this), _de);
    }
    return t.prototype.addObserver = function(e) {
      ~this.observers_.indexOf(e) || this.observers_.push(e), this.connected_ || this.connect_();
    }, t.prototype.removeObserver = function(e) {
      var r = this.observers_, n = r.indexOf(e);
      ~n && r.splice(n, 1), !r.length && this.connected_ && this.disconnect_();
    }, t.prototype.refresh = function() {
      var e = this.updateObservers_();
      e && this.refresh();
    }, t.prototype.updateObservers_ = function() {
      var e = this.observers_.filter(function(r) {
        return r.gatherActive(), r.hasActive();
      });
      return e.forEach(function(r) {
        return r.broadcastActive();
      }), e.length > 0;
    }, t.prototype.connect_ = function() {
      !VT || this.connected_ || (document.addEventListener("transitionend", this.onTransitionEnd_), window.addEventListener("resize", this.refresh), Nde ? (this.mutationsObserver_ = new MutationObserver(this.refresh), this.mutationsObserver_.observe(document, {
        attributes: !0,
        childList: !0,
        characterData: !0,
        subtree: !0
      })) : (document.addEventListener("DOMSubtreeModified", this.refresh), this.mutationEventsAdded_ = !0), this.connected_ = !0);
    }, t.prototype.disconnect_ = function() {
      !VT || !this.connected_ || (document.removeEventListener("transitionend", this.onTransitionEnd_), window.removeEventListener("resize", this.refresh), this.mutationsObserver_ && this.mutationsObserver_.disconnect(), this.mutationEventsAdded_ && document.removeEventListener("DOMSubtreeModified", this.refresh), this.mutationsObserver_ = null, this.mutationEventsAdded_ = !1, this.connected_ = !1);
    }, t.prototype.onTransitionEnd_ = function(e) {
      var r = e.propertyName, n = r === void 0 ? "" : r, a = Lde.some(function(i) {
        return !!~n.indexOf(i);
      });
      a && this.refresh();
    }, t.getInstance = function() {
      return this.instance_ || (this.instance_ = new t()), this.instance_;
    }, t.instance_ = null, t;
  }()
), VD = function(t, e) {
  for (var r = 0, n = Object.keys(e); r < n.length; r++) {
    var a = n[r];
    Object.defineProperty(t, a, {
      value: e[a],
      enumerable: !1,
      writable: !1,
      configurable: !0
    });
  }
  return t;
}, rf = function(t) {
  var e = t && t.ownerDocument && t.ownerDocument.defaultView;
  return e || Am;
}, qD = _1(0, 0, 0, 0);
function km(t) {
  return parseFloat(t) || 0;
}
function w6(t) {
  for (var e = [], r = 1; r < arguments.length; r++)
    e[r - 1] = arguments[r];
  return e.reduce(function(n, a) {
    var i = t["border-" + a + "-width"];
    return n + km(i);
  }, 0);
}
function Ide(t) {
  for (var e = ["top", "right", "bottom", "left"], r = {}, n = 0, a = e; n < a.length; n++) {
    var i = a[n], s = t["padding-" + i];
    r[i] = km(s);
  }
  return r;
}
function Pde(t) {
  var e = t.getBBox();
  return _1(0, 0, e.width, e.height);
}
function Dde(t) {
  var e = t.clientWidth, r = t.clientHeight;
  if (!e && !r)
    return qD;
  var n = rf(t).getComputedStyle(t), a = Ide(n), i = a.left + a.right, s = a.top + a.bottom, o = km(n.width), l = km(n.height);
  if (n.boxSizing === "border-box" && (Math.round(o + i) !== e && (o -= w6(n, "left", "right") + i), Math.round(l + s) !== r && (l -= w6(n, "top", "bottom") + s)), !Fde(t)) {
    var u = Math.round(o + i) - e, c = Math.round(l + s) - r;
    Math.abs(u) !== 1 && (o -= u), Math.abs(c) !== 1 && (l -= c);
  }
  return _1(a.left, a.top, o, l);
}
var $de = /* @__PURE__ */ function() {
  return typeof SVGGraphicsElement < "u" ? function(t) {
    return t instanceof rf(t).SVGGraphicsElement;
  } : function(t) {
    return t instanceof rf(t).SVGElement && typeof t.getBBox == "function";
  };
}();
function Fde(t) {
  return t === rf(t).document.documentElement;
}
function Bde(t) {
  return VT ? $de(t) ? Pde(t) : Dde(t) : qD;
}
function zde(t) {
  var e = t.x, r = t.y, n = t.width, a = t.height, i = typeof DOMRectReadOnly < "u" ? DOMRectReadOnly : Object, s = Object.create(i.prototype);
  return VD(s, {
    x: e,
    y: r,
    width: n,
    height: a,
    top: r,
    right: e + n,
    bottom: a + r,
    left: e
  }), s;
}
function _1(t, e, r, n) {
  return { x: t, y: e, width: r, height: n };
}
var Gde = (
  /** @class */
  function() {
    function t(e) {
      this.broadcastWidth = 0, this.broadcastHeight = 0, this.contentRect_ = _1(0, 0, 0, 0), this.target = e;
    }
    return t.prototype.isActive = function() {
      var e = Bde(this.target);
      return this.contentRect_ = e, e.width !== this.broadcastWidth || e.height !== this.broadcastHeight;
    }, t.prototype.broadcastRect = function() {
      var e = this.contentRect_;
      return this.broadcastWidth = e.width, this.broadcastHeight = e.height, e;
    }, t;
  }()
), Ude = (
  /** @class */
  /* @__PURE__ */ function() {
    function t(e, r) {
      var n = zde(r);
      VD(this, { target: e, contentRect: n });
    }
    return t;
  }()
), Hde = (
  /** @class */
  function() {
    function t(e, r, n) {
      if (this.activeObservations_ = [], this.observations_ = new HD(), typeof e != "function")
        throw new TypeError("The callback provided as parameter 1 is not a function.");
      this.callback_ = e, this.controller_ = r, this.callbackCtx_ = n;
    }
    return t.prototype.observe = function(e) {
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      if (!(typeof Element > "u" || !(Element instanceof Object))) {
        if (!(e instanceof rf(e).Element))
          throw new TypeError('parameter 1 is not of type "Element".');
        var r = this.observations_;
        r.has(e) || (r.set(e, new Gde(e)), this.controller_.addObserver(this), this.controller_.refresh());
      }
    }, t.prototype.unobserve = function(e) {
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      if (!(typeof Element > "u" || !(Element instanceof Object))) {
        if (!(e instanceof rf(e).Element))
          throw new TypeError('parameter 1 is not of type "Element".');
        var r = this.observations_;
        r.has(e) && (r.delete(e), r.size || this.controller_.removeObserver(this));
      }
    }, t.prototype.disconnect = function() {
      this.clearActive(), this.observations_.clear(), this.controller_.removeObserver(this);
    }, t.prototype.gatherActive = function() {
      var e = this;
      this.clearActive(), this.observations_.forEach(function(r) {
        r.isActive() && e.activeObservations_.push(r);
      });
    }, t.prototype.broadcastActive = function() {
      if (this.hasActive()) {
        var e = this.callbackCtx_, r = this.activeObservations_.map(function(n) {
          return new Ude(n.target, n.broadcastRect());
        });
        this.callback_.call(e, r, e), this.clearActive();
      }
    }, t.prototype.clearActive = function() {
      this.activeObservations_.splice(0);
    }, t.prototype.hasActive = function() {
      return this.activeObservations_.length > 0;
    }, t;
  }()
), WD = typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : new HD(), jD = (
  /** @class */
  /* @__PURE__ */ function() {
    function t(e) {
      if (!(this instanceof t))
        throw new TypeError("Cannot call a class as a function.");
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      var r = Ode.getInstance(), n = new Hde(e, r, this);
      WD.set(this, n);
    }
    return t;
  }()
);
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(t) {
  jD.prototype[t] = function() {
    var e;
    return (e = WD.get(this))[t].apply(e, arguments);
  };
});
var Vde = function() {
  return typeof Am.ResizeObserver < "u" ? Am.ResizeObserver : jD;
}(), Ys = /* @__PURE__ */ new Map();
function YD(t) {
  t.forEach(function(e) {
    var r, n = e.target;
    (r = Ys.get(n)) === null || r === void 0 || r.forEach(function(a) {
      return a(n);
    });
  });
}
var XD = new Vde(YD);
process.env.NODE_ENV;
process.env.NODE_ENV;
function qde(t, e) {
  Ys.has(t) || (Ys.set(t, /* @__PURE__ */ new Set()), XD.observe(t)), Ys.get(t).add(e);
}
function Wde(t, e) {
  Ys.has(t) && (Ys.get(t).delete(e), Ys.get(t).size || (XD.unobserve(t), Ys.delete(t)));
}
var jde = /* @__PURE__ */ function(t) {
  il(r, t);
  var e = sl(r);
  function r() {
    return Ln(this, r), e.apply(this, arguments);
  }
  return Nn(r, [{
    key: "render",
    value: function() {
      return this.props.children;
    }
  }]), r;
}(de.Component);
function Yde(t, e) {
  var r = t.children, n = t.disabled, a = de.useRef(null), i = de.useRef(null), s = de.useContext(HT), o = typeof r == "function", l = o ? r(a) : r, u = de.useRef({
    width: -1,
    height: -1,
    offsetWidth: -1,
    offsetHeight: -1
  }), c = !o && /* @__PURE__ */ de.isValidElement(l) && hO(l), f = c ? pO(l) : null, h = TX(f, a), d = function() {
    var m;
    return Vg(a.current) || // Support `nativeElement` format
    (a.current && Tt(a.current) === "object" ? Vg((m = a.current) === null || m === void 0 ? void 0 : m.nativeElement) : null) || Vg(i.current);
  };
  de.useImperativeHandle(e, function() {
    return d();
  });
  var p = de.useRef(t);
  p.current = t;
  var g = de.useCallback(function(v) {
    var m = p.current, b = m.onResize, y = m.data, x = v.getBoundingClientRect(), E = x.width, S = x.height, w = v.offsetWidth, C = v.offsetHeight, k = Math.floor(E), N = Math.floor(S);
    if (u.current.width !== k || u.current.height !== N || u.current.offsetWidth !== w || u.current.offsetHeight !== C) {
      var R = {
        width: k,
        height: N,
        offsetWidth: w,
        offsetHeight: C
      };
      u.current = R;
      var _ = w === Math.round(E) ? E : w, O = C === Math.round(S) ? S : C, T = ke(ke({}, R), {}, {
        offsetWidth: _,
        offsetHeight: O
      });
      s == null || s(T, v, y), b && Promise.resolve().then(function() {
        b(T, v);
      });
    }
  }, []);
  return de.useEffect(function() {
    var v = d();
    return v && !n && qde(v, g), function() {
      return Wde(v, g);
    };
  }, [a.current, n]), /* @__PURE__ */ de.createElement(jde, {
    ref: i
  }, c ? /* @__PURE__ */ de.cloneElement(l, {
    ref: h
  }) : l);
}
var KD = /* @__PURE__ */ de.forwardRef(Yde);
process.env.NODE_ENV !== "production" && (KD.displayName = "SingleObserver");
var Xde = "rc-observer-key";
function Kde(t, e) {
  var r = t.children, n = typeof r == "function" ? [r] : Cm(r);
  return process.env.NODE_ENV !== "production" && (n.length > 1 ? zd(!1, "Find more than one child node with `children` in ResizeObserver. Please use ResizeObserver.Collection instead.") : n.length === 0 && zd(!1, "`children` of ResizeObserver is empty. Nothing is in observe.")), n.map(function(a, i) {
    var s = (a == null ? void 0 : a.key) || "".concat(Xde, "-").concat(i);
    return /* @__PURE__ */ de.createElement(KD, Ra({}, t, {
      key: s,
      ref: i === 0 ? e : void 0
    }), a);
  });
}
var lC = /* @__PURE__ */ de.forwardRef(Kde);
process.env.NODE_ENV !== "production" && (lC.displayName = "ResizeObserver");
lC.Collection = Ade;
var Zde = `
  min-height:0 !important;
  max-height:none !important;
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
  pointer-events: none !important;
`, Qde = ["letter-spacing", "line-height", "padding-top", "padding-bottom", "font-family", "font-weight", "font-size", "font-variant", "text-rendering", "text-transform", "width", "text-indent", "padding-left", "padding-right", "border-width", "box-sizing", "word-break", "white-space"], Cx = {}, qa;
function Jde(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r = t.getAttribute("id") || t.getAttribute("data-reactid") || t.getAttribute("name");
  if (e && Cx[r])
    return Cx[r];
  var n = window.getComputedStyle(t), a = n.getPropertyValue("box-sizing") || n.getPropertyValue("-moz-box-sizing") || n.getPropertyValue("-webkit-box-sizing"), i = parseFloat(n.getPropertyValue("padding-bottom")) + parseFloat(n.getPropertyValue("padding-top")), s = parseFloat(n.getPropertyValue("border-bottom-width")) + parseFloat(n.getPropertyValue("border-top-width")), o = Qde.map(function(u) {
    return "".concat(u, ":").concat(n.getPropertyValue(u));
  }).join(";"), l = {
    sizingStyle: o,
    paddingSize: i,
    borderSize: s,
    boxSizing: a
  };
  return e && r && (Cx[r] = l), l;
}
function e0e(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  qa || (qa = document.createElement("textarea"), qa.setAttribute("tab-index", "-1"), qa.setAttribute("aria-hidden", "true"), qa.setAttribute("name", "hiddenTextarea"), document.body.appendChild(qa)), t.getAttribute("wrap") ? qa.setAttribute("wrap", t.getAttribute("wrap")) : qa.removeAttribute("wrap");
  var a = Jde(t, e), i = a.paddingSize, s = a.borderSize, o = a.boxSizing, l = a.sizingStyle;
  qa.setAttribute("style", "".concat(l, ";").concat(Zde)), qa.value = t.value || t.placeholder || "";
  var u = void 0, c = void 0, f, h = qa.scrollHeight;
  if (o === "border-box" ? h += s : o === "content-box" && (h -= i), r !== null || n !== null) {
    qa.value = " ";
    var d = qa.scrollHeight - i;
    r !== null && (u = d * r, o === "border-box" && (u = u + i + s), h = Math.max(u, h)), n !== null && (c = d * n, o === "border-box" && (c = c + i + s), f = h > c ? "" : "hidden", h = Math.min(c, h));
  }
  var p = {
    height: h,
    overflowY: f,
    resize: "none"
  };
  return u && (p.minHeight = u), c && (p.maxHeight = c), p;
}
var t0e = ["prefixCls", "defaultValue", "value", "autoSize", "onResize", "className", "style", "disabled", "onChange", "onInternalAutoSize"], Ax = 0, kx = 1, Rx = 2, r0e = /* @__PURE__ */ de.forwardRef(function(t, e) {
  var r = t, n = r.prefixCls, a = r.defaultValue, i = r.value, s = r.autoSize, o = r.onResize, l = r.className, u = r.style, c = r.disabled, f = r.onChange, h = r.onInternalAutoSize, d = vi(r, t0e), p = DS(a, {
    value: i,
    postState: function(j) {
      return j ?? "";
    }
  }), g = bt(p, 2), v = g[0], m = g[1], b = function(j) {
    m(j.target.value), f == null || f(j);
  }, y = de.useRef();
  de.useImperativeHandle(e, function() {
    return {
      textArea: y.current
    };
  });
  var x = de.useMemo(function() {
    return s && Tt(s) === "object" ? [s.minRows, s.maxRows] : [];
  }, [s]), E = bt(x, 2), S = E[0], w = E[1], C = !!s, k = function() {
    try {
      if (document.activeElement === y.current) {
        var j = y.current, Z = j.selectionStart, te = j.selectionEnd, ne = j.scrollTop;
        y.current.setSelectionRange(Z, te), y.current.scrollTop = ne;
      }
    } catch {
    }
  }, N = de.useState(Rx), R = bt(N, 2), _ = R[0], O = R[1], T = de.useState(), L = bt(T, 2), M = L[0], A = L[1], I = function() {
    O(Ax), process.env.NODE_ENV === "test" && (h == null || h());
  };
  zv(function() {
    C && I();
  }, [i, S, w, C]), zv(function() {
    if (_ === Ax)
      O(kx);
    else if (_ === kx) {
      var K = e0e(y.current, !1, S, w);
      O(Rx), A(K);
    } else
      k();
  }, [_]);
  var D = de.useRef(), F = function() {
    Vc.cancel(D.current);
  }, B = function(j) {
    _ === Rx && (o == null || o(j), s && (F(), D.current = Vc(function() {
      I();
    })));
  };
  de.useEffect(function() {
    return F;
  }, []);
  var G = C ? M : null, H = ke(ke({}, u), G);
  return (_ === Ax || _ === kx) && (H.overflowY = "hidden", H.overflowX = "hidden"), /* @__PURE__ */ de.createElement(lC, {
    onResize: B,
    disabled: !(s || o)
  }, /* @__PURE__ */ de.createElement("textarea", Ra({}, d, {
    ref: y,
    style: H,
    className: fr(n, l, pe({}, "".concat(n, "-disabled"), c)),
    disabled: c,
    value: v,
    onChange: b
  })));
}), n0e = ["defaultValue", "value", "onFocus", "onBlur", "onChange", "allowClear", "maxLength", "onCompositionStart", "onCompositionEnd", "suffix", "prefixCls", "showCount", "count", "className", "style", "disabled", "hidden", "classNames", "styles", "onResize", "onClear", "onPressEnter", "readOnly", "autoSize", "onKeyDown"], a0e = /* @__PURE__ */ lt.forwardRef(function(t, e) {
  var r, n = t.defaultValue, a = t.value, i = t.onFocus, s = t.onBlur, o = t.onChange, l = t.allowClear, u = t.maxLength, c = t.onCompositionStart, f = t.onCompositionEnd, h = t.suffix, d = t.prefixCls, p = d === void 0 ? "rc-textarea" : d, g = t.showCount, v = t.count, m = t.className, b = t.style, y = t.disabled, x = t.hidden, E = t.classNames, S = t.styles, w = t.onResize, C = t.onClear, k = t.onPressEnter, N = t.readOnly, R = t.autoSize, _ = t.onKeyDown, O = vi(t, n0e), T = DS(n, {
    value: a,
    defaultValue: n
  }), L = bt(T, 2), M = L[0], A = L[1], I = M == null ? "" : String(M), D = lt.useState(!1), F = bt(D, 2), B = F[0], G = F[1], H = lt.useRef(!1), K = lt.useState(null), j = bt(K, 2), Z = j[0], te = j[1], ne = tn(null), V = tn(null), q = function() {
    var Q;
    return (Q = V.current) === null || Q === void 0 ? void 0 : Q.textArea;
  }, X = function() {
    q().focus();
  };
  q8(e, function() {
    var z;
    return {
      resizableTextArea: V.current,
      focus: X,
      blur: function() {
        q().blur();
      },
      nativeElement: ((z = ne.current) === null || z === void 0 ? void 0 : z.nativeElement) || q()
    };
  }), Fi(function() {
    G(function(z) {
      return !y && z;
    });
  }, [y]);
  var W = lt.useState(null), ue = bt(W, 2), J = ue[0], Ce = ue[1];
  lt.useEffect(function() {
    if (J) {
      var z;
      (z = q()).setSelectionRange.apply(z, Ot(J));
    }
  }, [J]);
  var Ee = UD(v, g), Te = (r = Ee.max) !== null && r !== void 0 ? r : u, me = Number(Te) > 0, we = Ee.strategy(I), Ae = !!Te && we > Te, Ne = function(Q, se) {
    var oe = se;
    !H.current && Ee.exceedFormatter && Ee.max && Ee.strategy(se) > Ee.max && (oe = Ee.exceedFormatter(se, {
      max: Ee.max
    }), se !== oe && Ce([q().selectionStart || 0, q().selectionEnd || 0])), A(oe), Sm(Q.currentTarget, Q, o, oe);
  }, Ie = function(Q) {
    H.current = !0, c == null || c(Q);
  }, Me = function(Q) {
    H.current = !1, Ne(Q, Q.currentTarget.value), f == null || f(Q);
  }, _e = function(Q) {
    Ne(Q, Q.target.value);
  }, Be = function(Q) {
    Q.key === "Enter" && k && k(Q), _ == null || _(Q);
  }, st = function(Q) {
    G(!0), i == null || i(Q);
  }, ct = function(Q) {
    G(!1), s == null || s(Q);
  }, dt = function(Q) {
    A(""), X(), Sm(q(), Q, o);
  }, ft = h, rt;
  Ee.show && (Ee.showFormatter ? rt = Ee.showFormatter({
    value: I,
    count: we,
    maxLength: Te
  }) : rt = "".concat(we).concat(me ? " / ".concat(Te) : ""), ft = /* @__PURE__ */ lt.createElement(lt.Fragment, null, ft, /* @__PURE__ */ lt.createElement("span", {
    className: fr("".concat(p, "-data-count"), E == null ? void 0 : E.count),
    style: S == null ? void 0 : S.count
  }, rt)));
  var je = function(Q) {
    var se;
    w == null || w(Q), (se = q()) !== null && se !== void 0 && se.style.height && te(!0);
  }, ae = !R && !g && !l;
  return /* @__PURE__ */ lt.createElement(GD, {
    ref: ne,
    value: I,
    allowClear: l,
    handleReset: dt,
    suffix: ft,
    prefixCls: p,
    classNames: ke(ke({}, E), {}, {
      affixWrapper: fr(E == null ? void 0 : E.affixWrapper, pe(pe({}, "".concat(p, "-show-count"), g), "".concat(p, "-textarea-allow-clear"), l))
    }),
    disabled: y,
    focused: B,
    className: fr(m, Ae && "".concat(p, "-out-of-range")),
    style: ke(ke({}, b), Z && !ae ? {
      height: "auto"
    } : {}),
    dataAttrs: {
      affixWrapper: {
        "data-count": typeof rt == "string" ? rt : void 0
      }
    },
    hidden: x,
    readOnly: N,
    onClear: C
  }, /* @__PURE__ */ lt.createElement(r0e, Ra({}, O, {
    autoSize: R,
    maxLength: u,
    onKeyDown: Be,
    onChange: _e,
    onFocus: st,
    onBlur: ct,
    onCompositionStart: Ie,
    onCompositionEnd: Me,
    className: fr(E == null ? void 0 : E.textarea),
    style: ke(ke({}, S == null ? void 0 : S.textarea), {}, {
      resize: b == null ? void 0 : b.resize
    }),
    disabled: y,
    prefixCls: p,
    onResize: je,
    ref: V,
    readOnly: N
  })));
}), i0e = { icon: { tag: "svg", attrs: { "fill-rule": "evenodd", viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64c247.4 0 448 200.6 448 448S759.4 960 512 960 64 759.4 64 512 264.6 64 512 64zm127.98 274.82h-.04l-.08.06L512 466.75 384.14 338.88c-.04-.05-.06-.06-.08-.06a.12.12 0 00-.07 0c-.03 0-.05.01-.09.05l-45.02 45.02a.2.2 0 00-.05.09.12.12 0 000 .07v.02a.27.27 0 00.06.06L466.75 512 338.88 639.86c-.05.04-.06.06-.06.08a.12.12 0 000 .07c0 .03.01.05.05.09l45.02 45.02a.2.2 0 00.09.05.12.12 0 00.07 0c.02 0 .04-.01.08-.05L512 557.25l127.86 127.87c.04.04.06.05.08.05a.12.12 0 00.07 0c.03 0 .05-.01.09-.05l45.02-45.02a.2.2 0 00.05-.09.12.12 0 000-.07v-.02a.27.27 0 00-.05-.06L557.25 512l127.87-127.86c.04-.04.05-.06.05-.08a.12.12 0 000-.07c0-.03-.01-.05-.05-.09l-45.02-45.02a.2.2 0 00-.09-.05.12.12 0 00-.07 0z" } }] }, name: "close-circle", theme: "filled" }, uC = /* @__PURE__ */ AS({});
function ZD(t) {
  var e;
  return t == null || (e = t.getRootNode) === null || e === void 0 ? void 0 : e.call(t);
}
function s0e(t) {
  return ZD(t) instanceof ShadowRoot;
}
function o0e(t) {
  return s0e(t) ? ZD(t) : null;
}
function l0e(t) {
  return t.replace(/-(.)/g, function(e, r) {
    return r.toUpperCase();
  });
}
function u0e(t, e) {
  qr(t, "[@ant-design/icons] ".concat(e));
}
function E6(t) {
  return Tt(t) === "object" && typeof t.name == "string" && typeof t.theme == "string" && (Tt(t.icon) === "object" || typeof t.icon == "function");
}
function T6() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return Object.keys(t).reduce(function(e, r) {
    var n = t[r];
    switch (r) {
      case "class":
        e.className = n, delete e.class;
        break;
      default:
        delete e[r], e[l0e(r)] = n;
    }
    return e;
  }, {});
}
function qT(t, e, r) {
  return r ? /* @__PURE__ */ lt.createElement(t.tag, ke(ke({
    key: e
  }, T6(t.attrs)), r), (t.children || []).map(function(n, a) {
    return qT(n, "".concat(e, "-").concat(t.tag, "-").concat(a));
  })) : /* @__PURE__ */ lt.createElement(t.tag, ke({
    key: e
  }, T6(t.attrs)), (t.children || []).map(function(n, a) {
    return qT(n, "".concat(e, "-").concat(t.tag, "-").concat(a));
  }));
}
function QD(t) {
  return Hd(t)[0];
}
function JD(t) {
  return t ? Array.isArray(t) ? t : [t] : [];
}
var c0e = `
.anticon {
  display: inline-flex;
  align-items: center;
  color: inherit;
  font-style: normal;
  line-height: 0;
  text-align: center;
  text-transform: none;
  vertical-align: -0.125em;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.anticon > * {
  line-height: 1;
}

.anticon svg {
  display: inline-block;
}

.anticon::before {
  display: none;
}

.anticon .anticon-icon {
  display: block;
}

.anticon[tabindex] {
  cursor: pointer;
}

.anticon-spin::before,
.anticon-spin {
  display: inline-block;
  -webkit-animation: loadingCircle 1s infinite linear;
  animation: loadingCircle 1s infinite linear;
}

@-webkit-keyframes loadingCircle {
  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}

@keyframes loadingCircle {
  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}
`, f0e = function(e) {
  var r = qi(uC), n = r.csp, a = r.prefixCls, i = r.layer, s = c0e;
  a && (s = s.replace(/anticon/g, a)), i && (s = "@layer ".concat(i, ` {
`).concat(s, `
}`)), Fi(function() {
    var o = e.current, l = o0e(o);
    ql(s, "@ant-design-icons", {
      prepend: !i,
      csp: n,
      attachTo: l
    });
  }, []);
}, h0e = ["icon", "className", "onClick", "style", "primaryColor", "secondaryColor"], kd = {
  primaryColor: "#333",
  secondaryColor: "#E6E6E6",
  calculated: !1
};
function d0e(t) {
  var e = t.primaryColor, r = t.secondaryColor;
  kd.primaryColor = e, kd.secondaryColor = r || QD(e), kd.calculated = !!r;
}
function p0e() {
  return ke({}, kd);
}
var Sf = function(e) {
  var r = e.icon, n = e.className, a = e.onClick, i = e.style, s = e.primaryColor, o = e.secondaryColor, l = vi(e, h0e), u = de.useRef(), c = kd;
  if (s && (c = {
    primaryColor: s,
    secondaryColor: o || QD(s)
  }), f0e(u), u0e(E6(r), "icon should be icon definiton, but got ".concat(r)), !E6(r))
    return null;
  var f = r;
  return f && typeof f.icon == "function" && (f = ke(ke({}, f), {}, {
    icon: f.icon(c.primaryColor, c.secondaryColor)
  })), qT(f.icon, "svg-".concat(f.name), ke(ke({
    className: n,
    onClick: a,
    style: i,
    "data-icon": f.name,
    width: "1em",
    height: "1em",
    fill: "currentColor",
    "aria-hidden": "true"
  }, l), {}, {
    ref: u
  }));
};
Sf.displayName = "IconReact";
Sf.getTwoToneColors = p0e;
Sf.setTwoToneColors = d0e;
function e$(t) {
  var e = JD(t), r = bt(e, 2), n = r[0], a = r[1];
  return Sf.setTwoToneColors({
    primaryColor: n,
    secondaryColor: a
  });
}
function g0e() {
  var t = Sf.getTwoToneColors();
  return t.calculated ? [t.primaryColor, t.secondaryColor] : t.primaryColor;
}
var v0e = ["className", "icon", "spin", "rotate", "tabIndex", "onClick", "twoToneColor"];
e$(Uv.primary);
var L1 = /* @__PURE__ */ de.forwardRef(function(t, e) {
  var r = t.className, n = t.icon, a = t.spin, i = t.rotate, s = t.tabIndex, o = t.onClick, l = t.twoToneColor, u = vi(t, v0e), c = de.useContext(uC), f = c.prefixCls, h = f === void 0 ? "anticon" : f, d = c.rootClassName, p = fr(d, h, pe(pe({}, "".concat(h, "-").concat(n.name), !!n.name), "".concat(h, "-spin"), !!a || n.name === "loading"), r), g = s;
  g === void 0 && o && (g = -1);
  var v = i ? {
    msTransform: "rotate(".concat(i, "deg)"),
    transform: "rotate(".concat(i, "deg)")
  } : void 0, m = JD(l), b = bt(m, 2), y = b[0], x = b[1];
  return /* @__PURE__ */ de.createElement("span", Ra({
    role: "img",
    "aria-label": n.name
  }, u, {
    ref: e,
    tabIndex: g,
    onClick: o,
    className: p
  }), /* @__PURE__ */ de.createElement(Sf, {
    icon: n,
    primaryColor: y,
    secondaryColor: x,
    style: v
  }));
});
L1.displayName = "AntdIcon";
L1.getTwoToneColor = g0e;
L1.setTwoToneColor = e$;
var m0e = function(e, r) {
  return /* @__PURE__ */ de.createElement(L1, Ra({}, e, {
    ref: r,
    icon: i0e
  }));
}, t$ = /* @__PURE__ */ de.forwardRef(m0e);
process.env.NODE_ENV !== "production" && (t$.displayName = "CloseCircleFilled");
const r$ = (t) => {
  let e;
  return typeof t == "object" && (t != null && t.clearIcon) ? e = t : t && (e = {
    clearIcon: /* @__PURE__ */ lt.createElement(t$, null)
  }), e;
};
function WT(t, e, r) {
  return fr({
    [`${t}-status-success`]: e === "success",
    [`${t}-status-warning`]: e === "warning",
    [`${t}-status-error`]: e === "error",
    [`${t}-status-validating`]: e === "validating",
    [`${t}-has-feedback`]: r
  });
}
const n$ = (t, e) => e || t;
function a$() {
}
let Is = null;
function y0e() {
  Is = null, yO();
}
let cC = a$;
process.env.NODE_ENV !== "production" && (cC = (t, e, r) => {
  qr(t, `[antd: ${e}] ${r}`), process.env.NODE_ENV === "test" && y0e();
});
const i$ = /* @__PURE__ */ de.createContext({}), ru = process.env.NODE_ENV !== "production" ? (t) => {
  const {
    strict: e
  } = de.useContext(i$), r = (n, a, i) => {
    if (!n)
      if (e === !1 && a === "deprecated") {
        const s = Is;
        Is || (Is = {}), Is[t] = Is[t] || [], Is[t].includes(i || "") || Is[t].push(i || ""), s || console.warn("[antd] There exists deprecated usage in your code:", Is);
      } else
        process.env.NODE_ENV !== "production" && cC(n, t, i);
  };
  return r.deprecated = (n, a, i, s) => {
    r(n, "deprecated", `\`${a}\` is deprecated. Please use \`${i}\` instead.${s ? ` ${s}` : ""}`);
  }, r;
} : () => {
  const t = () => {
  };
  return t.deprecated = a$, t;
}, N1 = cC, jT = "ant", fC = "anticon", b0e = ["outlined", "borderless", "filled", "underlined"], x0e = (t, e) => e || (t ? `${jT}-${t}` : jT), Ho = /* @__PURE__ */ de.createContext({
  // We provide a default function for Context without provider
  getPrefixCls: x0e,
  iconPrefixCls: fC
}), {
  Consumer: j_e
} = Ho, S6 = {};
function s$(t) {
  const e = de.useContext(Ho), {
    getPrefixCls: r,
    direction: n,
    getPopupContainer: a
  } = e, i = e[t];
  return Object.assign(Object.assign({
    classNames: S6,
    styles: S6
  }, i), {
    getPrefixCls: r,
    direction: n,
    getPopupContainer: a
  });
}
const e0 = /* @__PURE__ */ de.createContext(!1), w0e = (t) => {
  let {
    children: e,
    disabled: r
  } = t;
  const n = de.useContext(e0);
  return /* @__PURE__ */ de.createElement(e0.Provider, {
    value: r ?? n
  }, e);
};
var o$ = /* @__PURE__ */ Nn(function t() {
  Ln(this, t);
}), l$ = "CALC_UNIT", E0e = new RegExp(l$, "g");
function Mx(t) {
  return typeof t == "number" ? "".concat(t).concat(l$) : t;
}
var T0e = /* @__PURE__ */ function(t) {
  il(r, t);
  var e = sl(r);
  function r(n, a) {
    var i;
    Ln(this, r), i = e.call(this), pe($t(i), "result", ""), pe($t(i), "unitlessCssVar", void 0), pe($t(i), "lowPriority", void 0);
    var s = Tt(n);
    return i.unitlessCssVar = a, n instanceof r ? i.result = "(".concat(n.result, ")") : s === "number" ? i.result = Mx(n) : s === "string" && (i.result = n), i;
  }
  return Nn(r, [{
    key: "add",
    value: function(a) {
      return a instanceof r ? this.result = "".concat(this.result, " + ").concat(a.getResult()) : (typeof a == "number" || typeof a == "string") && (this.result = "".concat(this.result, " + ").concat(Mx(a))), this.lowPriority = !0, this;
    }
  }, {
    key: "sub",
    value: function(a) {
      return a instanceof r ? this.result = "".concat(this.result, " - ").concat(a.getResult()) : (typeof a == "number" || typeof a == "string") && (this.result = "".concat(this.result, " - ").concat(Mx(a))), this.lowPriority = !0, this;
    }
  }, {
    key: "mul",
    value: function(a) {
      return this.lowPriority && (this.result = "(".concat(this.result, ")")), a instanceof r ? this.result = "".concat(this.result, " * ").concat(a.getResult(!0)) : (typeof a == "number" || typeof a == "string") && (this.result = "".concat(this.result, " * ").concat(a)), this.lowPriority = !1, this;
    }
  }, {
    key: "div",
    value: function(a) {
      return this.lowPriority && (this.result = "(".concat(this.result, ")")), a instanceof r ? this.result = "".concat(this.result, " / ").concat(a.getResult(!0)) : (typeof a == "number" || typeof a == "string") && (this.result = "".concat(this.result, " / ").concat(a)), this.lowPriority = !1, this;
    }
  }, {
    key: "getResult",
    value: function(a) {
      return this.lowPriority || a ? "(".concat(this.result, ")") : this.result;
    }
  }, {
    key: "equal",
    value: function(a) {
      var i = this, s = a || {}, o = s.unit, l = !0;
      return typeof o == "boolean" ? l = o : Array.from(this.unitlessCssVar).some(function(u) {
        return i.result.includes(u);
      }) && (l = !1), this.result = this.result.replace(E0e, l ? "px" : ""), typeof this.lowPriority < "u" ? "calc(".concat(this.result, ")") : this.result;
    }
  }]), r;
}(o$), S0e = /* @__PURE__ */ function(t) {
  il(r, t);
  var e = sl(r);
  function r(n) {
    var a;
    return Ln(this, r), a = e.call(this), pe($t(a), "result", 0), n instanceof r ? a.result = n.result : typeof n == "number" && (a.result = n), a;
  }
  return Nn(r, [{
    key: "add",
    value: function(a) {
      return a instanceof r ? this.result += a.result : typeof a == "number" && (this.result += a), this;
    }
  }, {
    key: "sub",
    value: function(a) {
      return a instanceof r ? this.result -= a.result : typeof a == "number" && (this.result -= a), this;
    }
  }, {
    key: "mul",
    value: function(a) {
      return a instanceof r ? this.result *= a.result : typeof a == "number" && (this.result *= a), this;
    }
  }, {
    key: "div",
    value: function(a) {
      return a instanceof r ? this.result /= a.result : typeof a == "number" && (this.result /= a), this;
    }
  }, {
    key: "equal",
    value: function() {
      return this.result;
    }
  }]), r;
}(o$), C0e = function(e, r) {
  var n = e === "css" ? T0e : S0e;
  return function(a) {
    return new n(a, r);
  };
}, C6 = function(e, r) {
  return "".concat([r, e.replace(/([A-Z]+)([A-Z][a-z]+)/g, "$1-$2").replace(/([a-z])([A-Z])/g, "$1-$2")].filter(Boolean).join("-"));
};
function A6(t, e, r, n) {
  var a = ke({}, e[t]);
  if (n != null && n.deprecatedTokens) {
    var i = n.deprecatedTokens;
    i.forEach(function(o) {
      var l = bt(o, 2), u = l[0], c = l[1];
      if (process.env.NODE_ENV !== "production" && qr(!(a != null && a[u]), "Component Token `".concat(String(u), "` of ").concat(String(t), " is deprecated. Please use `").concat(String(c), "` instead.")), a != null && a[u] || a != null && a[c]) {
        var f;
        (f = a[c]) !== null && f !== void 0 || (a[c] = a == null ? void 0 : a[u]);
      }
    });
  }
  var s = ke(ke({}, r), a);
  return Object.keys(s).forEach(function(o) {
    s[o] === e[o] && delete s[o];
  }), s;
}
var u$ = process.env.NODE_ENV !== "production" || typeof CSSINJS_STATISTIC < "u", YT = !0;
function Au() {
  for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)
    e[r] = arguments[r];
  if (!u$)
    return Object.assign.apply(Object, [{}].concat(e));
  YT = !1;
  var n = {};
  return e.forEach(function(a) {
    if (Tt(a) === "object") {
      var i = Object.keys(a);
      i.forEach(function(s) {
        Object.defineProperty(n, s, {
          configurable: !0,
          enumerable: !0,
          get: function() {
            return a[s];
          }
        });
      });
    }
  }), YT = !0, n;
}
var k6 = {};
function A0e() {
}
var k0e = function(e) {
  var r, n = e, a = A0e;
  return u$ && typeof Proxy < "u" && (r = /* @__PURE__ */ new Set(), n = new Proxy(e, {
    get: function(s, o) {
      if (YT) {
        var l;
        (l = r) === null || l === void 0 || l.add(o);
      }
      return s[o];
    }
  }), a = function(s, o) {
    var l;
    k6[s] = {
      global: Array.from(r),
      component: ke(ke({}, (l = k6[s]) === null || l === void 0 ? void 0 : l.component), o)
    };
  }), {
    token: n,
    keys: r,
    flush: a
  };
};
function R6(t, e, r) {
  if (typeof r == "function") {
    var n;
    return r(Au(e, (n = e[t]) !== null && n !== void 0 ? n : {}));
  }
  return r ?? {};
}
function R0e(t) {
  return t === "js" ? {
    max: Math.max,
    min: Math.min
  } : {
    max: function() {
      for (var r = arguments.length, n = new Array(r), a = 0; a < r; a++)
        n[a] = arguments[a];
      return "max(".concat(n.map(function(i) {
        return $r(i);
      }).join(","), ")");
    },
    min: function() {
      for (var r = arguments.length, n = new Array(r), a = 0; a < r; a++)
        n[a] = arguments[a];
      return "min(".concat(n.map(function(i) {
        return $r(i);
      }).join(","), ")");
    }
  };
}
var M0e = 1e3 * 60 * 10, _0e = /* @__PURE__ */ function() {
  function t() {
    Ln(this, t), pe(this, "map", /* @__PURE__ */ new Map()), pe(this, "objectIDMap", /* @__PURE__ */ new WeakMap()), pe(this, "nextID", 0), pe(this, "lastAccessBeat", /* @__PURE__ */ new Map()), pe(this, "accessBeat", 0);
  }
  return Nn(t, [{
    key: "set",
    value: function(r, n) {
      this.clear();
      var a = this.getCompositeKey(r);
      this.map.set(a, n), this.lastAccessBeat.set(a, Date.now());
    }
  }, {
    key: "get",
    value: function(r) {
      var n = this.getCompositeKey(r), a = this.map.get(n);
      return this.lastAccessBeat.set(n, Date.now()), this.accessBeat += 1, a;
    }
  }, {
    key: "getCompositeKey",
    value: function(r) {
      var n = this, a = r.map(function(i) {
        return i && Tt(i) === "object" ? "obj_".concat(n.getObjectID(i)) : "".concat(Tt(i), "_").concat(i);
      });
      return a.join("|");
    }
  }, {
    key: "getObjectID",
    value: function(r) {
      if (this.objectIDMap.has(r))
        return this.objectIDMap.get(r);
      var n = this.nextID;
      return this.objectIDMap.set(r, n), this.nextID += 1, n;
    }
  }, {
    key: "clear",
    value: function() {
      var r = this;
      if (this.accessBeat > 1e4) {
        var n = Date.now();
        this.lastAccessBeat.forEach(function(a, i) {
          n - a > M0e && (r.map.delete(i), r.lastAccessBeat.delete(i));
        }), this.accessBeat = 0;
      }
    }
  }]), t;
}(), M6 = new _0e();
function L0e(t, e) {
  return lt.useMemo(function() {
    var r = M6.get(e);
    if (r)
      return r;
    var n = t();
    return M6.set(e, n), n;
  }, e);
}
var N0e = function() {
  return {};
};
function O0e(t) {
  var e = t.useCSP, r = e === void 0 ? N0e : e, n = t.useToken, a = t.usePrefix, i = t.getResetStyles, s = t.getCommonStyle, o = t.getCompUnitless;
  function l(h, d, p, g) {
    var v = Array.isArray(h) ? h[0] : h;
    function m(C) {
      return "".concat(String(v)).concat(C.slice(0, 1).toUpperCase()).concat(C.slice(1));
    }
    var b = (g == null ? void 0 : g.unitless) || {}, y = typeof o == "function" ? o(h) : {}, x = ke(ke({}, y), {}, pe({}, m("zIndexPopup"), !0));
    Object.keys(b).forEach(function(C) {
      x[m(C)] = b[C];
    });
    var E = ke(ke({}, g), {}, {
      unitless: x,
      prefixToken: m
    }), S = c(h, d, p, E), w = u(v, p, E);
    return function(C) {
      var k = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : C, N = S(C, k), R = bt(N, 2), _ = R[1], O = w(k), T = bt(O, 2), L = T[0], M = T[1];
      return [L, _, M];
    };
  }
  function u(h, d, p) {
    var g = p.unitless, v = p.injectStyle, m = v === void 0 ? !0 : v, b = p.prefixToken, y = p.ignore, x = function(w) {
      var C = w.rootCls, k = w.cssVar, N = k === void 0 ? {} : k, R = n(), _ = R.realToken;
      return _Q({
        path: [h],
        prefix: N.prefix,
        key: N.key,
        unitless: g,
        ignore: y,
        token: _,
        scope: C
      }, function() {
        var O = R6(h, _, d), T = A6(h, _, O, {
          deprecatedTokens: p == null ? void 0 : p.deprecatedTokens
        });
        return Object.keys(O).forEach(function(L) {
          T[b(L)] = T[L], delete T[L];
        }), T;
      }), null;
    }, E = function(w) {
      var C = n(), k = C.cssVar;
      return [function(N) {
        return m && k ? /* @__PURE__ */ lt.createElement(lt.Fragment, null, /* @__PURE__ */ lt.createElement(x, {
          rootCls: w,
          cssVar: k,
          component: h
        }), N) : N;
      }, k == null ? void 0 : k.key];
    };
    return E;
  }
  function c(h, d, p) {
    var g = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, v = Array.isArray(h) ? h : [h, h], m = bt(v, 1), b = m[0], y = v.join("-"), x = t.layer || {
      name: "antd"
    };
    return function(E) {
      var S = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : E, w = n(), C = w.theme, k = w.realToken, N = w.hashId, R = w.token, _ = w.cssVar, O = a(), T = O.rootPrefixCls, L = O.iconPrefixCls, M = r(), A = _ ? "css" : "js", I = L0e(function() {
        var K = /* @__PURE__ */ new Set();
        return _ && Object.keys(g.unitless || {}).forEach(function(j) {
          K.add(Kg(j, _.prefix)), K.add(Kg(j, C6(b, _.prefix)));
        }), C0e(A, K);
      }, [A, b, _ == null ? void 0 : _.prefix]), D = R0e(A), F = D.max, B = D.min, G = {
        theme: C,
        token: R,
        hashId: N,
        nonce: function() {
          return M.nonce;
        },
        clientOnly: g.clientOnly,
        layer: x,
        // antd is always at top of styles
        order: g.order || -999
      };
      typeof i == "function" && GE(ke(ke({}, G), {}, {
        clientOnly: !1,
        path: ["Shared", T]
      }), function() {
        return i(R, {
          prefix: {
            rootPrefixCls: T,
            iconPrefixCls: L
          },
          csp: M
        });
      });
      var H = GE(ke(ke({}, G), {}, {
        path: [y, E, L]
      }), function() {
        if (g.injectStyle === !1)
          return [];
        var K = k0e(R), j = K.token, Z = K.flush, te = R6(b, k, p), ne = ".".concat(E), V = A6(b, k, te, {
          deprecatedTokens: g.deprecatedTokens
        });
        _ && te && Tt(te) === "object" && Object.keys(te).forEach(function(ue) {
          te[ue] = "var(".concat(Kg(ue, C6(b, _.prefix)), ")");
        });
        var q = Au(j, {
          componentCls: ne,
          prefixCls: E,
          iconCls: ".".concat(L),
          antCls: ".".concat(T),
          calc: I,
          // @ts-ignore
          max: F,
          // @ts-ignore
          min: B
        }, _ ? te : V), X = d(q, {
          hashId: N,
          prefixCls: E,
          rootPrefixCls: T,
          iconPrefixCls: L
        });
        Z(b, V);
        var W = typeof s == "function" ? s(q, E, S, g.resetFont) : null;
        return [g.resetStyle === !1 ? null : W, X];
      });
      return [H, N];
    };
  }
  function f(h, d, p) {
    var g = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, v = c(h, d, p, ke({
      resetStyle: !1,
      // Sub Style should default after root one
      order: -998
    }, g)), m = function(y) {
      var x = y.prefixCls, E = y.rootCls, S = E === void 0 ? x : E;
      return v(x, S), null;
    };
    return process.env.NODE_ENV !== "production" && (m.displayName = "SubStyle_".concat(String(Array.isArray(h) ? h.join(".") : h))), m;
  }
  return {
    genStyleHooks: l,
    genSubStyleComponent: f,
    genComponentStyleHook: c
  };
}
const c$ = function(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  return {
    boxSizing: "border-box",
    margin: 0,
    padding: 0,
    color: t.colorText,
    fontSize: t.fontSize,
    // font-variant: @font-variant-base;
    lineHeight: t.lineHeight,
    listStyle: "none",
    // font-feature-settings: @font-feature-settings-base;
    fontFamily: e ? "inherit" : t.fontFamily
  };
}, I0e = () => ({
  display: "inline-flex",
  alignItems: "center",
  color: "inherit",
  fontStyle: "normal",
  lineHeight: 0,
  textAlign: "center",
  textTransform: "none",
  // for SVG icon, see https://blog.prototypr.io/align-svg-icons-to-text-and-say-goodbye-to-font-icons-d44b3d7b26b4
  verticalAlign: "-0.125em",
  textRendering: "optimizeLegibility",
  "-webkit-font-smoothing": "antialiased",
  "-moz-osx-font-smoothing": "grayscale",
  "> *": {
    lineHeight: 1
  },
  svg: {
    display: "inline-block"
  }
}), P0e = () => ({
  // https://github.com/ant-design/ant-design/issues/21301#issuecomment-583955229
  "&::before": {
    display: "table",
    content: '""'
  },
  "&::after": {
    // https://github.com/ant-design/ant-design/issues/21864
    display: "table",
    clear: "both",
    content: '""'
  }
}), D0e = (t) => ({
  a: {
    color: t.colorLink,
    textDecoration: t.linkDecoration,
    backgroundColor: "transparent",
    // remove the gray background on active links in IE 10.
    outline: "none",
    cursor: "pointer",
    transition: `color ${t.motionDurationSlow}`,
    "-webkit-text-decoration-skip": "objects",
    // remove gaps in links underline in iOS 8+ and Safari 8+.
    "&:hover": {
      color: t.colorLinkHover
    },
    "&:active": {
      color: t.colorLinkActive
    },
    "&:active, &:hover": {
      textDecoration: t.linkHoverDecoration,
      outline: 0
    },
    // https://github.com/ant-design/ant-design/issues/22503
    "&:focus": {
      textDecoration: t.linkFocusDecoration,
      outline: 0
    },
    "&[disabled]": {
      color: t.colorTextDisabled,
      cursor: "not-allowed"
    }
  }
}), $0e = (t, e, r, n) => {
  const a = `[class^="${e}"], [class*=" ${e}"]`, i = r ? `.${r}` : a, s = {
    boxSizing: "border-box",
    "&::before, &::after": {
      boxSizing: "border-box"
    }
  };
  let o = {};
  return n !== !1 && (o = {
    fontFamily: t.fontFamily,
    fontSize: t.fontSize
  }), {
    [i]: Object.assign(Object.assign(Object.assign({}, o), s), {
      [a]: s
    })
  };
}, f$ = (t) => ({
  [`.${t}`]: Object.assign(Object.assign({}, I0e()), {
    [`.${t} .${t}-icon`]: {
      display: "block"
    }
  })
}), {
  genStyleHooks: hC
} = O0e({
  usePrefix: () => {
    const {
      getPrefixCls: t,
      iconPrefixCls: e
    } = qi(Ho);
    return {
      rootPrefixCls: t(),
      iconPrefixCls: e
    };
  },
  useToken: () => {
    const [t, e, r, n, a] = n1();
    return {
      theme: t,
      realToken: e,
      hashId: r,
      token: n,
      cssVar: a
    };
  },
  useCSP: () => {
    const {
      csp: t
    } = qi(Ho);
    return t ?? {};
  },
  getResetStyles: (t, e) => {
    var r;
    const n = D0e(t);
    return [n, {
      "&": n
    }, f$((r = e == null ? void 0 : e.prefix.iconPrefixCls) !== null && r !== void 0 ? r : fC)];
  },
  getCommonStyle: $0e,
  getCompUnitless: () => OI
}), F0e = (t, e) => {
  const [r, n] = n1();
  return GE({
    token: n,
    hashId: "",
    path: ["ant-design-icons", t],
    nonce: () => e == null ? void 0 : e.nonce,
    layer: {
      name: "antd"
    }
  }, () => [f$(t)]);
}, h$ = (t) => {
  const [, , , , e] = n1();
  return e ? `${t}-css-var` : "";
}, nf = /* @__PURE__ */ de.createContext(void 0), B0e = (t) => {
  let {
    children: e,
    size: r
  } = t;
  const n = de.useContext(nf);
  return /* @__PURE__ */ de.createElement(nf.Provider, {
    value: r || n
  }, e);
}, d$ = (t) => {
  const e = lt.useContext(nf);
  return lt.useMemo(() => t ? typeof t == "string" ? t ?? e : typeof t == "function" ? t(e) : e : e, [t, e]);
};
function ji() {
  ji = function() {
    return e;
  };
  var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, a = Object.defineProperty || function(M, A, I) {
    M[A] = I.value;
  }, i = typeof Symbol == "function" ? Symbol : {}, s = i.iterator || "@@iterator", o = i.asyncIterator || "@@asyncIterator", l = i.toStringTag || "@@toStringTag";
  function u(M, A, I) {
    return Object.defineProperty(M, A, {
      value: I,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), M[A];
  }
  try {
    u({}, "");
  } catch {
    u = function(I, D, F) {
      return I[D] = F;
    };
  }
  function c(M, A, I, D) {
    var F = A && A.prototype instanceof m ? A : m, B = Object.create(F.prototype), G = new T(D || []);
    return a(B, "_invoke", {
      value: N(M, I, G)
    }), B;
  }
  function f(M, A, I) {
    try {
      return {
        type: "normal",
        arg: M.call(A, I)
      };
    } catch (D) {
      return {
        type: "throw",
        arg: D
      };
    }
  }
  e.wrap = c;
  var h = "suspendedStart", d = "suspendedYield", p = "executing", g = "completed", v = {};
  function m() {
  }
  function b() {
  }
  function y() {
  }
  var x = {};
  u(x, s, function() {
    return this;
  });
  var E = Object.getPrototypeOf, S = E && E(E(L([])));
  S && S !== r && n.call(S, s) && (x = S);
  var w = y.prototype = m.prototype = Object.create(x);
  function C(M) {
    ["next", "throw", "return"].forEach(function(A) {
      u(M, A, function(I) {
        return this._invoke(A, I);
      });
    });
  }
  function k(M, A) {
    function I(F, B, G, H) {
      var K = f(M[F], M, B);
      if (K.type !== "throw") {
        var j = K.arg, Z = j.value;
        return Z && Tt(Z) == "object" && n.call(Z, "__await") ? A.resolve(Z.__await).then(function(te) {
          I("next", te, G, H);
        }, function(te) {
          I("throw", te, G, H);
        }) : A.resolve(Z).then(function(te) {
          j.value = te, G(j);
        }, function(te) {
          return I("throw", te, G, H);
        });
      }
      H(K.arg);
    }
    var D;
    a(this, "_invoke", {
      value: function(B, G) {
        function H() {
          return new A(function(K, j) {
            I(B, G, K, j);
          });
        }
        return D = D ? D.then(H, H) : H();
      }
    });
  }
  function N(M, A, I) {
    var D = h;
    return function(F, B) {
      if (D === p) throw Error("Generator is already running");
      if (D === g) {
        if (F === "throw") throw B;
        return {
          value: t,
          done: !0
        };
      }
      for (I.method = F, I.arg = B; ; ) {
        var G = I.delegate;
        if (G) {
          var H = R(G, I);
          if (H) {
            if (H === v) continue;
            return H;
          }
        }
        if (I.method === "next") I.sent = I._sent = I.arg;
        else if (I.method === "throw") {
          if (D === h) throw D = g, I.arg;
          I.dispatchException(I.arg);
        } else I.method === "return" && I.abrupt("return", I.arg);
        D = p;
        var K = f(M, A, I);
        if (K.type === "normal") {
          if (D = I.done ? g : d, K.arg === v) continue;
          return {
            value: K.arg,
            done: I.done
          };
        }
        K.type === "throw" && (D = g, I.method = "throw", I.arg = K.arg);
      }
    };
  }
  function R(M, A) {
    var I = A.method, D = M.iterator[I];
    if (D === t) return A.delegate = null, I === "throw" && M.iterator.return && (A.method = "return", A.arg = t, R(M, A), A.method === "throw") || I !== "return" && (A.method = "throw", A.arg = new TypeError("The iterator does not provide a '" + I + "' method")), v;
    var F = f(D, M.iterator, A.arg);
    if (F.type === "throw") return A.method = "throw", A.arg = F.arg, A.delegate = null, v;
    var B = F.arg;
    return B ? B.done ? (A[M.resultName] = B.value, A.next = M.nextLoc, A.method !== "return" && (A.method = "next", A.arg = t), A.delegate = null, v) : B : (A.method = "throw", A.arg = new TypeError("iterator result is not an object"), A.delegate = null, v);
  }
  function _(M) {
    var A = {
      tryLoc: M[0]
    };
    1 in M && (A.catchLoc = M[1]), 2 in M && (A.finallyLoc = M[2], A.afterLoc = M[3]), this.tryEntries.push(A);
  }
  function O(M) {
    var A = M.completion || {};
    A.type = "normal", delete A.arg, M.completion = A;
  }
  function T(M) {
    this.tryEntries = [{
      tryLoc: "root"
    }], M.forEach(_, this), this.reset(!0);
  }
  function L(M) {
    if (M || M === "") {
      var A = M[s];
      if (A) return A.call(M);
      if (typeof M.next == "function") return M;
      if (!isNaN(M.length)) {
        var I = -1, D = function F() {
          for (; ++I < M.length; ) if (n.call(M, I)) return F.value = M[I], F.done = !1, F;
          return F.value = t, F.done = !0, F;
        };
        return D.next = D;
      }
    }
    throw new TypeError(Tt(M) + " is not iterable");
  }
  return b.prototype = y, a(w, "constructor", {
    value: y,
    configurable: !0
  }), a(y, "constructor", {
    value: b,
    configurable: !0
  }), b.displayName = u(y, l, "GeneratorFunction"), e.isGeneratorFunction = function(M) {
    var A = typeof M == "function" && M.constructor;
    return !!A && (A === b || (A.displayName || A.name) === "GeneratorFunction");
  }, e.mark = function(M) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(M, y) : (M.__proto__ = y, u(M, l, "GeneratorFunction")), M.prototype = Object.create(w), M;
  }, e.awrap = function(M) {
    return {
      __await: M
    };
  }, C(k.prototype), u(k.prototype, o, function() {
    return this;
  }), e.AsyncIterator = k, e.async = function(M, A, I, D, F) {
    F === void 0 && (F = Promise);
    var B = new k(c(M, A, I, D), F);
    return e.isGeneratorFunction(A) ? B : B.next().then(function(G) {
      return G.done ? G.value : B.next();
    });
  }, C(w), u(w, l, "Generator"), u(w, s, function() {
    return this;
  }), u(w, "toString", function() {
    return "[object Generator]";
  }), e.keys = function(M) {
    var A = Object(M), I = [];
    for (var D in A) I.push(D);
    return I.reverse(), function F() {
      for (; I.length; ) {
        var B = I.pop();
        if (B in A) return F.value = B, F.done = !1, F;
      }
      return F.done = !0, F;
    };
  }, e.values = L, T.prototype = {
    constructor: T,
    reset: function(A) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(O), !A) for (var I in this) I.charAt(0) === "t" && n.call(this, I) && !isNaN(+I.slice(1)) && (this[I] = t);
    },
    stop: function() {
      this.done = !0;
      var A = this.tryEntries[0].completion;
      if (A.type === "throw") throw A.arg;
      return this.rval;
    },
    dispatchException: function(A) {
      if (this.done) throw A;
      var I = this;
      function D(j, Z) {
        return G.type = "throw", G.arg = A, I.next = j, Z && (I.method = "next", I.arg = t), !!Z;
      }
      for (var F = this.tryEntries.length - 1; F >= 0; --F) {
        var B = this.tryEntries[F], G = B.completion;
        if (B.tryLoc === "root") return D("end");
        if (B.tryLoc <= this.prev) {
          var H = n.call(B, "catchLoc"), K = n.call(B, "finallyLoc");
          if (H && K) {
            if (this.prev < B.catchLoc) return D(B.catchLoc, !0);
            if (this.prev < B.finallyLoc) return D(B.finallyLoc);
          } else if (H) {
            if (this.prev < B.catchLoc) return D(B.catchLoc, !0);
          } else {
            if (!K) throw Error("try statement without catch or finally");
            if (this.prev < B.finallyLoc) return D(B.finallyLoc);
          }
        }
      }
    },
    abrupt: function(A, I) {
      for (var D = this.tryEntries.length - 1; D >= 0; --D) {
        var F = this.tryEntries[D];
        if (F.tryLoc <= this.prev && n.call(F, "finallyLoc") && this.prev < F.finallyLoc) {
          var B = F;
          break;
        }
      }
      B && (A === "break" || A === "continue") && B.tryLoc <= I && I <= B.finallyLoc && (B = null);
      var G = B ? B.completion : {};
      return G.type = A, G.arg = I, B ? (this.method = "next", this.next = B.finallyLoc, v) : this.complete(G);
    },
    complete: function(A, I) {
      if (A.type === "throw") throw A.arg;
      return A.type === "break" || A.type === "continue" ? this.next = A.arg : A.type === "return" ? (this.rval = this.arg = A.arg, this.method = "return", this.next = "end") : A.type === "normal" && I && (this.next = I), v;
    },
    finish: function(A) {
      for (var I = this.tryEntries.length - 1; I >= 0; --I) {
        var D = this.tryEntries[I];
        if (D.finallyLoc === A) return this.complete(D.completion, D.afterLoc), O(D), v;
      }
    },
    catch: function(A) {
      for (var I = this.tryEntries.length - 1; I >= 0; --I) {
        var D = this.tryEntries[I];
        if (D.tryLoc === A) {
          var F = D.completion;
          if (F.type === "throw") {
            var B = F.arg;
            O(D);
          }
          return B;
        }
      }
      throw Error("illegal catch attempt");
    },
    delegateYield: function(A, I, D) {
      return this.delegate = {
        iterator: L(A),
        resultName: I,
        nextLoc: D
      }, this.method === "next" && (this.arg = t), v;
    }
  }, e;
}
function _6(t, e, r, n, a, i, s) {
  try {
    var o = t[i](s), l = o.value;
  } catch (u) {
    return void r(u);
  }
  o.done ? e(l) : Promise.resolve(l).then(n, a);
}
function Z0(t) {
  return function() {
    var e = this, r = arguments;
    return new Promise(function(n, a) {
      var i = t.apply(e, r);
      function s(l) {
        _6(i, n, a, s, o, "next", l);
      }
      function o(l) {
        _6(i, n, a, s, o, "throw", l);
      }
      s(void 0);
    });
  };
}
var Gl = "RC_FORM_INTERNAL_HOOKS", br = function() {
  qr(!1, "Can not find FormContext. Please make sure you wrap Field under Form.");
}, af = /* @__PURE__ */ de.createContext({
  getFieldValue: br,
  getFieldsValue: br,
  getFieldError: br,
  getFieldWarning: br,
  getFieldsError: br,
  isFieldsTouched: br,
  isFieldTouched: br,
  isFieldValidating: br,
  isFieldsValidating: br,
  resetFields: br,
  setFields: br,
  setFieldValue: br,
  setFieldsValue: br,
  validateFields: br,
  submit: br,
  getInternalHooks: function() {
    return br(), {
      dispatch: br,
      initEntityValue: br,
      registerField: br,
      useSubscribe: br,
      setInitialValues: br,
      destroyForm: br,
      setCallbacks: br,
      registerWatch: br,
      getFields: br,
      setValidateMessages: br,
      setPreserve: br,
      getInitialValue: br
    };
  }
}), Rm = /* @__PURE__ */ de.createContext(null);
function XT(t) {
  return t == null ? [] : Array.isArray(t) ? t : [t];
}
function z0e(t) {
  return t && !!t._init;
}
function KT() {
  return {
    default: "Validation error on field %s",
    required: "%s is required",
    enum: "%s must be one of %s",
    whitespace: "%s cannot be empty",
    date: {
      format: "%s date %s is invalid for format %s",
      parse: "%s date could not be parsed, %s is invalid ",
      invalid: "%s date %s is invalid"
    },
    types: {
      string: "%s is not a %s",
      method: "%s is not a %s (function)",
      array: "%s is not an %s",
      object: "%s is not an %s",
      number: "%s is not a %s",
      date: "%s is not a %s",
      boolean: "%s is not a %s",
      integer: "%s is not an %s",
      float: "%s is not a %s",
      regexp: "%s is not a valid %s",
      email: "%s is not a valid %s",
      url: "%s is not a valid %s",
      hex: "%s is not a valid %s"
    },
    string: {
      len: "%s must be exactly %s characters",
      min: "%s must be at least %s characters",
      max: "%s cannot be longer than %s characters",
      range: "%s must be between %s and %s characters"
    },
    number: {
      len: "%s must equal %s",
      min: "%s cannot be less than %s",
      max: "%s cannot be greater than %s",
      range: "%s must be between %s and %s"
    },
    array: {
      len: "%s must be exactly %s in length",
      min: "%s cannot be less than %s in length",
      max: "%s cannot be greater than %s in length",
      range: "%s must be between %s and %s in length"
    },
    pattern: {
      mismatch: "%s value %s does not match pattern %s"
    },
    clone: function() {
      var e = JSON.parse(JSON.stringify(this));
      return e.clone = this.clone, e;
    }
  };
}
var ZT = KT();
function G0e(t) {
  try {
    return Function.toString.call(t).indexOf("[native code]") !== -1;
  } catch {
    return typeof t == "function";
  }
}
function U0e(t, e, r) {
  if (PS()) return Reflect.construct.apply(null, arguments);
  var n = [null];
  n.push.apply(n, e);
  var a = new (t.bind.apply(t, n))();
  return r && Dd(a, r.prototype), a;
}
function QT(t) {
  var e = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return QT = function(n) {
    if (n === null || !G0e(n)) return n;
    if (typeof n != "function") throw new TypeError("Super expression must either be null or a function");
    if (e !== void 0) {
      if (e.has(n)) return e.get(n);
      e.set(n, a);
    }
    function a() {
      return U0e(n, arguments, $d(this).constructor);
    }
    return a.prototype = Object.create(n.prototype, {
      constructor: {
        value: a,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), Dd(a, n);
  }, QT(t);
}
var H0e = /%[sdj%]/g, p$ = function() {
};
typeof process < "u" && process.env && process.env.NODE_ENV !== "production" && typeof window < "u" && typeof document < "u" && (p$ = function(e, r) {
  typeof console < "u" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING > "u" && r.every(function(n) {
    return typeof n == "string";
  }) && console.warn(e, r);
});
function JT(t) {
  if (!t || !t.length) return null;
  var e = {};
  return t.forEach(function(r) {
    var n = r.field;
    e[n] = e[n] || [], e[n].push(r);
  }), e;
}
function Ja(t) {
  for (var e = arguments.length, r = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++)
    r[n - 1] = arguments[n];
  var a = 0, i = r.length;
  if (typeof t == "function")
    return t.apply(null, r);
  if (typeof t == "string") {
    var s = t.replace(H0e, function(o) {
      if (o === "%%")
        return "%";
      if (a >= i)
        return o;
      switch (o) {
        case "%s":
          return String(r[a++]);
        case "%d":
          return Number(r[a++]);
        case "%j":
          try {
            return JSON.stringify(r[a++]);
          } catch {
            return "[Circular]";
          }
          break;
        default:
          return o;
      }
    });
    return s;
  }
  return t;
}
function V0e(t) {
  return t === "string" || t === "url" || t === "hex" || t === "email" || t === "date" || t === "pattern";
}
function yn(t, e) {
  return !!(t == null || e === "array" && Array.isArray(t) && !t.length || V0e(e) && typeof t == "string" && !t);
}
function q0e(t, e, r) {
  var n = [], a = 0, i = t.length;
  function s(o) {
    n.push.apply(n, Ot(o || [])), a++, a === i && r(n);
  }
  t.forEach(function(o) {
    e(o, s);
  });
}
function L6(t, e, r) {
  var n = 0, a = t.length;
  function i(s) {
    if (s && s.length) {
      r(s);
      return;
    }
    var o = n;
    n = n + 1, o < a ? e(t[o], i) : r([]);
  }
  i([]);
}
function W0e(t) {
  var e = [];
  return Object.keys(t).forEach(function(r) {
    e.push.apply(e, Ot(t[r] || []));
  }), e;
}
var N6 = /* @__PURE__ */ function(t) {
  il(r, t);
  var e = sl(r);
  function r(n, a) {
    var i;
    return Ln(this, r), i = e.call(this, "Async Validation Error"), pe($t(i), "errors", void 0), pe($t(i), "fields", void 0), i.errors = n, i.fields = a, i;
  }
  return Nn(r);
}(/* @__PURE__ */ QT(Error));
function j0e(t, e, r, n, a) {
  if (e.first) {
    var i = new Promise(function(h, d) {
      var p = function(m) {
        return n(m), m.length ? d(new N6(m, JT(m))) : h(a);
      }, g = W0e(t);
      L6(g, r, p);
    });
    return i.catch(function(h) {
      return h;
    }), i;
  }
  var s = e.firstFields === !0 ? Object.keys(t) : e.firstFields || [], o = Object.keys(t), l = o.length, u = 0, c = [], f = new Promise(function(h, d) {
    var p = function(v) {
      if (c.push.apply(c, v), u++, u === l)
        return n(c), c.length ? d(new N6(c, JT(c))) : h(a);
    };
    o.length || (n(c), h(a)), o.forEach(function(g) {
      var v = t[g];
      s.indexOf(g) !== -1 ? L6(v, r, p) : q0e(v, r, p);
    });
  });
  return f.catch(function(h) {
    return h;
  }), f;
}
function Y0e(t) {
  return !!(t && t.message !== void 0);
}
function X0e(t, e) {
  for (var r = t, n = 0; n < e.length; n++) {
    if (r == null)
      return r;
    r = r[e[n]];
  }
  return r;
}
function O6(t, e) {
  return function(r) {
    var n;
    return t.fullFields ? n = X0e(e, t.fullFields) : n = e[r.field || t.fullField], Y0e(r) ? (r.field = r.field || t.fullField, r.fieldValue = n, r) : {
      message: typeof r == "function" ? r() : r,
      fieldValue: n,
      field: r.field || t.fullField
    };
  };
}
function I6(t, e) {
  if (e) {
    for (var r in e)
      if (e.hasOwnProperty(r)) {
        var n = e[r];
        Tt(n) === "object" && Tt(t[r]) === "object" ? t[r] = ke(ke({}, t[r]), n) : t[r] = n;
      }
  }
  return t;
}
var Gu = "enum", K0e = function(e, r, n, a, i) {
  e[Gu] = Array.isArray(e[Gu]) ? e[Gu] : [], e[Gu].indexOf(r) === -1 && a.push(Ja(i.messages[Gu], e.fullField, e[Gu].join(", ")));
}, Z0e = function(e, r, n, a, i) {
  if (e.pattern) {
    if (e.pattern instanceof RegExp)
      e.pattern.lastIndex = 0, e.pattern.test(r) || a.push(Ja(i.messages.pattern.mismatch, e.fullField, r, e.pattern));
    else if (typeof e.pattern == "string") {
      var s = new RegExp(e.pattern);
      s.test(r) || a.push(Ja(i.messages.pattern.mismatch, e.fullField, r, e.pattern));
    }
  }
}, Q0e = function(e, r, n, a, i) {
  var s = typeof e.len == "number", o = typeof e.min == "number", l = typeof e.max == "number", u = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, c = r, f = null, h = typeof r == "number", d = typeof r == "string", p = Array.isArray(r);
  if (h ? f = "number" : d ? f = "string" : p && (f = "array"), !f)
    return !1;
  p && (c = r.length), d && (c = r.replace(u, "_").length), s ? c !== e.len && a.push(Ja(i.messages[f].len, e.fullField, e.len)) : o && !l && c < e.min ? a.push(Ja(i.messages[f].min, e.fullField, e.min)) : l && !o && c > e.max ? a.push(Ja(i.messages[f].max, e.fullField, e.max)) : o && l && (c < e.min || c > e.max) && a.push(Ja(i.messages[f].range, e.fullField, e.min, e.max));
}, g$ = function(e, r, n, a, i, s) {
  e.required && (!n.hasOwnProperty(e.field) || yn(r, s || e.type)) && a.push(Ja(i.messages.required, e.fullField));
}, Zp;
const J0e = function() {
  if (Zp)
    return Zp;
  var t = "[a-fA-F\\d:]", e = function(S) {
    return S && S.includeBoundaries ? "(?:(?<=\\s|^)(?=".concat(t, ")|(?<=").concat(t, ")(?=\\s|$))") : "";
  }, r = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}", n = "[a-fA-F\\d]{1,4}", a = [
    "(?:".concat(n, ":){7}(?:").concat(n, "|:)"),
    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
    "(?:".concat(n, ":){6}(?:").concat(r, "|:").concat(n, "|:)"),
    // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::
    "(?:".concat(n, ":){5}(?::").concat(r, "|(?::").concat(n, "){1,2}|:)"),
    // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::
    "(?:".concat(n, ":){4}(?:(?::").concat(n, "){0,1}:").concat(r, "|(?::").concat(n, "){1,3}|:)"),
    // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::
    "(?:".concat(n, ":){3}(?:(?::").concat(n, "){0,2}:").concat(r, "|(?::").concat(n, "){1,4}|:)"),
    // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::
    "(?:".concat(n, ":){2}(?:(?::").concat(n, "){0,3}:").concat(r, "|(?::").concat(n, "){1,5}|:)"),
    // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::
    "(?:".concat(n, ":){1}(?:(?::").concat(n, "){0,4}:").concat(r, "|(?::").concat(n, "){1,6}|:)"),
    // 1::              1::3:4:5:6:7:8   1::8            1::
    "(?::(?:(?::".concat(n, "){0,5}:").concat(r, "|(?::").concat(n, "){1,7}|:))")
    // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::
  ], i = "(?:%[0-9a-zA-Z]{1,})?", s = "(?:".concat(a.join("|"), ")").concat(i), o = new RegExp("(?:^".concat(r, "$)|(?:^").concat(s, "$)")), l = new RegExp("^".concat(r, "$")), u = new RegExp("^".concat(s, "$")), c = function(S) {
    return S && S.exact ? o : new RegExp("(?:".concat(e(S)).concat(r).concat(e(S), ")|(?:").concat(e(S)).concat(s).concat(e(S), ")"), "g");
  };
  c.v4 = function(E) {
    return E && E.exact ? l : new RegExp("".concat(e(E)).concat(r).concat(e(E)), "g");
  }, c.v6 = function(E) {
    return E && E.exact ? u : new RegExp("".concat(e(E)).concat(s).concat(e(E)), "g");
  };
  var f = "(?:(?:[a-z]+:)?//)", h = "(?:\\S+(?::\\S*)?@)?", d = c.v4().source, p = c.v6().source, g = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)", v = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*", m = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))", b = "(?::\\d{2,5})?", y = '(?:[/?#][^\\s"]*)?', x = "(?:".concat(f, "|www\\.)").concat(h, "(?:localhost|").concat(d, "|").concat(p, "|").concat(g).concat(v).concat(m, ")").concat(b).concat(y);
  return Zp = new RegExp("(?:^".concat(x, "$)"), "i"), Zp;
};
var P6 = {
  // http://emailregex.com/
  email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
  // url: new RegExp(
  //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
  //   'i',
  // ),
  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
}, kh = {
  integer: function(e) {
    return kh.number(e) && parseInt(e, 10) === e;
  },
  float: function(e) {
    return kh.number(e) && !kh.integer(e);
  },
  array: function(e) {
    return Array.isArray(e);
  },
  regexp: function(e) {
    if (e instanceof RegExp)
      return !0;
    try {
      return !!new RegExp(e);
    } catch {
      return !1;
    }
  },
  date: function(e) {
    return typeof e.getTime == "function" && typeof e.getMonth == "function" && typeof e.getYear == "function" && !isNaN(e.getTime());
  },
  number: function(e) {
    return isNaN(e) ? !1 : typeof e == "number";
  },
  object: function(e) {
    return Tt(e) === "object" && !kh.array(e);
  },
  method: function(e) {
    return typeof e == "function";
  },
  email: function(e) {
    return typeof e == "string" && e.length <= 320 && !!e.match(P6.email);
  },
  url: function(e) {
    return typeof e == "string" && e.length <= 2048 && !!e.match(J0e());
  },
  hex: function(e) {
    return typeof e == "string" && !!e.match(P6.hex);
  }
}, epe = function(e, r, n, a, i) {
  if (e.required && r === void 0) {
    g$(e, r, n, a, i);
    return;
  }
  var s = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"], o = e.type;
  s.indexOf(o) > -1 ? kh[o](r) || a.push(Ja(i.messages.types[o], e.fullField, e.type)) : o && Tt(r) !== e.type && a.push(Ja(i.messages.types[o], e.fullField, e.type));
}, tpe = function(e, r, n, a, i) {
  (/^\s+$/.test(r) || r === "") && a.push(Ja(i.messages.whitespace, e.fullField));
};
const Yt = {
  required: g$,
  whitespace: tpe,
  type: epe,
  range: Q0e,
  enum: K0e,
  pattern: Z0e
};
var rpe = function(e, r, n, a, i) {
  var s = [], o = e.required || !e.required && a.hasOwnProperty(e.field);
  if (o) {
    if (yn(r) && !e.required)
      return n();
    Yt.required(e, r, a, s, i);
  }
  n(s);
}, npe = function(e, r, n, a, i) {
  var s = [], o = e.required || !e.required && a.hasOwnProperty(e.field);
  if (o) {
    if (r == null && !e.required)
      return n();
    Yt.required(e, r, a, s, i, "array"), r != null && (Yt.type(e, r, a, s, i), Yt.range(e, r, a, s, i));
  }
  n(s);
}, ape = function(e, r, n, a, i) {
  var s = [], o = e.required || !e.required && a.hasOwnProperty(e.field);
  if (o) {
    if (yn(r) && !e.required)
      return n();
    Yt.required(e, r, a, s, i), r !== void 0 && Yt.type(e, r, a, s, i);
  }
  n(s);
}, ipe = function(e, r, n, a, i) {
  var s = [], o = e.required || !e.required && a.hasOwnProperty(e.field);
  if (o) {
    if (yn(r, "date") && !e.required)
      return n();
    if (Yt.required(e, r, a, s, i), !yn(r, "date")) {
      var l;
      r instanceof Date ? l = r : l = new Date(r), Yt.type(e, l, a, s, i), l && Yt.range(e, l.getTime(), a, s, i);
    }
  }
  n(s);
}, spe = "enum", ope = function(e, r, n, a, i) {
  var s = [], o = e.required || !e.required && a.hasOwnProperty(e.field);
  if (o) {
    if (yn(r) && !e.required)
      return n();
    Yt.required(e, r, a, s, i), r !== void 0 && Yt[spe](e, r, a, s, i);
  }
  n(s);
}, lpe = function(e, r, n, a, i) {
  var s = [], o = e.required || !e.required && a.hasOwnProperty(e.field);
  if (o) {
    if (yn(r) && !e.required)
      return n();
    Yt.required(e, r, a, s, i), r !== void 0 && (Yt.type(e, r, a, s, i), Yt.range(e, r, a, s, i));
  }
  n(s);
}, upe = function(e, r, n, a, i) {
  var s = [], o = e.required || !e.required && a.hasOwnProperty(e.field);
  if (o) {
    if (yn(r) && !e.required)
      return n();
    Yt.required(e, r, a, s, i), r !== void 0 && (Yt.type(e, r, a, s, i), Yt.range(e, r, a, s, i));
  }
  n(s);
}, cpe = function(e, r, n, a, i) {
  var s = [], o = e.required || !e.required && a.hasOwnProperty(e.field);
  if (o) {
    if (yn(r) && !e.required)
      return n();
    Yt.required(e, r, a, s, i), r !== void 0 && Yt.type(e, r, a, s, i);
  }
  n(s);
}, fpe = function(e, r, n, a, i) {
  var s = [], o = e.required || !e.required && a.hasOwnProperty(e.field);
  if (o) {
    if (r === "" && (r = void 0), yn(r) && !e.required)
      return n();
    Yt.required(e, r, a, s, i), r !== void 0 && (Yt.type(e, r, a, s, i), Yt.range(e, r, a, s, i));
  }
  n(s);
}, hpe = function(e, r, n, a, i) {
  var s = [], o = e.required || !e.required && a.hasOwnProperty(e.field);
  if (o) {
    if (yn(r) && !e.required)
      return n();
    Yt.required(e, r, a, s, i), r !== void 0 && Yt.type(e, r, a, s, i);
  }
  n(s);
}, dpe = function(e, r, n, a, i) {
  var s = [], o = e.required || !e.required && a.hasOwnProperty(e.field);
  if (o) {
    if (yn(r, "string") && !e.required)
      return n();
    Yt.required(e, r, a, s, i), yn(r, "string") || Yt.pattern(e, r, a, s, i);
  }
  n(s);
}, ppe = function(e, r, n, a, i) {
  var s = [], o = e.required || !e.required && a.hasOwnProperty(e.field);
  if (o) {
    if (yn(r) && !e.required)
      return n();
    Yt.required(e, r, a, s, i), yn(r) || Yt.type(e, r, a, s, i);
  }
  n(s);
}, gpe = function(e, r, n, a, i) {
  var s = [], o = Array.isArray(r) ? "array" : Tt(r);
  Yt.required(e, r, a, s, i, o), n(s);
}, vpe = function(e, r, n, a, i) {
  var s = [], o = e.required || !e.required && a.hasOwnProperty(e.field);
  if (o) {
    if (yn(r, "string") && !e.required)
      return n();
    Yt.required(e, r, a, s, i, "string"), yn(r, "string") || (Yt.type(e, r, a, s, i), Yt.range(e, r, a, s, i), Yt.pattern(e, r, a, s, i), e.whitespace === !0 && Yt.whitespace(e, r, a, s, i));
  }
  n(s);
}, _x = function(e, r, n, a, i) {
  var s = e.type, o = [], l = e.required || !e.required && a.hasOwnProperty(e.field);
  if (l) {
    if (yn(r, s) && !e.required)
      return n();
    Yt.required(e, r, a, o, i, s), yn(r, s) || Yt.type(e, r, a, o, i);
  }
  n(o);
};
const Rd = {
  string: vpe,
  method: cpe,
  number: fpe,
  boolean: ape,
  regexp: ppe,
  integer: upe,
  float: lpe,
  array: npe,
  object: hpe,
  enum: ope,
  pattern: dpe,
  date: ipe,
  url: _x,
  hex: _x,
  email: _x,
  required: gpe,
  any: rpe
};
var Q0 = /* @__PURE__ */ function() {
  function t(e) {
    Ln(this, t), pe(this, "rules", null), pe(this, "_messages", ZT), this.define(e);
  }
  return Nn(t, [{
    key: "define",
    value: function(r) {
      var n = this;
      if (!r)
        throw new Error("Cannot configure a schema with no rules");
      if (Tt(r) !== "object" || Array.isArray(r))
        throw new Error("Rules must be an object");
      this.rules = {}, Object.keys(r).forEach(function(a) {
        var i = r[a];
        n.rules[a] = Array.isArray(i) ? i : [i];
      });
    }
  }, {
    key: "messages",
    value: function(r) {
      return r && (this._messages = I6(KT(), r)), this._messages;
    }
  }, {
    key: "validate",
    value: function(r) {
      var n = this, a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function() {
      }, s = r, o = a, l = i;
      if (typeof o == "function" && (l = o, o = {}), !this.rules || Object.keys(this.rules).length === 0)
        return l && l(null, s), Promise.resolve(s);
      function u(p) {
        var g = [], v = {};
        function m(y) {
          if (Array.isArray(y)) {
            var x;
            g = (x = g).concat.apply(x, Ot(y));
          } else
            g.push(y);
        }
        for (var b = 0; b < p.length; b++)
          m(p[b]);
        g.length ? (v = JT(g), l(g, v)) : l(null, s);
      }
      if (o.messages) {
        var c = this.messages();
        c === ZT && (c = KT()), I6(c, o.messages), o.messages = c;
      } else
        o.messages = this.messages();
      var f = {}, h = o.keys || Object.keys(this.rules);
      h.forEach(function(p) {
        var g = n.rules[p], v = s[p];
        g.forEach(function(m) {
          var b = m;
          typeof b.transform == "function" && (s === r && (s = ke({}, s)), v = s[p] = b.transform(v), v != null && (b.type = b.type || (Array.isArray(v) ? "array" : Tt(v)))), typeof b == "function" ? b = {
            validator: b
          } : b = ke({}, b), b.validator = n.getValidationMethod(b), b.validator && (b.field = p, b.fullField = b.fullField || p, b.type = n.getType(b), f[p] = f[p] || [], f[p].push({
            rule: b,
            value: v,
            source: s,
            field: p
          }));
        });
      });
      var d = {};
      return j0e(f, o, function(p, g) {
        var v = p.rule, m = (v.type === "object" || v.type === "array") && (Tt(v.fields) === "object" || Tt(v.defaultField) === "object");
        m = m && (v.required || !v.required && p.value), v.field = p.field;
        function b(w, C) {
          return ke(ke({}, C), {}, {
            fullField: "".concat(v.fullField, ".").concat(w),
            fullFields: v.fullFields ? [].concat(Ot(v.fullFields), [w]) : [w]
          });
        }
        function y() {
          var w = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], C = Array.isArray(w) ? w : [w];
          !o.suppressWarning && C.length && t.warning("async-validator:", C), C.length && v.message !== void 0 && (C = [].concat(v.message));
          var k = C.map(O6(v, s));
          if (o.first && k.length)
            return d[v.field] = 1, g(k);
          if (!m)
            g(k);
          else {
            if (v.required && !p.value)
              return v.message !== void 0 ? k = [].concat(v.message).map(O6(v, s)) : o.error && (k = [o.error(v, Ja(o.messages.required, v.field))]), g(k);
            var N = {};
            v.defaultField && Object.keys(p.value).map(function(O) {
              N[O] = v.defaultField;
            }), N = ke(ke({}, N), p.rule.fields);
            var R = {};
            Object.keys(N).forEach(function(O) {
              var T = N[O], L = Array.isArray(T) ? T : [T];
              R[O] = L.map(b.bind(null, O));
            });
            var _ = new t(R);
            _.messages(o.messages), p.rule.options && (p.rule.options.messages = o.messages, p.rule.options.error = o.error), _.validate(p.value, p.rule.options || o, function(O) {
              var T = [];
              k && k.length && T.push.apply(T, Ot(k)), O && O.length && T.push.apply(T, Ot(O)), g(T.length ? T : null);
            });
          }
        }
        var x;
        if (v.asyncValidator)
          x = v.asyncValidator(v, p.value, y, p.source, o);
        else if (v.validator) {
          try {
            x = v.validator(v, p.value, y, p.source, o);
          } catch (w) {
            var E, S;
            (E = (S = console).error) === null || E === void 0 || E.call(S, w), o.suppressValidatorError || setTimeout(function() {
              throw w;
            }, 0), y(w.message);
          }
          x === !0 ? y() : x === !1 ? y(typeof v.message == "function" ? v.message(v.fullField || v.field) : v.message || "".concat(v.fullField || v.field, " fails")) : x instanceof Array ? y(x) : x instanceof Error && y(x.message);
        }
        x && x.then && x.then(function() {
          return y();
        }, function(w) {
          return y(w);
        });
      }, function(p) {
        u(p);
      }, s);
    }
  }, {
    key: "getType",
    value: function(r) {
      if (r.type === void 0 && r.pattern instanceof RegExp && (r.type = "pattern"), typeof r.validator != "function" && r.type && !Rd.hasOwnProperty(r.type))
        throw new Error(Ja("Unknown rule type %s", r.type));
      return r.type || "string";
    }
  }, {
    key: "getValidationMethod",
    value: function(r) {
      if (typeof r.validator == "function")
        return r.validator;
      var n = Object.keys(r), a = n.indexOf("message");
      return a !== -1 && n.splice(a, 1), n.length === 1 && n[0] === "required" ? Rd.required : Rd[this.getType(r)] || void 0;
    }
  }]), t;
}();
pe(Q0, "register", function(e, r) {
  if (typeof r != "function")
    throw new Error("Cannot register a validator by type, validator is not a function");
  Rd[e] = r;
});
pe(Q0, "warning", p$);
pe(Q0, "messages", ZT);
pe(Q0, "validators", Rd);
var Wa = "'${name}' is not a valid ${type}", v$ = {
  default: "Validation error on field '${name}'",
  required: "'${name}' is required",
  enum: "'${name}' must be one of [${enum}]",
  whitespace: "'${name}' cannot be empty",
  date: {
    format: "'${name}' is invalid for format date",
    parse: "'${name}' could not be parsed as date",
    invalid: "'${name}' is invalid date"
  },
  types: {
    string: Wa,
    method: Wa,
    array: Wa,
    object: Wa,
    number: Wa,
    date: Wa,
    boolean: Wa,
    integer: Wa,
    float: Wa,
    regexp: Wa,
    email: Wa,
    url: Wa,
    hex: Wa
  },
  string: {
    len: "'${name}' must be exactly ${len} characters",
    min: "'${name}' must be at least ${min} characters",
    max: "'${name}' cannot be longer than ${max} characters",
    range: "'${name}' must be between ${min} and ${max} characters"
  },
  number: {
    len: "'${name}' must equal ${len}",
    min: "'${name}' cannot be less than ${min}",
    max: "'${name}' cannot be greater than ${max}",
    range: "'${name}' must be between ${min} and ${max}"
  },
  array: {
    len: "'${name}' must be exactly ${len} in length",
    min: "'${name}' cannot be less than ${min} in length",
    max: "'${name}' cannot be greater than ${max} in length",
    range: "'${name}' must be between ${min} and ${max} in length"
  },
  pattern: {
    mismatch: "'${name}' does not match pattern ${pattern}"
  }
}, D6 = Q0;
function mpe(t, e) {
  return t.replace(/\\?\$\{\w+\}/g, function(r) {
    if (r.startsWith("\\"))
      return r.slice(1);
    var n = r.slice(2, -1);
    return e[n];
  });
}
var $6 = "CODE_LOGIC_ERROR";
function e4(t, e, r, n, a) {
  return t4.apply(this, arguments);
}
function t4() {
  return t4 = Z0(/* @__PURE__ */ ji().mark(function t(e, r, n, a, i) {
    var s, o, l, u, c, f, h, d, p;
    return ji().wrap(function(v) {
      for (; ; ) switch (v.prev = v.next) {
        case 0:
          return s = ke({}, n), delete s.ruleIndex, D6.warning = function() {
          }, s.validator && (o = s.validator, s.validator = function() {
            try {
              return o.apply(void 0, arguments);
            } catch (m) {
              return console.error(m), Promise.reject($6);
            }
          }), l = null, s && s.type === "array" && s.defaultField && (l = s.defaultField, delete s.defaultField), u = new D6(pe({}, e, [s])), c = tc(v$, a.validateMessages), u.messages(c), f = [], v.prev = 10, v.next = 13, Promise.resolve(u.validate(pe({}, e, r), ke({}, a)));
        case 13:
          v.next = 18;
          break;
        case 15:
          v.prev = 15, v.t0 = v.catch(10), v.t0.errors && (f = v.t0.errors.map(function(m, b) {
            var y = m.message, x = y === $6 ? c.default : y;
            return /* @__PURE__ */ de.isValidElement(x) ? (
              // Wrap ReactNode with `key`
              /* @__PURE__ */ de.cloneElement(x, {
                key: "error_".concat(b)
              })
            ) : x;
          }));
        case 18:
          if (!(!f.length && l)) {
            v.next = 23;
            break;
          }
          return v.next = 21, Promise.all(r.map(function(m, b) {
            return e4("".concat(e, ".").concat(b), m, l, a, i);
          }));
        case 21:
          return h = v.sent, v.abrupt("return", h.reduce(function(m, b) {
            return [].concat(Ot(m), Ot(b));
          }, []));
        case 23:
          return d = ke(ke({}, n), {}, {
            name: e,
            enum: (n.enum || []).join(", ")
          }, i), p = f.map(function(m) {
            return typeof m == "string" ? mpe(m, d) : m;
          }), v.abrupt("return", p);
        case 26:
        case "end":
          return v.stop();
      }
    }, t, null, [[10, 15]]);
  })), t4.apply(this, arguments);
}
function ype(t, e, r, n, a, i) {
  var s = t.join("."), o = r.map(function(c, f) {
    var h = c.validator, d = ke(ke({}, c), {}, {
      ruleIndex: f
    });
    return h && (d.validator = function(p, g, v) {
      var m = !1, b = function() {
        for (var E = arguments.length, S = new Array(E), w = 0; w < E; w++)
          S[w] = arguments[w];
        Promise.resolve().then(function() {
          qr(!m, "Your validator function has already return a promise. `callback` will be ignored."), m || v.apply(void 0, S);
        });
      }, y = h(p, g, b);
      m = y && typeof y.then == "function" && typeof y.catch == "function", qr(m, "`callback` is deprecated. Please return a promise instead."), m && y.then(function() {
        v();
      }).catch(function(x) {
        v(x || " ");
      });
    }), d;
  }).sort(function(c, f) {
    var h = c.warningOnly, d = c.ruleIndex, p = f.warningOnly, g = f.ruleIndex;
    return !!h == !!p ? d - g : h ? 1 : -1;
  }), l;
  if (a === !0)
    l = new Promise(/* @__PURE__ */ function() {
      var c = Z0(/* @__PURE__ */ ji().mark(function f(h, d) {
        var p, g, v;
        return ji().wrap(function(b) {
          for (; ; ) switch (b.prev = b.next) {
            case 0:
              p = 0;
            case 1:
              if (!(p < o.length)) {
                b.next = 12;
                break;
              }
              return g = o[p], b.next = 5, e4(s, e, g, n, i);
            case 5:
              if (v = b.sent, !v.length) {
                b.next = 9;
                break;
              }
              return d([{
                errors: v,
                rule: g
              }]), b.abrupt("return");
            case 9:
              p += 1, b.next = 1;
              break;
            case 12:
              h([]);
            case 13:
            case "end":
              return b.stop();
          }
        }, f);
      }));
      return function(f, h) {
        return c.apply(this, arguments);
      };
    }());
  else {
    var u = o.map(function(c) {
      return e4(s, e, c, n, i).then(function(f) {
        return {
          errors: f,
          rule: c
        };
      });
    });
    l = (a ? xpe(u) : bpe(u)).then(function(c) {
      return Promise.reject(c);
    });
  }
  return l.catch(function(c) {
    return c;
  }), l;
}
function bpe(t) {
  return r4.apply(this, arguments);
}
function r4() {
  return r4 = Z0(/* @__PURE__ */ ji().mark(function t(e) {
    return ji().wrap(function(n) {
      for (; ; ) switch (n.prev = n.next) {
        case 0:
          return n.abrupt("return", Promise.all(e).then(function(a) {
            var i, s = (i = []).concat.apply(i, Ot(a));
            return s;
          }));
        case 1:
        case "end":
          return n.stop();
      }
    }, t);
  })), r4.apply(this, arguments);
}
function xpe(t) {
  return n4.apply(this, arguments);
}
function n4() {
  return n4 = Z0(/* @__PURE__ */ ji().mark(function t(e) {
    var r;
    return ji().wrap(function(a) {
      for (; ; ) switch (a.prev = a.next) {
        case 0:
          return r = 0, a.abrupt("return", new Promise(function(i) {
            e.forEach(function(s) {
              s.then(function(o) {
                o.errors.length && i([o]), r += 1, r === e.length && i([]);
              });
            });
          }));
        case 2:
        case "end":
          return a.stop();
      }
    }, t);
  })), n4.apply(this, arguments);
}
function Jr(t) {
  return XT(t);
}
function F6(t, e) {
  var r = {};
  return e.forEach(function(n) {
    var a = cs(t, n);
    r = Ri(r, n, a);
  }), r;
}
function bc(t, e) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  return t && t.some(function(n) {
    return m$(e, n, r);
  });
}
function m$(t, e) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  return !t || !e || !r && t.length !== e.length ? !1 : e.every(function(n, a) {
    return t[a] === n;
  });
}
function wpe(t, e) {
  if (t === e)
    return !0;
  if (!t && e || t && !e || !t || !e || Tt(t) !== "object" || Tt(e) !== "object")
    return !1;
  var r = Object.keys(t), n = Object.keys(e), a = new Set([].concat(r, n));
  return Ot(a).every(function(i) {
    var s = t[i], o = e[i];
    return typeof s == "function" && typeof o == "function" ? !0 : s === o;
  });
}
function Epe(t) {
  var e = arguments.length <= 1 ? void 0 : arguments[1];
  return e && e.target && Tt(e.target) === "object" && t in e.target ? e.target[t] : e;
}
function B6(t, e, r) {
  var n = t.length;
  if (e < 0 || e >= n || r < 0 || r >= n)
    return t;
  var a = t[e], i = e - r;
  return i > 0 ? [].concat(Ot(t.slice(0, r)), [a], Ot(t.slice(r, e)), Ot(t.slice(e + 1, n))) : i < 0 ? [].concat(Ot(t.slice(0, e)), Ot(t.slice(e + 1, r + 1)), [a], Ot(t.slice(r + 1, n))) : t;
}
var Tpe = ["name"], ui = [];
function Lx(t, e, r, n, a, i) {
  return typeof t == "function" ? t(e, r, "source" in i ? {
    source: i.source
  } : {}) : n !== a;
}
var dC = /* @__PURE__ */ function(t) {
  il(r, t);
  var e = sl(r);
  function r(n) {
    var a;
    if (Ln(this, r), a = e.call(this, n), pe($t(a), "state", {
      resetCount: 0
    }), pe($t(a), "cancelRegisterFunc", null), pe($t(a), "mounted", !1), pe($t(a), "touched", !1), pe($t(a), "dirty", !1), pe($t(a), "validatePromise", void 0), pe($t(a), "prevValidating", void 0), pe($t(a), "errors", ui), pe($t(a), "warnings", ui), pe($t(a), "cancelRegister", function() {
      var l = a.props, u = l.preserve, c = l.isListField, f = l.name;
      a.cancelRegisterFunc && a.cancelRegisterFunc(c, u, Jr(f)), a.cancelRegisterFunc = null;
    }), pe($t(a), "getNamePath", function() {
      var l = a.props, u = l.name, c = l.fieldContext, f = c.prefixName, h = f === void 0 ? [] : f;
      return u !== void 0 ? [].concat(Ot(h), Ot(u)) : [];
    }), pe($t(a), "getRules", function() {
      var l = a.props, u = l.rules, c = u === void 0 ? [] : u, f = l.fieldContext;
      return c.map(function(h) {
        return typeof h == "function" ? h(f) : h;
      });
    }), pe($t(a), "refresh", function() {
      a.mounted && a.setState(function(l) {
        var u = l.resetCount;
        return {
          resetCount: u + 1
        };
      });
    }), pe($t(a), "metaCache", null), pe($t(a), "triggerMetaEvent", function(l) {
      var u = a.props.onMetaChange;
      if (u) {
        var c = ke(ke({}, a.getMeta()), {}, {
          destroy: l
        });
        DE(a.metaCache, c) || u(c), a.metaCache = c;
      } else
        a.metaCache = null;
    }), pe($t(a), "onStoreChange", function(l, u, c) {
      var f = a.props, h = f.shouldUpdate, d = f.dependencies, p = d === void 0 ? [] : d, g = f.onReset, v = c.store, m = a.getNamePath(), b = a.getValue(l), y = a.getValue(v), x = u && bc(u, m);
      switch (c.type === "valueUpdate" && c.source === "external" && !DE(b, y) && (a.touched = !0, a.dirty = !0, a.validatePromise = null, a.errors = ui, a.warnings = ui, a.triggerMetaEvent()), c.type) {
        case "reset":
          if (!u || x) {
            a.touched = !1, a.dirty = !1, a.validatePromise = void 0, a.errors = ui, a.warnings = ui, a.triggerMetaEvent(), g == null || g(), a.refresh();
            return;
          }
          break;
        case "remove": {
          if (h && Lx(h, l, v, b, y, c)) {
            a.reRender();
            return;
          }
          break;
        }
        case "setField": {
          var E = c.data;
          if (x) {
            "touched" in E && (a.touched = E.touched), "validating" in E && !("originRCField" in E) && (a.validatePromise = E.validating ? Promise.resolve([]) : null), "errors" in E && (a.errors = E.errors || ui), "warnings" in E && (a.warnings = E.warnings || ui), a.dirty = !0, a.triggerMetaEvent(), a.reRender();
            return;
          } else if ("value" in E && bc(u, m, !0)) {
            a.reRender();
            return;
          }
          if (h && !m.length && Lx(h, l, v, b, y, c)) {
            a.reRender();
            return;
          }
          break;
        }
        case "dependenciesUpdate": {
          var S = p.map(Jr);
          if (S.some(function(w) {
            return bc(c.relatedFields, w);
          })) {
            a.reRender();
            return;
          }
          break;
        }
        default:
          if (x || (!p.length || m.length || h) && Lx(h, l, v, b, y, c)) {
            a.reRender();
            return;
          }
          break;
      }
      h === !0 && a.reRender();
    }), pe($t(a), "validateRules", function(l) {
      var u = a.getNamePath(), c = a.getValue(), f = l || {}, h = f.triggerName, d = f.validateOnly, p = d === void 0 ? !1 : d, g = Promise.resolve().then(/* @__PURE__ */ Z0(/* @__PURE__ */ ji().mark(function v() {
        var m, b, y, x, E, S, w;
        return ji().wrap(function(k) {
          for (; ; ) switch (k.prev = k.next) {
            case 0:
              if (a.mounted) {
                k.next = 2;
                break;
              }
              return k.abrupt("return", []);
            case 2:
              if (m = a.props, b = m.validateFirst, y = b === void 0 ? !1 : b, x = m.messageVariables, E = m.validateDebounce, S = a.getRules(), h && (S = S.filter(function(N) {
                return N;
              }).filter(function(N) {
                var R = N.validateTrigger;
                if (!R)
                  return !0;
                var _ = XT(R);
                return _.includes(h);
              })), !(E && h)) {
                k.next = 10;
                break;
              }
              return k.next = 8, new Promise(function(N) {
                setTimeout(N, E);
              });
            case 8:
              if (a.validatePromise === g) {
                k.next = 10;
                break;
              }
              return k.abrupt("return", []);
            case 10:
              return w = ype(u, c, S, l, y, x), w.catch(function(N) {
                return N;
              }).then(function() {
                var N = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ui;
                if (a.validatePromise === g) {
                  var R;
                  a.validatePromise = null;
                  var _ = [], O = [];
                  (R = N.forEach) === null || R === void 0 || R.call(N, function(T) {
                    var L = T.rule.warningOnly, M = T.errors, A = M === void 0 ? ui : M;
                    L ? O.push.apply(O, Ot(A)) : _.push.apply(_, Ot(A));
                  }), a.errors = _, a.warnings = O, a.triggerMetaEvent(), a.reRender();
                }
              }), k.abrupt("return", w);
            case 13:
            case "end":
              return k.stop();
          }
        }, v);
      })));
      return p || (a.validatePromise = g, a.dirty = !0, a.errors = ui, a.warnings = ui, a.triggerMetaEvent(), a.reRender()), g;
    }), pe($t(a), "isFieldValidating", function() {
      return !!a.validatePromise;
    }), pe($t(a), "isFieldTouched", function() {
      return a.touched;
    }), pe($t(a), "isFieldDirty", function() {
      if (a.dirty || a.props.initialValue !== void 0)
        return !0;
      var l = a.props.fieldContext, u = l.getInternalHooks(Gl), c = u.getInitialValue;
      return c(a.getNamePath()) !== void 0;
    }), pe($t(a), "getErrors", function() {
      return a.errors;
    }), pe($t(a), "getWarnings", function() {
      return a.warnings;
    }), pe($t(a), "isListField", function() {
      return a.props.isListField;
    }), pe($t(a), "isList", function() {
      return a.props.isList;
    }), pe($t(a), "isPreserve", function() {
      return a.props.preserve;
    }), pe($t(a), "getMeta", function() {
      a.prevValidating = a.isFieldValidating();
      var l = {
        touched: a.isFieldTouched(),
        validating: a.prevValidating,
        errors: a.errors,
        warnings: a.warnings,
        name: a.getNamePath(),
        validated: a.validatePromise === null
      };
      return l;
    }), pe($t(a), "getOnlyChild", function(l) {
      if (typeof l == "function") {
        var u = a.getMeta();
        return ke(ke({}, a.getOnlyChild(l(a.getControlled(), u, a.props.fieldContext))), {}, {
          isFunction: !0
        });
      }
      var c = Cm(l);
      return c.length !== 1 || !/* @__PURE__ */ de.isValidElement(c[0]) ? {
        child: c,
        isFunction: !1
      } : {
        child: c[0],
        isFunction: !1
      };
    }), pe($t(a), "getValue", function(l) {
      var u = a.props.fieldContext.getFieldsValue, c = a.getNamePath();
      return cs(l || u(!0), c);
    }), pe($t(a), "getControlled", function() {
      var l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, u = a.props, c = u.name, f = u.trigger, h = u.validateTrigger, d = u.getValueFromEvent, p = u.normalize, g = u.valuePropName, v = u.getValueProps, m = u.fieldContext, b = h !== void 0 ? h : m.validateTrigger, y = a.getNamePath(), x = m.getInternalHooks, E = m.getFieldsValue, S = x(Gl), w = S.dispatch, C = a.getValue(), k = v || function(T) {
        return pe({}, g, T);
      }, N = l[f], R = c !== void 0 ? k(C) : {};
      process.env.NODE_ENV !== "production" && R && Object.keys(R).forEach(function(T) {
        qr(typeof R[T] != "function", "It's not recommended to generate dynamic function prop by `getValueProps`. Please pass it to child component directly (prop: ".concat(T, ")"));
      });
      var _ = ke(ke({}, l), R);
      _[f] = function() {
        a.touched = !0, a.dirty = !0, a.triggerMetaEvent();
        for (var T, L = arguments.length, M = new Array(L), A = 0; A < L; A++)
          M[A] = arguments[A];
        d ? T = d.apply(void 0, M) : T = Epe.apply(void 0, [g].concat(M)), p && (T = p(T, C, E(!0))), T !== C && w({
          type: "updateValue",
          namePath: y,
          value: T
        }), N && N.apply(void 0, M);
      };
      var O = XT(b || []);
      return O.forEach(function(T) {
        var L = _[T];
        _[T] = function() {
          L && L.apply(void 0, arguments);
          var M = a.props.rules;
          M && M.length && w({
            type: "validateField",
            namePath: y,
            triggerName: T
          });
        };
      }), _;
    }), n.fieldContext) {
      var i = n.fieldContext.getInternalHooks, s = i(Gl), o = s.initEntityValue;
      o($t(a));
    }
    return a;
  }
  return Nn(r, [{
    key: "componentDidMount",
    value: function() {
      var a = this.props, i = a.shouldUpdate, s = a.fieldContext;
      if (this.mounted = !0, s) {
        var o = s.getInternalHooks, l = o(Gl), u = l.registerField;
        this.cancelRegisterFunc = u(this);
      }
      i === !0 && this.reRender();
    }
  }, {
    key: "componentWillUnmount",
    value: function() {
      this.cancelRegister(), this.triggerMetaEvent(!0), this.mounted = !1;
    }
  }, {
    key: "reRender",
    value: function() {
      this.mounted && this.forceUpdate();
    }
  }, {
    key: "render",
    value: function() {
      var a = this.state.resetCount, i = this.props.children, s = this.getOnlyChild(i), o = s.child, l = s.isFunction, u;
      return l ? u = o : /* @__PURE__ */ de.isValidElement(o) ? u = /* @__PURE__ */ de.cloneElement(o, this.getControlled(o.props)) : (qr(!o, "`children` of Field is not validate ReactElement."), u = o), /* @__PURE__ */ de.createElement(de.Fragment, {
        key: a
      }, u);
    }
  }]), r;
}(de.Component);
pe(dC, "contextType", af);
pe(dC, "defaultProps", {
  trigger: "onChange",
  valuePropName: "value"
});
function y$(t) {
  var e, r = t.name, n = vi(t, Tpe), a = de.useContext(af), i = de.useContext(Rm), s = r !== void 0 ? Jr(r) : void 0, o = (e = n.isListField) !== null && e !== void 0 ? e : !!i, l = "keep";
  return o || (l = "_".concat((s || []).join("_"))), process.env.NODE_ENV !== "production" && n.preserve === !1 && o && s.length <= 1 && qr(!1, "`preserve` should not apply on Form.List fields."), /* @__PURE__ */ de.createElement(dC, Ra({
    key: l,
    name: s,
    isListField: o
  }, n, {
    fieldContext: a
  }));
}
function Spe(t) {
  var e = t.name, r = t.initialValue, n = t.children, a = t.rules, i = t.validateTrigger, s = t.isListField, o = de.useContext(af), l = de.useContext(Rm), u = de.useRef({
    keys: [],
    id: 0
  }), c = u.current, f = de.useMemo(function() {
    var g = Jr(o.prefixName) || [];
    return [].concat(Ot(g), Ot(Jr(e)));
  }, [o.prefixName, e]), h = de.useMemo(function() {
    return ke(ke({}, o), {}, {
      prefixName: f
    });
  }, [o, f]), d = de.useMemo(function() {
    return {
      getKey: function(v) {
        var m = f.length, b = v[m];
        return [c.keys[b], v.slice(m + 1)];
      }
    };
  }, [f]);
  if (typeof n != "function")
    return qr(!1, "Form.List only accepts function as children."), null;
  var p = function(v, m, b) {
    var y = b.source;
    return y === "internal" ? !1 : v !== m;
  };
  return /* @__PURE__ */ de.createElement(Rm.Provider, {
    value: d
  }, /* @__PURE__ */ de.createElement(af.Provider, {
    value: h
  }, /* @__PURE__ */ de.createElement(y$, {
    name: [],
    shouldUpdate: p,
    rules: a,
    validateTrigger: i,
    initialValue: r,
    isList: !0,
    isListField: s ?? !!l
  }, function(g, v) {
    var m = g.value, b = m === void 0 ? [] : m, y = g.onChange, x = o.getFieldValue, E = function() {
      var k = x(f || []);
      return k || [];
    }, S = {
      add: function(k, N) {
        var R = E();
        N >= 0 && N <= R.length ? (c.keys = [].concat(Ot(c.keys.slice(0, N)), [c.id], Ot(c.keys.slice(N))), y([].concat(Ot(R.slice(0, N)), [k], Ot(R.slice(N))))) : (process.env.NODE_ENV !== "production" && (N < 0 || N > R.length) && qr(!1, "The second parameter of the add function should be a valid positive number."), c.keys = [].concat(Ot(c.keys), [c.id]), y([].concat(Ot(R), [k]))), c.id += 1;
      },
      remove: function(k) {
        var N = E(), R = new Set(Array.isArray(k) ? k : [k]);
        R.size <= 0 || (c.keys = c.keys.filter(function(_, O) {
          return !R.has(O);
        }), y(N.filter(function(_, O) {
          return !R.has(O);
        })));
      },
      move: function(k, N) {
        if (k !== N) {
          var R = E();
          k < 0 || k >= R.length || N < 0 || N >= R.length || (c.keys = B6(c.keys, k, N), y(B6(R, k, N)));
        }
      }
    }, w = b || [];
    return Array.isArray(w) || (w = [], process.env.NODE_ENV !== "production" && qr(!1, "Current value of '".concat(f.join(" > "), "' is not an array type."))), n(w.map(function(C, k) {
      var N = c.keys[k];
      return N === void 0 && (c.keys[k] = c.id, N = c.keys[k], c.id += 1), {
        name: k,
        key: N,
        isListField: !0
      };
    }), S, v);
  })));
}
function Cpe(t) {
  var e = !1, r = t.length, n = [];
  return t.length ? new Promise(function(a, i) {
    t.forEach(function(s, o) {
      s.catch(function(l) {
        return e = !0, l;
      }).then(function(l) {
        r -= 1, n[o] = l, !(r > 0) && (e && i(n), a(n));
      });
    });
  }) : Promise.resolve([]);
}
var b$ = "__@field_split__";
function Nx(t) {
  return t.map(function(e) {
    return "".concat(Tt(e), ":").concat(e);
  }).join(b$);
}
var Uu = /* @__PURE__ */ function() {
  function t() {
    Ln(this, t), pe(this, "kvs", /* @__PURE__ */ new Map());
  }
  return Nn(t, [{
    key: "set",
    value: function(r, n) {
      this.kvs.set(Nx(r), n);
    }
  }, {
    key: "get",
    value: function(r) {
      return this.kvs.get(Nx(r));
    }
  }, {
    key: "update",
    value: function(r, n) {
      var a = this.get(r), i = n(a);
      i ? this.set(r, i) : this.delete(r);
    }
  }, {
    key: "delete",
    value: function(r) {
      this.kvs.delete(Nx(r));
    }
    // Since we only use this in test, let simply realize this
  }, {
    key: "map",
    value: function(r) {
      return Ot(this.kvs.entries()).map(function(n) {
        var a = bt(n, 2), i = a[0], s = a[1], o = i.split(b$);
        return r({
          key: o.map(function(l) {
            var u = l.match(/^([^:]*):(.*)$/), c = bt(u, 3), f = c[1], h = c[2];
            return f === "number" ? Number(h) : h;
          }),
          value: s
        });
      });
    }
  }, {
    key: "toJSON",
    value: function() {
      var r = {};
      return this.map(function(n) {
        var a = n.key, i = n.value;
        return r[a.join(".")] = i, null;
      }), r;
    }
  }]), t;
}(), Ape = ["name"], kpe = /* @__PURE__ */ Nn(function t(e) {
  var r = this;
  Ln(this, t), pe(this, "formHooked", !1), pe(this, "forceRootUpdate", void 0), pe(this, "subscribable", !0), pe(this, "store", {}), pe(this, "fieldEntities", []), pe(this, "initialValues", {}), pe(this, "callbacks", {}), pe(this, "validateMessages", null), pe(this, "preserve", null), pe(this, "lastValidatePromise", null), pe(this, "getForm", function() {
    return {
      getFieldValue: r.getFieldValue,
      getFieldsValue: r.getFieldsValue,
      getFieldError: r.getFieldError,
      getFieldWarning: r.getFieldWarning,
      getFieldsError: r.getFieldsError,
      isFieldsTouched: r.isFieldsTouched,
      isFieldTouched: r.isFieldTouched,
      isFieldValidating: r.isFieldValidating,
      isFieldsValidating: r.isFieldsValidating,
      resetFields: r.resetFields,
      setFields: r.setFields,
      setFieldValue: r.setFieldValue,
      setFieldsValue: r.setFieldsValue,
      validateFields: r.validateFields,
      submit: r.submit,
      _init: !0,
      getInternalHooks: r.getInternalHooks
    };
  }), pe(this, "getInternalHooks", function(n) {
    return n === Gl ? (r.formHooked = !0, {
      dispatch: r.dispatch,
      initEntityValue: r.initEntityValue,
      registerField: r.registerField,
      useSubscribe: r.useSubscribe,
      setInitialValues: r.setInitialValues,
      destroyForm: r.destroyForm,
      setCallbacks: r.setCallbacks,
      setValidateMessages: r.setValidateMessages,
      getFields: r.getFields,
      setPreserve: r.setPreserve,
      getInitialValue: r.getInitialValue,
      registerWatch: r.registerWatch
    }) : (qr(!1, "`getInternalHooks` is internal usage. Should not call directly."), null);
  }), pe(this, "useSubscribe", function(n) {
    r.subscribable = n;
  }), pe(this, "prevWithoutPreserves", null), pe(this, "setInitialValues", function(n, a) {
    if (r.initialValues = n || {}, a) {
      var i, s = tc(n, r.store);
      (i = r.prevWithoutPreserves) === null || i === void 0 || i.map(function(o) {
        var l = o.key;
        s = Ri(s, l, cs(n, l));
      }), r.prevWithoutPreserves = null, r.updateStore(s);
    }
  }), pe(this, "destroyForm", function(n) {
    if (n)
      r.updateStore({});
    else {
      var a = new Uu();
      r.getFieldEntities(!0).forEach(function(i) {
        r.isMergedPreserve(i.isPreserve()) || a.set(i.getNamePath(), !0);
      }), r.prevWithoutPreserves = a;
    }
  }), pe(this, "getInitialValue", function(n) {
    var a = cs(r.initialValues, n);
    return n.length ? tc(a) : a;
  }), pe(this, "setCallbacks", function(n) {
    r.callbacks = n;
  }), pe(this, "setValidateMessages", function(n) {
    r.validateMessages = n;
  }), pe(this, "setPreserve", function(n) {
    r.preserve = n;
  }), pe(this, "watchList", []), pe(this, "registerWatch", function(n) {
    return r.watchList.push(n), function() {
      r.watchList = r.watchList.filter(function(a) {
        return a !== n;
      });
    };
  }), pe(this, "notifyWatch", function() {
    var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    if (r.watchList.length) {
      var a = r.getFieldsValue(), i = r.getFieldsValue(!0);
      r.watchList.forEach(function(s) {
        s(a, i, n);
      });
    }
  }), pe(this, "timeoutId", null), pe(this, "warningUnhooked", function() {
    process.env.NODE_ENV !== "production" && !r.timeoutId && typeof window < "u" && (r.timeoutId = setTimeout(function() {
      r.timeoutId = null, r.formHooked || qr(!1, "Instance created by `useForm` is not connected to any Form element. Forget to pass `form` prop?");
    }));
  }), pe(this, "updateStore", function(n) {
    r.store = n;
  }), pe(this, "getFieldEntities", function() {
    var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
    return n ? r.fieldEntities.filter(function(a) {
      return a.getNamePath().length;
    }) : r.fieldEntities;
  }), pe(this, "getFieldsMap", function() {
    var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, a = new Uu();
    return r.getFieldEntities(n).forEach(function(i) {
      var s = i.getNamePath();
      a.set(s, i);
    }), a;
  }), pe(this, "getFieldEntitiesForNamePathList", function(n) {
    if (!n)
      return r.getFieldEntities(!0);
    var a = r.getFieldsMap(!0);
    return n.map(function(i) {
      var s = Jr(i);
      return a.get(s) || {
        INVALIDATE_NAME_PATH: Jr(i)
      };
    });
  }), pe(this, "getFieldsValue", function(n, a) {
    r.warningUnhooked();
    var i, s, o;
    if (n === !0 || Array.isArray(n) ? (i = n, s = a) : n && Tt(n) === "object" && (o = n.strict, s = n.filter), i === !0 && !s)
      return r.store;
    var l = r.getFieldEntitiesForNamePathList(Array.isArray(i) ? i : null), u = [];
    return l.forEach(function(c) {
      var f, h, d = "INVALIDATE_NAME_PATH" in c ? c.INVALIDATE_NAME_PATH : c.getNamePath();
      if (o) {
        var p, g;
        if ((p = (g = c).isList) !== null && p !== void 0 && p.call(g))
          return;
      } else if (!i && (f = (h = c).isListField) !== null && f !== void 0 && f.call(h))
        return;
      if (!s)
        u.push(d);
      else {
        var v = "getMeta" in c ? c.getMeta() : null;
        s(v) && u.push(d);
      }
    }), F6(r.store, u.map(Jr));
  }), pe(this, "getFieldValue", function(n) {
    r.warningUnhooked();
    var a = Jr(n);
    return cs(r.store, a);
  }), pe(this, "getFieldsError", function(n) {
    r.warningUnhooked();
    var a = r.getFieldEntitiesForNamePathList(n);
    return a.map(function(i, s) {
      return i && !("INVALIDATE_NAME_PATH" in i) ? {
        name: i.getNamePath(),
        errors: i.getErrors(),
        warnings: i.getWarnings()
      } : {
        name: Jr(n[s]),
        errors: [],
        warnings: []
      };
    });
  }), pe(this, "getFieldError", function(n) {
    r.warningUnhooked();
    var a = Jr(n), i = r.getFieldsError([a])[0];
    return i.errors;
  }), pe(this, "getFieldWarning", function(n) {
    r.warningUnhooked();
    var a = Jr(n), i = r.getFieldsError([a])[0];
    return i.warnings;
  }), pe(this, "isFieldsTouched", function() {
    r.warningUnhooked();
    for (var n = arguments.length, a = new Array(n), i = 0; i < n; i++)
      a[i] = arguments[i];
    var s = a[0], o = a[1], l, u = !1;
    a.length === 0 ? l = null : a.length === 1 ? Array.isArray(s) ? (l = s.map(Jr), u = !1) : (l = null, u = s) : (l = s.map(Jr), u = o);
    var c = r.getFieldEntities(!0), f = function(v) {
      return v.isFieldTouched();
    };
    if (!l)
      return u ? c.every(function(g) {
        return f(g) || g.isList();
      }) : c.some(f);
    var h = new Uu();
    l.forEach(function(g) {
      h.set(g, []);
    }), c.forEach(function(g) {
      var v = g.getNamePath();
      l.forEach(function(m) {
        m.every(function(b, y) {
          return v[y] === b;
        }) && h.update(m, function(b) {
          return [].concat(Ot(b), [g]);
        });
      });
    });
    var d = function(v) {
      return v.some(f);
    }, p = h.map(function(g) {
      var v = g.value;
      return v;
    });
    return u ? p.every(d) : p.some(d);
  }), pe(this, "isFieldTouched", function(n) {
    return r.warningUnhooked(), r.isFieldsTouched([n]);
  }), pe(this, "isFieldsValidating", function(n) {
    r.warningUnhooked();
    var a = r.getFieldEntities();
    if (!n)
      return a.some(function(s) {
        return s.isFieldValidating();
      });
    var i = n.map(Jr);
    return a.some(function(s) {
      var o = s.getNamePath();
      return bc(i, o) && s.isFieldValidating();
    });
  }), pe(this, "isFieldValidating", function(n) {
    return r.warningUnhooked(), r.isFieldsValidating([n]);
  }), pe(this, "resetWithFieldInitialValue", function() {
    var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, a = new Uu(), i = r.getFieldEntities(!0);
    i.forEach(function(l) {
      var u = l.props.initialValue, c = l.getNamePath();
      if (u !== void 0) {
        var f = a.get(c) || /* @__PURE__ */ new Set();
        f.add({
          entity: l,
          value: u
        }), a.set(c, f);
      }
    });
    var s = function(u) {
      u.forEach(function(c) {
        var f = c.props.initialValue;
        if (f !== void 0) {
          var h = c.getNamePath(), d = r.getInitialValue(h);
          if (d !== void 0)
            qr(!1, "Form already set 'initialValues' with path '".concat(h.join("."), "'. Field can not overwrite it."));
          else {
            var p = a.get(h);
            if (p && p.size > 1)
              qr(!1, "Multiple Field with path '".concat(h.join("."), "' set 'initialValue'. Can not decide which one to pick."));
            else if (p) {
              var g = r.getFieldValue(h), v = c.isListField();
              !v && (!n.skipExist || g === void 0) && r.updateStore(Ri(r.store, h, Ot(p)[0].value));
            }
          }
        }
      });
    }, o;
    n.entities ? o = n.entities : n.namePathList ? (o = [], n.namePathList.forEach(function(l) {
      var u = a.get(l);
      if (u) {
        var c;
        (c = o).push.apply(c, Ot(Ot(u).map(function(f) {
          return f.entity;
        })));
      }
    })) : o = i, s(o);
  }), pe(this, "resetFields", function(n) {
    r.warningUnhooked();
    var a = r.store;
    if (!n) {
      r.updateStore(tc(r.initialValues)), r.resetWithFieldInitialValue(), r.notifyObservers(a, null, {
        type: "reset"
      }), r.notifyWatch();
      return;
    }
    var i = n.map(Jr);
    i.forEach(function(s) {
      var o = r.getInitialValue(s);
      r.updateStore(Ri(r.store, s, o));
    }), r.resetWithFieldInitialValue({
      namePathList: i
    }), r.notifyObservers(a, i, {
      type: "reset"
    }), r.notifyWatch(i);
  }), pe(this, "setFields", function(n) {
    r.warningUnhooked();
    var a = r.store, i = [];
    n.forEach(function(s) {
      var o = s.name, l = vi(s, Ape), u = Jr(o);
      i.push(u), "value" in l && r.updateStore(Ri(r.store, u, l.value)), r.notifyObservers(a, [u], {
        type: "setField",
        data: s
      });
    }), r.notifyWatch(i);
  }), pe(this, "getFields", function() {
    var n = r.getFieldEntities(!0), a = n.map(function(i) {
      var s = i.getNamePath(), o = i.getMeta(), l = ke(ke({}, o), {}, {
        name: s,
        value: r.getFieldValue(s)
      });
      return Object.defineProperty(l, "originRCField", {
        value: !0
      }), l;
    });
    return a;
  }), pe(this, "initEntityValue", function(n) {
    var a = n.props.initialValue;
    if (a !== void 0) {
      var i = n.getNamePath(), s = cs(r.store, i);
      s === void 0 && r.updateStore(Ri(r.store, i, a));
    }
  }), pe(this, "isMergedPreserve", function(n) {
    var a = n !== void 0 ? n : r.preserve;
    return a ?? !0;
  }), pe(this, "registerField", function(n) {
    r.fieldEntities.push(n);
    var a = n.getNamePath();
    if (r.notifyWatch([a]), n.props.initialValue !== void 0) {
      var i = r.store;
      r.resetWithFieldInitialValue({
        entities: [n],
        skipExist: !0
      }), r.notifyObservers(i, [n.getNamePath()], {
        type: "valueUpdate",
        source: "internal"
      });
    }
    return function(s, o) {
      var l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
      if (r.fieldEntities = r.fieldEntities.filter(function(f) {
        return f !== n;
      }), !r.isMergedPreserve(o) && (!s || l.length > 1)) {
        var u = s ? void 0 : r.getInitialValue(a);
        if (a.length && r.getFieldValue(a) !== u && r.fieldEntities.every(function(f) {
          return (
            // Only reset when no namePath exist
            !m$(f.getNamePath(), a)
          );
        })) {
          var c = r.store;
          r.updateStore(Ri(c, a, u, !0)), r.notifyObservers(c, [a], {
            type: "remove"
          }), r.triggerDependenciesUpdate(c, a);
        }
      }
      r.notifyWatch([a]);
    };
  }), pe(this, "dispatch", function(n) {
    switch (n.type) {
      case "updateValue": {
        var a = n.namePath, i = n.value;
        r.updateValue(a, i);
        break;
      }
      case "validateField": {
        var s = n.namePath, o = n.triggerName;
        r.validateFields([s], {
          triggerName: o
        });
        break;
      }
    }
  }), pe(this, "notifyObservers", function(n, a, i) {
    if (r.subscribable) {
      var s = ke(ke({}, i), {}, {
        store: r.getFieldsValue(!0)
      });
      r.getFieldEntities().forEach(function(o) {
        var l = o.onStoreChange;
        l(n, a, s);
      });
    } else
      r.forceRootUpdate();
  }), pe(this, "triggerDependenciesUpdate", function(n, a) {
    var i = r.getDependencyChildrenFields(a);
    return i.length && r.validateFields(i), r.notifyObservers(n, i, {
      type: "dependenciesUpdate",
      relatedFields: [a].concat(Ot(i))
    }), i;
  }), pe(this, "updateValue", function(n, a) {
    var i = Jr(n), s = r.store;
    r.updateStore(Ri(r.store, i, a)), r.notifyObservers(s, [i], {
      type: "valueUpdate",
      source: "internal"
    }), r.notifyWatch([i]);
    var o = r.triggerDependenciesUpdate(s, i), l = r.callbacks.onValuesChange;
    if (l) {
      var u = F6(r.store, [i]);
      l(u, r.getFieldsValue());
    }
    r.triggerOnFieldsChange([i].concat(Ot(o)));
  }), pe(this, "setFieldsValue", function(n) {
    r.warningUnhooked();
    var a = r.store;
    if (n) {
      var i = tc(r.store, n);
      r.updateStore(i);
    }
    r.notifyObservers(a, null, {
      type: "valueUpdate",
      source: "external"
    }), r.notifyWatch();
  }), pe(this, "setFieldValue", function(n, a) {
    r.setFields([{
      name: n,
      value: a,
      errors: [],
      warnings: []
    }]);
  }), pe(this, "getDependencyChildrenFields", function(n) {
    var a = /* @__PURE__ */ new Set(), i = [], s = new Uu();
    r.getFieldEntities().forEach(function(l) {
      var u = l.props.dependencies;
      (u || []).forEach(function(c) {
        var f = Jr(c);
        s.update(f, function() {
          var h = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : /* @__PURE__ */ new Set();
          return h.add(l), h;
        });
      });
    });
    var o = function l(u) {
      var c = s.get(u) || /* @__PURE__ */ new Set();
      c.forEach(function(f) {
        if (!a.has(f)) {
          a.add(f);
          var h = f.getNamePath();
          f.isFieldDirty() && h.length && (i.push(h), l(h));
        }
      });
    };
    return o(n), i;
  }), pe(this, "triggerOnFieldsChange", function(n, a) {
    var i = r.callbacks.onFieldsChange;
    if (i) {
      var s = r.getFields();
      if (a) {
        var o = new Uu();
        a.forEach(function(u) {
          var c = u.name, f = u.errors;
          o.set(c, f);
        }), s.forEach(function(u) {
          u.errors = o.get(u.name) || u.errors;
        });
      }
      var l = s.filter(function(u) {
        var c = u.name;
        return bc(n, c);
      });
      l.length && i(l, s);
    }
  }), pe(this, "validateFields", function(n, a) {
    r.warningUnhooked();
    var i, s;
    Array.isArray(n) || typeof n == "string" || typeof a == "string" ? (i = n, s = a) : s = n;
    var o = !!i, l = o ? i.map(Jr) : [], u = [], c = String(Date.now()), f = /* @__PURE__ */ new Set(), h = s || {}, d = h.recursive, p = h.dirty;
    r.getFieldEntities(!0).forEach(function(b) {
      if (o || l.push(b.getNamePath()), !(!b.props.rules || !b.props.rules.length) && !(p && !b.isFieldDirty())) {
        var y = b.getNamePath();
        if (f.add(y.join(c)), !o || bc(l, y, d)) {
          var x = b.validateRules(ke({
            validateMessages: ke(ke({}, v$), r.validateMessages)
          }, s));
          u.push(x.then(function() {
            return {
              name: y,
              errors: [],
              warnings: []
            };
          }).catch(function(E) {
            var S, w = [], C = [];
            return (S = E.forEach) === null || S === void 0 || S.call(E, function(k) {
              var N = k.rule.warningOnly, R = k.errors;
              N ? C.push.apply(C, Ot(R)) : w.push.apply(w, Ot(R));
            }), w.length ? Promise.reject({
              name: y,
              errors: w,
              warnings: C
            }) : {
              name: y,
              errors: w,
              warnings: C
            };
          }));
        }
      }
    });
    var g = Cpe(u);
    r.lastValidatePromise = g, g.catch(function(b) {
      return b;
    }).then(function(b) {
      var y = b.map(function(x) {
        var E = x.name;
        return E;
      });
      r.notifyObservers(r.store, y, {
        type: "validateFinish"
      }), r.triggerOnFieldsChange(y, b);
    });
    var v = g.then(function() {
      return r.lastValidatePromise === g ? Promise.resolve(r.getFieldsValue(l)) : Promise.reject([]);
    }).catch(function(b) {
      var y = b.filter(function(x) {
        return x && x.errors.length;
      });
      return Promise.reject({
        values: r.getFieldsValue(l),
        errorFields: y,
        outOfDate: r.lastValidatePromise !== g
      });
    });
    v.catch(function(b) {
      return b;
    });
    var m = l.filter(function(b) {
      return f.has(b.join(c));
    });
    return r.triggerOnFieldsChange(m), v;
  }), pe(this, "submit", function() {
    r.warningUnhooked(), r.validateFields().then(function(n) {
      var a = r.callbacks.onFinish;
      if (a)
        try {
          a(n);
        } catch (i) {
          console.error(i);
        }
    }).catch(function(n) {
      var a = r.callbacks.onFinishFailed;
      a && a(n);
    });
  }), this.forceRootUpdate = e;
});
function x$(t) {
  var e = de.useRef(), r = de.useState({}), n = bt(r, 2), a = n[1];
  if (!e.current)
    if (t)
      e.current = t;
    else {
      var i = function() {
        a({});
      }, s = new kpe(i);
      e.current = s.getForm();
    }
  return [e.current];
}
var a4 = /* @__PURE__ */ de.createContext({
  triggerFormChange: function() {
  },
  triggerFormFinish: function() {
  },
  registerForm: function() {
  },
  unregisterForm: function() {
  }
}), Rpe = function(e) {
  var r = e.validateMessages, n = e.onFormChange, a = e.onFormFinish, i = e.children, s = de.useContext(a4), o = de.useRef({});
  return /* @__PURE__ */ de.createElement(a4.Provider, {
    value: ke(ke({}, s), {}, {
      validateMessages: ke(ke({}, s.validateMessages), r),
      // =========================================================
      // =                  Global Form Control                  =
      // =========================================================
      triggerFormChange: function(u, c) {
        n && n(u, {
          changedFields: c,
          forms: o.current
        }), s.triggerFormChange(u, c);
      },
      triggerFormFinish: function(u, c) {
        a && a(u, {
          values: c,
          forms: o.current
        }), s.triggerFormFinish(u, c);
      },
      registerForm: function(u, c) {
        u && (o.current = ke(ke({}, o.current), {}, pe({}, u, c))), s.registerForm(u, c);
      },
      unregisterForm: function(u) {
        var c = ke({}, o.current);
        delete c[u], o.current = c, s.unregisterForm(u);
      }
    })
  }, i);
}, Mpe = ["name", "initialValues", "fields", "form", "preserve", "children", "component", "validateMessages", "validateTrigger", "onValuesChange", "onFieldsChange", "onFinish", "onFinishFailed", "clearOnDestroy"], _pe = function(e, r) {
  var n = e.name, a = e.initialValues, i = e.fields, s = e.form, o = e.preserve, l = e.children, u = e.component, c = u === void 0 ? "form" : u, f = e.validateMessages, h = e.validateTrigger, d = h === void 0 ? "onChange" : h, p = e.onValuesChange, g = e.onFieldsChange, v = e.onFinish, m = e.onFinishFailed, b = e.clearOnDestroy, y = vi(e, Mpe), x = de.useRef(null), E = de.useContext(a4), S = x$(s), w = bt(S, 1), C = w[0], k = C.getInternalHooks(Gl), N = k.useSubscribe, R = k.setInitialValues, _ = k.setCallbacks, O = k.setValidateMessages, T = k.setPreserve, L = k.destroyForm;
  de.useImperativeHandle(r, function() {
    return ke(ke({}, C), {}, {
      nativeElement: x.current
    });
  }), de.useEffect(function() {
    return E.registerForm(n, C), function() {
      E.unregisterForm(n);
    };
  }, [E, C, n]), O(ke(ke({}, E.validateMessages), f)), _({
    onValuesChange: p,
    onFieldsChange: function(K) {
      if (E.triggerFormChange(n, K), g) {
        for (var j = arguments.length, Z = new Array(j > 1 ? j - 1 : 0), te = 1; te < j; te++)
          Z[te - 1] = arguments[te];
        g.apply(void 0, [K].concat(Z));
      }
    },
    onFinish: function(K) {
      E.triggerFormFinish(n, K), v && v(K);
    },
    onFinishFailed: m
  }), T(o);
  var M = de.useRef(null);
  R(a, !M.current), M.current || (M.current = !0), de.useEffect(
    function() {
      return function() {
        return L(b);
      };
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  var A, I = typeof l == "function";
  if (I) {
    var D = C.getFieldsValue(!0);
    A = l(D, C);
  } else
    A = l;
  N(!I);
  var F = de.useRef();
  de.useEffect(function() {
    wpe(F.current || [], i || []) || C.setFields(i || []), F.current = i;
  }, [i, C]);
  var B = de.useMemo(function() {
    return ke(ke({}, C), {}, {
      validateTrigger: d
    });
  }, [C, d]), G = /* @__PURE__ */ de.createElement(Rm.Provider, {
    value: null
  }, /* @__PURE__ */ de.createElement(af.Provider, {
    value: B
  }, A));
  return c === !1 ? G : /* @__PURE__ */ de.createElement(c, Ra({}, y, {
    ref: x,
    onSubmit: function(K) {
      K.preventDefault(), K.stopPropagation(), C.submit();
    },
    onReset: function(K) {
      var j;
      K.preventDefault(), C.resetFields(), (j = y.onReset) === null || j === void 0 || j.call(y, K);
    }
  }), G);
};
function z6(t) {
  try {
    return JSON.stringify(t);
  } catch {
    return Math.random();
  }
}
var Lpe = process.env.NODE_ENV !== "production" ? function(t) {
  var e = t.join("__RC_FIELD_FORM_SPLIT__"), r = tn(e);
  qr(r.current === e, "`useWatch` is not support dynamic `namePath`. Please provide static instead.");
} : function() {
};
function Npe() {
  for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)
    e[r] = arguments[r];
  var n = e[0], a = e[1], i = a === void 0 ? {} : a, s = z0e(i) ? {
    form: i
  } : i, o = s.form, l = dE(), u = bt(l, 2), c = u[0], f = u[1], h = V8(function() {
    return z6(c);
  }, [c]), d = tn(h);
  d.current = h;
  var p = qi(af), g = o || p, v = g && g._init;
  process.env.NODE_ENV !== "production" && qr(e.length === 2 ? o ? v : !0 : v, "useWatch requires a form instance since it can not auto detect from context.");
  var m = Jr(n), b = tn(m);
  return b.current = m, Lpe(m), Fi(
    function() {
      if (v) {
        var y = g.getFieldsValue, x = g.getInternalHooks, E = x(Gl), S = E.registerWatch, w = function(R, _) {
          var O = s.preserve ? _ : R;
          return typeof n == "function" ? n(O) : cs(O, b.current);
        }, C = S(function(N, R) {
          var _ = w(N, R), O = z6(_);
          d.current !== O && (d.current = O, f(_));
        }), k = w(y(), y(!0));
        return c !== k && f(k), C;
      }
    },
    // We do not need re-register since namePath content is the same
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [v]
  ), c;
}
var Ope = /* @__PURE__ */ de.forwardRef(_pe), J0 = Ope;
J0.FormProvider = Rpe;
J0.Field = y$;
J0.List = Spe;
J0.useForm = x$;
J0.useWatch = Npe;
const t0 = /* @__PURE__ */ de.createContext({});
process.env.NODE_ENV !== "production" && (t0.displayName = "FormItemInputContext");
const Ipe = (t) => {
  let {
    children: e,
    status: r,
    override: n
  } = t;
  const a = de.useContext(t0), i = de.useMemo(() => {
    const s = Object.assign({}, a);
    return n && delete s.isFormItemInput, r && (delete s.status, delete s.hasFeedback, delete s.feedbackIcon), s;
  }, [r, n, a]);
  return /* @__PURE__ */ de.createElement(t0.Provider, {
    value: i
  }, e);
}, Ppe = /* @__PURE__ */ de.createContext(void 0), Dpe = /* @__PURE__ */ AS(void 0);
var $pe = {
  yearFormat: "YYYY",
  dayFormat: "D",
  cellMeridiemFormat: "A",
  monthBeforeYear: !0
}, Fpe = ke(ke({}, $pe), {}, {
  locale: "en_US",
  today: "Today",
  now: "Now",
  backToToday: "Back to today",
  ok: "OK",
  clear: "Clear",
  week: "Week",
  month: "Month",
  year: "Year",
  timeSelect: "select time",
  dateSelect: "select date",
  weekSelect: "Choose a week",
  monthSelect: "Choose a month",
  yearSelect: "Choose a year",
  decadeSelect: "Choose a decade",
  dateFormat: "M/D/YYYY",
  dateTimeFormat: "M/D/YYYY HH:mm:ss",
  previousMonth: "Previous month (PageUp)",
  nextMonth: "Next month (PageDown)",
  previousYear: "Last year (Control + left)",
  nextYear: "Next year (Control + right)",
  previousDecade: "Last decade",
  nextDecade: "Next decade",
  previousCentury: "Last century",
  nextCentury: "Next century"
});
const Bpe = {
  placeholder: "Select time",
  rangePlaceholder: ["Start time", "End time"]
};
Object.assign({
  placeholder: "Select date",
  yearPlaceholder: "Select year",
  quarterPlaceholder: "Select quarter",
  monthPlaceholder: "Select month",
  weekPlaceholder: "Select week",
  rangePlaceholder: ["Start date", "End date"],
  rangeYearPlaceholder: ["Start year", "End year"],
  rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
  rangeMonthPlaceholder: ["Start month", "End month"],
  rangeWeekPlaceholder: ["Start week", "End week"]
}, Fpe), Object.assign({}, Bpe);
const ja = "${label} is not a valid ${type}", O1 = {
  Modal: {
    okText: "OK",
    cancelText: "Cancel",
    justOkText: "OK"
  },
  Form: {
    optional: "(optional)",
    defaultValidateMessages: {
      default: "Field validation error for ${label}",
      required: "Please enter ${label}",
      enum: "${label} must be one of [${enum}]",
      whitespace: "${label} cannot be a blank character",
      date: {
        format: "${label} date format is invalid",
        parse: "${label} cannot be converted to a date",
        invalid: "${label} is an invalid date"
      },
      types: {
        string: ja,
        method: ja,
        array: ja,
        object: ja,
        number: ja,
        date: ja,
        boolean: ja,
        integer: ja,
        float: ja,
        regexp: ja,
        email: ja,
        url: ja,
        hex: ja
      },
      string: {
        len: "${label} must be ${len} characters",
        min: "${label} must be at least ${min} characters",
        max: "${label} must be up to ${max} characters",
        range: "${label} must be between ${min}-${max} characters"
      },
      number: {
        len: "${label} must be equal to ${len}",
        min: "${label} must be minimum ${min}",
        max: "${label} must be maximum ${max}",
        range: "${label} must be between ${min}-${max}"
      },
      array: {
        len: "Must be ${len} ${label}",
        min: "At least ${min} ${label}",
        max: "At most ${max} ${label}",
        range: "The amount of ${label} must be between ${min}-${max}"
      },
      pattern: {
        mismatch: "${label} does not match the pattern ${pattern}"
      }
    }
  }
};
Object.assign({}, O1.Modal);
let fv = [];
const G6 = () => fv.reduce((t, e) => Object.assign(Object.assign({}, t), e), O1.Modal);
function zpe(t) {
  if (t) {
    const e = Object.assign({}, t);
    return fv.push(e), G6(), () => {
      fv = fv.filter((r) => r !== e), G6();
    };
  }
  Object.assign({}, O1.Modal);
}
const w$ = /* @__PURE__ */ AS(void 0), E$ = "internalMark", T$ = (t) => {
  const {
    locale: e = {},
    children: r,
    _ANT_MARK__: n
  } = t;
  if (process.env.NODE_ENV !== "production") {
    const i = ru("LocaleProvider");
    process.env.NODE_ENV !== "production" && i(n === E$, "deprecated", "`LocaleProvider` is deprecated. Please use `locale` with `ConfigProvider` instead: http://u.ant.design/locale");
  }
  de.useEffect(() => zpe(e == null ? void 0 : e.Modal), [e]);
  const a = de.useMemo(() => Object.assign(Object.assign({}, e), {
    exist: !0
  }), [e]);
  return /* @__PURE__ */ de.createElement(w$.Provider, {
    value: a
  }, r);
};
process.env.NODE_ENV !== "production" && (T$.displayName = "LocaleProvider");
const Gpe = `-ant-${Date.now()}-${Math.random()}`;
function Upe(t, e) {
  const r = {}, n = (s, o) => {
    let l = s.clone();
    return l = (o == null ? void 0 : o(l)) || l, l.toRgbString();
  }, a = (s, o) => {
    const l = new rn(s), u = Hd(l.toRgbString());
    r[`${o}-color`] = n(l), r[`${o}-color-disabled`] = u[1], r[`${o}-color-hover`] = u[4], r[`${o}-color-active`] = u[6], r[`${o}-color-outline`] = l.clone().setA(0.2).toRgbString(), r[`${o}-color-deprecated-bg`] = u[0], r[`${o}-color-deprecated-border`] = u[2];
  };
  if (e.primaryColor) {
    a(e.primaryColor, "primary");
    const s = new rn(e.primaryColor), o = Hd(s.toRgbString());
    o.forEach((u, c) => {
      r[`primary-${c + 1}`] = u;
    }), r["primary-color-deprecated-l-35"] = n(s, (u) => u.lighten(35)), r["primary-color-deprecated-l-20"] = n(s, (u) => u.lighten(20)), r["primary-color-deprecated-t-20"] = n(s, (u) => u.tint(20)), r["primary-color-deprecated-t-50"] = n(s, (u) => u.tint(50)), r["primary-color-deprecated-f-12"] = n(s, (u) => u.setA(u.a * 0.12));
    const l = new rn(o[0]);
    r["primary-color-active-deprecated-f-30"] = n(l, (u) => u.setA(u.a * 0.3)), r["primary-color-active-deprecated-d-02"] = n(l, (u) => u.darken(2));
  }
  return e.successColor && a(e.successColor, "success"), e.warningColor && a(e.warningColor, "warning"), e.errorColor && a(e.errorColor, "error"), e.infoColor && a(e.infoColor, "info"), `
  :root {
    ${Object.keys(r).map((s) => `--${t}-${s}: ${r[s]};`).join(`
`)}
  }
  `.trim();
}
function Hpe(t, e) {
  const r = Upe(t, e);
  po() ? ql(r, `${Gpe}-dynamic-theme`) : process.env.NODE_ENV !== "production" && N1(!1, "ConfigProvider", "SSR do not support dynamic theme with css variables.");
}
function Vpe() {
  const t = qi(e0), e = qi(nf);
  return {
    componentDisabled: t,
    componentSize: e
  };
}
const qpe = Object.assign({}, de), {
  useId: U6
} = qpe, Wpe = () => "", jpe = typeof U6 > "u" ? Wpe : U6;
function Ype(t, e, r) {
  var n, a;
  const i = ru("ConfigProvider"), s = t || {}, o = s.inherit === !1 || !e ? Object.assign(Object.assign({}, eT), {
    hashed: (n = e == null ? void 0 : e.hashed) !== null && n !== void 0 ? n : eT.hashed,
    cssVar: e == null ? void 0 : e.cssVar
  }) : e, l = jpe();
  if (process.env.NODE_ENV !== "production") {
    const u = s.cssVar || o.cssVar, c = !!(typeof s.cssVar == "object" && (!((a = s.cssVar) === null || a === void 0) && a.key) || l);
    process.env.NODE_ENV !== "production" && i(!u || c, "breaking", "Missing key in `cssVar` config. Please upgrade to React 18 or set `cssVar.key` manually in each ConfigProvider inside `cssVar` enabled ConfigProvider.");
  }
  return IS(() => {
    var u, c;
    if (!t)
      return e;
    const f = Object.assign({}, o.components);
    Object.keys(t.components || {}).forEach((p) => {
      f[p] = Object.assign(Object.assign({}, f[p]), t.components[p]);
    });
    const h = `css-var-${l.replace(/:/g, "")}`, d = ((u = s.cssVar) !== null && u !== void 0 ? u : o.cssVar) && Object.assign(Object.assign(Object.assign({
      prefix: r == null ? void 0 : r.prefixCls
    }, typeof o.cssVar == "object" ? o.cssVar : {}), typeof s.cssVar == "object" ? s.cssVar : {}), {
      key: typeof s.cssVar == "object" && ((c = s.cssVar) === null || c === void 0 ? void 0 : c.key) || h
    });
    return Object.assign(Object.assign(Object.assign({}, o), s), {
      token: Object.assign(Object.assign({}, o.token), s.token),
      components: f,
      cssVar: d
    });
  }, [s, o], (u, c) => u.some((f, h) => {
    const d = c[h];
    return !DE(f, d, !0);
  }));
}
function Xpe(t) {
  const {
    children: e
  } = t, [, r] = n1(), {
    motion: n
  } = r, a = de.useRef(!1);
  return a.current = a.current || n === !1, a.current ? /* @__PURE__ */ de.createElement(AX, {
    motion: n
  }, e) : e;
}
const S$ = /* @__PURE__ */ de.memo((t) => {
  let {
    dropdownMatchSelectWidth: e
  } = t;
  return ru("ConfigProvider").deprecated(e === void 0, "dropdownMatchSelectWidth", "popupMatchSelectWidth"), null;
});
process.env.NODE_ENV !== "production" && (S$.displayName = "PropWarning");
const Kpe = process.env.NODE_ENV !== "production" ? S$ : () => null;
var Zpe = function(t, e) {
  var r = {};
  for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function") for (var a = 0, n = Object.getOwnPropertySymbols(t); a < n.length; a++)
    e.indexOf(n[a]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[a]) && (r[n[a]] = t[n[a]]);
  return r;
};
let i4 = !1;
process.env.NODE_ENV;
const Qpe = ["getTargetContainer", "getPopupContainer", "renderEmpty", "input", "pagination", "form", "select", "button"];
let C$;
function Jpe() {
  return C$ || jT;
}
function ege(t) {
  return Object.keys(t).some((e) => e.endsWith("Color"));
}
const tge = (t) => {
  const {
    prefixCls: e,
    iconPrefixCls: r,
    theme: n,
    holderRender: a
  } = t;
  e !== void 0 && (C$ = e), n && ege(n) && (process.env.NODE_ENV !== "production" && N1(!1, "ConfigProvider", "`config` of css variable theme is not work in v5. Please use new `theme` config instead."), Hpe(Jpe(), n));
}, rge = (t) => {
  const {
    children: e,
    csp: r,
    autoInsertSpaceInButton: n,
    alert: a,
    anchor: i,
    form: s,
    locale: o,
    componentSize: l,
    direction: u,
    space: c,
    splitter: f,
    virtual: h,
    dropdownMatchSelectWidth: d,
    popupMatchSelectWidth: p,
    popupOverflow: g,
    legacyLocale: v,
    parentContext: m,
    iconPrefixCls: b,
    theme: y,
    componentDisabled: x,
    segmented: E,
    statistic: S,
    spin: w,
    calendar: C,
    carousel: k,
    cascader: N,
    collapse: R,
    typography: _,
    checkbox: O,
    descriptions: T,
    divider: L,
    drawer: M,
    skeleton: A,
    steps: I,
    image: D,
    layout: F,
    list: B,
    mentions: G,
    modal: H,
    progress: K,
    result: j,
    slider: Z,
    breadcrumb: te,
    menu: ne,
    pagination: V,
    input: q,
    textArea: X,
    empty: W,
    badge: ue,
    radio: J,
    rate: Ce,
    switch: Ee,
    transfer: Te,
    avatar: me,
    message: we,
    tag: Ae,
    table: Ne,
    card: Ie,
    tabs: Me,
    timeline: _e,
    timePicker: Be,
    upload: st,
    notification: ct,
    tree: dt,
    colorPicker: ft,
    datePicker: rt,
    rangePicker: je,
    flex: ae,
    wave: z,
    dropdown: Q,
    warning: se,
    tour: oe,
    tooltip: he,
    popover: Le,
    popconfirm: ge,
    floatButtonGroup: Se,
    variant: xe,
    inputNumber: $e,
    treeSelect: Ze
  } = t, We = de.useCallback((yt, ee) => {
    const {
      prefixCls: Re
    } = t;
    if (ee)
      return ee;
    const Ge = Re || m.getPrefixCls("");
    return yt ? `${Ge}-${yt}` : Ge;
  }, [m.getPrefixCls, t.prefixCls]), He = b || m.iconPrefixCls || fC, Pe = r || m.csp;
  F0e(He, Pe);
  const De = Ype(y, m.theme, {
    prefixCls: We("")
  });
  process.env.NODE_ENV !== "production" && (i4 = i4 || !!De);
  const mt = {
    csp: Pe,
    autoInsertSpaceInButton: n,
    alert: a,
    anchor: i,
    locale: o || v,
    direction: u,
    space: c,
    splitter: f,
    virtual: h,
    popupMatchSelectWidth: p ?? d,
    popupOverflow: g,
    getPrefixCls: We,
    iconPrefixCls: He,
    theme: De,
    segmented: E,
    statistic: S,
    spin: w,
    calendar: C,
    carousel: k,
    cascader: N,
    collapse: R,
    typography: _,
    checkbox: O,
    descriptions: T,
    divider: L,
    drawer: M,
    skeleton: A,
    steps: I,
    image: D,
    input: q,
    textArea: X,
    layout: F,
    list: B,
    mentions: G,
    modal: H,
    progress: K,
    result: j,
    slider: Z,
    breadcrumb: te,
    menu: ne,
    pagination: V,
    empty: W,
    badge: ue,
    radio: J,
    rate: Ce,
    switch: Ee,
    transfer: Te,
    avatar: me,
    message: we,
    tag: Ae,
    table: Ne,
    card: Ie,
    tabs: Me,
    timeline: _e,
    timePicker: Be,
    upload: st,
    notification: ct,
    tree: dt,
    colorPicker: ft,
    datePicker: rt,
    rangePicker: je,
    flex: ae,
    wave: z,
    dropdown: Q,
    warning: se,
    tour: oe,
    tooltip: he,
    popover: Le,
    popconfirm: ge,
    floatButtonGroup: Se,
    variant: xe,
    inputNumber: $e,
    treeSelect: Ze
  };
  process.env.NODE_ENV !== "production" && ru("ConfigProvider")(!("autoInsertSpaceInButton" in t), "deprecated", "`autoInsertSpaceInButton` is deprecated. Please use `{ button: { autoInsertSpace: boolean }}` instead.");
  const Ke = Object.assign({}, m);
  Object.keys(mt).forEach((yt) => {
    mt[yt] !== void 0 && (Ke[yt] = mt[yt]);
  }), Qpe.forEach((yt) => {
    const ee = t[yt];
    ee && (Ke[yt] = ee);
  }), typeof n < "u" && (Ke.button = Object.assign({
    autoInsertSpace: n
  }, Ke.button));
  const et = IS(() => Ke, Ke, (yt, ee) => {
    const Re = Object.keys(yt), Ge = Object.keys(ee);
    return Re.length !== Ge.length || Re.some((ot) => yt[ot] !== ee[ot]);
  }), {
    layer: Pt
  } = de.useContext(F0), vt = de.useMemo(() => ({
    prefixCls: He,
    csp: Pe,
    layer: Pt ? "antd" : void 0
  }), [He, Pe, Pt]);
  let nt = /* @__PURE__ */ de.createElement(de.Fragment, null, /* @__PURE__ */ de.createElement(Kpe, {
    dropdownMatchSelectWidth: d
  }), e);
  const Dt = de.useMemo(() => {
    var yt, ee, Re, Ge;
    return tc(((yt = O1.Form) === null || yt === void 0 ? void 0 : yt.defaultValidateMessages) || {}, ((Re = (ee = et.locale) === null || ee === void 0 ? void 0 : ee.Form) === null || Re === void 0 ? void 0 : Re.defaultValidateMessages) || {}, ((Ge = et.form) === null || Ge === void 0 ? void 0 : Ge.validateMessages) || {}, (s == null ? void 0 : s.validateMessages) || {});
  }, [et, s == null ? void 0 : s.validateMessages]);
  Object.keys(Dt).length > 0 && (nt = /* @__PURE__ */ de.createElement(Dpe.Provider, {
    value: Dt
  }, nt)), o && (nt = /* @__PURE__ */ de.createElement(T$, {
    locale: o,
    _ANT_MARK__: E$
  }, nt)), nt = /* @__PURE__ */ de.createElement(uC.Provider, {
    value: vt
  }, nt), l && (nt = /* @__PURE__ */ de.createElement(B0e, {
    size: l
  }, nt)), nt = /* @__PURE__ */ de.createElement(Xpe, null, nt);
  const Gt = de.useMemo(() => {
    const yt = De || {}, {
      algorithm: ee,
      token: Re,
      components: Ge,
      cssVar: ot
    } = yt, kt = Zpe(yt, ["algorithm", "token", "components", "cssVar"]), wt = ee && (!Array.isArray(ee) || ee.length > 0) ? FE(ee) : _I, pt = {};
    Object.entries(Ge || {}).forEach((or) => {
      let [ze, le] = or;
      const Oe = Object.assign({}, le);
      "algorithm" in Oe && (Oe.algorithm === !0 ? Oe.theme = wt : (Array.isArray(Oe.algorithm) || typeof Oe.algorithm == "function") && (Oe.theme = FE(Oe.algorithm)), delete Oe.algorithm), pt[ze] = Oe;
    });
    const gt = Object.assign(Object.assign({}, Ud), Re);
    return Object.assign(Object.assign({}, kt), {
      theme: wt,
      token: gt,
      components: pt,
      override: Object.assign({
        override: gt
      }, pt),
      cssVar: ot
    });
  }, [De]);
  return y && (nt = /* @__PURE__ */ de.createElement(LI.Provider, {
    value: Gt
  }, nt)), et.warning && (nt = /* @__PURE__ */ de.createElement(i$.Provider, {
    value: et.warning
  }, nt)), x !== void 0 && (nt = /* @__PURE__ */ de.createElement(w0e, {
    disabled: x
  }, nt)), /* @__PURE__ */ de.createElement(Ho.Provider, {
    value: et
  }, nt);
}, Cf = (t) => {
  const e = de.useContext(Ho), r = de.useContext(w$);
  return /* @__PURE__ */ de.createElement(rge, Object.assign({
    parentContext: e,
    legacyLocale: r
  }, t));
};
Cf.ConfigContext = Ho;
Cf.SizeContext = nf;
Cf.config = tge;
Cf.useConfig = Vpe;
Object.defineProperty(Cf, "SizeContext", {
  get: () => (process.env.NODE_ENV !== "production" && N1(!1, "ConfigProvider", "ConfigProvider.SizeContext is deprecated. Please use `ConfigProvider.useConfig().componentSize` instead."), nf)
});
process.env.NODE_ENV !== "production" && (Cf.displayName = "ConfigProvider");
const A$ = function(t, e) {
  let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
  var n, a;
  const {
    variant: i,
    [t]: s
  } = de.useContext(Ho), o = de.useContext(Ppe), l = s == null ? void 0 : s.variant;
  let u;
  typeof e < "u" ? u = e : r === !1 ? u = "borderless" : u = (a = (n = o ?? l) !== null && n !== void 0 ? n : i) !== null && a !== void 0 ? a : "outlined";
  const c = b0e.includes(u);
  return [u, c];
}, k$ = /* @__PURE__ */ de.createContext(null), R$ = (t, e) => {
  const r = de.useContext(k$), n = de.useMemo(() => {
    if (!r)
      return "";
    const {
      compactDirection: a,
      isFirstItem: i,
      isLastItem: s
    } = r, o = a === "vertical" ? "-vertical-" : "-";
    return fr(`${t}-compact${o}item`, {
      [`${t}-compact${o}first-item`]: i,
      [`${t}-compact${o}last-item`]: s,
      [`${t}-compact${o}item-rtl`]: e === "rtl"
    });
  }, [t, e, r]);
  return {
    compactSize: r == null ? void 0 : r.compactSize,
    compactDirection: r == null ? void 0 : r.compactDirection,
    compactItemClassnames: n
  };
}, nge = (t) => {
  const {
    children: e
  } = t;
  return /* @__PURE__ */ de.createElement(k$.Provider, {
    value: null
  }, e);
}, H6 = (t) => {
  const {
    space: e,
    form: r,
    children: n
  } = t;
  if (n == null)
    return null;
  let a = n;
  return r && (a = /* @__PURE__ */ lt.createElement(Ipe, {
    override: !0,
    status: !0
  }, a)), e && (a = /* @__PURE__ */ lt.createElement(nge, null, a)), a;
};
function age(t, e) {
  const r = tn([]), n = () => {
    r.current.push(setTimeout(() => {
      var a, i, s, o;
      !((a = t.current) === null || a === void 0) && a.input && ((i = t.current) === null || i === void 0 ? void 0 : i.input.getAttribute("type")) === "password" && (!((s = t.current) === null || s === void 0) && s.input.hasAttribute("value")) && ((o = t.current) === null || o === void 0 || o.input.removeAttribute("value"));
    }));
  };
  return Fi(() => (n(), () => r.current.forEach((a) => {
    a && clearTimeout(a);
  })), []), n;
}
function ige(t, e, r) {
  const {
    focusElCls: n,
    focus: a,
    borderElCls: i
  } = r, s = i ? "> *" : "", o = ["hover", a ? "focus" : null, "active"].filter(Boolean).map((l) => `&:${l} ${s}`).join(",");
  return {
    [`&-item:not(${e}-last-item)`]: {
      marginInlineEnd: t.calc(t.lineWidth).mul(-1).equal()
    },
    "&-item": Object.assign(Object.assign({
      [o]: {
        zIndex: 2
      }
    }, n ? {
      [`&${n}`]: {
        zIndex: 2
      }
    } : {}), {
      [`&[disabled] ${s}`]: {
        zIndex: 0
      }
    })
  };
}
function sge(t, e, r) {
  const {
    borderElCls: n
  } = r, a = n ? `> ${n}` : "";
  return {
    [`&-item:not(${e}-first-item):not(${e}-last-item) ${a}`]: {
      borderRadius: 0
    },
    [`&-item:not(${e}-last-item)${e}-first-item`]: {
      [`& ${a}, &${t}-sm ${a}, &${t}-lg ${a}`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`&-item:not(${e}-first-item)${e}-last-item`]: {
      [`& ${a}, &${t}-sm ${a}, &${t}-lg ${a}`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    }
  };
}
function oge(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    focus: !0
  };
  const {
    componentCls: r
  } = t, n = `${r}-compact`;
  return {
    [n]: Object.assign(Object.assign({}, ige(t, n, e)), sge(r, n, e))
  };
}
function pC(t) {
  return Au(t, {
    inputAffixPadding: t.paddingXXS
  });
}
const gC = (t) => {
  const {
    controlHeight: e,
    fontSize: r,
    lineHeight: n,
    lineWidth: a,
    controlHeightSM: i,
    controlHeightLG: s,
    fontSizeLG: o,
    lineHeightLG: l,
    paddingSM: u,
    controlPaddingHorizontalSM: c,
    controlPaddingHorizontal: f,
    colorFillAlter: h,
    colorPrimaryHover: d,
    colorPrimary: p,
    controlOutlineWidth: g,
    controlOutline: v,
    colorErrorOutline: m,
    colorWarningOutline: b,
    colorBgContainer: y,
    inputFontSize: x,
    inputFontSizeLG: E,
    inputFontSizeSM: S
  } = t, w = x || r, C = S || w, k = E || o, N = Math.round((e - w * n) / 2 * 10) / 10 - a, R = Math.round((i - C * n) / 2 * 10) / 10 - a, _ = Math.ceil((s - k * l) / 2 * 10) / 10 - a;
  return {
    paddingBlock: Math.max(N, 0),
    paddingBlockSM: Math.max(R, 0),
    paddingBlockLG: Math.max(_, 0),
    paddingInline: u - a,
    paddingInlineSM: c - a,
    paddingInlineLG: f - a,
    addonBg: h,
    activeBorderColor: p,
    hoverBorderColor: d,
    activeShadow: `0 0 0 ${g}px ${v}`,
    errorActiveShadow: `0 0 0 ${g}px ${m}`,
    warningActiveShadow: `0 0 0 ${g}px ${b}`,
    hoverBg: y,
    activeBg: y,
    inputFontSize: w,
    inputFontSizeLG: k,
    inputFontSizeSM: C
  };
}, lge = (t) => ({
  borderColor: t.hoverBorderColor,
  backgroundColor: t.hoverBg
}), vC = (t) => ({
  color: t.colorTextDisabled,
  backgroundColor: t.colorBgContainerDisabled,
  borderColor: t.colorBorder,
  boxShadow: "none",
  cursor: "not-allowed",
  opacity: 1,
  "input[disabled], textarea[disabled]": {
    cursor: "not-allowed"
  },
  "&:hover:not([disabled])": Object.assign({}, lge(Au(t, {
    hoverBorderColor: t.colorBorder,
    hoverBg: t.colorBgContainerDisabled
  })))
}), M$ = (t, e) => ({
  background: t.colorBgContainer,
  borderWidth: t.lineWidth,
  borderStyle: t.lineType,
  borderColor: e.borderColor,
  "&:hover": {
    borderColor: e.hoverBorderColor,
    backgroundColor: t.hoverBg
  },
  "&:focus, &:focus-within": {
    borderColor: e.activeBorderColor,
    boxShadow: e.activeShadow,
    outline: 0,
    backgroundColor: t.activeBg
  }
}), V6 = (t, e) => ({
  [`&${t.componentCls}-status-${e.status}:not(${t.componentCls}-disabled)`]: Object.assign(Object.assign({}, M$(t, e)), {
    [`${t.componentCls}-prefix, ${t.componentCls}-suffix`]: {
      color: e.affixColor
    }
  }),
  [`&${t.componentCls}-status-${e.status}${t.componentCls}-disabled`]: {
    borderColor: e.borderColor
  }
}), uge = (t, e) => ({
  "&-outlined": Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, M$(t, {
    borderColor: t.colorBorder,
    hoverBorderColor: t.hoverBorderColor,
    activeBorderColor: t.activeBorderColor,
    activeShadow: t.activeShadow
  })), {
    [`&${t.componentCls}-disabled, &[disabled]`]: Object.assign({}, vC(t))
  }), V6(t, {
    status: "error",
    borderColor: t.colorError,
    hoverBorderColor: t.colorErrorBorderHover,
    activeBorderColor: t.colorError,
    activeShadow: t.errorActiveShadow,
    affixColor: t.colorError
  })), V6(t, {
    status: "warning",
    borderColor: t.colorWarning,
    hoverBorderColor: t.colorWarningBorderHover,
    activeBorderColor: t.colorWarning,
    activeShadow: t.warningActiveShadow,
    affixColor: t.colorWarning
  })), e)
}), q6 = (t, e) => ({
  [`&${t.componentCls}-group-wrapper-status-${e.status}`]: {
    [`${t.componentCls}-group-addon`]: {
      borderColor: e.addonBorderColor,
      color: e.addonColor
    }
  }
}), cge = (t) => ({
  "&-outlined": Object.assign(Object.assign(Object.assign({
    [`${t.componentCls}-group`]: {
      "&-addon": {
        background: t.addonBg,
        border: `${$r(t.lineWidth)} ${t.lineType} ${t.colorBorder}`
      },
      "&-addon:first-child": {
        borderInlineEnd: 0
      },
      "&-addon:last-child": {
        borderInlineStart: 0
      }
    }
  }, q6(t, {
    status: "error",
    addonBorderColor: t.colorError,
    addonColor: t.colorErrorText
  })), q6(t, {
    status: "warning",
    addonBorderColor: t.colorWarning,
    addonColor: t.colorWarningText
  })), {
    [`&${t.componentCls}-group-wrapper-disabled`]: {
      [`${t.componentCls}-group-addon`]: Object.assign({}, vC(t))
    }
  })
}), fge = (t, e) => {
  const {
    componentCls: r
  } = t;
  return {
    "&-borderless": Object.assign({
      background: "transparent",
      border: "none",
      "&:focus, &:focus-within": {
        outline: "none"
      },
      // >>>>> Disabled
      [`&${r}-disabled, &[disabled]`]: {
        color: t.colorTextDisabled,
        cursor: "not-allowed"
      },
      // >>>>> Status
      [`&${r}-status-error`]: {
        "&, & input, & textarea": {
          color: t.colorError
        }
      },
      [`&${r}-status-warning`]: {
        "&, & input, & textarea": {
          color: t.colorWarning
        }
      }
    }, e)
  };
}, _$ = (t, e) => {
  var r;
  return {
    background: e.bg,
    borderWidth: t.lineWidth,
    borderStyle: t.lineType,
    borderColor: "transparent",
    "input&, & input, textarea&, & textarea": {
      color: (r = e == null ? void 0 : e.inputColor) !== null && r !== void 0 ? r : "unset"
    },
    "&:hover": {
      background: e.hoverBg
    },
    "&:focus, &:focus-within": {
      outline: 0,
      borderColor: e.activeBorderColor,
      backgroundColor: t.activeBg
    }
  };
}, W6 = (t, e) => ({
  [`&${t.componentCls}-status-${e.status}:not(${t.componentCls}-disabled)`]: Object.assign(Object.assign({}, _$(t, e)), {
    [`${t.componentCls}-prefix, ${t.componentCls}-suffix`]: {
      color: e.affixColor
    }
  })
}), hge = (t, e) => ({
  "&-filled": Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, _$(t, {
    bg: t.colorFillTertiary,
    hoverBg: t.colorFillSecondary,
    activeBorderColor: t.activeBorderColor
  })), {
    [`&${t.componentCls}-disabled, &[disabled]`]: Object.assign({}, vC(t))
  }), W6(t, {
    status: "error",
    bg: t.colorErrorBg,
    hoverBg: t.colorErrorBgHover,
    activeBorderColor: t.colorError,
    inputColor: t.colorErrorText,
    affixColor: t.colorError
  })), W6(t, {
    status: "warning",
    bg: t.colorWarningBg,
    hoverBg: t.colorWarningBgHover,
    activeBorderColor: t.colorWarning,
    inputColor: t.colorWarningText,
    affixColor: t.colorWarning
  })), e)
}), j6 = (t, e) => ({
  [`&${t.componentCls}-group-wrapper-status-${e.status}`]: {
    [`${t.componentCls}-group-addon`]: {
      background: e.addonBg,
      color: e.addonColor
    }
  }
}), dge = (t) => ({
  "&-filled": Object.assign(Object.assign(Object.assign({
    [`${t.componentCls}-group`]: {
      "&-addon": {
        background: t.colorFillTertiary
      },
      [`${t.componentCls}-filled:not(:focus):not(:focus-within)`]: {
        "&:not(:first-child)": {
          borderInlineStart: `${$r(t.lineWidth)} ${t.lineType} ${t.colorSplit}`
        },
        "&:not(:last-child)": {
          borderInlineEnd: `${$r(t.lineWidth)} ${t.lineType} ${t.colorSplit}`
        }
      }
    }
  }, j6(t, {
    status: "error",
    addonBg: t.colorErrorBg,
    addonColor: t.colorErrorText
  })), j6(t, {
    status: "warning",
    addonBg: t.colorWarningBg,
    addonColor: t.colorWarningText
  })), {
    [`&${t.componentCls}-group-wrapper-disabled`]: {
      [`${t.componentCls}-group`]: {
        "&-addon": {
          background: t.colorFillTertiary,
          color: t.colorTextDisabled
        },
        "&-addon:first-child": {
          borderInlineStart: `${$r(t.lineWidth)} ${t.lineType} ${t.colorBorder}`,
          borderTop: `${$r(t.lineWidth)} ${t.lineType} ${t.colorBorder}`,
          borderBottom: `${$r(t.lineWidth)} ${t.lineType} ${t.colorBorder}`
        },
        "&-addon:last-child": {
          borderInlineEnd: `${$r(t.lineWidth)} ${t.lineType} ${t.colorBorder}`,
          borderTop: `${$r(t.lineWidth)} ${t.lineType} ${t.colorBorder}`,
          borderBottom: `${$r(t.lineWidth)} ${t.lineType} ${t.colorBorder}`
        }
      }
    }
  })
}), L$ = (t, e) => ({
  background: t.colorBgContainer,
  borderWidth: `${$r(t.lineWidth)} 0`,
  borderStyle: `${t.lineType} none`,
  borderColor: `transparent transparent ${e.borderColor} transparent`,
  borderRadius: 0,
  "&:hover": {
    borderColor: `transparent transparent ${e.borderColor} transparent`,
    backgroundColor: t.hoverBg
  },
  "&:focus, &:focus-within": {
    borderColor: `transparent transparent ${e.borderColor} transparent`,
    outline: 0,
    backgroundColor: t.activeBg
  }
}), Y6 = (t, e) => ({
  [`&${t.componentCls}-status-${e.status}:not(${t.componentCls}-disabled)`]: Object.assign(Object.assign({}, L$(t, e)), {
    [`${t.componentCls}-prefix, ${t.componentCls}-suffix`]: {
      color: e.affixColor
    }
  }),
  [`&${t.componentCls}-status-${e.status}${t.componentCls}-disabled`]: {
    borderColor: `transparent transparent ${e.borderColor} transparent`
  }
}), pge = (t, e) => ({
  "&-underlined": Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, L$(t, {
    borderColor: t.colorBorder,
    hoverBorderColor: t.hoverBorderColor,
    activeBorderColor: t.activeBorderColor,
    activeShadow: t.activeShadow
  })), {
    // >>>>> Disabled
    [`&${t.componentCls}-disabled, &[disabled]`]: {
      color: t.colorTextDisabled,
      boxShadow: "none",
      cursor: "not-allowed",
      "&:hover": {
        borderColor: `transparent transparent ${t.colorBorder} transparent`
      }
    },
    "input[disabled], textarea[disabled]": {
      cursor: "not-allowed"
    }
  }), Y6(t, {
    status: "error",
    borderColor: t.colorError,
    hoverBorderColor: t.colorErrorBorderHover,
    activeBorderColor: t.colorError,
    activeShadow: t.errorActiveShadow,
    affixColor: t.colorError
  })), Y6(t, {
    status: "warning",
    borderColor: t.colorWarning,
    hoverBorderColor: t.colorWarningBorderHover,
    activeBorderColor: t.colorWarning,
    activeShadow: t.warningActiveShadow,
    affixColor: t.colorWarning
  })), e)
}), gge = (t) => ({
  // Firefox
  "&::-moz-placeholder": {
    opacity: 1
  },
  "&::placeholder": {
    color: t,
    userSelect: "none"
    // https://github.com/ant-design/ant-design/pull/32639
  },
  "&:placeholder-shown": {
    textOverflow: "ellipsis"
  }
}), N$ = (t) => {
  const {
    paddingBlockLG: e,
    lineHeightLG: r,
    borderRadiusLG: n,
    paddingInlineLG: a
  } = t;
  return {
    padding: `${$r(e)} ${$r(a)}`,
    fontSize: t.inputFontSizeLG,
    lineHeight: r,
    borderRadius: n
  };
}, O$ = (t) => ({
  padding: `${$r(t.paddingBlockSM)} ${$r(t.paddingInlineSM)}`,
  fontSize: t.inputFontSizeSM,
  borderRadius: t.borderRadiusSM
}), I$ = (t) => Object.assign(Object.assign({
  position: "relative",
  display: "inline-block",
  width: "100%",
  minWidth: 0,
  padding: `${$r(t.paddingBlock)} ${$r(t.paddingInline)}`,
  color: t.colorText,
  fontSize: t.inputFontSize,
  lineHeight: t.lineHeight,
  borderRadius: t.borderRadius,
  transition: `all ${t.motionDurationMid}`
}, gge(t.colorTextPlaceholder)), {
  // Size
  "&-lg": Object.assign({}, N$(t)),
  "&-sm": Object.assign({}, O$(t)),
  // RTL
  "&-rtl, &-textarea-rtl": {
    direction: "rtl"
  }
}), vge = (t) => {
  const {
    componentCls: e,
    antCls: r
  } = t;
  return {
    position: "relative",
    display: "table",
    width: "100%",
    borderCollapse: "separate",
    borderSpacing: 0,
    // Undo padding and float of grid classes
    "&[class*='col-']": {
      paddingInlineEnd: t.paddingXS,
      "&:last-child": {
        paddingInlineEnd: 0
      }
    },
    // Sizing options
    [`&-lg ${e}, &-lg > ${e}-group-addon`]: Object.assign({}, N$(t)),
    [`&-sm ${e}, &-sm > ${e}-group-addon`]: Object.assign({}, O$(t)),
    // Fix https://github.com/ant-design/ant-design/issues/5754
    [`&-lg ${r}-select-single ${r}-select-selector`]: {
      height: t.controlHeightLG
    },
    [`&-sm ${r}-select-single ${r}-select-selector`]: {
      height: t.controlHeightSM
    },
    [`> ${e}`]: {
      display: "table-cell",
      "&:not(:first-child):not(:last-child)": {
        borderRadius: 0
      }
    },
    [`${e}-group`]: {
      "&-addon, &-wrap": {
        display: "table-cell",
        width: 1,
        whiteSpace: "nowrap",
        verticalAlign: "middle",
        "&:not(:first-child):not(:last-child)": {
          borderRadius: 0
        }
      },
      "&-wrap > *": {
        display: "block !important"
      },
      "&-addon": {
        position: "relative",
        padding: `0 ${$r(t.paddingInline)}`,
        color: t.colorText,
        fontWeight: "normal",
        fontSize: t.inputFontSize,
        textAlign: "center",
        borderRadius: t.borderRadius,
        transition: `all ${t.motionDurationSlow}`,
        lineHeight: 1,
        // Reset Select's style in addon
        [`${r}-select`]: {
          margin: `${$r(t.calc(t.paddingBlock).add(1).mul(-1).equal())} ${$r(t.calc(t.paddingInline).mul(-1).equal())}`,
          [`&${r}-select-single:not(${r}-select-customize-input):not(${r}-pagination-size-changer)`]: {
            [`${r}-select-selector`]: {
              backgroundColor: "inherit",
              border: `${$r(t.lineWidth)} ${t.lineType} transparent`,
              boxShadow: "none"
            }
          }
        },
        // https://github.com/ant-design/ant-design/issues/31333
        [`${r}-cascader-picker`]: {
          margin: `-9px ${$r(t.calc(t.paddingInline).mul(-1).equal())}`,
          backgroundColor: "transparent",
          [`${r}-cascader-input`]: {
            textAlign: "start",
            border: 0,
            boxShadow: "none"
          }
        }
      }
    },
    [e]: {
      width: "100%",
      marginBottom: 0,
      textAlign: "inherit",
      "&:focus": {
        zIndex: 1,
        // Fix https://gw.alipayobjects.com/zos/rmsportal/DHNpoqfMXSfrSnlZvhsJ.png
        borderInlineEndWidth: 1
      },
      "&:hover": {
        zIndex: 1,
        borderInlineEndWidth: 1,
        [`${e}-search-with-button &`]: {
          zIndex: 0
        }
      }
    },
    // Reset rounded corners
    [`> ${e}:first-child, ${e}-group-addon:first-child`]: {
      borderStartEndRadius: 0,
      borderEndEndRadius: 0,
      // Reset Select's style in addon
      [`${r}-select ${r}-select-selector`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`> ${e}-affix-wrapper`]: {
      [`&:not(:first-child) ${e}`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      },
      [`&:not(:last-child) ${e}`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`> ${e}:last-child, ${e}-group-addon:last-child`]: {
      borderStartStartRadius: 0,
      borderEndStartRadius: 0,
      // Reset Select's style in addon
      [`${r}-select ${r}-select-selector`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`${e}-affix-wrapper`]: {
      "&:not(:last-child)": {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0,
        [`${e}-search &`]: {
          borderStartStartRadius: t.borderRadius,
          borderEndStartRadius: t.borderRadius
        }
      },
      [`&:not(:first-child), ${e}-search &:not(:first-child)`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`&${e}-group-compact`]: Object.assign(Object.assign({
      display: "block"
    }, P0e()), {
      [`${e}-group-addon, ${e}-group-wrap, > ${e}`]: {
        "&:not(:first-child):not(:last-child)": {
          borderInlineEndWidth: t.lineWidth,
          "&:hover, &:focus": {
            zIndex: 1
          }
        }
      },
      "& > *": {
        display: "inline-flex",
        float: "none",
        verticalAlign: "top",
        // https://github.com/ant-design/ant-design-pro/issues/139
        borderRadius: 0
      },
      [`
        & > ${e}-affix-wrapper,
        & > ${e}-number-affix-wrapper,
        & > ${r}-picker-range
      `]: {
        display: "inline-flex"
      },
      "& > *:not(:last-child)": {
        marginInlineEnd: t.calc(t.lineWidth).mul(-1).equal(),
        borderInlineEndWidth: t.lineWidth
      },
      // Undo float for .ant-input-group .ant-input
      [e]: {
        float: "none"
      },
      // reset border for Select, DatePicker, AutoComplete, Cascader, Mention, TimePicker, Input
      [`& > ${r}-select > ${r}-select-selector,
      & > ${r}-select-auto-complete ${e},
      & > ${r}-cascader-picker ${e},
      & > ${e}-group-wrapper ${e}`]: {
        borderInlineEndWidth: t.lineWidth,
        borderRadius: 0,
        "&:hover, &:focus": {
          zIndex: 1
        }
      },
      [`& > ${r}-select-focused`]: {
        zIndex: 1
      },
      // update z-index for arrow icon
      [`& > ${r}-select > ${r}-select-arrow`]: {
        zIndex: 1
        // https://github.com/ant-design/ant-design/issues/20371
      },
      [`& > *:first-child,
      & > ${r}-select:first-child > ${r}-select-selector,
      & > ${r}-select-auto-complete:first-child ${e},
      & > ${r}-cascader-picker:first-child ${e}`]: {
        borderStartStartRadius: t.borderRadius,
        borderEndStartRadius: t.borderRadius
      },
      [`& > *:last-child,
      & > ${r}-select:last-child > ${r}-select-selector,
      & > ${r}-cascader-picker:last-child ${e},
      & > ${r}-cascader-picker-focused:last-child ${e}`]: {
        borderInlineEndWidth: t.lineWidth,
        borderStartEndRadius: t.borderRadius,
        borderEndEndRadius: t.borderRadius
      },
      // https://github.com/ant-design/ant-design/issues/12493
      [`& > ${r}-select-auto-complete ${e}`]: {
        verticalAlign: "top"
      },
      [`${e}-group-wrapper + ${e}-group-wrapper`]: {
        marginInlineStart: t.calc(t.lineWidth).mul(-1).equal(),
        [`${e}-affix-wrapper`]: {
          borderRadius: 0
        }
      },
      [`${e}-group-wrapper:not(:last-child)`]: {
        [`&${e}-search > ${e}-group`]: {
          [`& > ${e}-group-addon > ${e}-search-button`]: {
            borderRadius: 0
          },
          [`& > ${e}`]: {
            borderStartStartRadius: t.borderRadius,
            borderStartEndRadius: 0,
            borderEndEndRadius: 0,
            borderEndStartRadius: t.borderRadius
          }
        }
      }
    })
  };
}, mge = (t) => {
  const {
    componentCls: e,
    controlHeightSM: r,
    lineWidth: n,
    calc: a
  } = t, s = a(r).sub(a(n).mul(2)).sub(16).div(2).equal();
  return {
    [e]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, c$(t)), I$(t)), uge(t)), hge(t)), fge(t)), pge(t)), {
      '&[type="color"]': {
        height: t.controlHeight,
        [`&${e}-lg`]: {
          height: t.controlHeightLG
        },
        [`&${e}-sm`]: {
          height: r,
          paddingTop: s,
          paddingBottom: s
        }
      },
      '&[type="search"]::-webkit-search-cancel-button, &[type="search"]::-webkit-search-decoration': {
        appearance: "none"
      }
    })
  };
}, yge = (t) => {
  const {
    componentCls: e
  } = t;
  return {
    // ========================= Input =========================
    [`${e}-clear-icon`]: {
      margin: 0,
      padding: 0,
      lineHeight: 0,
      color: t.colorTextQuaternary,
      fontSize: t.fontSizeIcon,
      verticalAlign: -1,
      // https://github.com/ant-design/ant-design/pull/18151
      // https://codesandbox.io/s/wizardly-sun-u10br
      cursor: "pointer",
      transition: `color ${t.motionDurationSlow}`,
      border: "none",
      outline: "none",
      backgroundColor: "transparent",
      "&:hover": {
        color: t.colorTextTertiary
      },
      "&:active": {
        color: t.colorText
      },
      "&-hidden": {
        visibility: "hidden"
      },
      "&-has-suffix": {
        margin: `0 ${$r(t.inputAffixPadding)}`
      }
    }
  };
}, bge = (t) => {
  const {
    componentCls: e,
    inputAffixPadding: r,
    colorTextDescription: n,
    motionDurationSlow: a,
    colorIcon: i,
    colorIconHover: s,
    iconCls: o
  } = t, l = `${e}-affix-wrapper`, u = `${e}-affix-wrapper-disabled`;
  return {
    [l]: Object.assign(Object.assign(Object.assign(Object.assign({}, I$(t)), {
      display: "inline-flex",
      [`&:not(${e}-disabled):hover`]: {
        zIndex: 1,
        [`${e}-search-with-button &`]: {
          zIndex: 0
        }
      },
      "&-focused, &:focus": {
        zIndex: 1
      },
      [`> input${e}`]: {
        padding: 0
      },
      [`> input${e}, > textarea${e}`]: {
        fontSize: "inherit",
        border: "none",
        borderRadius: 0,
        outline: "none",
        background: "transparent",
        color: "inherit",
        "&::-ms-reveal": {
          display: "none"
        },
        "&:focus": {
          boxShadow: "none !important"
        }
      },
      "&::before": {
        display: "inline-block",
        width: 0,
        visibility: "hidden",
        content: '"\\a0"'
      },
      [e]: {
        "&-prefix, &-suffix": {
          display: "flex",
          flex: "none",
          alignItems: "center",
          "> *:not(:last-child)": {
            marginInlineEnd: t.paddingXS
          }
        },
        "&-show-count-suffix": {
          color: n
        },
        "&-show-count-has-suffix": {
          marginInlineEnd: t.paddingXXS
        },
        "&-prefix": {
          marginInlineEnd: r
        },
        "&-suffix": {
          marginInlineStart: r
        }
      }
    }), yge(t)), {
      // password
      [`${o}${e}-password-icon`]: {
        color: i,
        cursor: "pointer",
        transition: `all ${a}`,
        "&:hover": {
          color: s
        }
      }
    }),
    // 覆盖 affix-wrapper borderRadius！
    [`${e}-underlined`]: {
      borderRadius: 0
    },
    [u]: {
      // password disabled
      [`${o}${e}-password-icon`]: {
        color: i,
        cursor: "not-allowed",
        "&:hover": {
          color: i
        }
      }
    }
  };
}, xge = (t) => {
  const {
    componentCls: e,
    borderRadiusLG: r,
    borderRadiusSM: n
  } = t;
  return {
    [`${e}-group`]: Object.assign(Object.assign(Object.assign({}, c$(t)), vge(t)), {
      "&-rtl": {
        direction: "rtl"
      },
      "&-wrapper": Object.assign(Object.assign(Object.assign({
        display: "inline-block",
        width: "100%",
        textAlign: "start",
        verticalAlign: "top",
        "&-rtl": {
          direction: "rtl"
        },
        // Size
        "&-lg": {
          [`${e}-group-addon`]: {
            borderRadius: r,
            fontSize: t.inputFontSizeLG
          }
        },
        "&-sm": {
          [`${e}-group-addon`]: {
            borderRadius: n
          }
        }
      }, cge(t)), dge(t)), {
        // '&-disabled': {
        //   [`${componentCls}-group-addon`]: {
        //     ...genDisabledStyle(token),
        //   },
        // },
        // Fix the issue of using icons in Space Compact mode
        // https://github.com/ant-design/ant-design/issues/42122
        [`&:not(${e}-compact-first-item):not(${e}-compact-last-item)${e}-compact-item`]: {
          [`${e}, ${e}-group-addon`]: {
            borderRadius: 0
          }
        },
        [`&:not(${e}-compact-last-item)${e}-compact-first-item`]: {
          [`${e}, ${e}-group-addon`]: {
            borderStartEndRadius: 0,
            borderEndEndRadius: 0
          }
        },
        [`&:not(${e}-compact-first-item)${e}-compact-last-item`]: {
          [`${e}, ${e}-group-addon`]: {
            borderStartStartRadius: 0,
            borderEndStartRadius: 0
          }
        },
        // Fix the issue of input use show-count param in space compact mode
        // https://github.com/ant-design/ant-design/issues/46872
        [`&:not(${e}-compact-last-item)${e}-compact-item`]: {
          [`${e}-affix-wrapper`]: {
            borderStartEndRadius: 0,
            borderEndEndRadius: 0
          }
        },
        // Fix the issue of input use `addonAfter` param in space compact mode
        // https://github.com/ant-design/ant-design/issues/52483
        [`&:not(${e}-compact-first-item)${e}-compact-item`]: {
          [`${e}-affix-wrapper`]: {
            borderStartStartRadius: 0,
            borderEndStartRadius: 0
          }
        }
      })
    })
  };
}, wge = (t) => {
  const {
    componentCls: e,
    antCls: r
  } = t, n = `${e}-search`;
  return {
    [n]: {
      [e]: {
        "&:hover, &:focus": {
          [`+ ${e}-group-addon ${n}-button:not(${r}-btn-primary)`]: {
            borderInlineStartColor: t.colorPrimaryHover
          }
        }
      },
      [`${e}-affix-wrapper`]: {
        height: t.controlHeight,
        borderRadius: 0
      },
      // fix slight height diff in Firefox:
      // https://ant.design/components/auto-complete-cn/#auto-complete-demo-certain-category
      [`${e}-lg`]: {
        lineHeight: t.calc(t.lineHeightLG).sub(2e-4).equal()
      },
      [`> ${e}-group`]: {
        [`> ${e}-group-addon:last-child`]: {
          insetInlineStart: -1,
          padding: 0,
          border: 0,
          [`${n}-button`]: {
            // Fix https://github.com/ant-design/ant-design/issues/47150
            marginInlineEnd: -1,
            borderStartStartRadius: 0,
            borderEndStartRadius: 0,
            boxShadow: "none"
          },
          [`${n}-button:not(${r}-btn-primary)`]: {
            color: t.colorTextDescription,
            "&:hover": {
              color: t.colorPrimaryHover
            },
            "&:active": {
              color: t.colorPrimaryActive
            },
            [`&${r}-btn-loading::before`]: {
              insetInlineStart: 0,
              insetInlineEnd: 0,
              insetBlockStart: 0,
              insetBlockEnd: 0
            }
          }
        }
      },
      [`${n}-button`]: {
        height: t.controlHeight,
        "&:hover, &:focus": {
          zIndex: 1
        }
      },
      "&-large": {
        [`${e}-affix-wrapper, ${n}-button`]: {
          height: t.controlHeightLG
        }
      },
      "&-small": {
        [`${e}-affix-wrapper, ${n}-button`]: {
          height: t.controlHeightSM
        }
      },
      "&-rtl": {
        direction: "rtl"
      },
      // ===================== Compact Item Customized Styles =====================
      [`&${e}-compact-item`]: {
        [`&:not(${e}-compact-last-item)`]: {
          [`${e}-group-addon`]: {
            [`${e}-search-button`]: {
              marginInlineEnd: t.calc(t.lineWidth).mul(-1).equal(),
              borderRadius: 0
            }
          }
        },
        [`&:not(${e}-compact-first-item)`]: {
          [`${e},${e}-affix-wrapper`]: {
            borderRadius: 0
          }
        },
        [`> ${e}-group-addon ${e}-search-button,
        > ${e},
        ${e}-affix-wrapper`]: {
          "&:hover, &:focus, &:active": {
            zIndex: 2
          }
        },
        [`> ${e}-affix-wrapper-focused`]: {
          zIndex: 2
        }
      }
    }
  };
}, Ege = (t) => {
  const {
    componentCls: e
  } = t;
  return {
    [`${e}-out-of-range`]: {
      [`&, & input, & textarea, ${e}-show-count-suffix, ${e}-data-count`]: {
        color: t.colorError
      }
    }
  };
}, P$ = hC(["Input", "Shared"], (t) => {
  const e = Au(t, pC(t));
  return [mge(e), bge(e)];
}, gC, {
  resetFont: !1
}), Tge = hC(["Input", "Component"], (t) => {
  const e = Au(t, pC(t));
  return [
    xge(e),
    wge(e),
    Ege(e),
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    oge(e)
  ];
}, gC, {
  resetFont: !1
});
function Sge(t) {
  return !!(t.prefix || t.suffix || t.allowClear || t.showCount);
}
var Cge = function(t, e) {
  var r = {};
  for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function") for (var a = 0, n = Object.getOwnPropertySymbols(t); a < n.length; a++)
    e.indexOf(n[a]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[a]) && (r[n[a]] = t[n[a]]);
  return r;
};
const Age = /* @__PURE__ */ CS((t, e) => {
  const {
    prefixCls: r,
    bordered: n = !0,
    status: a,
    size: i,
    disabled: s,
    onBlur: o,
    onFocus: l,
    suffix: u,
    allowClear: c,
    addonAfter: f,
    addonBefore: h,
    className: d,
    style: p,
    styles: g,
    rootClassName: v,
    onChange: m,
    classNames: b,
    variant: y
  } = t, x = Cge(t, ["prefixCls", "bordered", "status", "size", "disabled", "onBlur", "onFocus", "suffix", "allowClear", "addonAfter", "addonBefore", "className", "style", "styles", "rootClassName", "onChange", "classNames", "variant"]);
  if (process.env.NODE_ENV !== "production") {
    const {
      deprecated: we
    } = ru("Input");
    we(!("bordered" in t), "bordered", "variant");
  }
  const {
    getPrefixCls: E,
    direction: S,
    allowClear: w,
    autoComplete: C,
    className: k,
    style: N,
    classNames: R,
    styles: _
  } = s$("input"), O = E("input", r), T = tn(null), L = h$(O), [M, A, I] = P$(O, v), [D] = Tge(O, L), {
    compactSize: F,
    compactItemClassnames: B
  } = R$(O, S), G = d$((we) => {
    var Ae;
    return (Ae = i ?? F) !== null && Ae !== void 0 ? Ae : we;
  }), H = lt.useContext(e0), K = s ?? H, {
    status: j,
    hasFeedback: Z,
    feedbackIcon: te
  } = qi(t0), ne = n$(j, a), V = Sge(t) || !!Z, q = tn(V);
  if (process.env.NODE_ENV !== "production") {
    const we = ru("Input");
    Fi(() => {
      var Ae;
      V && !q.current && process.env.NODE_ENV !== "production" && we(document.activeElement === ((Ae = T.current) === null || Ae === void 0 ? void 0 : Ae.input), "usage", "When Input is focused, dynamic add or remove prefix / suffix will make it lose focus caused by dom structure change. Read more: https://ant.design/components/input/#FAQ"), q.current = V;
    }, [V]);
  }
  const X = age(T), W = (we) => {
    X(), o == null || o(we);
  }, ue = (we) => {
    X(), l == null || l(we);
  }, J = (we) => {
    X(), m == null || m(we);
  }, Ce = (Z || u) && /* @__PURE__ */ lt.createElement(lt.Fragment, null, u, Z && te), Ee = r$(c ?? w), [Te, me] = A$("input", y, n);
  return M(D(/* @__PURE__ */ lt.createElement(Cde, Object.assign({
    ref: fO(e, T),
    prefixCls: O,
    autoComplete: C
  }, x, {
    disabled: K,
    onBlur: W,
    onFocus: ue,
    style: Object.assign(Object.assign({}, N), p),
    styles: Object.assign(Object.assign({}, _), g),
    suffix: Ce,
    allowClear: Ee,
    className: fr(d, v, I, L, B, k),
    onChange: J,
    addonBefore: h && /* @__PURE__ */ lt.createElement(H6, {
      form: !0,
      space: !0
    }, h),
    addonAfter: f && /* @__PURE__ */ lt.createElement(H6, {
      form: !0,
      space: !0
    }, f),
    classNames: Object.assign(Object.assign(Object.assign({}, b), R), {
      input: fr({
        [`${O}-sm`]: G === "small",
        [`${O}-lg`]: G === "large",
        [`${O}-rtl`]: S === "rtl"
      }, b == null ? void 0 : b.input, R.input, A),
      variant: fr({
        [`${O}-${Te}`]: me
      }, WT(O, ne)),
      affixWrapper: fr({
        [`${O}-affix-wrapper-sm`]: G === "small",
        [`${O}-affix-wrapper-lg`]: G === "large",
        [`${O}-affix-wrapper-rtl`]: S === "rtl"
      }, A),
      wrapper: fr({
        [`${O}-group-rtl`]: S === "rtl"
      }, A),
      groupWrapper: fr({
        [`${O}-group-wrapper-sm`]: G === "small",
        [`${O}-group-wrapper-lg`]: G === "large",
        [`${O}-group-wrapper-rtl`]: S === "rtl",
        [`${O}-group-wrapper-${Te}`]: me
      }, WT(`${O}-group-wrapper`, ne, Z), A)
    })
  }))));
});
process.env.NODE_ENV !== "production" && (Age.displayName = "Input");
const kge = (t) => {
  const {
    componentCls: e,
    paddingLG: r
  } = t, n = `${e}-textarea`;
  return {
    // Raw Textarea
    [`textarea${e}`]: {
      maxWidth: "100%",
      // prevent textarea resize from coming out of its container
      height: "auto",
      minHeight: t.controlHeight,
      lineHeight: t.lineHeight,
      verticalAlign: "bottom",
      transition: `all ${t.motionDurationSlow}`,
      resize: "vertical",
      [`&${e}-mouse-active`]: {
        transition: `all ${t.motionDurationSlow}, height 0s, width 0s`
      }
    },
    // Wrapper for resize
    [`${e}-textarea-affix-wrapper-resize-dirty`]: {
      width: "auto"
    },
    [n]: {
      position: "relative",
      "&-show-count": {
        // https://github.com/ant-design/ant-design/issues/33049
        [`> ${e}`]: {
          height: "100%"
        },
        [`${e}-data-count`]: {
          position: "absolute",
          bottom: t.calc(t.fontSize).mul(t.lineHeight).mul(-1).equal(),
          insetInlineEnd: 0,
          color: t.colorTextDescription,
          whiteSpace: "nowrap",
          pointerEvents: "none"
        }
      },
      [`
        &-allow-clear > ${e},
        &-affix-wrapper${n}-has-feedback ${e}
      `]: {
        paddingInlineEnd: r
      },
      [`&-affix-wrapper${e}-affix-wrapper`]: {
        padding: 0,
        [`> textarea${e}`]: {
          fontSize: "inherit",
          border: "none",
          outline: "none",
          background: "transparent",
          minHeight: t.calc(t.controlHeight).sub(t.calc(t.lineWidth).mul(2)).equal(),
          "&:focus": {
            boxShadow: "none !important"
          }
        },
        [`${e}-suffix`]: {
          margin: 0,
          "> *:not(:last-child)": {
            marginInline: 0
          },
          // Clear Icon
          [`${e}-clear-icon`]: {
            position: "absolute",
            insetInlineEnd: t.paddingInline,
            insetBlockStart: t.paddingXS
          },
          // Feedback Icon
          [`${n}-suffix`]: {
            position: "absolute",
            top: 0,
            insetInlineEnd: t.paddingInline,
            bottom: 0,
            zIndex: 1,
            display: "inline-flex",
            alignItems: "center",
            margin: "auto",
            pointerEvents: "none"
          }
        }
      },
      [`&-affix-wrapper${e}-affix-wrapper-sm`]: {
        [`${e}-suffix`]: {
          [`${e}-clear-icon`]: {
            insetInlineEnd: t.paddingInlineSM
          }
        }
      }
    }
  };
}, Rge = hC(["Input", "TextArea"], (t) => {
  const e = Au(t, pC(t));
  return [kge(e)];
}, gC, {
  resetFont: !1
});
var Mge = function(t, e) {
  var r = {};
  for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function") for (var a = 0, n = Object.getOwnPropertySymbols(t); a < n.length; a++)
    e.indexOf(n[a]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[a]) && (r[n[a]] = t[n[a]]);
  return r;
};
const Y_e = /* @__PURE__ */ CS((t, e) => {
  var r;
  const {
    prefixCls: n,
    bordered: a = !0,
    size: i,
    disabled: s,
    status: o,
    allowClear: l,
    classNames: u,
    rootClassName: c,
    className: f,
    style: h,
    styles: d,
    variant: p,
    showCount: g,
    onMouseDown: v,
    onResize: m
  } = t, b = Mge(t, ["prefixCls", "bordered", "size", "disabled", "status", "allowClear", "classNames", "rootClassName", "className", "style", "styles", "variant", "showCount", "onMouseDown", "onResize"]);
  if (process.env.NODE_ENV !== "production") {
    const {
      deprecated: Ee
    } = ru("TextArea");
    Ee(!("bordered" in t), "bordered", "variant");
  }
  const {
    getPrefixCls: y,
    direction: x,
    allowClear: E,
    autoComplete: S,
    className: w,
    style: C,
    classNames: k,
    styles: N
  } = s$("textArea"), R = de.useContext(e0), _ = s ?? R, {
    status: O,
    hasFeedback: T,
    feedbackIcon: L
  } = de.useContext(t0), M = n$(O, o), A = de.useRef(null);
  de.useImperativeHandle(e, () => {
    var Ee;
    return {
      resizableTextArea: (Ee = A.current) === null || Ee === void 0 ? void 0 : Ee.resizableTextArea,
      focus: (Te) => {
        var me, we;
        zD((we = (me = A.current) === null || me === void 0 ? void 0 : me.resizableTextArea) === null || we === void 0 ? void 0 : we.textArea, Te);
      },
      blur: () => {
        var Te;
        return (Te = A.current) === null || Te === void 0 ? void 0 : Te.blur();
      }
    };
  });
  const I = y("input", n), D = h$(I), [F, B, G] = P$(I, c), [H] = Rge(I, D), {
    compactSize: K,
    compactItemClassnames: j
  } = R$(I, x), Z = d$((Ee) => {
    var Te;
    return (Te = i ?? K) !== null && Te !== void 0 ? Te : Ee;
  }), [te, ne] = A$("textArea", p, a), V = r$(l ?? E), [q, X] = de.useState(!1), [W, ue] = de.useState(!1), J = (Ee) => {
    X(!0), v == null || v(Ee);
    const Te = () => {
      X(!1), document.removeEventListener("mouseup", Te);
    };
    document.addEventListener("mouseup", Te);
  }, Ce = (Ee) => {
    var Te, me;
    if (m == null || m(Ee), q && typeof getComputedStyle == "function") {
      const we = (me = (Te = A.current) === null || Te === void 0 ? void 0 : Te.nativeElement) === null || me === void 0 ? void 0 : me.querySelector("textarea");
      we && getComputedStyle(we).resize === "both" && ue(!0);
    }
  };
  return F(H(/* @__PURE__ */ de.createElement(a0e, Object.assign({
    autoComplete: S
  }, b, {
    style: Object.assign(Object.assign({}, C), h),
    styles: Object.assign(Object.assign({}, N), d),
    disabled: _,
    allowClear: V,
    className: fr(
      G,
      D,
      f,
      c,
      j,
      w,
      // Only for wrapper
      W && `${I}-textarea-affix-wrapper-resize-dirty`
    ),
    classNames: Object.assign(Object.assign(Object.assign({}, u), k), {
      textarea: fr({
        [`${I}-sm`]: Z === "small",
        [`${I}-lg`]: Z === "large"
      }, B, u == null ? void 0 : u.textarea, k.textarea, q && `${I}-mouse-active`),
      variant: fr({
        [`${I}-${te}`]: ne
      }, WT(I, M)),
      affixWrapper: fr(`${I}-textarea-affix-wrapper`, {
        [`${I}-affix-wrapper-rtl`]: x === "rtl",
        [`${I}-affix-wrapper-sm`]: Z === "small",
        [`${I}-affix-wrapper-lg`]: Z === "large",
        [`${I}-textarea-show-count`]: g || ((r = t.count) === null || r === void 0 ? void 0 : r.show)
      }, B)
    }),
    prefixCls: I,
    suffix: T && /* @__PURE__ */ de.createElement("span", {
      className: `${I}-textarea-suffix`
    }, L),
    showCount: g,
    ref: A,
    onResize: Ce,
    onMouseDown: J
  }))));
});
class Ea {
  // The + prefix indicates that these fields aren't writeable
  // Lexer holding the input string.
  // Start offset, zero-based inclusive.
  // End offset, zero-based exclusive.
  constructor(e, r, n) {
    this.lexer = void 0, this.start = void 0, this.end = void 0, this.lexer = e, this.start = r, this.end = n;
  }
  /**
   * Merges two `SourceLocation`s from location providers, given they are
   * provided in order of appearance.
   * - Returns the first one's location if only the first is provided.
   * - Returns a merged range of the first and the last if both are provided
   *   and their lexers match.
   * - Otherwise, returns null.
   */
  static range(e, r) {
    return r ? !e || !e.loc || !r.loc || e.loc.lexer !== r.loc.lexer ? null : new Ea(e.loc.lexer, e.loc.start, r.loc.end) : e && e.loc;
  }
}
class ei {
  // don't expand the token
  // used in \noexpand
  constructor(e, r) {
    this.text = void 0, this.loc = void 0, this.noexpand = void 0, this.treatAsRelax = void 0, this.text = e, this.loc = r;
  }
  /**
   * Given a pair of tokens (this and endToken), compute a `Token` encompassing
   * the whole input range enclosed by these two.
   */
  range(e, r) {
    return new ei(r, Ea.range(this, e));
  }
}
class Ve {
  // Error start position based on passed-in Token or ParseNode.
  // Length of affected text based on passed-in Token or ParseNode.
  // The underlying error message without any context added.
  constructor(e, r) {
    this.name = void 0, this.position = void 0, this.length = void 0, this.rawMessage = void 0;
    var n = "KaTeX parse error: " + e, a, i, s = r && r.loc;
    if (s && s.start <= s.end) {
      var o = s.lexer.input;
      a = s.start, i = s.end, a === o.length ? n += " at end of input: " : n += " at position " + (a + 1) + ": ";
      var l = o.slice(a, i).replace(/[^]/g, "$&̲"), u;
      a > 15 ? u = "…" + o.slice(a - 15, a) : u = o.slice(0, a);
      var c;
      i + 15 < o.length ? c = o.slice(i, i + 15) + "…" : c = o.slice(i), n += u + l + c;
    }
    var f = new Error(n);
    return f.name = "ParseError", f.__proto__ = Ve.prototype, f.position = a, a != null && i != null && (f.length = i - a), f.rawMessage = e, f;
  }
}
Ve.prototype.__proto__ = Error.prototype;
var _ge = function(e, r) {
  return e === void 0 ? r : e;
}, Lge = /([A-Z])/g, Nge = function(e) {
  return e.replace(Lge, "-$1").toLowerCase();
}, Oge = {
  "&": "&amp;",
  ">": "&gt;",
  "<": "&lt;",
  '"': "&quot;",
  "'": "&#x27;"
}, Ige = /[&><"']/g;
function Pge(t) {
  return String(t).replace(Ige, (e) => Oge[e]);
}
var D$ = function t(e) {
  return e.type === "ordgroup" || e.type === "color" ? e.body.length === 1 ? t(e.body[0]) : e : e.type === "font" ? t(e.body) : e;
}, Dge = function(e) {
  var r = D$(e);
  return r.type === "mathord" || r.type === "textord" || r.type === "atom";
}, $ge = function(e) {
  if (!e)
    throw new Error("Expected non-null, but got " + String(e));
  return e;
}, Fge = function(e) {
  var r = /^[\x00-\x20]*([^\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(e);
  return r ? r[2] !== ":" || !/^[a-zA-Z][a-zA-Z0-9+\-.]*$/.test(r[1]) ? null : r[1].toLowerCase() : "_relative";
}, rr = {
  deflt: _ge,
  escape: Pge,
  hyphenate: Nge,
  getBaseElem: D$,
  isCharacterBox: Dge,
  protocolFromUrl: Fge
}, Md = {
  displayMode: {
    type: "boolean",
    description: "Render math in display mode, which puts the math in display style (so \\int and \\sum are large, for example), and centers the math on the page on its own line.",
    cli: "-d, --display-mode"
  },
  output: {
    type: {
      enum: ["htmlAndMathml", "html", "mathml"]
    },
    description: "Determines the markup language of the output.",
    cli: "-F, --format <type>"
  },
  leqno: {
    type: "boolean",
    description: "Render display math in leqno style (left-justified tags)."
  },
  fleqn: {
    type: "boolean",
    description: "Render display math flush left."
  },
  throwOnError: {
    type: "boolean",
    default: !0,
    cli: "-t, --no-throw-on-error",
    cliDescription: "Render errors (in the color given by --error-color) instead of throwing a ParseError exception when encountering an error."
  },
  errorColor: {
    type: "string",
    default: "#cc0000",
    cli: "-c, --error-color <color>",
    cliDescription: "A color string given in the format 'rgb' or 'rrggbb' (no #). This option determines the color of errors rendered by the -t option.",
    cliProcessor: (t) => "#" + t
  },
  macros: {
    type: "object",
    cli: "-m, --macro <def>",
    cliDescription: "Define custom macro of the form '\\foo:expansion' (use multiple -m arguments for multiple macros).",
    cliDefault: [],
    cliProcessor: (t, e) => (e.push(t), e)
  },
  minRuleThickness: {
    type: "number",
    description: "Specifies a minimum thickness, in ems, for fraction lines, `\\sqrt` top lines, `{array}` vertical lines, `\\hline`, `\\hdashline`, `\\underline`, `\\overline`, and the borders of `\\fbox`, `\\boxed`, and `\\fcolorbox`.",
    processor: (t) => Math.max(0, t),
    cli: "--min-rule-thickness <size>",
    cliProcessor: parseFloat
  },
  colorIsTextColor: {
    type: "boolean",
    description: "Makes \\color behave like LaTeX's 2-argument \\textcolor, instead of LaTeX's one-argument \\color mode change.",
    cli: "-b, --color-is-text-color"
  },
  strict: {
    type: [{
      enum: ["warn", "ignore", "error"]
    }, "boolean", "function"],
    description: "Turn on strict / LaTeX faithfulness mode, which throws an error if the input uses features that are not supported by LaTeX.",
    cli: "-S, --strict",
    cliDefault: !1
  },
  trust: {
    type: ["boolean", "function"],
    description: "Trust the input, enabling all HTML features such as \\url.",
    cli: "-T, --trust"
  },
  maxSize: {
    type: "number",
    default: 1 / 0,
    description: "If non-zero, all user-specified sizes, e.g. in \\rule{500em}{500em}, will be capped to maxSize ems. Otherwise, elements and spaces can be arbitrarily large",
    processor: (t) => Math.max(0, t),
    cli: "-s, --max-size <n>",
    cliProcessor: parseInt
  },
  maxExpand: {
    type: "number",
    default: 1e3,
    description: "Limit the number of macro expansions to the specified number, to prevent e.g. infinite macro loops. If set to Infinity, the macro expander will try to fully expand as in LaTeX.",
    processor: (t) => Math.max(0, t),
    cli: "-e, --max-expand <n>",
    cliProcessor: (t) => t === "Infinity" ? 1 / 0 : parseInt(t)
  },
  globalGroup: {
    type: "boolean",
    cli: !1
  }
};
function Bge(t) {
  if (t.default)
    return t.default;
  var e = t.type, r = Array.isArray(e) ? e[0] : e;
  if (typeof r != "string")
    return r.enum[0];
  switch (r) {
    case "boolean":
      return !1;
    case "string":
      return "";
    case "number":
      return 0;
    case "object":
      return {};
  }
}
class mC {
  constructor(e) {
    this.displayMode = void 0, this.output = void 0, this.leqno = void 0, this.fleqn = void 0, this.throwOnError = void 0, this.errorColor = void 0, this.macros = void 0, this.minRuleThickness = void 0, this.colorIsTextColor = void 0, this.strict = void 0, this.trust = void 0, this.maxSize = void 0, this.maxExpand = void 0, this.globalGroup = void 0, e = e || {};
    for (var r in Md)
      if (Md.hasOwnProperty(r)) {
        var n = Md[r];
        this[r] = e[r] !== void 0 ? n.processor ? n.processor(e[r]) : e[r] : Bge(n);
      }
  }
  /**
   * Report nonstrict (non-LaTeX-compatible) input.
   * Can safely not be called if `this.strict` is false in JavaScript.
   */
  reportNonstrict(e, r, n) {
    var a = this.strict;
    if (typeof a == "function" && (a = a(e, r, n)), !(!a || a === "ignore")) {
      if (a === !0 || a === "error")
        throw new Ve("LaTeX-incompatible input and strict mode is set to 'error': " + (r + " [" + e + "]"), n);
      a === "warn" ? typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (r + " [" + e + "]")) : typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + a + "': " + r + " [" + e + "]"));
    }
  }
  /**
   * Check whether to apply strict (LaTeX-adhering) behavior for unusual
   * input (like `\\`).  Unlike `nonstrict`, will not throw an error;
   * instead, "error" translates to a return value of `true`, while "ignore"
   * translates to a return value of `false`.  May still print a warning:
   * "warn" prints a warning and returns `false`.
   * This is for the second category of `errorCode`s listed in the README.
   */
  useStrictBehavior(e, r, n) {
    var a = this.strict;
    if (typeof a == "function")
      try {
        a = a(e, r, n);
      } catch {
        a = "error";
      }
    return !a || a === "ignore" ? !1 : a === !0 || a === "error" ? !0 : a === "warn" ? (typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (r + " [" + e + "]")), !1) : (typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + a + "': " + r + " [" + e + "]")), !1);
  }
  /**
   * Check whether to test potentially dangerous input, and return
   * `true` (trusted) or `false` (untrusted).  The sole argument `context`
   * should be an object with `command` field specifying the relevant LaTeX
   * command (as a string starting with `\`), and any other arguments, etc.
   * If `context` has a `url` field, a `protocol` field will automatically
   * get added by this function (changing the specified object).
   */
  isTrusted(e) {
    if (e.url && !e.protocol) {
      var r = rr.protocolFromUrl(e.url);
      if (r == null)
        return !1;
      e.protocol = r;
    }
    var n = typeof this.trust == "function" ? this.trust(e) : this.trust;
    return !!n;
  }
}
class Eo {
  constructor(e, r, n) {
    this.id = void 0, this.size = void 0, this.cramped = void 0, this.id = e, this.size = r, this.cramped = n;
  }
  /**
   * Get the style of a superscript given a base in the current style.
   */
  sup() {
    return os[zge[this.id]];
  }
  /**
   * Get the style of a subscript given a base in the current style.
   */
  sub() {
    return os[Gge[this.id]];
  }
  /**
   * Get the style of a fraction numerator given the fraction in the current
   * style.
   */
  fracNum() {
    return os[Uge[this.id]];
  }
  /**
   * Get the style of a fraction denominator given the fraction in the current
   * style.
   */
  fracDen() {
    return os[Hge[this.id]];
  }
  /**
   * Get the cramped version of a style (in particular, cramping a cramped style
   * doesn't change the style).
   */
  cramp() {
    return os[Vge[this.id]];
  }
  /**
   * Get a text or display version of this style.
   */
  text() {
    return os[qge[this.id]];
  }
  /**
   * Return true if this style is tightly spaced (scriptstyle/scriptscriptstyle)
   */
  isTight() {
    return this.size >= 2;
  }
}
var yC = 0, Mm = 1, xc = 2, Zs = 3, r0 = 4, pi = 5, sf = 6, ca = 7, os = [new Eo(yC, 0, !1), new Eo(Mm, 0, !0), new Eo(xc, 1, !1), new Eo(Zs, 1, !0), new Eo(r0, 2, !1), new Eo(pi, 2, !0), new Eo(sf, 3, !1), new Eo(ca, 3, !0)], zge = [r0, pi, r0, pi, sf, ca, sf, ca], Gge = [pi, pi, pi, pi, ca, ca, ca, ca], Uge = [xc, Zs, r0, pi, sf, ca, sf, ca], Hge = [Zs, Zs, pi, pi, ca, ca, ca, ca], Vge = [Mm, Mm, Zs, Zs, pi, pi, ca, ca], qge = [yC, Mm, xc, Zs, xc, Zs, xc, Zs], Ct = {
  DISPLAY: os[yC],
  TEXT: os[xc],
  SCRIPT: os[r0],
  SCRIPTSCRIPT: os[sf]
}, s4 = [{
  // Latin characters beyond the Latin-1 characters we have metrics for.
  // Needed for Czech, Hungarian and Turkish text, for example.
  name: "latin",
  blocks: [
    [256, 591],
    // Latin Extended-A and Latin Extended-B
    [768, 879]
    // Combining Diacritical marks
  ]
}, {
  // The Cyrillic script used by Russian and related languages.
  // A Cyrillic subset used to be supported as explicitly defined
  // symbols in symbols.js
  name: "cyrillic",
  blocks: [[1024, 1279]]
}, {
  // Armenian
  name: "armenian",
  blocks: [[1328, 1423]]
}, {
  // The Brahmic scripts of South and Southeast Asia
  // Devanagari (0900–097F)
  // Bengali (0980–09FF)
  // Gurmukhi (0A00–0A7F)
  // Gujarati (0A80–0AFF)
  // Oriya (0B00–0B7F)
  // Tamil (0B80–0BFF)
  // Telugu (0C00–0C7F)
  // Kannada (0C80–0CFF)
  // Malayalam (0D00–0D7F)
  // Sinhala (0D80–0DFF)
  // Thai (0E00–0E7F)
  // Lao (0E80–0EFF)
  // Tibetan (0F00–0FFF)
  // Myanmar (1000–109F)
  name: "brahmic",
  blocks: [[2304, 4255]]
}, {
  name: "georgian",
  blocks: [[4256, 4351]]
}, {
  // Chinese and Japanese.
  // The "k" in cjk is for Korean, but we've separated Korean out
  name: "cjk",
  blocks: [
    [12288, 12543],
    // CJK symbols and punctuation, Hiragana, Katakana
    [19968, 40879],
    // CJK ideograms
    [65280, 65376]
    // Fullwidth punctuation
    // TODO: add halfwidth Katakana and Romanji glyphs
  ]
}, {
  // Korean
  name: "hangul",
  blocks: [[44032, 55215]]
}];
function Wge(t) {
  for (var e = 0; e < s4.length; e++)
    for (var r = s4[e], n = 0; n < r.blocks.length; n++) {
      var a = r.blocks[n];
      if (t >= a[0] && t <= a[1])
        return r.name;
    }
  return null;
}
var hv = [];
s4.forEach((t) => t.blocks.forEach((e) => hv.push(...e)));
function $$(t) {
  for (var e = 0; e < hv.length; e += 2)
    if (t >= hv[e] && t <= hv[e + 1])
      return !0;
  return !1;
}
var Hu = 80, jge = function(e, r) {
  return "M95," + (622 + e + r) + `
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l` + e / 2.075 + " -" + e + `
c5.3,-9.3,12,-14,20,-14
H400000v` + (40 + e) + `H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M` + (834 + e) + " " + r + "h400000v" + (40 + e) + "h-400000z";
}, Yge = function(e, r) {
  return "M263," + (601 + e + r) + `c0.7,0,18,39.7,52,119
c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
c340,-704.7,510.7,-1060.3,512,-1067
l` + e / 2.084 + " -" + e + `
c4.7,-7.3,11,-11,19,-11
H40000v` + (40 + e) + `H1012.3
s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
M` + (1001 + e) + " " + r + "h400000v" + (40 + e) + "h-400000z";
}, Xge = function(e, r) {
  return "M983 " + (10 + e + r) + `
l` + e / 3.13 + " -" + e + `
c4,-6.7,10,-10,18,-10 H400000v` + (40 + e) + `
H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7
s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744
c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30
c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722
c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5
c53.7,-170.3,84.5,-266.8,92.5,-289.5z
M` + (1001 + e) + " " + r + "h400000v" + (40 + e) + "h-400000z";
}, Kge = function(e, r) {
  return "M424," + (2398 + e + r) + `
c-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514
c0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20
s-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121
s209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081
l` + e / 4.223 + " -" + e + `c4,-6.7,10,-10,18,-10 H400000
v` + (40 + e) + `H1014.6
s-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185
c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2z M` + (1001 + e) + " " + r + `
h400000v` + (40 + e) + "h-400000z";
}, Zge = function(e, r) {
  return "M473," + (2713 + e + r) + `
c339.3,-1799.3,509.3,-2700,510,-2702 l` + e / 5.298 + " -" + e + `
c3.3,-7.3,9.3,-11,18,-11 H400000v` + (40 + e) + `H1017.7
s-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200
c0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26
s76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,
606zM` + (1001 + e) + " " + r + "h400000v" + (40 + e) + "H1017.7z";
}, Qge = function(e) {
  var r = e / 2;
  return "M400000 " + e + " H0 L" + r + " 0 l65 45 L145 " + (e - 80) + " H400000z";
}, Jge = function(e, r, n) {
  var a = n - 54 - r - e;
  return "M702 " + (e + r) + "H400000" + (40 + e) + `
H742v` + a + `l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1
h-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170
c-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667
219 661 l218 661zM702 ` + r + "H400000v" + (40 + e) + "H742z";
}, eve = function(e, r, n) {
  r = 1e3 * r;
  var a = "";
  switch (e) {
    case "sqrtMain":
      a = jge(r, Hu);
      break;
    case "sqrtSize1":
      a = Yge(r, Hu);
      break;
    case "sqrtSize2":
      a = Xge(r, Hu);
      break;
    case "sqrtSize3":
      a = Kge(r, Hu);
      break;
    case "sqrtSize4":
      a = Zge(r, Hu);
      break;
    case "sqrtTall":
      a = Jge(r, Hu, n);
  }
  return a;
}, tve = function(e, r) {
  switch (e) {
    case "⎜":
      return "M291 0 H417 V" + r + " H291z M291 0 H417 V" + r + " H291z";
    case "∣":
      return "M145 0 H188 V" + r + " H145z M145 0 H188 V" + r + " H145z";
    case "∥":
      return "M145 0 H188 V" + r + " H145z M145 0 H188 V" + r + " H145z" + ("M367 0 H410 V" + r + " H367z M367 0 H410 V" + r + " H367z");
    case "⎟":
      return "M457 0 H583 V" + r + " H457z M457 0 H583 V" + r + " H457z";
    case "⎢":
      return "M319 0 H403 V" + r + " H319z M319 0 H403 V" + r + " H319z";
    case "⎥":
      return "M263 0 H347 V" + r + " H263z M263 0 H347 V" + r + " H263z";
    case "⎪":
      return "M384 0 H504 V" + r + " H384z M384 0 H504 V" + r + " H384z";
    case "⏐":
      return "M312 0 H355 V" + r + " H312z M312 0 H355 V" + r + " H312z";
    case "‖":
      return "M257 0 H300 V" + r + " H257z M257 0 H300 V" + r + " H257z" + ("M478 0 H521 V" + r + " H478z M478 0 H521 V" + r + " H478z");
    default:
      return "";
  }
}, X6 = {
  // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main
  doubleleftarrow: `M262 157
l10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3
 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28
 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5
c2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5
 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87
-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7
-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z
m8 0v40h399730v-40zm0 194v40h399730v-40z`,
  // doublerightarrow is from glyph U+21D2 in font KaTeX Main
  doublerightarrow: `M399738 392l
-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5
 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88
-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68
-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18
-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782
c-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3
-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z`,
  // leftarrow is from glyph U+2190 in font KaTeX Main
  leftarrow: `M400000 241H110l3-3c68.7-52.7 113.7-120
 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8
-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247
c-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208
 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3
 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202
 l-3-3h399890zM100 241v40h399900v-40z`,
  // overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular
  leftbrace: `M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117
-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7
 5-6 9-10 13-.7 1-7.3 1-20 1H6z`,
  leftbraceunder: `M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13
 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688
 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7
-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z`,
  // overgroup is from the MnSymbol package (public domain)
  leftgroup: `M400000 80
H435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0
 435 0h399565z`,
  leftgroupunder: `M400000 262
H435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219
 435 219h399565z`,
  // Harpoons are from glyph U+21BD in font KaTeX Main
  leftharpoon: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3
-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5
-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7
-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z`,
  leftharpoonplus: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5
 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3
-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7
-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z
m0 0v40h400000v-40z`,
  leftharpoondown: `M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333
 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5
 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667
-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z`,
  leftharpoondownplus: `M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12
 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7
-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0
v40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z`,
  // hook is from glyph U+21A9 in font KaTeX Main
  lefthook: `M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5
-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3
-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21
 71.5 23h399859zM103 281v-40h399897v40z`,
  leftlinesegment: `M40 281 V428 H0 V94 H40 V241 H400000 v40z
M40 281 V428 H0 V94 H40 V241 H400000 v40z`,
  leftmapsto: `M40 281 V448H0V74H40V241H400000v40z
M40 281 V448H0V74H40V241H400000v40z`,
  // tofrom is from glyph U+21C4 in font KaTeX AMS Regular
  leftToFrom: `M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23
-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8
c28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3
 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z`,
  longequal: `M0 50 h400000 v40H0z m0 194h40000v40H0z
M0 50 h400000 v40H0z m0 194h40000v40H0z`,
  midbrace: `M200428 334
c-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14
-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7
 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11
 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z`,
  midbraceunder: `M199572 214
c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14
 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3
 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0
-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z`,
  oiintSize1: `M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6
-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z
m368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8
60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z`,
  oiintSize2: `M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8
-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z
m502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2
c0 110 84 276 504 276s502.4-166 502.4-276z`,
  oiiintSize1: `M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6
-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z
m525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0
85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z`,
  oiiintSize2: `M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8
-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z
m770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1
c0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z`,
  rightarrow: `M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z`,
  rightbrace: `M400000 542l
-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5
s-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1
c124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z`,
  rightbraceunder: `M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3
 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237
-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z`,
  rightgroup: `M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0
 3-1 3-3v-38c-76-158-257-219-435-219H0z`,
  rightgroupunder: `M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18
 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z`,
  rightharpoon: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3
-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2
-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58
 69.2 92 94.5zm0 0v40h399900v-40z`,
  rightharpoonplus: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11
-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7
 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z
m0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z`,
  rightharpoondown: `M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8
 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5
-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95
-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z`,
  rightharpoondownplus: `M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8
 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3
 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3
-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z
m0-194v40h400000v-40zm0 0v40h400000v-40z`,
  righthook: `M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3
 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0
-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21
 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z`,
  rightlinesegment: `M399960 241 V94 h40 V428 h-40 V281 H0 v-40z
M399960 241 V94 h40 V428 h-40 V281 H0 v-40z`,
  rightToFrom: `M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23
 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32
-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142
-167z M100 147v40h399900v-40zM0 341v40h399900v-40z`,
  // twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular
  twoheadleftarrow: `M0 167c68 40
 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69
-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3
-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19
-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101
 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z`,
  twoheadrightarrow: `M400000 167
c-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3
 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42
 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333
-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70
 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z`,
  // tilde1 is a modified version of a glyph from the MnSymbol package
  tilde1: `M200 55.538c-77 0-168 73.953-177 73.953-3 0-7
-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0
 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0
 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128
-68.267.847-113-73.952-191-73.952z`,
  // ditto tilde2, tilde3, & tilde4
  tilde2: `M344 55.266c-142 0-300.638 81.316-311.5 86.418
-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9
 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114
c1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751
 181.476 676 181.476c-149 0-189-126.21-332-126.21z`,
  tilde3: `M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457
-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0
 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697
 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696
 -338 0-409-156.573-744-156.573z`,
  tilde4: `M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345
-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409
 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9
 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409
 -175.236-744-175.236z`,
  // vec is from glyph U+20D7 in font KaTeX Main
  vec: `M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z`,
  // widehat1 is a modified version of a glyph from the MnSymbol package
  widehat1: `M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z`,
  // ditto widehat2, widehat3, & widehat4
  widehat2: `M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  widehat3: `M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  widehat4: `M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  // widecheck paths are all inverted versions of widehat
  widecheck1: `M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,
-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z`,
  widecheck2: `M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  widecheck3: `M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  widecheck4: `M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  // The next ten paths support reaction arrows from the mhchem package.
  // Arrows for \ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX
  // baraboveleftarrow is mostly from glyph U+2190 in font KaTeX Main
  baraboveleftarrow: `M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202
c4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5
c-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130
s-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47
121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6
s2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11
c0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z
M100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z`,
  // rightarrowabovebar is mostly from glyph U+2192, KaTeX Main
  rightarrowabovebar: `M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32
-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0
13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39
-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5
-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z`,
  // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.
  // Ref from mhchem.sty: \rlap{\raisebox{-.22ex}{$\kern0.5em
  baraboveshortleftharpoon: `M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17
c2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21
c-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40
c-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z
M0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z`,
  rightharpoonaboveshortbar: `M0,241 l0,40c399126,0,399993,0,399993,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z`,
  shortbaraboveleftharpoon: `M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,
1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,
-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z
M93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z`,
  shortrightharpoonabovebar: `M53,241l0,40c398570,0,399437,0,399437,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z`
}, rve = function(e, r) {
  switch (e) {
    case "lbrack":
      return "M403 1759 V84 H666 V0 H319 V1759 v" + r + ` v1759 h347 v-84
H403z M403 1759 V0 H319 V1759 v` + r + " v1759 h84z";
    case "rbrack":
      return "M347 1759 V0 H0 V84 H263 V1759 v" + r + ` v1759 H0 v84 H347z
M347 1759 V0 H263 V1759 v` + r + " v1759 h84z";
    case "vert":
      return "M145 15 v585 v" + r + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -r + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v` + r + " v585 h43z";
    case "doublevert":
      return "M145 15 v585 v" + r + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -r + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v` + r + ` v585 h43z
M367 15 v585 v` + r + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -r + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M410 15 H367 v585 v` + r + " v585 h43z";
    case "lfloor":
      return "M319 602 V0 H403 V602 v" + r + ` v1715 h263 v84 H319z
MM319 602 V0 H403 V602 v` + r + " v1715 H319z";
    case "rfloor":
      return "M319 602 V0 H403 V602 v" + r + ` v1799 H0 v-84 H319z
MM319 602 V0 H403 V602 v` + r + " v1715 H319z";
    case "lceil":
      return "M403 1759 V84 H666 V0 H319 V1759 v" + r + ` v602 h84z
M403 1759 V0 H319 V1759 v` + r + " v602 h84z";
    case "rceil":
      return "M347 1759 V0 H0 V84 H263 V1759 v" + r + ` v602 h84z
M347 1759 V0 h-84 V1759 v` + r + " v602 h84z";
    case "lparen":
      return `M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1
c-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,
-36,557 l0,` + (r + 84) + `c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,
949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9
c0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,
-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189
l0,-` + (r + 92) + `c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,
-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z`;
    case "rparen":
      return `M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,
63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5
c11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0,` + (r + 9) + `
c-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664
c-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11
c0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17
c242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558
l0,-` + (r + 144) + `c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,
-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z`;
    default:
      throw new Error("Unknown stretchy delimiter.");
  }
};
class ep {
  // Never used; needed for satisfying interface.
  constructor(e) {
    this.children = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, this.children = e, this.classes = [], this.height = 0, this.depth = 0, this.maxFontSize = 0, this.style = {};
  }
  hasClass(e) {
    return this.classes.includes(e);
  }
  /** Convert the fragment into a node. */
  toNode() {
    for (var e = document.createDocumentFragment(), r = 0; r < this.children.length; r++)
      e.appendChild(this.children[r].toNode());
    return e;
  }
  /** Convert the fragment into HTML markup. */
  toMarkup() {
    for (var e = "", r = 0; r < this.children.length; r++)
      e += this.children[r].toMarkup();
    return e;
  }
  /**
   * Converts the math node into a string, similar to innerText. Applies to
   * MathDomNode's only.
   */
  toText() {
    var e = (r) => r.toText();
    return this.children.map(e).join("");
  }
}
var fs = {
  "AMS-Regular": {
    32: [0, 0, 0, 0, 0.25],
    65: [0, 0.68889, 0, 0, 0.72222],
    66: [0, 0.68889, 0, 0, 0.66667],
    67: [0, 0.68889, 0, 0, 0.72222],
    68: [0, 0.68889, 0, 0, 0.72222],
    69: [0, 0.68889, 0, 0, 0.66667],
    70: [0, 0.68889, 0, 0, 0.61111],
    71: [0, 0.68889, 0, 0, 0.77778],
    72: [0, 0.68889, 0, 0, 0.77778],
    73: [0, 0.68889, 0, 0, 0.38889],
    74: [0.16667, 0.68889, 0, 0, 0.5],
    75: [0, 0.68889, 0, 0, 0.77778],
    76: [0, 0.68889, 0, 0, 0.66667],
    77: [0, 0.68889, 0, 0, 0.94445],
    78: [0, 0.68889, 0, 0, 0.72222],
    79: [0.16667, 0.68889, 0, 0, 0.77778],
    80: [0, 0.68889, 0, 0, 0.61111],
    81: [0.16667, 0.68889, 0, 0, 0.77778],
    82: [0, 0.68889, 0, 0, 0.72222],
    83: [0, 0.68889, 0, 0, 0.55556],
    84: [0, 0.68889, 0, 0, 0.66667],
    85: [0, 0.68889, 0, 0, 0.72222],
    86: [0, 0.68889, 0, 0, 0.72222],
    87: [0, 0.68889, 0, 0, 1],
    88: [0, 0.68889, 0, 0, 0.72222],
    89: [0, 0.68889, 0, 0, 0.72222],
    90: [0, 0.68889, 0, 0, 0.66667],
    107: [0, 0.68889, 0, 0, 0.55556],
    160: [0, 0, 0, 0, 0.25],
    165: [0, 0.675, 0.025, 0, 0.75],
    174: [0.15559, 0.69224, 0, 0, 0.94666],
    240: [0, 0.68889, 0, 0, 0.55556],
    295: [0, 0.68889, 0, 0, 0.54028],
    710: [0, 0.825, 0, 0, 2.33334],
    732: [0, 0.9, 0, 0, 2.33334],
    770: [0, 0.825, 0, 0, 2.33334],
    771: [0, 0.9, 0, 0, 2.33334],
    989: [0.08167, 0.58167, 0, 0, 0.77778],
    1008: [0, 0.43056, 0.04028, 0, 0.66667],
    8245: [0, 0.54986, 0, 0, 0.275],
    8463: [0, 0.68889, 0, 0, 0.54028],
    8487: [0, 0.68889, 0, 0, 0.72222],
    8498: [0, 0.68889, 0, 0, 0.55556],
    8502: [0, 0.68889, 0, 0, 0.66667],
    8503: [0, 0.68889, 0, 0, 0.44445],
    8504: [0, 0.68889, 0, 0, 0.66667],
    8513: [0, 0.68889, 0, 0, 0.63889],
    8592: [-0.03598, 0.46402, 0, 0, 0.5],
    8594: [-0.03598, 0.46402, 0, 0, 0.5],
    8602: [-0.13313, 0.36687, 0, 0, 1],
    8603: [-0.13313, 0.36687, 0, 0, 1],
    8606: [0.01354, 0.52239, 0, 0, 1],
    8608: [0.01354, 0.52239, 0, 0, 1],
    8610: [0.01354, 0.52239, 0, 0, 1.11111],
    8611: [0.01354, 0.52239, 0, 0, 1.11111],
    8619: [0, 0.54986, 0, 0, 1],
    8620: [0, 0.54986, 0, 0, 1],
    8621: [-0.13313, 0.37788, 0, 0, 1.38889],
    8622: [-0.13313, 0.36687, 0, 0, 1],
    8624: [0, 0.69224, 0, 0, 0.5],
    8625: [0, 0.69224, 0, 0, 0.5],
    8630: [0, 0.43056, 0, 0, 1],
    8631: [0, 0.43056, 0, 0, 1],
    8634: [0.08198, 0.58198, 0, 0, 0.77778],
    8635: [0.08198, 0.58198, 0, 0, 0.77778],
    8638: [0.19444, 0.69224, 0, 0, 0.41667],
    8639: [0.19444, 0.69224, 0, 0, 0.41667],
    8642: [0.19444, 0.69224, 0, 0, 0.41667],
    8643: [0.19444, 0.69224, 0, 0, 0.41667],
    8644: [0.1808, 0.675, 0, 0, 1],
    8646: [0.1808, 0.675, 0, 0, 1],
    8647: [0.1808, 0.675, 0, 0, 1],
    8648: [0.19444, 0.69224, 0, 0, 0.83334],
    8649: [0.1808, 0.675, 0, 0, 1],
    8650: [0.19444, 0.69224, 0, 0, 0.83334],
    8651: [0.01354, 0.52239, 0, 0, 1],
    8652: [0.01354, 0.52239, 0, 0, 1],
    8653: [-0.13313, 0.36687, 0, 0, 1],
    8654: [-0.13313, 0.36687, 0, 0, 1],
    8655: [-0.13313, 0.36687, 0, 0, 1],
    8666: [0.13667, 0.63667, 0, 0, 1],
    8667: [0.13667, 0.63667, 0, 0, 1],
    8669: [-0.13313, 0.37788, 0, 0, 1],
    8672: [-0.064, 0.437, 0, 0, 1.334],
    8674: [-0.064, 0.437, 0, 0, 1.334],
    8705: [0, 0.825, 0, 0, 0.5],
    8708: [0, 0.68889, 0, 0, 0.55556],
    8709: [0.08167, 0.58167, 0, 0, 0.77778],
    8717: [0, 0.43056, 0, 0, 0.42917],
    8722: [-0.03598, 0.46402, 0, 0, 0.5],
    8724: [0.08198, 0.69224, 0, 0, 0.77778],
    8726: [0.08167, 0.58167, 0, 0, 0.77778],
    8733: [0, 0.69224, 0, 0, 0.77778],
    8736: [0, 0.69224, 0, 0, 0.72222],
    8737: [0, 0.69224, 0, 0, 0.72222],
    8738: [0.03517, 0.52239, 0, 0, 0.72222],
    8739: [0.08167, 0.58167, 0, 0, 0.22222],
    8740: [0.25142, 0.74111, 0, 0, 0.27778],
    8741: [0.08167, 0.58167, 0, 0, 0.38889],
    8742: [0.25142, 0.74111, 0, 0, 0.5],
    8756: [0, 0.69224, 0, 0, 0.66667],
    8757: [0, 0.69224, 0, 0, 0.66667],
    8764: [-0.13313, 0.36687, 0, 0, 0.77778],
    8765: [-0.13313, 0.37788, 0, 0, 0.77778],
    8769: [-0.13313, 0.36687, 0, 0, 0.77778],
    8770: [-0.03625, 0.46375, 0, 0, 0.77778],
    8774: [0.30274, 0.79383, 0, 0, 0.77778],
    8776: [-0.01688, 0.48312, 0, 0, 0.77778],
    8778: [0.08167, 0.58167, 0, 0, 0.77778],
    8782: [0.06062, 0.54986, 0, 0, 0.77778],
    8783: [0.06062, 0.54986, 0, 0, 0.77778],
    8785: [0.08198, 0.58198, 0, 0, 0.77778],
    8786: [0.08198, 0.58198, 0, 0, 0.77778],
    8787: [0.08198, 0.58198, 0, 0, 0.77778],
    8790: [0, 0.69224, 0, 0, 0.77778],
    8791: [0.22958, 0.72958, 0, 0, 0.77778],
    8796: [0.08198, 0.91667, 0, 0, 0.77778],
    8806: [0.25583, 0.75583, 0, 0, 0.77778],
    8807: [0.25583, 0.75583, 0, 0, 0.77778],
    8808: [0.25142, 0.75726, 0, 0, 0.77778],
    8809: [0.25142, 0.75726, 0, 0, 0.77778],
    8812: [0.25583, 0.75583, 0, 0, 0.5],
    8814: [0.20576, 0.70576, 0, 0, 0.77778],
    8815: [0.20576, 0.70576, 0, 0, 0.77778],
    8816: [0.30274, 0.79383, 0, 0, 0.77778],
    8817: [0.30274, 0.79383, 0, 0, 0.77778],
    8818: [0.22958, 0.72958, 0, 0, 0.77778],
    8819: [0.22958, 0.72958, 0, 0, 0.77778],
    8822: [0.1808, 0.675, 0, 0, 0.77778],
    8823: [0.1808, 0.675, 0, 0, 0.77778],
    8828: [0.13667, 0.63667, 0, 0, 0.77778],
    8829: [0.13667, 0.63667, 0, 0, 0.77778],
    8830: [0.22958, 0.72958, 0, 0, 0.77778],
    8831: [0.22958, 0.72958, 0, 0, 0.77778],
    8832: [0.20576, 0.70576, 0, 0, 0.77778],
    8833: [0.20576, 0.70576, 0, 0, 0.77778],
    8840: [0.30274, 0.79383, 0, 0, 0.77778],
    8841: [0.30274, 0.79383, 0, 0, 0.77778],
    8842: [0.13597, 0.63597, 0, 0, 0.77778],
    8843: [0.13597, 0.63597, 0, 0, 0.77778],
    8847: [0.03517, 0.54986, 0, 0, 0.77778],
    8848: [0.03517, 0.54986, 0, 0, 0.77778],
    8858: [0.08198, 0.58198, 0, 0, 0.77778],
    8859: [0.08198, 0.58198, 0, 0, 0.77778],
    8861: [0.08198, 0.58198, 0, 0, 0.77778],
    8862: [0, 0.675, 0, 0, 0.77778],
    8863: [0, 0.675, 0, 0, 0.77778],
    8864: [0, 0.675, 0, 0, 0.77778],
    8865: [0, 0.675, 0, 0, 0.77778],
    8872: [0, 0.69224, 0, 0, 0.61111],
    8873: [0, 0.69224, 0, 0, 0.72222],
    8874: [0, 0.69224, 0, 0, 0.88889],
    8876: [0, 0.68889, 0, 0, 0.61111],
    8877: [0, 0.68889, 0, 0, 0.61111],
    8878: [0, 0.68889, 0, 0, 0.72222],
    8879: [0, 0.68889, 0, 0, 0.72222],
    8882: [0.03517, 0.54986, 0, 0, 0.77778],
    8883: [0.03517, 0.54986, 0, 0, 0.77778],
    8884: [0.13667, 0.63667, 0, 0, 0.77778],
    8885: [0.13667, 0.63667, 0, 0, 0.77778],
    8888: [0, 0.54986, 0, 0, 1.11111],
    8890: [0.19444, 0.43056, 0, 0, 0.55556],
    8891: [0.19444, 0.69224, 0, 0, 0.61111],
    8892: [0.19444, 0.69224, 0, 0, 0.61111],
    8901: [0, 0.54986, 0, 0, 0.27778],
    8903: [0.08167, 0.58167, 0, 0, 0.77778],
    8905: [0.08167, 0.58167, 0, 0, 0.77778],
    8906: [0.08167, 0.58167, 0, 0, 0.77778],
    8907: [0, 0.69224, 0, 0, 0.77778],
    8908: [0, 0.69224, 0, 0, 0.77778],
    8909: [-0.03598, 0.46402, 0, 0, 0.77778],
    8910: [0, 0.54986, 0, 0, 0.76042],
    8911: [0, 0.54986, 0, 0, 0.76042],
    8912: [0.03517, 0.54986, 0, 0, 0.77778],
    8913: [0.03517, 0.54986, 0, 0, 0.77778],
    8914: [0, 0.54986, 0, 0, 0.66667],
    8915: [0, 0.54986, 0, 0, 0.66667],
    8916: [0, 0.69224, 0, 0, 0.66667],
    8918: [0.0391, 0.5391, 0, 0, 0.77778],
    8919: [0.0391, 0.5391, 0, 0, 0.77778],
    8920: [0.03517, 0.54986, 0, 0, 1.33334],
    8921: [0.03517, 0.54986, 0, 0, 1.33334],
    8922: [0.38569, 0.88569, 0, 0, 0.77778],
    8923: [0.38569, 0.88569, 0, 0, 0.77778],
    8926: [0.13667, 0.63667, 0, 0, 0.77778],
    8927: [0.13667, 0.63667, 0, 0, 0.77778],
    8928: [0.30274, 0.79383, 0, 0, 0.77778],
    8929: [0.30274, 0.79383, 0, 0, 0.77778],
    8934: [0.23222, 0.74111, 0, 0, 0.77778],
    8935: [0.23222, 0.74111, 0, 0, 0.77778],
    8936: [0.23222, 0.74111, 0, 0, 0.77778],
    8937: [0.23222, 0.74111, 0, 0, 0.77778],
    8938: [0.20576, 0.70576, 0, 0, 0.77778],
    8939: [0.20576, 0.70576, 0, 0, 0.77778],
    8940: [0.30274, 0.79383, 0, 0, 0.77778],
    8941: [0.30274, 0.79383, 0, 0, 0.77778],
    8994: [0.19444, 0.69224, 0, 0, 0.77778],
    8995: [0.19444, 0.69224, 0, 0, 0.77778],
    9416: [0.15559, 0.69224, 0, 0, 0.90222],
    9484: [0, 0.69224, 0, 0, 0.5],
    9488: [0, 0.69224, 0, 0, 0.5],
    9492: [0, 0.37788, 0, 0, 0.5],
    9496: [0, 0.37788, 0, 0, 0.5],
    9585: [0.19444, 0.68889, 0, 0, 0.88889],
    9586: [0.19444, 0.74111, 0, 0, 0.88889],
    9632: [0, 0.675, 0, 0, 0.77778],
    9633: [0, 0.675, 0, 0, 0.77778],
    9650: [0, 0.54986, 0, 0, 0.72222],
    9651: [0, 0.54986, 0, 0, 0.72222],
    9654: [0.03517, 0.54986, 0, 0, 0.77778],
    9660: [0, 0.54986, 0, 0, 0.72222],
    9661: [0, 0.54986, 0, 0, 0.72222],
    9664: [0.03517, 0.54986, 0, 0, 0.77778],
    9674: [0.11111, 0.69224, 0, 0, 0.66667],
    9733: [0.19444, 0.69224, 0, 0, 0.94445],
    10003: [0, 0.69224, 0, 0, 0.83334],
    10016: [0, 0.69224, 0, 0, 0.83334],
    10731: [0.11111, 0.69224, 0, 0, 0.66667],
    10846: [0.19444, 0.75583, 0, 0, 0.61111],
    10877: [0.13667, 0.63667, 0, 0, 0.77778],
    10878: [0.13667, 0.63667, 0, 0, 0.77778],
    10885: [0.25583, 0.75583, 0, 0, 0.77778],
    10886: [0.25583, 0.75583, 0, 0, 0.77778],
    10887: [0.13597, 0.63597, 0, 0, 0.77778],
    10888: [0.13597, 0.63597, 0, 0, 0.77778],
    10889: [0.26167, 0.75726, 0, 0, 0.77778],
    10890: [0.26167, 0.75726, 0, 0, 0.77778],
    10891: [0.48256, 0.98256, 0, 0, 0.77778],
    10892: [0.48256, 0.98256, 0, 0, 0.77778],
    10901: [0.13667, 0.63667, 0, 0, 0.77778],
    10902: [0.13667, 0.63667, 0, 0, 0.77778],
    10933: [0.25142, 0.75726, 0, 0, 0.77778],
    10934: [0.25142, 0.75726, 0, 0, 0.77778],
    10935: [0.26167, 0.75726, 0, 0, 0.77778],
    10936: [0.26167, 0.75726, 0, 0, 0.77778],
    10937: [0.26167, 0.75726, 0, 0, 0.77778],
    10938: [0.26167, 0.75726, 0, 0, 0.77778],
    10949: [0.25583, 0.75583, 0, 0, 0.77778],
    10950: [0.25583, 0.75583, 0, 0, 0.77778],
    10955: [0.28481, 0.79383, 0, 0, 0.77778],
    10956: [0.28481, 0.79383, 0, 0, 0.77778],
    57350: [0.08167, 0.58167, 0, 0, 0.22222],
    57351: [0.08167, 0.58167, 0, 0, 0.38889],
    57352: [0.08167, 0.58167, 0, 0, 0.77778],
    57353: [0, 0.43056, 0.04028, 0, 0.66667],
    57356: [0.25142, 0.75726, 0, 0, 0.77778],
    57357: [0.25142, 0.75726, 0, 0, 0.77778],
    57358: [0.41951, 0.91951, 0, 0, 0.77778],
    57359: [0.30274, 0.79383, 0, 0, 0.77778],
    57360: [0.30274, 0.79383, 0, 0, 0.77778],
    57361: [0.41951, 0.91951, 0, 0, 0.77778],
    57366: [0.25142, 0.75726, 0, 0, 0.77778],
    57367: [0.25142, 0.75726, 0, 0, 0.77778],
    57368: [0.25142, 0.75726, 0, 0, 0.77778],
    57369: [0.25142, 0.75726, 0, 0, 0.77778],
    57370: [0.13597, 0.63597, 0, 0, 0.77778],
    57371: [0.13597, 0.63597, 0, 0, 0.77778]
  },
  "Caligraphic-Regular": {
    32: [0, 0, 0, 0, 0.25],
    65: [0, 0.68333, 0, 0.19445, 0.79847],
    66: [0, 0.68333, 0.03041, 0.13889, 0.65681],
    67: [0, 0.68333, 0.05834, 0.13889, 0.52653],
    68: [0, 0.68333, 0.02778, 0.08334, 0.77139],
    69: [0, 0.68333, 0.08944, 0.11111, 0.52778],
    70: [0, 0.68333, 0.09931, 0.11111, 0.71875],
    71: [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
    72: [0, 0.68333, 965e-5, 0.11111, 0.84452],
    73: [0, 0.68333, 0.07382, 0, 0.54452],
    74: [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
    75: [0, 0.68333, 0.01445, 0.05556, 0.76195],
    76: [0, 0.68333, 0, 0.13889, 0.68972],
    77: [0, 0.68333, 0, 0.13889, 1.2009],
    78: [0, 0.68333, 0.14736, 0.08334, 0.82049],
    79: [0, 0.68333, 0.02778, 0.11111, 0.79611],
    80: [0, 0.68333, 0.08222, 0.08334, 0.69556],
    81: [0.09722, 0.68333, 0, 0.11111, 0.81667],
    82: [0, 0.68333, 0, 0.08334, 0.8475],
    83: [0, 0.68333, 0.075, 0.13889, 0.60556],
    84: [0, 0.68333, 0.25417, 0, 0.54464],
    85: [0, 0.68333, 0.09931, 0.08334, 0.62583],
    86: [0, 0.68333, 0.08222, 0, 0.61278],
    87: [0, 0.68333, 0.08222, 0.08334, 0.98778],
    88: [0, 0.68333, 0.14643, 0.13889, 0.7133],
    89: [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
    90: [0, 0.68333, 0.07944, 0.13889, 0.72473],
    160: [0, 0, 0, 0, 0.25]
  },
  "Fraktur-Regular": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69141, 0, 0, 0.29574],
    34: [0, 0.69141, 0, 0, 0.21471],
    38: [0, 0.69141, 0, 0, 0.73786],
    39: [0, 0.69141, 0, 0, 0.21201],
    40: [0.24982, 0.74947, 0, 0, 0.38865],
    41: [0.24982, 0.74947, 0, 0, 0.38865],
    42: [0, 0.62119, 0, 0, 0.27764],
    43: [0.08319, 0.58283, 0, 0, 0.75623],
    44: [0, 0.10803, 0, 0, 0.27764],
    45: [0.08319, 0.58283, 0, 0, 0.75623],
    46: [0, 0.10803, 0, 0, 0.27764],
    47: [0.24982, 0.74947, 0, 0, 0.50181],
    48: [0, 0.47534, 0, 0, 0.50181],
    49: [0, 0.47534, 0, 0, 0.50181],
    50: [0, 0.47534, 0, 0, 0.50181],
    51: [0.18906, 0.47534, 0, 0, 0.50181],
    52: [0.18906, 0.47534, 0, 0, 0.50181],
    53: [0.18906, 0.47534, 0, 0, 0.50181],
    54: [0, 0.69141, 0, 0, 0.50181],
    55: [0.18906, 0.47534, 0, 0, 0.50181],
    56: [0, 0.69141, 0, 0, 0.50181],
    57: [0.18906, 0.47534, 0, 0, 0.50181],
    58: [0, 0.47534, 0, 0, 0.21606],
    59: [0.12604, 0.47534, 0, 0, 0.21606],
    61: [-0.13099, 0.36866, 0, 0, 0.75623],
    63: [0, 0.69141, 0, 0, 0.36245],
    65: [0, 0.69141, 0, 0, 0.7176],
    66: [0, 0.69141, 0, 0, 0.88397],
    67: [0, 0.69141, 0, 0, 0.61254],
    68: [0, 0.69141, 0, 0, 0.83158],
    69: [0, 0.69141, 0, 0, 0.66278],
    70: [0.12604, 0.69141, 0, 0, 0.61119],
    71: [0, 0.69141, 0, 0, 0.78539],
    72: [0.06302, 0.69141, 0, 0, 0.7203],
    73: [0, 0.69141, 0, 0, 0.55448],
    74: [0.12604, 0.69141, 0, 0, 0.55231],
    75: [0, 0.69141, 0, 0, 0.66845],
    76: [0, 0.69141, 0, 0, 0.66602],
    77: [0, 0.69141, 0, 0, 1.04953],
    78: [0, 0.69141, 0, 0, 0.83212],
    79: [0, 0.69141, 0, 0, 0.82699],
    80: [0.18906, 0.69141, 0, 0, 0.82753],
    81: [0.03781, 0.69141, 0, 0, 0.82699],
    82: [0, 0.69141, 0, 0, 0.82807],
    83: [0, 0.69141, 0, 0, 0.82861],
    84: [0, 0.69141, 0, 0, 0.66899],
    85: [0, 0.69141, 0, 0, 0.64576],
    86: [0, 0.69141, 0, 0, 0.83131],
    87: [0, 0.69141, 0, 0, 1.04602],
    88: [0, 0.69141, 0, 0, 0.71922],
    89: [0.18906, 0.69141, 0, 0, 0.83293],
    90: [0.12604, 0.69141, 0, 0, 0.60201],
    91: [0.24982, 0.74947, 0, 0, 0.27764],
    93: [0.24982, 0.74947, 0, 0, 0.27764],
    94: [0, 0.69141, 0, 0, 0.49965],
    97: [0, 0.47534, 0, 0, 0.50046],
    98: [0, 0.69141, 0, 0, 0.51315],
    99: [0, 0.47534, 0, 0, 0.38946],
    100: [0, 0.62119, 0, 0, 0.49857],
    101: [0, 0.47534, 0, 0, 0.40053],
    102: [0.18906, 0.69141, 0, 0, 0.32626],
    103: [0.18906, 0.47534, 0, 0, 0.5037],
    104: [0.18906, 0.69141, 0, 0, 0.52126],
    105: [0, 0.69141, 0, 0, 0.27899],
    106: [0, 0.69141, 0, 0, 0.28088],
    107: [0, 0.69141, 0, 0, 0.38946],
    108: [0, 0.69141, 0, 0, 0.27953],
    109: [0, 0.47534, 0, 0, 0.76676],
    110: [0, 0.47534, 0, 0, 0.52666],
    111: [0, 0.47534, 0, 0, 0.48885],
    112: [0.18906, 0.52396, 0, 0, 0.50046],
    113: [0.18906, 0.47534, 0, 0, 0.48912],
    114: [0, 0.47534, 0, 0, 0.38919],
    115: [0, 0.47534, 0, 0, 0.44266],
    116: [0, 0.62119, 0, 0, 0.33301],
    117: [0, 0.47534, 0, 0, 0.5172],
    118: [0, 0.52396, 0, 0, 0.5118],
    119: [0, 0.52396, 0, 0, 0.77351],
    120: [0.18906, 0.47534, 0, 0, 0.38865],
    121: [0.18906, 0.47534, 0, 0, 0.49884],
    122: [0.18906, 0.47534, 0, 0, 0.39054],
    160: [0, 0, 0, 0, 0.25],
    8216: [0, 0.69141, 0, 0, 0.21471],
    8217: [0, 0.69141, 0, 0, 0.21471],
    58112: [0, 0.62119, 0, 0, 0.49749],
    58113: [0, 0.62119, 0, 0, 0.4983],
    58114: [0.18906, 0.69141, 0, 0, 0.33328],
    58115: [0.18906, 0.69141, 0, 0, 0.32923],
    58116: [0.18906, 0.47534, 0, 0, 0.50343],
    58117: [0, 0.69141, 0, 0, 0.33301],
    58118: [0, 0.62119, 0, 0, 0.33409],
    58119: [0, 0.47534, 0, 0, 0.50073]
  },
  "Main-Bold": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.35],
    34: [0, 0.69444, 0, 0, 0.60278],
    35: [0.19444, 0.69444, 0, 0, 0.95833],
    36: [0.05556, 0.75, 0, 0, 0.575],
    37: [0.05556, 0.75, 0, 0, 0.95833],
    38: [0, 0.69444, 0, 0, 0.89444],
    39: [0, 0.69444, 0, 0, 0.31944],
    40: [0.25, 0.75, 0, 0, 0.44722],
    41: [0.25, 0.75, 0, 0, 0.44722],
    42: [0, 0.75, 0, 0, 0.575],
    43: [0.13333, 0.63333, 0, 0, 0.89444],
    44: [0.19444, 0.15556, 0, 0, 0.31944],
    45: [0, 0.44444, 0, 0, 0.38333],
    46: [0, 0.15556, 0, 0, 0.31944],
    47: [0.25, 0.75, 0, 0, 0.575],
    48: [0, 0.64444, 0, 0, 0.575],
    49: [0, 0.64444, 0, 0, 0.575],
    50: [0, 0.64444, 0, 0, 0.575],
    51: [0, 0.64444, 0, 0, 0.575],
    52: [0, 0.64444, 0, 0, 0.575],
    53: [0, 0.64444, 0, 0, 0.575],
    54: [0, 0.64444, 0, 0, 0.575],
    55: [0, 0.64444, 0, 0, 0.575],
    56: [0, 0.64444, 0, 0, 0.575],
    57: [0, 0.64444, 0, 0, 0.575],
    58: [0, 0.44444, 0, 0, 0.31944],
    59: [0.19444, 0.44444, 0, 0, 0.31944],
    60: [0.08556, 0.58556, 0, 0, 0.89444],
    61: [-0.10889, 0.39111, 0, 0, 0.89444],
    62: [0.08556, 0.58556, 0, 0, 0.89444],
    63: [0, 0.69444, 0, 0, 0.54305],
    64: [0, 0.69444, 0, 0, 0.89444],
    65: [0, 0.68611, 0, 0, 0.86944],
    66: [0, 0.68611, 0, 0, 0.81805],
    67: [0, 0.68611, 0, 0, 0.83055],
    68: [0, 0.68611, 0, 0, 0.88194],
    69: [0, 0.68611, 0, 0, 0.75555],
    70: [0, 0.68611, 0, 0, 0.72361],
    71: [0, 0.68611, 0, 0, 0.90416],
    72: [0, 0.68611, 0, 0, 0.9],
    73: [0, 0.68611, 0, 0, 0.43611],
    74: [0, 0.68611, 0, 0, 0.59444],
    75: [0, 0.68611, 0, 0, 0.90138],
    76: [0, 0.68611, 0, 0, 0.69166],
    77: [0, 0.68611, 0, 0, 1.09166],
    78: [0, 0.68611, 0, 0, 0.9],
    79: [0, 0.68611, 0, 0, 0.86388],
    80: [0, 0.68611, 0, 0, 0.78611],
    81: [0.19444, 0.68611, 0, 0, 0.86388],
    82: [0, 0.68611, 0, 0, 0.8625],
    83: [0, 0.68611, 0, 0, 0.63889],
    84: [0, 0.68611, 0, 0, 0.8],
    85: [0, 0.68611, 0, 0, 0.88472],
    86: [0, 0.68611, 0.01597, 0, 0.86944],
    87: [0, 0.68611, 0.01597, 0, 1.18888],
    88: [0, 0.68611, 0, 0, 0.86944],
    89: [0, 0.68611, 0.02875, 0, 0.86944],
    90: [0, 0.68611, 0, 0, 0.70277],
    91: [0.25, 0.75, 0, 0, 0.31944],
    92: [0.25, 0.75, 0, 0, 0.575],
    93: [0.25, 0.75, 0, 0, 0.31944],
    94: [0, 0.69444, 0, 0, 0.575],
    95: [0.31, 0.13444, 0.03194, 0, 0.575],
    97: [0, 0.44444, 0, 0, 0.55902],
    98: [0, 0.69444, 0, 0, 0.63889],
    99: [0, 0.44444, 0, 0, 0.51111],
    100: [0, 0.69444, 0, 0, 0.63889],
    101: [0, 0.44444, 0, 0, 0.52708],
    102: [0, 0.69444, 0.10903, 0, 0.35139],
    103: [0.19444, 0.44444, 0.01597, 0, 0.575],
    104: [0, 0.69444, 0, 0, 0.63889],
    105: [0, 0.69444, 0, 0, 0.31944],
    106: [0.19444, 0.69444, 0, 0, 0.35139],
    107: [0, 0.69444, 0, 0, 0.60694],
    108: [0, 0.69444, 0, 0, 0.31944],
    109: [0, 0.44444, 0, 0, 0.95833],
    110: [0, 0.44444, 0, 0, 0.63889],
    111: [0, 0.44444, 0, 0, 0.575],
    112: [0.19444, 0.44444, 0, 0, 0.63889],
    113: [0.19444, 0.44444, 0, 0, 0.60694],
    114: [0, 0.44444, 0, 0, 0.47361],
    115: [0, 0.44444, 0, 0, 0.45361],
    116: [0, 0.63492, 0, 0, 0.44722],
    117: [0, 0.44444, 0, 0, 0.63889],
    118: [0, 0.44444, 0.01597, 0, 0.60694],
    119: [0, 0.44444, 0.01597, 0, 0.83055],
    120: [0, 0.44444, 0, 0, 0.60694],
    121: [0.19444, 0.44444, 0.01597, 0, 0.60694],
    122: [0, 0.44444, 0, 0, 0.51111],
    123: [0.25, 0.75, 0, 0, 0.575],
    124: [0.25, 0.75, 0, 0, 0.31944],
    125: [0.25, 0.75, 0, 0, 0.575],
    126: [0.35, 0.34444, 0, 0, 0.575],
    160: [0, 0, 0, 0, 0.25],
    163: [0, 0.69444, 0, 0, 0.86853],
    168: [0, 0.69444, 0, 0, 0.575],
    172: [0, 0.44444, 0, 0, 0.76666],
    176: [0, 0.69444, 0, 0, 0.86944],
    177: [0.13333, 0.63333, 0, 0, 0.89444],
    184: [0.17014, 0, 0, 0, 0.51111],
    198: [0, 0.68611, 0, 0, 1.04166],
    215: [0.13333, 0.63333, 0, 0, 0.89444],
    216: [0.04861, 0.73472, 0, 0, 0.89444],
    223: [0, 0.69444, 0, 0, 0.59722],
    230: [0, 0.44444, 0, 0, 0.83055],
    247: [0.13333, 0.63333, 0, 0, 0.89444],
    248: [0.09722, 0.54167, 0, 0, 0.575],
    305: [0, 0.44444, 0, 0, 0.31944],
    338: [0, 0.68611, 0, 0, 1.16944],
    339: [0, 0.44444, 0, 0, 0.89444],
    567: [0.19444, 0.44444, 0, 0, 0.35139],
    710: [0, 0.69444, 0, 0, 0.575],
    711: [0, 0.63194, 0, 0, 0.575],
    713: [0, 0.59611, 0, 0, 0.575],
    714: [0, 0.69444, 0, 0, 0.575],
    715: [0, 0.69444, 0, 0, 0.575],
    728: [0, 0.69444, 0, 0, 0.575],
    729: [0, 0.69444, 0, 0, 0.31944],
    730: [0, 0.69444, 0, 0, 0.86944],
    732: [0, 0.69444, 0, 0, 0.575],
    733: [0, 0.69444, 0, 0, 0.575],
    915: [0, 0.68611, 0, 0, 0.69166],
    916: [0, 0.68611, 0, 0, 0.95833],
    920: [0, 0.68611, 0, 0, 0.89444],
    923: [0, 0.68611, 0, 0, 0.80555],
    926: [0, 0.68611, 0, 0, 0.76666],
    928: [0, 0.68611, 0, 0, 0.9],
    931: [0, 0.68611, 0, 0, 0.83055],
    933: [0, 0.68611, 0, 0, 0.89444],
    934: [0, 0.68611, 0, 0, 0.83055],
    936: [0, 0.68611, 0, 0, 0.89444],
    937: [0, 0.68611, 0, 0, 0.83055],
    8211: [0, 0.44444, 0.03194, 0, 0.575],
    8212: [0, 0.44444, 0.03194, 0, 1.14999],
    8216: [0, 0.69444, 0, 0, 0.31944],
    8217: [0, 0.69444, 0, 0, 0.31944],
    8220: [0, 0.69444, 0, 0, 0.60278],
    8221: [0, 0.69444, 0, 0, 0.60278],
    8224: [0.19444, 0.69444, 0, 0, 0.51111],
    8225: [0.19444, 0.69444, 0, 0, 0.51111],
    8242: [0, 0.55556, 0, 0, 0.34444],
    8407: [0, 0.72444, 0.15486, 0, 0.575],
    8463: [0, 0.69444, 0, 0, 0.66759],
    8465: [0, 0.69444, 0, 0, 0.83055],
    8467: [0, 0.69444, 0, 0, 0.47361],
    8472: [0.19444, 0.44444, 0, 0, 0.74027],
    8476: [0, 0.69444, 0, 0, 0.83055],
    8501: [0, 0.69444, 0, 0, 0.70277],
    8592: [-0.10889, 0.39111, 0, 0, 1.14999],
    8593: [0.19444, 0.69444, 0, 0, 0.575],
    8594: [-0.10889, 0.39111, 0, 0, 1.14999],
    8595: [0.19444, 0.69444, 0, 0, 0.575],
    8596: [-0.10889, 0.39111, 0, 0, 1.14999],
    8597: [0.25, 0.75, 0, 0, 0.575],
    8598: [0.19444, 0.69444, 0, 0, 1.14999],
    8599: [0.19444, 0.69444, 0, 0, 1.14999],
    8600: [0.19444, 0.69444, 0, 0, 1.14999],
    8601: [0.19444, 0.69444, 0, 0, 1.14999],
    8636: [-0.10889, 0.39111, 0, 0, 1.14999],
    8637: [-0.10889, 0.39111, 0, 0, 1.14999],
    8640: [-0.10889, 0.39111, 0, 0, 1.14999],
    8641: [-0.10889, 0.39111, 0, 0, 1.14999],
    8656: [-0.10889, 0.39111, 0, 0, 1.14999],
    8657: [0.19444, 0.69444, 0, 0, 0.70277],
    8658: [-0.10889, 0.39111, 0, 0, 1.14999],
    8659: [0.19444, 0.69444, 0, 0, 0.70277],
    8660: [-0.10889, 0.39111, 0, 0, 1.14999],
    8661: [0.25, 0.75, 0, 0, 0.70277],
    8704: [0, 0.69444, 0, 0, 0.63889],
    8706: [0, 0.69444, 0.06389, 0, 0.62847],
    8707: [0, 0.69444, 0, 0, 0.63889],
    8709: [0.05556, 0.75, 0, 0, 0.575],
    8711: [0, 0.68611, 0, 0, 0.95833],
    8712: [0.08556, 0.58556, 0, 0, 0.76666],
    8715: [0.08556, 0.58556, 0, 0, 0.76666],
    8722: [0.13333, 0.63333, 0, 0, 0.89444],
    8723: [0.13333, 0.63333, 0, 0, 0.89444],
    8725: [0.25, 0.75, 0, 0, 0.575],
    8726: [0.25, 0.75, 0, 0, 0.575],
    8727: [-0.02778, 0.47222, 0, 0, 0.575],
    8728: [-0.02639, 0.47361, 0, 0, 0.575],
    8729: [-0.02639, 0.47361, 0, 0, 0.575],
    8730: [0.18, 0.82, 0, 0, 0.95833],
    8733: [0, 0.44444, 0, 0, 0.89444],
    8734: [0, 0.44444, 0, 0, 1.14999],
    8736: [0, 0.69224, 0, 0, 0.72222],
    8739: [0.25, 0.75, 0, 0, 0.31944],
    8741: [0.25, 0.75, 0, 0, 0.575],
    8743: [0, 0.55556, 0, 0, 0.76666],
    8744: [0, 0.55556, 0, 0, 0.76666],
    8745: [0, 0.55556, 0, 0, 0.76666],
    8746: [0, 0.55556, 0, 0, 0.76666],
    8747: [0.19444, 0.69444, 0.12778, 0, 0.56875],
    8764: [-0.10889, 0.39111, 0, 0, 0.89444],
    8768: [0.19444, 0.69444, 0, 0, 0.31944],
    8771: [222e-5, 0.50222, 0, 0, 0.89444],
    8773: [0.027, 0.638, 0, 0, 0.894],
    8776: [0.02444, 0.52444, 0, 0, 0.89444],
    8781: [222e-5, 0.50222, 0, 0, 0.89444],
    8801: [222e-5, 0.50222, 0, 0, 0.89444],
    8804: [0.19667, 0.69667, 0, 0, 0.89444],
    8805: [0.19667, 0.69667, 0, 0, 0.89444],
    8810: [0.08556, 0.58556, 0, 0, 1.14999],
    8811: [0.08556, 0.58556, 0, 0, 1.14999],
    8826: [0.08556, 0.58556, 0, 0, 0.89444],
    8827: [0.08556, 0.58556, 0, 0, 0.89444],
    8834: [0.08556, 0.58556, 0, 0, 0.89444],
    8835: [0.08556, 0.58556, 0, 0, 0.89444],
    8838: [0.19667, 0.69667, 0, 0, 0.89444],
    8839: [0.19667, 0.69667, 0, 0, 0.89444],
    8846: [0, 0.55556, 0, 0, 0.76666],
    8849: [0.19667, 0.69667, 0, 0, 0.89444],
    8850: [0.19667, 0.69667, 0, 0, 0.89444],
    8851: [0, 0.55556, 0, 0, 0.76666],
    8852: [0, 0.55556, 0, 0, 0.76666],
    8853: [0.13333, 0.63333, 0, 0, 0.89444],
    8854: [0.13333, 0.63333, 0, 0, 0.89444],
    8855: [0.13333, 0.63333, 0, 0, 0.89444],
    8856: [0.13333, 0.63333, 0, 0, 0.89444],
    8857: [0.13333, 0.63333, 0, 0, 0.89444],
    8866: [0, 0.69444, 0, 0, 0.70277],
    8867: [0, 0.69444, 0, 0, 0.70277],
    8868: [0, 0.69444, 0, 0, 0.89444],
    8869: [0, 0.69444, 0, 0, 0.89444],
    8900: [-0.02639, 0.47361, 0, 0, 0.575],
    8901: [-0.02639, 0.47361, 0, 0, 0.31944],
    8902: [-0.02778, 0.47222, 0, 0, 0.575],
    8968: [0.25, 0.75, 0, 0, 0.51111],
    8969: [0.25, 0.75, 0, 0, 0.51111],
    8970: [0.25, 0.75, 0, 0, 0.51111],
    8971: [0.25, 0.75, 0, 0, 0.51111],
    8994: [-0.13889, 0.36111, 0, 0, 1.14999],
    8995: [-0.13889, 0.36111, 0, 0, 1.14999],
    9651: [0.19444, 0.69444, 0, 0, 1.02222],
    9657: [-0.02778, 0.47222, 0, 0, 0.575],
    9661: [0.19444, 0.69444, 0, 0, 1.02222],
    9667: [-0.02778, 0.47222, 0, 0, 0.575],
    9711: [0.19444, 0.69444, 0, 0, 1.14999],
    9824: [0.12963, 0.69444, 0, 0, 0.89444],
    9825: [0.12963, 0.69444, 0, 0, 0.89444],
    9826: [0.12963, 0.69444, 0, 0, 0.89444],
    9827: [0.12963, 0.69444, 0, 0, 0.89444],
    9837: [0, 0.75, 0, 0, 0.44722],
    9838: [0.19444, 0.69444, 0, 0, 0.44722],
    9839: [0.19444, 0.69444, 0, 0, 0.44722],
    10216: [0.25, 0.75, 0, 0, 0.44722],
    10217: [0.25, 0.75, 0, 0, 0.44722],
    10815: [0, 0.68611, 0, 0, 0.9],
    10927: [0.19667, 0.69667, 0, 0, 0.89444],
    10928: [0.19667, 0.69667, 0, 0, 0.89444],
    57376: [0.19444, 0.69444, 0, 0, 0]
  },
  "Main-BoldItalic": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0.11417, 0, 0.38611],
    34: [0, 0.69444, 0.07939, 0, 0.62055],
    35: [0.19444, 0.69444, 0.06833, 0, 0.94444],
    37: [0.05556, 0.75, 0.12861, 0, 0.94444],
    38: [0, 0.69444, 0.08528, 0, 0.88555],
    39: [0, 0.69444, 0.12945, 0, 0.35555],
    40: [0.25, 0.75, 0.15806, 0, 0.47333],
    41: [0.25, 0.75, 0.03306, 0, 0.47333],
    42: [0, 0.75, 0.14333, 0, 0.59111],
    43: [0.10333, 0.60333, 0.03306, 0, 0.88555],
    44: [0.19444, 0.14722, 0, 0, 0.35555],
    45: [0, 0.44444, 0.02611, 0, 0.41444],
    46: [0, 0.14722, 0, 0, 0.35555],
    47: [0.25, 0.75, 0.15806, 0, 0.59111],
    48: [0, 0.64444, 0.13167, 0, 0.59111],
    49: [0, 0.64444, 0.13167, 0, 0.59111],
    50: [0, 0.64444, 0.13167, 0, 0.59111],
    51: [0, 0.64444, 0.13167, 0, 0.59111],
    52: [0.19444, 0.64444, 0.13167, 0, 0.59111],
    53: [0, 0.64444, 0.13167, 0, 0.59111],
    54: [0, 0.64444, 0.13167, 0, 0.59111],
    55: [0.19444, 0.64444, 0.13167, 0, 0.59111],
    56: [0, 0.64444, 0.13167, 0, 0.59111],
    57: [0, 0.64444, 0.13167, 0, 0.59111],
    58: [0, 0.44444, 0.06695, 0, 0.35555],
    59: [0.19444, 0.44444, 0.06695, 0, 0.35555],
    61: [-0.10889, 0.39111, 0.06833, 0, 0.88555],
    63: [0, 0.69444, 0.11472, 0, 0.59111],
    64: [0, 0.69444, 0.09208, 0, 0.88555],
    65: [0, 0.68611, 0, 0, 0.86555],
    66: [0, 0.68611, 0.0992, 0, 0.81666],
    67: [0, 0.68611, 0.14208, 0, 0.82666],
    68: [0, 0.68611, 0.09062, 0, 0.87555],
    69: [0, 0.68611, 0.11431, 0, 0.75666],
    70: [0, 0.68611, 0.12903, 0, 0.72722],
    71: [0, 0.68611, 0.07347, 0, 0.89527],
    72: [0, 0.68611, 0.17208, 0, 0.8961],
    73: [0, 0.68611, 0.15681, 0, 0.47166],
    74: [0, 0.68611, 0.145, 0, 0.61055],
    75: [0, 0.68611, 0.14208, 0, 0.89499],
    76: [0, 0.68611, 0, 0, 0.69777],
    77: [0, 0.68611, 0.17208, 0, 1.07277],
    78: [0, 0.68611, 0.17208, 0, 0.8961],
    79: [0, 0.68611, 0.09062, 0, 0.85499],
    80: [0, 0.68611, 0.0992, 0, 0.78721],
    81: [0.19444, 0.68611, 0.09062, 0, 0.85499],
    82: [0, 0.68611, 0.02559, 0, 0.85944],
    83: [0, 0.68611, 0.11264, 0, 0.64999],
    84: [0, 0.68611, 0.12903, 0, 0.7961],
    85: [0, 0.68611, 0.17208, 0, 0.88083],
    86: [0, 0.68611, 0.18625, 0, 0.86555],
    87: [0, 0.68611, 0.18625, 0, 1.15999],
    88: [0, 0.68611, 0.15681, 0, 0.86555],
    89: [0, 0.68611, 0.19803, 0, 0.86555],
    90: [0, 0.68611, 0.14208, 0, 0.70888],
    91: [0.25, 0.75, 0.1875, 0, 0.35611],
    93: [0.25, 0.75, 0.09972, 0, 0.35611],
    94: [0, 0.69444, 0.06709, 0, 0.59111],
    95: [0.31, 0.13444, 0.09811, 0, 0.59111],
    97: [0, 0.44444, 0.09426, 0, 0.59111],
    98: [0, 0.69444, 0.07861, 0, 0.53222],
    99: [0, 0.44444, 0.05222, 0, 0.53222],
    100: [0, 0.69444, 0.10861, 0, 0.59111],
    101: [0, 0.44444, 0.085, 0, 0.53222],
    102: [0.19444, 0.69444, 0.21778, 0, 0.4],
    103: [0.19444, 0.44444, 0.105, 0, 0.53222],
    104: [0, 0.69444, 0.09426, 0, 0.59111],
    105: [0, 0.69326, 0.11387, 0, 0.35555],
    106: [0.19444, 0.69326, 0.1672, 0, 0.35555],
    107: [0, 0.69444, 0.11111, 0, 0.53222],
    108: [0, 0.69444, 0.10861, 0, 0.29666],
    109: [0, 0.44444, 0.09426, 0, 0.94444],
    110: [0, 0.44444, 0.09426, 0, 0.64999],
    111: [0, 0.44444, 0.07861, 0, 0.59111],
    112: [0.19444, 0.44444, 0.07861, 0, 0.59111],
    113: [0.19444, 0.44444, 0.105, 0, 0.53222],
    114: [0, 0.44444, 0.11111, 0, 0.50167],
    115: [0, 0.44444, 0.08167, 0, 0.48694],
    116: [0, 0.63492, 0.09639, 0, 0.385],
    117: [0, 0.44444, 0.09426, 0, 0.62055],
    118: [0, 0.44444, 0.11111, 0, 0.53222],
    119: [0, 0.44444, 0.11111, 0, 0.76777],
    120: [0, 0.44444, 0.12583, 0, 0.56055],
    121: [0.19444, 0.44444, 0.105, 0, 0.56166],
    122: [0, 0.44444, 0.13889, 0, 0.49055],
    126: [0.35, 0.34444, 0.11472, 0, 0.59111],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.69444, 0.11473, 0, 0.59111],
    176: [0, 0.69444, 0, 0, 0.94888],
    184: [0.17014, 0, 0, 0, 0.53222],
    198: [0, 0.68611, 0.11431, 0, 1.02277],
    216: [0.04861, 0.73472, 0.09062, 0, 0.88555],
    223: [0.19444, 0.69444, 0.09736, 0, 0.665],
    230: [0, 0.44444, 0.085, 0, 0.82666],
    248: [0.09722, 0.54167, 0.09458, 0, 0.59111],
    305: [0, 0.44444, 0.09426, 0, 0.35555],
    338: [0, 0.68611, 0.11431, 0, 1.14054],
    339: [0, 0.44444, 0.085, 0, 0.82666],
    567: [0.19444, 0.44444, 0.04611, 0, 0.385],
    710: [0, 0.69444, 0.06709, 0, 0.59111],
    711: [0, 0.63194, 0.08271, 0, 0.59111],
    713: [0, 0.59444, 0.10444, 0, 0.59111],
    714: [0, 0.69444, 0.08528, 0, 0.59111],
    715: [0, 0.69444, 0, 0, 0.59111],
    728: [0, 0.69444, 0.10333, 0, 0.59111],
    729: [0, 0.69444, 0.12945, 0, 0.35555],
    730: [0, 0.69444, 0, 0, 0.94888],
    732: [0, 0.69444, 0.11472, 0, 0.59111],
    733: [0, 0.69444, 0.11472, 0, 0.59111],
    915: [0, 0.68611, 0.12903, 0, 0.69777],
    916: [0, 0.68611, 0, 0, 0.94444],
    920: [0, 0.68611, 0.09062, 0, 0.88555],
    923: [0, 0.68611, 0, 0, 0.80666],
    926: [0, 0.68611, 0.15092, 0, 0.76777],
    928: [0, 0.68611, 0.17208, 0, 0.8961],
    931: [0, 0.68611, 0.11431, 0, 0.82666],
    933: [0, 0.68611, 0.10778, 0, 0.88555],
    934: [0, 0.68611, 0.05632, 0, 0.82666],
    936: [0, 0.68611, 0.10778, 0, 0.88555],
    937: [0, 0.68611, 0.0992, 0, 0.82666],
    8211: [0, 0.44444, 0.09811, 0, 0.59111],
    8212: [0, 0.44444, 0.09811, 0, 1.18221],
    8216: [0, 0.69444, 0.12945, 0, 0.35555],
    8217: [0, 0.69444, 0.12945, 0, 0.35555],
    8220: [0, 0.69444, 0.16772, 0, 0.62055],
    8221: [0, 0.69444, 0.07939, 0, 0.62055]
  },
  "Main-Italic": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0.12417, 0, 0.30667],
    34: [0, 0.69444, 0.06961, 0, 0.51444],
    35: [0.19444, 0.69444, 0.06616, 0, 0.81777],
    37: [0.05556, 0.75, 0.13639, 0, 0.81777],
    38: [0, 0.69444, 0.09694, 0, 0.76666],
    39: [0, 0.69444, 0.12417, 0, 0.30667],
    40: [0.25, 0.75, 0.16194, 0, 0.40889],
    41: [0.25, 0.75, 0.03694, 0, 0.40889],
    42: [0, 0.75, 0.14917, 0, 0.51111],
    43: [0.05667, 0.56167, 0.03694, 0, 0.76666],
    44: [0.19444, 0.10556, 0, 0, 0.30667],
    45: [0, 0.43056, 0.02826, 0, 0.35778],
    46: [0, 0.10556, 0, 0, 0.30667],
    47: [0.25, 0.75, 0.16194, 0, 0.51111],
    48: [0, 0.64444, 0.13556, 0, 0.51111],
    49: [0, 0.64444, 0.13556, 0, 0.51111],
    50: [0, 0.64444, 0.13556, 0, 0.51111],
    51: [0, 0.64444, 0.13556, 0, 0.51111],
    52: [0.19444, 0.64444, 0.13556, 0, 0.51111],
    53: [0, 0.64444, 0.13556, 0, 0.51111],
    54: [0, 0.64444, 0.13556, 0, 0.51111],
    55: [0.19444, 0.64444, 0.13556, 0, 0.51111],
    56: [0, 0.64444, 0.13556, 0, 0.51111],
    57: [0, 0.64444, 0.13556, 0, 0.51111],
    58: [0, 0.43056, 0.0582, 0, 0.30667],
    59: [0.19444, 0.43056, 0.0582, 0, 0.30667],
    61: [-0.13313, 0.36687, 0.06616, 0, 0.76666],
    63: [0, 0.69444, 0.1225, 0, 0.51111],
    64: [0, 0.69444, 0.09597, 0, 0.76666],
    65: [0, 0.68333, 0, 0, 0.74333],
    66: [0, 0.68333, 0.10257, 0, 0.70389],
    67: [0, 0.68333, 0.14528, 0, 0.71555],
    68: [0, 0.68333, 0.09403, 0, 0.755],
    69: [0, 0.68333, 0.12028, 0, 0.67833],
    70: [0, 0.68333, 0.13305, 0, 0.65277],
    71: [0, 0.68333, 0.08722, 0, 0.77361],
    72: [0, 0.68333, 0.16389, 0, 0.74333],
    73: [0, 0.68333, 0.15806, 0, 0.38555],
    74: [0, 0.68333, 0.14028, 0, 0.525],
    75: [0, 0.68333, 0.14528, 0, 0.76888],
    76: [0, 0.68333, 0, 0, 0.62722],
    77: [0, 0.68333, 0.16389, 0, 0.89666],
    78: [0, 0.68333, 0.16389, 0, 0.74333],
    79: [0, 0.68333, 0.09403, 0, 0.76666],
    80: [0, 0.68333, 0.10257, 0, 0.67833],
    81: [0.19444, 0.68333, 0.09403, 0, 0.76666],
    82: [0, 0.68333, 0.03868, 0, 0.72944],
    83: [0, 0.68333, 0.11972, 0, 0.56222],
    84: [0, 0.68333, 0.13305, 0, 0.71555],
    85: [0, 0.68333, 0.16389, 0, 0.74333],
    86: [0, 0.68333, 0.18361, 0, 0.74333],
    87: [0, 0.68333, 0.18361, 0, 0.99888],
    88: [0, 0.68333, 0.15806, 0, 0.74333],
    89: [0, 0.68333, 0.19383, 0, 0.74333],
    90: [0, 0.68333, 0.14528, 0, 0.61333],
    91: [0.25, 0.75, 0.1875, 0, 0.30667],
    93: [0.25, 0.75, 0.10528, 0, 0.30667],
    94: [0, 0.69444, 0.06646, 0, 0.51111],
    95: [0.31, 0.12056, 0.09208, 0, 0.51111],
    97: [0, 0.43056, 0.07671, 0, 0.51111],
    98: [0, 0.69444, 0.06312, 0, 0.46],
    99: [0, 0.43056, 0.05653, 0, 0.46],
    100: [0, 0.69444, 0.10333, 0, 0.51111],
    101: [0, 0.43056, 0.07514, 0, 0.46],
    102: [0.19444, 0.69444, 0.21194, 0, 0.30667],
    103: [0.19444, 0.43056, 0.08847, 0, 0.46],
    104: [0, 0.69444, 0.07671, 0, 0.51111],
    105: [0, 0.65536, 0.1019, 0, 0.30667],
    106: [0.19444, 0.65536, 0.14467, 0, 0.30667],
    107: [0, 0.69444, 0.10764, 0, 0.46],
    108: [0, 0.69444, 0.10333, 0, 0.25555],
    109: [0, 0.43056, 0.07671, 0, 0.81777],
    110: [0, 0.43056, 0.07671, 0, 0.56222],
    111: [0, 0.43056, 0.06312, 0, 0.51111],
    112: [0.19444, 0.43056, 0.06312, 0, 0.51111],
    113: [0.19444, 0.43056, 0.08847, 0, 0.46],
    114: [0, 0.43056, 0.10764, 0, 0.42166],
    115: [0, 0.43056, 0.08208, 0, 0.40889],
    116: [0, 0.61508, 0.09486, 0, 0.33222],
    117: [0, 0.43056, 0.07671, 0, 0.53666],
    118: [0, 0.43056, 0.10764, 0, 0.46],
    119: [0, 0.43056, 0.10764, 0, 0.66444],
    120: [0, 0.43056, 0.12042, 0, 0.46389],
    121: [0.19444, 0.43056, 0.08847, 0, 0.48555],
    122: [0, 0.43056, 0.12292, 0, 0.40889],
    126: [0.35, 0.31786, 0.11585, 0, 0.51111],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.66786, 0.10474, 0, 0.51111],
    176: [0, 0.69444, 0, 0, 0.83129],
    184: [0.17014, 0, 0, 0, 0.46],
    198: [0, 0.68333, 0.12028, 0, 0.88277],
    216: [0.04861, 0.73194, 0.09403, 0, 0.76666],
    223: [0.19444, 0.69444, 0.10514, 0, 0.53666],
    230: [0, 0.43056, 0.07514, 0, 0.71555],
    248: [0.09722, 0.52778, 0.09194, 0, 0.51111],
    338: [0, 0.68333, 0.12028, 0, 0.98499],
    339: [0, 0.43056, 0.07514, 0, 0.71555],
    710: [0, 0.69444, 0.06646, 0, 0.51111],
    711: [0, 0.62847, 0.08295, 0, 0.51111],
    713: [0, 0.56167, 0.10333, 0, 0.51111],
    714: [0, 0.69444, 0.09694, 0, 0.51111],
    715: [0, 0.69444, 0, 0, 0.51111],
    728: [0, 0.69444, 0.10806, 0, 0.51111],
    729: [0, 0.66786, 0.11752, 0, 0.30667],
    730: [0, 0.69444, 0, 0, 0.83129],
    732: [0, 0.66786, 0.11585, 0, 0.51111],
    733: [0, 0.69444, 0.1225, 0, 0.51111],
    915: [0, 0.68333, 0.13305, 0, 0.62722],
    916: [0, 0.68333, 0, 0, 0.81777],
    920: [0, 0.68333, 0.09403, 0, 0.76666],
    923: [0, 0.68333, 0, 0, 0.69222],
    926: [0, 0.68333, 0.15294, 0, 0.66444],
    928: [0, 0.68333, 0.16389, 0, 0.74333],
    931: [0, 0.68333, 0.12028, 0, 0.71555],
    933: [0, 0.68333, 0.11111, 0, 0.76666],
    934: [0, 0.68333, 0.05986, 0, 0.71555],
    936: [0, 0.68333, 0.11111, 0, 0.76666],
    937: [0, 0.68333, 0.10257, 0, 0.71555],
    8211: [0, 0.43056, 0.09208, 0, 0.51111],
    8212: [0, 0.43056, 0.09208, 0, 1.02222],
    8216: [0, 0.69444, 0.12417, 0, 0.30667],
    8217: [0, 0.69444, 0.12417, 0, 0.30667],
    8220: [0, 0.69444, 0.1685, 0, 0.51444],
    8221: [0, 0.69444, 0.06961, 0, 0.51444],
    8463: [0, 0.68889, 0, 0, 0.54028]
  },
  "Main-Regular": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.27778],
    34: [0, 0.69444, 0, 0, 0.5],
    35: [0.19444, 0.69444, 0, 0, 0.83334],
    36: [0.05556, 0.75, 0, 0, 0.5],
    37: [0.05556, 0.75, 0, 0, 0.83334],
    38: [0, 0.69444, 0, 0, 0.77778],
    39: [0, 0.69444, 0, 0, 0.27778],
    40: [0.25, 0.75, 0, 0, 0.38889],
    41: [0.25, 0.75, 0, 0, 0.38889],
    42: [0, 0.75, 0, 0, 0.5],
    43: [0.08333, 0.58333, 0, 0, 0.77778],
    44: [0.19444, 0.10556, 0, 0, 0.27778],
    45: [0, 0.43056, 0, 0, 0.33333],
    46: [0, 0.10556, 0, 0, 0.27778],
    47: [0.25, 0.75, 0, 0, 0.5],
    48: [0, 0.64444, 0, 0, 0.5],
    49: [0, 0.64444, 0, 0, 0.5],
    50: [0, 0.64444, 0, 0, 0.5],
    51: [0, 0.64444, 0, 0, 0.5],
    52: [0, 0.64444, 0, 0, 0.5],
    53: [0, 0.64444, 0, 0, 0.5],
    54: [0, 0.64444, 0, 0, 0.5],
    55: [0, 0.64444, 0, 0, 0.5],
    56: [0, 0.64444, 0, 0, 0.5],
    57: [0, 0.64444, 0, 0, 0.5],
    58: [0, 0.43056, 0, 0, 0.27778],
    59: [0.19444, 0.43056, 0, 0, 0.27778],
    60: [0.0391, 0.5391, 0, 0, 0.77778],
    61: [-0.13313, 0.36687, 0, 0, 0.77778],
    62: [0.0391, 0.5391, 0, 0, 0.77778],
    63: [0, 0.69444, 0, 0, 0.47222],
    64: [0, 0.69444, 0, 0, 0.77778],
    65: [0, 0.68333, 0, 0, 0.75],
    66: [0, 0.68333, 0, 0, 0.70834],
    67: [0, 0.68333, 0, 0, 0.72222],
    68: [0, 0.68333, 0, 0, 0.76389],
    69: [0, 0.68333, 0, 0, 0.68056],
    70: [0, 0.68333, 0, 0, 0.65278],
    71: [0, 0.68333, 0, 0, 0.78472],
    72: [0, 0.68333, 0, 0, 0.75],
    73: [0, 0.68333, 0, 0, 0.36111],
    74: [0, 0.68333, 0, 0, 0.51389],
    75: [0, 0.68333, 0, 0, 0.77778],
    76: [0, 0.68333, 0, 0, 0.625],
    77: [0, 0.68333, 0, 0, 0.91667],
    78: [0, 0.68333, 0, 0, 0.75],
    79: [0, 0.68333, 0, 0, 0.77778],
    80: [0, 0.68333, 0, 0, 0.68056],
    81: [0.19444, 0.68333, 0, 0, 0.77778],
    82: [0, 0.68333, 0, 0, 0.73611],
    83: [0, 0.68333, 0, 0, 0.55556],
    84: [0, 0.68333, 0, 0, 0.72222],
    85: [0, 0.68333, 0, 0, 0.75],
    86: [0, 0.68333, 0.01389, 0, 0.75],
    87: [0, 0.68333, 0.01389, 0, 1.02778],
    88: [0, 0.68333, 0, 0, 0.75],
    89: [0, 0.68333, 0.025, 0, 0.75],
    90: [0, 0.68333, 0, 0, 0.61111],
    91: [0.25, 0.75, 0, 0, 0.27778],
    92: [0.25, 0.75, 0, 0, 0.5],
    93: [0.25, 0.75, 0, 0, 0.27778],
    94: [0, 0.69444, 0, 0, 0.5],
    95: [0.31, 0.12056, 0.02778, 0, 0.5],
    97: [0, 0.43056, 0, 0, 0.5],
    98: [0, 0.69444, 0, 0, 0.55556],
    99: [0, 0.43056, 0, 0, 0.44445],
    100: [0, 0.69444, 0, 0, 0.55556],
    101: [0, 0.43056, 0, 0, 0.44445],
    102: [0, 0.69444, 0.07778, 0, 0.30556],
    103: [0.19444, 0.43056, 0.01389, 0, 0.5],
    104: [0, 0.69444, 0, 0, 0.55556],
    105: [0, 0.66786, 0, 0, 0.27778],
    106: [0.19444, 0.66786, 0, 0, 0.30556],
    107: [0, 0.69444, 0, 0, 0.52778],
    108: [0, 0.69444, 0, 0, 0.27778],
    109: [0, 0.43056, 0, 0, 0.83334],
    110: [0, 0.43056, 0, 0, 0.55556],
    111: [0, 0.43056, 0, 0, 0.5],
    112: [0.19444, 0.43056, 0, 0, 0.55556],
    113: [0.19444, 0.43056, 0, 0, 0.52778],
    114: [0, 0.43056, 0, 0, 0.39167],
    115: [0, 0.43056, 0, 0, 0.39445],
    116: [0, 0.61508, 0, 0, 0.38889],
    117: [0, 0.43056, 0, 0, 0.55556],
    118: [0, 0.43056, 0.01389, 0, 0.52778],
    119: [0, 0.43056, 0.01389, 0, 0.72222],
    120: [0, 0.43056, 0, 0, 0.52778],
    121: [0.19444, 0.43056, 0.01389, 0, 0.52778],
    122: [0, 0.43056, 0, 0, 0.44445],
    123: [0.25, 0.75, 0, 0, 0.5],
    124: [0.25, 0.75, 0, 0, 0.27778],
    125: [0.25, 0.75, 0, 0, 0.5],
    126: [0.35, 0.31786, 0, 0, 0.5],
    160: [0, 0, 0, 0, 0.25],
    163: [0, 0.69444, 0, 0, 0.76909],
    167: [0.19444, 0.69444, 0, 0, 0.44445],
    168: [0, 0.66786, 0, 0, 0.5],
    172: [0, 0.43056, 0, 0, 0.66667],
    176: [0, 0.69444, 0, 0, 0.75],
    177: [0.08333, 0.58333, 0, 0, 0.77778],
    182: [0.19444, 0.69444, 0, 0, 0.61111],
    184: [0.17014, 0, 0, 0, 0.44445],
    198: [0, 0.68333, 0, 0, 0.90278],
    215: [0.08333, 0.58333, 0, 0, 0.77778],
    216: [0.04861, 0.73194, 0, 0, 0.77778],
    223: [0, 0.69444, 0, 0, 0.5],
    230: [0, 0.43056, 0, 0, 0.72222],
    247: [0.08333, 0.58333, 0, 0, 0.77778],
    248: [0.09722, 0.52778, 0, 0, 0.5],
    305: [0, 0.43056, 0, 0, 0.27778],
    338: [0, 0.68333, 0, 0, 1.01389],
    339: [0, 0.43056, 0, 0, 0.77778],
    567: [0.19444, 0.43056, 0, 0, 0.30556],
    710: [0, 0.69444, 0, 0, 0.5],
    711: [0, 0.62847, 0, 0, 0.5],
    713: [0, 0.56778, 0, 0, 0.5],
    714: [0, 0.69444, 0, 0, 0.5],
    715: [0, 0.69444, 0, 0, 0.5],
    728: [0, 0.69444, 0, 0, 0.5],
    729: [0, 0.66786, 0, 0, 0.27778],
    730: [0, 0.69444, 0, 0, 0.75],
    732: [0, 0.66786, 0, 0, 0.5],
    733: [0, 0.69444, 0, 0, 0.5],
    915: [0, 0.68333, 0, 0, 0.625],
    916: [0, 0.68333, 0, 0, 0.83334],
    920: [0, 0.68333, 0, 0, 0.77778],
    923: [0, 0.68333, 0, 0, 0.69445],
    926: [0, 0.68333, 0, 0, 0.66667],
    928: [0, 0.68333, 0, 0, 0.75],
    931: [0, 0.68333, 0, 0, 0.72222],
    933: [0, 0.68333, 0, 0, 0.77778],
    934: [0, 0.68333, 0, 0, 0.72222],
    936: [0, 0.68333, 0, 0, 0.77778],
    937: [0, 0.68333, 0, 0, 0.72222],
    8211: [0, 0.43056, 0.02778, 0, 0.5],
    8212: [0, 0.43056, 0.02778, 0, 1],
    8216: [0, 0.69444, 0, 0, 0.27778],
    8217: [0, 0.69444, 0, 0, 0.27778],
    8220: [0, 0.69444, 0, 0, 0.5],
    8221: [0, 0.69444, 0, 0, 0.5],
    8224: [0.19444, 0.69444, 0, 0, 0.44445],
    8225: [0.19444, 0.69444, 0, 0, 0.44445],
    8230: [0, 0.123, 0, 0, 1.172],
    8242: [0, 0.55556, 0, 0, 0.275],
    8407: [0, 0.71444, 0.15382, 0, 0.5],
    8463: [0, 0.68889, 0, 0, 0.54028],
    8465: [0, 0.69444, 0, 0, 0.72222],
    8467: [0, 0.69444, 0, 0.11111, 0.41667],
    8472: [0.19444, 0.43056, 0, 0.11111, 0.63646],
    8476: [0, 0.69444, 0, 0, 0.72222],
    8501: [0, 0.69444, 0, 0, 0.61111],
    8592: [-0.13313, 0.36687, 0, 0, 1],
    8593: [0.19444, 0.69444, 0, 0, 0.5],
    8594: [-0.13313, 0.36687, 0, 0, 1],
    8595: [0.19444, 0.69444, 0, 0, 0.5],
    8596: [-0.13313, 0.36687, 0, 0, 1],
    8597: [0.25, 0.75, 0, 0, 0.5],
    8598: [0.19444, 0.69444, 0, 0, 1],
    8599: [0.19444, 0.69444, 0, 0, 1],
    8600: [0.19444, 0.69444, 0, 0, 1],
    8601: [0.19444, 0.69444, 0, 0, 1],
    8614: [0.011, 0.511, 0, 0, 1],
    8617: [0.011, 0.511, 0, 0, 1.126],
    8618: [0.011, 0.511, 0, 0, 1.126],
    8636: [-0.13313, 0.36687, 0, 0, 1],
    8637: [-0.13313, 0.36687, 0, 0, 1],
    8640: [-0.13313, 0.36687, 0, 0, 1],
    8641: [-0.13313, 0.36687, 0, 0, 1],
    8652: [0.011, 0.671, 0, 0, 1],
    8656: [-0.13313, 0.36687, 0, 0, 1],
    8657: [0.19444, 0.69444, 0, 0, 0.61111],
    8658: [-0.13313, 0.36687, 0, 0, 1],
    8659: [0.19444, 0.69444, 0, 0, 0.61111],
    8660: [-0.13313, 0.36687, 0, 0, 1],
    8661: [0.25, 0.75, 0, 0, 0.61111],
    8704: [0, 0.69444, 0, 0, 0.55556],
    8706: [0, 0.69444, 0.05556, 0.08334, 0.5309],
    8707: [0, 0.69444, 0, 0, 0.55556],
    8709: [0.05556, 0.75, 0, 0, 0.5],
    8711: [0, 0.68333, 0, 0, 0.83334],
    8712: [0.0391, 0.5391, 0, 0, 0.66667],
    8715: [0.0391, 0.5391, 0, 0, 0.66667],
    8722: [0.08333, 0.58333, 0, 0, 0.77778],
    8723: [0.08333, 0.58333, 0, 0, 0.77778],
    8725: [0.25, 0.75, 0, 0, 0.5],
    8726: [0.25, 0.75, 0, 0, 0.5],
    8727: [-0.03472, 0.46528, 0, 0, 0.5],
    8728: [-0.05555, 0.44445, 0, 0, 0.5],
    8729: [-0.05555, 0.44445, 0, 0, 0.5],
    8730: [0.2, 0.8, 0, 0, 0.83334],
    8733: [0, 0.43056, 0, 0, 0.77778],
    8734: [0, 0.43056, 0, 0, 1],
    8736: [0, 0.69224, 0, 0, 0.72222],
    8739: [0.25, 0.75, 0, 0, 0.27778],
    8741: [0.25, 0.75, 0, 0, 0.5],
    8743: [0, 0.55556, 0, 0, 0.66667],
    8744: [0, 0.55556, 0, 0, 0.66667],
    8745: [0, 0.55556, 0, 0, 0.66667],
    8746: [0, 0.55556, 0, 0, 0.66667],
    8747: [0.19444, 0.69444, 0.11111, 0, 0.41667],
    8764: [-0.13313, 0.36687, 0, 0, 0.77778],
    8768: [0.19444, 0.69444, 0, 0, 0.27778],
    8771: [-0.03625, 0.46375, 0, 0, 0.77778],
    8773: [-0.022, 0.589, 0, 0, 0.778],
    8776: [-0.01688, 0.48312, 0, 0, 0.77778],
    8781: [-0.03625, 0.46375, 0, 0, 0.77778],
    8784: [-0.133, 0.673, 0, 0, 0.778],
    8801: [-0.03625, 0.46375, 0, 0, 0.77778],
    8804: [0.13597, 0.63597, 0, 0, 0.77778],
    8805: [0.13597, 0.63597, 0, 0, 0.77778],
    8810: [0.0391, 0.5391, 0, 0, 1],
    8811: [0.0391, 0.5391, 0, 0, 1],
    8826: [0.0391, 0.5391, 0, 0, 0.77778],
    8827: [0.0391, 0.5391, 0, 0, 0.77778],
    8834: [0.0391, 0.5391, 0, 0, 0.77778],
    8835: [0.0391, 0.5391, 0, 0, 0.77778],
    8838: [0.13597, 0.63597, 0, 0, 0.77778],
    8839: [0.13597, 0.63597, 0, 0, 0.77778],
    8846: [0, 0.55556, 0, 0, 0.66667],
    8849: [0.13597, 0.63597, 0, 0, 0.77778],
    8850: [0.13597, 0.63597, 0, 0, 0.77778],
    8851: [0, 0.55556, 0, 0, 0.66667],
    8852: [0, 0.55556, 0, 0, 0.66667],
    8853: [0.08333, 0.58333, 0, 0, 0.77778],
    8854: [0.08333, 0.58333, 0, 0, 0.77778],
    8855: [0.08333, 0.58333, 0, 0, 0.77778],
    8856: [0.08333, 0.58333, 0, 0, 0.77778],
    8857: [0.08333, 0.58333, 0, 0, 0.77778],
    8866: [0, 0.69444, 0, 0, 0.61111],
    8867: [0, 0.69444, 0, 0, 0.61111],
    8868: [0, 0.69444, 0, 0, 0.77778],
    8869: [0, 0.69444, 0, 0, 0.77778],
    8872: [0.249, 0.75, 0, 0, 0.867],
    8900: [-0.05555, 0.44445, 0, 0, 0.5],
    8901: [-0.05555, 0.44445, 0, 0, 0.27778],
    8902: [-0.03472, 0.46528, 0, 0, 0.5],
    8904: [5e-3, 0.505, 0, 0, 0.9],
    8942: [0.03, 0.903, 0, 0, 0.278],
    8943: [-0.19, 0.313, 0, 0, 1.172],
    8945: [-0.1, 0.823, 0, 0, 1.282],
    8968: [0.25, 0.75, 0, 0, 0.44445],
    8969: [0.25, 0.75, 0, 0, 0.44445],
    8970: [0.25, 0.75, 0, 0, 0.44445],
    8971: [0.25, 0.75, 0, 0, 0.44445],
    8994: [-0.14236, 0.35764, 0, 0, 1],
    8995: [-0.14236, 0.35764, 0, 0, 1],
    9136: [0.244, 0.744, 0, 0, 0.412],
    9137: [0.244, 0.745, 0, 0, 0.412],
    9651: [0.19444, 0.69444, 0, 0, 0.88889],
    9657: [-0.03472, 0.46528, 0, 0, 0.5],
    9661: [0.19444, 0.69444, 0, 0, 0.88889],
    9667: [-0.03472, 0.46528, 0, 0, 0.5],
    9711: [0.19444, 0.69444, 0, 0, 1],
    9824: [0.12963, 0.69444, 0, 0, 0.77778],
    9825: [0.12963, 0.69444, 0, 0, 0.77778],
    9826: [0.12963, 0.69444, 0, 0, 0.77778],
    9827: [0.12963, 0.69444, 0, 0, 0.77778],
    9837: [0, 0.75, 0, 0, 0.38889],
    9838: [0.19444, 0.69444, 0, 0, 0.38889],
    9839: [0.19444, 0.69444, 0, 0, 0.38889],
    10216: [0.25, 0.75, 0, 0, 0.38889],
    10217: [0.25, 0.75, 0, 0, 0.38889],
    10222: [0.244, 0.744, 0, 0, 0.412],
    10223: [0.244, 0.745, 0, 0, 0.412],
    10229: [0.011, 0.511, 0, 0, 1.609],
    10230: [0.011, 0.511, 0, 0, 1.638],
    10231: [0.011, 0.511, 0, 0, 1.859],
    10232: [0.024, 0.525, 0, 0, 1.609],
    10233: [0.024, 0.525, 0, 0, 1.638],
    10234: [0.024, 0.525, 0, 0, 1.858],
    10236: [0.011, 0.511, 0, 0, 1.638],
    10815: [0, 0.68333, 0, 0, 0.75],
    10927: [0.13597, 0.63597, 0, 0, 0.77778],
    10928: [0.13597, 0.63597, 0, 0, 0.77778],
    57376: [0.19444, 0.69444, 0, 0, 0]
  },
  "Math-BoldItalic": {
    32: [0, 0, 0, 0, 0.25],
    48: [0, 0.44444, 0, 0, 0.575],
    49: [0, 0.44444, 0, 0, 0.575],
    50: [0, 0.44444, 0, 0, 0.575],
    51: [0.19444, 0.44444, 0, 0, 0.575],
    52: [0.19444, 0.44444, 0, 0, 0.575],
    53: [0.19444, 0.44444, 0, 0, 0.575],
    54: [0, 0.64444, 0, 0, 0.575],
    55: [0.19444, 0.44444, 0, 0, 0.575],
    56: [0, 0.64444, 0, 0, 0.575],
    57: [0.19444, 0.44444, 0, 0, 0.575],
    65: [0, 0.68611, 0, 0, 0.86944],
    66: [0, 0.68611, 0.04835, 0, 0.8664],
    67: [0, 0.68611, 0.06979, 0, 0.81694],
    68: [0, 0.68611, 0.03194, 0, 0.93812],
    69: [0, 0.68611, 0.05451, 0, 0.81007],
    70: [0, 0.68611, 0.15972, 0, 0.68889],
    71: [0, 0.68611, 0, 0, 0.88673],
    72: [0, 0.68611, 0.08229, 0, 0.98229],
    73: [0, 0.68611, 0.07778, 0, 0.51111],
    74: [0, 0.68611, 0.10069, 0, 0.63125],
    75: [0, 0.68611, 0.06979, 0, 0.97118],
    76: [0, 0.68611, 0, 0, 0.75555],
    77: [0, 0.68611, 0.11424, 0, 1.14201],
    78: [0, 0.68611, 0.11424, 0, 0.95034],
    79: [0, 0.68611, 0.03194, 0, 0.83666],
    80: [0, 0.68611, 0.15972, 0, 0.72309],
    81: [0.19444, 0.68611, 0, 0, 0.86861],
    82: [0, 0.68611, 421e-5, 0, 0.87235],
    83: [0, 0.68611, 0.05382, 0, 0.69271],
    84: [0, 0.68611, 0.15972, 0, 0.63663],
    85: [0, 0.68611, 0.11424, 0, 0.80027],
    86: [0, 0.68611, 0.25555, 0, 0.67778],
    87: [0, 0.68611, 0.15972, 0, 1.09305],
    88: [0, 0.68611, 0.07778, 0, 0.94722],
    89: [0, 0.68611, 0.25555, 0, 0.67458],
    90: [0, 0.68611, 0.06979, 0, 0.77257],
    97: [0, 0.44444, 0, 0, 0.63287],
    98: [0, 0.69444, 0, 0, 0.52083],
    99: [0, 0.44444, 0, 0, 0.51342],
    100: [0, 0.69444, 0, 0, 0.60972],
    101: [0, 0.44444, 0, 0, 0.55361],
    102: [0.19444, 0.69444, 0.11042, 0, 0.56806],
    103: [0.19444, 0.44444, 0.03704, 0, 0.5449],
    104: [0, 0.69444, 0, 0, 0.66759],
    105: [0, 0.69326, 0, 0, 0.4048],
    106: [0.19444, 0.69326, 0.0622, 0, 0.47083],
    107: [0, 0.69444, 0.01852, 0, 0.6037],
    108: [0, 0.69444, 88e-4, 0, 0.34815],
    109: [0, 0.44444, 0, 0, 1.0324],
    110: [0, 0.44444, 0, 0, 0.71296],
    111: [0, 0.44444, 0, 0, 0.58472],
    112: [0.19444, 0.44444, 0, 0, 0.60092],
    113: [0.19444, 0.44444, 0.03704, 0, 0.54213],
    114: [0, 0.44444, 0.03194, 0, 0.5287],
    115: [0, 0.44444, 0, 0, 0.53125],
    116: [0, 0.63492, 0, 0, 0.41528],
    117: [0, 0.44444, 0, 0, 0.68102],
    118: [0, 0.44444, 0.03704, 0, 0.56666],
    119: [0, 0.44444, 0.02778, 0, 0.83148],
    120: [0, 0.44444, 0, 0, 0.65903],
    121: [0.19444, 0.44444, 0.03704, 0, 0.59028],
    122: [0, 0.44444, 0.04213, 0, 0.55509],
    160: [0, 0, 0, 0, 0.25],
    915: [0, 0.68611, 0.15972, 0, 0.65694],
    916: [0, 0.68611, 0, 0, 0.95833],
    920: [0, 0.68611, 0.03194, 0, 0.86722],
    923: [0, 0.68611, 0, 0, 0.80555],
    926: [0, 0.68611, 0.07458, 0, 0.84125],
    928: [0, 0.68611, 0.08229, 0, 0.98229],
    931: [0, 0.68611, 0.05451, 0, 0.88507],
    933: [0, 0.68611, 0.15972, 0, 0.67083],
    934: [0, 0.68611, 0, 0, 0.76666],
    936: [0, 0.68611, 0.11653, 0, 0.71402],
    937: [0, 0.68611, 0.04835, 0, 0.8789],
    945: [0, 0.44444, 0, 0, 0.76064],
    946: [0.19444, 0.69444, 0.03403, 0, 0.65972],
    947: [0.19444, 0.44444, 0.06389, 0, 0.59003],
    948: [0, 0.69444, 0.03819, 0, 0.52222],
    949: [0, 0.44444, 0, 0, 0.52882],
    950: [0.19444, 0.69444, 0.06215, 0, 0.50833],
    951: [0.19444, 0.44444, 0.03704, 0, 0.6],
    952: [0, 0.69444, 0.03194, 0, 0.5618],
    953: [0, 0.44444, 0, 0, 0.41204],
    954: [0, 0.44444, 0, 0, 0.66759],
    955: [0, 0.69444, 0, 0, 0.67083],
    956: [0.19444, 0.44444, 0, 0, 0.70787],
    957: [0, 0.44444, 0.06898, 0, 0.57685],
    958: [0.19444, 0.69444, 0.03021, 0, 0.50833],
    959: [0, 0.44444, 0, 0, 0.58472],
    960: [0, 0.44444, 0.03704, 0, 0.68241],
    961: [0.19444, 0.44444, 0, 0, 0.6118],
    962: [0.09722, 0.44444, 0.07917, 0, 0.42361],
    963: [0, 0.44444, 0.03704, 0, 0.68588],
    964: [0, 0.44444, 0.13472, 0, 0.52083],
    965: [0, 0.44444, 0.03704, 0, 0.63055],
    966: [0.19444, 0.44444, 0, 0, 0.74722],
    967: [0.19444, 0.44444, 0, 0, 0.71805],
    968: [0.19444, 0.69444, 0.03704, 0, 0.75833],
    969: [0, 0.44444, 0.03704, 0, 0.71782],
    977: [0, 0.69444, 0, 0, 0.69155],
    981: [0.19444, 0.69444, 0, 0, 0.7125],
    982: [0, 0.44444, 0.03194, 0, 0.975],
    1009: [0.19444, 0.44444, 0, 0, 0.6118],
    1013: [0, 0.44444, 0, 0, 0.48333],
    57649: [0, 0.44444, 0, 0, 0.39352],
    57911: [0.19444, 0.44444, 0, 0, 0.43889]
  },
  "Math-Italic": {
    32: [0, 0, 0, 0, 0.25],
    48: [0, 0.43056, 0, 0, 0.5],
    49: [0, 0.43056, 0, 0, 0.5],
    50: [0, 0.43056, 0, 0, 0.5],
    51: [0.19444, 0.43056, 0, 0, 0.5],
    52: [0.19444, 0.43056, 0, 0, 0.5],
    53: [0.19444, 0.43056, 0, 0, 0.5],
    54: [0, 0.64444, 0, 0, 0.5],
    55: [0.19444, 0.43056, 0, 0, 0.5],
    56: [0, 0.64444, 0, 0, 0.5],
    57: [0.19444, 0.43056, 0, 0, 0.5],
    65: [0, 0.68333, 0, 0.13889, 0.75],
    66: [0, 0.68333, 0.05017, 0.08334, 0.75851],
    67: [0, 0.68333, 0.07153, 0.08334, 0.71472],
    68: [0, 0.68333, 0.02778, 0.05556, 0.82792],
    69: [0, 0.68333, 0.05764, 0.08334, 0.7382],
    70: [0, 0.68333, 0.13889, 0.08334, 0.64306],
    71: [0, 0.68333, 0, 0.08334, 0.78625],
    72: [0, 0.68333, 0.08125, 0.05556, 0.83125],
    73: [0, 0.68333, 0.07847, 0.11111, 0.43958],
    74: [0, 0.68333, 0.09618, 0.16667, 0.55451],
    75: [0, 0.68333, 0.07153, 0.05556, 0.84931],
    76: [0, 0.68333, 0, 0.02778, 0.68056],
    77: [0, 0.68333, 0.10903, 0.08334, 0.97014],
    78: [0, 0.68333, 0.10903, 0.08334, 0.80347],
    79: [0, 0.68333, 0.02778, 0.08334, 0.76278],
    80: [0, 0.68333, 0.13889, 0.08334, 0.64201],
    81: [0.19444, 0.68333, 0, 0.08334, 0.79056],
    82: [0, 0.68333, 773e-5, 0.08334, 0.75929],
    83: [0, 0.68333, 0.05764, 0.08334, 0.6132],
    84: [0, 0.68333, 0.13889, 0.08334, 0.58438],
    85: [0, 0.68333, 0.10903, 0.02778, 0.68278],
    86: [0, 0.68333, 0.22222, 0, 0.58333],
    87: [0, 0.68333, 0.13889, 0, 0.94445],
    88: [0, 0.68333, 0.07847, 0.08334, 0.82847],
    89: [0, 0.68333, 0.22222, 0, 0.58056],
    90: [0, 0.68333, 0.07153, 0.08334, 0.68264],
    97: [0, 0.43056, 0, 0, 0.52859],
    98: [0, 0.69444, 0, 0, 0.42917],
    99: [0, 0.43056, 0, 0.05556, 0.43276],
    100: [0, 0.69444, 0, 0.16667, 0.52049],
    101: [0, 0.43056, 0, 0.05556, 0.46563],
    102: [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
    103: [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
    104: [0, 0.69444, 0, 0, 0.57616],
    105: [0, 0.65952, 0, 0, 0.34451],
    106: [0.19444, 0.65952, 0.05724, 0, 0.41181],
    107: [0, 0.69444, 0.03148, 0, 0.5206],
    108: [0, 0.69444, 0.01968, 0.08334, 0.29838],
    109: [0, 0.43056, 0, 0, 0.87801],
    110: [0, 0.43056, 0, 0, 0.60023],
    111: [0, 0.43056, 0, 0.05556, 0.48472],
    112: [0.19444, 0.43056, 0, 0.08334, 0.50313],
    113: [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
    114: [0, 0.43056, 0.02778, 0.05556, 0.45116],
    115: [0, 0.43056, 0, 0.05556, 0.46875],
    116: [0, 0.61508, 0, 0.08334, 0.36111],
    117: [0, 0.43056, 0, 0.02778, 0.57246],
    118: [0, 0.43056, 0.03588, 0.02778, 0.48472],
    119: [0, 0.43056, 0.02691, 0.08334, 0.71592],
    120: [0, 0.43056, 0, 0.02778, 0.57153],
    121: [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
    122: [0, 0.43056, 0.04398, 0.05556, 0.46505],
    160: [0, 0, 0, 0, 0.25],
    915: [0, 0.68333, 0.13889, 0.08334, 0.61528],
    916: [0, 0.68333, 0, 0.16667, 0.83334],
    920: [0, 0.68333, 0.02778, 0.08334, 0.76278],
    923: [0, 0.68333, 0, 0.16667, 0.69445],
    926: [0, 0.68333, 0.07569, 0.08334, 0.74236],
    928: [0, 0.68333, 0.08125, 0.05556, 0.83125],
    931: [0, 0.68333, 0.05764, 0.08334, 0.77986],
    933: [0, 0.68333, 0.13889, 0.05556, 0.58333],
    934: [0, 0.68333, 0, 0.08334, 0.66667],
    936: [0, 0.68333, 0.11, 0.05556, 0.61222],
    937: [0, 0.68333, 0.05017, 0.08334, 0.7724],
    945: [0, 0.43056, 37e-4, 0.02778, 0.6397],
    946: [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
    947: [0.19444, 0.43056, 0.05556, 0, 0.51773],
    948: [0, 0.69444, 0.03785, 0.05556, 0.44444],
    949: [0, 0.43056, 0, 0.08334, 0.46632],
    950: [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
    951: [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
    952: [0, 0.69444, 0.02778, 0.08334, 0.46944],
    953: [0, 0.43056, 0, 0.05556, 0.35394],
    954: [0, 0.43056, 0, 0, 0.57616],
    955: [0, 0.69444, 0, 0, 0.58334],
    956: [0.19444, 0.43056, 0, 0.02778, 0.60255],
    957: [0, 0.43056, 0.06366, 0.02778, 0.49398],
    958: [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
    959: [0, 0.43056, 0, 0.05556, 0.48472],
    960: [0, 0.43056, 0.03588, 0, 0.57003],
    961: [0.19444, 0.43056, 0, 0.08334, 0.51702],
    962: [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
    963: [0, 0.43056, 0.03588, 0, 0.57141],
    964: [0, 0.43056, 0.1132, 0.02778, 0.43715],
    965: [0, 0.43056, 0.03588, 0.02778, 0.54028],
    966: [0.19444, 0.43056, 0, 0.08334, 0.65417],
    967: [0.19444, 0.43056, 0, 0.05556, 0.62569],
    968: [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
    969: [0, 0.43056, 0.03588, 0, 0.62245],
    977: [0, 0.69444, 0, 0.08334, 0.59144],
    981: [0.19444, 0.69444, 0, 0.08334, 0.59583],
    982: [0, 0.43056, 0.02778, 0, 0.82813],
    1009: [0.19444, 0.43056, 0, 0.08334, 0.51702],
    1013: [0, 0.43056, 0, 0.05556, 0.4059],
    57649: [0, 0.43056, 0, 0.02778, 0.32246],
    57911: [0.19444, 0.43056, 0, 0.08334, 0.38403]
  },
  "SansSerif-Bold": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.36667],
    34: [0, 0.69444, 0, 0, 0.55834],
    35: [0.19444, 0.69444, 0, 0, 0.91667],
    36: [0.05556, 0.75, 0, 0, 0.55],
    37: [0.05556, 0.75, 0, 0, 1.02912],
    38: [0, 0.69444, 0, 0, 0.83056],
    39: [0, 0.69444, 0, 0, 0.30556],
    40: [0.25, 0.75, 0, 0, 0.42778],
    41: [0.25, 0.75, 0, 0, 0.42778],
    42: [0, 0.75, 0, 0, 0.55],
    43: [0.11667, 0.61667, 0, 0, 0.85556],
    44: [0.10556, 0.13056, 0, 0, 0.30556],
    45: [0, 0.45833, 0, 0, 0.36667],
    46: [0, 0.13056, 0, 0, 0.30556],
    47: [0.25, 0.75, 0, 0, 0.55],
    48: [0, 0.69444, 0, 0, 0.55],
    49: [0, 0.69444, 0, 0, 0.55],
    50: [0, 0.69444, 0, 0, 0.55],
    51: [0, 0.69444, 0, 0, 0.55],
    52: [0, 0.69444, 0, 0, 0.55],
    53: [0, 0.69444, 0, 0, 0.55],
    54: [0, 0.69444, 0, 0, 0.55],
    55: [0, 0.69444, 0, 0, 0.55],
    56: [0, 0.69444, 0, 0, 0.55],
    57: [0, 0.69444, 0, 0, 0.55],
    58: [0, 0.45833, 0, 0, 0.30556],
    59: [0.10556, 0.45833, 0, 0, 0.30556],
    61: [-0.09375, 0.40625, 0, 0, 0.85556],
    63: [0, 0.69444, 0, 0, 0.51945],
    64: [0, 0.69444, 0, 0, 0.73334],
    65: [0, 0.69444, 0, 0, 0.73334],
    66: [0, 0.69444, 0, 0, 0.73334],
    67: [0, 0.69444, 0, 0, 0.70278],
    68: [0, 0.69444, 0, 0, 0.79445],
    69: [0, 0.69444, 0, 0, 0.64167],
    70: [0, 0.69444, 0, 0, 0.61111],
    71: [0, 0.69444, 0, 0, 0.73334],
    72: [0, 0.69444, 0, 0, 0.79445],
    73: [0, 0.69444, 0, 0, 0.33056],
    74: [0, 0.69444, 0, 0, 0.51945],
    75: [0, 0.69444, 0, 0, 0.76389],
    76: [0, 0.69444, 0, 0, 0.58056],
    77: [0, 0.69444, 0, 0, 0.97778],
    78: [0, 0.69444, 0, 0, 0.79445],
    79: [0, 0.69444, 0, 0, 0.79445],
    80: [0, 0.69444, 0, 0, 0.70278],
    81: [0.10556, 0.69444, 0, 0, 0.79445],
    82: [0, 0.69444, 0, 0, 0.70278],
    83: [0, 0.69444, 0, 0, 0.61111],
    84: [0, 0.69444, 0, 0, 0.73334],
    85: [0, 0.69444, 0, 0, 0.76389],
    86: [0, 0.69444, 0.01528, 0, 0.73334],
    87: [0, 0.69444, 0.01528, 0, 1.03889],
    88: [0, 0.69444, 0, 0, 0.73334],
    89: [0, 0.69444, 0.0275, 0, 0.73334],
    90: [0, 0.69444, 0, 0, 0.67223],
    91: [0.25, 0.75, 0, 0, 0.34306],
    93: [0.25, 0.75, 0, 0, 0.34306],
    94: [0, 0.69444, 0, 0, 0.55],
    95: [0.35, 0.10833, 0.03056, 0, 0.55],
    97: [0, 0.45833, 0, 0, 0.525],
    98: [0, 0.69444, 0, 0, 0.56111],
    99: [0, 0.45833, 0, 0, 0.48889],
    100: [0, 0.69444, 0, 0, 0.56111],
    101: [0, 0.45833, 0, 0, 0.51111],
    102: [0, 0.69444, 0.07639, 0, 0.33611],
    103: [0.19444, 0.45833, 0.01528, 0, 0.55],
    104: [0, 0.69444, 0, 0, 0.56111],
    105: [0, 0.69444, 0, 0, 0.25556],
    106: [0.19444, 0.69444, 0, 0, 0.28611],
    107: [0, 0.69444, 0, 0, 0.53056],
    108: [0, 0.69444, 0, 0, 0.25556],
    109: [0, 0.45833, 0, 0, 0.86667],
    110: [0, 0.45833, 0, 0, 0.56111],
    111: [0, 0.45833, 0, 0, 0.55],
    112: [0.19444, 0.45833, 0, 0, 0.56111],
    113: [0.19444, 0.45833, 0, 0, 0.56111],
    114: [0, 0.45833, 0.01528, 0, 0.37222],
    115: [0, 0.45833, 0, 0, 0.42167],
    116: [0, 0.58929, 0, 0, 0.40417],
    117: [0, 0.45833, 0, 0, 0.56111],
    118: [0, 0.45833, 0.01528, 0, 0.5],
    119: [0, 0.45833, 0.01528, 0, 0.74445],
    120: [0, 0.45833, 0, 0, 0.5],
    121: [0.19444, 0.45833, 0.01528, 0, 0.5],
    122: [0, 0.45833, 0, 0, 0.47639],
    126: [0.35, 0.34444, 0, 0, 0.55],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.69444, 0, 0, 0.55],
    176: [0, 0.69444, 0, 0, 0.73334],
    180: [0, 0.69444, 0, 0, 0.55],
    184: [0.17014, 0, 0, 0, 0.48889],
    305: [0, 0.45833, 0, 0, 0.25556],
    567: [0.19444, 0.45833, 0, 0, 0.28611],
    710: [0, 0.69444, 0, 0, 0.55],
    711: [0, 0.63542, 0, 0, 0.55],
    713: [0, 0.63778, 0, 0, 0.55],
    728: [0, 0.69444, 0, 0, 0.55],
    729: [0, 0.69444, 0, 0, 0.30556],
    730: [0, 0.69444, 0, 0, 0.73334],
    732: [0, 0.69444, 0, 0, 0.55],
    733: [0, 0.69444, 0, 0, 0.55],
    915: [0, 0.69444, 0, 0, 0.58056],
    916: [0, 0.69444, 0, 0, 0.91667],
    920: [0, 0.69444, 0, 0, 0.85556],
    923: [0, 0.69444, 0, 0, 0.67223],
    926: [0, 0.69444, 0, 0, 0.73334],
    928: [0, 0.69444, 0, 0, 0.79445],
    931: [0, 0.69444, 0, 0, 0.79445],
    933: [0, 0.69444, 0, 0, 0.85556],
    934: [0, 0.69444, 0, 0, 0.79445],
    936: [0, 0.69444, 0, 0, 0.85556],
    937: [0, 0.69444, 0, 0, 0.79445],
    8211: [0, 0.45833, 0.03056, 0, 0.55],
    8212: [0, 0.45833, 0.03056, 0, 1.10001],
    8216: [0, 0.69444, 0, 0, 0.30556],
    8217: [0, 0.69444, 0, 0, 0.30556],
    8220: [0, 0.69444, 0, 0, 0.55834],
    8221: [0, 0.69444, 0, 0, 0.55834]
  },
  "SansSerif-Italic": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0.05733, 0, 0.31945],
    34: [0, 0.69444, 316e-5, 0, 0.5],
    35: [0.19444, 0.69444, 0.05087, 0, 0.83334],
    36: [0.05556, 0.75, 0.11156, 0, 0.5],
    37: [0.05556, 0.75, 0.03126, 0, 0.83334],
    38: [0, 0.69444, 0.03058, 0, 0.75834],
    39: [0, 0.69444, 0.07816, 0, 0.27778],
    40: [0.25, 0.75, 0.13164, 0, 0.38889],
    41: [0.25, 0.75, 0.02536, 0, 0.38889],
    42: [0, 0.75, 0.11775, 0, 0.5],
    43: [0.08333, 0.58333, 0.02536, 0, 0.77778],
    44: [0.125, 0.08333, 0, 0, 0.27778],
    45: [0, 0.44444, 0.01946, 0, 0.33333],
    46: [0, 0.08333, 0, 0, 0.27778],
    47: [0.25, 0.75, 0.13164, 0, 0.5],
    48: [0, 0.65556, 0.11156, 0, 0.5],
    49: [0, 0.65556, 0.11156, 0, 0.5],
    50: [0, 0.65556, 0.11156, 0, 0.5],
    51: [0, 0.65556, 0.11156, 0, 0.5],
    52: [0, 0.65556, 0.11156, 0, 0.5],
    53: [0, 0.65556, 0.11156, 0, 0.5],
    54: [0, 0.65556, 0.11156, 0, 0.5],
    55: [0, 0.65556, 0.11156, 0, 0.5],
    56: [0, 0.65556, 0.11156, 0, 0.5],
    57: [0, 0.65556, 0.11156, 0, 0.5],
    58: [0, 0.44444, 0.02502, 0, 0.27778],
    59: [0.125, 0.44444, 0.02502, 0, 0.27778],
    61: [-0.13, 0.37, 0.05087, 0, 0.77778],
    63: [0, 0.69444, 0.11809, 0, 0.47222],
    64: [0, 0.69444, 0.07555, 0, 0.66667],
    65: [0, 0.69444, 0, 0, 0.66667],
    66: [0, 0.69444, 0.08293, 0, 0.66667],
    67: [0, 0.69444, 0.11983, 0, 0.63889],
    68: [0, 0.69444, 0.07555, 0, 0.72223],
    69: [0, 0.69444, 0.11983, 0, 0.59722],
    70: [0, 0.69444, 0.13372, 0, 0.56945],
    71: [0, 0.69444, 0.11983, 0, 0.66667],
    72: [0, 0.69444, 0.08094, 0, 0.70834],
    73: [0, 0.69444, 0.13372, 0, 0.27778],
    74: [0, 0.69444, 0.08094, 0, 0.47222],
    75: [0, 0.69444, 0.11983, 0, 0.69445],
    76: [0, 0.69444, 0, 0, 0.54167],
    77: [0, 0.69444, 0.08094, 0, 0.875],
    78: [0, 0.69444, 0.08094, 0, 0.70834],
    79: [0, 0.69444, 0.07555, 0, 0.73611],
    80: [0, 0.69444, 0.08293, 0, 0.63889],
    81: [0.125, 0.69444, 0.07555, 0, 0.73611],
    82: [0, 0.69444, 0.08293, 0, 0.64584],
    83: [0, 0.69444, 0.09205, 0, 0.55556],
    84: [0, 0.69444, 0.13372, 0, 0.68056],
    85: [0, 0.69444, 0.08094, 0, 0.6875],
    86: [0, 0.69444, 0.1615, 0, 0.66667],
    87: [0, 0.69444, 0.1615, 0, 0.94445],
    88: [0, 0.69444, 0.13372, 0, 0.66667],
    89: [0, 0.69444, 0.17261, 0, 0.66667],
    90: [0, 0.69444, 0.11983, 0, 0.61111],
    91: [0.25, 0.75, 0.15942, 0, 0.28889],
    93: [0.25, 0.75, 0.08719, 0, 0.28889],
    94: [0, 0.69444, 0.0799, 0, 0.5],
    95: [0.35, 0.09444, 0.08616, 0, 0.5],
    97: [0, 0.44444, 981e-5, 0, 0.48056],
    98: [0, 0.69444, 0.03057, 0, 0.51667],
    99: [0, 0.44444, 0.08336, 0, 0.44445],
    100: [0, 0.69444, 0.09483, 0, 0.51667],
    101: [0, 0.44444, 0.06778, 0, 0.44445],
    102: [0, 0.69444, 0.21705, 0, 0.30556],
    103: [0.19444, 0.44444, 0.10836, 0, 0.5],
    104: [0, 0.69444, 0.01778, 0, 0.51667],
    105: [0, 0.67937, 0.09718, 0, 0.23889],
    106: [0.19444, 0.67937, 0.09162, 0, 0.26667],
    107: [0, 0.69444, 0.08336, 0, 0.48889],
    108: [0, 0.69444, 0.09483, 0, 0.23889],
    109: [0, 0.44444, 0.01778, 0, 0.79445],
    110: [0, 0.44444, 0.01778, 0, 0.51667],
    111: [0, 0.44444, 0.06613, 0, 0.5],
    112: [0.19444, 0.44444, 0.0389, 0, 0.51667],
    113: [0.19444, 0.44444, 0.04169, 0, 0.51667],
    114: [0, 0.44444, 0.10836, 0, 0.34167],
    115: [0, 0.44444, 0.0778, 0, 0.38333],
    116: [0, 0.57143, 0.07225, 0, 0.36111],
    117: [0, 0.44444, 0.04169, 0, 0.51667],
    118: [0, 0.44444, 0.10836, 0, 0.46111],
    119: [0, 0.44444, 0.10836, 0, 0.68334],
    120: [0, 0.44444, 0.09169, 0, 0.46111],
    121: [0.19444, 0.44444, 0.10836, 0, 0.46111],
    122: [0, 0.44444, 0.08752, 0, 0.43472],
    126: [0.35, 0.32659, 0.08826, 0, 0.5],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.67937, 0.06385, 0, 0.5],
    176: [0, 0.69444, 0, 0, 0.73752],
    184: [0.17014, 0, 0, 0, 0.44445],
    305: [0, 0.44444, 0.04169, 0, 0.23889],
    567: [0.19444, 0.44444, 0.04169, 0, 0.26667],
    710: [0, 0.69444, 0.0799, 0, 0.5],
    711: [0, 0.63194, 0.08432, 0, 0.5],
    713: [0, 0.60889, 0.08776, 0, 0.5],
    714: [0, 0.69444, 0.09205, 0, 0.5],
    715: [0, 0.69444, 0, 0, 0.5],
    728: [0, 0.69444, 0.09483, 0, 0.5],
    729: [0, 0.67937, 0.07774, 0, 0.27778],
    730: [0, 0.69444, 0, 0, 0.73752],
    732: [0, 0.67659, 0.08826, 0, 0.5],
    733: [0, 0.69444, 0.09205, 0, 0.5],
    915: [0, 0.69444, 0.13372, 0, 0.54167],
    916: [0, 0.69444, 0, 0, 0.83334],
    920: [0, 0.69444, 0.07555, 0, 0.77778],
    923: [0, 0.69444, 0, 0, 0.61111],
    926: [0, 0.69444, 0.12816, 0, 0.66667],
    928: [0, 0.69444, 0.08094, 0, 0.70834],
    931: [0, 0.69444, 0.11983, 0, 0.72222],
    933: [0, 0.69444, 0.09031, 0, 0.77778],
    934: [0, 0.69444, 0.04603, 0, 0.72222],
    936: [0, 0.69444, 0.09031, 0, 0.77778],
    937: [0, 0.69444, 0.08293, 0, 0.72222],
    8211: [0, 0.44444, 0.08616, 0, 0.5],
    8212: [0, 0.44444, 0.08616, 0, 1],
    8216: [0, 0.69444, 0.07816, 0, 0.27778],
    8217: [0, 0.69444, 0.07816, 0, 0.27778],
    8220: [0, 0.69444, 0.14205, 0, 0.5],
    8221: [0, 0.69444, 316e-5, 0, 0.5]
  },
  "SansSerif-Regular": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.31945],
    34: [0, 0.69444, 0, 0, 0.5],
    35: [0.19444, 0.69444, 0, 0, 0.83334],
    36: [0.05556, 0.75, 0, 0, 0.5],
    37: [0.05556, 0.75, 0, 0, 0.83334],
    38: [0, 0.69444, 0, 0, 0.75834],
    39: [0, 0.69444, 0, 0, 0.27778],
    40: [0.25, 0.75, 0, 0, 0.38889],
    41: [0.25, 0.75, 0, 0, 0.38889],
    42: [0, 0.75, 0, 0, 0.5],
    43: [0.08333, 0.58333, 0, 0, 0.77778],
    44: [0.125, 0.08333, 0, 0, 0.27778],
    45: [0, 0.44444, 0, 0, 0.33333],
    46: [0, 0.08333, 0, 0, 0.27778],
    47: [0.25, 0.75, 0, 0, 0.5],
    48: [0, 0.65556, 0, 0, 0.5],
    49: [0, 0.65556, 0, 0, 0.5],
    50: [0, 0.65556, 0, 0, 0.5],
    51: [0, 0.65556, 0, 0, 0.5],
    52: [0, 0.65556, 0, 0, 0.5],
    53: [0, 0.65556, 0, 0, 0.5],
    54: [0, 0.65556, 0, 0, 0.5],
    55: [0, 0.65556, 0, 0, 0.5],
    56: [0, 0.65556, 0, 0, 0.5],
    57: [0, 0.65556, 0, 0, 0.5],
    58: [0, 0.44444, 0, 0, 0.27778],
    59: [0.125, 0.44444, 0, 0, 0.27778],
    61: [-0.13, 0.37, 0, 0, 0.77778],
    63: [0, 0.69444, 0, 0, 0.47222],
    64: [0, 0.69444, 0, 0, 0.66667],
    65: [0, 0.69444, 0, 0, 0.66667],
    66: [0, 0.69444, 0, 0, 0.66667],
    67: [0, 0.69444, 0, 0, 0.63889],
    68: [0, 0.69444, 0, 0, 0.72223],
    69: [0, 0.69444, 0, 0, 0.59722],
    70: [0, 0.69444, 0, 0, 0.56945],
    71: [0, 0.69444, 0, 0, 0.66667],
    72: [0, 0.69444, 0, 0, 0.70834],
    73: [0, 0.69444, 0, 0, 0.27778],
    74: [0, 0.69444, 0, 0, 0.47222],
    75: [0, 0.69444, 0, 0, 0.69445],
    76: [0, 0.69444, 0, 0, 0.54167],
    77: [0, 0.69444, 0, 0, 0.875],
    78: [0, 0.69444, 0, 0, 0.70834],
    79: [0, 0.69444, 0, 0, 0.73611],
    80: [0, 0.69444, 0, 0, 0.63889],
    81: [0.125, 0.69444, 0, 0, 0.73611],
    82: [0, 0.69444, 0, 0, 0.64584],
    83: [0, 0.69444, 0, 0, 0.55556],
    84: [0, 0.69444, 0, 0, 0.68056],
    85: [0, 0.69444, 0, 0, 0.6875],
    86: [0, 0.69444, 0.01389, 0, 0.66667],
    87: [0, 0.69444, 0.01389, 0, 0.94445],
    88: [0, 0.69444, 0, 0, 0.66667],
    89: [0, 0.69444, 0.025, 0, 0.66667],
    90: [0, 0.69444, 0, 0, 0.61111],
    91: [0.25, 0.75, 0, 0, 0.28889],
    93: [0.25, 0.75, 0, 0, 0.28889],
    94: [0, 0.69444, 0, 0, 0.5],
    95: [0.35, 0.09444, 0.02778, 0, 0.5],
    97: [0, 0.44444, 0, 0, 0.48056],
    98: [0, 0.69444, 0, 0, 0.51667],
    99: [0, 0.44444, 0, 0, 0.44445],
    100: [0, 0.69444, 0, 0, 0.51667],
    101: [0, 0.44444, 0, 0, 0.44445],
    102: [0, 0.69444, 0.06944, 0, 0.30556],
    103: [0.19444, 0.44444, 0.01389, 0, 0.5],
    104: [0, 0.69444, 0, 0, 0.51667],
    105: [0, 0.67937, 0, 0, 0.23889],
    106: [0.19444, 0.67937, 0, 0, 0.26667],
    107: [0, 0.69444, 0, 0, 0.48889],
    108: [0, 0.69444, 0, 0, 0.23889],
    109: [0, 0.44444, 0, 0, 0.79445],
    110: [0, 0.44444, 0, 0, 0.51667],
    111: [0, 0.44444, 0, 0, 0.5],
    112: [0.19444, 0.44444, 0, 0, 0.51667],
    113: [0.19444, 0.44444, 0, 0, 0.51667],
    114: [0, 0.44444, 0.01389, 0, 0.34167],
    115: [0, 0.44444, 0, 0, 0.38333],
    116: [0, 0.57143, 0, 0, 0.36111],
    117: [0, 0.44444, 0, 0, 0.51667],
    118: [0, 0.44444, 0.01389, 0, 0.46111],
    119: [0, 0.44444, 0.01389, 0, 0.68334],
    120: [0, 0.44444, 0, 0, 0.46111],
    121: [0.19444, 0.44444, 0.01389, 0, 0.46111],
    122: [0, 0.44444, 0, 0, 0.43472],
    126: [0.35, 0.32659, 0, 0, 0.5],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.67937, 0, 0, 0.5],
    176: [0, 0.69444, 0, 0, 0.66667],
    184: [0.17014, 0, 0, 0, 0.44445],
    305: [0, 0.44444, 0, 0, 0.23889],
    567: [0.19444, 0.44444, 0, 0, 0.26667],
    710: [0, 0.69444, 0, 0, 0.5],
    711: [0, 0.63194, 0, 0, 0.5],
    713: [0, 0.60889, 0, 0, 0.5],
    714: [0, 0.69444, 0, 0, 0.5],
    715: [0, 0.69444, 0, 0, 0.5],
    728: [0, 0.69444, 0, 0, 0.5],
    729: [0, 0.67937, 0, 0, 0.27778],
    730: [0, 0.69444, 0, 0, 0.66667],
    732: [0, 0.67659, 0, 0, 0.5],
    733: [0, 0.69444, 0, 0, 0.5],
    915: [0, 0.69444, 0, 0, 0.54167],
    916: [0, 0.69444, 0, 0, 0.83334],
    920: [0, 0.69444, 0, 0, 0.77778],
    923: [0, 0.69444, 0, 0, 0.61111],
    926: [0, 0.69444, 0, 0, 0.66667],
    928: [0, 0.69444, 0, 0, 0.70834],
    931: [0, 0.69444, 0, 0, 0.72222],
    933: [0, 0.69444, 0, 0, 0.77778],
    934: [0, 0.69444, 0, 0, 0.72222],
    936: [0, 0.69444, 0, 0, 0.77778],
    937: [0, 0.69444, 0, 0, 0.72222],
    8211: [0, 0.44444, 0.02778, 0, 0.5],
    8212: [0, 0.44444, 0.02778, 0, 1],
    8216: [0, 0.69444, 0, 0, 0.27778],
    8217: [0, 0.69444, 0, 0, 0.27778],
    8220: [0, 0.69444, 0, 0, 0.5],
    8221: [0, 0.69444, 0, 0, 0.5]
  },
  "Script-Regular": {
    32: [0, 0, 0, 0, 0.25],
    65: [0, 0.7, 0.22925, 0, 0.80253],
    66: [0, 0.7, 0.04087, 0, 0.90757],
    67: [0, 0.7, 0.1689, 0, 0.66619],
    68: [0, 0.7, 0.09371, 0, 0.77443],
    69: [0, 0.7, 0.18583, 0, 0.56162],
    70: [0, 0.7, 0.13634, 0, 0.89544],
    71: [0, 0.7, 0.17322, 0, 0.60961],
    72: [0, 0.7, 0.29694, 0, 0.96919],
    73: [0, 0.7, 0.19189, 0, 0.80907],
    74: [0.27778, 0.7, 0.19189, 0, 1.05159],
    75: [0, 0.7, 0.31259, 0, 0.91364],
    76: [0, 0.7, 0.19189, 0, 0.87373],
    77: [0, 0.7, 0.15981, 0, 1.08031],
    78: [0, 0.7, 0.3525, 0, 0.9015],
    79: [0, 0.7, 0.08078, 0, 0.73787],
    80: [0, 0.7, 0.08078, 0, 1.01262],
    81: [0, 0.7, 0.03305, 0, 0.88282],
    82: [0, 0.7, 0.06259, 0, 0.85],
    83: [0, 0.7, 0.19189, 0, 0.86767],
    84: [0, 0.7, 0.29087, 0, 0.74697],
    85: [0, 0.7, 0.25815, 0, 0.79996],
    86: [0, 0.7, 0.27523, 0, 0.62204],
    87: [0, 0.7, 0.27523, 0, 0.80532],
    88: [0, 0.7, 0.26006, 0, 0.94445],
    89: [0, 0.7, 0.2939, 0, 0.70961],
    90: [0, 0.7, 0.24037, 0, 0.8212],
    160: [0, 0, 0, 0, 0.25]
  },
  "Size1-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [0.35001, 0.85, 0, 0, 0.45834],
    41: [0.35001, 0.85, 0, 0, 0.45834],
    47: [0.35001, 0.85, 0, 0, 0.57778],
    91: [0.35001, 0.85, 0, 0, 0.41667],
    92: [0.35001, 0.85, 0, 0, 0.57778],
    93: [0.35001, 0.85, 0, 0, 0.41667],
    123: [0.35001, 0.85, 0, 0, 0.58334],
    125: [0.35001, 0.85, 0, 0, 0.58334],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.72222, 0, 0, 0.55556],
    732: [0, 0.72222, 0, 0, 0.55556],
    770: [0, 0.72222, 0, 0, 0.55556],
    771: [0, 0.72222, 0, 0, 0.55556],
    8214: [-99e-5, 0.601, 0, 0, 0.77778],
    8593: [1e-5, 0.6, 0, 0, 0.66667],
    8595: [1e-5, 0.6, 0, 0, 0.66667],
    8657: [1e-5, 0.6, 0, 0, 0.77778],
    8659: [1e-5, 0.6, 0, 0, 0.77778],
    8719: [0.25001, 0.75, 0, 0, 0.94445],
    8720: [0.25001, 0.75, 0, 0, 0.94445],
    8721: [0.25001, 0.75, 0, 0, 1.05556],
    8730: [0.35001, 0.85, 0, 0, 1],
    8739: [-599e-5, 0.606, 0, 0, 0.33333],
    8741: [-599e-5, 0.606, 0, 0, 0.55556],
    8747: [0.30612, 0.805, 0.19445, 0, 0.47222],
    8748: [0.306, 0.805, 0.19445, 0, 0.47222],
    8749: [0.306, 0.805, 0.19445, 0, 0.47222],
    8750: [0.30612, 0.805, 0.19445, 0, 0.47222],
    8896: [0.25001, 0.75, 0, 0, 0.83334],
    8897: [0.25001, 0.75, 0, 0, 0.83334],
    8898: [0.25001, 0.75, 0, 0, 0.83334],
    8899: [0.25001, 0.75, 0, 0, 0.83334],
    8968: [0.35001, 0.85, 0, 0, 0.47222],
    8969: [0.35001, 0.85, 0, 0, 0.47222],
    8970: [0.35001, 0.85, 0, 0, 0.47222],
    8971: [0.35001, 0.85, 0, 0, 0.47222],
    9168: [-99e-5, 0.601, 0, 0, 0.66667],
    10216: [0.35001, 0.85, 0, 0, 0.47222],
    10217: [0.35001, 0.85, 0, 0, 0.47222],
    10752: [0.25001, 0.75, 0, 0, 1.11111],
    10753: [0.25001, 0.75, 0, 0, 1.11111],
    10754: [0.25001, 0.75, 0, 0, 1.11111],
    10756: [0.25001, 0.75, 0, 0, 0.83334],
    10758: [0.25001, 0.75, 0, 0, 0.83334]
  },
  "Size2-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [0.65002, 1.15, 0, 0, 0.59722],
    41: [0.65002, 1.15, 0, 0, 0.59722],
    47: [0.65002, 1.15, 0, 0, 0.81111],
    91: [0.65002, 1.15, 0, 0, 0.47222],
    92: [0.65002, 1.15, 0, 0, 0.81111],
    93: [0.65002, 1.15, 0, 0, 0.47222],
    123: [0.65002, 1.15, 0, 0, 0.66667],
    125: [0.65002, 1.15, 0, 0, 0.66667],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.75, 0, 0, 1],
    732: [0, 0.75, 0, 0, 1],
    770: [0, 0.75, 0, 0, 1],
    771: [0, 0.75, 0, 0, 1],
    8719: [0.55001, 1.05, 0, 0, 1.27778],
    8720: [0.55001, 1.05, 0, 0, 1.27778],
    8721: [0.55001, 1.05, 0, 0, 1.44445],
    8730: [0.65002, 1.15, 0, 0, 1],
    8747: [0.86225, 1.36, 0.44445, 0, 0.55556],
    8748: [0.862, 1.36, 0.44445, 0, 0.55556],
    8749: [0.862, 1.36, 0.44445, 0, 0.55556],
    8750: [0.86225, 1.36, 0.44445, 0, 0.55556],
    8896: [0.55001, 1.05, 0, 0, 1.11111],
    8897: [0.55001, 1.05, 0, 0, 1.11111],
    8898: [0.55001, 1.05, 0, 0, 1.11111],
    8899: [0.55001, 1.05, 0, 0, 1.11111],
    8968: [0.65002, 1.15, 0, 0, 0.52778],
    8969: [0.65002, 1.15, 0, 0, 0.52778],
    8970: [0.65002, 1.15, 0, 0, 0.52778],
    8971: [0.65002, 1.15, 0, 0, 0.52778],
    10216: [0.65002, 1.15, 0, 0, 0.61111],
    10217: [0.65002, 1.15, 0, 0, 0.61111],
    10752: [0.55001, 1.05, 0, 0, 1.51112],
    10753: [0.55001, 1.05, 0, 0, 1.51112],
    10754: [0.55001, 1.05, 0, 0, 1.51112],
    10756: [0.55001, 1.05, 0, 0, 1.11111],
    10758: [0.55001, 1.05, 0, 0, 1.11111]
  },
  "Size3-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [0.95003, 1.45, 0, 0, 0.73611],
    41: [0.95003, 1.45, 0, 0, 0.73611],
    47: [0.95003, 1.45, 0, 0, 1.04445],
    91: [0.95003, 1.45, 0, 0, 0.52778],
    92: [0.95003, 1.45, 0, 0, 1.04445],
    93: [0.95003, 1.45, 0, 0, 0.52778],
    123: [0.95003, 1.45, 0, 0, 0.75],
    125: [0.95003, 1.45, 0, 0, 0.75],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.75, 0, 0, 1.44445],
    732: [0, 0.75, 0, 0, 1.44445],
    770: [0, 0.75, 0, 0, 1.44445],
    771: [0, 0.75, 0, 0, 1.44445],
    8730: [0.95003, 1.45, 0, 0, 1],
    8968: [0.95003, 1.45, 0, 0, 0.58334],
    8969: [0.95003, 1.45, 0, 0, 0.58334],
    8970: [0.95003, 1.45, 0, 0, 0.58334],
    8971: [0.95003, 1.45, 0, 0, 0.58334],
    10216: [0.95003, 1.45, 0, 0, 0.75],
    10217: [0.95003, 1.45, 0, 0, 0.75]
  },
  "Size4-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [1.25003, 1.75, 0, 0, 0.79167],
    41: [1.25003, 1.75, 0, 0, 0.79167],
    47: [1.25003, 1.75, 0, 0, 1.27778],
    91: [1.25003, 1.75, 0, 0, 0.58334],
    92: [1.25003, 1.75, 0, 0, 1.27778],
    93: [1.25003, 1.75, 0, 0, 0.58334],
    123: [1.25003, 1.75, 0, 0, 0.80556],
    125: [1.25003, 1.75, 0, 0, 0.80556],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.825, 0, 0, 1.8889],
    732: [0, 0.825, 0, 0, 1.8889],
    770: [0, 0.825, 0, 0, 1.8889],
    771: [0, 0.825, 0, 0, 1.8889],
    8730: [1.25003, 1.75, 0, 0, 1],
    8968: [1.25003, 1.75, 0, 0, 0.63889],
    8969: [1.25003, 1.75, 0, 0, 0.63889],
    8970: [1.25003, 1.75, 0, 0, 0.63889],
    8971: [1.25003, 1.75, 0, 0, 0.63889],
    9115: [0.64502, 1.155, 0, 0, 0.875],
    9116: [1e-5, 0.6, 0, 0, 0.875],
    9117: [0.64502, 1.155, 0, 0, 0.875],
    9118: [0.64502, 1.155, 0, 0, 0.875],
    9119: [1e-5, 0.6, 0, 0, 0.875],
    9120: [0.64502, 1.155, 0, 0, 0.875],
    9121: [0.64502, 1.155, 0, 0, 0.66667],
    9122: [-99e-5, 0.601, 0, 0, 0.66667],
    9123: [0.64502, 1.155, 0, 0, 0.66667],
    9124: [0.64502, 1.155, 0, 0, 0.66667],
    9125: [-99e-5, 0.601, 0, 0, 0.66667],
    9126: [0.64502, 1.155, 0, 0, 0.66667],
    9127: [1e-5, 0.9, 0, 0, 0.88889],
    9128: [0.65002, 1.15, 0, 0, 0.88889],
    9129: [0.90001, 0, 0, 0, 0.88889],
    9130: [0, 0.3, 0, 0, 0.88889],
    9131: [1e-5, 0.9, 0, 0, 0.88889],
    9132: [0.65002, 1.15, 0, 0, 0.88889],
    9133: [0.90001, 0, 0, 0, 0.88889],
    9143: [0.88502, 0.915, 0, 0, 1.05556],
    10216: [1.25003, 1.75, 0, 0, 0.80556],
    10217: [1.25003, 1.75, 0, 0, 0.80556],
    57344: [-499e-5, 0.605, 0, 0, 1.05556],
    57345: [-499e-5, 0.605, 0, 0, 1.05556],
    57680: [0, 0.12, 0, 0, 0.45],
    57681: [0, 0.12, 0, 0, 0.45],
    57682: [0, 0.12, 0, 0, 0.45],
    57683: [0, 0.12, 0, 0, 0.45]
  },
  "Typewriter-Regular": {
    32: [0, 0, 0, 0, 0.525],
    33: [0, 0.61111, 0, 0, 0.525],
    34: [0, 0.61111, 0, 0, 0.525],
    35: [0, 0.61111, 0, 0, 0.525],
    36: [0.08333, 0.69444, 0, 0, 0.525],
    37: [0.08333, 0.69444, 0, 0, 0.525],
    38: [0, 0.61111, 0, 0, 0.525],
    39: [0, 0.61111, 0, 0, 0.525],
    40: [0.08333, 0.69444, 0, 0, 0.525],
    41: [0.08333, 0.69444, 0, 0, 0.525],
    42: [0, 0.52083, 0, 0, 0.525],
    43: [-0.08056, 0.53055, 0, 0, 0.525],
    44: [0.13889, 0.125, 0, 0, 0.525],
    45: [-0.08056, 0.53055, 0, 0, 0.525],
    46: [0, 0.125, 0, 0, 0.525],
    47: [0.08333, 0.69444, 0, 0, 0.525],
    48: [0, 0.61111, 0, 0, 0.525],
    49: [0, 0.61111, 0, 0, 0.525],
    50: [0, 0.61111, 0, 0, 0.525],
    51: [0, 0.61111, 0, 0, 0.525],
    52: [0, 0.61111, 0, 0, 0.525],
    53: [0, 0.61111, 0, 0, 0.525],
    54: [0, 0.61111, 0, 0, 0.525],
    55: [0, 0.61111, 0, 0, 0.525],
    56: [0, 0.61111, 0, 0, 0.525],
    57: [0, 0.61111, 0, 0, 0.525],
    58: [0, 0.43056, 0, 0, 0.525],
    59: [0.13889, 0.43056, 0, 0, 0.525],
    60: [-0.05556, 0.55556, 0, 0, 0.525],
    61: [-0.19549, 0.41562, 0, 0, 0.525],
    62: [-0.05556, 0.55556, 0, 0, 0.525],
    63: [0, 0.61111, 0, 0, 0.525],
    64: [0, 0.61111, 0, 0, 0.525],
    65: [0, 0.61111, 0, 0, 0.525],
    66: [0, 0.61111, 0, 0, 0.525],
    67: [0, 0.61111, 0, 0, 0.525],
    68: [0, 0.61111, 0, 0, 0.525],
    69: [0, 0.61111, 0, 0, 0.525],
    70: [0, 0.61111, 0, 0, 0.525],
    71: [0, 0.61111, 0, 0, 0.525],
    72: [0, 0.61111, 0, 0, 0.525],
    73: [0, 0.61111, 0, 0, 0.525],
    74: [0, 0.61111, 0, 0, 0.525],
    75: [0, 0.61111, 0, 0, 0.525],
    76: [0, 0.61111, 0, 0, 0.525],
    77: [0, 0.61111, 0, 0, 0.525],
    78: [0, 0.61111, 0, 0, 0.525],
    79: [0, 0.61111, 0, 0, 0.525],
    80: [0, 0.61111, 0, 0, 0.525],
    81: [0.13889, 0.61111, 0, 0, 0.525],
    82: [0, 0.61111, 0, 0, 0.525],
    83: [0, 0.61111, 0, 0, 0.525],
    84: [0, 0.61111, 0, 0, 0.525],
    85: [0, 0.61111, 0, 0, 0.525],
    86: [0, 0.61111, 0, 0, 0.525],
    87: [0, 0.61111, 0, 0, 0.525],
    88: [0, 0.61111, 0, 0, 0.525],
    89: [0, 0.61111, 0, 0, 0.525],
    90: [0, 0.61111, 0, 0, 0.525],
    91: [0.08333, 0.69444, 0, 0, 0.525],
    92: [0.08333, 0.69444, 0, 0, 0.525],
    93: [0.08333, 0.69444, 0, 0, 0.525],
    94: [0, 0.61111, 0, 0, 0.525],
    95: [0.09514, 0, 0, 0, 0.525],
    96: [0, 0.61111, 0, 0, 0.525],
    97: [0, 0.43056, 0, 0, 0.525],
    98: [0, 0.61111, 0, 0, 0.525],
    99: [0, 0.43056, 0, 0, 0.525],
    100: [0, 0.61111, 0, 0, 0.525],
    101: [0, 0.43056, 0, 0, 0.525],
    102: [0, 0.61111, 0, 0, 0.525],
    103: [0.22222, 0.43056, 0, 0, 0.525],
    104: [0, 0.61111, 0, 0, 0.525],
    105: [0, 0.61111, 0, 0, 0.525],
    106: [0.22222, 0.61111, 0, 0, 0.525],
    107: [0, 0.61111, 0, 0, 0.525],
    108: [0, 0.61111, 0, 0, 0.525],
    109: [0, 0.43056, 0, 0, 0.525],
    110: [0, 0.43056, 0, 0, 0.525],
    111: [0, 0.43056, 0, 0, 0.525],
    112: [0.22222, 0.43056, 0, 0, 0.525],
    113: [0.22222, 0.43056, 0, 0, 0.525],
    114: [0, 0.43056, 0, 0, 0.525],
    115: [0, 0.43056, 0, 0, 0.525],
    116: [0, 0.55358, 0, 0, 0.525],
    117: [0, 0.43056, 0, 0, 0.525],
    118: [0, 0.43056, 0, 0, 0.525],
    119: [0, 0.43056, 0, 0, 0.525],
    120: [0, 0.43056, 0, 0, 0.525],
    121: [0.22222, 0.43056, 0, 0, 0.525],
    122: [0, 0.43056, 0, 0, 0.525],
    123: [0.08333, 0.69444, 0, 0, 0.525],
    124: [0.08333, 0.69444, 0, 0, 0.525],
    125: [0.08333, 0.69444, 0, 0, 0.525],
    126: [0, 0.61111, 0, 0, 0.525],
    127: [0, 0.61111, 0, 0, 0.525],
    160: [0, 0, 0, 0, 0.525],
    176: [0, 0.61111, 0, 0, 0.525],
    184: [0.19445, 0, 0, 0, 0.525],
    305: [0, 0.43056, 0, 0, 0.525],
    567: [0.22222, 0.43056, 0, 0, 0.525],
    711: [0, 0.56597, 0, 0, 0.525],
    713: [0, 0.56555, 0, 0, 0.525],
    714: [0, 0.61111, 0, 0, 0.525],
    715: [0, 0.61111, 0, 0, 0.525],
    728: [0, 0.61111, 0, 0, 0.525],
    730: [0, 0.61111, 0, 0, 0.525],
    770: [0, 0.61111, 0, 0, 0.525],
    771: [0, 0.61111, 0, 0, 0.525],
    776: [0, 0.61111, 0, 0, 0.525],
    915: [0, 0.61111, 0, 0, 0.525],
    916: [0, 0.61111, 0, 0, 0.525],
    920: [0, 0.61111, 0, 0, 0.525],
    923: [0, 0.61111, 0, 0, 0.525],
    926: [0, 0.61111, 0, 0, 0.525],
    928: [0, 0.61111, 0, 0, 0.525],
    931: [0, 0.61111, 0, 0, 0.525],
    933: [0, 0.61111, 0, 0, 0.525],
    934: [0, 0.61111, 0, 0, 0.525],
    936: [0, 0.61111, 0, 0, 0.525],
    937: [0, 0.61111, 0, 0, 0.525],
    8216: [0, 0.61111, 0, 0, 0.525],
    8217: [0, 0.61111, 0, 0, 0.525],
    8242: [0, 0.61111, 0, 0, 0.525],
    9251: [0.11111, 0.21944, 0, 0, 0.525]
  }
}, Qp = {
  slant: [0.25, 0.25, 0.25],
  // sigma1
  space: [0, 0, 0],
  // sigma2
  stretch: [0, 0, 0],
  // sigma3
  shrink: [0, 0, 0],
  // sigma4
  xHeight: [0.431, 0.431, 0.431],
  // sigma5
  quad: [1, 1.171, 1.472],
  // sigma6
  extraSpace: [0, 0, 0],
  // sigma7
  num1: [0.677, 0.732, 0.925],
  // sigma8
  num2: [0.394, 0.384, 0.387],
  // sigma9
  num3: [0.444, 0.471, 0.504],
  // sigma10
  denom1: [0.686, 0.752, 1.025],
  // sigma11
  denom2: [0.345, 0.344, 0.532],
  // sigma12
  sup1: [0.413, 0.503, 0.504],
  // sigma13
  sup2: [0.363, 0.431, 0.404],
  // sigma14
  sup3: [0.289, 0.286, 0.294],
  // sigma15
  sub1: [0.15, 0.143, 0.2],
  // sigma16
  sub2: [0.247, 0.286, 0.4],
  // sigma17
  supDrop: [0.386, 0.353, 0.494],
  // sigma18
  subDrop: [0.05, 0.071, 0.1],
  // sigma19
  delim1: [2.39, 1.7, 1.98],
  // sigma20
  delim2: [1.01, 1.157, 1.42],
  // sigma21
  axisHeight: [0.25, 0.25, 0.25],
  // sigma22
  // These font metrics are extracted from TeX by using tftopl on cmex10.tfm;
  // they correspond to the font parameters of the extension fonts (family 3).
  // See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to
  // match cmex7, we'd use cmex7.tfm values for script and scriptscript
  // values.
  defaultRuleThickness: [0.04, 0.049, 0.049],
  // xi8; cmex7: 0.049
  bigOpSpacing1: [0.111, 0.111, 0.111],
  // xi9
  bigOpSpacing2: [0.166, 0.166, 0.166],
  // xi10
  bigOpSpacing3: [0.2, 0.2, 0.2],
  // xi11
  bigOpSpacing4: [0.6, 0.611, 0.611],
  // xi12; cmex7: 0.611
  bigOpSpacing5: [0.1, 0.143, 0.143],
  // xi13; cmex7: 0.143
  // The \sqrt rule width is taken from the height of the surd character.
  // Since we use the same font at all sizes, this thickness doesn't scale.
  sqrtRuleThickness: [0.04, 0.04, 0.04],
  // This value determines how large a pt is, for metrics which are defined
  // in terms of pts.
  // This value is also used in katex.scss; if you change it make sure the
  // values match.
  ptPerEm: [10, 10, 10],
  // The space between adjacent `|` columns in an array definition. From
  // `\showthe\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.
  doubleRuleSep: [0.2, 0.2, 0.2],
  // The width of separator lines in {array} environments. From
  // `\showthe\arrayrulewidth` in LaTeX. Equals 0.4 / ptPerEm.
  arrayRuleWidth: [0.04, 0.04, 0.04],
  // Two values from LaTeX source2e:
  fboxsep: [0.3, 0.3, 0.3],
  //        3 pt / ptPerEm
  fboxrule: [0.04, 0.04, 0.04]
  // 0.4 pt / ptPerEm
}, K6 = {
  // Latin-1
  Å: "A",
  Ð: "D",
  Þ: "o",
  å: "a",
  ð: "d",
  þ: "o",
  // Cyrillic
  А: "A",
  Б: "B",
  В: "B",
  Г: "F",
  Д: "A",
  Е: "E",
  Ж: "K",
  З: "3",
  И: "N",
  Й: "N",
  К: "K",
  Л: "N",
  М: "M",
  Н: "H",
  О: "O",
  П: "N",
  Р: "P",
  С: "C",
  Т: "T",
  У: "y",
  Ф: "O",
  Х: "X",
  Ц: "U",
  Ч: "h",
  Ш: "W",
  Щ: "W",
  Ъ: "B",
  Ы: "X",
  Ь: "B",
  Э: "3",
  Ю: "X",
  Я: "R",
  а: "a",
  б: "b",
  в: "a",
  г: "r",
  д: "y",
  е: "e",
  ж: "m",
  з: "e",
  и: "n",
  й: "n",
  к: "n",
  л: "n",
  м: "m",
  н: "n",
  о: "o",
  п: "n",
  р: "p",
  с: "c",
  т: "o",
  у: "y",
  ф: "b",
  х: "x",
  ц: "n",
  ч: "n",
  ш: "w",
  щ: "w",
  ъ: "a",
  ы: "m",
  ь: "a",
  э: "e",
  ю: "m",
  я: "r"
};
function F$(t, e) {
  fs[t] = e;
}
function bC(t, e, r) {
  if (!fs[e])
    throw new Error("Font metrics not found for font: " + e + ".");
  var n = t.charCodeAt(0), a = fs[e][n];
  if (!a && t[0] in K6 && (n = K6[t[0]].charCodeAt(0), a = fs[e][n]), !a && r === "text" && $$(n) && (a = fs[e][77]), a)
    return {
      depth: a[0],
      height: a[1],
      italic: a[2],
      skew: a[3],
      width: a[4]
    };
}
var Ox = {};
function nve(t) {
  var e;
  if (t >= 5 ? e = 0 : t >= 3 ? e = 1 : e = 2, !Ox[e]) {
    var r = Ox[e] = {
      cssEmPerMu: Qp.quad[e] / 18
    };
    for (var n in Qp)
      Qp.hasOwnProperty(n) && (r[n] = Qp[n][e]);
  }
  return Ox[e];
}
var ave = [
  // Each element contains [textsize, scriptsize, scriptscriptsize].
  // The size mappings are taken from TeX with \normalsize=10pt.
  [1, 1, 1],
  // size1: [5, 5, 5]              \tiny
  [2, 1, 1],
  // size2: [6, 5, 5]
  [3, 1, 1],
  // size3: [7, 5, 5]              \scriptsize
  [4, 2, 1],
  // size4: [8, 6, 5]              \footnotesize
  [5, 2, 1],
  // size5: [9, 6, 5]              \small
  [6, 3, 1],
  // size6: [10, 7, 5]             \normalsize
  [7, 4, 2],
  // size7: [12, 8, 6]             \large
  [8, 6, 3],
  // size8: [14.4, 10, 7]          \Large
  [9, 7, 6],
  // size9: [17.28, 12, 10]        \LARGE
  [10, 8, 7],
  // size10: [20.74, 14.4, 12]     \huge
  [11, 10, 9]
  // size11: [24.88, 20.74, 17.28] \HUGE
], Z6 = [
  // fontMetrics.js:getGlobalMetrics also uses size indexes, so if
  // you change size indexes, change that function.
  0.5,
  0.6,
  0.7,
  0.8,
  0.9,
  1,
  1.2,
  1.44,
  1.728,
  2.074,
  2.488
], Q6 = function(e, r) {
  return r.size < 2 ? e : ave[e - 1][r.size - 1];
};
class Fs {
  // A font family applies to a group of fonts (i.e. SansSerif), while a font
  // represents a specific font (i.e. SansSerif Bold).
  // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm
  /**
   * The base size index.
   */
  constructor(e) {
    this.style = void 0, this.color = void 0, this.size = void 0, this.textSize = void 0, this.phantom = void 0, this.font = void 0, this.fontFamily = void 0, this.fontWeight = void 0, this.fontShape = void 0, this.sizeMultiplier = void 0, this.maxSize = void 0, this.minRuleThickness = void 0, this._fontMetrics = void 0, this.style = e.style, this.color = e.color, this.size = e.size || Fs.BASESIZE, this.textSize = e.textSize || this.size, this.phantom = !!e.phantom, this.font = e.font || "", this.fontFamily = e.fontFamily || "", this.fontWeight = e.fontWeight || "", this.fontShape = e.fontShape || "", this.sizeMultiplier = Z6[this.size - 1], this.maxSize = e.maxSize, this.minRuleThickness = e.minRuleThickness, this._fontMetrics = void 0;
  }
  /**
   * Returns a new options object with the same properties as "this".  Properties
   * from "extension" will be copied to the new options object.
   */
  extend(e) {
    var r = {
      style: this.style,
      size: this.size,
      textSize: this.textSize,
      color: this.color,
      phantom: this.phantom,
      font: this.font,
      fontFamily: this.fontFamily,
      fontWeight: this.fontWeight,
      fontShape: this.fontShape,
      maxSize: this.maxSize,
      minRuleThickness: this.minRuleThickness
    };
    for (var n in e)
      e.hasOwnProperty(n) && (r[n] = e[n]);
    return new Fs(r);
  }
  /**
   * Return an options object with the given style. If `this.style === style`,
   * returns `this`.
   */
  havingStyle(e) {
    return this.style === e ? this : this.extend({
      style: e,
      size: Q6(this.textSize, e)
    });
  }
  /**
   * Return an options object with a cramped version of the current style. If
   * the current style is cramped, returns `this`.
   */
  havingCrampedStyle() {
    return this.havingStyle(this.style.cramp());
  }
  /**
   * Return an options object with the given size and in at least `\textstyle`.
   * Returns `this` if appropriate.
   */
  havingSize(e) {
    return this.size === e && this.textSize === e ? this : this.extend({
      style: this.style.text(),
      size: e,
      textSize: e,
      sizeMultiplier: Z6[e - 1]
    });
  }
  /**
   * Like `this.havingSize(BASESIZE).havingStyle(style)`. If `style` is omitted,
   * changes to at least `\textstyle`.
   */
  havingBaseStyle(e) {
    e = e || this.style.text();
    var r = Q6(Fs.BASESIZE, e);
    return this.size === r && this.textSize === Fs.BASESIZE && this.style === e ? this : this.extend({
      style: e,
      size: r
    });
  }
  /**
   * Remove the effect of sizing changes such as \Huge.
   * Keep the effect of the current style, such as \scriptstyle.
   */
  havingBaseSizing() {
    var e;
    switch (this.style.id) {
      case 4:
      case 5:
        e = 3;
        break;
      case 6:
      case 7:
        e = 1;
        break;
      default:
        e = 6;
    }
    return this.extend({
      style: this.style.text(),
      size: e
    });
  }
  /**
   * Create a new options object with the given color.
   */
  withColor(e) {
    return this.extend({
      color: e
    });
  }
  /**
   * Create a new options object with "phantom" set to true.
   */
  withPhantom() {
    return this.extend({
      phantom: !0
    });
  }
  /**
   * Creates a new options object with the given math font or old text font.
   * @type {[type]}
   */
  withFont(e) {
    return this.extend({
      font: e
    });
  }
  /**
   * Create a new options objects with the given fontFamily.
   */
  withTextFontFamily(e) {
    return this.extend({
      fontFamily: e,
      font: ""
    });
  }
  /**
   * Creates a new options object with the given font weight
   */
  withTextFontWeight(e) {
    return this.extend({
      fontWeight: e,
      font: ""
    });
  }
  /**
   * Creates a new options object with the given font weight
   */
  withTextFontShape(e) {
    return this.extend({
      fontShape: e,
      font: ""
    });
  }
  /**
   * Return the CSS sizing classes required to switch from enclosing options
   * `oldOptions` to `this`. Returns an array of classes.
   */
  sizingClasses(e) {
    return e.size !== this.size ? ["sizing", "reset-size" + e.size, "size" + this.size] : [];
  }
  /**
   * Return the CSS sizing classes required to switch to the base size. Like
   * `this.havingSize(BASESIZE).sizingClasses(this)`.
   */
  baseSizingClasses() {
    return this.size !== Fs.BASESIZE ? ["sizing", "reset-size" + this.size, "size" + Fs.BASESIZE] : [];
  }
  /**
   * Return the font metrics for this size.
   */
  fontMetrics() {
    return this._fontMetrics || (this._fontMetrics = nve(this.size)), this._fontMetrics;
  }
  /**
   * Gets the CSS color of the current options object
   */
  getColor() {
    return this.phantom ? "transparent" : this.color;
  }
}
Fs.BASESIZE = 6;
var o4 = {
  // https://en.wikibooks.org/wiki/LaTeX/Lengths and
  // https://tex.stackexchange.com/a/8263
  pt: 1,
  // TeX point
  mm: 7227 / 2540,
  // millimeter
  cm: 7227 / 254,
  // centimeter
  in: 72.27,
  // inch
  bp: 803 / 800,
  // big (PostScript) points
  pc: 12,
  // pica
  dd: 1238 / 1157,
  // didot
  cc: 14856 / 1157,
  // cicero (12 didot)
  nd: 685 / 642,
  // new didot
  nc: 1370 / 107,
  // new cicero (12 new didot)
  sp: 1 / 65536,
  // scaled point (TeX's internal smallest unit)
  // https://tex.stackexchange.com/a/41371
  px: 803 / 800
  // \pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX
}, ive = {
  ex: !0,
  em: !0,
  mu: !0
}, B$ = function(e) {
  return typeof e != "string" && (e = e.unit), e in o4 || e in ive || e === "ex";
}, Ur = function(e, r) {
  var n;
  if (e.unit in o4)
    n = o4[e.unit] / r.fontMetrics().ptPerEm / r.sizeMultiplier;
  else if (e.unit === "mu")
    n = r.fontMetrics().cssEmPerMu;
  else {
    var a;
    if (r.style.isTight() ? a = r.havingStyle(r.style.text()) : a = r, e.unit === "ex")
      n = a.fontMetrics().xHeight;
    else if (e.unit === "em")
      n = a.fontMetrics().quad;
    else
      throw new Ve("Invalid unit: '" + e.unit + "'");
    a !== r && (n *= a.sizeMultiplier / r.sizeMultiplier);
  }
  return Math.min(e.number * n, r.maxSize);
}, Qe = function(e) {
  return +e.toFixed(4) + "em";
}, Vo = function(e) {
  return e.filter((r) => r).join(" ");
}, z$ = function(e, r, n) {
  if (this.classes = e || [], this.attributes = {}, this.height = 0, this.depth = 0, this.maxFontSize = 0, this.style = n || {}, r) {
    r.style.isTight() && this.classes.push("mtight");
    var a = r.getColor();
    a && (this.style.color = a);
  }
}, G$ = function(e) {
  var r = document.createElement(e);
  r.className = Vo(this.classes);
  for (var n in this.style)
    this.style.hasOwnProperty(n) && (r.style[n] = this.style[n]);
  for (var a in this.attributes)
    this.attributes.hasOwnProperty(a) && r.setAttribute(a, this.attributes[a]);
  for (var i = 0; i < this.children.length; i++)
    r.appendChild(this.children[i].toNode());
  return r;
}, sve = /[\s"'>/=\x00-\x1f]/, U$ = function(e) {
  var r = "<" + e;
  this.classes.length && (r += ' class="' + rr.escape(Vo(this.classes)) + '"');
  var n = "";
  for (var a in this.style)
    this.style.hasOwnProperty(a) && (n += rr.hyphenate(a) + ":" + this.style[a] + ";");
  n && (r += ' style="' + rr.escape(n) + '"');
  for (var i in this.attributes)
    if (this.attributes.hasOwnProperty(i)) {
      if (sve.test(i))
        throw new Ve("Invalid attribute name '" + i + "'");
      r += " " + i + '="' + rr.escape(this.attributes[i]) + '"';
    }
  r += ">";
  for (var s = 0; s < this.children.length; s++)
    r += this.children[s].toMarkup();
  return r += "</" + e + ">", r;
};
class tp {
  constructor(e, r, n, a) {
    this.children = void 0, this.attributes = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.width = void 0, this.maxFontSize = void 0, this.style = void 0, z$.call(this, e, n, a), this.children = r || [];
  }
  /**
   * Sets an arbitrary attribute on the span. Warning: use this wisely. Not
   * all browsers support attributes the same, and having too many custom
   * attributes is probably bad.
   */
  setAttribute(e, r) {
    this.attributes[e] = r;
  }
  hasClass(e) {
    return this.classes.includes(e);
  }
  toNode() {
    return G$.call(this, "span");
  }
  toMarkup() {
    return U$.call(this, "span");
  }
}
class xC {
  constructor(e, r, n, a) {
    this.children = void 0, this.attributes = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, z$.call(this, r, a), this.children = n || [], this.setAttribute("href", e);
  }
  setAttribute(e, r) {
    this.attributes[e] = r;
  }
  hasClass(e) {
    return this.classes.includes(e);
  }
  toNode() {
    return G$.call(this, "a");
  }
  toMarkup() {
    return U$.call(this, "a");
  }
}
class ove {
  constructor(e, r, n) {
    this.src = void 0, this.alt = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, this.alt = r, this.src = e, this.classes = ["mord"], this.style = n;
  }
  hasClass(e) {
    return this.classes.includes(e);
  }
  toNode() {
    var e = document.createElement("img");
    e.src = this.src, e.alt = this.alt, e.className = "mord";
    for (var r in this.style)
      this.style.hasOwnProperty(r) && (e.style[r] = this.style[r]);
    return e;
  }
  toMarkup() {
    var e = '<img src="' + rr.escape(this.src) + '"' + (' alt="' + rr.escape(this.alt) + '"'), r = "";
    for (var n in this.style)
      this.style.hasOwnProperty(n) && (r += rr.hyphenate(n) + ":" + this.style[n] + ";");
    return r && (e += ' style="' + rr.escape(r) + '"'), e += "'/>", e;
  }
}
var lve = {
  î: "ı̂",
  ï: "ı̈",
  í: "ı́",
  // 'ī': '\u0131\u0304', // enable when we add Extended Latin
  ì: "ı̀"
};
class Ei {
  constructor(e, r, n, a, i, s, o, l) {
    this.text = void 0, this.height = void 0, this.depth = void 0, this.italic = void 0, this.skew = void 0, this.width = void 0, this.maxFontSize = void 0, this.classes = void 0, this.style = void 0, this.text = e, this.height = r || 0, this.depth = n || 0, this.italic = a || 0, this.skew = i || 0, this.width = s || 0, this.classes = o || [], this.style = l || {}, this.maxFontSize = 0;
    var u = Wge(this.text.charCodeAt(0));
    u && this.classes.push(u + "_fallback"), /[îïíì]/.test(this.text) && (this.text = lve[this.text]);
  }
  hasClass(e) {
    return this.classes.includes(e);
  }
  /**
   * Creates a text node or span from a symbol node. Note that a span is only
   * created if it is needed.
   */
  toNode() {
    var e = document.createTextNode(this.text), r = null;
    this.italic > 0 && (r = document.createElement("span"), r.style.marginRight = Qe(this.italic)), this.classes.length > 0 && (r = r || document.createElement("span"), r.className = Vo(this.classes));
    for (var n in this.style)
      this.style.hasOwnProperty(n) && (r = r || document.createElement("span"), r.style[n] = this.style[n]);
    return r ? (r.appendChild(e), r) : e;
  }
  /**
   * Creates markup for a symbol node.
   */
  toMarkup() {
    var e = !1, r = "<span";
    this.classes.length && (e = !0, r += ' class="', r += rr.escape(Vo(this.classes)), r += '"');
    var n = "";
    this.italic > 0 && (n += "margin-right:" + this.italic + "em;");
    for (var a in this.style)
      this.style.hasOwnProperty(a) && (n += rr.hyphenate(a) + ":" + this.style[a] + ";");
    n && (e = !0, r += ' style="' + rr.escape(n) + '"');
    var i = rr.escape(this.text);
    return e ? (r += ">", r += i, r += "</span>", r) : i;
  }
}
class ao {
  constructor(e, r) {
    this.children = void 0, this.attributes = void 0, this.children = e || [], this.attributes = r || {};
  }
  toNode() {
    var e = "http://www.w3.org/2000/svg", r = document.createElementNS(e, "svg");
    for (var n in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, n) && r.setAttribute(n, this.attributes[n]);
    for (var a = 0; a < this.children.length; a++)
      r.appendChild(this.children[a].toNode());
    return r;
  }
  toMarkup() {
    var e = '<svg xmlns="http://www.w3.org/2000/svg"';
    for (var r in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, r) && (e += " " + r + '="' + rr.escape(this.attributes[r]) + '"');
    e += ">";
    for (var n = 0; n < this.children.length; n++)
      e += this.children[n].toMarkup();
    return e += "</svg>", e;
  }
}
class qo {
  constructor(e, r) {
    this.pathName = void 0, this.alternate = void 0, this.pathName = e, this.alternate = r;
  }
  toNode() {
    var e = "http://www.w3.org/2000/svg", r = document.createElementNS(e, "path");
    return this.alternate ? r.setAttribute("d", this.alternate) : r.setAttribute("d", X6[this.pathName]), r;
  }
  toMarkup() {
    return this.alternate ? '<path d="' + rr.escape(this.alternate) + '"/>' : '<path d="' + rr.escape(X6[this.pathName]) + '"/>';
  }
}
class l4 {
  constructor(e) {
    this.attributes = void 0, this.attributes = e || {};
  }
  toNode() {
    var e = "http://www.w3.org/2000/svg", r = document.createElementNS(e, "line");
    for (var n in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, n) && r.setAttribute(n, this.attributes[n]);
    return r;
  }
  toMarkup() {
    var e = "<line";
    for (var r in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, r) && (e += " " + r + '="' + rr.escape(this.attributes[r]) + '"');
    return e += "/>", e;
  }
}
function J6(t) {
  if (t instanceof Ei)
    return t;
  throw new Error("Expected symbolNode but got " + String(t) + ".");
}
function uve(t) {
  if (t instanceof tp)
    return t;
  throw new Error("Expected span<HtmlDomNode> but got " + String(t) + ".");
}
var cve = {
  bin: 1,
  close: 1,
  inner: 1,
  open: 1,
  punct: 1,
  rel: 1
}, fve = {
  "accent-token": 1,
  mathord: 1,
  "op-token": 1,
  spacing: 1,
  textord: 1
}, Mr = {
  math: {},
  text: {}
};
function P(t, e, r, n, a, i) {
  Mr[t][a] = {
    font: e,
    group: r,
    replace: n
  }, i && n && (Mr[t][n] = Mr[t][a]);
}
var $ = "math", Fe = "text", U = "main", re = "ams", Br = "accent-token", ut = "bin", ma = "close", Af = "inner", St = "mathord", hn = "op-token", ii = "open", I1 = "punct", ie = "rel", bo = "spacing", ce = "textord";
P($, U, ie, "≡", "\\equiv", !0);
P($, U, ie, "≺", "\\prec", !0);
P($, U, ie, "≻", "\\succ", !0);
P($, U, ie, "∼", "\\sim", !0);
P($, U, ie, "⊥", "\\perp");
P($, U, ie, "⪯", "\\preceq", !0);
P($, U, ie, "⪰", "\\succeq", !0);
P($, U, ie, "≃", "\\simeq", !0);
P($, U, ie, "∣", "\\mid", !0);
P($, U, ie, "≪", "\\ll", !0);
P($, U, ie, "≫", "\\gg", !0);
P($, U, ie, "≍", "\\asymp", !0);
P($, U, ie, "∥", "\\parallel");
P($, U, ie, "⋈", "\\bowtie", !0);
P($, U, ie, "⌣", "\\smile", !0);
P($, U, ie, "⊑", "\\sqsubseteq", !0);
P($, U, ie, "⊒", "\\sqsupseteq", !0);
P($, U, ie, "≐", "\\doteq", !0);
P($, U, ie, "⌢", "\\frown", !0);
P($, U, ie, "∋", "\\ni", !0);
P($, U, ie, "∝", "\\propto", !0);
P($, U, ie, "⊢", "\\vdash", !0);
P($, U, ie, "⊣", "\\dashv", !0);
P($, U, ie, "∋", "\\owns");
P($, U, I1, ".", "\\ldotp");
P($, U, I1, "⋅", "\\cdotp");
P($, U, ce, "#", "\\#");
P(Fe, U, ce, "#", "\\#");
P($, U, ce, "&", "\\&");
P(Fe, U, ce, "&", "\\&");
P($, U, ce, "ℵ", "\\aleph", !0);
P($, U, ce, "∀", "\\forall", !0);
P($, U, ce, "ℏ", "\\hbar", !0);
P($, U, ce, "∃", "\\exists", !0);
P($, U, ce, "∇", "\\nabla", !0);
P($, U, ce, "♭", "\\flat", !0);
P($, U, ce, "ℓ", "\\ell", !0);
P($, U, ce, "♮", "\\natural", !0);
P($, U, ce, "♣", "\\clubsuit", !0);
P($, U, ce, "℘", "\\wp", !0);
P($, U, ce, "♯", "\\sharp", !0);
P($, U, ce, "♢", "\\diamondsuit", !0);
P($, U, ce, "ℜ", "\\Re", !0);
P($, U, ce, "♡", "\\heartsuit", !0);
P($, U, ce, "ℑ", "\\Im", !0);
P($, U, ce, "♠", "\\spadesuit", !0);
P($, U, ce, "§", "\\S", !0);
P(Fe, U, ce, "§", "\\S");
P($, U, ce, "¶", "\\P", !0);
P(Fe, U, ce, "¶", "\\P");
P($, U, ce, "†", "\\dag");
P(Fe, U, ce, "†", "\\dag");
P(Fe, U, ce, "†", "\\textdagger");
P($, U, ce, "‡", "\\ddag");
P(Fe, U, ce, "‡", "\\ddag");
P(Fe, U, ce, "‡", "\\textdaggerdbl");
P($, U, ma, "⎱", "\\rmoustache", !0);
P($, U, ii, "⎰", "\\lmoustache", !0);
P($, U, ma, "⟯", "\\rgroup", !0);
P($, U, ii, "⟮", "\\lgroup", !0);
P($, U, ut, "∓", "\\mp", !0);
P($, U, ut, "⊖", "\\ominus", !0);
P($, U, ut, "⊎", "\\uplus", !0);
P($, U, ut, "⊓", "\\sqcap", !0);
P($, U, ut, "∗", "\\ast");
P($, U, ut, "⊔", "\\sqcup", !0);
P($, U, ut, "◯", "\\bigcirc", !0);
P($, U, ut, "∙", "\\bullet", !0);
P($, U, ut, "‡", "\\ddagger");
P($, U, ut, "≀", "\\wr", !0);
P($, U, ut, "⨿", "\\amalg");
P($, U, ut, "&", "\\And");
P($, U, ie, "⟵", "\\longleftarrow", !0);
P($, U, ie, "⇐", "\\Leftarrow", !0);
P($, U, ie, "⟸", "\\Longleftarrow", !0);
P($, U, ie, "⟶", "\\longrightarrow", !0);
P($, U, ie, "⇒", "\\Rightarrow", !0);
P($, U, ie, "⟹", "\\Longrightarrow", !0);
P($, U, ie, "↔", "\\leftrightarrow", !0);
P($, U, ie, "⟷", "\\longleftrightarrow", !0);
P($, U, ie, "⇔", "\\Leftrightarrow", !0);
P($, U, ie, "⟺", "\\Longleftrightarrow", !0);
P($, U, ie, "↦", "\\mapsto", !0);
P($, U, ie, "⟼", "\\longmapsto", !0);
P($, U, ie, "↗", "\\nearrow", !0);
P($, U, ie, "↩", "\\hookleftarrow", !0);
P($, U, ie, "↪", "\\hookrightarrow", !0);
P($, U, ie, "↘", "\\searrow", !0);
P($, U, ie, "↼", "\\leftharpoonup", !0);
P($, U, ie, "⇀", "\\rightharpoonup", !0);
P($, U, ie, "↙", "\\swarrow", !0);
P($, U, ie, "↽", "\\leftharpoondown", !0);
P($, U, ie, "⇁", "\\rightharpoondown", !0);
P($, U, ie, "↖", "\\nwarrow", !0);
P($, U, ie, "⇌", "\\rightleftharpoons", !0);
P($, re, ie, "≮", "\\nless", !0);
P($, re, ie, "", "\\@nleqslant");
P($, re, ie, "", "\\@nleqq");
P($, re, ie, "⪇", "\\lneq", !0);
P($, re, ie, "≨", "\\lneqq", !0);
P($, re, ie, "", "\\@lvertneqq");
P($, re, ie, "⋦", "\\lnsim", !0);
P($, re, ie, "⪉", "\\lnapprox", !0);
P($, re, ie, "⊀", "\\nprec", !0);
P($, re, ie, "⋠", "\\npreceq", !0);
P($, re, ie, "⋨", "\\precnsim", !0);
P($, re, ie, "⪹", "\\precnapprox", !0);
P($, re, ie, "≁", "\\nsim", !0);
P($, re, ie, "", "\\@nshortmid");
P($, re, ie, "∤", "\\nmid", !0);
P($, re, ie, "⊬", "\\nvdash", !0);
P($, re, ie, "⊭", "\\nvDash", !0);
P($, re, ie, "⋪", "\\ntriangleleft");
P($, re, ie, "⋬", "\\ntrianglelefteq", !0);
P($, re, ie, "⊊", "\\subsetneq", !0);
P($, re, ie, "", "\\@varsubsetneq");
P($, re, ie, "⫋", "\\subsetneqq", !0);
P($, re, ie, "", "\\@varsubsetneqq");
P($, re, ie, "≯", "\\ngtr", !0);
P($, re, ie, "", "\\@ngeqslant");
P($, re, ie, "", "\\@ngeqq");
P($, re, ie, "⪈", "\\gneq", !0);
P($, re, ie, "≩", "\\gneqq", !0);
P($, re, ie, "", "\\@gvertneqq");
P($, re, ie, "⋧", "\\gnsim", !0);
P($, re, ie, "⪊", "\\gnapprox", !0);
P($, re, ie, "⊁", "\\nsucc", !0);
P($, re, ie, "⋡", "\\nsucceq", !0);
P($, re, ie, "⋩", "\\succnsim", !0);
P($, re, ie, "⪺", "\\succnapprox", !0);
P($, re, ie, "≆", "\\ncong", !0);
P($, re, ie, "", "\\@nshortparallel");
P($, re, ie, "∦", "\\nparallel", !0);
P($, re, ie, "⊯", "\\nVDash", !0);
P($, re, ie, "⋫", "\\ntriangleright");
P($, re, ie, "⋭", "\\ntrianglerighteq", !0);
P($, re, ie, "", "\\@nsupseteqq");
P($, re, ie, "⊋", "\\supsetneq", !0);
P($, re, ie, "", "\\@varsupsetneq");
P($, re, ie, "⫌", "\\supsetneqq", !0);
P($, re, ie, "", "\\@varsupsetneqq");
P($, re, ie, "⊮", "\\nVdash", !0);
P($, re, ie, "⪵", "\\precneqq", !0);
P($, re, ie, "⪶", "\\succneqq", !0);
P($, re, ie, "", "\\@nsubseteqq");
P($, re, ut, "⊴", "\\unlhd");
P($, re, ut, "⊵", "\\unrhd");
P($, re, ie, "↚", "\\nleftarrow", !0);
P($, re, ie, "↛", "\\nrightarrow", !0);
P($, re, ie, "⇍", "\\nLeftarrow", !0);
P($, re, ie, "⇏", "\\nRightarrow", !0);
P($, re, ie, "↮", "\\nleftrightarrow", !0);
P($, re, ie, "⇎", "\\nLeftrightarrow", !0);
P($, re, ie, "△", "\\vartriangle");
P($, re, ce, "ℏ", "\\hslash");
P($, re, ce, "▽", "\\triangledown");
P($, re, ce, "◊", "\\lozenge");
P($, re, ce, "Ⓢ", "\\circledS");
P($, re, ce, "®", "\\circledR");
P(Fe, re, ce, "®", "\\circledR");
P($, re, ce, "∡", "\\measuredangle", !0);
P($, re, ce, "∄", "\\nexists");
P($, re, ce, "℧", "\\mho");
P($, re, ce, "Ⅎ", "\\Finv", !0);
P($, re, ce, "⅁", "\\Game", !0);
P($, re, ce, "‵", "\\backprime");
P($, re, ce, "▲", "\\blacktriangle");
P($, re, ce, "▼", "\\blacktriangledown");
P($, re, ce, "■", "\\blacksquare");
P($, re, ce, "⧫", "\\blacklozenge");
P($, re, ce, "★", "\\bigstar");
P($, re, ce, "∢", "\\sphericalangle", !0);
P($, re, ce, "∁", "\\complement", !0);
P($, re, ce, "ð", "\\eth", !0);
P(Fe, U, ce, "ð", "ð");
P($, re, ce, "╱", "\\diagup");
P($, re, ce, "╲", "\\diagdown");
P($, re, ce, "□", "\\square");
P($, re, ce, "□", "\\Box");
P($, re, ce, "◊", "\\Diamond");
P($, re, ce, "¥", "\\yen", !0);
P(Fe, re, ce, "¥", "\\yen", !0);
P($, re, ce, "✓", "\\checkmark", !0);
P(Fe, re, ce, "✓", "\\checkmark");
P($, re, ce, "ℶ", "\\beth", !0);
P($, re, ce, "ℸ", "\\daleth", !0);
P($, re, ce, "ℷ", "\\gimel", !0);
P($, re, ce, "ϝ", "\\digamma", !0);
P($, re, ce, "ϰ", "\\varkappa");
P($, re, ii, "┌", "\\@ulcorner", !0);
P($, re, ma, "┐", "\\@urcorner", !0);
P($, re, ii, "└", "\\@llcorner", !0);
P($, re, ma, "┘", "\\@lrcorner", !0);
P($, re, ie, "≦", "\\leqq", !0);
P($, re, ie, "⩽", "\\leqslant", !0);
P($, re, ie, "⪕", "\\eqslantless", !0);
P($, re, ie, "≲", "\\lesssim", !0);
P($, re, ie, "⪅", "\\lessapprox", !0);
P($, re, ie, "≊", "\\approxeq", !0);
P($, re, ut, "⋖", "\\lessdot");
P($, re, ie, "⋘", "\\lll", !0);
P($, re, ie, "≶", "\\lessgtr", !0);
P($, re, ie, "⋚", "\\lesseqgtr", !0);
P($, re, ie, "⪋", "\\lesseqqgtr", !0);
P($, re, ie, "≑", "\\doteqdot");
P($, re, ie, "≓", "\\risingdotseq", !0);
P($, re, ie, "≒", "\\fallingdotseq", !0);
P($, re, ie, "∽", "\\backsim", !0);
P($, re, ie, "⋍", "\\backsimeq", !0);
P($, re, ie, "⫅", "\\subseteqq", !0);
P($, re, ie, "⋐", "\\Subset", !0);
P($, re, ie, "⊏", "\\sqsubset", !0);
P($, re, ie, "≼", "\\preccurlyeq", !0);
P($, re, ie, "⋞", "\\curlyeqprec", !0);
P($, re, ie, "≾", "\\precsim", !0);
P($, re, ie, "⪷", "\\precapprox", !0);
P($, re, ie, "⊲", "\\vartriangleleft");
P($, re, ie, "⊴", "\\trianglelefteq");
P($, re, ie, "⊨", "\\vDash", !0);
P($, re, ie, "⊪", "\\Vvdash", !0);
P($, re, ie, "⌣", "\\smallsmile");
P($, re, ie, "⌢", "\\smallfrown");
P($, re, ie, "≏", "\\bumpeq", !0);
P($, re, ie, "≎", "\\Bumpeq", !0);
P($, re, ie, "≧", "\\geqq", !0);
P($, re, ie, "⩾", "\\geqslant", !0);
P($, re, ie, "⪖", "\\eqslantgtr", !0);
P($, re, ie, "≳", "\\gtrsim", !0);
P($, re, ie, "⪆", "\\gtrapprox", !0);
P($, re, ut, "⋗", "\\gtrdot");
P($, re, ie, "⋙", "\\ggg", !0);
P($, re, ie, "≷", "\\gtrless", !0);
P($, re, ie, "⋛", "\\gtreqless", !0);
P($, re, ie, "⪌", "\\gtreqqless", !0);
P($, re, ie, "≖", "\\eqcirc", !0);
P($, re, ie, "≗", "\\circeq", !0);
P($, re, ie, "≜", "\\triangleq", !0);
P($, re, ie, "∼", "\\thicksim");
P($, re, ie, "≈", "\\thickapprox");
P($, re, ie, "⫆", "\\supseteqq", !0);
P($, re, ie, "⋑", "\\Supset", !0);
P($, re, ie, "⊐", "\\sqsupset", !0);
P($, re, ie, "≽", "\\succcurlyeq", !0);
P($, re, ie, "⋟", "\\curlyeqsucc", !0);
P($, re, ie, "≿", "\\succsim", !0);
P($, re, ie, "⪸", "\\succapprox", !0);
P($, re, ie, "⊳", "\\vartriangleright");
P($, re, ie, "⊵", "\\trianglerighteq");
P($, re, ie, "⊩", "\\Vdash", !0);
P($, re, ie, "∣", "\\shortmid");
P($, re, ie, "∥", "\\shortparallel");
P($, re, ie, "≬", "\\between", !0);
P($, re, ie, "⋔", "\\pitchfork", !0);
P($, re, ie, "∝", "\\varpropto");
P($, re, ie, "◀", "\\blacktriangleleft");
P($, re, ie, "∴", "\\therefore", !0);
P($, re, ie, "∍", "\\backepsilon");
P($, re, ie, "▶", "\\blacktriangleright");
P($, re, ie, "∵", "\\because", !0);
P($, re, ie, "⋘", "\\llless");
P($, re, ie, "⋙", "\\gggtr");
P($, re, ut, "⊲", "\\lhd");
P($, re, ut, "⊳", "\\rhd");
P($, re, ie, "≂", "\\eqsim", !0);
P($, U, ie, "⋈", "\\Join");
P($, re, ie, "≑", "\\Doteq", !0);
P($, re, ut, "∔", "\\dotplus", !0);
P($, re, ut, "∖", "\\smallsetminus");
P($, re, ut, "⋒", "\\Cap", !0);
P($, re, ut, "⋓", "\\Cup", !0);
P($, re, ut, "⩞", "\\doublebarwedge", !0);
P($, re, ut, "⊟", "\\boxminus", !0);
P($, re, ut, "⊞", "\\boxplus", !0);
P($, re, ut, "⋇", "\\divideontimes", !0);
P($, re, ut, "⋉", "\\ltimes", !0);
P($, re, ut, "⋊", "\\rtimes", !0);
P($, re, ut, "⋋", "\\leftthreetimes", !0);
P($, re, ut, "⋌", "\\rightthreetimes", !0);
P($, re, ut, "⋏", "\\curlywedge", !0);
P($, re, ut, "⋎", "\\curlyvee", !0);
P($, re, ut, "⊝", "\\circleddash", !0);
P($, re, ut, "⊛", "\\circledast", !0);
P($, re, ut, "⋅", "\\centerdot");
P($, re, ut, "⊺", "\\intercal", !0);
P($, re, ut, "⋒", "\\doublecap");
P($, re, ut, "⋓", "\\doublecup");
P($, re, ut, "⊠", "\\boxtimes", !0);
P($, re, ie, "⇢", "\\dashrightarrow", !0);
P($, re, ie, "⇠", "\\dashleftarrow", !0);
P($, re, ie, "⇇", "\\leftleftarrows", !0);
P($, re, ie, "⇆", "\\leftrightarrows", !0);
P($, re, ie, "⇚", "\\Lleftarrow", !0);
P($, re, ie, "↞", "\\twoheadleftarrow", !0);
P($, re, ie, "↢", "\\leftarrowtail", !0);
P($, re, ie, "↫", "\\looparrowleft", !0);
P($, re, ie, "⇋", "\\leftrightharpoons", !0);
P($, re, ie, "↶", "\\curvearrowleft", !0);
P($, re, ie, "↺", "\\circlearrowleft", !0);
P($, re, ie, "↰", "\\Lsh", !0);
P($, re, ie, "⇈", "\\upuparrows", !0);
P($, re, ie, "↿", "\\upharpoonleft", !0);
P($, re, ie, "⇃", "\\downharpoonleft", !0);
P($, U, ie, "⊶", "\\origof", !0);
P($, U, ie, "⊷", "\\imageof", !0);
P($, re, ie, "⊸", "\\multimap", !0);
P($, re, ie, "↭", "\\leftrightsquigarrow", !0);
P($, re, ie, "⇉", "\\rightrightarrows", !0);
P($, re, ie, "⇄", "\\rightleftarrows", !0);
P($, re, ie, "↠", "\\twoheadrightarrow", !0);
P($, re, ie, "↣", "\\rightarrowtail", !0);
P($, re, ie, "↬", "\\looparrowright", !0);
P($, re, ie, "↷", "\\curvearrowright", !0);
P($, re, ie, "↻", "\\circlearrowright", !0);
P($, re, ie, "↱", "\\Rsh", !0);
P($, re, ie, "⇊", "\\downdownarrows", !0);
P($, re, ie, "↾", "\\upharpoonright", !0);
P($, re, ie, "⇂", "\\downharpoonright", !0);
P($, re, ie, "⇝", "\\rightsquigarrow", !0);
P($, re, ie, "⇝", "\\leadsto");
P($, re, ie, "⇛", "\\Rrightarrow", !0);
P($, re, ie, "↾", "\\restriction");
P($, U, ce, "‘", "`");
P($, U, ce, "$", "\\$");
P(Fe, U, ce, "$", "\\$");
P(Fe, U, ce, "$", "\\textdollar");
P($, U, ce, "%", "\\%");
P(Fe, U, ce, "%", "\\%");
P($, U, ce, "_", "\\_");
P(Fe, U, ce, "_", "\\_");
P(Fe, U, ce, "_", "\\textunderscore");
P($, U, ce, "∠", "\\angle", !0);
P($, U, ce, "∞", "\\infty", !0);
P($, U, ce, "′", "\\prime");
P($, U, ce, "△", "\\triangle");
P($, U, ce, "Γ", "\\Gamma", !0);
P($, U, ce, "Δ", "\\Delta", !0);
P($, U, ce, "Θ", "\\Theta", !0);
P($, U, ce, "Λ", "\\Lambda", !0);
P($, U, ce, "Ξ", "\\Xi", !0);
P($, U, ce, "Π", "\\Pi", !0);
P($, U, ce, "Σ", "\\Sigma", !0);
P($, U, ce, "Υ", "\\Upsilon", !0);
P($, U, ce, "Φ", "\\Phi", !0);
P($, U, ce, "Ψ", "\\Psi", !0);
P($, U, ce, "Ω", "\\Omega", !0);
P($, U, ce, "A", "Α");
P($, U, ce, "B", "Β");
P($, U, ce, "E", "Ε");
P($, U, ce, "Z", "Ζ");
P($, U, ce, "H", "Η");
P($, U, ce, "I", "Ι");
P($, U, ce, "K", "Κ");
P($, U, ce, "M", "Μ");
P($, U, ce, "N", "Ν");
P($, U, ce, "O", "Ο");
P($, U, ce, "P", "Ρ");
P($, U, ce, "T", "Τ");
P($, U, ce, "X", "Χ");
P($, U, ce, "¬", "\\neg", !0);
P($, U, ce, "¬", "\\lnot");
P($, U, ce, "⊤", "\\top");
P($, U, ce, "⊥", "\\bot");
P($, U, ce, "∅", "\\emptyset");
P($, re, ce, "∅", "\\varnothing");
P($, U, St, "α", "\\alpha", !0);
P($, U, St, "β", "\\beta", !0);
P($, U, St, "γ", "\\gamma", !0);
P($, U, St, "δ", "\\delta", !0);
P($, U, St, "ϵ", "\\epsilon", !0);
P($, U, St, "ζ", "\\zeta", !0);
P($, U, St, "η", "\\eta", !0);
P($, U, St, "θ", "\\theta", !0);
P($, U, St, "ι", "\\iota", !0);
P($, U, St, "κ", "\\kappa", !0);
P($, U, St, "λ", "\\lambda", !0);
P($, U, St, "μ", "\\mu", !0);
P($, U, St, "ν", "\\nu", !0);
P($, U, St, "ξ", "\\xi", !0);
P($, U, St, "ο", "\\omicron", !0);
P($, U, St, "π", "\\pi", !0);
P($, U, St, "ρ", "\\rho", !0);
P($, U, St, "σ", "\\sigma", !0);
P($, U, St, "τ", "\\tau", !0);
P($, U, St, "υ", "\\upsilon", !0);
P($, U, St, "ϕ", "\\phi", !0);
P($, U, St, "χ", "\\chi", !0);
P($, U, St, "ψ", "\\psi", !0);
P($, U, St, "ω", "\\omega", !0);
P($, U, St, "ε", "\\varepsilon", !0);
P($, U, St, "ϑ", "\\vartheta", !0);
P($, U, St, "ϖ", "\\varpi", !0);
P($, U, St, "ϱ", "\\varrho", !0);
P($, U, St, "ς", "\\varsigma", !0);
P($, U, St, "φ", "\\varphi", !0);
P($, U, ut, "∗", "*", !0);
P($, U, ut, "+", "+");
P($, U, ut, "−", "-", !0);
P($, U, ut, "⋅", "\\cdot", !0);
P($, U, ut, "∘", "\\circ", !0);
P($, U, ut, "÷", "\\div", !0);
P($, U, ut, "±", "\\pm", !0);
P($, U, ut, "×", "\\times", !0);
P($, U, ut, "∩", "\\cap", !0);
P($, U, ut, "∪", "\\cup", !0);
P($, U, ut, "∖", "\\setminus", !0);
P($, U, ut, "∧", "\\land");
P($, U, ut, "∨", "\\lor");
P($, U, ut, "∧", "\\wedge", !0);
P($, U, ut, "∨", "\\vee", !0);
P($, U, ce, "√", "\\surd");
P($, U, ii, "⟨", "\\langle", !0);
P($, U, ii, "∣", "\\lvert");
P($, U, ii, "∥", "\\lVert");
P($, U, ma, "?", "?");
P($, U, ma, "!", "!");
P($, U, ma, "⟩", "\\rangle", !0);
P($, U, ma, "∣", "\\rvert");
P($, U, ma, "∥", "\\rVert");
P($, U, ie, "=", "=");
P($, U, ie, ":", ":");
P($, U, ie, "≈", "\\approx", !0);
P($, U, ie, "≅", "\\cong", !0);
P($, U, ie, "≥", "\\ge");
P($, U, ie, "≥", "\\geq", !0);
P($, U, ie, "←", "\\gets");
P($, U, ie, ">", "\\gt", !0);
P($, U, ie, "∈", "\\in", !0);
P($, U, ie, "", "\\@not");
P($, U, ie, "⊂", "\\subset", !0);
P($, U, ie, "⊃", "\\supset", !0);
P($, U, ie, "⊆", "\\subseteq", !0);
P($, U, ie, "⊇", "\\supseteq", !0);
P($, re, ie, "⊈", "\\nsubseteq", !0);
P($, re, ie, "⊉", "\\nsupseteq", !0);
P($, U, ie, "⊨", "\\models");
P($, U, ie, "←", "\\leftarrow", !0);
P($, U, ie, "≤", "\\le");
P($, U, ie, "≤", "\\leq", !0);
P($, U, ie, "<", "\\lt", !0);
P($, U, ie, "→", "\\rightarrow", !0);
P($, U, ie, "→", "\\to");
P($, re, ie, "≱", "\\ngeq", !0);
P($, re, ie, "≰", "\\nleq", !0);
P($, U, bo, " ", "\\ ");
P($, U, bo, " ", "\\space");
P($, U, bo, " ", "\\nobreakspace");
P(Fe, U, bo, " ", "\\ ");
P(Fe, U, bo, " ", " ");
P(Fe, U, bo, " ", "\\space");
P(Fe, U, bo, " ", "\\nobreakspace");
P($, U, bo, null, "\\nobreak");
P($, U, bo, null, "\\allowbreak");
P($, U, I1, ",", ",");
P($, U, I1, ";", ";");
P($, re, ut, "⊼", "\\barwedge", !0);
P($, re, ut, "⊻", "\\veebar", !0);
P($, U, ut, "⊙", "\\odot", !0);
P($, U, ut, "⊕", "\\oplus", !0);
P($, U, ut, "⊗", "\\otimes", !0);
P($, U, ce, "∂", "\\partial", !0);
P($, U, ut, "⊘", "\\oslash", !0);
P($, re, ut, "⊚", "\\circledcirc", !0);
P($, re, ut, "⊡", "\\boxdot", !0);
P($, U, ut, "△", "\\bigtriangleup");
P($, U, ut, "▽", "\\bigtriangledown");
P($, U, ut, "†", "\\dagger");
P($, U, ut, "⋄", "\\diamond");
P($, U, ut, "⋆", "\\star");
P($, U, ut, "◃", "\\triangleleft");
P($, U, ut, "▹", "\\triangleright");
P($, U, ii, "{", "\\{");
P(Fe, U, ce, "{", "\\{");
P(Fe, U, ce, "{", "\\textbraceleft");
P($, U, ma, "}", "\\}");
P(Fe, U, ce, "}", "\\}");
P(Fe, U, ce, "}", "\\textbraceright");
P($, U, ii, "{", "\\lbrace");
P($, U, ma, "}", "\\rbrace");
P($, U, ii, "[", "\\lbrack", !0);
P(Fe, U, ce, "[", "\\lbrack", !0);
P($, U, ma, "]", "\\rbrack", !0);
P(Fe, U, ce, "]", "\\rbrack", !0);
P($, U, ii, "(", "\\lparen", !0);
P($, U, ma, ")", "\\rparen", !0);
P(Fe, U, ce, "<", "\\textless", !0);
P(Fe, U, ce, ">", "\\textgreater", !0);
P($, U, ii, "⌊", "\\lfloor", !0);
P($, U, ma, "⌋", "\\rfloor", !0);
P($, U, ii, "⌈", "\\lceil", !0);
P($, U, ma, "⌉", "\\rceil", !0);
P($, U, ce, "\\", "\\backslash");
P($, U, ce, "∣", "|");
P($, U, ce, "∣", "\\vert");
P(Fe, U, ce, "|", "\\textbar", !0);
P($, U, ce, "∥", "\\|");
P($, U, ce, "∥", "\\Vert");
P(Fe, U, ce, "∥", "\\textbardbl");
P(Fe, U, ce, "~", "\\textasciitilde");
P(Fe, U, ce, "\\", "\\textbackslash");
P(Fe, U, ce, "^", "\\textasciicircum");
P($, U, ie, "↑", "\\uparrow", !0);
P($, U, ie, "⇑", "\\Uparrow", !0);
P($, U, ie, "↓", "\\downarrow", !0);
P($, U, ie, "⇓", "\\Downarrow", !0);
P($, U, ie, "↕", "\\updownarrow", !0);
P($, U, ie, "⇕", "\\Updownarrow", !0);
P($, U, hn, "∐", "\\coprod");
P($, U, hn, "⋁", "\\bigvee");
P($, U, hn, "⋀", "\\bigwedge");
P($, U, hn, "⨄", "\\biguplus");
P($, U, hn, "⋂", "\\bigcap");
P($, U, hn, "⋃", "\\bigcup");
P($, U, hn, "∫", "\\int");
P($, U, hn, "∫", "\\intop");
P($, U, hn, "∬", "\\iint");
P($, U, hn, "∭", "\\iiint");
P($, U, hn, "∏", "\\prod");
P($, U, hn, "∑", "\\sum");
P($, U, hn, "⨂", "\\bigotimes");
P($, U, hn, "⨁", "\\bigoplus");
P($, U, hn, "⨀", "\\bigodot");
P($, U, hn, "∮", "\\oint");
P($, U, hn, "∯", "\\oiint");
P($, U, hn, "∰", "\\oiiint");
P($, U, hn, "⨆", "\\bigsqcup");
P($, U, hn, "∫", "\\smallint");
P(Fe, U, Af, "…", "\\textellipsis");
P($, U, Af, "…", "\\mathellipsis");
P(Fe, U, Af, "…", "\\ldots", !0);
P($, U, Af, "…", "\\ldots", !0);
P($, U, Af, "⋯", "\\@cdots", !0);
P($, U, Af, "⋱", "\\ddots", !0);
P($, U, ce, "⋮", "\\varvdots");
P(Fe, U, ce, "⋮", "\\varvdots");
P($, U, Br, "ˊ", "\\acute");
P($, U, Br, "ˋ", "\\grave");
P($, U, Br, "¨", "\\ddot");
P($, U, Br, "~", "\\tilde");
P($, U, Br, "ˉ", "\\bar");
P($, U, Br, "˘", "\\breve");
P($, U, Br, "ˇ", "\\check");
P($, U, Br, "^", "\\hat");
P($, U, Br, "⃗", "\\vec");
P($, U, Br, "˙", "\\dot");
P($, U, Br, "˚", "\\mathring");
P($, U, St, "", "\\@imath");
P($, U, St, "", "\\@jmath");
P($, U, ce, "ı", "ı");
P($, U, ce, "ȷ", "ȷ");
P(Fe, U, ce, "ı", "\\i", !0);
P(Fe, U, ce, "ȷ", "\\j", !0);
P(Fe, U, ce, "ß", "\\ss", !0);
P(Fe, U, ce, "æ", "\\ae", !0);
P(Fe, U, ce, "œ", "\\oe", !0);
P(Fe, U, ce, "ø", "\\o", !0);
P(Fe, U, ce, "Æ", "\\AE", !0);
P(Fe, U, ce, "Œ", "\\OE", !0);
P(Fe, U, ce, "Ø", "\\O", !0);
P(Fe, U, Br, "ˊ", "\\'");
P(Fe, U, Br, "ˋ", "\\`");
P(Fe, U, Br, "ˆ", "\\^");
P(Fe, U, Br, "˜", "\\~");
P(Fe, U, Br, "ˉ", "\\=");
P(Fe, U, Br, "˘", "\\u");
P(Fe, U, Br, "˙", "\\.");
P(Fe, U, Br, "¸", "\\c");
P(Fe, U, Br, "˚", "\\r");
P(Fe, U, Br, "ˇ", "\\v");
P(Fe, U, Br, "¨", '\\"');
P(Fe, U, Br, "˝", "\\H");
P(Fe, U, Br, "◯", "\\textcircled");
var H$ = {
  "--": !0,
  "---": !0,
  "``": !0,
  "''": !0
};
P(Fe, U, ce, "–", "--", !0);
P(Fe, U, ce, "–", "\\textendash");
P(Fe, U, ce, "—", "---", !0);
P(Fe, U, ce, "—", "\\textemdash");
P(Fe, U, ce, "‘", "`", !0);
P(Fe, U, ce, "‘", "\\textquoteleft");
P(Fe, U, ce, "’", "'", !0);
P(Fe, U, ce, "’", "\\textquoteright");
P(Fe, U, ce, "“", "``", !0);
P(Fe, U, ce, "“", "\\textquotedblleft");
P(Fe, U, ce, "”", "''", !0);
P(Fe, U, ce, "”", "\\textquotedblright");
P($, U, ce, "°", "\\degree", !0);
P(Fe, U, ce, "°", "\\degree");
P(Fe, U, ce, "°", "\\textdegree", !0);
P($, U, ce, "£", "\\pounds");
P($, U, ce, "£", "\\mathsterling", !0);
P(Fe, U, ce, "£", "\\pounds");
P(Fe, U, ce, "£", "\\textsterling", !0);
P($, re, ce, "✠", "\\maltese");
P(Fe, re, ce, "✠", "\\maltese");
var e7 = '0123456789/@."';
for (var Ix = 0; Ix < e7.length; Ix++) {
  var t7 = e7.charAt(Ix);
  P($, U, ce, t7, t7);
}
var r7 = '0123456789!@*()-=+";:?/.,';
for (var Px = 0; Px < r7.length; Px++) {
  var n7 = r7.charAt(Px);
  P(Fe, U, ce, n7, n7);
}
var _m = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
for (var Dx = 0; Dx < _m.length; Dx++) {
  var Jp = _m.charAt(Dx);
  P($, U, St, Jp, Jp), P(Fe, U, ce, Jp, Jp);
}
P($, re, ce, "C", "ℂ");
P(Fe, re, ce, "C", "ℂ");
P($, re, ce, "H", "ℍ");
P(Fe, re, ce, "H", "ℍ");
P($, re, ce, "N", "ℕ");
P(Fe, re, ce, "N", "ℕ");
P($, re, ce, "P", "ℙ");
P(Fe, re, ce, "P", "ℙ");
P($, re, ce, "Q", "ℚ");
P(Fe, re, ce, "Q", "ℚ");
P($, re, ce, "R", "ℝ");
P(Fe, re, ce, "R", "ℝ");
P($, re, ce, "Z", "ℤ");
P(Fe, re, ce, "Z", "ℤ");
P($, U, St, "h", "ℎ");
P(Fe, U, St, "h", "ℎ");
var _t = "";
for (var sa = 0; sa < _m.length; sa++) {
  var Yr = _m.charAt(sa);
  _t = String.fromCharCode(55349, 56320 + sa), P($, U, St, Yr, _t), P(Fe, U, ce, Yr, _t), _t = String.fromCharCode(55349, 56372 + sa), P($, U, St, Yr, _t), P(Fe, U, ce, Yr, _t), _t = String.fromCharCode(55349, 56424 + sa), P($, U, St, Yr, _t), P(Fe, U, ce, Yr, _t), _t = String.fromCharCode(55349, 56580 + sa), P($, U, St, Yr, _t), P(Fe, U, ce, Yr, _t), _t = String.fromCharCode(55349, 56684 + sa), P($, U, St, Yr, _t), P(Fe, U, ce, Yr, _t), _t = String.fromCharCode(55349, 56736 + sa), P($, U, St, Yr, _t), P(Fe, U, ce, Yr, _t), _t = String.fromCharCode(55349, 56788 + sa), P($, U, St, Yr, _t), P(Fe, U, ce, Yr, _t), _t = String.fromCharCode(55349, 56840 + sa), P($, U, St, Yr, _t), P(Fe, U, ce, Yr, _t), _t = String.fromCharCode(55349, 56944 + sa), P($, U, St, Yr, _t), P(Fe, U, ce, Yr, _t), sa < 26 && (_t = String.fromCharCode(55349, 56632 + sa), P($, U, St, Yr, _t), P(Fe, U, ce, Yr, _t), _t = String.fromCharCode(55349, 56476 + sa), P($, U, St, Yr, _t), P(Fe, U, ce, Yr, _t));
}
_t = "𝕜";
P($, U, St, "k", _t);
P(Fe, U, ce, "k", _t);
for (var Sl = 0; Sl < 10; Sl++) {
  var To = Sl.toString();
  _t = String.fromCharCode(55349, 57294 + Sl), P($, U, St, To, _t), P(Fe, U, ce, To, _t), _t = String.fromCharCode(55349, 57314 + Sl), P($, U, St, To, _t), P(Fe, U, ce, To, _t), _t = String.fromCharCode(55349, 57324 + Sl), P($, U, St, To, _t), P(Fe, U, ce, To, _t), _t = String.fromCharCode(55349, 57334 + Sl), P($, U, St, To, _t), P(Fe, U, ce, To, _t);
}
var u4 = "ÐÞþ";
for (var $x = 0; $x < u4.length; $x++) {
  var eg = u4.charAt($x);
  P($, U, St, eg, eg), P(Fe, U, ce, eg, eg);
}
var tg = [
  ["mathbf", "textbf", "Main-Bold"],
  // A-Z bold upright
  ["mathbf", "textbf", "Main-Bold"],
  // a-z bold upright
  ["mathnormal", "textit", "Math-Italic"],
  // A-Z italic
  ["mathnormal", "textit", "Math-Italic"],
  // a-z italic
  ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
  // A-Z bold italic
  ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
  // a-z bold italic
  // Map fancy A-Z letters to script, not calligraphic.
  // This aligns with unicode-math and math fonts (except Cambria Math).
  ["mathscr", "textscr", "Script-Regular"],
  // A-Z script
  ["", "", ""],
  // a-z script.  No font
  ["", "", ""],
  // A-Z bold script. No font
  ["", "", ""],
  // a-z bold script. No font
  ["mathfrak", "textfrak", "Fraktur-Regular"],
  // A-Z Fraktur
  ["mathfrak", "textfrak", "Fraktur-Regular"],
  // a-z Fraktur
  ["mathbb", "textbb", "AMS-Regular"],
  // A-Z double-struck
  ["mathbb", "textbb", "AMS-Regular"],
  // k double-struck
  // Note that we are using a bold font, but font metrics for regular Fraktur.
  ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
  // A-Z bold Fraktur
  ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
  // a-z bold Fraktur
  ["mathsf", "textsf", "SansSerif-Regular"],
  // A-Z sans-serif
  ["mathsf", "textsf", "SansSerif-Regular"],
  // a-z sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // A-Z bold sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // a-z bold sans-serif
  ["mathitsf", "textitsf", "SansSerif-Italic"],
  // A-Z italic sans-serif
  ["mathitsf", "textitsf", "SansSerif-Italic"],
  // a-z italic sans-serif
  ["", "", ""],
  // A-Z bold italic sans. No font
  ["", "", ""],
  // a-z bold italic sans. No font
  ["mathtt", "texttt", "Typewriter-Regular"],
  // A-Z monospace
  ["mathtt", "texttt", "Typewriter-Regular"]
  // a-z monospace
], a7 = [
  ["mathbf", "textbf", "Main-Bold"],
  // 0-9 bold
  ["", "", ""],
  // 0-9 double-struck. No KaTeX font.
  ["mathsf", "textsf", "SansSerif-Regular"],
  // 0-9 sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // 0-9 bold sans-serif
  ["mathtt", "texttt", "Typewriter-Regular"]
  // 0-9 monospace
], hve = function(e, r) {
  var n = e.charCodeAt(0), a = e.charCodeAt(1), i = (n - 55296) * 1024 + (a - 56320) + 65536, s = r === "math" ? 0 : 1;
  if (119808 <= i && i < 120484) {
    var o = Math.floor((i - 119808) / 26);
    return [tg[o][2], tg[o][s]];
  } else if (120782 <= i && i <= 120831) {
    var l = Math.floor((i - 120782) / 10);
    return [a7[l][2], a7[l][s]];
  } else {
    if (i === 120485 || i === 120486)
      return [tg[0][2], tg[0][s]];
    if (120486 < i && i < 120782)
      return ["", ""];
    throw new Ve("Unsupported character: " + e);
  }
}, P1 = function(e, r, n) {
  return Mr[n][e] && Mr[n][e].replace && (e = Mr[n][e].replace), {
    value: e,
    metrics: bC(e, r, n)
  };
}, Li = function(e, r, n, a, i) {
  var s = P1(e, r, n), o = s.metrics;
  e = s.value;
  var l;
  if (o) {
    var u = o.italic;
    (n === "text" || a && a.font === "mathit") && (u = 0), l = new Ei(e, o.height, o.depth, u, o.skew, o.width, i);
  } else
    typeof console < "u" && console.warn("No character metrics " + ("for '" + e + "' in style '" + r + "' and mode '" + n + "'")), l = new Ei(e, 0, 0, 0, 0, 0, i);
  if (a) {
    l.maxFontSize = a.sizeMultiplier, a.style.isTight() && l.classes.push("mtight");
    var c = a.getColor();
    c && (l.style.color = c);
  }
  return l;
}, dve = function(e, r, n, a) {
  return a === void 0 && (a = []), n.font === "boldsymbol" && P1(e, "Main-Bold", r).metrics ? Li(e, "Main-Bold", r, n, a.concat(["mathbf"])) : e === "\\" || Mr[r][e].font === "main" ? Li(e, "Main-Regular", r, n, a) : Li(e, "AMS-Regular", r, n, a.concat(["amsrm"]));
}, pve = function(e, r, n, a, i) {
  return i !== "textord" && P1(e, "Math-BoldItalic", r).metrics ? {
    fontName: "Math-BoldItalic",
    fontClass: "boldsymbol"
  } : {
    fontName: "Main-Bold",
    fontClass: "mathbf"
  };
}, gve = function(e, r, n) {
  var a = e.mode, i = e.text, s = ["mord"], o = a === "math" || a === "text" && r.font, l = o ? r.font : r.fontFamily, u = "", c = "";
  if (i.charCodeAt(0) === 55349 && ([u, c] = hve(i, a)), u.length > 0)
    return Li(i, u, a, r, s.concat(c));
  if (l) {
    var f, h;
    if (l === "boldsymbol") {
      var d = pve(i, a, r, s, n);
      f = d.fontName, h = [d.fontClass];
    } else o ? (f = W$[l].fontName, h = [l]) : (f = rg(l, r.fontWeight, r.fontShape), h = [l, r.fontWeight, r.fontShape]);
    if (P1(i, f, a).metrics)
      return Li(i, f, a, r, s.concat(h));
    if (H$.hasOwnProperty(i) && f.slice(0, 10) === "Typewriter") {
      for (var p = [], g = 0; g < i.length; g++)
        p.push(Li(i[g], f, a, r, s.concat(h)));
      return q$(p);
    }
  }
  if (n === "mathord")
    return Li(i, "Math-Italic", a, r, s.concat(["mathnormal"]));
  if (n === "textord") {
    var v = Mr[a][i] && Mr[a][i].font;
    if (v === "ams") {
      var m = rg("amsrm", r.fontWeight, r.fontShape);
      return Li(i, m, a, r, s.concat("amsrm", r.fontWeight, r.fontShape));
    } else if (v === "main" || !v) {
      var b = rg("textrm", r.fontWeight, r.fontShape);
      return Li(i, b, a, r, s.concat(r.fontWeight, r.fontShape));
    } else {
      var y = rg(v, r.fontWeight, r.fontShape);
      return Li(i, y, a, r, s.concat(y, r.fontWeight, r.fontShape));
    }
  } else
    throw new Error("unexpected type: " + n + " in makeOrd");
}, vve = (t, e) => {
  if (Vo(t.classes) !== Vo(e.classes) || t.skew !== e.skew || t.maxFontSize !== e.maxFontSize)
    return !1;
  if (t.classes.length === 1) {
    var r = t.classes[0];
    if (r === "mbin" || r === "mord")
      return !1;
  }
  for (var n in t.style)
    if (t.style.hasOwnProperty(n) && t.style[n] !== e.style[n])
      return !1;
  for (var a in e.style)
    if (e.style.hasOwnProperty(a) && t.style[a] !== e.style[a])
      return !1;
  return !0;
}, mve = (t) => {
  for (var e = 0; e < t.length - 1; e++) {
    var r = t[e], n = t[e + 1];
    r instanceof Ei && n instanceof Ei && vve(r, n) && (r.text += n.text, r.height = Math.max(r.height, n.height), r.depth = Math.max(r.depth, n.depth), r.italic = n.italic, t.splice(e + 1, 1), e--);
  }
  return t;
}, wC = function(e) {
  for (var r = 0, n = 0, a = 0, i = 0; i < e.children.length; i++) {
    var s = e.children[i];
    s.height > r && (r = s.height), s.depth > n && (n = s.depth), s.maxFontSize > a && (a = s.maxFontSize);
  }
  e.height = r, e.depth = n, e.maxFontSize = a;
}, wa = function(e, r, n, a) {
  var i = new tp(e, r, n, a);
  return wC(i), i;
}, V$ = (t, e, r, n) => new tp(t, e, r, n), yve = function(e, r, n) {
  var a = wa([e], [], r);
  return a.height = Math.max(n || r.fontMetrics().defaultRuleThickness, r.minRuleThickness), a.style.borderBottomWidth = Qe(a.height), a.maxFontSize = 1, a;
}, bve = function(e, r, n, a) {
  var i = new xC(e, r, n, a);
  return wC(i), i;
}, q$ = function(e) {
  var r = new ep(e);
  return wC(r), r;
}, xve = function(e, r) {
  return e instanceof ep ? wa([], [e], r) : e;
}, wve = function(e) {
  if (e.positionType === "individualShift") {
    for (var r = e.children, n = [r[0]], a = -r[0].shift - r[0].elem.depth, i = a, s = 1; s < r.length; s++) {
      var o = -r[s].shift - i - r[s].elem.depth, l = o - (r[s - 1].elem.height + r[s - 1].elem.depth);
      i = i + o, n.push({
        type: "kern",
        size: l
      }), n.push(r[s]);
    }
    return {
      children: n,
      depth: a
    };
  }
  var u;
  if (e.positionType === "top") {
    for (var c = e.positionData, f = 0; f < e.children.length; f++) {
      var h = e.children[f];
      c -= h.type === "kern" ? h.size : h.elem.height + h.elem.depth;
    }
    u = c;
  } else if (e.positionType === "bottom")
    u = -e.positionData;
  else {
    var d = e.children[0];
    if (d.type !== "elem")
      throw new Error('First child must have type "elem".');
    if (e.positionType === "shift")
      u = -d.elem.depth - e.positionData;
    else if (e.positionType === "firstBaseline")
      u = -d.elem.depth;
    else
      throw new Error("Invalid positionType " + e.positionType + ".");
  }
  return {
    children: e.children,
    depth: u
  };
}, Eve = function(e, r) {
  for (var {
    children: n,
    depth: a
  } = wve(e), i = 0, s = 0; s < n.length; s++) {
    var o = n[s];
    if (o.type === "elem") {
      var l = o.elem;
      i = Math.max(i, l.maxFontSize, l.height);
    }
  }
  i += 2;
  var u = wa(["pstrut"], []);
  u.style.height = Qe(i);
  for (var c = [], f = a, h = a, d = a, p = 0; p < n.length; p++) {
    var g = n[p];
    if (g.type === "kern")
      d += g.size;
    else {
      var v = g.elem, m = g.wrapperClasses || [], b = g.wrapperStyle || {}, y = wa(m, [u, v], void 0, b);
      y.style.top = Qe(-i - d - v.depth), g.marginLeft && (y.style.marginLeft = g.marginLeft), g.marginRight && (y.style.marginRight = g.marginRight), c.push(y), d += v.height + v.depth;
    }
    f = Math.min(f, d), h = Math.max(h, d);
  }
  var x = wa(["vlist"], c);
  x.style.height = Qe(h);
  var E;
  if (f < 0) {
    var S = wa([], []), w = wa(["vlist"], [S]);
    w.style.height = Qe(-f);
    var C = wa(["vlist-s"], [new Ei("​")]);
    E = [wa(["vlist-r"], [x, C]), wa(["vlist-r"], [w])];
  } else
    E = [wa(["vlist-r"], [x])];
  var k = wa(["vlist-t"], E);
  return E.length === 2 && k.classes.push("vlist-t2"), k.height = h, k.depth = -f, k;
}, Tve = (t, e) => {
  var r = wa(["mspace"], [], e), n = Ur(t, e);
  return r.style.marginRight = Qe(n), r;
}, rg = function(e, r, n) {
  var a = "";
  switch (e) {
    case "amsrm":
      a = "AMS";
      break;
    case "textrm":
      a = "Main";
      break;
    case "textsf":
      a = "SansSerif";
      break;
    case "texttt":
      a = "Typewriter";
      break;
    default:
      a = e;
  }
  var i;
  return r === "textbf" && n === "textit" ? i = "BoldItalic" : r === "textbf" ? i = "Bold" : r === "textit" ? i = "Italic" : i = "Regular", a + "-" + i;
}, W$ = {
  // styles
  mathbf: {
    variant: "bold",
    fontName: "Main-Bold"
  },
  mathrm: {
    variant: "normal",
    fontName: "Main-Regular"
  },
  textit: {
    variant: "italic",
    fontName: "Main-Italic"
  },
  mathit: {
    variant: "italic",
    fontName: "Main-Italic"
  },
  mathnormal: {
    variant: "italic",
    fontName: "Math-Italic"
  },
  mathsfit: {
    variant: "sans-serif-italic",
    fontName: "SansSerif-Italic"
  },
  // "boldsymbol" is missing because they require the use of multiple fonts:
  // Math-BoldItalic and Main-Bold.  This is handled by a special case in
  // makeOrd which ends up calling boldsymbol.
  // families
  mathbb: {
    variant: "double-struck",
    fontName: "AMS-Regular"
  },
  mathcal: {
    variant: "script",
    fontName: "Caligraphic-Regular"
  },
  mathfrak: {
    variant: "fraktur",
    fontName: "Fraktur-Regular"
  },
  mathscr: {
    variant: "script",
    fontName: "Script-Regular"
  },
  mathsf: {
    variant: "sans-serif",
    fontName: "SansSerif-Regular"
  },
  mathtt: {
    variant: "monospace",
    fontName: "Typewriter-Regular"
  }
}, j$ = {
  //   path, width, height
  vec: ["vec", 0.471, 0.714],
  // values from the font glyph
  oiintSize1: ["oiintSize1", 0.957, 0.499],
  // oval to overlay the integrand
  oiintSize2: ["oiintSize2", 1.472, 0.659],
  oiiintSize1: ["oiiintSize1", 1.304, 0.499],
  oiiintSize2: ["oiiintSize2", 1.98, 0.659]
}, Sve = function(e, r) {
  var [n, a, i] = j$[e], s = new qo(n), o = new ao([s], {
    width: Qe(a),
    height: Qe(i),
    // Override CSS rule `.katex svg { width: 100% }`
    style: "width:" + Qe(a),
    viewBox: "0 0 " + 1e3 * a + " " + 1e3 * i,
    preserveAspectRatio: "xMinYMin"
  }), l = V$(["overlay"], [o], r);
  return l.height = i, l.style.height = Qe(i), l.style.width = Qe(a), l;
}, ye = {
  fontMap: W$,
  makeSymbol: Li,
  mathsym: dve,
  makeSpan: wa,
  makeSvgSpan: V$,
  makeLineSpan: yve,
  makeAnchor: bve,
  makeFragment: q$,
  wrapFragment: xve,
  makeVList: Eve,
  makeOrd: gve,
  makeGlue: Tve,
  staticSvg: Sve,
  svgData: j$,
  tryCombineChars: mve
}, Gr = {
  number: 3,
  unit: "mu"
}, Cl = {
  number: 4,
  unit: "mu"
}, Ls = {
  number: 5,
  unit: "mu"
}, Cve = {
  mord: {
    mop: Gr,
    mbin: Cl,
    mrel: Ls,
    minner: Gr
  },
  mop: {
    mord: Gr,
    mop: Gr,
    mrel: Ls,
    minner: Gr
  },
  mbin: {
    mord: Cl,
    mop: Cl,
    mopen: Cl,
    minner: Cl
  },
  mrel: {
    mord: Ls,
    mop: Ls,
    mopen: Ls,
    minner: Ls
  },
  mopen: {},
  mclose: {
    mop: Gr,
    mbin: Cl,
    mrel: Ls,
    minner: Gr
  },
  mpunct: {
    mord: Gr,
    mop: Gr,
    mrel: Ls,
    mopen: Gr,
    mclose: Gr,
    mpunct: Gr,
    minner: Gr
  },
  minner: {
    mord: Gr,
    mop: Gr,
    mbin: Cl,
    mrel: Ls,
    mopen: Gr,
    mpunct: Gr,
    minner: Gr
  }
}, Ave = {
  mord: {
    mop: Gr
  },
  mop: {
    mord: Gr,
    mop: Gr
  },
  mbin: {},
  mrel: {},
  mopen: {},
  mclose: {
    mop: Gr
  },
  mpunct: {},
  minner: {
    mop: Gr
  }
}, Y$ = {}, Lm = {}, Nm = {};
function it(t) {
  for (var {
    type: e,
    names: r,
    props: n,
    handler: a,
    htmlBuilder: i,
    mathmlBuilder: s
  } = t, o = {
    type: e,
    numArgs: n.numArgs,
    argTypes: n.argTypes,
    allowedInArgument: !!n.allowedInArgument,
    allowedInText: !!n.allowedInText,
    allowedInMath: n.allowedInMath === void 0 ? !0 : n.allowedInMath,
    numOptionalArgs: n.numOptionalArgs || 0,
    infix: !!n.infix,
    primitive: !!n.primitive,
    handler: a
  }, l = 0; l < r.length; ++l)
    Y$[r[l]] = o;
  e && (i && (Lm[e] = i), s && (Nm[e] = s));
}
function ku(t) {
  var {
    type: e,
    htmlBuilder: r,
    mathmlBuilder: n
  } = t;
  it({
    type: e,
    names: [],
    props: {
      numArgs: 0
    },
    handler() {
      throw new Error("Should never be called.");
    },
    htmlBuilder: r,
    mathmlBuilder: n
  });
}
var Om = function(e) {
  return e.type === "ordgroup" && e.body.length === 1 ? e.body[0] : e;
}, nn = function(e) {
  return e.type === "ordgroup" ? e.body : [e];
}, io = ye.makeSpan, kve = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"], Rve = ["rightmost", "mrel", "mclose", "mpunct"], Mve = {
  display: Ct.DISPLAY,
  text: Ct.TEXT,
  script: Ct.SCRIPT,
  scriptscript: Ct.SCRIPTSCRIPT
}, _ve = {
  mord: "mord",
  mop: "mop",
  mbin: "mbin",
  mrel: "mrel",
  mopen: "mopen",
  mclose: "mclose",
  mpunct: "mpunct",
  minner: "minner"
}, bn = function(e, r, n, a) {
  a === void 0 && (a = [null, null]);
  for (var i = [], s = 0; s < e.length; s++) {
    var o = er(e[s], r);
    if (o instanceof ep) {
      var l = o.children;
      i.push(...l);
    } else
      i.push(o);
  }
  if (ye.tryCombineChars(i), !n)
    return i;
  var u = r;
  if (e.length === 1) {
    var c = e[0];
    c.type === "sizing" ? u = r.havingSize(c.size) : c.type === "styling" && (u = r.havingStyle(Mve[c.style]));
  }
  var f = io([a[0] || "leftmost"], [], r), h = io([a[1] || "rightmost"], [], r), d = n === "root";
  return i7(i, (p, g) => {
    var v = g.classes[0], m = p.classes[0];
    v === "mbin" && Rve.includes(m) ? g.classes[0] = "mord" : m === "mbin" && kve.includes(v) && (p.classes[0] = "mord");
  }, {
    node: f
  }, h, d), i7(i, (p, g) => {
    var v = c4(g), m = c4(p), b = v && m ? p.hasClass("mtight") ? Ave[v][m] : Cve[v][m] : null;
    if (b)
      return ye.makeGlue(b, u);
  }, {
    node: f
  }, h, d), i;
}, i7 = function t(e, r, n, a, i) {
  a && e.push(a);
  for (var s = 0; s < e.length; s++) {
    var o = e[s], l = X$(o);
    if (l) {
      t(l.children, r, n, null, i);
      continue;
    }
    var u = !o.hasClass("mspace");
    if (u) {
      var c = r(o, n.node);
      c && (n.insertAfter ? n.insertAfter(c) : (e.unshift(c), s++));
    }
    u ? n.node = o : i && o.hasClass("newline") && (n.node = io(["leftmost"])), n.insertAfter = /* @__PURE__ */ ((f) => (h) => {
      e.splice(f + 1, 0, h), s++;
    })(s);
  }
  a && e.pop();
}, X$ = function(e) {
  return e instanceof ep || e instanceof xC || e instanceof tp && e.hasClass("enclosing") ? e : null;
}, Lve = function t(e, r) {
  var n = X$(e);
  if (n) {
    var a = n.children;
    if (a.length) {
      if (r === "right")
        return t(a[a.length - 1], "right");
      if (r === "left")
        return t(a[0], "left");
    }
  }
  return e;
}, c4 = function(e, r) {
  return e ? (r && (e = Lve(e, r)), _ve[e.classes[0]] || null) : null;
}, n0 = function(e, r) {
  var n = ["nulldelimiter"].concat(e.baseSizingClasses());
  return io(r.concat(n));
}, er = function(e, r, n) {
  if (!e)
    return io();
  if (Lm[e.type]) {
    var a = Lm[e.type](e, r);
    if (n && r.size !== n.size) {
      a = io(r.sizingClasses(n), [a], r);
      var i = r.sizeMultiplier / n.sizeMultiplier;
      a.height *= i, a.depth *= i;
    }
    return a;
  } else
    throw new Ve("Got group of unknown type: '" + e.type + "'");
};
function ng(t, e) {
  var r = io(["base"], t, e), n = io(["strut"]);
  return n.style.height = Qe(r.height + r.depth), r.depth && (n.style.verticalAlign = Qe(-r.depth)), r.children.unshift(n), r;
}
function f4(t, e) {
  var r = null;
  t.length === 1 && t[0].type === "tag" && (r = t[0].tag, t = t[0].body);
  var n = bn(t, e, "root"), a;
  n.length === 2 && n[1].hasClass("tag") && (a = n.pop());
  for (var i = [], s = [], o = 0; o < n.length; o++)
    if (s.push(n[o]), n[o].hasClass("mbin") || n[o].hasClass("mrel") || n[o].hasClass("allowbreak")) {
      for (var l = !1; o < n.length - 1 && n[o + 1].hasClass("mspace") && !n[o + 1].hasClass("newline"); )
        o++, s.push(n[o]), n[o].hasClass("nobreak") && (l = !0);
      l || (i.push(ng(s, e)), s = []);
    } else n[o].hasClass("newline") && (s.pop(), s.length > 0 && (i.push(ng(s, e)), s = []), i.push(n[o]));
  s.length > 0 && i.push(ng(s, e));
  var u;
  r ? (u = ng(bn(r, e, !0)), u.classes = ["tag"], i.push(u)) : a && i.push(a);
  var c = io(["katex-html"], i);
  if (c.setAttribute("aria-hidden", "true"), u) {
    var f = u.children[0];
    f.style.height = Qe(c.height + c.depth), c.depth && (f.style.verticalAlign = Qe(-c.depth));
  }
  return c;
}
function K$(t) {
  return new ep(t);
}
class Za {
  constructor(e, r, n) {
    this.type = void 0, this.attributes = void 0, this.children = void 0, this.classes = void 0, this.type = e, this.attributes = {}, this.children = r || [], this.classes = n || [];
  }
  /**
   * Sets an attribute on a MathML node. MathML depends on attributes to convey a
   * semantic content, so this is used heavily.
   */
  setAttribute(e, r) {
    this.attributes[e] = r;
  }
  /**
   * Gets an attribute on a MathML node.
   */
  getAttribute(e) {
    return this.attributes[e];
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    var e = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
    for (var r in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, r) && e.setAttribute(r, this.attributes[r]);
    this.classes.length > 0 && (e.className = Vo(this.classes));
    for (var n = 0; n < this.children.length; n++)
      if (this.children[n] instanceof hs && this.children[n + 1] instanceof hs) {
        for (var a = this.children[n].toText() + this.children[++n].toText(); this.children[n + 1] instanceof hs; )
          a += this.children[++n].toText();
        e.appendChild(new hs(a).toNode());
      } else
        e.appendChild(this.children[n].toNode());
    return e;
  }
  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    var e = "<" + this.type;
    for (var r in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, r) && (e += " " + r + '="', e += rr.escape(this.attributes[r]), e += '"');
    this.classes.length > 0 && (e += ' class ="' + rr.escape(Vo(this.classes)) + '"'), e += ">";
    for (var n = 0; n < this.children.length; n++)
      e += this.children[n].toMarkup();
    return e += "</" + this.type + ">", e;
  }
  /**
   * Converts the math node into a string, similar to innerText, but escaped.
   */
  toText() {
    return this.children.map((e) => e.toText()).join("");
  }
}
class hs {
  constructor(e) {
    this.text = void 0, this.text = e;
  }
  /**
   * Converts the text node into a DOM text node.
   */
  toNode() {
    return document.createTextNode(this.text);
  }
  /**
   * Converts the text node into escaped HTML markup
   * (representing the text itself).
   */
  toMarkup() {
    return rr.escape(this.toText());
  }
  /**
   * Converts the text node into a string
   * (representing the text itself).
   */
  toText() {
    return this.text;
  }
}
class Nve {
  /**
   * Create a Space node with width given in CSS ems.
   */
  constructor(e) {
    this.width = void 0, this.character = void 0, this.width = e, e >= 0.05555 && e <= 0.05556 ? this.character = " " : e >= 0.1666 && e <= 0.1667 ? this.character = " " : e >= 0.2222 && e <= 0.2223 ? this.character = " " : e >= 0.2777 && e <= 0.2778 ? this.character = "  " : e >= -0.05556 && e <= -0.05555 ? this.character = " ⁣" : e >= -0.1667 && e <= -0.1666 ? this.character = " ⁣" : e >= -0.2223 && e <= -0.2222 ? this.character = " ⁣" : e >= -0.2778 && e <= -0.2777 ? this.character = " ⁣" : this.character = null;
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    if (this.character)
      return document.createTextNode(this.character);
    var e = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
    return e.setAttribute("width", Qe(this.width)), e;
  }
  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    return this.character ? "<mtext>" + this.character + "</mtext>" : '<mspace width="' + Qe(this.width) + '"/>';
  }
  /**
   * Converts the math node into a string, similar to innerText.
   */
  toText() {
    return this.character ? this.character : " ";
  }
}
var Ue = {
  MathNode: Za,
  TextNode: hs,
  SpaceNode: Nve,
  newDocumentFragment: K$
}, Ti = function(e, r, n) {
  return Mr[r][e] && Mr[r][e].replace && e.charCodeAt(0) !== 55349 && !(H$.hasOwnProperty(e) && n && (n.fontFamily && n.fontFamily.slice(4, 6) === "tt" || n.font && n.font.slice(4, 6) === "tt")) && (e = Mr[r][e].replace), new Ue.TextNode(e);
}, EC = function(e) {
  return e.length === 1 ? e[0] : new Ue.MathNode("mrow", e);
}, TC = function(e, r) {
  if (r.fontFamily === "texttt")
    return "monospace";
  if (r.fontFamily === "textsf")
    return r.fontShape === "textit" && r.fontWeight === "textbf" ? "sans-serif-bold-italic" : r.fontShape === "textit" ? "sans-serif-italic" : r.fontWeight === "textbf" ? "bold-sans-serif" : "sans-serif";
  if (r.fontShape === "textit" && r.fontWeight === "textbf")
    return "bold-italic";
  if (r.fontShape === "textit")
    return "italic";
  if (r.fontWeight === "textbf")
    return "bold";
  var n = r.font;
  if (!n || n === "mathnormal")
    return null;
  var a = e.mode;
  if (n === "mathit")
    return "italic";
  if (n === "boldsymbol")
    return e.type === "textord" ? "bold" : "bold-italic";
  if (n === "mathbf")
    return "bold";
  if (n === "mathbb")
    return "double-struck";
  if (n === "mathsfit")
    return "sans-serif-italic";
  if (n === "mathfrak")
    return "fraktur";
  if (n === "mathscr" || n === "mathcal")
    return "script";
  if (n === "mathsf")
    return "sans-serif";
  if (n === "mathtt")
    return "monospace";
  var i = e.text;
  if (["\\imath", "\\jmath"].includes(i))
    return null;
  Mr[a][i] && Mr[a][i].replace && (i = Mr[a][i].replace);
  var s = ye.fontMap[n].fontName;
  return bC(i, s, a) ? ye.fontMap[n].variant : null;
};
function Fx(t) {
  if (!t)
    return !1;
  if (t.type === "mi" && t.children.length === 1) {
    var e = t.children[0];
    return e instanceof hs && e.text === ".";
  } else if (t.type === "mo" && t.children.length === 1 && t.getAttribute("separator") === "true" && t.getAttribute("lspace") === "0em" && t.getAttribute("rspace") === "0em") {
    var r = t.children[0];
    return r instanceof hs && r.text === ",";
  } else
    return !1;
}
var Oa = function(e, r, n) {
  if (e.length === 1) {
    var a = Cr(e[0], r);
    return n && a instanceof Za && a.type === "mo" && (a.setAttribute("lspace", "0em"), a.setAttribute("rspace", "0em")), [a];
  }
  for (var i = [], s, o = 0; o < e.length; o++) {
    var l = Cr(e[o], r);
    if (l instanceof Za && s instanceof Za) {
      if (l.type === "mtext" && s.type === "mtext" && l.getAttribute("mathvariant") === s.getAttribute("mathvariant")) {
        s.children.push(...l.children);
        continue;
      } else if (l.type === "mn" && s.type === "mn") {
        s.children.push(...l.children);
        continue;
      } else if (Fx(l) && s.type === "mn") {
        s.children.push(...l.children);
        continue;
      } else if (l.type === "mn" && Fx(s))
        l.children = [...s.children, ...l.children], i.pop();
      else if ((l.type === "msup" || l.type === "msub") && l.children.length >= 1 && (s.type === "mn" || Fx(s))) {
        var u = l.children[0];
        u instanceof Za && u.type === "mn" && (u.children = [...s.children, ...u.children], i.pop());
      } else if (s.type === "mi" && s.children.length === 1) {
        var c = s.children[0];
        if (c instanceof hs && c.text === "̸" && (l.type === "mo" || l.type === "mi" || l.type === "mn")) {
          var f = l.children[0];
          f instanceof hs && f.text.length > 0 && (f.text = f.text.slice(0, 1) + "̸" + f.text.slice(1), i.pop());
        }
      }
    }
    i.push(l), s = l;
  }
  return i;
}, Wo = function(e, r, n) {
  return EC(Oa(e, r, n));
}, Cr = function(e, r) {
  if (!e)
    return new Ue.MathNode("mrow");
  if (Nm[e.type]) {
    var n = Nm[e.type](e, r);
    return n;
  } else
    throw new Ve("Got group of unknown type: '" + e.type + "'");
};
function s7(t, e, r, n, a) {
  var i = Oa(t, r), s;
  i.length === 1 && i[0] instanceof Za && ["mrow", "mtable"].includes(i[0].type) ? s = i[0] : s = new Ue.MathNode("mrow", i);
  var o = new Ue.MathNode("annotation", [new Ue.TextNode(e)]);
  o.setAttribute("encoding", "application/x-tex");
  var l = new Ue.MathNode("semantics", [s, o]), u = new Ue.MathNode("math", [l]);
  u.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML"), n && u.setAttribute("display", "block");
  var c = a ? "katex" : "katex-mathml";
  return ye.makeSpan([c], [u]);
}
var Z$ = function(e) {
  return new Fs({
    style: e.displayMode ? Ct.DISPLAY : Ct.TEXT,
    maxSize: e.maxSize,
    minRuleThickness: e.minRuleThickness
  });
}, Q$ = function(e, r) {
  if (r.displayMode) {
    var n = ["katex-display"];
    r.leqno && n.push("leqno"), r.fleqn && n.push("fleqn"), e = ye.makeSpan(n, [e]);
  }
  return e;
}, Ove = function(e, r, n) {
  var a = Z$(n), i;
  if (n.output === "mathml")
    return s7(e, r, a, n.displayMode, !0);
  if (n.output === "html") {
    var s = f4(e, a);
    i = ye.makeSpan(["katex"], [s]);
  } else {
    var o = s7(e, r, a, n.displayMode, !1), l = f4(e, a);
    i = ye.makeSpan(["katex"], [o, l]);
  }
  return Q$(i, n);
}, Ive = function(e, r, n) {
  var a = Z$(n), i = f4(e, a), s = ye.makeSpan(["katex"], [i]);
  return Q$(s, n);
}, Pve = {
  widehat: "^",
  widecheck: "ˇ",
  widetilde: "~",
  utilde: "~",
  overleftarrow: "←",
  underleftarrow: "←",
  xleftarrow: "←",
  overrightarrow: "→",
  underrightarrow: "→",
  xrightarrow: "→",
  underbrace: "⏟",
  overbrace: "⏞",
  overgroup: "⏠",
  undergroup: "⏡",
  overleftrightarrow: "↔",
  underleftrightarrow: "↔",
  xleftrightarrow: "↔",
  Overrightarrow: "⇒",
  xRightarrow: "⇒",
  overleftharpoon: "↼",
  xleftharpoonup: "↼",
  overrightharpoon: "⇀",
  xrightharpoonup: "⇀",
  xLeftarrow: "⇐",
  xLeftrightarrow: "⇔",
  xhookleftarrow: "↩",
  xhookrightarrow: "↪",
  xmapsto: "↦",
  xrightharpoondown: "⇁",
  xleftharpoondown: "↽",
  xrightleftharpoons: "⇌",
  xleftrightharpoons: "⇋",
  xtwoheadleftarrow: "↞",
  xtwoheadrightarrow: "↠",
  xlongequal: "=",
  xtofrom: "⇄",
  xrightleftarrows: "⇄",
  xrightequilibrium: "⇌",
  // Not a perfect match.
  xleftequilibrium: "⇋",
  // None better available.
  "\\cdrightarrow": "→",
  "\\cdleftarrow": "←",
  "\\cdlongequal": "="
}, Dve = function(e) {
  var r = new Ue.MathNode("mo", [new Ue.TextNode(Pve[e.replace(/^\\/, "")])]);
  return r.setAttribute("stretchy", "true"), r;
}, $ve = {
  //   path(s), minWidth, height, align
  overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
  "\\cdrightarrow": [["rightarrow"], 3, 522, "xMaxYMin"],
  // CD minwwidth2.5pc
  xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
  "\\cdleftarrow": [["leftarrow"], 3, 522, "xMinYMin"],
  Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
  xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
  xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
  overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
  overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
  xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
  "\\cdlongequal": [["longequal"], 3, 334, "xMinYMin"],
  xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
  xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
  overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
  underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
  underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
  xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
  xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
  xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
  xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
  xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
  overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
  undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
  xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
  xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
  // The next three arrows are from the mhchem package.
  // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the
  // document as \xrightarrow or \xrightleftharpoons. Those have
  // min-length = 1.75em, so we set min-length on these next three to match.
  xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
  xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
  xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
}, Fve = function(e) {
  return e.type === "ordgroup" ? e.body.length : 1;
}, Bve = function(e, r) {
  function n() {
    var o = 4e5, l = e.label.slice(1);
    if (["widehat", "widecheck", "widetilde", "utilde"].includes(l)) {
      var u = e, c = Fve(u.base), f, h, d;
      if (c > 5)
        l === "widehat" || l === "widecheck" ? (f = 420, o = 2364, d = 0.42, h = l + "4") : (f = 312, o = 2340, d = 0.34, h = "tilde4");
      else {
        var p = [1, 1, 2, 2, 3, 3][c];
        l === "widehat" || l === "widecheck" ? (o = [0, 1062, 2364, 2364, 2364][p], f = [0, 239, 300, 360, 420][p], d = [0, 0.24, 0.3, 0.3, 0.36, 0.42][p], h = l + p) : (o = [0, 600, 1033, 2339, 2340][p], f = [0, 260, 286, 306, 312][p], d = [0, 0.26, 0.286, 0.3, 0.306, 0.34][p], h = "tilde" + p);
      }
      var g = new qo(h), v = new ao([g], {
        width: "100%",
        height: Qe(d),
        viewBox: "0 0 " + o + " " + f,
        preserveAspectRatio: "none"
      });
      return {
        span: ye.makeSvgSpan([], [v], r),
        minWidth: 0,
        height: d
      };
    } else {
      var m = [], b = $ve[l], [y, x, E] = b, S = E / 1e3, w = y.length, C, k;
      if (w === 1) {
        var N = b[3];
        C = ["hide-tail"], k = [N];
      } else if (w === 2)
        C = ["halfarrow-left", "halfarrow-right"], k = ["xMinYMin", "xMaxYMin"];
      else if (w === 3)
        C = ["brace-left", "brace-center", "brace-right"], k = ["xMinYMin", "xMidYMin", "xMaxYMin"];
      else
        throw new Error(`Correct katexImagesData or update code here to support
                    ` + w + " children.");
      for (var R = 0; R < w; R++) {
        var _ = new qo(y[R]), O = new ao([_], {
          width: "400em",
          height: Qe(S),
          viewBox: "0 0 " + o + " " + E,
          preserveAspectRatio: k[R] + " slice"
        }), T = ye.makeSvgSpan([C[R]], [O], r);
        if (w === 1)
          return {
            span: T,
            minWidth: x,
            height: S
          };
        T.style.height = Qe(S), m.push(T);
      }
      return {
        span: ye.makeSpan(["stretchy"], m, r),
        minWidth: x,
        height: S
      };
    }
  }
  var {
    span: a,
    minWidth: i,
    height: s
  } = n();
  return a.height = s, a.style.height = Qe(s), i > 0 && (a.style.minWidth = Qe(i)), a;
}, zve = function(e, r, n, a, i) {
  var s, o = e.height + e.depth + n + a;
  if (/fbox|color|angl/.test(r)) {
    if (s = ye.makeSpan(["stretchy", r], [], i), r === "fbox") {
      var l = i.color && i.getColor();
      l && (s.style.borderColor = l);
    }
  } else {
    var u = [];
    /^[bx]cancel$/.test(r) && u.push(new l4({
      x1: "0",
      y1: "0",
      x2: "100%",
      y2: "100%",
      "stroke-width": "0.046em"
    })), /^x?cancel$/.test(r) && u.push(new l4({
      x1: "0",
      y1: "100%",
      x2: "100%",
      y2: "0",
      "stroke-width": "0.046em"
    }));
    var c = new ao(u, {
      width: "100%",
      height: Qe(o)
    });
    s = ye.makeSvgSpan([], [c], i);
  }
  return s.height = o, s.style.height = Qe(o), s;
}, so = {
  encloseSpan: zve,
  mathMLnode: Dve,
  svgSpan: Bve
};
function Bt(t, e) {
  if (!t || t.type !== e)
    throw new Error("Expected node of type " + e + ", but got " + (t ? "node of type " + t.type : String(t)));
  return t;
}
function SC(t) {
  var e = D1(t);
  if (!e)
    throw new Error("Expected node of symbol group type, but got " + (t ? "node of type " + t.type : String(t)));
  return e;
}
function D1(t) {
  return t && (t.type === "atom" || fve.hasOwnProperty(t.type)) ? t : null;
}
var CC = (t, e) => {
  var r, n, a;
  t && t.type === "supsub" ? (n = Bt(t.base, "accent"), r = n.base, t.base = r, a = uve(er(t, e)), t.base = n) : (n = Bt(t, "accent"), r = n.base);
  var i = er(r, e.havingCrampedStyle()), s = n.isShifty && rr.isCharacterBox(r), o = 0;
  if (s) {
    var l = rr.getBaseElem(r), u = er(l, e.havingCrampedStyle());
    o = J6(u).skew;
  }
  var c = n.label === "\\c", f = c ? i.height + i.depth : Math.min(i.height, e.fontMetrics().xHeight), h;
  if (n.isStretchy)
    h = so.svgSpan(n, e), h = ye.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: i
      }, {
        type: "elem",
        elem: h,
        wrapperClasses: ["svg-align"],
        wrapperStyle: o > 0 ? {
          width: "calc(100% - " + Qe(2 * o) + ")",
          marginLeft: Qe(2 * o)
        } : void 0
      }]
    }, e);
  else {
    var d, p;
    n.label === "\\vec" ? (d = ye.staticSvg("vec", e), p = ye.svgData.vec[1]) : (d = ye.makeOrd({
      mode: n.mode,
      text: n.label
    }, e, "textord"), d = J6(d), d.italic = 0, p = d.width, c && (f += d.depth)), h = ye.makeSpan(["accent-body"], [d]);
    var g = n.label === "\\textcircled";
    g && (h.classes.push("accent-full"), f = i.height);
    var v = o;
    g || (v -= p / 2), h.style.left = Qe(v), n.label === "\\textcircled" && (h.style.top = ".2em"), h = ye.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: i
      }, {
        type: "kern",
        size: -f
      }, {
        type: "elem",
        elem: h
      }]
    }, e);
  }
  var m = ye.makeSpan(["mord", "accent"], [h], e);
  return a ? (a.children[0] = m, a.height = Math.max(m.height, a.height), a.classes[0] = "mord", a) : m;
}, J$ = (t, e) => {
  var r = t.isStretchy ? so.mathMLnode(t.label) : new Ue.MathNode("mo", [Ti(t.label, t.mode)]), n = new Ue.MathNode("mover", [Cr(t.base, e), r]);
  return n.setAttribute("accent", "true"), n;
}, Gve = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map((t) => "\\" + t).join("|"));
it({
  type: "accent",
  names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
  props: {
    numArgs: 1
  },
  handler: (t, e) => {
    var r = Om(e[0]), n = !Gve.test(t.funcName), a = !n || t.funcName === "\\widehat" || t.funcName === "\\widetilde" || t.funcName === "\\widecheck";
    return {
      type: "accent",
      mode: t.parser.mode,
      label: t.funcName,
      isStretchy: n,
      isShifty: a,
      base: r
    };
  },
  htmlBuilder: CC,
  mathmlBuilder: J$
});
it({
  type: "accent",
  names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\c", "\\r", "\\H", "\\v", "\\textcircled"],
  props: {
    numArgs: 1,
    allowedInText: !0,
    allowedInMath: !0,
    // unless in strict mode
    argTypes: ["primitive"]
  },
  handler: (t, e) => {
    var r = e[0], n = t.parser.mode;
    return n === "math" && (t.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + t.funcName + " works only in text mode"), n = "text"), {
      type: "accent",
      mode: n,
      label: t.funcName,
      isStretchy: !1,
      isShifty: !0,
      base: r
    };
  },
  htmlBuilder: CC,
  mathmlBuilder: J$
});
it({
  type: "accentUnder",
  names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
  props: {
    numArgs: 1
  },
  handler: (t, e) => {
    var {
      parser: r,
      funcName: n
    } = t, a = e[0];
    return {
      type: "accentUnder",
      mode: r.mode,
      label: n,
      base: a
    };
  },
  htmlBuilder: (t, e) => {
    var r = er(t.base, e), n = so.svgSpan(t, e), a = t.label === "\\utilde" ? 0.12 : 0, i = ye.makeVList({
      positionType: "top",
      positionData: r.height,
      children: [{
        type: "elem",
        elem: n,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: a
      }, {
        type: "elem",
        elem: r
      }]
    }, e);
    return ye.makeSpan(["mord", "accentunder"], [i], e);
  },
  mathmlBuilder: (t, e) => {
    var r = so.mathMLnode(t.label), n = new Ue.MathNode("munder", [Cr(t.base, e), r]);
    return n.setAttribute("accentunder", "true"), n;
  }
});
var ag = (t) => {
  var e = new Ue.MathNode("mpadded", t ? [t] : []);
  return e.setAttribute("width", "+0.6em"), e.setAttribute("lspace", "0.3em"), e;
};
it({
  type: "xArrow",
  names: [
    "\\xleftarrow",
    "\\xrightarrow",
    "\\xLeftarrow",
    "\\xRightarrow",
    "\\xleftrightarrow",
    "\\xLeftrightarrow",
    "\\xhookleftarrow",
    "\\xhookrightarrow",
    "\\xmapsto",
    "\\xrightharpoondown",
    "\\xrightharpoonup",
    "\\xleftharpoondown",
    "\\xleftharpoonup",
    "\\xrightleftharpoons",
    "\\xleftrightharpoons",
    "\\xlongequal",
    "\\xtwoheadrightarrow",
    "\\xtwoheadleftarrow",
    "\\xtofrom",
    // The next 3 functions are here to support the mhchem extension.
    // Direct use of these functions is discouraged and may break someday.
    "\\xrightleftarrows",
    "\\xrightequilibrium",
    "\\xleftequilibrium",
    // The next 3 functions are here only to support the {CD} environment.
    "\\\\cdrightarrow",
    "\\\\cdleftarrow",
    "\\\\cdlongequal"
  ],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler(t, e, r) {
    var {
      parser: n,
      funcName: a
    } = t;
    return {
      type: "xArrow",
      mode: n.mode,
      label: a,
      body: e[0],
      below: r[0]
    };
  },
  // Flow is unable to correctly infer the type of `group`, even though it's
  // unambiguously determined from the passed-in `type` above.
  htmlBuilder(t, e) {
    var r = e.style, n = e.havingStyle(r.sup()), a = ye.wrapFragment(er(t.body, n, e), e), i = t.label.slice(0, 2) === "\\x" ? "x" : "cd";
    a.classes.push(i + "-arrow-pad");
    var s;
    t.below && (n = e.havingStyle(r.sub()), s = ye.wrapFragment(er(t.below, n, e), e), s.classes.push(i + "-arrow-pad"));
    var o = so.svgSpan(t, e), l = -e.fontMetrics().axisHeight + 0.5 * o.height, u = -e.fontMetrics().axisHeight - 0.5 * o.height - 0.111;
    (a.depth > 0.25 || t.label === "\\xleftequilibrium") && (u -= a.depth);
    var c;
    if (s) {
      var f = -e.fontMetrics().axisHeight + s.height + 0.5 * o.height + 0.111;
      c = ye.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: a,
          shift: u
        }, {
          type: "elem",
          elem: o,
          shift: l
        }, {
          type: "elem",
          elem: s,
          shift: f
        }]
      }, e);
    } else
      c = ye.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: a,
          shift: u
        }, {
          type: "elem",
          elem: o,
          shift: l
        }]
      }, e);
    return c.children[0].children[0].children[1].classes.push("svg-align"), ye.makeSpan(["mrel", "x-arrow"], [c], e);
  },
  mathmlBuilder(t, e) {
    var r = so.mathMLnode(t.label);
    r.setAttribute("minsize", t.label.charAt(0) === "x" ? "1.75em" : "3.0em");
    var n;
    if (t.body) {
      var a = ag(Cr(t.body, e));
      if (t.below) {
        var i = ag(Cr(t.below, e));
        n = new Ue.MathNode("munderover", [r, i, a]);
      } else
        n = new Ue.MathNode("mover", [r, a]);
    } else if (t.below) {
      var s = ag(Cr(t.below, e));
      n = new Ue.MathNode("munder", [r, s]);
    } else
      n = ag(), n = new Ue.MathNode("mover", [r, n]);
    return n;
  }
});
var Uve = ye.makeSpan;
function eF(t, e) {
  var r = bn(t.body, e, !0);
  return Uve([t.mclass], r, e);
}
function tF(t, e) {
  var r, n = Oa(t.body, e);
  return t.mclass === "minner" ? r = new Ue.MathNode("mpadded", n) : t.mclass === "mord" ? t.isCharacterBox ? (r = n[0], r.type = "mi") : r = new Ue.MathNode("mi", n) : (t.isCharacterBox ? (r = n[0], r.type = "mo") : r = new Ue.MathNode("mo", n), t.mclass === "mbin" ? (r.attributes.lspace = "0.22em", r.attributes.rspace = "0.22em") : t.mclass === "mpunct" ? (r.attributes.lspace = "0em", r.attributes.rspace = "0.17em") : t.mclass === "mopen" || t.mclass === "mclose" ? (r.attributes.lspace = "0em", r.attributes.rspace = "0em") : t.mclass === "minner" && (r.attributes.lspace = "0.0556em", r.attributes.width = "+0.1111em")), r;
}
it({
  type: "mclass",
  names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler(t, e) {
    var {
      parser: r,
      funcName: n
    } = t, a = e[0];
    return {
      type: "mclass",
      mode: r.mode,
      mclass: "m" + n.slice(5),
      // TODO(kevinb): don't prefix with 'm'
      body: nn(a),
      isCharacterBox: rr.isCharacterBox(a)
    };
  },
  htmlBuilder: eF,
  mathmlBuilder: tF
});
var $1 = (t) => {
  var e = t.type === "ordgroup" && t.body.length ? t.body[0] : t;
  return e.type === "atom" && (e.family === "bin" || e.family === "rel") ? "m" + e.family : "mord";
};
it({
  type: "mclass",
  names: ["\\@binrel"],
  props: {
    numArgs: 2
  },
  handler(t, e) {
    var {
      parser: r
    } = t;
    return {
      type: "mclass",
      mode: r.mode,
      mclass: $1(e[0]),
      body: nn(e[1]),
      isCharacterBox: rr.isCharacterBox(e[1])
    };
  }
});
it({
  type: "mclass",
  names: ["\\stackrel", "\\overset", "\\underset"],
  props: {
    numArgs: 2
  },
  handler(t, e) {
    var {
      parser: r,
      funcName: n
    } = t, a = e[1], i = e[0], s;
    n !== "\\stackrel" ? s = $1(a) : s = "mrel";
    var o = {
      type: "op",
      mode: a.mode,
      limits: !0,
      alwaysHandleSupSub: !0,
      parentIsSupSub: !1,
      symbol: !1,
      suppressBaseShift: n !== "\\stackrel",
      body: nn(a)
    }, l = {
      type: "supsub",
      mode: i.mode,
      base: o,
      sup: n === "\\underset" ? null : i,
      sub: n === "\\underset" ? i : null
    };
    return {
      type: "mclass",
      mode: r.mode,
      mclass: s,
      body: [l],
      isCharacterBox: rr.isCharacterBox(l)
    };
  },
  htmlBuilder: eF,
  mathmlBuilder: tF
});
it({
  type: "pmb",
  names: ["\\pmb"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler(t, e) {
    var {
      parser: r
    } = t;
    return {
      type: "pmb",
      mode: r.mode,
      mclass: $1(e[0]),
      body: nn(e[0])
    };
  },
  htmlBuilder(t, e) {
    var r = bn(t.body, e, !0), n = ye.makeSpan([t.mclass], r, e);
    return n.style.textShadow = "0.02em 0.01em 0.04px", n;
  },
  mathmlBuilder(t, e) {
    var r = Oa(t.body, e), n = new Ue.MathNode("mstyle", r);
    return n.setAttribute("style", "text-shadow: 0.02em 0.01em 0.04px"), n;
  }
});
var Hve = {
  ">": "\\\\cdrightarrow",
  "<": "\\\\cdleftarrow",
  "=": "\\\\cdlongequal",
  A: "\\uparrow",
  V: "\\downarrow",
  "|": "\\Vert",
  ".": "no arrow"
}, o7 = () => ({
  type: "styling",
  body: [],
  mode: "math",
  style: "display"
}), l7 = (t) => t.type === "textord" && t.text === "@", Vve = (t, e) => (t.type === "mathord" || t.type === "atom") && t.text === e;
function qve(t, e, r) {
  var n = Hve[t];
  switch (n) {
    case "\\\\cdrightarrow":
    case "\\\\cdleftarrow":
      return r.callFunction(n, [e[0]], [e[1]]);
    case "\\uparrow":
    case "\\downarrow": {
      var a = r.callFunction("\\\\cdleft", [e[0]], []), i = {
        type: "atom",
        text: n,
        mode: "math",
        family: "rel"
      }, s = r.callFunction("\\Big", [i], []), o = r.callFunction("\\\\cdright", [e[1]], []), l = {
        type: "ordgroup",
        mode: "math",
        body: [a, s, o]
      };
      return r.callFunction("\\\\cdparent", [l], []);
    }
    case "\\\\cdlongequal":
      return r.callFunction("\\\\cdlongequal", [], []);
    case "\\Vert": {
      var u = {
        type: "textord",
        text: "\\Vert",
        mode: "math"
      };
      return r.callFunction("\\Big", [u], []);
    }
    default:
      return {
        type: "textord",
        text: " ",
        mode: "math"
      };
  }
}
function Wve(t) {
  var e = [];
  for (t.gullet.beginGroup(), t.gullet.macros.set("\\cr", "\\\\\\relax"), t.gullet.beginGroup(); ; ) {
    e.push(t.parseExpression(!1, "\\\\")), t.gullet.endGroup(), t.gullet.beginGroup();
    var r = t.fetch().text;
    if (r === "&" || r === "\\\\")
      t.consume();
    else if (r === "\\end") {
      e[e.length - 1].length === 0 && e.pop();
      break;
    } else
      throw new Ve("Expected \\\\ or \\cr or \\end", t.nextToken);
  }
  for (var n = [], a = [n], i = 0; i < e.length; i++) {
    for (var s = e[i], o = o7(), l = 0; l < s.length; l++)
      if (!l7(s[l]))
        o.body.push(s[l]);
      else {
        n.push(o), l += 1;
        var u = SC(s[l]).text, c = new Array(2);
        if (c[0] = {
          type: "ordgroup",
          mode: "math",
          body: []
        }, c[1] = {
          type: "ordgroup",
          mode: "math",
          body: []
        }, !("=|.".indexOf(u) > -1)) if ("<>AV".indexOf(u) > -1)
          for (var f = 0; f < 2; f++) {
            for (var h = !0, d = l + 1; d < s.length; d++) {
              if (Vve(s[d], u)) {
                h = !1, l = d;
                break;
              }
              if (l7(s[d]))
                throw new Ve("Missing a " + u + " character to complete a CD arrow.", s[d]);
              c[f].body.push(s[d]);
            }
            if (h)
              throw new Ve("Missing a " + u + " character to complete a CD arrow.", s[l]);
          }
        else
          throw new Ve('Expected one of "<>AV=|." after @', s[l]);
        var p = qve(u, c, t), g = {
          type: "styling",
          body: [p],
          mode: "math",
          style: "display"
          // CD is always displaystyle.
        };
        n.push(g), o = o7();
      }
    i % 2 === 0 ? n.push(o) : n.shift(), n = [], a.push(n);
  }
  t.gullet.endGroup(), t.gullet.endGroup();
  var v = new Array(a[0].length).fill({
    type: "align",
    align: "c",
    pregap: 0.25,
    // CD package sets \enskip between columns.
    postgap: 0.25
    // So pre and post each get half an \enskip, i.e. 0.25em.
  });
  return {
    type: "array",
    mode: "math",
    body: a,
    arraystretch: 1,
    addJot: !0,
    rowGaps: [null],
    cols: v,
    colSeparationType: "CD",
    hLinesBeforeRow: new Array(a.length + 1).fill([])
  };
}
it({
  type: "cdlabel",
  names: ["\\\\cdleft", "\\\\cdright"],
  props: {
    numArgs: 1
  },
  handler(t, e) {
    var {
      parser: r,
      funcName: n
    } = t;
    return {
      type: "cdlabel",
      mode: r.mode,
      side: n.slice(4),
      label: e[0]
    };
  },
  htmlBuilder(t, e) {
    var r = e.havingStyle(e.style.sup()), n = ye.wrapFragment(er(t.label, r, e), e);
    return n.classes.push("cd-label-" + t.side), n.style.bottom = Qe(0.8 - n.depth), n.height = 0, n.depth = 0, n;
  },
  mathmlBuilder(t, e) {
    var r = new Ue.MathNode("mrow", [Cr(t.label, e)]);
    return r = new Ue.MathNode("mpadded", [r]), r.setAttribute("width", "0"), t.side === "left" && r.setAttribute("lspace", "-1width"), r.setAttribute("voffset", "0.7em"), r = new Ue.MathNode("mstyle", [r]), r.setAttribute("displaystyle", "false"), r.setAttribute("scriptlevel", "1"), r;
  }
});
it({
  type: "cdlabelparent",
  names: ["\\\\cdparent"],
  props: {
    numArgs: 1
  },
  handler(t, e) {
    var {
      parser: r
    } = t;
    return {
      type: "cdlabelparent",
      mode: r.mode,
      fragment: e[0]
    };
  },
  htmlBuilder(t, e) {
    var r = ye.wrapFragment(er(t.fragment, e), e);
    return r.classes.push("cd-vert-arrow"), r;
  },
  mathmlBuilder(t, e) {
    return new Ue.MathNode("mrow", [Cr(t.fragment, e)]);
  }
});
it({
  type: "textord",
  names: ["\\@char"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler(t, e) {
    for (var {
      parser: r
    } = t, n = Bt(e[0], "ordgroup"), a = n.body, i = "", s = 0; s < a.length; s++) {
      var o = Bt(a[s], "textord");
      i += o.text;
    }
    var l = parseInt(i), u;
    if (isNaN(l))
      throw new Ve("\\@char has non-numeric argument " + i);
    if (l < 0 || l >= 1114111)
      throw new Ve("\\@char with invalid code point " + i);
    return l <= 65535 ? u = String.fromCharCode(l) : (l -= 65536, u = String.fromCharCode((l >> 10) + 55296, (l & 1023) + 56320)), {
      type: "textord",
      mode: r.mode,
      text: u
    };
  }
});
var rF = (t, e) => {
  var r = bn(t.body, e.withColor(t.color), !1);
  return ye.makeFragment(r);
}, nF = (t, e) => {
  var r = Oa(t.body, e.withColor(t.color)), n = new Ue.MathNode("mstyle", r);
  return n.setAttribute("mathcolor", t.color), n;
};
it({
  type: "color",
  names: ["\\textcolor"],
  props: {
    numArgs: 2,
    allowedInText: !0,
    argTypes: ["color", "original"]
  },
  handler(t, e) {
    var {
      parser: r
    } = t, n = Bt(e[0], "color-token").color, a = e[1];
    return {
      type: "color",
      mode: r.mode,
      color: n,
      body: nn(a)
    };
  },
  htmlBuilder: rF,
  mathmlBuilder: nF
});
it({
  type: "color",
  names: ["\\color"],
  props: {
    numArgs: 1,
    allowedInText: !0,
    argTypes: ["color"]
  },
  handler(t, e) {
    var {
      parser: r,
      breakOnTokenText: n
    } = t, a = Bt(e[0], "color-token").color;
    r.gullet.macros.set("\\current@color", a);
    var i = r.parseExpression(!0, n);
    return {
      type: "color",
      mode: r.mode,
      color: a,
      body: i
    };
  },
  htmlBuilder: rF,
  mathmlBuilder: nF
});
it({
  type: "cr",
  names: ["\\\\"],
  props: {
    numArgs: 0,
    numOptionalArgs: 0,
    allowedInText: !0
  },
  handler(t, e, r) {
    var {
      parser: n
    } = t, a = n.gullet.future().text === "[" ? n.parseSizeGroup(!0) : null, i = !n.settings.displayMode || !n.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode");
    return {
      type: "cr",
      mode: n.mode,
      newLine: i,
      size: a && Bt(a, "size").value
    };
  },
  // The following builders are called only at the top level,
  // not within tabular/array environments.
  htmlBuilder(t, e) {
    var r = ye.makeSpan(["mspace"], [], e);
    return t.newLine && (r.classes.push("newline"), t.size && (r.style.marginTop = Qe(Ur(t.size, e)))), r;
  },
  mathmlBuilder(t, e) {
    var r = new Ue.MathNode("mspace");
    return t.newLine && (r.setAttribute("linebreak", "newline"), t.size && r.setAttribute("height", Qe(Ur(t.size, e)))), r;
  }
});
var h4 = {
  "\\global": "\\global",
  "\\long": "\\\\globallong",
  "\\\\globallong": "\\\\globallong",
  "\\def": "\\gdef",
  "\\gdef": "\\gdef",
  "\\edef": "\\xdef",
  "\\xdef": "\\xdef",
  "\\let": "\\\\globallet",
  "\\futurelet": "\\\\globalfuture"
}, aF = (t) => {
  var e = t.text;
  if (/^(?:[\\{}$&#^_]|EOF)$/.test(e))
    throw new Ve("Expected a control sequence", t);
  return e;
}, jve = (t) => {
  var e = t.gullet.popToken();
  return e.text === "=" && (e = t.gullet.popToken(), e.text === " " && (e = t.gullet.popToken())), e;
}, iF = (t, e, r, n) => {
  var a = t.gullet.macros.get(r.text);
  a == null && (r.noexpand = !0, a = {
    tokens: [r],
    numArgs: 0,
    // reproduce the same behavior in expansion
    unexpandable: !t.gullet.isExpandable(r.text)
  }), t.gullet.macros.set(e, a, n);
};
it({
  type: "internal",
  names: [
    "\\global",
    "\\long",
    "\\\\globallong"
    // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler(t) {
    var {
      parser: e,
      funcName: r
    } = t;
    e.consumeSpaces();
    var n = e.fetch();
    if (h4[n.text])
      return (r === "\\global" || r === "\\\\globallong") && (n.text = h4[n.text]), Bt(e.parseFunction(), "internal");
    throw new Ve("Invalid token after macro prefix", n);
  }
});
it({
  type: "internal",
  names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(t) {
    var {
      parser: e,
      funcName: r
    } = t, n = e.gullet.popToken(), a = n.text;
    if (/^(?:[\\{}$&#^_]|EOF)$/.test(a))
      throw new Ve("Expected a control sequence", n);
    for (var i = 0, s, o = [[]]; e.gullet.future().text !== "{"; )
      if (n = e.gullet.popToken(), n.text === "#") {
        if (e.gullet.future().text === "{") {
          s = e.gullet.future(), o[i].push("{");
          break;
        }
        if (n = e.gullet.popToken(), !/^[1-9]$/.test(n.text))
          throw new Ve('Invalid argument number "' + n.text + '"');
        if (parseInt(n.text) !== i + 1)
          throw new Ve('Argument number "' + n.text + '" out of order');
        i++, o.push([]);
      } else {
        if (n.text === "EOF")
          throw new Ve("Expected a macro definition");
        o[i].push(n.text);
      }
    var {
      tokens: l
    } = e.gullet.consumeArg();
    return s && l.unshift(s), (r === "\\edef" || r === "\\xdef") && (l = e.gullet.expandTokens(l), l.reverse()), e.gullet.macros.set(a, {
      tokens: l,
      numArgs: i,
      delimiters: o
    }, r === h4[r]), {
      type: "internal",
      mode: e.mode
    };
  }
});
it({
  type: "internal",
  names: [
    "\\let",
    "\\\\globallet"
    // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(t) {
    var {
      parser: e,
      funcName: r
    } = t, n = aF(e.gullet.popToken());
    e.gullet.consumeSpaces();
    var a = jve(e);
    return iF(e, n, a, r === "\\\\globallet"), {
      type: "internal",
      mode: e.mode
    };
  }
});
it({
  type: "internal",
  names: [
    "\\futurelet",
    "\\\\globalfuture"
    // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(t) {
    var {
      parser: e,
      funcName: r
    } = t, n = aF(e.gullet.popToken()), a = e.gullet.popToken(), i = e.gullet.popToken();
    return iF(e, n, i, r === "\\\\globalfuture"), e.gullet.pushToken(i), e.gullet.pushToken(a), {
      type: "internal",
      mode: e.mode
    };
  }
});
var Rh = function(e, r, n) {
  var a = Mr.math[e] && Mr.math[e].replace, i = bC(a || e, r, n);
  if (!i)
    throw new Error("Unsupported symbol " + e + " and font size " + r + ".");
  return i;
}, AC = function(e, r, n, a) {
  var i = n.havingBaseStyle(r), s = ye.makeSpan(a.concat(i.sizingClasses(n)), [e], n), o = i.sizeMultiplier / n.sizeMultiplier;
  return s.height *= o, s.depth *= o, s.maxFontSize = i.sizeMultiplier, s;
}, sF = function(e, r, n) {
  var a = r.havingBaseStyle(n), i = (1 - r.sizeMultiplier / a.sizeMultiplier) * r.fontMetrics().axisHeight;
  e.classes.push("delimcenter"), e.style.top = Qe(i), e.height -= i, e.depth += i;
}, Yve = function(e, r, n, a, i, s) {
  var o = ye.makeSymbol(e, "Main-Regular", i, a), l = AC(o, r, a, s);
  return n && sF(l, a, r), l;
}, Xve = function(e, r, n, a) {
  return ye.makeSymbol(e, "Size" + r + "-Regular", n, a);
}, oF = function(e, r, n, a, i, s) {
  var o = Xve(e, r, i, a), l = AC(ye.makeSpan(["delimsizing", "size" + r], [o], a), Ct.TEXT, a, s);
  return n && sF(l, a, Ct.TEXT), l;
}, Bx = function(e, r, n) {
  var a;
  r === "Size1-Regular" ? a = "delim-size1" : a = "delim-size4";
  var i = ye.makeSpan(["delimsizinginner", a], [ye.makeSpan([], [ye.makeSymbol(e, r, n)])]);
  return {
    type: "elem",
    elem: i
  };
}, zx = function(e, r, n) {
  var a = fs["Size4-Regular"][e.charCodeAt(0)] ? fs["Size4-Regular"][e.charCodeAt(0)][4] : fs["Size1-Regular"][e.charCodeAt(0)][4], i = new qo("inner", tve(e, Math.round(1e3 * r))), s = new ao([i], {
    width: Qe(a),
    height: Qe(r),
    // Override CSS rule `.katex svg { width: 100% }`
    style: "width:" + Qe(a),
    viewBox: "0 0 " + 1e3 * a + " " + Math.round(1e3 * r),
    preserveAspectRatio: "xMinYMin"
  }), o = ye.makeSvgSpan([], [s], n);
  return o.height = r, o.style.height = Qe(r), o.style.width = Qe(a), {
    type: "elem",
    elem: o
  };
}, d4 = 8e-3, ig = {
  type: "kern",
  size: -1 * d4
}, Kve = ["|", "\\lvert", "\\rvert", "\\vert"], Zve = ["\\|", "\\lVert", "\\rVert", "\\Vert"], lF = function(e, r, n, a, i, s) {
  var o, l, u, c, f = "", h = 0;
  o = u = c = e, l = null;
  var d = "Size1-Regular";
  e === "\\uparrow" ? u = c = "⏐" : e === "\\Uparrow" ? u = c = "‖" : e === "\\downarrow" ? o = u = "⏐" : e === "\\Downarrow" ? o = u = "‖" : e === "\\updownarrow" ? (o = "\\uparrow", u = "⏐", c = "\\downarrow") : e === "\\Updownarrow" ? (o = "\\Uparrow", u = "‖", c = "\\Downarrow") : Kve.includes(e) ? (u = "∣", f = "vert", h = 333) : Zve.includes(e) ? (u = "∥", f = "doublevert", h = 556) : e === "[" || e === "\\lbrack" ? (o = "⎡", u = "⎢", c = "⎣", d = "Size4-Regular", f = "lbrack", h = 667) : e === "]" || e === "\\rbrack" ? (o = "⎤", u = "⎥", c = "⎦", d = "Size4-Regular", f = "rbrack", h = 667) : e === "\\lfloor" || e === "⌊" ? (u = o = "⎢", c = "⎣", d = "Size4-Regular", f = "lfloor", h = 667) : e === "\\lceil" || e === "⌈" ? (o = "⎡", u = c = "⎢", d = "Size4-Regular", f = "lceil", h = 667) : e === "\\rfloor" || e === "⌋" ? (u = o = "⎥", c = "⎦", d = "Size4-Regular", f = "rfloor", h = 667) : e === "\\rceil" || e === "⌉" ? (o = "⎤", u = c = "⎥", d = "Size4-Regular", f = "rceil", h = 667) : e === "(" || e === "\\lparen" ? (o = "⎛", u = "⎜", c = "⎝", d = "Size4-Regular", f = "lparen", h = 875) : e === ")" || e === "\\rparen" ? (o = "⎞", u = "⎟", c = "⎠", d = "Size4-Regular", f = "rparen", h = 875) : e === "\\{" || e === "\\lbrace" ? (o = "⎧", l = "⎨", c = "⎩", u = "⎪", d = "Size4-Regular") : e === "\\}" || e === "\\rbrace" ? (o = "⎫", l = "⎬", c = "⎭", u = "⎪", d = "Size4-Regular") : e === "\\lgroup" || e === "⟮" ? (o = "⎧", c = "⎩", u = "⎪", d = "Size4-Regular") : e === "\\rgroup" || e === "⟯" ? (o = "⎫", c = "⎭", u = "⎪", d = "Size4-Regular") : e === "\\lmoustache" || e === "⎰" ? (o = "⎧", c = "⎭", u = "⎪", d = "Size4-Regular") : (e === "\\rmoustache" || e === "⎱") && (o = "⎫", c = "⎩", u = "⎪", d = "Size4-Regular");
  var p = Rh(o, d, i), g = p.height + p.depth, v = Rh(u, d, i), m = v.height + v.depth, b = Rh(c, d, i), y = b.height + b.depth, x = 0, E = 1;
  if (l !== null) {
    var S = Rh(l, d, i);
    x = S.height + S.depth, E = 2;
  }
  var w = g + y + x, C = Math.max(0, Math.ceil((r - w) / (E * m))), k = w + C * E * m, N = a.fontMetrics().axisHeight;
  n && (N *= a.sizeMultiplier);
  var R = k / 2 - N, _ = [];
  if (f.length > 0) {
    var O = k - g - y, T = Math.round(k * 1e3), L = rve(f, Math.round(O * 1e3)), M = new qo(f, L), A = (h / 1e3).toFixed(3) + "em", I = (T / 1e3).toFixed(3) + "em", D = new ao([M], {
      width: A,
      height: I,
      viewBox: "0 0 " + h + " " + T
    }), F = ye.makeSvgSpan([], [D], a);
    F.height = T / 1e3, F.style.width = A, F.style.height = I, _.push({
      type: "elem",
      elem: F
    });
  } else {
    if (_.push(Bx(c, d, i)), _.push(ig), l === null) {
      var B = k - g - y + 2 * d4;
      _.push(zx(u, B, a));
    } else {
      var G = (k - g - y - x) / 2 + 2 * d4;
      _.push(zx(u, G, a)), _.push(ig), _.push(Bx(l, d, i)), _.push(ig), _.push(zx(u, G, a));
    }
    _.push(ig), _.push(Bx(o, d, i));
  }
  var H = a.havingBaseStyle(Ct.TEXT), K = ye.makeVList({
    positionType: "bottom",
    positionData: R,
    children: _
  }, H);
  return AC(ye.makeSpan(["delimsizing", "mult"], [K], H), Ct.TEXT, a, s);
}, Gx = 80, Ux = 0.08, Hx = function(e, r, n, a, i) {
  var s = eve(e, a, n), o = new qo(e, s), l = new ao([o], {
    // Note: 1000:1 ratio of viewBox to document em width.
    width: "400em",
    height: Qe(r),
    viewBox: "0 0 400000 " + n,
    preserveAspectRatio: "xMinYMin slice"
  });
  return ye.makeSvgSpan(["hide-tail"], [l], i);
}, Qve = function(e, r) {
  var n = r.havingBaseSizing(), a = hF("\\surd", e * n.sizeMultiplier, fF, n), i = n.sizeMultiplier, s = Math.max(0, r.minRuleThickness - r.fontMetrics().sqrtRuleThickness), o, l = 0, u = 0, c = 0, f;
  return a.type === "small" ? (c = 1e3 + 1e3 * s + Gx, e < 1 ? i = 1 : e < 1.4 && (i = 0.7), l = (1 + s + Ux) / i, u = (1 + s) / i, o = Hx("sqrtMain", l, c, s, r), o.style.minWidth = "0.853em", f = 0.833 / i) : a.type === "large" ? (c = (1e3 + Gx) * _d[a.size], u = (_d[a.size] + s) / i, l = (_d[a.size] + s + Ux) / i, o = Hx("sqrtSize" + a.size, l, c, s, r), o.style.minWidth = "1.02em", f = 1 / i) : (l = e + s + Ux, u = e + s, c = Math.floor(1e3 * e + s) + Gx, o = Hx("sqrtTall", l, c, s, r), o.style.minWidth = "0.742em", f = 1.056), o.height = u, o.style.height = Qe(l), {
    span: o,
    advanceWidth: f,
    // Calculate the actual line width.
    // This actually should depend on the chosen font -- e.g. \boldmath
    // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and
    // have thicker rules.
    ruleWidth: (r.fontMetrics().sqrtRuleThickness + s) * i
  };
}, uF = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "⌊", "⌋", "\\lceil", "\\rceil", "⌈", "⌉", "\\surd"], Jve = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "⟮", "⟯", "\\lmoustache", "\\rmoustache", "⎰", "⎱"], cF = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"], _d = [0, 1.2, 1.8, 2.4, 3], eme = function(e, r, n, a, i) {
  if (e === "<" || e === "\\lt" || e === "⟨" ? e = "\\langle" : (e === ">" || e === "\\gt" || e === "⟩") && (e = "\\rangle"), uF.includes(e) || cF.includes(e))
    return oF(e, r, !1, n, a, i);
  if (Jve.includes(e))
    return lF(e, _d[r], !1, n, a, i);
  throw new Ve("Illegal delimiter: '" + e + "'");
}, tme = [{
  type: "small",
  style: Ct.SCRIPTSCRIPT
}, {
  type: "small",
  style: Ct.SCRIPT
}, {
  type: "small",
  style: Ct.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}], rme = [{
  type: "small",
  style: Ct.SCRIPTSCRIPT
}, {
  type: "small",
  style: Ct.SCRIPT
}, {
  type: "small",
  style: Ct.TEXT
}, {
  type: "stack"
}], fF = [{
  type: "small",
  style: Ct.SCRIPTSCRIPT
}, {
  type: "small",
  style: Ct.SCRIPT
}, {
  type: "small",
  style: Ct.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}, {
  type: "stack"
}], nme = function(e) {
  if (e.type === "small")
    return "Main-Regular";
  if (e.type === "large")
    return "Size" + e.size + "-Regular";
  if (e.type === "stack")
    return "Size4-Regular";
  throw new Error("Add support for delim type '" + e.type + "' here.");
}, hF = function(e, r, n, a) {
  for (var i = Math.min(2, 3 - a.style.size), s = i; s < n.length && n[s].type !== "stack"; s++) {
    var o = Rh(e, nme(n[s]), "math"), l = o.height + o.depth;
    if (n[s].type === "small") {
      var u = a.havingBaseStyle(n[s].style);
      l *= u.sizeMultiplier;
    }
    if (l > r)
      return n[s];
  }
  return n[n.length - 1];
}, dF = function(e, r, n, a, i, s) {
  e === "<" || e === "\\lt" || e === "⟨" ? e = "\\langle" : (e === ">" || e === "\\gt" || e === "⟩") && (e = "\\rangle");
  var o;
  cF.includes(e) ? o = tme : uF.includes(e) ? o = fF : o = rme;
  var l = hF(e, r, o, a);
  return l.type === "small" ? Yve(e, l.style, n, a, i, s) : l.type === "large" ? oF(e, l.size, n, a, i, s) : lF(e, r, n, a, i, s);
}, ame = function(e, r, n, a, i, s) {
  var o = a.fontMetrics().axisHeight * a.sizeMultiplier, l = 901, u = 5 / a.fontMetrics().ptPerEm, c = Math.max(r - o, n + o), f = Math.max(
    // In real TeX, calculations are done using integral values which are
    // 65536 per pt, or 655360 per em. So, the division here truncates in
    // TeX but doesn't here, producing different results. If we wanted to
    // exactly match TeX's calculation, we could do
    //   Math.floor(655360 * maxDistFromAxis / 500) *
    //    delimiterFactor / 655360
    // (To see the difference, compare
    //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
    // in TeX and KaTeX)
    c / 500 * l,
    2 * c - u
  );
  return dF(e, f, !0, a, i, s);
}, Qs = {
  sqrtImage: Qve,
  sizedDelim: eme,
  sizeToMaxHeight: _d,
  customSizedDelim: dF,
  leftRightDelim: ame
}, u7 = {
  "\\bigl": {
    mclass: "mopen",
    size: 1
  },
  "\\Bigl": {
    mclass: "mopen",
    size: 2
  },
  "\\biggl": {
    mclass: "mopen",
    size: 3
  },
  "\\Biggl": {
    mclass: "mopen",
    size: 4
  },
  "\\bigr": {
    mclass: "mclose",
    size: 1
  },
  "\\Bigr": {
    mclass: "mclose",
    size: 2
  },
  "\\biggr": {
    mclass: "mclose",
    size: 3
  },
  "\\Biggr": {
    mclass: "mclose",
    size: 4
  },
  "\\bigm": {
    mclass: "mrel",
    size: 1
  },
  "\\Bigm": {
    mclass: "mrel",
    size: 2
  },
  "\\biggm": {
    mclass: "mrel",
    size: 3
  },
  "\\Biggm": {
    mclass: "mrel",
    size: 4
  },
  "\\big": {
    mclass: "mord",
    size: 1
  },
  "\\Big": {
    mclass: "mord",
    size: 2
  },
  "\\bigg": {
    mclass: "mord",
    size: 3
  },
  "\\Bigg": {
    mclass: "mord",
    size: 4
  }
}, ime = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "⌊", "⌋", "\\lceil", "\\rceil", "⌈", "⌉", "<", ">", "\\langle", "⟨", "\\rangle", "⟩", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "⟮", "⟯", "\\lmoustache", "\\rmoustache", "⎰", "⎱", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
function F1(t, e) {
  var r = D1(t);
  if (r && ime.includes(r.text))
    return r;
  throw r ? new Ve("Invalid delimiter '" + r.text + "' after '" + e.funcName + "'", t) : new Ve("Invalid delimiter type '" + t.type + "'", t);
}
it({
  type: "delimsizing",
  names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
  props: {
    numArgs: 1,
    argTypes: ["primitive"]
  },
  handler: (t, e) => {
    var r = F1(e[0], t);
    return {
      type: "delimsizing",
      mode: t.parser.mode,
      size: u7[t.funcName].size,
      mclass: u7[t.funcName].mclass,
      delim: r.text
    };
  },
  htmlBuilder: (t, e) => t.delim === "." ? ye.makeSpan([t.mclass]) : Qs.sizedDelim(t.delim, t.size, e, t.mode, [t.mclass]),
  mathmlBuilder: (t) => {
    var e = [];
    t.delim !== "." && e.push(Ti(t.delim, t.mode));
    var r = new Ue.MathNode("mo", e);
    t.mclass === "mopen" || t.mclass === "mclose" ? r.setAttribute("fence", "true") : r.setAttribute("fence", "false"), r.setAttribute("stretchy", "true");
    var n = Qe(Qs.sizeToMaxHeight[t.size]);
    return r.setAttribute("minsize", n), r.setAttribute("maxsize", n), r;
  }
});
function c7(t) {
  if (!t.body)
    throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
}
it({
  type: "leftright-right",
  names: ["\\right"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (t, e) => {
    var r = t.parser.gullet.macros.get("\\current@color");
    if (r && typeof r != "string")
      throw new Ve("\\current@color set to non-string in \\right");
    return {
      type: "leftright-right",
      mode: t.parser.mode,
      delim: F1(e[0], t).text,
      color: r
      // undefined if not set via \color
    };
  }
});
it({
  type: "leftright",
  names: ["\\left"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (t, e) => {
    var r = F1(e[0], t), n = t.parser;
    ++n.leftrightDepth;
    var a = n.parseExpression(!1);
    --n.leftrightDepth, n.expect("\\right", !1);
    var i = Bt(n.parseFunction(), "leftright-right");
    return {
      type: "leftright",
      mode: n.mode,
      body: a,
      left: r.text,
      right: i.delim,
      rightColor: i.color
    };
  },
  htmlBuilder: (t, e) => {
    c7(t);
    for (var r = bn(t.body, e, !0, ["mopen", "mclose"]), n = 0, a = 0, i = !1, s = 0; s < r.length; s++)
      r[s].isMiddle ? i = !0 : (n = Math.max(r[s].height, n), a = Math.max(r[s].depth, a));
    n *= e.sizeMultiplier, a *= e.sizeMultiplier;
    var o;
    if (t.left === "." ? o = n0(e, ["mopen"]) : o = Qs.leftRightDelim(t.left, n, a, e, t.mode, ["mopen"]), r.unshift(o), i)
      for (var l = 1; l < r.length; l++) {
        var u = r[l], c = u.isMiddle;
        c && (r[l] = Qs.leftRightDelim(c.delim, n, a, c.options, t.mode, []));
      }
    var f;
    if (t.right === ".")
      f = n0(e, ["mclose"]);
    else {
      var h = t.rightColor ? e.withColor(t.rightColor) : e;
      f = Qs.leftRightDelim(t.right, n, a, h, t.mode, ["mclose"]);
    }
    return r.push(f), ye.makeSpan(["minner"], r, e);
  },
  mathmlBuilder: (t, e) => {
    c7(t);
    var r = Oa(t.body, e);
    if (t.left !== ".") {
      var n = new Ue.MathNode("mo", [Ti(t.left, t.mode)]);
      n.setAttribute("fence", "true"), r.unshift(n);
    }
    if (t.right !== ".") {
      var a = new Ue.MathNode("mo", [Ti(t.right, t.mode)]);
      a.setAttribute("fence", "true"), t.rightColor && a.setAttribute("mathcolor", t.rightColor), r.push(a);
    }
    return EC(r);
  }
});
it({
  type: "middle",
  names: ["\\middle"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (t, e) => {
    var r = F1(e[0], t);
    if (!t.parser.leftrightDepth)
      throw new Ve("\\middle without preceding \\left", r);
    return {
      type: "middle",
      mode: t.parser.mode,
      delim: r.text
    };
  },
  htmlBuilder: (t, e) => {
    var r;
    if (t.delim === ".")
      r = n0(e, []);
    else {
      r = Qs.sizedDelim(t.delim, 1, e, t.mode, []);
      var n = {
        delim: t.delim,
        options: e
      };
      r.isMiddle = n;
    }
    return r;
  },
  mathmlBuilder: (t, e) => {
    var r = t.delim === "\\vert" || t.delim === "|" ? Ti("|", "text") : Ti(t.delim, t.mode), n = new Ue.MathNode("mo", [r]);
    return n.setAttribute("fence", "true"), n.setAttribute("lspace", "0.05em"), n.setAttribute("rspace", "0.05em"), n;
  }
});
var kC = (t, e) => {
  var r = ye.wrapFragment(er(t.body, e), e), n = t.label.slice(1), a = e.sizeMultiplier, i, s = 0, o = rr.isCharacterBox(t.body);
  if (n === "sout")
    i = ye.makeSpan(["stretchy", "sout"]), i.height = e.fontMetrics().defaultRuleThickness / a, s = -0.5 * e.fontMetrics().xHeight;
  else if (n === "phase") {
    var l = Ur({
      number: 0.6,
      unit: "pt"
    }, e), u = Ur({
      number: 0.35,
      unit: "ex"
    }, e), c = e.havingBaseSizing();
    a = a / c.sizeMultiplier;
    var f = r.height + r.depth + l + u;
    r.style.paddingLeft = Qe(f / 2 + l);
    var h = Math.floor(1e3 * f * a), d = Qge(h), p = new ao([new qo("phase", d)], {
      width: "400em",
      height: Qe(h / 1e3),
      viewBox: "0 0 400000 " + h,
      preserveAspectRatio: "xMinYMin slice"
    });
    i = ye.makeSvgSpan(["hide-tail"], [p], e), i.style.height = Qe(f), s = r.depth + l + u;
  } else {
    /cancel/.test(n) ? o || r.classes.push("cancel-pad") : n === "angl" ? r.classes.push("anglpad") : r.classes.push("boxpad");
    var g = 0, v = 0, m = 0;
    /box/.test(n) ? (m = Math.max(
      e.fontMetrics().fboxrule,
      // default
      e.minRuleThickness
      // User override.
    ), g = e.fontMetrics().fboxsep + (n === "colorbox" ? 0 : m), v = g) : n === "angl" ? (m = Math.max(e.fontMetrics().defaultRuleThickness, e.minRuleThickness), g = 4 * m, v = Math.max(0, 0.25 - r.depth)) : (g = o ? 0.2 : 0, v = g), i = so.encloseSpan(r, n, g, v, e), /fbox|boxed|fcolorbox/.test(n) ? (i.style.borderStyle = "solid", i.style.borderWidth = Qe(m)) : n === "angl" && m !== 0.049 && (i.style.borderTopWidth = Qe(m), i.style.borderRightWidth = Qe(m)), s = r.depth + v, t.backgroundColor && (i.style.backgroundColor = t.backgroundColor, t.borderColor && (i.style.borderColor = t.borderColor));
  }
  var b;
  if (t.backgroundColor)
    b = ye.makeVList({
      positionType: "individualShift",
      children: [
        // Put the color background behind inner;
        {
          type: "elem",
          elem: i,
          shift: s
        },
        {
          type: "elem",
          elem: r,
          shift: 0
        }
      ]
    }, e);
  else {
    var y = /cancel|phase/.test(n) ? ["svg-align"] : [];
    b = ye.makeVList({
      positionType: "individualShift",
      children: [
        // Write the \cancel stroke on top of inner.
        {
          type: "elem",
          elem: r,
          shift: 0
        },
        {
          type: "elem",
          elem: i,
          shift: s,
          wrapperClasses: y
        }
      ]
    }, e);
  }
  return /cancel/.test(n) && (b.height = r.height, b.depth = r.depth), /cancel/.test(n) && !o ? ye.makeSpan(["mord", "cancel-lap"], [b], e) : ye.makeSpan(["mord"], [b], e);
}, RC = (t, e) => {
  var r = 0, n = new Ue.MathNode(t.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [Cr(t.body, e)]);
  switch (t.label) {
    case "\\cancel":
      n.setAttribute("notation", "updiagonalstrike");
      break;
    case "\\bcancel":
      n.setAttribute("notation", "downdiagonalstrike");
      break;
    case "\\phase":
      n.setAttribute("notation", "phasorangle");
      break;
    case "\\sout":
      n.setAttribute("notation", "horizontalstrike");
      break;
    case "\\fbox":
      n.setAttribute("notation", "box");
      break;
    case "\\angl":
      n.setAttribute("notation", "actuarial");
      break;
    case "\\fcolorbox":
    case "\\colorbox":
      if (r = e.fontMetrics().fboxsep * e.fontMetrics().ptPerEm, n.setAttribute("width", "+" + 2 * r + "pt"), n.setAttribute("height", "+" + 2 * r + "pt"), n.setAttribute("lspace", r + "pt"), n.setAttribute("voffset", r + "pt"), t.label === "\\fcolorbox") {
        var a = Math.max(
          e.fontMetrics().fboxrule,
          // default
          e.minRuleThickness
          // user override
        );
        n.setAttribute("style", "border: " + a + "em solid " + String(t.borderColor));
      }
      break;
    case "\\xcancel":
      n.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
      break;
  }
  return t.backgroundColor && n.setAttribute("mathbackground", t.backgroundColor), n;
};
it({
  type: "enclose",
  names: ["\\colorbox"],
  props: {
    numArgs: 2,
    allowedInText: !0,
    argTypes: ["color", "text"]
  },
  handler(t, e, r) {
    var {
      parser: n,
      funcName: a
    } = t, i = Bt(e[0], "color-token").color, s = e[1];
    return {
      type: "enclose",
      mode: n.mode,
      label: a,
      backgroundColor: i,
      body: s
    };
  },
  htmlBuilder: kC,
  mathmlBuilder: RC
});
it({
  type: "enclose",
  names: ["\\fcolorbox"],
  props: {
    numArgs: 3,
    allowedInText: !0,
    argTypes: ["color", "color", "text"]
  },
  handler(t, e, r) {
    var {
      parser: n,
      funcName: a
    } = t, i = Bt(e[0], "color-token").color, s = Bt(e[1], "color-token").color, o = e[2];
    return {
      type: "enclose",
      mode: n.mode,
      label: a,
      backgroundColor: s,
      borderColor: i,
      body: o
    };
  },
  htmlBuilder: kC,
  mathmlBuilder: RC
});
it({
  type: "enclose",
  names: ["\\fbox"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: !0
  },
  handler(t, e) {
    var {
      parser: r
    } = t;
    return {
      type: "enclose",
      mode: r.mode,
      label: "\\fbox",
      body: e[0]
    };
  }
});
it({
  type: "enclose",
  names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"],
  props: {
    numArgs: 1
  },
  handler(t, e) {
    var {
      parser: r,
      funcName: n
    } = t, a = e[0];
    return {
      type: "enclose",
      mode: r.mode,
      label: n,
      body: a
    };
  },
  htmlBuilder: kC,
  mathmlBuilder: RC
});
it({
  type: "enclose",
  names: ["\\angl"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: !1
  },
  handler(t, e) {
    var {
      parser: r
    } = t;
    return {
      type: "enclose",
      mode: r.mode,
      label: "\\angl",
      body: e[0]
    };
  }
});
var pF = {};
function Ts(t) {
  for (var {
    type: e,
    names: r,
    props: n,
    handler: a,
    htmlBuilder: i,
    mathmlBuilder: s
  } = t, o = {
    type: e,
    numArgs: n.numArgs || 0,
    allowedInText: !1,
    numOptionalArgs: 0,
    handler: a
  }, l = 0; l < r.length; ++l)
    pF[r[l]] = o;
  i && (Lm[e] = i), s && (Nm[e] = s);
}
var gF = {};
function Y(t, e) {
  gF[t] = e;
}
function f7(t) {
  var e = [];
  t.consumeSpaces();
  var r = t.fetch().text;
  for (r === "\\relax" && (t.consume(), t.consumeSpaces(), r = t.fetch().text); r === "\\hline" || r === "\\hdashline"; )
    t.consume(), e.push(r === "\\hdashline"), t.consumeSpaces(), r = t.fetch().text;
  return e;
}
var B1 = (t) => {
  var e = t.parser.settings;
  if (!e.displayMode)
    throw new Ve("{" + t.envName + "} can be used only in display mode.");
};
function MC(t) {
  if (t.indexOf("ed") === -1)
    return t.indexOf("*") === -1;
}
function fl(t, e, r) {
  var {
    hskipBeforeAndAfter: n,
    addJot: a,
    cols: i,
    arraystretch: s,
    colSeparationType: o,
    autoTag: l,
    singleRow: u,
    emptySingleRow: c,
    maxNumCols: f,
    leqno: h
  } = e;
  if (t.gullet.beginGroup(), u || t.gullet.macros.set("\\cr", "\\\\\\relax"), !s) {
    var d = t.gullet.expandMacroAsText("\\arraystretch");
    if (d == null)
      s = 1;
    else if (s = parseFloat(d), !s || s < 0)
      throw new Ve("Invalid \\arraystretch: " + d);
  }
  t.gullet.beginGroup();
  var p = [], g = [p], v = [], m = [], b = l != null ? [] : void 0;
  function y() {
    l && t.gullet.macros.set("\\@eqnsw", "1", !0);
  }
  function x() {
    b && (t.gullet.macros.get("\\df@tag") ? (b.push(t.subparse([new ei("\\df@tag")])), t.gullet.macros.set("\\df@tag", void 0, !0)) : b.push(!!l && t.gullet.macros.get("\\@eqnsw") === "1"));
  }
  for (y(), m.push(f7(t)); ; ) {
    var E = t.parseExpression(!1, u ? "\\end" : "\\\\");
    t.gullet.endGroup(), t.gullet.beginGroup(), E = {
      type: "ordgroup",
      mode: t.mode,
      body: E
    }, r && (E = {
      type: "styling",
      mode: t.mode,
      style: r,
      body: [E]
    }), p.push(E);
    var S = t.fetch().text;
    if (S === "&") {
      if (f && p.length === f) {
        if (u || o)
          throw new Ve("Too many tab characters: &", t.nextToken);
        t.settings.reportNonstrict("textEnv", "Too few columns specified in the {array} column argument.");
      }
      t.consume();
    } else if (S === "\\end") {
      x(), p.length === 1 && E.type === "styling" && E.body[0].body.length === 0 && (g.length > 1 || !c) && g.pop(), m.length < g.length + 1 && m.push([]);
      break;
    } else if (S === "\\\\") {
      t.consume();
      var w = void 0;
      t.gullet.future().text !== " " && (w = t.parseSizeGroup(!0)), v.push(w ? w.value : null), x(), m.push(f7(t)), p = [], g.push(p), y();
    } else
      throw new Ve("Expected & or \\\\ or \\cr or \\end", t.nextToken);
  }
  return t.gullet.endGroup(), t.gullet.endGroup(), {
    type: "array",
    mode: t.mode,
    addJot: a,
    arraystretch: s,
    body: g,
    cols: i,
    rowGaps: v,
    hskipBeforeAndAfter: n,
    hLinesBeforeRow: m,
    colSeparationType: o,
    tags: b,
    leqno: h
  };
}
function _C(t) {
  return t.slice(0, 1) === "d" ? "display" : "text";
}
var Ss = function(e, r) {
  var n, a, i = e.body.length, s = e.hLinesBeforeRow, o = 0, l = new Array(i), u = [], c = Math.max(
    // From LaTeX \showthe\arrayrulewidth. Equals 0.04 em.
    r.fontMetrics().arrayRuleWidth,
    r.minRuleThickness
    // User override.
  ), f = 1 / r.fontMetrics().ptPerEm, h = 5 * f;
  if (e.colSeparationType && e.colSeparationType === "small") {
    var d = r.havingStyle(Ct.SCRIPT).sizeMultiplier;
    h = 0.2778 * (d / r.sizeMultiplier);
  }
  var p = e.colSeparationType === "CD" ? Ur({
    number: 3,
    unit: "ex"
  }, r) : 12 * f, g = 3 * f, v = e.arraystretch * p, m = 0.7 * v, b = 0.3 * v, y = 0;
  function x(me) {
    for (var we = 0; we < me.length; ++we)
      we > 0 && (y += 0.25), u.push({
        pos: y,
        isDashed: me[we]
      });
  }
  for (x(s[0]), n = 0; n < e.body.length; ++n) {
    var E = e.body[n], S = m, w = b;
    o < E.length && (o = E.length);
    var C = new Array(E.length);
    for (a = 0; a < E.length; ++a) {
      var k = er(E[a], r);
      w < k.depth && (w = k.depth), S < k.height && (S = k.height), C[a] = k;
    }
    var N = e.rowGaps[n], R = 0;
    N && (R = Ur(N, r), R > 0 && (R += b, w < R && (w = R), R = 0)), e.addJot && (w += g), C.height = S, C.depth = w, y += S, C.pos = y, y += w + R, l[n] = C, x(s[n + 1]);
  }
  var _ = y / 2 + r.fontMetrics().axisHeight, O = e.cols || [], T = [], L, M, A = [];
  if (e.tags && e.tags.some((me) => me))
    for (n = 0; n < i; ++n) {
      var I = l[n], D = I.pos - _, F = e.tags[n], B = void 0;
      F === !0 ? B = ye.makeSpan(["eqn-num"], [], r) : F === !1 ? B = ye.makeSpan([], [], r) : B = ye.makeSpan([], bn(F, r, !0), r), B.depth = I.depth, B.height = I.height, A.push({
        type: "elem",
        elem: B,
        shift: D
      });
    }
  for (
    a = 0, M = 0;
    // Continue while either there are more columns or more column
    // descriptions, so trailing separators don't get lost.
    a < o || M < O.length;
    ++a, ++M
  ) {
    for (var G = O[M] || {}, H = !0; G.type === "separator"; ) {
      if (H || (L = ye.makeSpan(["arraycolsep"], []), L.style.width = Qe(r.fontMetrics().doubleRuleSep), T.push(L)), G.separator === "|" || G.separator === ":") {
        var K = G.separator === "|" ? "solid" : "dashed", j = ye.makeSpan(["vertical-separator"], [], r);
        j.style.height = Qe(y), j.style.borderRightWidth = Qe(c), j.style.borderRightStyle = K, j.style.margin = "0 " + Qe(-c / 2);
        var Z = y - _;
        Z && (j.style.verticalAlign = Qe(-Z)), T.push(j);
      } else
        throw new Ve("Invalid separator type: " + G.separator);
      M++, G = O[M] || {}, H = !1;
    }
    if (!(a >= o)) {
      var te = void 0;
      (a > 0 || e.hskipBeforeAndAfter) && (te = rr.deflt(G.pregap, h), te !== 0 && (L = ye.makeSpan(["arraycolsep"], []), L.style.width = Qe(te), T.push(L)));
      var ne = [];
      for (n = 0; n < i; ++n) {
        var V = l[n], q = V[a];
        if (q) {
          var X = V.pos - _;
          q.depth = V.depth, q.height = V.height, ne.push({
            type: "elem",
            elem: q,
            shift: X
          });
        }
      }
      ne = ye.makeVList({
        positionType: "individualShift",
        children: ne
      }, r), ne = ye.makeSpan(["col-align-" + (G.align || "c")], [ne]), T.push(ne), (a < o - 1 || e.hskipBeforeAndAfter) && (te = rr.deflt(G.postgap, h), te !== 0 && (L = ye.makeSpan(["arraycolsep"], []), L.style.width = Qe(te), T.push(L)));
    }
  }
  if (l = ye.makeSpan(["mtable"], T), u.length > 0) {
    for (var W = ye.makeLineSpan("hline", r, c), ue = ye.makeLineSpan("hdashline", r, c), J = [{
      type: "elem",
      elem: l,
      shift: 0
    }]; u.length > 0; ) {
      var Ce = u.pop(), Ee = Ce.pos - _;
      Ce.isDashed ? J.push({
        type: "elem",
        elem: ue,
        shift: Ee
      }) : J.push({
        type: "elem",
        elem: W,
        shift: Ee
      });
    }
    l = ye.makeVList({
      positionType: "individualShift",
      children: J
    }, r);
  }
  if (A.length === 0)
    return ye.makeSpan(["mord"], [l], r);
  var Te = ye.makeVList({
    positionType: "individualShift",
    children: A
  }, r);
  return Te = ye.makeSpan(["tag"], [Te], r), ye.makeFragment([l, Te]);
}, sme = {
  c: "center ",
  l: "left ",
  r: "right "
}, Cs = function(e, r) {
  for (var n = [], a = new Ue.MathNode("mtd", [], ["mtr-glue"]), i = new Ue.MathNode("mtd", [], ["mml-eqn-num"]), s = 0; s < e.body.length; s++) {
    for (var o = e.body[s], l = [], u = 0; u < o.length; u++)
      l.push(new Ue.MathNode("mtd", [Cr(o[u], r)]));
    e.tags && e.tags[s] && (l.unshift(a), l.push(a), e.leqno ? l.unshift(i) : l.push(i)), n.push(new Ue.MathNode("mtr", l));
  }
  var c = new Ue.MathNode("mtable", n), f = e.arraystretch === 0.5 ? 0.1 : 0.16 + e.arraystretch - 1 + (e.addJot ? 0.09 : 0);
  c.setAttribute("rowspacing", Qe(f));
  var h = "", d = "";
  if (e.cols && e.cols.length > 0) {
    var p = e.cols, g = "", v = !1, m = 0, b = p.length;
    p[0].type === "separator" && (h += "top ", m = 1), p[p.length - 1].type === "separator" && (h += "bottom ", b -= 1);
    for (var y = m; y < b; y++)
      p[y].type === "align" ? (d += sme[p[y].align], v && (g += "none "), v = !0) : p[y].type === "separator" && v && (g += p[y].separator === "|" ? "solid " : "dashed ", v = !1);
    c.setAttribute("columnalign", d.trim()), /[sd]/.test(g) && c.setAttribute("columnlines", g.trim());
  }
  if (e.colSeparationType === "align") {
    for (var x = e.cols || [], E = "", S = 1; S < x.length; S++)
      E += S % 2 ? "0em " : "1em ";
    c.setAttribute("columnspacing", E.trim());
  } else e.colSeparationType === "alignat" || e.colSeparationType === "gather" ? c.setAttribute("columnspacing", "0em") : e.colSeparationType === "small" ? c.setAttribute("columnspacing", "0.2778em") : e.colSeparationType === "CD" ? c.setAttribute("columnspacing", "0.5em") : c.setAttribute("columnspacing", "1em");
  var w = "", C = e.hLinesBeforeRow;
  h += C[0].length > 0 ? "left " : "", h += C[C.length - 1].length > 0 ? "right " : "";
  for (var k = 1; k < C.length - 1; k++)
    w += C[k].length === 0 ? "none " : C[k][0] ? "dashed " : "solid ";
  return /[sd]/.test(w) && c.setAttribute("rowlines", w.trim()), h !== "" && (c = new Ue.MathNode("menclose", [c]), c.setAttribute("notation", h.trim())), e.arraystretch && e.arraystretch < 1 && (c = new Ue.MathNode("mstyle", [c]), c.setAttribute("scriptlevel", "1")), c;
}, vF = function(e, r) {
  e.envName.indexOf("ed") === -1 && B1(e);
  var n = [], a = e.envName.indexOf("at") > -1 ? "alignat" : "align", i = e.envName === "split", s = fl(e.parser, {
    cols: n,
    addJot: !0,
    autoTag: i ? void 0 : MC(e.envName),
    emptySingleRow: !0,
    colSeparationType: a,
    maxNumCols: i ? 2 : void 0,
    leqno: e.parser.settings.leqno
  }, "display"), o, l = 0, u = {
    type: "ordgroup",
    mode: e.mode,
    body: []
  };
  if (r[0] && r[0].type === "ordgroup") {
    for (var c = "", f = 0; f < r[0].body.length; f++) {
      var h = Bt(r[0].body[f], "textord");
      c += h.text;
    }
    o = Number(c), l = o * 2;
  }
  var d = !l;
  s.body.forEach(function(m) {
    for (var b = 1; b < m.length; b += 2) {
      var y = Bt(m[b], "styling"), x = Bt(y.body[0], "ordgroup");
      x.body.unshift(u);
    }
    if (d)
      l < m.length && (l = m.length);
    else {
      var E = m.length / 2;
      if (o < E)
        throw new Ve("Too many math in a row: " + ("expected " + o + ", but got " + E), m[0]);
    }
  });
  for (var p = 0; p < l; ++p) {
    var g = "r", v = 0;
    p % 2 === 1 ? g = "l" : p > 0 && d && (v = 1), n[p] = {
      type: "align",
      align: g,
      pregap: v,
      postgap: 0
    };
  }
  return s.colSeparationType = d ? "align" : "alignat", s;
};
Ts({
  type: "array",
  names: ["array", "darray"],
  props: {
    numArgs: 1
  },
  handler(t, e) {
    var r = D1(e[0]), n = r ? [e[0]] : Bt(e[0], "ordgroup").body, a = n.map(function(s) {
      var o = SC(s), l = o.text;
      if ("lcr".indexOf(l) !== -1)
        return {
          type: "align",
          align: l
        };
      if (l === "|")
        return {
          type: "separator",
          separator: "|"
        };
      if (l === ":")
        return {
          type: "separator",
          separator: ":"
        };
      throw new Ve("Unknown column alignment: " + l, s);
    }), i = {
      cols: a,
      hskipBeforeAndAfter: !0,
      // \@preamble in lttab.dtx
      maxNumCols: a.length
    };
    return fl(t.parser, i, _C(t.envName));
  },
  htmlBuilder: Ss,
  mathmlBuilder: Cs
});
Ts({
  type: "array",
  names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"],
  props: {
    numArgs: 0
  },
  handler(t) {
    var e = {
      matrix: null,
      pmatrix: ["(", ")"],
      bmatrix: ["[", "]"],
      Bmatrix: ["\\{", "\\}"],
      vmatrix: ["|", "|"],
      Vmatrix: ["\\Vert", "\\Vert"]
    }[t.envName.replace("*", "")], r = "c", n = {
      hskipBeforeAndAfter: !1,
      cols: [{
        type: "align",
        align: r
      }]
    };
    if (t.envName.charAt(t.envName.length - 1) === "*") {
      var a = t.parser;
      if (a.consumeSpaces(), a.fetch().text === "[") {
        if (a.consume(), a.consumeSpaces(), r = a.fetch().text, "lcr".indexOf(r) === -1)
          throw new Ve("Expected l or c or r", a.nextToken);
        a.consume(), a.consumeSpaces(), a.expect("]"), a.consume(), n.cols = [{
          type: "align",
          align: r
        }];
      }
    }
    var i = fl(t.parser, n, _C(t.envName)), s = Math.max(0, ...i.body.map((o) => o.length));
    return i.cols = new Array(s).fill({
      type: "align",
      align: r
    }), e ? {
      type: "leftright",
      mode: t.mode,
      body: [i],
      left: e[0],
      right: e[1],
      rightColor: void 0
      // \right uninfluenced by \color in array
    } : i;
  },
  htmlBuilder: Ss,
  mathmlBuilder: Cs
});
Ts({
  type: "array",
  names: ["smallmatrix"],
  props: {
    numArgs: 0
  },
  handler(t) {
    var e = {
      arraystretch: 0.5
    }, r = fl(t.parser, e, "script");
    return r.colSeparationType = "small", r;
  },
  htmlBuilder: Ss,
  mathmlBuilder: Cs
});
Ts({
  type: "array",
  names: ["subarray"],
  props: {
    numArgs: 1
  },
  handler(t, e) {
    var r = D1(e[0]), n = r ? [e[0]] : Bt(e[0], "ordgroup").body, a = n.map(function(s) {
      var o = SC(s), l = o.text;
      if ("lc".indexOf(l) !== -1)
        return {
          type: "align",
          align: l
        };
      throw new Ve("Unknown column alignment: " + l, s);
    });
    if (a.length > 1)
      throw new Ve("{subarray} can contain only one column");
    var i = {
      cols: a,
      hskipBeforeAndAfter: !1,
      arraystretch: 0.5
    };
    if (i = fl(t.parser, i, "script"), i.body.length > 0 && i.body[0].length > 1)
      throw new Ve("{subarray} can contain only one column");
    return i;
  },
  htmlBuilder: Ss,
  mathmlBuilder: Cs
});
Ts({
  type: "array",
  names: ["cases", "dcases", "rcases", "drcases"],
  props: {
    numArgs: 0
  },
  handler(t) {
    var e = {
      arraystretch: 1.2,
      cols: [{
        type: "align",
        align: "l",
        pregap: 0,
        // TODO(kevinb) get the current style.
        // For now we use the metrics for TEXT style which is what we were
        // doing before.  Before attempting to get the current style we
        // should look at TeX's behavior especially for \over and matrices.
        postgap: 1
        /* 1em quad */
      }, {
        type: "align",
        align: "l",
        pregap: 0,
        postgap: 0
      }]
    }, r = fl(t.parser, e, _C(t.envName));
    return {
      type: "leftright",
      mode: t.mode,
      body: [r],
      left: t.envName.indexOf("r") > -1 ? "." : "\\{",
      right: t.envName.indexOf("r") > -1 ? "\\}" : ".",
      rightColor: void 0
    };
  },
  htmlBuilder: Ss,
  mathmlBuilder: Cs
});
Ts({
  type: "array",
  names: ["align", "align*", "aligned", "split"],
  props: {
    numArgs: 0
  },
  handler: vF,
  htmlBuilder: Ss,
  mathmlBuilder: Cs
});
Ts({
  type: "array",
  names: ["gathered", "gather", "gather*"],
  props: {
    numArgs: 0
  },
  handler(t) {
    ["gather", "gather*"].includes(t.envName) && B1(t);
    var e = {
      cols: [{
        type: "align",
        align: "c"
      }],
      addJot: !0,
      colSeparationType: "gather",
      autoTag: MC(t.envName),
      emptySingleRow: !0,
      leqno: t.parser.settings.leqno
    };
    return fl(t.parser, e, "display");
  },
  htmlBuilder: Ss,
  mathmlBuilder: Cs
});
Ts({
  type: "array",
  names: ["alignat", "alignat*", "alignedat"],
  props: {
    numArgs: 1
  },
  handler: vF,
  htmlBuilder: Ss,
  mathmlBuilder: Cs
});
Ts({
  type: "array",
  names: ["equation", "equation*"],
  props: {
    numArgs: 0
  },
  handler(t) {
    B1(t);
    var e = {
      autoTag: MC(t.envName),
      emptySingleRow: !0,
      singleRow: !0,
      maxNumCols: 1,
      leqno: t.parser.settings.leqno
    };
    return fl(t.parser, e, "display");
  },
  htmlBuilder: Ss,
  mathmlBuilder: Cs
});
Ts({
  type: "array",
  names: ["CD"],
  props: {
    numArgs: 0
  },
  handler(t) {
    return B1(t), Wve(t.parser);
  },
  htmlBuilder: Ss,
  mathmlBuilder: Cs
});
Y("\\nonumber", "\\gdef\\@eqnsw{0}");
Y("\\notag", "\\nonumber");
it({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\hline", "\\hdashline"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInMath: !0
  },
  handler(t, e) {
    throw new Ve(t.funcName + " valid only within array environment");
  }
});
var h7 = pF;
it({
  type: "environment",
  names: ["\\begin", "\\end"],
  props: {
    numArgs: 1,
    argTypes: ["text"]
  },
  handler(t, e) {
    var {
      parser: r,
      funcName: n
    } = t, a = e[0];
    if (a.type !== "ordgroup")
      throw new Ve("Invalid environment name", a);
    for (var i = "", s = 0; s < a.body.length; ++s)
      i += Bt(a.body[s], "textord").text;
    if (n === "\\begin") {
      if (!h7.hasOwnProperty(i))
        throw new Ve("No such environment: " + i, a);
      var o = h7[i], {
        args: l,
        optArgs: u
      } = r.parseArguments("\\begin{" + i + "}", o), c = {
        mode: r.mode,
        envName: i,
        parser: r
      }, f = o.handler(c, l, u);
      r.expect("\\end", !1);
      var h = r.nextToken, d = Bt(r.parseFunction(), "environment");
      if (d.name !== i)
        throw new Ve("Mismatch: \\begin{" + i + "} matched by \\end{" + d.name + "}", h);
      return f;
    }
    return {
      type: "environment",
      mode: r.mode,
      name: i,
      nameGroup: a
    };
  }
});
var mF = (t, e) => {
  var r = t.font, n = e.withFont(r);
  return er(t.body, n);
}, yF = (t, e) => {
  var r = t.font, n = e.withFont(r);
  return Cr(t.body, n);
}, d7 = {
  "\\Bbb": "\\mathbb",
  "\\bold": "\\mathbf",
  "\\frak": "\\mathfrak",
  "\\bm": "\\boldsymbol"
};
it({
  type: "font",
  names: [
    // styles, except \boldsymbol defined below
    "\\mathrm",
    "\\mathit",
    "\\mathbf",
    "\\mathnormal",
    "\\mathsfit",
    // families
    "\\mathbb",
    "\\mathcal",
    "\\mathfrak",
    "\\mathscr",
    "\\mathsf",
    "\\mathtt",
    // aliases, except \bm defined below
    "\\Bbb",
    "\\bold",
    "\\frak"
  ],
  props: {
    numArgs: 1,
    allowedInArgument: !0
  },
  handler: (t, e) => {
    var {
      parser: r,
      funcName: n
    } = t, a = Om(e[0]), i = n;
    return i in d7 && (i = d7[i]), {
      type: "font",
      mode: r.mode,
      font: i.slice(1),
      body: a
    };
  },
  htmlBuilder: mF,
  mathmlBuilder: yF
});
it({
  type: "mclass",
  names: ["\\boldsymbol", "\\bm"],
  props: {
    numArgs: 1
  },
  handler: (t, e) => {
    var {
      parser: r
    } = t, n = e[0], a = rr.isCharacterBox(n);
    return {
      type: "mclass",
      mode: r.mode,
      mclass: $1(n),
      body: [{
        type: "font",
        mode: r.mode,
        font: "boldsymbol",
        body: n
      }],
      isCharacterBox: a
    };
  }
});
it({
  type: "font",
  names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler: (t, e) => {
    var {
      parser: r,
      funcName: n,
      breakOnTokenText: a
    } = t, {
      mode: i
    } = r, s = r.parseExpression(!0, a), o = "math" + n.slice(1);
    return {
      type: "font",
      mode: i,
      font: o,
      body: {
        type: "ordgroup",
        mode: r.mode,
        body: s
      }
    };
  },
  htmlBuilder: mF,
  mathmlBuilder: yF
});
var bF = (t, e) => {
  var r = e;
  return t === "display" ? r = r.id >= Ct.SCRIPT.id ? r.text() : Ct.DISPLAY : t === "text" && r.size === Ct.DISPLAY.size ? r = Ct.TEXT : t === "script" ? r = Ct.SCRIPT : t === "scriptscript" && (r = Ct.SCRIPTSCRIPT), r;
}, LC = (t, e) => {
  var r = bF(t.size, e.style), n = r.fracNum(), a = r.fracDen(), i;
  i = e.havingStyle(n);
  var s = er(t.numer, i, e);
  if (t.continued) {
    var o = 8.5 / e.fontMetrics().ptPerEm, l = 3.5 / e.fontMetrics().ptPerEm;
    s.height = s.height < o ? o : s.height, s.depth = s.depth < l ? l : s.depth;
  }
  i = e.havingStyle(a);
  var u = er(t.denom, i, e), c, f, h;
  t.hasBarLine ? (t.barSize ? (f = Ur(t.barSize, e), c = ye.makeLineSpan("frac-line", e, f)) : c = ye.makeLineSpan("frac-line", e), f = c.height, h = c.height) : (c = null, f = 0, h = e.fontMetrics().defaultRuleThickness);
  var d, p, g;
  r.size === Ct.DISPLAY.size || t.size === "display" ? (d = e.fontMetrics().num1, f > 0 ? p = 3 * h : p = 7 * h, g = e.fontMetrics().denom1) : (f > 0 ? (d = e.fontMetrics().num2, p = h) : (d = e.fontMetrics().num3, p = 3 * h), g = e.fontMetrics().denom2);
  var v;
  if (c) {
    var b = e.fontMetrics().axisHeight;
    d - s.depth - (b + 0.5 * f) < p && (d += p - (d - s.depth - (b + 0.5 * f))), b - 0.5 * f - (u.height - g) < p && (g += p - (b - 0.5 * f - (u.height - g)));
    var y = -(b - 0.5 * f);
    v = ye.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: u,
        shift: g
      }, {
        type: "elem",
        elem: c,
        shift: y
      }, {
        type: "elem",
        elem: s,
        shift: -d
      }]
    }, e);
  } else {
    var m = d - s.depth - (u.height - g);
    m < p && (d += 0.5 * (p - m), g += 0.5 * (p - m)), v = ye.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: u,
        shift: g
      }, {
        type: "elem",
        elem: s,
        shift: -d
      }]
    }, e);
  }
  i = e.havingStyle(r), v.height *= i.sizeMultiplier / e.sizeMultiplier, v.depth *= i.sizeMultiplier / e.sizeMultiplier;
  var x;
  r.size === Ct.DISPLAY.size ? x = e.fontMetrics().delim1 : r.size === Ct.SCRIPTSCRIPT.size ? x = e.havingStyle(Ct.SCRIPT).fontMetrics().delim2 : x = e.fontMetrics().delim2;
  var E, S;
  return t.leftDelim == null ? E = n0(e, ["mopen"]) : E = Qs.customSizedDelim(t.leftDelim, x, !0, e.havingStyle(r), t.mode, ["mopen"]), t.continued ? S = ye.makeSpan([]) : t.rightDelim == null ? S = n0(e, ["mclose"]) : S = Qs.customSizedDelim(t.rightDelim, x, !0, e.havingStyle(r), t.mode, ["mclose"]), ye.makeSpan(["mord"].concat(i.sizingClasses(e)), [E, ye.makeSpan(["mfrac"], [v]), S], e);
}, NC = (t, e) => {
  var r = new Ue.MathNode("mfrac", [Cr(t.numer, e), Cr(t.denom, e)]);
  if (!t.hasBarLine)
    r.setAttribute("linethickness", "0px");
  else if (t.barSize) {
    var n = Ur(t.barSize, e);
    r.setAttribute("linethickness", Qe(n));
  }
  var a = bF(t.size, e.style);
  if (a.size !== e.style.size) {
    r = new Ue.MathNode("mstyle", [r]);
    var i = a.size === Ct.DISPLAY.size ? "true" : "false";
    r.setAttribute("displaystyle", i), r.setAttribute("scriptlevel", "0");
  }
  if (t.leftDelim != null || t.rightDelim != null) {
    var s = [];
    if (t.leftDelim != null) {
      var o = new Ue.MathNode("mo", [new Ue.TextNode(t.leftDelim.replace("\\", ""))]);
      o.setAttribute("fence", "true"), s.push(o);
    }
    if (s.push(r), t.rightDelim != null) {
      var l = new Ue.MathNode("mo", [new Ue.TextNode(t.rightDelim.replace("\\", ""))]);
      l.setAttribute("fence", "true"), s.push(l);
    }
    return EC(s);
  }
  return r;
};
it({
  type: "genfrac",
  names: [
    "\\dfrac",
    "\\frac",
    "\\tfrac",
    "\\dbinom",
    "\\binom",
    "\\tbinom",
    "\\\\atopfrac",
    // can’t be entered directly
    "\\\\bracefrac",
    "\\\\brackfrac"
    // ditto
  ],
  props: {
    numArgs: 2,
    allowedInArgument: !0
  },
  handler: (t, e) => {
    var {
      parser: r,
      funcName: n
    } = t, a = e[0], i = e[1], s, o = null, l = null, u = "auto";
    switch (n) {
      case "\\dfrac":
      case "\\frac":
      case "\\tfrac":
        s = !0;
        break;
      case "\\\\atopfrac":
        s = !1;
        break;
      case "\\dbinom":
      case "\\binom":
      case "\\tbinom":
        s = !1, o = "(", l = ")";
        break;
      case "\\\\bracefrac":
        s = !1, o = "\\{", l = "\\}";
        break;
      case "\\\\brackfrac":
        s = !1, o = "[", l = "]";
        break;
      default:
        throw new Error("Unrecognized genfrac command");
    }
    switch (n) {
      case "\\dfrac":
      case "\\dbinom":
        u = "display";
        break;
      case "\\tfrac":
      case "\\tbinom":
        u = "text";
        break;
    }
    return {
      type: "genfrac",
      mode: r.mode,
      continued: !1,
      numer: a,
      denom: i,
      hasBarLine: s,
      leftDelim: o,
      rightDelim: l,
      size: u,
      barSize: null
    };
  },
  htmlBuilder: LC,
  mathmlBuilder: NC
});
it({
  type: "genfrac",
  names: ["\\cfrac"],
  props: {
    numArgs: 2
  },
  handler: (t, e) => {
    var {
      parser: r,
      funcName: n
    } = t, a = e[0], i = e[1];
    return {
      type: "genfrac",
      mode: r.mode,
      continued: !0,
      numer: a,
      denom: i,
      hasBarLine: !0,
      leftDelim: null,
      rightDelim: null,
      size: "display",
      barSize: null
    };
  }
});
it({
  type: "infix",
  names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
  props: {
    numArgs: 0,
    infix: !0
  },
  handler(t) {
    var {
      parser: e,
      funcName: r,
      token: n
    } = t, a;
    switch (r) {
      case "\\over":
        a = "\\frac";
        break;
      case "\\choose":
        a = "\\binom";
        break;
      case "\\atop":
        a = "\\\\atopfrac";
        break;
      case "\\brace":
        a = "\\\\bracefrac";
        break;
      case "\\brack":
        a = "\\\\brackfrac";
        break;
      default:
        throw new Error("Unrecognized infix genfrac command");
    }
    return {
      type: "infix",
      mode: e.mode,
      replaceWith: a,
      token: n
    };
  }
});
var p7 = ["display", "text", "script", "scriptscript"], g7 = function(e) {
  var r = null;
  return e.length > 0 && (r = e, r = r === "." ? null : r), r;
};
it({
  type: "genfrac",
  names: ["\\genfrac"],
  props: {
    numArgs: 6,
    allowedInArgument: !0,
    argTypes: ["math", "math", "size", "text", "math", "math"]
  },
  handler(t, e) {
    var {
      parser: r
    } = t, n = e[4], a = e[5], i = Om(e[0]), s = i.type === "atom" && i.family === "open" ? g7(i.text) : null, o = Om(e[1]), l = o.type === "atom" && o.family === "close" ? g7(o.text) : null, u = Bt(e[2], "size"), c, f = null;
    u.isBlank ? c = !0 : (f = u.value, c = f.number > 0);
    var h = "auto", d = e[3];
    if (d.type === "ordgroup") {
      if (d.body.length > 0) {
        var p = Bt(d.body[0], "textord");
        h = p7[Number(p.text)];
      }
    } else
      d = Bt(d, "textord"), h = p7[Number(d.text)];
    return {
      type: "genfrac",
      mode: r.mode,
      numer: n,
      denom: a,
      continued: !1,
      hasBarLine: c,
      barSize: f,
      leftDelim: s,
      rightDelim: l,
      size: h
    };
  },
  htmlBuilder: LC,
  mathmlBuilder: NC
});
it({
  type: "infix",
  names: ["\\above"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    infix: !0
  },
  handler(t, e) {
    var {
      parser: r,
      funcName: n,
      token: a
    } = t;
    return {
      type: "infix",
      mode: r.mode,
      replaceWith: "\\\\abovefrac",
      size: Bt(e[0], "size").value,
      token: a
    };
  }
});
it({
  type: "genfrac",
  names: ["\\\\abovefrac"],
  props: {
    numArgs: 3,
    argTypes: ["math", "size", "math"]
  },
  handler: (t, e) => {
    var {
      parser: r,
      funcName: n
    } = t, a = e[0], i = $ge(Bt(e[1], "infix").size), s = e[2], o = i.number > 0;
    return {
      type: "genfrac",
      mode: r.mode,
      numer: a,
      denom: s,
      continued: !1,
      hasBarLine: o,
      barSize: i,
      leftDelim: null,
      rightDelim: null,
      size: "auto"
    };
  },
  htmlBuilder: LC,
  mathmlBuilder: NC
});
var xF = (t, e) => {
  var r = e.style, n, a;
  t.type === "supsub" ? (n = t.sup ? er(t.sup, e.havingStyle(r.sup()), e) : er(t.sub, e.havingStyle(r.sub()), e), a = Bt(t.base, "horizBrace")) : a = Bt(t, "horizBrace");
  var i = er(a.base, e.havingBaseStyle(Ct.DISPLAY)), s = so.svgSpan(a, e), o;
  if (a.isOver ? (o = ye.makeVList({
    positionType: "firstBaseline",
    children: [{
      type: "elem",
      elem: i
    }, {
      type: "kern",
      size: 0.1
    }, {
      type: "elem",
      elem: s
    }]
  }, e), o.children[0].children[0].children[1].classes.push("svg-align")) : (o = ye.makeVList({
    positionType: "bottom",
    positionData: i.depth + 0.1 + s.height,
    children: [{
      type: "elem",
      elem: s
    }, {
      type: "kern",
      size: 0.1
    }, {
      type: "elem",
      elem: i
    }]
  }, e), o.children[0].children[0].children[0].classes.push("svg-align")), n) {
    var l = ye.makeSpan(["mord", a.isOver ? "mover" : "munder"], [o], e);
    a.isOver ? o = ye.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: l
      }, {
        type: "kern",
        size: 0.2
      }, {
        type: "elem",
        elem: n
      }]
    }, e) : o = ye.makeVList({
      positionType: "bottom",
      positionData: l.depth + 0.2 + n.height + n.depth,
      children: [{
        type: "elem",
        elem: n
      }, {
        type: "kern",
        size: 0.2
      }, {
        type: "elem",
        elem: l
      }]
    }, e);
  }
  return ye.makeSpan(["mord", a.isOver ? "mover" : "munder"], [o], e);
}, ome = (t, e) => {
  var r = so.mathMLnode(t.label);
  return new Ue.MathNode(t.isOver ? "mover" : "munder", [Cr(t.base, e), r]);
};
it({
  type: "horizBrace",
  names: ["\\overbrace", "\\underbrace"],
  props: {
    numArgs: 1
  },
  handler(t, e) {
    var {
      parser: r,
      funcName: n
    } = t;
    return {
      type: "horizBrace",
      mode: r.mode,
      label: n,
      isOver: /^\\over/.test(n),
      base: e[0]
    };
  },
  htmlBuilder: xF,
  mathmlBuilder: ome
});
it({
  type: "href",
  names: ["\\href"],
  props: {
    numArgs: 2,
    argTypes: ["url", "original"],
    allowedInText: !0
  },
  handler: (t, e) => {
    var {
      parser: r
    } = t, n = e[1], a = Bt(e[0], "url").url;
    return r.settings.isTrusted({
      command: "\\href",
      url: a
    }) ? {
      type: "href",
      mode: r.mode,
      href: a,
      body: nn(n)
    } : r.formatUnsupportedCmd("\\href");
  },
  htmlBuilder: (t, e) => {
    var r = bn(t.body, e, !1);
    return ye.makeAnchor(t.href, [], r, e);
  },
  mathmlBuilder: (t, e) => {
    var r = Wo(t.body, e);
    return r instanceof Za || (r = new Za("mrow", [r])), r.setAttribute("href", t.href), r;
  }
});
it({
  type: "href",
  names: ["\\url"],
  props: {
    numArgs: 1,
    argTypes: ["url"],
    allowedInText: !0
  },
  handler: (t, e) => {
    var {
      parser: r
    } = t, n = Bt(e[0], "url").url;
    if (!r.settings.isTrusted({
      command: "\\url",
      url: n
    }))
      return r.formatUnsupportedCmd("\\url");
    for (var a = [], i = 0; i < n.length; i++) {
      var s = n[i];
      s === "~" && (s = "\\textasciitilde"), a.push({
        type: "textord",
        mode: "text",
        text: s
      });
    }
    var o = {
      type: "text",
      mode: r.mode,
      font: "\\texttt",
      body: a
    };
    return {
      type: "href",
      mode: r.mode,
      href: n,
      body: nn(o)
    };
  }
});
it({
  type: "hbox",
  names: ["\\hbox"],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInText: !0,
    primitive: !0
  },
  handler(t, e) {
    var {
      parser: r
    } = t;
    return {
      type: "hbox",
      mode: r.mode,
      body: nn(e[0])
    };
  },
  htmlBuilder(t, e) {
    var r = bn(t.body, e, !1);
    return ye.makeFragment(r);
  },
  mathmlBuilder(t, e) {
    return new Ue.MathNode("mrow", Oa(t.body, e));
  }
});
it({
  type: "html",
  names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
  props: {
    numArgs: 2,
    argTypes: ["raw", "original"],
    allowedInText: !0
  },
  handler: (t, e) => {
    var {
      parser: r,
      funcName: n,
      token: a
    } = t, i = Bt(e[0], "raw").string, s = e[1];
    r.settings.strict && r.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
    var o, l = {};
    switch (n) {
      case "\\htmlClass":
        l.class = i, o = {
          command: "\\htmlClass",
          class: i
        };
        break;
      case "\\htmlId":
        l.id = i, o = {
          command: "\\htmlId",
          id: i
        };
        break;
      case "\\htmlStyle":
        l.style = i, o = {
          command: "\\htmlStyle",
          style: i
        };
        break;
      case "\\htmlData": {
        for (var u = i.split(","), c = 0; c < u.length; c++) {
          var f = u[c].split("=");
          if (f.length !== 2)
            throw new Ve("Error parsing key-value for \\htmlData");
          l["data-" + f[0].trim()] = f[1].trim();
        }
        o = {
          command: "\\htmlData",
          attributes: l
        };
        break;
      }
      default:
        throw new Error("Unrecognized html command");
    }
    return r.settings.isTrusted(o) ? {
      type: "html",
      mode: r.mode,
      attributes: l,
      body: nn(s)
    } : r.formatUnsupportedCmd(n);
  },
  htmlBuilder: (t, e) => {
    var r = bn(t.body, e, !1), n = ["enclosing"];
    t.attributes.class && n.push(...t.attributes.class.trim().split(/\s+/));
    var a = ye.makeSpan(n, r, e);
    for (var i in t.attributes)
      i !== "class" && t.attributes.hasOwnProperty(i) && a.setAttribute(i, t.attributes[i]);
    return a;
  },
  mathmlBuilder: (t, e) => Wo(t.body, e)
});
it({
  type: "htmlmathml",
  names: ["\\html@mathml"],
  props: {
    numArgs: 2,
    allowedInText: !0
  },
  handler: (t, e) => {
    var {
      parser: r
    } = t;
    return {
      type: "htmlmathml",
      mode: r.mode,
      html: nn(e[0]),
      mathml: nn(e[1])
    };
  },
  htmlBuilder: (t, e) => {
    var r = bn(t.html, e, !1);
    return ye.makeFragment(r);
  },
  mathmlBuilder: (t, e) => Wo(t.mathml, e)
});
var Vx = function(e) {
  if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(e))
    return {
      number: +e,
      unit: "bp"
    };
  var r = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(e);
  if (!r)
    throw new Ve("Invalid size: '" + e + "' in \\includegraphics");
  var n = {
    number: +(r[1] + r[2]),
    // sign + magnitude, cast to number
    unit: r[3]
  };
  if (!B$(n))
    throw new Ve("Invalid unit: '" + n.unit + "' in \\includegraphics.");
  return n;
};
it({
  type: "includegraphics",
  names: ["\\includegraphics"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    argTypes: ["raw", "url"],
    allowedInText: !1
  },
  handler: (t, e, r) => {
    var {
      parser: n
    } = t, a = {
      number: 0,
      unit: "em"
    }, i = {
      number: 0.9,
      unit: "em"
    }, s = {
      number: 0,
      unit: "em"
    }, o = "";
    if (r[0])
      for (var l = Bt(r[0], "raw").string, u = l.split(","), c = 0; c < u.length; c++) {
        var f = u[c].split("=");
        if (f.length === 2) {
          var h = f[1].trim();
          switch (f[0].trim()) {
            case "alt":
              o = h;
              break;
            case "width":
              a = Vx(h);
              break;
            case "height":
              i = Vx(h);
              break;
            case "totalheight":
              s = Vx(h);
              break;
            default:
              throw new Ve("Invalid key: '" + f[0] + "' in \\includegraphics.");
          }
        }
      }
    var d = Bt(e[0], "url").url;
    return o === "" && (o = d, o = o.replace(/^.*[\\/]/, ""), o = o.substring(0, o.lastIndexOf("."))), n.settings.isTrusted({
      command: "\\includegraphics",
      url: d
    }) ? {
      type: "includegraphics",
      mode: n.mode,
      alt: o,
      width: a,
      height: i,
      totalheight: s,
      src: d
    } : n.formatUnsupportedCmd("\\includegraphics");
  },
  htmlBuilder: (t, e) => {
    var r = Ur(t.height, e), n = 0;
    t.totalheight.number > 0 && (n = Ur(t.totalheight, e) - r);
    var a = 0;
    t.width.number > 0 && (a = Ur(t.width, e));
    var i = {
      height: Qe(r + n)
    };
    a > 0 && (i.width = Qe(a)), n > 0 && (i.verticalAlign = Qe(-n));
    var s = new ove(t.src, t.alt, i);
    return s.height = r, s.depth = n, s;
  },
  mathmlBuilder: (t, e) => {
    var r = new Ue.MathNode("mglyph", []);
    r.setAttribute("alt", t.alt);
    var n = Ur(t.height, e), a = 0;
    if (t.totalheight.number > 0 && (a = Ur(t.totalheight, e) - n, r.setAttribute("valign", Qe(-a))), r.setAttribute("height", Qe(n + a)), t.width.number > 0) {
      var i = Ur(t.width, e);
      r.setAttribute("width", Qe(i));
    }
    return r.setAttribute("src", t.src), r;
  }
});
it({
  type: "kern",
  names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    primitive: !0,
    allowedInText: !0
  },
  handler(t, e) {
    var {
      parser: r,
      funcName: n
    } = t, a = Bt(e[0], "size");
    if (r.settings.strict) {
      var i = n[1] === "m", s = a.value.unit === "mu";
      i ? (s || r.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + n + " supports only mu units, " + ("not " + a.value.unit + " units")), r.mode !== "math" && r.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + n + " works only in math mode")) : s && r.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + n + " doesn't support mu units");
    }
    return {
      type: "kern",
      mode: r.mode,
      dimension: a.value
    };
  },
  htmlBuilder(t, e) {
    return ye.makeGlue(t.dimension, e);
  },
  mathmlBuilder(t, e) {
    var r = Ur(t.dimension, e);
    return new Ue.SpaceNode(r);
  }
});
it({
  type: "lap",
  names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (t, e) => {
    var {
      parser: r,
      funcName: n
    } = t, a = e[0];
    return {
      type: "lap",
      mode: r.mode,
      alignment: n.slice(5),
      body: a
    };
  },
  htmlBuilder: (t, e) => {
    var r;
    t.alignment === "clap" ? (r = ye.makeSpan([], [er(t.body, e)]), r = ye.makeSpan(["inner"], [r], e)) : r = ye.makeSpan(["inner"], [er(t.body, e)]);
    var n = ye.makeSpan(["fix"], []), a = ye.makeSpan([t.alignment], [r, n], e), i = ye.makeSpan(["strut"]);
    return i.style.height = Qe(a.height + a.depth), a.depth && (i.style.verticalAlign = Qe(-a.depth)), a.children.unshift(i), a = ye.makeSpan(["thinbox"], [a], e), ye.makeSpan(["mord", "vbox"], [a], e);
  },
  mathmlBuilder: (t, e) => {
    var r = new Ue.MathNode("mpadded", [Cr(t.body, e)]);
    if (t.alignment !== "rlap") {
      var n = t.alignment === "llap" ? "-1" : "-0.5";
      r.setAttribute("lspace", n + "width");
    }
    return r.setAttribute("width", "0px"), r;
  }
});
it({
  type: "styling",
  names: ["\\(", "$"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInMath: !1
  },
  handler(t, e) {
    var {
      funcName: r,
      parser: n
    } = t, a = n.mode;
    n.switchMode("math");
    var i = r === "\\(" ? "\\)" : "$", s = n.parseExpression(!1, i);
    return n.expect(i), n.switchMode(a), {
      type: "styling",
      mode: n.mode,
      style: "text",
      body: s
    };
  }
});
it({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\)", "\\]"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInMath: !1
  },
  handler(t, e) {
    throw new Ve("Mismatched " + t.funcName);
  }
});
var v7 = (t, e) => {
  switch (e.style.size) {
    case Ct.DISPLAY.size:
      return t.display;
    case Ct.TEXT.size:
      return t.text;
    case Ct.SCRIPT.size:
      return t.script;
    case Ct.SCRIPTSCRIPT.size:
      return t.scriptscript;
    default:
      return t.text;
  }
};
it({
  type: "mathchoice",
  names: ["\\mathchoice"],
  props: {
    numArgs: 4,
    primitive: !0
  },
  handler: (t, e) => {
    var {
      parser: r
    } = t;
    return {
      type: "mathchoice",
      mode: r.mode,
      display: nn(e[0]),
      text: nn(e[1]),
      script: nn(e[2]),
      scriptscript: nn(e[3])
    };
  },
  htmlBuilder: (t, e) => {
    var r = v7(t, e), n = bn(r, e, !1);
    return ye.makeFragment(n);
  },
  mathmlBuilder: (t, e) => {
    var r = v7(t, e);
    return Wo(r, e);
  }
});
var wF = (t, e, r, n, a, i, s) => {
  t = ye.makeSpan([], [t]);
  var o = r && rr.isCharacterBox(r), l, u;
  if (e) {
    var c = er(e, n.havingStyle(a.sup()), n);
    u = {
      elem: c,
      kern: Math.max(n.fontMetrics().bigOpSpacing1, n.fontMetrics().bigOpSpacing3 - c.depth)
    };
  }
  if (r) {
    var f = er(r, n.havingStyle(a.sub()), n);
    l = {
      elem: f,
      kern: Math.max(n.fontMetrics().bigOpSpacing2, n.fontMetrics().bigOpSpacing4 - f.height)
    };
  }
  var h;
  if (u && l) {
    var d = n.fontMetrics().bigOpSpacing5 + l.elem.height + l.elem.depth + l.kern + t.depth + s;
    h = ye.makeVList({
      positionType: "bottom",
      positionData: d,
      children: [{
        type: "kern",
        size: n.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: l.elem,
        marginLeft: Qe(-i)
      }, {
        type: "kern",
        size: l.kern
      }, {
        type: "elem",
        elem: t
      }, {
        type: "kern",
        size: u.kern
      }, {
        type: "elem",
        elem: u.elem,
        marginLeft: Qe(i)
      }, {
        type: "kern",
        size: n.fontMetrics().bigOpSpacing5
      }]
    }, n);
  } else if (l) {
    var p = t.height - s;
    h = ye.makeVList({
      positionType: "top",
      positionData: p,
      children: [{
        type: "kern",
        size: n.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: l.elem,
        marginLeft: Qe(-i)
      }, {
        type: "kern",
        size: l.kern
      }, {
        type: "elem",
        elem: t
      }]
    }, n);
  } else if (u) {
    var g = t.depth + s;
    h = ye.makeVList({
      positionType: "bottom",
      positionData: g,
      children: [{
        type: "elem",
        elem: t
      }, {
        type: "kern",
        size: u.kern
      }, {
        type: "elem",
        elem: u.elem,
        marginLeft: Qe(i)
      }, {
        type: "kern",
        size: n.fontMetrics().bigOpSpacing5
      }]
    }, n);
  } else
    return t;
  var v = [h];
  if (l && i !== 0 && !o) {
    var m = ye.makeSpan(["mspace"], [], n);
    m.style.marginRight = Qe(i), v.unshift(m);
  }
  return ye.makeSpan(["mop", "op-limits"], v, n);
}, EF = ["\\smallint"], kf = (t, e) => {
  var r, n, a = !1, i;
  t.type === "supsub" ? (r = t.sup, n = t.sub, i = Bt(t.base, "op"), a = !0) : i = Bt(t, "op");
  var s = e.style, o = !1;
  s.size === Ct.DISPLAY.size && i.symbol && !EF.includes(i.name) && (o = !0);
  var l;
  if (i.symbol) {
    var u = o ? "Size2-Regular" : "Size1-Regular", c = "";
    if ((i.name === "\\oiint" || i.name === "\\oiiint") && (c = i.name.slice(1), i.name = c === "oiint" ? "\\iint" : "\\iiint"), l = ye.makeSymbol(i.name, u, "math", e, ["mop", "op-symbol", o ? "large-op" : "small-op"]), c.length > 0) {
      var f = l.italic, h = ye.staticSvg(c + "Size" + (o ? "2" : "1"), e);
      l = ye.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: l,
          shift: 0
        }, {
          type: "elem",
          elem: h,
          shift: o ? 0.08 : 0
        }]
      }, e), i.name = "\\" + c, l.classes.unshift("mop"), l.italic = f;
    }
  } else if (i.body) {
    var d = bn(i.body, e, !0);
    d.length === 1 && d[0] instanceof Ei ? (l = d[0], l.classes[0] = "mop") : l = ye.makeSpan(["mop"], d, e);
  } else {
    for (var p = [], g = 1; g < i.name.length; g++)
      p.push(ye.mathsym(i.name[g], i.mode, e));
    l = ye.makeSpan(["mop"], p, e);
  }
  var v = 0, m = 0;
  return (l instanceof Ei || i.name === "\\oiint" || i.name === "\\oiiint") && !i.suppressBaseShift && (v = (l.height - l.depth) / 2 - e.fontMetrics().axisHeight, m = l.italic), a ? wF(l, r, n, e, s, m, v) : (v && (l.style.position = "relative", l.style.top = Qe(v)), l);
}, rp = (t, e) => {
  var r;
  if (t.symbol)
    r = new Za("mo", [Ti(t.name, t.mode)]), EF.includes(t.name) && r.setAttribute("largeop", "false");
  else if (t.body)
    r = new Za("mo", Oa(t.body, e));
  else {
    r = new Za("mi", [new hs(t.name.slice(1))]);
    var n = new Za("mo", [Ti("⁡", "text")]);
    t.parentIsSupSub ? r = new Za("mrow", [r, n]) : r = K$([r, n]);
  }
  return r;
}, lme = {
  "∏": "\\prod",
  "∐": "\\coprod",
  "∑": "\\sum",
  "⋀": "\\bigwedge",
  "⋁": "\\bigvee",
  "⋂": "\\bigcap",
  "⋃": "\\bigcup",
  "⨀": "\\bigodot",
  "⨁": "\\bigoplus",
  "⨂": "\\bigotimes",
  "⨄": "\\biguplus",
  "⨆": "\\bigsqcup"
};
it({
  type: "op",
  names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "∏", "∐", "∑", "⋀", "⋁", "⋂", "⋃", "⨀", "⨁", "⨂", "⨄", "⨆"],
  props: {
    numArgs: 0
  },
  handler: (t, e) => {
    var {
      parser: r,
      funcName: n
    } = t, a = n;
    return a.length === 1 && (a = lme[a]), {
      type: "op",
      mode: r.mode,
      limits: !0,
      parentIsSupSub: !1,
      symbol: !0,
      name: a
    };
  },
  htmlBuilder: kf,
  mathmlBuilder: rp
});
it({
  type: "op",
  names: ["\\mathop"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (t, e) => {
    var {
      parser: r
    } = t, n = e[0];
    return {
      type: "op",
      mode: r.mode,
      limits: !1,
      parentIsSupSub: !1,
      symbol: !1,
      body: nn(n)
    };
  },
  htmlBuilder: kf,
  mathmlBuilder: rp
});
var ume = {
  "∫": "\\int",
  "∬": "\\iint",
  "∭": "\\iiint",
  "∮": "\\oint",
  "∯": "\\oiint",
  "∰": "\\oiiint"
};
it({
  type: "op",
  names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
  props: {
    numArgs: 0
  },
  handler(t) {
    var {
      parser: e,
      funcName: r
    } = t;
    return {
      type: "op",
      mode: e.mode,
      limits: !1,
      parentIsSupSub: !1,
      symbol: !1,
      name: r
    };
  },
  htmlBuilder: kf,
  mathmlBuilder: rp
});
it({
  type: "op",
  names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
  props: {
    numArgs: 0
  },
  handler(t) {
    var {
      parser: e,
      funcName: r
    } = t;
    return {
      type: "op",
      mode: e.mode,
      limits: !0,
      parentIsSupSub: !1,
      symbol: !1,
      name: r
    };
  },
  htmlBuilder: kf,
  mathmlBuilder: rp
});
it({
  type: "op",
  names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "∫", "∬", "∭", "∮", "∯", "∰"],
  props: {
    numArgs: 0
  },
  handler(t) {
    var {
      parser: e,
      funcName: r
    } = t, n = r;
    return n.length === 1 && (n = ume[n]), {
      type: "op",
      mode: e.mode,
      limits: !1,
      parentIsSupSub: !1,
      symbol: !0,
      name: n
    };
  },
  htmlBuilder: kf,
  mathmlBuilder: rp
});
var TF = (t, e) => {
  var r, n, a = !1, i;
  t.type === "supsub" ? (r = t.sup, n = t.sub, i = Bt(t.base, "operatorname"), a = !0) : i = Bt(t, "operatorname");
  var s;
  if (i.body.length > 0) {
    for (var o = i.body.map((f) => {
      var h = f.text;
      return typeof h == "string" ? {
        type: "textord",
        mode: f.mode,
        text: h
      } : f;
    }), l = bn(o, e.withFont("mathrm"), !0), u = 0; u < l.length; u++) {
      var c = l[u];
      c instanceof Ei && (c.text = c.text.replace(/\u2212/, "-").replace(/\u2217/, "*"));
    }
    s = ye.makeSpan(["mop"], l, e);
  } else
    s = ye.makeSpan(["mop"], [], e);
  return a ? wF(s, r, n, e, e.style, 0, 0) : s;
}, cme = (t, e) => {
  for (var r = Oa(t.body, e.withFont("mathrm")), n = !0, a = 0; a < r.length; a++) {
    var i = r[a];
    if (!(i instanceof Ue.SpaceNode)) if (i instanceof Ue.MathNode)
      switch (i.type) {
        case "mi":
        case "mn":
        case "ms":
        case "mspace":
        case "mtext":
          break;
        case "mo": {
          var s = i.children[0];
          i.children.length === 1 && s instanceof Ue.TextNode ? s.text = s.text.replace(/\u2212/, "-").replace(/\u2217/, "*") : n = !1;
          break;
        }
        default:
          n = !1;
      }
    else
      n = !1;
  }
  if (n) {
    var o = r.map((c) => c.toText()).join("");
    r = [new Ue.TextNode(o)];
  }
  var l = new Ue.MathNode("mi", r);
  l.setAttribute("mathvariant", "normal");
  var u = new Ue.MathNode("mo", [Ti("⁡", "text")]);
  return t.parentIsSupSub ? new Ue.MathNode("mrow", [l, u]) : Ue.newDocumentFragment([l, u]);
};
it({
  type: "operatorname",
  names: ["\\operatorname@", "\\operatornamewithlimits"],
  props: {
    numArgs: 1
  },
  handler: (t, e) => {
    var {
      parser: r,
      funcName: n
    } = t, a = e[0];
    return {
      type: "operatorname",
      mode: r.mode,
      body: nn(a),
      alwaysHandleSupSub: n === "\\operatornamewithlimits",
      limits: !1,
      parentIsSupSub: !1
    };
  },
  htmlBuilder: TF,
  mathmlBuilder: cme
});
Y("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@");
ku({
  type: "ordgroup",
  htmlBuilder(t, e) {
    return t.semisimple ? ye.makeFragment(bn(t.body, e, !1)) : ye.makeSpan(["mord"], bn(t.body, e, !0), e);
  },
  mathmlBuilder(t, e) {
    return Wo(t.body, e, !0);
  }
});
it({
  type: "overline",
  names: ["\\overline"],
  props: {
    numArgs: 1
  },
  handler(t, e) {
    var {
      parser: r
    } = t, n = e[0];
    return {
      type: "overline",
      mode: r.mode,
      body: n
    };
  },
  htmlBuilder(t, e) {
    var r = er(t.body, e.havingCrampedStyle()), n = ye.makeLineSpan("overline-line", e), a = e.fontMetrics().defaultRuleThickness, i = ye.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: r
      }, {
        type: "kern",
        size: 3 * a
      }, {
        type: "elem",
        elem: n
      }, {
        type: "kern",
        size: a
      }]
    }, e);
    return ye.makeSpan(["mord", "overline"], [i], e);
  },
  mathmlBuilder(t, e) {
    var r = new Ue.MathNode("mo", [new Ue.TextNode("‾")]);
    r.setAttribute("stretchy", "true");
    var n = new Ue.MathNode("mover", [Cr(t.body, e), r]);
    return n.setAttribute("accent", "true"), n;
  }
});
it({
  type: "phantom",
  names: ["\\phantom"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (t, e) => {
    var {
      parser: r
    } = t, n = e[0];
    return {
      type: "phantom",
      mode: r.mode,
      body: nn(n)
    };
  },
  htmlBuilder: (t, e) => {
    var r = bn(t.body, e.withPhantom(), !1);
    return ye.makeFragment(r);
  },
  mathmlBuilder: (t, e) => {
    var r = Oa(t.body, e);
    return new Ue.MathNode("mphantom", r);
  }
});
it({
  type: "hphantom",
  names: ["\\hphantom"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (t, e) => {
    var {
      parser: r
    } = t, n = e[0];
    return {
      type: "hphantom",
      mode: r.mode,
      body: n
    };
  },
  htmlBuilder: (t, e) => {
    var r = ye.makeSpan([], [er(t.body, e.withPhantom())]);
    if (r.height = 0, r.depth = 0, r.children)
      for (var n = 0; n < r.children.length; n++)
        r.children[n].height = 0, r.children[n].depth = 0;
    return r = ye.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: r
      }]
    }, e), ye.makeSpan(["mord"], [r], e);
  },
  mathmlBuilder: (t, e) => {
    var r = Oa(nn(t.body), e), n = new Ue.MathNode("mphantom", r), a = new Ue.MathNode("mpadded", [n]);
    return a.setAttribute("height", "0px"), a.setAttribute("depth", "0px"), a;
  }
});
it({
  type: "vphantom",
  names: ["\\vphantom"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (t, e) => {
    var {
      parser: r
    } = t, n = e[0];
    return {
      type: "vphantom",
      mode: r.mode,
      body: n
    };
  },
  htmlBuilder: (t, e) => {
    var r = ye.makeSpan(["inner"], [er(t.body, e.withPhantom())]), n = ye.makeSpan(["fix"], []);
    return ye.makeSpan(["mord", "rlap"], [r, n], e);
  },
  mathmlBuilder: (t, e) => {
    var r = Oa(nn(t.body), e), n = new Ue.MathNode("mphantom", r), a = new Ue.MathNode("mpadded", [n]);
    return a.setAttribute("width", "0px"), a;
  }
});
it({
  type: "raisebox",
  names: ["\\raisebox"],
  props: {
    numArgs: 2,
    argTypes: ["size", "hbox"],
    allowedInText: !0
  },
  handler(t, e) {
    var {
      parser: r
    } = t, n = Bt(e[0], "size").value, a = e[1];
    return {
      type: "raisebox",
      mode: r.mode,
      dy: n,
      body: a
    };
  },
  htmlBuilder(t, e) {
    var r = er(t.body, e), n = Ur(t.dy, e);
    return ye.makeVList({
      positionType: "shift",
      positionData: -n,
      children: [{
        type: "elem",
        elem: r
      }]
    }, e);
  },
  mathmlBuilder(t, e) {
    var r = new Ue.MathNode("mpadded", [Cr(t.body, e)]), n = t.dy.number + t.dy.unit;
    return r.setAttribute("voffset", n), r;
  }
});
it({
  type: "internal",
  names: ["\\relax"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInArgument: !0
  },
  handler(t) {
    var {
      parser: e
    } = t;
    return {
      type: "internal",
      mode: e.mode
    };
  }
});
it({
  type: "rule",
  names: ["\\rule"],
  props: {
    numArgs: 2,
    numOptionalArgs: 1,
    allowedInText: !0,
    allowedInMath: !0,
    argTypes: ["size", "size", "size"]
  },
  handler(t, e, r) {
    var {
      parser: n
    } = t, a = r[0], i = Bt(e[0], "size"), s = Bt(e[1], "size");
    return {
      type: "rule",
      mode: n.mode,
      shift: a && Bt(a, "size").value,
      width: i.value,
      height: s.value
    };
  },
  htmlBuilder(t, e) {
    var r = ye.makeSpan(["mord", "rule"], [], e), n = Ur(t.width, e), a = Ur(t.height, e), i = t.shift ? Ur(t.shift, e) : 0;
    return r.style.borderRightWidth = Qe(n), r.style.borderTopWidth = Qe(a), r.style.bottom = Qe(i), r.width = n, r.height = a + i, r.depth = -i, r.maxFontSize = a * 1.125 * e.sizeMultiplier, r;
  },
  mathmlBuilder(t, e) {
    var r = Ur(t.width, e), n = Ur(t.height, e), a = t.shift ? Ur(t.shift, e) : 0, i = e.color && e.getColor() || "black", s = new Ue.MathNode("mspace");
    s.setAttribute("mathbackground", i), s.setAttribute("width", Qe(r)), s.setAttribute("height", Qe(n));
    var o = new Ue.MathNode("mpadded", [s]);
    return a >= 0 ? o.setAttribute("height", Qe(a)) : (o.setAttribute("height", Qe(a)), o.setAttribute("depth", Qe(-a))), o.setAttribute("voffset", Qe(a)), o;
  }
});
function SF(t, e, r) {
  for (var n = bn(t, e, !1), a = e.sizeMultiplier / r.sizeMultiplier, i = 0; i < n.length; i++) {
    var s = n[i].classes.indexOf("sizing");
    s < 0 ? Array.prototype.push.apply(n[i].classes, e.sizingClasses(r)) : n[i].classes[s + 1] === "reset-size" + e.size && (n[i].classes[s + 1] = "reset-size" + r.size), n[i].height *= a, n[i].depth *= a;
  }
  return ye.makeFragment(n);
}
var m7 = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"], fme = (t, e) => {
  var r = e.havingSize(t.size);
  return SF(t.body, r, e);
};
it({
  type: "sizing",
  names: m7,
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler: (t, e) => {
    var {
      breakOnTokenText: r,
      funcName: n,
      parser: a
    } = t, i = a.parseExpression(!1, r);
    return {
      type: "sizing",
      mode: a.mode,
      // Figure out what size to use based on the list of functions above
      size: m7.indexOf(n) + 1,
      body: i
    };
  },
  htmlBuilder: fme,
  mathmlBuilder: (t, e) => {
    var r = e.havingSize(t.size), n = Oa(t.body, r), a = new Ue.MathNode("mstyle", n);
    return a.setAttribute("mathsize", Qe(r.sizeMultiplier)), a;
  }
});
it({
  type: "smash",
  names: ["\\smash"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    allowedInText: !0
  },
  handler: (t, e, r) => {
    var {
      parser: n
    } = t, a = !1, i = !1, s = r[0] && Bt(r[0], "ordgroup");
    if (s)
      for (var o = "", l = 0; l < s.body.length; ++l) {
        var u = s.body[l];
        if (o = u.text, o === "t")
          a = !0;
        else if (o === "b")
          i = !0;
        else {
          a = !1, i = !1;
          break;
        }
      }
    else
      a = !0, i = !0;
    var c = e[0];
    return {
      type: "smash",
      mode: n.mode,
      body: c,
      smashHeight: a,
      smashDepth: i
    };
  },
  htmlBuilder: (t, e) => {
    var r = ye.makeSpan([], [er(t.body, e)]);
    if (!t.smashHeight && !t.smashDepth)
      return r;
    if (t.smashHeight && (r.height = 0, r.children))
      for (var n = 0; n < r.children.length; n++)
        r.children[n].height = 0;
    if (t.smashDepth && (r.depth = 0, r.children))
      for (var a = 0; a < r.children.length; a++)
        r.children[a].depth = 0;
    var i = ye.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: r
      }]
    }, e);
    return ye.makeSpan(["mord"], [i], e);
  },
  mathmlBuilder: (t, e) => {
    var r = new Ue.MathNode("mpadded", [Cr(t.body, e)]);
    return t.smashHeight && r.setAttribute("height", "0px"), t.smashDepth && r.setAttribute("depth", "0px"), r;
  }
});
it({
  type: "sqrt",
  names: ["\\sqrt"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler(t, e, r) {
    var {
      parser: n
    } = t, a = r[0], i = e[0];
    return {
      type: "sqrt",
      mode: n.mode,
      body: i,
      index: a
    };
  },
  htmlBuilder(t, e) {
    var r = er(t.body, e.havingCrampedStyle());
    r.height === 0 && (r.height = e.fontMetrics().xHeight), r = ye.wrapFragment(r, e);
    var n = e.fontMetrics(), a = n.defaultRuleThickness, i = a;
    e.style.id < Ct.TEXT.id && (i = e.fontMetrics().xHeight);
    var s = a + i / 4, o = r.height + r.depth + s + a, {
      span: l,
      ruleWidth: u,
      advanceWidth: c
    } = Qs.sqrtImage(o, e), f = l.height - u;
    f > r.height + r.depth + s && (s = (s + f - r.height - r.depth) / 2);
    var h = l.height - r.height - s - u;
    r.style.paddingLeft = Qe(c);
    var d = ye.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: r,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: -(r.height + h)
      }, {
        type: "elem",
        elem: l
      }, {
        type: "kern",
        size: u
      }]
    }, e);
    if (t.index) {
      var p = e.havingStyle(Ct.SCRIPTSCRIPT), g = er(t.index, p, e), v = 0.6 * (d.height - d.depth), m = ye.makeVList({
        positionType: "shift",
        positionData: -v,
        children: [{
          type: "elem",
          elem: g
        }]
      }, e), b = ye.makeSpan(["root"], [m]);
      return ye.makeSpan(["mord", "sqrt"], [b, d], e);
    } else
      return ye.makeSpan(["mord", "sqrt"], [d], e);
  },
  mathmlBuilder(t, e) {
    var {
      body: r,
      index: n
    } = t;
    return n ? new Ue.MathNode("mroot", [Cr(r, e), Cr(n, e)]) : new Ue.MathNode("msqrt", [Cr(r, e)]);
  }
});
var y7 = {
  display: Ct.DISPLAY,
  text: Ct.TEXT,
  script: Ct.SCRIPT,
  scriptscript: Ct.SCRIPTSCRIPT
};
it({
  type: "styling",
  names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(t, e) {
    var {
      breakOnTokenText: r,
      funcName: n,
      parser: a
    } = t, i = a.parseExpression(!0, r), s = n.slice(1, n.length - 5);
    return {
      type: "styling",
      mode: a.mode,
      // Figure out what style to use by pulling out the style from
      // the function name
      style: s,
      body: i
    };
  },
  htmlBuilder(t, e) {
    var r = y7[t.style], n = e.havingStyle(r).withFont("");
    return SF(t.body, n, e);
  },
  mathmlBuilder(t, e) {
    var r = y7[t.style], n = e.havingStyle(r), a = Oa(t.body, n), i = new Ue.MathNode("mstyle", a), s = {
      display: ["0", "true"],
      text: ["0", "false"],
      script: ["1", "false"],
      scriptscript: ["2", "false"]
    }, o = s[t.style];
    return i.setAttribute("scriptlevel", o[0]), i.setAttribute("displaystyle", o[1]), i;
  }
});
var hme = function(e, r) {
  var n = e.base;
  if (n)
    if (n.type === "op") {
      var a = n.limits && (r.style.size === Ct.DISPLAY.size || n.alwaysHandleSupSub);
      return a ? kf : null;
    } else if (n.type === "operatorname") {
      var i = n.alwaysHandleSupSub && (r.style.size === Ct.DISPLAY.size || n.limits);
      return i ? TF : null;
    } else {
      if (n.type === "accent")
        return rr.isCharacterBox(n.base) ? CC : null;
      if (n.type === "horizBrace") {
        var s = !e.sub;
        return s === n.isOver ? xF : null;
      } else
        return null;
    }
  else return null;
};
ku({
  type: "supsub",
  htmlBuilder(t, e) {
    var r = hme(t, e);
    if (r)
      return r(t, e);
    var {
      base: n,
      sup: a,
      sub: i
    } = t, s = er(n, e), o, l, u = e.fontMetrics(), c = 0, f = 0, h = n && rr.isCharacterBox(n);
    if (a) {
      var d = e.havingStyle(e.style.sup());
      o = er(a, d, e), h || (c = s.height - d.fontMetrics().supDrop * d.sizeMultiplier / e.sizeMultiplier);
    }
    if (i) {
      var p = e.havingStyle(e.style.sub());
      l = er(i, p, e), h || (f = s.depth + p.fontMetrics().subDrop * p.sizeMultiplier / e.sizeMultiplier);
    }
    var g;
    e.style === Ct.DISPLAY ? g = u.sup1 : e.style.cramped ? g = u.sup3 : g = u.sup2;
    var v = e.sizeMultiplier, m = Qe(0.5 / u.ptPerEm / v), b = null;
    if (l) {
      var y = t.base && t.base.type === "op" && t.base.name && (t.base.name === "\\oiint" || t.base.name === "\\oiiint");
      (s instanceof Ei || y) && (b = Qe(-s.italic));
    }
    var x;
    if (o && l) {
      c = Math.max(c, g, o.depth + 0.25 * u.xHeight), f = Math.max(f, u.sub2);
      var E = u.defaultRuleThickness, S = 4 * E;
      if (c - o.depth - (l.height - f) < S) {
        f = S - (c - o.depth) + l.height;
        var w = 0.8 * u.xHeight - (c - o.depth);
        w > 0 && (c += w, f -= w);
      }
      var C = [{
        type: "elem",
        elem: l,
        shift: f,
        marginRight: m,
        marginLeft: b
      }, {
        type: "elem",
        elem: o,
        shift: -c,
        marginRight: m
      }];
      x = ye.makeVList({
        positionType: "individualShift",
        children: C
      }, e);
    } else if (l) {
      f = Math.max(f, u.sub1, l.height - 0.8 * u.xHeight);
      var k = [{
        type: "elem",
        elem: l,
        marginLeft: b,
        marginRight: m
      }];
      x = ye.makeVList({
        positionType: "shift",
        positionData: f,
        children: k
      }, e);
    } else if (o)
      c = Math.max(c, g, o.depth + 0.25 * u.xHeight), x = ye.makeVList({
        positionType: "shift",
        positionData: -c,
        children: [{
          type: "elem",
          elem: o,
          marginRight: m
        }]
      }, e);
    else
      throw new Error("supsub must have either sup or sub.");
    var N = c4(s, "right") || "mord";
    return ye.makeSpan([N], [s, ye.makeSpan(["msupsub"], [x])], e);
  },
  mathmlBuilder(t, e) {
    var r = !1, n, a;
    t.base && t.base.type === "horizBrace" && (a = !!t.sup, a === t.base.isOver && (r = !0, n = t.base.isOver)), t.base && (t.base.type === "op" || t.base.type === "operatorname") && (t.base.parentIsSupSub = !0);
    var i = [Cr(t.base, e)];
    t.sub && i.push(Cr(t.sub, e)), t.sup && i.push(Cr(t.sup, e));
    var s;
    if (r)
      s = n ? "mover" : "munder";
    else if (t.sub)
      if (t.sup) {
        var u = t.base;
        u && u.type === "op" && u.limits && e.style === Ct.DISPLAY || u && u.type === "operatorname" && u.alwaysHandleSupSub && (e.style === Ct.DISPLAY || u.limits) ? s = "munderover" : s = "msubsup";
      } else {
        var l = t.base;
        l && l.type === "op" && l.limits && (e.style === Ct.DISPLAY || l.alwaysHandleSupSub) || l && l.type === "operatorname" && l.alwaysHandleSupSub && (l.limits || e.style === Ct.DISPLAY) ? s = "munder" : s = "msub";
      }
    else {
      var o = t.base;
      o && o.type === "op" && o.limits && (e.style === Ct.DISPLAY || o.alwaysHandleSupSub) || o && o.type === "operatorname" && o.alwaysHandleSupSub && (o.limits || e.style === Ct.DISPLAY) ? s = "mover" : s = "msup";
    }
    return new Ue.MathNode(s, i);
  }
});
ku({
  type: "atom",
  htmlBuilder(t, e) {
    return ye.mathsym(t.text, t.mode, e, ["m" + t.family]);
  },
  mathmlBuilder(t, e) {
    var r = new Ue.MathNode("mo", [Ti(t.text, t.mode)]);
    if (t.family === "bin") {
      var n = TC(t, e);
      n === "bold-italic" && r.setAttribute("mathvariant", n);
    } else t.family === "punct" ? r.setAttribute("separator", "true") : (t.family === "open" || t.family === "close") && r.setAttribute("stretchy", "false");
    return r;
  }
});
var CF = {
  mi: "italic",
  mn: "normal",
  mtext: "normal"
};
ku({
  type: "mathord",
  htmlBuilder(t, e) {
    return ye.makeOrd(t, e, "mathord");
  },
  mathmlBuilder(t, e) {
    var r = new Ue.MathNode("mi", [Ti(t.text, t.mode, e)]), n = TC(t, e) || "italic";
    return n !== CF[r.type] && r.setAttribute("mathvariant", n), r;
  }
});
ku({
  type: "textord",
  htmlBuilder(t, e) {
    return ye.makeOrd(t, e, "textord");
  },
  mathmlBuilder(t, e) {
    var r = Ti(t.text, t.mode, e), n = TC(t, e) || "normal", a;
    return t.mode === "text" ? a = new Ue.MathNode("mtext", [r]) : /[0-9]/.test(t.text) ? a = new Ue.MathNode("mn", [r]) : t.text === "\\prime" ? a = new Ue.MathNode("mo", [r]) : a = new Ue.MathNode("mi", [r]), n !== CF[a.type] && a.setAttribute("mathvariant", n), a;
  }
});
var qx = {
  "\\nobreak": "nobreak",
  "\\allowbreak": "allowbreak"
}, Wx = {
  " ": {},
  "\\ ": {},
  "~": {
    className: "nobreak"
  },
  "\\space": {},
  "\\nobreakspace": {
    className: "nobreak"
  }
};
ku({
  type: "spacing",
  htmlBuilder(t, e) {
    if (Wx.hasOwnProperty(t.text)) {
      var r = Wx[t.text].className || "";
      if (t.mode === "text") {
        var n = ye.makeOrd(t, e, "textord");
        return n.classes.push(r), n;
      } else
        return ye.makeSpan(["mspace", r], [ye.mathsym(t.text, t.mode, e)], e);
    } else {
      if (qx.hasOwnProperty(t.text))
        return ye.makeSpan(["mspace", qx[t.text]], [], e);
      throw new Ve('Unknown type of space "' + t.text + '"');
    }
  },
  mathmlBuilder(t, e) {
    var r;
    if (Wx.hasOwnProperty(t.text))
      r = new Ue.MathNode("mtext", [new Ue.TextNode(" ")]);
    else {
      if (qx.hasOwnProperty(t.text))
        return new Ue.MathNode("mspace");
      throw new Ve('Unknown type of space "' + t.text + '"');
    }
    return r;
  }
});
var b7 = () => {
  var t = new Ue.MathNode("mtd", []);
  return t.setAttribute("width", "50%"), t;
};
ku({
  type: "tag",
  mathmlBuilder(t, e) {
    var r = new Ue.MathNode("mtable", [new Ue.MathNode("mtr", [b7(), new Ue.MathNode("mtd", [Wo(t.body, e)]), b7(), new Ue.MathNode("mtd", [Wo(t.tag, e)])])]);
    return r.setAttribute("width", "100%"), r;
  }
});
var x7 = {
  "\\text": void 0,
  "\\textrm": "textrm",
  "\\textsf": "textsf",
  "\\texttt": "texttt",
  "\\textnormal": "textrm"
}, w7 = {
  "\\textbf": "textbf",
  "\\textmd": "textmd"
}, dme = {
  "\\textit": "textit",
  "\\textup": "textup"
}, E7 = (t, e) => {
  var r = t.font;
  if (r) {
    if (x7[r])
      return e.withTextFontFamily(x7[r]);
    if (w7[r])
      return e.withTextFontWeight(w7[r]);
    if (r === "\\emph")
      return e.fontShape === "textit" ? e.withTextFontShape("textup") : e.withTextFontShape("textit");
  } else return e;
  return e.withTextFontShape(dme[r]);
};
it({
  type: "text",
  names: [
    // Font families
    "\\text",
    "\\textrm",
    "\\textsf",
    "\\texttt",
    "\\textnormal",
    // Font weights
    "\\textbf",
    "\\textmd",
    // Font Shapes
    "\\textit",
    "\\textup",
    "\\emph"
  ],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInArgument: !0,
    allowedInText: !0
  },
  handler(t, e) {
    var {
      parser: r,
      funcName: n
    } = t, a = e[0];
    return {
      type: "text",
      mode: r.mode,
      body: nn(a),
      font: n
    };
  },
  htmlBuilder(t, e) {
    var r = E7(t, e), n = bn(t.body, r, !0);
    return ye.makeSpan(["mord", "text"], n, r);
  },
  mathmlBuilder(t, e) {
    var r = E7(t, e);
    return Wo(t.body, r);
  }
});
it({
  type: "underline",
  names: ["\\underline"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler(t, e) {
    var {
      parser: r
    } = t;
    return {
      type: "underline",
      mode: r.mode,
      body: e[0]
    };
  },
  htmlBuilder(t, e) {
    var r = er(t.body, e), n = ye.makeLineSpan("underline-line", e), a = e.fontMetrics().defaultRuleThickness, i = ye.makeVList({
      positionType: "top",
      positionData: r.height,
      children: [{
        type: "kern",
        size: a
      }, {
        type: "elem",
        elem: n
      }, {
        type: "kern",
        size: 3 * a
      }, {
        type: "elem",
        elem: r
      }]
    }, e);
    return ye.makeSpan(["mord", "underline"], [i], e);
  },
  mathmlBuilder(t, e) {
    var r = new Ue.MathNode("mo", [new Ue.TextNode("‾")]);
    r.setAttribute("stretchy", "true");
    var n = new Ue.MathNode("munder", [Cr(t.body, e), r]);
    return n.setAttribute("accentunder", "true"), n;
  }
});
it({
  type: "vcenter",
  names: ["\\vcenter"],
  props: {
    numArgs: 1,
    argTypes: ["original"],
    // In LaTeX, \vcenter can act only on a box.
    allowedInText: !1
  },
  handler(t, e) {
    var {
      parser: r
    } = t;
    return {
      type: "vcenter",
      mode: r.mode,
      body: e[0]
    };
  },
  htmlBuilder(t, e) {
    var r = er(t.body, e), n = e.fontMetrics().axisHeight, a = 0.5 * (r.height - n - (r.depth + n));
    return ye.makeVList({
      positionType: "shift",
      positionData: a,
      children: [{
        type: "elem",
        elem: r
      }]
    }, e);
  },
  mathmlBuilder(t, e) {
    return new Ue.MathNode("mpadded", [Cr(t.body, e)], ["vcenter"]);
  }
});
it({
  type: "verb",
  names: ["\\verb"],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler(t, e, r) {
    throw new Ve("\\verb ended by end of line instead of matching delimiter");
  },
  htmlBuilder(t, e) {
    for (var r = T7(t), n = [], a = e.havingStyle(e.style.text()), i = 0; i < r.length; i++) {
      var s = r[i];
      s === "~" && (s = "\\textasciitilde"), n.push(ye.makeSymbol(s, "Typewriter-Regular", t.mode, a, ["mord", "texttt"]));
    }
    return ye.makeSpan(["mord", "text"].concat(a.sizingClasses(e)), ye.tryCombineChars(n), a);
  },
  mathmlBuilder(t, e) {
    var r = new Ue.TextNode(T7(t)), n = new Ue.MathNode("mtext", [r]);
    return n.setAttribute("mathvariant", "monospace"), n;
  }
});
var T7 = (t) => t.body.replace(/ /g, t.star ? "␣" : " "), Io = Y$, AF = `[ \r
	]`, pme = "\\\\[a-zA-Z@]+", gme = "\\\\[^\uD800-\uDFFF]", vme = "(" + pme + ")" + AF + "*", mme = `\\\\(
|[ \r	]+
?)[ \r	]*`, p4 = "[̀-ͯ]", yme = new RegExp(p4 + "+$"), bme = "(" + AF + "+)|" + // whitespace
(mme + "|") + // \whitespace
"([!-\\[\\]-‧‪-퟿豈-￿]" + // single codepoint
(p4 + "*") + // ...plus accents
"|[\uD800-\uDBFF][\uDC00-\uDFFF]" + // surrogate pair
(p4 + "*") + // ...plus accents
"|\\\\verb\\*([^]).*?\\4|\\\\verb([^*a-zA-Z]).*?\\5" + // \verb unstarred
("|" + vme) + // \macroName + spaces
("|" + gme + ")");
let S7 = class {
  // Category codes. The lexer only supports comment characters (14) for now.
  // MacroExpander additionally distinguishes active (13).
  constructor(e, r) {
    this.input = void 0, this.settings = void 0, this.tokenRegex = void 0, this.catcodes = void 0, this.input = e, this.settings = r, this.tokenRegex = new RegExp(bme, "g"), this.catcodes = {
      "%": 14,
      // comment character
      "~": 13
      // active character
    };
  }
  setCatcode(e, r) {
    this.catcodes[e] = r;
  }
  /**
   * This function lexes a single token.
   */
  lex() {
    var e = this.input, r = this.tokenRegex.lastIndex;
    if (r === e.length)
      return new ei("EOF", new Ea(this, r, r));
    var n = this.tokenRegex.exec(e);
    if (n === null || n.index !== r)
      throw new Ve("Unexpected character: '" + e[r] + "'", new ei(e[r], new Ea(this, r, r + 1)));
    var a = n[6] || n[3] || (n[2] ? "\\ " : " ");
    if (this.catcodes[a] === 14) {
      var i = e.indexOf(`
`, this.tokenRegex.lastIndex);
      return i === -1 ? (this.tokenRegex.lastIndex = e.length, this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)")) : this.tokenRegex.lastIndex = i + 1, this.lex();
    }
    return new ei(a, new Ea(this, r, this.tokenRegex.lastIndex));
  }
};
class xme {
  /**
   * Both arguments are optional.  The first argument is an object of
   * built-in mappings which never change.  The second argument is an object
   * of initial (global-level) mappings, which will constantly change
   * according to any global/top-level `set`s done.
   */
  constructor(e, r) {
    e === void 0 && (e = {}), r === void 0 && (r = {}), this.current = void 0, this.builtins = void 0, this.undefStack = void 0, this.current = r, this.builtins = e, this.undefStack = [];
  }
  /**
   * Start a new nested group, affecting future local `set`s.
   */
  beginGroup() {
    this.undefStack.push({});
  }
  /**
   * End current nested group, restoring values before the group began.
   */
  endGroup() {
    if (this.undefStack.length === 0)
      throw new Ve("Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug");
    var e = this.undefStack.pop();
    for (var r in e)
      e.hasOwnProperty(r) && (e[r] == null ? delete this.current[r] : this.current[r] = e[r]);
  }
  /**
   * Ends all currently nested groups (if any), restoring values before the
   * groups began.  Useful in case of an error in the middle of parsing.
   */
  endGroups() {
    for (; this.undefStack.length > 0; )
      this.endGroup();
  }
  /**
   * Detect whether `name` has a definition.  Equivalent to
   * `get(name) != null`.
   */
  has(e) {
    return this.current.hasOwnProperty(e) || this.builtins.hasOwnProperty(e);
  }
  /**
   * Get the current value of a name, or `undefined` if there is no value.
   *
   * Note: Do not use `if (namespace.get(...))` to detect whether a macro
   * is defined, as the definition may be the empty string which evaluates
   * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or
   * `if (namespace.has(...))`.
   */
  get(e) {
    return this.current.hasOwnProperty(e) ? this.current[e] : this.builtins[e];
  }
  /**
   * Set the current value of a name, and optionally set it globally too.
   * Local set() sets the current value and (when appropriate) adds an undo
   * operation to the undo stack.  Global set() may change the undo
   * operation at every level, so takes time linear in their number.
   * A value of undefined means to delete existing definitions.
   */
  set(e, r, n) {
    if (n === void 0 && (n = !1), n) {
      for (var a = 0; a < this.undefStack.length; a++)
        delete this.undefStack[a][e];
      this.undefStack.length > 0 && (this.undefStack[this.undefStack.length - 1][e] = r);
    } else {
      var i = this.undefStack[this.undefStack.length - 1];
      i && !i.hasOwnProperty(e) && (i[e] = this.current[e]);
    }
    r == null ? delete this.current[e] : this.current[e] = r;
  }
}
var wme = gF;
Y("\\noexpand", function(t) {
  var e = t.popToken();
  return t.isExpandable(e.text) && (e.noexpand = !0, e.treatAsRelax = !0), {
    tokens: [e],
    numArgs: 0
  };
});
Y("\\expandafter", function(t) {
  var e = t.popToken();
  return t.expandOnce(!0), {
    tokens: [e],
    numArgs: 0
  };
});
Y("\\@firstoftwo", function(t) {
  var e = t.consumeArgs(2);
  return {
    tokens: e[0],
    numArgs: 0
  };
});
Y("\\@secondoftwo", function(t) {
  var e = t.consumeArgs(2);
  return {
    tokens: e[1],
    numArgs: 0
  };
});
Y("\\@ifnextchar", function(t) {
  var e = t.consumeArgs(3);
  t.consumeSpaces();
  var r = t.future();
  return e[0].length === 1 && e[0][0].text === r.text ? {
    tokens: e[1],
    numArgs: 0
  } : {
    tokens: e[2],
    numArgs: 0
  };
});
Y("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}");
Y("\\TextOrMath", function(t) {
  var e = t.consumeArgs(2);
  return t.mode === "text" ? {
    tokens: e[0],
    numArgs: 0
  } : {
    tokens: e[1],
    numArgs: 0
  };
});
var C7 = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  a: 10,
  A: 10,
  b: 11,
  B: 11,
  c: 12,
  C: 12,
  d: 13,
  D: 13,
  e: 14,
  E: 14,
  f: 15,
  F: 15
};
Y("\\char", function(t) {
  var e = t.popToken(), r, n = "";
  if (e.text === "'")
    r = 8, e = t.popToken();
  else if (e.text === '"')
    r = 16, e = t.popToken();
  else if (e.text === "`")
    if (e = t.popToken(), e.text[0] === "\\")
      n = e.text.charCodeAt(1);
    else {
      if (e.text === "EOF")
        throw new Ve("\\char` missing argument");
      n = e.text.charCodeAt(0);
    }
  else
    r = 10;
  if (r) {
    if (n = C7[e.text], n == null || n >= r)
      throw new Ve("Invalid base-" + r + " digit " + e.text);
    for (var a; (a = C7[t.future().text]) != null && a < r; )
      n *= r, n += a, t.popToken();
  }
  return "\\@char{" + n + "}";
});
var OC = (t, e, r, n) => {
  var a = t.consumeArg().tokens;
  if (a.length !== 1)
    throw new Ve("\\newcommand's first argument must be a macro name");
  var i = a[0].text, s = t.isDefined(i);
  if (s && !e)
    throw new Ve("\\newcommand{" + i + "} attempting to redefine " + (i + "; use \\renewcommand"));
  if (!s && !r)
    throw new Ve("\\renewcommand{" + i + "} when command " + i + " does not yet exist; use \\newcommand");
  var o = 0;
  if (a = t.consumeArg().tokens, a.length === 1 && a[0].text === "[") {
    for (var l = "", u = t.expandNextToken(); u.text !== "]" && u.text !== "EOF"; )
      l += u.text, u = t.expandNextToken();
    if (!l.match(/^\s*[0-9]+\s*$/))
      throw new Ve("Invalid number of arguments: " + l);
    o = parseInt(l), a = t.consumeArg().tokens;
  }
  return s && n || t.macros.set(i, {
    tokens: a,
    numArgs: o
  }), "";
};
Y("\\newcommand", (t) => OC(t, !1, !0, !1));
Y("\\renewcommand", (t) => OC(t, !0, !1, !1));
Y("\\providecommand", (t) => OC(t, !0, !0, !0));
Y("\\message", (t) => {
  var e = t.consumeArgs(1)[0];
  return console.log(e.reverse().map((r) => r.text).join("")), "";
});
Y("\\errmessage", (t) => {
  var e = t.consumeArgs(1)[0];
  return console.error(e.reverse().map((r) => r.text).join("")), "";
});
Y("\\show", (t) => {
  var e = t.popToken(), r = e.text;
  return console.log(e, t.macros.get(r), Io[r], Mr.math[r], Mr.text[r]), "";
});
Y("\\bgroup", "{");
Y("\\egroup", "}");
Y("~", "\\nobreakspace");
Y("\\lq", "`");
Y("\\rq", "'");
Y("\\aa", "\\r a");
Y("\\AA", "\\r A");
Y("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`©}");
Y("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
Y("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`®}");
Y("ℬ", "\\mathscr{B}");
Y("ℰ", "\\mathscr{E}");
Y("ℱ", "\\mathscr{F}");
Y("ℋ", "\\mathscr{H}");
Y("ℐ", "\\mathscr{I}");
Y("ℒ", "\\mathscr{L}");
Y("ℳ", "\\mathscr{M}");
Y("ℛ", "\\mathscr{R}");
Y("ℭ", "\\mathfrak{C}");
Y("ℌ", "\\mathfrak{H}");
Y("ℨ", "\\mathfrak{Z}");
Y("\\Bbbk", "\\Bbb{k}");
Y("·", "\\cdotp");
Y("\\llap", "\\mathllap{\\textrm{#1}}");
Y("\\rlap", "\\mathrlap{\\textrm{#1}}");
Y("\\clap", "\\mathclap{\\textrm{#1}}");
Y("\\mathstrut", "\\vphantom{(}");
Y("\\underbar", "\\underline{\\text{#1}}");
Y("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}');
Y("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`≠}}");
Y("\\ne", "\\neq");
Y("≠", "\\neq");
Y("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`∉}}");
Y("∉", "\\notin");
Y("≘", "\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`≘}}");
Y("≙", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`≘}}");
Y("≚", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`≚}}");
Y("≛", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`≛}}");
Y("≝", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`≝}}");
Y("≞", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`≞}}");
Y("≟", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`≟}}");
Y("⟂", "\\perp");
Y("‼", "\\mathclose{!\\mkern-0.8mu!}");
Y("∌", "\\notni");
Y("⌜", "\\ulcorner");
Y("⌝", "\\urcorner");
Y("⌞", "\\llcorner");
Y("⌟", "\\lrcorner");
Y("©", "\\copyright");
Y("®", "\\textregistered");
Y("️", "\\textregistered");
Y("\\ulcorner", '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}');
Y("\\urcorner", '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}');
Y("\\llcorner", '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}');
Y("\\lrcorner", '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}');
Y("\\vdots", "{\\varvdots\\rule{0pt}{15pt}}");
Y("⋮", "\\vdots");
Y("\\varGamma", "\\mathit{\\Gamma}");
Y("\\varDelta", "\\mathit{\\Delta}");
Y("\\varTheta", "\\mathit{\\Theta}");
Y("\\varLambda", "\\mathit{\\Lambda}");
Y("\\varXi", "\\mathit{\\Xi}");
Y("\\varPi", "\\mathit{\\Pi}");
Y("\\varSigma", "\\mathit{\\Sigma}");
Y("\\varUpsilon", "\\mathit{\\Upsilon}");
Y("\\varPhi", "\\mathit{\\Phi}");
Y("\\varPsi", "\\mathit{\\Psi}");
Y("\\varOmega", "\\mathit{\\Omega}");
Y("\\substack", "\\begin{subarray}{c}#1\\end{subarray}");
Y("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu\\relax");
Y("\\boxed", "\\fbox{$\\displaystyle{#1}$}");
Y("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
Y("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
Y("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");
Y("\\dddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ...}}{#1}}");
Y("\\ddddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ....}}{#1}}");
var A7 = {
  ",": "\\dotsc",
  "\\not": "\\dotsb",
  // \keybin@ checks for the following:
  "+": "\\dotsb",
  "=": "\\dotsb",
  "<": "\\dotsb",
  ">": "\\dotsb",
  "-": "\\dotsb",
  "*": "\\dotsb",
  ":": "\\dotsb",
  // Symbols whose definition starts with \DOTSB:
  "\\DOTSB": "\\dotsb",
  "\\coprod": "\\dotsb",
  "\\bigvee": "\\dotsb",
  "\\bigwedge": "\\dotsb",
  "\\biguplus": "\\dotsb",
  "\\bigcap": "\\dotsb",
  "\\bigcup": "\\dotsb",
  "\\prod": "\\dotsb",
  "\\sum": "\\dotsb",
  "\\bigotimes": "\\dotsb",
  "\\bigoplus": "\\dotsb",
  "\\bigodot": "\\dotsb",
  "\\bigsqcup": "\\dotsb",
  "\\And": "\\dotsb",
  "\\longrightarrow": "\\dotsb",
  "\\Longrightarrow": "\\dotsb",
  "\\longleftarrow": "\\dotsb",
  "\\Longleftarrow": "\\dotsb",
  "\\longleftrightarrow": "\\dotsb",
  "\\Longleftrightarrow": "\\dotsb",
  "\\mapsto": "\\dotsb",
  "\\longmapsto": "\\dotsb",
  "\\hookrightarrow": "\\dotsb",
  "\\doteq": "\\dotsb",
  // Symbols whose definition starts with \mathbin:
  "\\mathbin": "\\dotsb",
  // Symbols whose definition starts with \mathrel:
  "\\mathrel": "\\dotsb",
  "\\relbar": "\\dotsb",
  "\\Relbar": "\\dotsb",
  "\\xrightarrow": "\\dotsb",
  "\\xleftarrow": "\\dotsb",
  // Symbols whose definition starts with \DOTSI:
  "\\DOTSI": "\\dotsi",
  "\\int": "\\dotsi",
  "\\oint": "\\dotsi",
  "\\iint": "\\dotsi",
  "\\iiint": "\\dotsi",
  "\\iiiint": "\\dotsi",
  "\\idotsint": "\\dotsi",
  // Symbols whose definition starts with \DOTSX:
  "\\DOTSX": "\\dotsx"
};
Y("\\dots", function(t) {
  var e = "\\dotso", r = t.expandAfterFuture().text;
  return r in A7 ? e = A7[r] : (r.slice(0, 4) === "\\not" || r in Mr.math && ["bin", "rel"].includes(Mr.math[r].group)) && (e = "\\dotsb"), e;
});
var IC = {
  // \rightdelim@ checks for the following:
  ")": !0,
  "]": !0,
  "\\rbrack": !0,
  "\\}": !0,
  "\\rbrace": !0,
  "\\rangle": !0,
  "\\rceil": !0,
  "\\rfloor": !0,
  "\\rgroup": !0,
  "\\rmoustache": !0,
  "\\right": !0,
  "\\bigr": !0,
  "\\biggr": !0,
  "\\Bigr": !0,
  "\\Biggr": !0,
  // \extra@ also tests for the following:
  $: !0,
  // \extrap@ checks for the following:
  ";": !0,
  ".": !0,
  ",": !0
};
Y("\\dotso", function(t) {
  var e = t.future().text;
  return e in IC ? "\\ldots\\," : "\\ldots";
});
Y("\\dotsc", function(t) {
  var e = t.future().text;
  return e in IC && e !== "," ? "\\ldots\\," : "\\ldots";
});
Y("\\cdots", function(t) {
  var e = t.future().text;
  return e in IC ? "\\@cdots\\," : "\\@cdots";
});
Y("\\dotsb", "\\cdots");
Y("\\dotsm", "\\cdots");
Y("\\dotsi", "\\!\\cdots");
Y("\\dotsx", "\\ldots\\,");
Y("\\DOTSI", "\\relax");
Y("\\DOTSB", "\\relax");
Y("\\DOTSX", "\\relax");
Y("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");
Y("\\,", "\\tmspace+{3mu}{.1667em}");
Y("\\thinspace", "\\,");
Y("\\>", "\\mskip{4mu}");
Y("\\:", "\\tmspace+{4mu}{.2222em}");
Y("\\medspace", "\\:");
Y("\\;", "\\tmspace+{5mu}{.2777em}");
Y("\\thickspace", "\\;");
Y("\\!", "\\tmspace-{3mu}{.1667em}");
Y("\\negthinspace", "\\!");
Y("\\negmedspace", "\\tmspace-{4mu}{.2222em}");
Y("\\negthickspace", "\\tmspace-{5mu}{.277em}");
Y("\\enspace", "\\kern.5em ");
Y("\\enskip", "\\hskip.5em\\relax");
Y("\\quad", "\\hskip1em\\relax");
Y("\\qquad", "\\hskip2em\\relax");
Y("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
Y("\\tag@paren", "\\tag@literal{({#1})}");
Y("\\tag@literal", (t) => {
  if (t.macros.get("\\df@tag"))
    throw new Ve("Multiple \\tag");
  return "\\gdef\\df@tag{\\text{#1}}";
});
Y("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
Y("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
Y("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
Y("\\mod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1");
Y("\\newline", "\\\\\\relax");
Y("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
var kF = Qe(fs["Main-Regular"][84][1] - 0.7 * fs["Main-Regular"][65][1]);
Y("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + kF + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}");
Y("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + kF + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}");
Y("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
Y("\\@hspace", "\\hskip #1\\relax");
Y("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax");
Y("\\ordinarycolon", ":");
Y("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}");
Y("\\dblcolon", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}');
Y("\\coloneqq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2254}}');
Y("\\Coloneqq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2237\\char"3d}}');
Y("\\coloneq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}');
Y("\\Coloneq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}');
Y("\\eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}');
Y("\\Eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}');
Y("\\eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}');
Y("\\Eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}');
Y("\\colonapprox", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}');
Y("\\Colonapprox", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}');
Y("\\colonsim", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}');
Y("\\Colonsim", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}');
Y("∷", "\\dblcolon");
Y("∹", "\\eqcolon");
Y("≔", "\\coloneqq");
Y("≕", "\\eqqcolon");
Y("⩴", "\\Coloneqq");
Y("\\ratio", "\\vcentcolon");
Y("\\coloncolon", "\\dblcolon");
Y("\\colonequals", "\\coloneqq");
Y("\\coloncolonequals", "\\Coloneqq");
Y("\\equalscolon", "\\eqqcolon");
Y("\\equalscoloncolon", "\\Eqqcolon");
Y("\\colonminus", "\\coloneq");
Y("\\coloncolonminus", "\\Coloneq");
Y("\\minuscolon", "\\eqcolon");
Y("\\minuscoloncolon", "\\Eqcolon");
Y("\\coloncolonapprox", "\\Colonapprox");
Y("\\coloncolonsim", "\\Colonsim");
Y("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
Y("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
Y("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
Y("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}");
Y("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`∌}}");
Y("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
Y("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}");
Y("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}");
Y("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}");
Y("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}");
Y("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}");
Y("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}");
Y("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}");
Y("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{≩}");
Y("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{≨}");
Y("\\ngeqq", "\\html@mathml{\\@ngeqq}{≱}");
Y("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{≱}");
Y("\\nleqq", "\\html@mathml{\\@nleqq}{≰}");
Y("\\nleqslant", "\\html@mathml{\\@nleqslant}{≰}");
Y("\\nshortmid", "\\html@mathml{\\@nshortmid}{∤}");
Y("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{∦}");
Y("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{⊈}");
Y("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{⊉}");
Y("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{⊊}");
Y("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{⫋}");
Y("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{⊋}");
Y("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{⫌}");
Y("\\imath", "\\html@mathml{\\@imath}{ı}");
Y("\\jmath", "\\html@mathml{\\@jmath}{ȷ}");
Y("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`⟦}}");
Y("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`⟧}}");
Y("⟦", "\\llbracket");
Y("⟧", "\\rrbracket");
Y("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`⦃}}");
Y("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`⦄}}");
Y("⦃", "\\lBrace");
Y("⦄", "\\rBrace");
Y("\\minuso", "\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`⦵}}");
Y("⦵", "\\minuso");
Y("\\darr", "\\downarrow");
Y("\\dArr", "\\Downarrow");
Y("\\Darr", "\\Downarrow");
Y("\\lang", "\\langle");
Y("\\rang", "\\rangle");
Y("\\uarr", "\\uparrow");
Y("\\uArr", "\\Uparrow");
Y("\\Uarr", "\\Uparrow");
Y("\\N", "\\mathbb{N}");
Y("\\R", "\\mathbb{R}");
Y("\\Z", "\\mathbb{Z}");
Y("\\alef", "\\aleph");
Y("\\alefsym", "\\aleph");
Y("\\Alpha", "\\mathrm{A}");
Y("\\Beta", "\\mathrm{B}");
Y("\\bull", "\\bullet");
Y("\\Chi", "\\mathrm{X}");
Y("\\clubs", "\\clubsuit");
Y("\\cnums", "\\mathbb{C}");
Y("\\Complex", "\\mathbb{C}");
Y("\\Dagger", "\\ddagger");
Y("\\diamonds", "\\diamondsuit");
Y("\\empty", "\\emptyset");
Y("\\Epsilon", "\\mathrm{E}");
Y("\\Eta", "\\mathrm{H}");
Y("\\exist", "\\exists");
Y("\\harr", "\\leftrightarrow");
Y("\\hArr", "\\Leftrightarrow");
Y("\\Harr", "\\Leftrightarrow");
Y("\\hearts", "\\heartsuit");
Y("\\image", "\\Im");
Y("\\infin", "\\infty");
Y("\\Iota", "\\mathrm{I}");
Y("\\isin", "\\in");
Y("\\Kappa", "\\mathrm{K}");
Y("\\larr", "\\leftarrow");
Y("\\lArr", "\\Leftarrow");
Y("\\Larr", "\\Leftarrow");
Y("\\lrarr", "\\leftrightarrow");
Y("\\lrArr", "\\Leftrightarrow");
Y("\\Lrarr", "\\Leftrightarrow");
Y("\\Mu", "\\mathrm{M}");
Y("\\natnums", "\\mathbb{N}");
Y("\\Nu", "\\mathrm{N}");
Y("\\Omicron", "\\mathrm{O}");
Y("\\plusmn", "\\pm");
Y("\\rarr", "\\rightarrow");
Y("\\rArr", "\\Rightarrow");
Y("\\Rarr", "\\Rightarrow");
Y("\\real", "\\Re");
Y("\\reals", "\\mathbb{R}");
Y("\\Reals", "\\mathbb{R}");
Y("\\Rho", "\\mathrm{P}");
Y("\\sdot", "\\cdot");
Y("\\sect", "\\S");
Y("\\spades", "\\spadesuit");
Y("\\sub", "\\subset");
Y("\\sube", "\\subseteq");
Y("\\supe", "\\supseteq");
Y("\\Tau", "\\mathrm{T}");
Y("\\thetasym", "\\vartheta");
Y("\\weierp", "\\wp");
Y("\\Zeta", "\\mathrm{Z}");
Y("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
Y("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
Y("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits");
Y("\\bra", "\\mathinner{\\langle{#1}|}");
Y("\\ket", "\\mathinner{|{#1}\\rangle}");
Y("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
Y("\\Bra", "\\left\\langle#1\\right|");
Y("\\Ket", "\\left|#1\\right\\rangle");
var RF = (t) => (e) => {
  var r = e.consumeArg().tokens, n = e.consumeArg().tokens, a = e.consumeArg().tokens, i = e.consumeArg().tokens, s = e.macros.get("|"), o = e.macros.get("\\|");
  e.macros.beginGroup();
  var l = (f) => (h) => {
    t && (h.macros.set("|", s), a.length && h.macros.set("\\|", o));
    var d = f;
    if (!f && a.length) {
      var p = h.future();
      p.text === "|" && (h.popToken(), d = !0);
    }
    return {
      tokens: d ? a : n,
      numArgs: 0
    };
  };
  e.macros.set("|", l(!1)), a.length && e.macros.set("\\|", l(!0));
  var u = e.consumeArg().tokens, c = e.expandTokens([
    ...i,
    ...u,
    ...r
    // reversed
  ]);
  return e.macros.endGroup(), {
    tokens: c.reverse(),
    numArgs: 0
  };
};
Y("\\bra@ket", RF(!1));
Y("\\bra@set", RF(!0));
Y("\\Braket", "\\bra@ket{\\left\\langle}{\\,\\middle\\vert\\,}{\\,\\middle\\vert\\,}{\\right\\rangle}");
Y("\\Set", "\\bra@set{\\left\\{\\:}{\\;\\middle\\vert\\;}{\\;\\middle\\Vert\\;}{\\:\\right\\}}");
Y("\\set", "\\bra@set{\\{\\,}{\\mid}{}{\\,\\}}");
Y("\\angln", "{\\angl n}");
Y("\\blue", "\\textcolor{##6495ed}{#1}");
Y("\\orange", "\\textcolor{##ffa500}{#1}");
Y("\\pink", "\\textcolor{##ff00af}{#1}");
Y("\\red", "\\textcolor{##df0030}{#1}");
Y("\\green", "\\textcolor{##28ae7b}{#1}");
Y("\\gray", "\\textcolor{gray}{#1}");
Y("\\purple", "\\textcolor{##9d38bd}{#1}");
Y("\\blueA", "\\textcolor{##ccfaff}{#1}");
Y("\\blueB", "\\textcolor{##80f6ff}{#1}");
Y("\\blueC", "\\textcolor{##63d9ea}{#1}");
Y("\\blueD", "\\textcolor{##11accd}{#1}");
Y("\\blueE", "\\textcolor{##0c7f99}{#1}");
Y("\\tealA", "\\textcolor{##94fff5}{#1}");
Y("\\tealB", "\\textcolor{##26edd5}{#1}");
Y("\\tealC", "\\textcolor{##01d1c1}{#1}");
Y("\\tealD", "\\textcolor{##01a995}{#1}");
Y("\\tealE", "\\textcolor{##208170}{#1}");
Y("\\greenA", "\\textcolor{##b6ffb0}{#1}");
Y("\\greenB", "\\textcolor{##8af281}{#1}");
Y("\\greenC", "\\textcolor{##74cf70}{#1}");
Y("\\greenD", "\\textcolor{##1fab54}{#1}");
Y("\\greenE", "\\textcolor{##0d923f}{#1}");
Y("\\goldA", "\\textcolor{##ffd0a9}{#1}");
Y("\\goldB", "\\textcolor{##ffbb71}{#1}");
Y("\\goldC", "\\textcolor{##ff9c39}{#1}");
Y("\\goldD", "\\textcolor{##e07d10}{#1}");
Y("\\goldE", "\\textcolor{##a75a05}{#1}");
Y("\\redA", "\\textcolor{##fca9a9}{#1}");
Y("\\redB", "\\textcolor{##ff8482}{#1}");
Y("\\redC", "\\textcolor{##f9685d}{#1}");
Y("\\redD", "\\textcolor{##e84d39}{#1}");
Y("\\redE", "\\textcolor{##bc2612}{#1}");
Y("\\maroonA", "\\textcolor{##ffbde0}{#1}");
Y("\\maroonB", "\\textcolor{##ff92c6}{#1}");
Y("\\maroonC", "\\textcolor{##ed5fa6}{#1}");
Y("\\maroonD", "\\textcolor{##ca337c}{#1}");
Y("\\maroonE", "\\textcolor{##9e034e}{#1}");
Y("\\purpleA", "\\textcolor{##ddd7ff}{#1}");
Y("\\purpleB", "\\textcolor{##c6b9fc}{#1}");
Y("\\purpleC", "\\textcolor{##aa87ff}{#1}");
Y("\\purpleD", "\\textcolor{##7854ab}{#1}");
Y("\\purpleE", "\\textcolor{##543b78}{#1}");
Y("\\mintA", "\\textcolor{##f5f9e8}{#1}");
Y("\\mintB", "\\textcolor{##edf2df}{#1}");
Y("\\mintC", "\\textcolor{##e0e5cc}{#1}");
Y("\\grayA", "\\textcolor{##f6f7f7}{#1}");
Y("\\grayB", "\\textcolor{##f0f1f2}{#1}");
Y("\\grayC", "\\textcolor{##e3e5e6}{#1}");
Y("\\grayD", "\\textcolor{##d6d8da}{#1}");
Y("\\grayE", "\\textcolor{##babec2}{#1}");
Y("\\grayF", "\\textcolor{##888d93}{#1}");
Y("\\grayG", "\\textcolor{##626569}{#1}");
Y("\\grayH", "\\textcolor{##3b3e40}{#1}");
Y("\\grayI", "\\textcolor{##21242c}{#1}");
Y("\\kaBlue", "\\textcolor{##314453}{#1}");
Y("\\kaGreen", "\\textcolor{##71B307}{#1}");
var MF = {
  "^": !0,
  // Parser.js
  _: !0,
  // Parser.js
  "\\limits": !0,
  // Parser.js
  "\\nolimits": !0
  // Parser.js
};
class Eme {
  constructor(e, r, n) {
    this.settings = void 0, this.expansionCount = void 0, this.lexer = void 0, this.macros = void 0, this.stack = void 0, this.mode = void 0, this.settings = r, this.expansionCount = 0, this.feed(e), this.macros = new xme(wme, r.macros), this.mode = n, this.stack = [];
  }
  /**
   * Feed a new input string to the same MacroExpander
   * (with existing macros etc.).
   */
  feed(e) {
    this.lexer = new S7(e, this.settings);
  }
  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(e) {
    this.mode = e;
  }
  /**
   * Start a new group nesting within all namespaces.
   */
  beginGroup() {
    this.macros.beginGroup();
  }
  /**
   * End current group nesting within all namespaces.
   */
  endGroup() {
    this.macros.endGroup();
  }
  /**
   * Ends all currently nested groups (if any), restoring values before the
   * groups began.  Useful in case of an error in the middle of parsing.
   */
  endGroups() {
    this.macros.endGroups();
  }
  /**
   * Returns the topmost token on the stack, without expanding it.
   * Similar in behavior to TeX's `\futurelet`.
   */
  future() {
    return this.stack.length === 0 && this.pushToken(this.lexer.lex()), this.stack[this.stack.length - 1];
  }
  /**
   * Remove and return the next unexpanded token.
   */
  popToken() {
    return this.future(), this.stack.pop();
  }
  /**
   * Add a given token to the token stack.  In particular, this get be used
   * to put back a token returned from one of the other methods.
   */
  pushToken(e) {
    this.stack.push(e);
  }
  /**
   * Append an array of tokens to the token stack.
   */
  pushTokens(e) {
    this.stack.push(...e);
  }
  /**
   * Find an macro argument without expanding tokens and append the array of
   * tokens to the token stack. Uses Token as a container for the result.
   */
  scanArgument(e) {
    var r, n, a;
    if (e) {
      if (this.consumeSpaces(), this.future().text !== "[")
        return null;
      r = this.popToken(), {
        tokens: a,
        end: n
      } = this.consumeArg(["]"]);
    } else
      ({
        tokens: a,
        start: r,
        end: n
      } = this.consumeArg());
    return this.pushToken(new ei("EOF", n.loc)), this.pushTokens(a), new ei("", Ea.range(r, n));
  }
  /**
   * Consume all following space tokens, without expansion.
   */
  consumeSpaces() {
    for (; ; ) {
      var e = this.future();
      if (e.text === " ")
        this.stack.pop();
      else
        break;
    }
  }
  /**
   * Consume an argument from the token stream, and return the resulting array
   * of tokens and start/end token.
   */
  consumeArg(e) {
    var r = [], n = e && e.length > 0;
    n || this.consumeSpaces();
    var a = this.future(), i, s = 0, o = 0;
    do {
      if (i = this.popToken(), r.push(i), i.text === "{")
        ++s;
      else if (i.text === "}") {
        if (--s, s === -1)
          throw new Ve("Extra }", i);
      } else if (i.text === "EOF")
        throw new Ve("Unexpected end of input in a macro argument, expected '" + (e && n ? e[o] : "}") + "'", i);
      if (e && n)
        if ((s === 0 || s === 1 && e[o] === "{") && i.text === e[o]) {
          if (++o, o === e.length) {
            r.splice(-o, o);
            break;
          }
        } else
          o = 0;
    } while (s !== 0 || n);
    return a.text === "{" && r[r.length - 1].text === "}" && (r.pop(), r.shift()), r.reverse(), {
      tokens: r,
      start: a,
      end: i
    };
  }
  /**
   * Consume the specified number of (delimited) arguments from the token
   * stream and return the resulting array of arguments.
   */
  consumeArgs(e, r) {
    if (r) {
      if (r.length !== e + 1)
        throw new Ve("The length of delimiters doesn't match the number of args!");
      for (var n = r[0], a = 0; a < n.length; a++) {
        var i = this.popToken();
        if (n[a] !== i.text)
          throw new Ve("Use of the macro doesn't match its definition", i);
      }
    }
    for (var s = [], o = 0; o < e; o++)
      s.push(this.consumeArg(r && r[o + 1]).tokens);
    return s;
  }
  /**
   * Increment `expansionCount` by the specified amount.
   * Throw an error if it exceeds `maxExpand`.
   */
  countExpansion(e) {
    if (this.expansionCount += e, this.expansionCount > this.settings.maxExpand)
      throw new Ve("Too many expansions: infinite loop or need to increase maxExpand setting");
  }
  /**
   * Expand the next token only once if possible.
   *
   * If the token is expanded, the resulting tokens will be pushed onto
   * the stack in reverse order, and the number of such tokens will be
   * returned.  This number might be zero or positive.
   *
   * If not, the return value is `false`, and the next token remains at the
   * top of the stack.
   *
   * In either case, the next token will be on the top of the stack,
   * or the stack will be empty (in case of empty expansion
   * and no other tokens).
   *
   * Used to implement `expandAfterFuture` and `expandNextToken`.
   *
   * If expandableOnly, only expandable tokens are expanded and
   * an undefined control sequence results in an error.
   */
  expandOnce(e) {
    var r = this.popToken(), n = r.text, a = r.noexpand ? null : this._getExpansion(n);
    if (a == null || e && a.unexpandable) {
      if (e && a == null && n[0] === "\\" && !this.isDefined(n))
        throw new Ve("Undefined control sequence: " + n);
      return this.pushToken(r), !1;
    }
    this.countExpansion(1);
    var i = a.tokens, s = this.consumeArgs(a.numArgs, a.delimiters);
    if (a.numArgs) {
      i = i.slice();
      for (var o = i.length - 1; o >= 0; --o) {
        var l = i[o];
        if (l.text === "#") {
          if (o === 0)
            throw new Ve("Incomplete placeholder at end of macro body", l);
          if (l = i[--o], l.text === "#")
            i.splice(o + 1, 1);
          else if (/^[1-9]$/.test(l.text))
            i.splice(o, 2, ...s[+l.text - 1]);
          else
            throw new Ve("Not a valid argument number", l);
        }
      }
    }
    return this.pushTokens(i), i.length;
  }
  /**
   * Expand the next token only once (if possible), and return the resulting
   * top token on the stack (without removing anything from the stack).
   * Similar in behavior to TeX's `\expandafter\futurelet`.
   * Equivalent to expandOnce() followed by future().
   */
  expandAfterFuture() {
    return this.expandOnce(), this.future();
  }
  /**
   * Recursively expand first token, then return first non-expandable token.
   */
  expandNextToken() {
    for (; ; )
      if (this.expandOnce() === !1) {
        var e = this.stack.pop();
        return e.treatAsRelax && (e.text = "\\relax"), e;
      }
    throw new Error();
  }
  /**
   * Fully expand the given macro name and return the resulting list of
   * tokens, or return `undefined` if no such macro is defined.
   */
  expandMacro(e) {
    return this.macros.has(e) ? this.expandTokens([new ei(e)]) : void 0;
  }
  /**
   * Fully expand the given token stream and return the resulting list of
   * tokens.  Note that the input tokens are in reverse order, but the
   * output tokens are in forward order.
   */
  expandTokens(e) {
    var r = [], n = this.stack.length;
    for (this.pushTokens(e); this.stack.length > n; )
      if (this.expandOnce(!0) === !1) {
        var a = this.stack.pop();
        a.treatAsRelax && (a.noexpand = !1, a.treatAsRelax = !1), r.push(a);
      }
    return this.countExpansion(r.length), r;
  }
  /**
   * Fully expand the given macro name and return the result as a string,
   * or return `undefined` if no such macro is defined.
   */
  expandMacroAsText(e) {
    var r = this.expandMacro(e);
    return r && r.map((n) => n.text).join("");
  }
  /**
   * Returns the expanded macro as a reversed array of tokens and a macro
   * argument count.  Or returns `null` if no such macro.
   */
  _getExpansion(e) {
    var r = this.macros.get(e);
    if (r == null)
      return r;
    if (e.length === 1) {
      var n = this.lexer.catcodes[e];
      if (n != null && n !== 13)
        return;
    }
    var a = typeof r == "function" ? r(this) : r;
    if (typeof a == "string") {
      var i = 0;
      if (a.indexOf("#") !== -1)
        for (var s = a.replace(/##/g, ""); s.indexOf("#" + (i + 1)) !== -1; )
          ++i;
      for (var o = new S7(a, this.settings), l = [], u = o.lex(); u.text !== "EOF"; )
        l.push(u), u = o.lex();
      l.reverse();
      var c = {
        tokens: l,
        numArgs: i
      };
      return c;
    }
    return a;
  }
  /**
   * Determine whether a command is currently "defined" (has some
   * functionality), meaning that it's a macro (in the current group),
   * a function, a symbol, or one of the special commands listed in
   * `implicitCommands`.
   */
  isDefined(e) {
    return this.macros.has(e) || Io.hasOwnProperty(e) || Mr.math.hasOwnProperty(e) || Mr.text.hasOwnProperty(e) || MF.hasOwnProperty(e);
  }
  /**
   * Determine whether a command is expandable.
   */
  isExpandable(e) {
    var r = this.macros.get(e);
    return r != null ? typeof r == "string" || typeof r == "function" || !r.unexpandable : Io.hasOwnProperty(e) && !Io[e].primitive;
  }
}
var k7 = /^[₊₋₌₍₎₀₁₂₃₄₅₆₇₈₉ₐₑₕᵢⱼₖₗₘₙₒₚᵣₛₜᵤᵥₓᵦᵧᵨᵩᵪ]/, sg = Object.freeze({
  "₊": "+",
  "₋": "-",
  "₌": "=",
  "₍": "(",
  "₎": ")",
  "₀": "0",
  "₁": "1",
  "₂": "2",
  "₃": "3",
  "₄": "4",
  "₅": "5",
  "₆": "6",
  "₇": "7",
  "₈": "8",
  "₉": "9",
  "ₐ": "a",
  "ₑ": "e",
  "ₕ": "h",
  "ᵢ": "i",
  "ⱼ": "j",
  "ₖ": "k",
  "ₗ": "l",
  "ₘ": "m",
  "ₙ": "n",
  "ₒ": "o",
  "ₚ": "p",
  "ᵣ": "r",
  "ₛ": "s",
  "ₜ": "t",
  "ᵤ": "u",
  "ᵥ": "v",
  "ₓ": "x",
  "ᵦ": "β",
  "ᵧ": "γ",
  "ᵨ": "ρ",
  "ᵩ": "ϕ",
  "ᵪ": "χ",
  "⁺": "+",
  "⁻": "-",
  "⁼": "=",
  "⁽": "(",
  "⁾": ")",
  "⁰": "0",
  "¹": "1",
  "²": "2",
  "³": "3",
  "⁴": "4",
  "⁵": "5",
  "⁶": "6",
  "⁷": "7",
  "⁸": "8",
  "⁹": "9",
  "ᴬ": "A",
  "ᴮ": "B",
  "ᴰ": "D",
  "ᴱ": "E",
  "ᴳ": "G",
  "ᴴ": "H",
  "ᴵ": "I",
  "ᴶ": "J",
  "ᴷ": "K",
  "ᴸ": "L",
  "ᴹ": "M",
  "ᴺ": "N",
  "ᴼ": "O",
  "ᴾ": "P",
  "ᴿ": "R",
  "ᵀ": "T",
  "ᵁ": "U",
  "ⱽ": "V",
  "ᵂ": "W",
  "ᵃ": "a",
  "ᵇ": "b",
  "ᶜ": "c",
  "ᵈ": "d",
  "ᵉ": "e",
  "ᶠ": "f",
  "ᵍ": "g",
  ʰ: "h",
  "ⁱ": "i",
  ʲ: "j",
  "ᵏ": "k",
  ˡ: "l",
  "ᵐ": "m",
  ⁿ: "n",
  "ᵒ": "o",
  "ᵖ": "p",
  ʳ: "r",
  ˢ: "s",
  "ᵗ": "t",
  "ᵘ": "u",
  "ᵛ": "v",
  ʷ: "w",
  ˣ: "x",
  ʸ: "y",
  "ᶻ": "z",
  "ᵝ": "β",
  "ᵞ": "γ",
  "ᵟ": "δ",
  "ᵠ": "ϕ",
  "ᵡ": "χ",
  "ᶿ": "θ"
}), jx = {
  "́": {
    text: "\\'",
    math: "\\acute"
  },
  "̀": {
    text: "\\`",
    math: "\\grave"
  },
  "̈": {
    text: '\\"',
    math: "\\ddot"
  },
  "̃": {
    text: "\\~",
    math: "\\tilde"
  },
  "̄": {
    text: "\\=",
    math: "\\bar"
  },
  "̆": {
    text: "\\u",
    math: "\\breve"
  },
  "̌": {
    text: "\\v",
    math: "\\check"
  },
  "̂": {
    text: "\\^",
    math: "\\hat"
  },
  "̇": {
    text: "\\.",
    math: "\\dot"
  },
  "̊": {
    text: "\\r",
    math: "\\mathring"
  },
  "̋": {
    text: "\\H"
  },
  "̧": {
    text: "\\c"
  }
}, R7 = {
  á: "á",
  à: "à",
  ä: "ä",
  ǟ: "ǟ",
  ã: "ã",
  ā: "ā",
  ă: "ă",
  ắ: "ắ",
  ằ: "ằ",
  ẵ: "ẵ",
  ǎ: "ǎ",
  â: "â",
  ấ: "ấ",
  ầ: "ầ",
  ẫ: "ẫ",
  ȧ: "ȧ",
  ǡ: "ǡ",
  å: "å",
  ǻ: "ǻ",
  ḃ: "ḃ",
  ć: "ć",
  ḉ: "ḉ",
  č: "č",
  ĉ: "ĉ",
  ċ: "ċ",
  ç: "ç",
  ď: "ď",
  ḋ: "ḋ",
  ḑ: "ḑ",
  é: "é",
  è: "è",
  ë: "ë",
  ẽ: "ẽ",
  ē: "ē",
  ḗ: "ḗ",
  ḕ: "ḕ",
  ĕ: "ĕ",
  ḝ: "ḝ",
  ě: "ě",
  ê: "ê",
  ế: "ế",
  ề: "ề",
  ễ: "ễ",
  ė: "ė",
  ȩ: "ȩ",
  ḟ: "ḟ",
  ǵ: "ǵ",
  ḡ: "ḡ",
  ğ: "ğ",
  ǧ: "ǧ",
  ĝ: "ĝ",
  ġ: "ġ",
  ģ: "ģ",
  ḧ: "ḧ",
  ȟ: "ȟ",
  ĥ: "ĥ",
  ḣ: "ḣ",
  ḩ: "ḩ",
  í: "í",
  ì: "ì",
  ï: "ï",
  ḯ: "ḯ",
  ĩ: "ĩ",
  ī: "ī",
  ĭ: "ĭ",
  ǐ: "ǐ",
  î: "î",
  ǰ: "ǰ",
  ĵ: "ĵ",
  ḱ: "ḱ",
  ǩ: "ǩ",
  ķ: "ķ",
  ĺ: "ĺ",
  ľ: "ľ",
  ļ: "ļ",
  ḿ: "ḿ",
  ṁ: "ṁ",
  ń: "ń",
  ǹ: "ǹ",
  ñ: "ñ",
  ň: "ň",
  ṅ: "ṅ",
  ņ: "ņ",
  ó: "ó",
  ò: "ò",
  ö: "ö",
  ȫ: "ȫ",
  õ: "õ",
  ṍ: "ṍ",
  ṏ: "ṏ",
  ȭ: "ȭ",
  ō: "ō",
  ṓ: "ṓ",
  ṑ: "ṑ",
  ŏ: "ŏ",
  ǒ: "ǒ",
  ô: "ô",
  ố: "ố",
  ồ: "ồ",
  ỗ: "ỗ",
  ȯ: "ȯ",
  ȱ: "ȱ",
  ő: "ő",
  ṕ: "ṕ",
  ṗ: "ṗ",
  ŕ: "ŕ",
  ř: "ř",
  ṙ: "ṙ",
  ŗ: "ŗ",
  ś: "ś",
  ṥ: "ṥ",
  š: "š",
  ṧ: "ṧ",
  ŝ: "ŝ",
  ṡ: "ṡ",
  ş: "ş",
  ẗ: "ẗ",
  ť: "ť",
  ṫ: "ṫ",
  ţ: "ţ",
  ú: "ú",
  ù: "ù",
  ü: "ü",
  ǘ: "ǘ",
  ǜ: "ǜ",
  ǖ: "ǖ",
  ǚ: "ǚ",
  ũ: "ũ",
  ṹ: "ṹ",
  ū: "ū",
  ṻ: "ṻ",
  ŭ: "ŭ",
  ǔ: "ǔ",
  û: "û",
  ů: "ů",
  ű: "ű",
  ṽ: "ṽ",
  ẃ: "ẃ",
  ẁ: "ẁ",
  ẅ: "ẅ",
  ŵ: "ŵ",
  ẇ: "ẇ",
  ẘ: "ẘ",
  ẍ: "ẍ",
  ẋ: "ẋ",
  ý: "ý",
  ỳ: "ỳ",
  ÿ: "ÿ",
  ỹ: "ỹ",
  ȳ: "ȳ",
  ŷ: "ŷ",
  ẏ: "ẏ",
  ẙ: "ẙ",
  ź: "ź",
  ž: "ž",
  ẑ: "ẑ",
  ż: "ż",
  Á: "Á",
  À: "À",
  Ä: "Ä",
  Ǟ: "Ǟ",
  Ã: "Ã",
  Ā: "Ā",
  Ă: "Ă",
  Ắ: "Ắ",
  Ằ: "Ằ",
  Ẵ: "Ẵ",
  Ǎ: "Ǎ",
  Â: "Â",
  Ấ: "Ấ",
  Ầ: "Ầ",
  Ẫ: "Ẫ",
  Ȧ: "Ȧ",
  Ǡ: "Ǡ",
  Å: "Å",
  Ǻ: "Ǻ",
  Ḃ: "Ḃ",
  Ć: "Ć",
  Ḉ: "Ḉ",
  Č: "Č",
  Ĉ: "Ĉ",
  Ċ: "Ċ",
  Ç: "Ç",
  Ď: "Ď",
  Ḋ: "Ḋ",
  Ḑ: "Ḑ",
  É: "É",
  È: "È",
  Ë: "Ë",
  Ẽ: "Ẽ",
  Ē: "Ē",
  Ḗ: "Ḗ",
  Ḕ: "Ḕ",
  Ĕ: "Ĕ",
  Ḝ: "Ḝ",
  Ě: "Ě",
  Ê: "Ê",
  Ế: "Ế",
  Ề: "Ề",
  Ễ: "Ễ",
  Ė: "Ė",
  Ȩ: "Ȩ",
  Ḟ: "Ḟ",
  Ǵ: "Ǵ",
  Ḡ: "Ḡ",
  Ğ: "Ğ",
  Ǧ: "Ǧ",
  Ĝ: "Ĝ",
  Ġ: "Ġ",
  Ģ: "Ģ",
  Ḧ: "Ḧ",
  Ȟ: "Ȟ",
  Ĥ: "Ĥ",
  Ḣ: "Ḣ",
  Ḩ: "Ḩ",
  Í: "Í",
  Ì: "Ì",
  Ï: "Ï",
  Ḯ: "Ḯ",
  Ĩ: "Ĩ",
  Ī: "Ī",
  Ĭ: "Ĭ",
  Ǐ: "Ǐ",
  Î: "Î",
  İ: "İ",
  Ĵ: "Ĵ",
  Ḱ: "Ḱ",
  Ǩ: "Ǩ",
  Ķ: "Ķ",
  Ĺ: "Ĺ",
  Ľ: "Ľ",
  Ļ: "Ļ",
  Ḿ: "Ḿ",
  Ṁ: "Ṁ",
  Ń: "Ń",
  Ǹ: "Ǹ",
  Ñ: "Ñ",
  Ň: "Ň",
  Ṅ: "Ṅ",
  Ņ: "Ņ",
  Ó: "Ó",
  Ò: "Ò",
  Ö: "Ö",
  Ȫ: "Ȫ",
  Õ: "Õ",
  Ṍ: "Ṍ",
  Ṏ: "Ṏ",
  Ȭ: "Ȭ",
  Ō: "Ō",
  Ṓ: "Ṓ",
  Ṑ: "Ṑ",
  Ŏ: "Ŏ",
  Ǒ: "Ǒ",
  Ô: "Ô",
  Ố: "Ố",
  Ồ: "Ồ",
  Ỗ: "Ỗ",
  Ȯ: "Ȯ",
  Ȱ: "Ȱ",
  Ő: "Ő",
  Ṕ: "Ṕ",
  Ṗ: "Ṗ",
  Ŕ: "Ŕ",
  Ř: "Ř",
  Ṙ: "Ṙ",
  Ŗ: "Ŗ",
  Ś: "Ś",
  Ṥ: "Ṥ",
  Š: "Š",
  Ṧ: "Ṧ",
  Ŝ: "Ŝ",
  Ṡ: "Ṡ",
  Ş: "Ş",
  Ť: "Ť",
  Ṫ: "Ṫ",
  Ţ: "Ţ",
  Ú: "Ú",
  Ù: "Ù",
  Ü: "Ü",
  Ǘ: "Ǘ",
  Ǜ: "Ǜ",
  Ǖ: "Ǖ",
  Ǚ: "Ǚ",
  Ũ: "Ũ",
  Ṹ: "Ṹ",
  Ū: "Ū",
  Ṻ: "Ṻ",
  Ŭ: "Ŭ",
  Ǔ: "Ǔ",
  Û: "Û",
  Ů: "Ů",
  Ű: "Ű",
  Ṽ: "Ṽ",
  Ẃ: "Ẃ",
  Ẁ: "Ẁ",
  Ẅ: "Ẅ",
  Ŵ: "Ŵ",
  Ẇ: "Ẇ",
  Ẍ: "Ẍ",
  Ẋ: "Ẋ",
  Ý: "Ý",
  Ỳ: "Ỳ",
  Ÿ: "Ÿ",
  Ỹ: "Ỹ",
  Ȳ: "Ȳ",
  Ŷ: "Ŷ",
  Ẏ: "Ẏ",
  Ź: "Ź",
  Ž: "Ž",
  Ẑ: "Ẑ",
  Ż: "Ż",
  ά: "ά",
  ὰ: "ὰ",
  ᾱ: "ᾱ",
  ᾰ: "ᾰ",
  έ: "έ",
  ὲ: "ὲ",
  ή: "ή",
  ὴ: "ὴ",
  ί: "ί",
  ὶ: "ὶ",
  ϊ: "ϊ",
  ΐ: "ΐ",
  ῒ: "ῒ",
  ῑ: "ῑ",
  ῐ: "ῐ",
  ό: "ό",
  ὸ: "ὸ",
  ύ: "ύ",
  ὺ: "ὺ",
  ϋ: "ϋ",
  ΰ: "ΰ",
  ῢ: "ῢ",
  ῡ: "ῡ",
  ῠ: "ῠ",
  ώ: "ώ",
  ὼ: "ὼ",
  Ύ: "Ύ",
  Ὺ: "Ὺ",
  Ϋ: "Ϋ",
  Ῡ: "Ῡ",
  Ῠ: "Ῠ",
  Ώ: "Ώ",
  Ὼ: "Ὼ"
};
let _F = class LF {
  constructor(e, r) {
    this.mode = void 0, this.gullet = void 0, this.settings = void 0, this.leftrightDepth = void 0, this.nextToken = void 0, this.mode = "math", this.gullet = new Eme(e, r, this.mode), this.settings = r, this.leftrightDepth = 0;
  }
  /**
   * Checks a result to make sure it has the right type, and throws an
   * appropriate error otherwise.
   */
  expect(e, r) {
    if (r === void 0 && (r = !0), this.fetch().text !== e)
      throw new Ve("Expected '" + e + "', got '" + this.fetch().text + "'", this.fetch());
    r && this.consume();
  }
  /**
   * Discards the current lookahead token, considering it consumed.
   */
  consume() {
    this.nextToken = null;
  }
  /**
   * Return the current lookahead token, or if there isn't one (at the
   * beginning, or if the previous lookahead token was consume()d),
   * fetch the next token as the new lookahead token and return it.
   */
  fetch() {
    return this.nextToken == null && (this.nextToken = this.gullet.expandNextToken()), this.nextToken;
  }
  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(e) {
    this.mode = e, this.gullet.switchMode(e);
  }
  /**
   * Main parsing function, which parses an entire input.
   */
  parse() {
    this.settings.globalGroup || this.gullet.beginGroup(), this.settings.colorIsTextColor && this.gullet.macros.set("\\color", "\\textcolor");
    try {
      var e = this.parseExpression(!1);
      return this.expect("EOF"), this.settings.globalGroup || this.gullet.endGroup(), e;
    } finally {
      this.gullet.endGroups();
    }
  }
  /**
   * Fully parse a separate sequence of tokens as a separate job.
   * Tokens should be specified in reverse order, as in a MacroDefinition.
   */
  subparse(e) {
    var r = this.nextToken;
    this.consume(), this.gullet.pushToken(new ei("}")), this.gullet.pushTokens(e);
    var n = this.parseExpression(!1);
    return this.expect("}"), this.nextToken = r, n;
  }
  /**
   * Parses an "expression", which is a list of atoms.
   *
   * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
   *                 happens when functions have higher precedence han infix
   *                 nodes in implicit parses.
   *
   * `breakOnTokenText`: The text of the token that the expression should end
   *                     with, or `null` if something else should end the
   *                     expression.
   */
  parseExpression(e, r) {
    for (var n = []; ; ) {
      this.mode === "math" && this.consumeSpaces();
      var a = this.fetch();
      if (LF.endOfExpression.indexOf(a.text) !== -1 || r && a.text === r || e && Io[a.text] && Io[a.text].infix)
        break;
      var i = this.parseAtom(r);
      if (i) {
        if (i.type === "internal")
          continue;
      } else break;
      n.push(i);
    }
    return this.mode === "text" && this.formLigatures(n), this.handleInfixNodes(n);
  }
  /**
   * Rewrites infix operators such as \over with corresponding commands such
   * as \frac.
   *
   * There can only be one infix operator per group.  If there's more than one
   * then the expression is ambiguous.  This can be resolved by adding {}.
   */
  handleInfixNodes(e) {
    for (var r = -1, n, a = 0; a < e.length; a++)
      if (e[a].type === "infix") {
        if (r !== -1)
          throw new Ve("only one infix operator per group", e[a].token);
        r = a, n = e[a].replaceWith;
      }
    if (r !== -1 && n) {
      var i, s, o = e.slice(0, r), l = e.slice(r + 1);
      o.length === 1 && o[0].type === "ordgroup" ? i = o[0] : i = {
        type: "ordgroup",
        mode: this.mode,
        body: o
      }, l.length === 1 && l[0].type === "ordgroup" ? s = l[0] : s = {
        type: "ordgroup",
        mode: this.mode,
        body: l
      };
      var u;
      return n === "\\\\abovefrac" ? u = this.callFunction(n, [i, e[r], s], []) : u = this.callFunction(n, [i, s], []), [u];
    } else
      return e;
  }
  /**
   * Handle a subscript or superscript with nice errors.
   */
  handleSupSubscript(e) {
    var r = this.fetch(), n = r.text;
    this.consume(), this.consumeSpaces();
    var a;
    do {
      var i;
      a = this.parseGroup(e);
    } while (((i = a) == null ? void 0 : i.type) === "internal");
    if (!a)
      throw new Ve("Expected group after '" + n + "'", r);
    return a;
  }
  /**
   * Converts the textual input of an unsupported command into a text node
   * contained within a color node whose color is determined by errorColor
   */
  formatUnsupportedCmd(e) {
    for (var r = [], n = 0; n < e.length; n++)
      r.push({
        type: "textord",
        mode: "text",
        text: e[n]
      });
    var a = {
      type: "text",
      mode: this.mode,
      body: r
    }, i = {
      type: "color",
      mode: this.mode,
      color: this.settings.errorColor,
      body: [a]
    };
    return i;
  }
  /**
   * Parses a group with optional super/subscripts.
   */
  parseAtom(e) {
    var r = this.parseGroup("atom", e);
    if ((r == null ? void 0 : r.type) === "internal" || this.mode === "text")
      return r;
    for (var n, a; ; ) {
      this.consumeSpaces();
      var i = this.fetch();
      if (i.text === "\\limits" || i.text === "\\nolimits") {
        if (r && r.type === "op") {
          var s = i.text === "\\limits";
          r.limits = s, r.alwaysHandleSupSub = !0;
        } else if (r && r.type === "operatorname")
          r.alwaysHandleSupSub && (r.limits = i.text === "\\limits");
        else
          throw new Ve("Limit controls must follow a math operator", i);
        this.consume();
      } else if (i.text === "^") {
        if (n)
          throw new Ve("Double superscript", i);
        n = this.handleSupSubscript("superscript");
      } else if (i.text === "_") {
        if (a)
          throw new Ve("Double subscript", i);
        a = this.handleSupSubscript("subscript");
      } else if (i.text === "'") {
        if (n)
          throw new Ve("Double superscript", i);
        var o = {
          type: "textord",
          mode: this.mode,
          text: "\\prime"
        }, l = [o];
        for (this.consume(); this.fetch().text === "'"; )
          l.push(o), this.consume();
        this.fetch().text === "^" && l.push(this.handleSupSubscript("superscript")), n = {
          type: "ordgroup",
          mode: this.mode,
          body: l
        };
      } else if (sg[i.text]) {
        var u = k7.test(i.text), c = [];
        for (c.push(new ei(sg[i.text])), this.consume(); ; ) {
          var f = this.fetch().text;
          if (!sg[f] || k7.test(f) !== u)
            break;
          c.unshift(new ei(sg[f])), this.consume();
        }
        var h = this.subparse(c);
        u ? a = {
          type: "ordgroup",
          mode: "math",
          body: h
        } : n = {
          type: "ordgroup",
          mode: "math",
          body: h
        };
      } else
        break;
    }
    return n || a ? {
      type: "supsub",
      mode: this.mode,
      base: r,
      sup: n,
      sub: a
    } : r;
  }
  /**
   * Parses an entire function, including its base and all of its arguments.
   */
  parseFunction(e, r) {
    var n = this.fetch(), a = n.text, i = Io[a];
    if (!i)
      return null;
    if (this.consume(), r && r !== "atom" && !i.allowedInArgument)
      throw new Ve("Got function '" + a + "' with no arguments" + (r ? " as " + r : ""), n);
    if (this.mode === "text" && !i.allowedInText)
      throw new Ve("Can't use function '" + a + "' in text mode", n);
    if (this.mode === "math" && i.allowedInMath === !1)
      throw new Ve("Can't use function '" + a + "' in math mode", n);
    var {
      args: s,
      optArgs: o
    } = this.parseArguments(a, i);
    return this.callFunction(a, s, o, n, e);
  }
  /**
   * Call a function handler with a suitable context and arguments.
   */
  callFunction(e, r, n, a, i) {
    var s = {
      funcName: e,
      parser: this,
      token: a,
      breakOnTokenText: i
    }, o = Io[e];
    if (o && o.handler)
      return o.handler(s, r, n);
    throw new Ve("No function handler for " + e);
  }
  /**
   * Parses the arguments of a function or environment
   */
  parseArguments(e, r) {
    var n = r.numArgs + r.numOptionalArgs;
    if (n === 0)
      return {
        args: [],
        optArgs: []
      };
    for (var a = [], i = [], s = 0; s < n; s++) {
      var o = r.argTypes && r.argTypes[s], l = s < r.numOptionalArgs;
      (r.primitive && o == null || // \sqrt expands into primitive if optional argument doesn't exist
      r.type === "sqrt" && s === 1 && i[0] == null) && (o = "primitive");
      var u = this.parseGroupOfType("argument to '" + e + "'", o, l);
      if (l)
        i.push(u);
      else if (u != null)
        a.push(u);
      else
        throw new Ve("Null argument, please report this as a bug");
    }
    return {
      args: a,
      optArgs: i
    };
  }
  /**
   * Parses a group when the mode is changing.
   */
  parseGroupOfType(e, r, n) {
    switch (r) {
      case "color":
        return this.parseColorGroup(n);
      case "size":
        return this.parseSizeGroup(n);
      case "url":
        return this.parseUrlGroup(n);
      case "math":
      case "text":
        return this.parseArgumentGroup(n, r);
      case "hbox": {
        var a = this.parseArgumentGroup(n, "text");
        return a != null ? {
          type: "styling",
          mode: a.mode,
          body: [a],
          style: "text"
          // simulate \textstyle
        } : null;
      }
      case "raw": {
        var i = this.parseStringGroup("raw", n);
        return i != null ? {
          type: "raw",
          mode: "text",
          string: i.text
        } : null;
      }
      case "primitive": {
        if (n)
          throw new Ve("A primitive argument cannot be optional");
        var s = this.parseGroup(e);
        if (s == null)
          throw new Ve("Expected group as " + e, this.fetch());
        return s;
      }
      case "original":
      case null:
      case void 0:
        return this.parseArgumentGroup(n);
      default:
        throw new Ve("Unknown group type as " + e, this.fetch());
    }
  }
  /**
   * Discard any space tokens, fetching the next non-space token.
   */
  consumeSpaces() {
    for (; this.fetch().text === " "; )
      this.consume();
  }
  /**
   * Parses a group, essentially returning the string formed by the
   * brace-enclosed tokens plus some position information.
   */
  parseStringGroup(e, r) {
    var n = this.gullet.scanArgument(r);
    if (n == null)
      return null;
    for (var a = "", i; (i = this.fetch()).text !== "EOF"; )
      a += i.text, this.consume();
    return this.consume(), n.text = a, n;
  }
  /**
   * Parses a regex-delimited group: the largest sequence of tokens
   * whose concatenated strings match `regex`. Returns the string
   * formed by the tokens plus some position information.
   */
  parseRegexGroup(e, r) {
    for (var n = this.fetch(), a = n, i = "", s; (s = this.fetch()).text !== "EOF" && e.test(i + s.text); )
      a = s, i += a.text, this.consume();
    if (i === "")
      throw new Ve("Invalid " + r + ": '" + n.text + "'", n);
    return n.range(a, i);
  }
  /**
   * Parses a color description.
   */
  parseColorGroup(e) {
    var r = this.parseStringGroup("color", e);
    if (r == null)
      return null;
    var n = /^(#[a-f0-9]{3,4}|#[a-f0-9]{6}|#[a-f0-9]{8}|[a-f0-9]{6}|[a-z]+)$/i.exec(r.text);
    if (!n)
      throw new Ve("Invalid color: '" + r.text + "'", r);
    var a = n[0];
    return /^[0-9a-f]{6}$/i.test(a) && (a = "#" + a), {
      type: "color-token",
      mode: this.mode,
      color: a
    };
  }
  /**
   * Parses a size specification, consisting of magnitude and unit.
   */
  parseSizeGroup(e) {
    var r, n = !1;
    if (this.gullet.consumeSpaces(), !e && this.gullet.future().text !== "{" ? r = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size") : r = this.parseStringGroup("size", e), !r)
      return null;
    !e && r.text.length === 0 && (r.text = "0pt", n = !0);
    var a = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(r.text);
    if (!a)
      throw new Ve("Invalid size: '" + r.text + "'", r);
    var i = {
      number: +(a[1] + a[2]),
      // sign + magnitude, cast to number
      unit: a[3]
    };
    if (!B$(i))
      throw new Ve("Invalid unit: '" + i.unit + "'", r);
    return {
      type: "size",
      mode: this.mode,
      value: i,
      isBlank: n
    };
  }
  /**
   * Parses an URL, checking escaped letters and allowed protocols,
   * and setting the catcode of % as an active character (as in \hyperref).
   */
  parseUrlGroup(e) {
    this.gullet.lexer.setCatcode("%", 13), this.gullet.lexer.setCatcode("~", 12);
    var r = this.parseStringGroup("url", e);
    if (this.gullet.lexer.setCatcode("%", 14), this.gullet.lexer.setCatcode("~", 13), r == null)
      return null;
    var n = r.text.replace(/\\([#$%&~_^{}])/g, "$1");
    return {
      type: "url",
      mode: this.mode,
      url: n
    };
  }
  /**
   * Parses an argument with the mode specified.
   */
  parseArgumentGroup(e, r) {
    var n = this.gullet.scanArgument(e);
    if (n == null)
      return null;
    var a = this.mode;
    r && this.switchMode(r), this.gullet.beginGroup();
    var i = this.parseExpression(!1, "EOF");
    this.expect("EOF"), this.gullet.endGroup();
    var s = {
      type: "ordgroup",
      mode: this.mode,
      loc: n.loc,
      body: i
    };
    return r && this.switchMode(a), s;
  }
  /**
   * Parses an ordinary group, which is either a single nucleus (like "x")
   * or an expression in braces (like "{x+y}") or an implicit group, a group
   * that starts at the current position, and ends right before a higher explicit
   * group ends, or at EOF.
   */
  parseGroup(e, r) {
    var n = this.fetch(), a = n.text, i;
    if (a === "{" || a === "\\begingroup") {
      this.consume();
      var s = a === "{" ? "}" : "\\endgroup";
      this.gullet.beginGroup();
      var o = this.parseExpression(!1, s), l = this.fetch();
      this.expect(s), this.gullet.endGroup(), i = {
        type: "ordgroup",
        mode: this.mode,
        loc: Ea.range(n, l),
        body: o,
        // A group formed by \begingroup...\endgroup is a semi-simple group
        // which doesn't affect spacing in math mode, i.e., is transparent.
        // https://tex.stackexchange.com/questions/1930/when-should-one-
        // use-begingroup-instead-of-bgroup
        semisimple: a === "\\begingroup" || void 0
      };
    } else if (i = this.parseFunction(r, e) || this.parseSymbol(), i == null && a[0] === "\\" && !MF.hasOwnProperty(a)) {
      if (this.settings.throwOnError)
        throw new Ve("Undefined control sequence: " + a, n);
      i = this.formatUnsupportedCmd(a), this.consume();
    }
    return i;
  }
  /**
   * Form ligature-like combinations of characters for text mode.
   * This includes inputs like "--", "---", "``" and "''".
   * The result will simply replace multiple textord nodes with a single
   * character in each value by a single textord node having multiple
   * characters in its value.  The representation is still ASCII source.
   * The group will be modified in place.
   */
  formLigatures(e) {
    for (var r = e.length - 1, n = 0; n < r; ++n) {
      var a = e[n], i = a.text;
      i === "-" && e[n + 1].text === "-" && (n + 1 < r && e[n + 2].text === "-" ? (e.splice(n, 3, {
        type: "textord",
        mode: "text",
        loc: Ea.range(a, e[n + 2]),
        text: "---"
      }), r -= 2) : (e.splice(n, 2, {
        type: "textord",
        mode: "text",
        loc: Ea.range(a, e[n + 1]),
        text: "--"
      }), r -= 1)), (i === "'" || i === "`") && e[n + 1].text === i && (e.splice(n, 2, {
        type: "textord",
        mode: "text",
        loc: Ea.range(a, e[n + 1]),
        text: i + i
      }), r -= 1);
    }
  }
  /**
   * Parse a single symbol out of the string. Here, we handle single character
   * symbols and special functions like \verb.
   */
  parseSymbol() {
    var e = this.fetch(), r = e.text;
    if (/^\\verb[^a-zA-Z]/.test(r)) {
      this.consume();
      var n = r.slice(5), a = n.charAt(0) === "*";
      if (a && (n = n.slice(1)), n.length < 2 || n.charAt(0) !== n.slice(-1))
        throw new Ve(`\\verb assertion failed --
                    please report what input caused this bug`);
      return n = n.slice(1, -1), {
        type: "verb",
        mode: "text",
        body: n,
        star: a
      };
    }
    R7.hasOwnProperty(r[0]) && !Mr[this.mode][r[0]] && (this.settings.strict && this.mode === "math" && this.settings.reportNonstrict("unicodeTextInMathMode", 'Accented Unicode text character "' + r[0] + '" used in math mode', e), r = R7[r[0]] + r.slice(1));
    var i = yme.exec(r);
    i && (r = r.substring(0, i.index), r === "i" ? r = "ı" : r === "j" && (r = "ȷ"));
    var s;
    if (Mr[this.mode][r]) {
      this.settings.strict && this.mode === "math" && u4.indexOf(r) >= 0 && this.settings.reportNonstrict("unicodeTextInMathMode", 'Latin-1/Unicode text character "' + r[0] + '" used in math mode', e);
      var o = Mr[this.mode][r].group, l = Ea.range(e), u;
      if (cve.hasOwnProperty(o)) {
        var c = o;
        u = {
          type: "atom",
          mode: this.mode,
          family: c,
          loc: l,
          text: r
        };
      } else
        u = {
          type: o,
          mode: this.mode,
          loc: l,
          text: r
        };
      s = u;
    } else if (r.charCodeAt(0) >= 128)
      this.settings.strict && ($$(r.charCodeAt(0)) ? this.mode === "math" && this.settings.reportNonstrict("unicodeTextInMathMode", 'Unicode text character "' + r[0] + '" used in math mode', e) : this.settings.reportNonstrict("unknownSymbol", 'Unrecognized Unicode character "' + r[0] + '"' + (" (" + r.charCodeAt(0) + ")"), e)), s = {
        type: "textord",
        mode: "text",
        loc: Ea.range(e),
        text: r
      };
    else
      return null;
    if (this.consume(), i)
      for (var f = 0; f < i[0].length; f++) {
        var h = i[0][f];
        if (!jx[h])
          throw new Ve("Unknown accent ' " + h + "'", e);
        var d = jx[h][this.mode] || jx[h].text;
        if (!d)
          throw new Ve("Accent " + h + " unsupported in " + this.mode + " mode", e);
        s = {
          type: "accent",
          mode: this.mode,
          loc: Ea.range(e),
          label: d,
          isStretchy: !1,
          isShifty: !0,
          // $FlowFixMe
          base: s
        };
      }
    return s;
  }
};
_F.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
var PC = function(e, r) {
  if (!(typeof e == "string" || e instanceof String))
    throw new TypeError("KaTeX can only parse string typed expression");
  var n = new _F(e, r);
  delete n.gullet.macros.current["\\df@tag"];
  var a = n.parse();
  if (delete n.gullet.macros.current["\\current@color"], delete n.gullet.macros.current["\\color"], n.gullet.macros.get("\\df@tag")) {
    if (!r.displayMode)
      throw new Ve("\\tag works only in display equations");
    a = [{
      type: "tag",
      mode: "text",
      body: a,
      tag: n.subparse([new ei("\\df@tag")])
    }];
  }
  return a;
}, DC = function(e, r, n) {
  r.textContent = "";
  var a = z1(e, n).toNode();
  r.appendChild(a);
};
typeof document < "u" && document.compatMode !== "CSS1Compat" && (typeof console < "u" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype."), DC = function() {
  throw new Ve("KaTeX doesn't work in quirks mode.");
});
var NF = function(e, r) {
  var n = z1(e, r).toMarkup();
  return n;
}, OF = function(e, r) {
  var n = new mC(r);
  return PC(e, n);
}, IF = function(e, r, n) {
  if (n.throwOnError || !(e instanceof Ve))
    throw e;
  var a = ye.makeSpan(["katex-error"], [new Ei(r)]);
  return a.setAttribute("title", e.toString()), a.setAttribute("style", "color:" + n.errorColor), a;
}, z1 = function(e, r) {
  var n = new mC(r);
  try {
    var a = PC(e, n);
    return Ove(a, e, n);
  } catch (i) {
    return IF(i, e, n);
  }
}, PF = function(e, r) {
  var n = new mC(r);
  try {
    var a = PC(e, n);
    return Ive(a, e, n);
  } catch (i) {
    return IF(i, e, n);
  }
}, DF = "0.16.25", $F = {
  Span: tp,
  Anchor: xC,
  SymbolNode: Ei,
  SvgNode: ao,
  PathNode: qo,
  LineNode: l4
}, Tme = {
  /**
   * Current KaTeX version
   */
  version: DF,
  /**
   * Renders the given LaTeX into an HTML+MathML combination, and adds
   * it as a child to the specified DOM node.
   */
  render: DC,
  /**
   * Renders the given LaTeX into an HTML+MathML combination string,
   * for sending to the client.
   */
  renderToString: NF,
  /**
   * KaTeX error, usually during parsing.
   */
  ParseError: Ve,
  /**
   * The schema of Settings
   */
  SETTINGS_SCHEMA: Md,
  /**
   * Parses the given LaTeX into KaTeX's internal parse tree structure,
   * without rendering to HTML or MathML.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __parse: OF,
  /**
   * Renders the given LaTeX into an HTML+MathML internal DOM tree
   * representation, without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToDomTree: z1,
  /**
   * Renders the given LaTeX into an HTML internal DOM tree representation,
   * without MathML and without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToHTMLTree: PF,
  /**
   * extends internal font metrics object with a new object
   * each key in the new object represents a font name
  */
  __setFontMetrics: F$,
  /**
   * adds a new symbol to builtin symbols table
   */
  __defineSymbol: P,
  /**
   * adds a new function to builtin function list,
   * which directly produce parse tree elements
   * and have their own html/mathml builders
   */
  __defineFunction: it,
  /**
   * adds a new macro to builtin macro list
   */
  __defineMacro: Y,
  /**
   * Expose the dom tree node types, which can be useful for type checking nodes.
   *
   * NOTE: These methods are not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __domTree: $F
};
const K_e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ParseError: Ve,
  SETTINGS_SCHEMA: Md,
  __defineFunction: it,
  __defineMacro: Y,
  __defineSymbol: P,
  __domTree: $F,
  __parse: OF,
  __renderToDomTree: z1,
  __renderToHTMLTree: PF,
  __setFontMetrics: F$,
  default: Tme,
  get render() {
    return DC;
  },
  renderToString: NF,
  version: DF
}, Symbol.toStringTag, { value: "Module" }));
var Sme = "[object Symbol]";
function nu(t) {
  return typeof t == "symbol" || wi(t) && vo(t) == Sme;
}
function Yl(t, e) {
  for (var r = -1, n = t == null ? 0 : t.length, a = Array(n); ++r < n; )
    a[r] = e(t[r], r, t);
  return a;
}
var M7 = bi ? bi.prototype : void 0, _7 = M7 ? M7.toString : void 0;
function FF(t) {
  if (typeof t == "string")
    return t;
  if (jt(t))
    return Yl(t, FF) + "";
  if (nu(t))
    return _7 ? _7.call(t) : "";
  var e = t + "";
  return e == "0" && 1 / t == -1 / 0 ? "-0" : e;
}
var Cme = /\s/;
function Ame(t) {
  for (var e = t.length; e-- && Cme.test(t.charAt(e)); )
    ;
  return e;
}
var kme = /^\s+/;
function Rme(t) {
  return t && t.slice(0, Ame(t) + 1).replace(kme, "");
}
var L7 = NaN, Mme = /^[-+]0x[0-9a-f]+$/i, _me = /^0b[01]+$/i, Lme = /^0o[0-7]+$/i, Nme = parseInt;
function Ome(t) {
  if (typeof t == "number")
    return t;
  if (nu(t))
    return L7;
  if (Ma(t)) {
    var e = typeof t.valueOf == "function" ? t.valueOf() : t;
    t = Ma(e) ? e + "" : e;
  }
  if (typeof t != "string")
    return t === 0 ? t : +t;
  t = Rme(t);
  var r = _me.test(t);
  return r || Lme.test(t) ? Nme(t.slice(2), r ? 2 : 8) : Mme.test(t) ? L7 : +t;
}
var Ime = 1 / 0, Pme = 17976931348623157e292;
function dv(t) {
  if (!t)
    return t === 0 ? t : 0;
  if (t = Ome(t), t === Ime || t === -1 / 0) {
    var e = t < 0 ? -1 : 1;
    return e * Pme;
  }
  return t === t ? t : 0;
}
function G1(t) {
  var e = dv(t), r = e % 1;
  return e === e ? r ? e - r : e : 0;
}
function dn() {
}
function BF(t, e) {
  for (var r = -1, n = t == null ? 0 : t.length; ++r < n && e(t[r], r, t) !== !1; )
    ;
  return t;
}
function zF(t, e, r, n) {
  for (var a = t.length, i = r + -1; ++i < a; )
    if (e(t[i], i, t))
      return i;
  return -1;
}
function Dme(t) {
  return t !== t;
}
function $me(t, e, r) {
  for (var n = r - 1, a = t.length; ++n < a; )
    if (t[n] === e)
      return n;
  return -1;
}
function $C(t, e, r) {
  return e === e ? $me(t, e, r) : zF(t, Dme, r);
}
function GF(t, e) {
  var r = t == null ? 0 : t.length;
  return !!r && $C(t, e, 0) > -1;
}
function vn(t) {
  return Es(t) ? $9(t) : sD(t);
}
var Fme = Object.prototype, Bme = Fme.hasOwnProperty, ai = G9(function(t, e) {
  if (V0(e) || Es(e)) {
    Tf(e, vn(e), t);
    return;
  }
  for (var r in e)
    Bme.call(e, r) && W0(t, r, e[r]);
}), zme = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Gme = /^\w*$/;
function FC(t, e) {
  if (jt(t))
    return !1;
  var r = typeof t;
  return r == "number" || r == "symbol" || r == "boolean" || t == null || nu(t) ? !0 : Gme.test(t) || !zme.test(t) || e != null && t in Object(e);
}
var Ume = 500;
function Hme(t) {
  var e = C5(t, function(n) {
    return r.size === Ume && r.clear(), n;
  }), r = e.cache;
  return e;
}
var Vme = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, qme = /\\(\\)?/g, Wme = Hme(function(t) {
  var e = [];
  return t.charCodeAt(0) === 46 && e.push(""), t.replace(Vme, function(r, n, a, i) {
    e.push(a ? i.replace(qme, "$1") : n || r);
  }), e;
});
function UF(t) {
  return t == null ? "" : FF(t);
}
function U1(t, e) {
  return jt(t) ? t : FC(t, e) ? [t] : Wme(UF(t));
}
function np(t) {
  if (typeof t == "string" || nu(t))
    return t;
  var e = t + "";
  return e == "0" && 1 / t == -1 / 0 ? "-0" : e;
}
function H1(t, e) {
  e = U1(e, t);
  for (var r = 0, n = e.length; t != null && r < n; )
    t = t[np(e[r++])];
  return r && r == n ? t : void 0;
}
function jme(t, e, r) {
  var n = t == null ? void 0 : H1(t, e);
  return n === void 0 ? r : n;
}
function BC(t, e) {
  for (var r = -1, n = e.length, a = t.length; ++r < n; )
    t[a + r] = e[r];
  return t;
}
var N7 = bi ? bi.isConcatSpreadable : void 0;
function Yme(t) {
  return jt(t) || ef(t) || !!(N7 && t && t[N7]);
}
function ap(t, e, r, n, a) {
  var i = -1, s = t.length;
  for (r || (r = Yme), a || (a = []); ++i < s; ) {
    var o = t[i];
    r(o) ? BC(a, o) : n || (a[a.length] = o);
  }
  return a;
}
function kn(t) {
  var e = t == null ? 0 : t.length;
  return e ? ap(t) : [];
}
function Xme(t) {
  return z9(B9(t, void 0, kn), t + "");
}
function HF(t, e, r) {
  var n = -1, a = t.length;
  e < 0 && (e = -e > a ? 0 : a + e), r = r > a ? a : r, r < 0 && (r += a), a = e > r ? 0 : r - e >>> 0, e >>>= 0;
  for (var i = Array(a); ++n < a; )
    i[n] = t[n + e];
  return i;
}
function Kme(t, e, r, n) {
  var a = -1, i = t == null ? 0 : t.length;
  for (n && i && (r = t[++a]); ++a < i; )
    r = e(r, t[a], a, t);
  return r;
}
function Zme(t, e) {
  return t && Tf(e, vn(e), t);
}
function Qme(t, e) {
  return t && Tf(e, Eu(e), t);
}
function zC(t, e) {
  for (var r = -1, n = t == null ? 0 : t.length, a = 0, i = []; ++r < n; ) {
    var s = t[r];
    e(s, r, t) && (i[a++] = s);
  }
  return i;
}
function VF() {
  return [];
}
var Jme = Object.prototype, eye = Jme.propertyIsEnumerable, O7 = Object.getOwnPropertySymbols, GC = O7 ? function(t) {
  return t == null ? [] : (t = Object(t), zC(O7(t), function(e) {
    return eye.call(t, e);
  }));
} : VF;
function tye(t, e) {
  return Tf(t, GC(t), e);
}
var rye = Object.getOwnPropertySymbols, qF = rye ? function(t) {
  for (var e = []; t; )
    BC(e, GC(t)), t = R5(t);
  return e;
} : VF;
function nye(t, e) {
  return Tf(t, qF(t), e);
}
function WF(t, e, r) {
  var n = e(t);
  return jt(t) ? n : BC(n, r(t));
}
function g4(t) {
  return WF(t, vn, GC);
}
function jF(t) {
  return WF(t, Eu, qF);
}
var aye = Object.prototype, iye = aye.hasOwnProperty;
function sye(t) {
  var e = t.length, r = new t.constructor(e);
  return e && typeof t[0] == "string" && iye.call(t, "index") && (r.index = t.index, r.input = t.input), r;
}
function oye(t, e) {
  var r = e ? k5(t.buffer) : t.buffer;
  return new t.constructor(r, t.byteOffset, t.byteLength);
}
var lye = /\w*$/;
function uye(t) {
  var e = new t.constructor(t.source, lye.exec(t));
  return e.lastIndex = t.lastIndex, e;
}
var I7 = bi ? bi.prototype : void 0, P7 = I7 ? I7.valueOf : void 0;
function cye(t) {
  return P7 ? Object(P7.call(t)) : {};
}
var fye = "[object Boolean]", hye = "[object Date]", dye = "[object Map]", pye = "[object Number]", gye = "[object RegExp]", vye = "[object Set]", mye = "[object String]", yye = "[object Symbol]", bye = "[object ArrayBuffer]", xye = "[object DataView]", wye = "[object Float32Array]", Eye = "[object Float64Array]", Tye = "[object Int8Array]", Sye = "[object Int16Array]", Cye = "[object Int32Array]", Aye = "[object Uint8Array]", kye = "[object Uint8ClampedArray]", Rye = "[object Uint16Array]", Mye = "[object Uint32Array]";
function _ye(t, e, r) {
  var n = t.constructor;
  switch (e) {
    case bye:
      return k5(t);
    case fye:
    case hye:
      return new n(+t);
    case xye:
      return oye(t, r);
    case wye:
    case Eye:
    case Tye:
    case Sye:
    case Cye:
    case Aye:
    case kye:
    case Rye:
    case Mye:
      return M9(t, r);
    case dye:
      return new n();
    case pye:
    case mye:
      return new n(t);
    case gye:
      return uye(t);
    case vye:
      return new n();
    case yye:
      return cye(t);
  }
}
var Lye = "[object Map]";
function Nye(t) {
  return wi(t) && fi(t) == Lye;
}
var D7 = Go && Go.isMap, Oye = D7 ? q0(D7) : Nye, Iye = "[object Set]";
function Pye(t) {
  return wi(t) && fi(t) == Iye;
}
var $7 = Go && Go.isSet, Dye = $7 ? q0($7) : Pye, $ye = 1, Fye = 2, Bye = 4, YF = "[object Arguments]", zye = "[object Array]", Gye = "[object Boolean]", Uye = "[object Date]", Hye = "[object Error]", XF = "[object Function]", Vye = "[object GeneratorFunction]", qye = "[object Map]", Wye = "[object Number]", KF = "[object Object]", jye = "[object RegExp]", Yye = "[object Set]", Xye = "[object String]", Kye = "[object Symbol]", Zye = "[object WeakMap]", Qye = "[object ArrayBuffer]", Jye = "[object DataView]", e1e = "[object Float32Array]", t1e = "[object Float64Array]", r1e = "[object Int8Array]", n1e = "[object Int16Array]", a1e = "[object Int32Array]", i1e = "[object Uint8Array]", s1e = "[object Uint8ClampedArray]", o1e = "[object Uint16Array]", l1e = "[object Uint32Array]", kr = {};
kr[YF] = kr[zye] = kr[Qye] = kr[Jye] = kr[Gye] = kr[Uye] = kr[e1e] = kr[t1e] = kr[r1e] = kr[n1e] = kr[a1e] = kr[qye] = kr[Wye] = kr[KF] = kr[jye] = kr[Yye] = kr[Xye] = kr[Kye] = kr[i1e] = kr[s1e] = kr[o1e] = kr[l1e] = !0;
kr[Hye] = kr[XF] = kr[Zye] = !1;
function Ld(t, e, r, n, a, i) {
  var s, o = e & $ye, l = e & Fye, u = e & Bye;
  if (s !== void 0)
    return s;
  if (!Ma(t))
    return t;
  var c = jt(t);
  if (c) {
    if (s = sye(t), !o)
      return _9(t, s);
  } else {
    var f = fi(t), h = f == XF || f == Vye;
    if (tf(t))
      return R9(t, o);
    if (f == KF || f == YF || h && !a) {
      if (s = l || h ? {} : N9(t), !o)
        return l ? nye(t, Qme(s, t)) : tye(t, Zme(s, t));
    } else {
      if (!kr[f])
        return a ? t : {};
      s = _ye(t, f, o);
    }
  }
  i || (i = new Ui());
  var d = i.get(t);
  if (d)
    return d;
  i.set(t, s), Dye(t) ? t.forEach(function(v) {
    s.add(Ld(v, e, r, v, t, i));
  }) : Oye(t) && t.forEach(function(v, m) {
    s.set(m, Ld(v, e, r, m, t, i));
  });
  var p = u ? l ? jF : g4 : l ? Eu : vn, g = c ? void 0 : p(t);
  return BF(g || t, function(v, m) {
    g && (m = v, v = t[m]), W0(s, m, Ld(v, e, r, m, t, i));
  }), s;
}
var u1e = 4;
function _n(t) {
  return Ld(t, u1e);
}
var c1e = 1, f1e = 4;
function h1e(t) {
  return Ld(t, c1e | f1e);
}
function ip(t) {
  for (var e = -1, r = t == null ? 0 : t.length, n = 0, a = []; ++e < r; ) {
    var i = t[e];
    i && (a[n++] = i);
  }
  return a;
}
var d1e = "__lodash_hash_undefined__";
function p1e(t) {
  return this.__data__.set(t, d1e), this;
}
function g1e(t) {
  return this.__data__.has(t);
}
function of(t) {
  var e = -1, r = t == null ? 0 : t.length;
  for (this.__data__ = new yo(); ++e < r; )
    this.add(t[e]);
}
of.prototype.add = of.prototype.push = p1e;
of.prototype.has = g1e;
function ZF(t, e) {
  for (var r = -1, n = t == null ? 0 : t.length; ++r < n; )
    if (e(t[r], r, t))
      return !0;
  return !1;
}
function UC(t, e) {
  return t.has(e);
}
var v1e = 1, m1e = 2;
function QF(t, e, r, n, a, i) {
  var s = r & v1e, o = t.length, l = e.length;
  if (o != l && !(s && l > o))
    return !1;
  var u = i.get(t), c = i.get(e);
  if (u && c)
    return u == e && c == t;
  var f = -1, h = !0, d = r & m1e ? new of() : void 0;
  for (i.set(t, e), i.set(e, t); ++f < o; ) {
    var p = t[f], g = e[f];
    if (n)
      var v = s ? n(g, p, f, e, t, i) : n(p, g, f, t, e, i);
    if (v !== void 0) {
      if (v)
        continue;
      h = !1;
      break;
    }
    if (d) {
      if (!ZF(e, function(m, b) {
        if (!UC(d, b) && (p === m || a(p, m, r, n, i)))
          return d.push(b);
      })) {
        h = !1;
        break;
      }
    } else if (!(p === g || a(p, g, r, n, i))) {
      h = !1;
      break;
    }
  }
  return i.delete(t), i.delete(e), h;
}
function y1e(t) {
  var e = -1, r = Array(t.size);
  return t.forEach(function(n, a) {
    r[++e] = [a, n];
  }), r;
}
function HC(t) {
  var e = -1, r = Array(t.size);
  return t.forEach(function(n) {
    r[++e] = n;
  }), r;
}
var b1e = 1, x1e = 2, w1e = "[object Boolean]", E1e = "[object Date]", T1e = "[object Error]", S1e = "[object Map]", C1e = "[object Number]", A1e = "[object RegExp]", k1e = "[object Set]", R1e = "[object String]", M1e = "[object Symbol]", _1e = "[object ArrayBuffer]", L1e = "[object DataView]", F7 = bi ? bi.prototype : void 0, Yx = F7 ? F7.valueOf : void 0;
function N1e(t, e, r, n, a, i, s) {
  switch (r) {
    case L1e:
      if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset)
        return !1;
      t = t.buffer, e = e.buffer;
    case _1e:
      return !(t.byteLength != e.byteLength || !i(new cm(t), new cm(e)));
    case w1e:
    case E1e:
    case C1e:
      return Ef(+t, +e);
    case T1e:
      return t.name == e.name && t.message == e.message;
    case A1e:
    case R1e:
      return t == e + "";
    case S1e:
      var o = y1e;
    case k1e:
      var l = n & b1e;
      if (o || (o = HC), t.size != e.size && !l)
        return !1;
      var u = s.get(t);
      if (u)
        return u == e;
      n |= x1e, s.set(t, e);
      var c = QF(o(t), o(e), n, a, i, s);
      return s.delete(t), c;
    case M1e:
      if (Yx)
        return Yx.call(t) == Yx.call(e);
  }
  return !1;
}
var O1e = 1, I1e = Object.prototype, P1e = I1e.hasOwnProperty;
function D1e(t, e, r, n, a, i) {
  var s = r & O1e, o = g4(t), l = o.length, u = g4(e), c = u.length;
  if (l != c && !s)
    return !1;
  for (var f = l; f--; ) {
    var h = o[f];
    if (!(s ? h in e : P1e.call(e, h)))
      return !1;
  }
  var d = i.get(t), p = i.get(e);
  if (d && p)
    return d == e && p == t;
  var g = !0;
  i.set(t, e), i.set(e, t);
  for (var v = s; ++f < l; ) {
    h = o[f];
    var m = t[h], b = e[h];
    if (n)
      var y = s ? n(b, m, h, e, t, i) : n(m, b, h, t, e, i);
    if (!(y === void 0 ? m === b || a(m, b, r, n, i) : y)) {
      g = !1;
      break;
    }
    v || (v = h == "constructor");
  }
  if (g && !v) {
    var x = t.constructor, E = e.constructor;
    x != E && "constructor" in t && "constructor" in e && !(typeof x == "function" && x instanceof x && typeof E == "function" && E instanceof E) && (g = !1);
  }
  return i.delete(t), i.delete(e), g;
}
var $1e = 1, B7 = "[object Arguments]", z7 = "[object Array]", og = "[object Object]", F1e = Object.prototype, G7 = F1e.hasOwnProperty;
function B1e(t, e, r, n, a, i) {
  var s = jt(t), o = jt(e), l = s ? z7 : fi(t), u = o ? z7 : fi(e);
  l = l == B7 ? og : l, u = u == B7 ? og : u;
  var c = l == og, f = u == og, h = l == u;
  if (h && tf(t)) {
    if (!tf(e))
      return !1;
    s = !0, c = !1;
  }
  if (h && !c)
    return i || (i = new Ui()), s || v1(t) ? QF(t, e, r, n, a, i) : N1e(t, e, l, r, n, a, i);
  if (!(r & $1e)) {
    var d = c && G7.call(t, "__wrapped__"), p = f && G7.call(e, "__wrapped__");
    if (d || p) {
      var g = d ? t.value() : t, v = p ? e.value() : e;
      return i || (i = new Ui()), a(g, v, r, n, i);
    }
  }
  return h ? (i || (i = new Ui()), D1e(t, e, r, n, a, i)) : !1;
}
function VC(t, e, r, n, a) {
  return t === e ? !0 : t == null || e == null || !wi(t) && !wi(e) ? t !== t && e !== e : B1e(t, e, r, n, VC, a);
}
var z1e = 1, G1e = 2;
function U1e(t, e, r, n) {
  var a = r.length, i = a;
  if (t == null)
    return !i;
  for (t = Object(t); a--; ) {
    var s = r[a];
    if (s[2] ? s[1] !== t[s[0]] : !(s[0] in t))
      return !1;
  }
  for (; ++a < i; ) {
    s = r[a];
    var o = s[0], l = t[o], u = s[1];
    if (s[2]) {
      if (l === void 0 && !(o in t))
        return !1;
    } else {
      var c = new Ui(), f;
      if (!(f === void 0 ? VC(u, l, z1e | G1e, n, c) : f))
        return !1;
    }
  }
  return !0;
}
function JF(t) {
  return t === t && !Ma(t);
}
function H1e(t) {
  for (var e = vn(t), r = e.length; r--; ) {
    var n = e[r], a = t[n];
    e[r] = [n, a, JF(a)];
  }
  return e;
}
function eB(t, e) {
  return function(r) {
    return r == null ? !1 : r[t] === e && (e !== void 0 || t in Object(r));
  };
}
function V1e(t) {
  var e = H1e(t);
  return e.length == 1 && e[0][2] ? eB(e[0][0], e[0][1]) : function(r) {
    return r === t || U1e(r, t, e);
  };
}
function q1e(t, e) {
  return t != null && e in Object(t);
}
function tB(t, e, r) {
  e = U1(e, t);
  for (var n = -1, a = e.length, i = !1; ++n < a; ) {
    var s = np(e[n]);
    if (!(i = t != null && r(t, s)))
      break;
    t = t[s];
  }
  return i || ++n != a ? i : (a = t == null ? 0 : t.length, !!a && M5(a) && m1(s, a) && (jt(t) || ef(t)));
}
function rB(t, e) {
  return t != null && tB(t, e, q1e);
}
var W1e = 1, j1e = 2;
function Y1e(t, e) {
  return FC(t) && JF(e) ? eB(np(t), e) : function(r) {
    var n = jme(r, t);
    return n === void 0 && n === e ? rB(r, t) : VC(e, n, W1e | j1e);
  };
}
function X1e(t) {
  return function(e) {
    return e == null ? void 0 : e[t];
  };
}
function K1e(t) {
  return function(e) {
    return H1(e, t);
  };
}
function Z1e(t) {
  return FC(t) ? X1e(np(t)) : K1e(t);
}
function Ia(t) {
  return typeof t == "function" ? t : t == null ? no : typeof t == "object" ? jt(t) ? Y1e(t[0], t[1]) : V1e(t) : Z1e(t);
}
function Q1e(t, e, r, n) {
  for (var a = -1, i = t == null ? 0 : t.length; ++a < i; ) {
    var s = t[a];
    e(n, s, r(s), t);
  }
  return n;
}
function qC(t, e) {
  return t && A5(t, e, vn);
}
function J1e(t, e) {
  return function(r, n) {
    if (r == null)
      return r;
    if (!Es(r))
      return t(r, n);
    for (var a = r.length, i = -1, s = Object(r); ++i < a && n(s[i], i, s) !== !1; )
      ;
    return r;
  };
}
var Ru = J1e(qC);
function ebe(t, e, r, n) {
  return Ru(t, function(a, i, s) {
    e(n, a, r(a), s);
  }), n;
}
function tbe(t, e) {
  return function(r, n) {
    var a = jt(r) ? Q1e : ebe, i = e ? e() : {};
    return a(r, t, Ia(n), i);
  };
}
var nB = Object.prototype, rbe = nB.hasOwnProperty, V1 = j0(function(t, e) {
  t = Object(t);
  var r = -1, n = e.length, a = n > 2 ? e[2] : void 0;
  for (a && Qd(e[0], e[1], a) && (n = 1); ++r < n; )
    for (var i = e[r], s = Eu(i), o = -1, l = s.length; ++o < l; ) {
      var u = s[o], c = t[u];
      (c === void 0 || Ef(c, nB[u]) && !rbe.call(t, u)) && (t[u] = i[u]);
    }
  return t;
}), nbe = 200;
function abe(t, e, r, n) {
  var a = -1, i = GF, s = !0, o = t.length, l = [], u = e.length;
  if (!o)
    return l;
  e.length >= nbe && (i = UC, s = !1, e = new of(e));
  e:
    for (; ++a < o; ) {
      var c = t[a], f = c;
      if (c = c !== 0 ? c : 0, s && f === f) {
        for (var h = u; h--; )
          if (e[h] === f)
            continue e;
        l.push(c);
      } else i(e, f, n) || l.push(c);
    }
  return l;
}
var q1 = j0(function(t, e) {
  return fm(t) ? abe(t, ap(e, 1, fm, !0)) : [];
});
function ms(t) {
  var e = t == null ? 0 : t.length;
  return e ? t[e - 1] : void 0;
}
function Dn(t, e, r) {
  var n = t == null ? 0 : t.length;
  return n ? (e = e === void 0 ? 1 : G1(e), HF(t, e < 0 ? 0 : e, n)) : [];
}
function a0(t, e, r) {
  var n = t == null ? 0 : t.length;
  return n ? (e = e === void 0 ? 1 : G1(e), e = n - e, HF(t, 0, e < 0 ? 0 : e)) : [];
}
function WC(t) {
  return typeof t == "function" ? t : no;
}
function ve(t, e) {
  var r = jt(t) ? BF : Ru;
  return r(t, WC(e));
}
function ibe(t, e) {
  for (var r = -1, n = t == null ? 0 : t.length; ++r < n; )
    if (!e(t[r], r, t))
      return !1;
  return !0;
}
function sbe(t, e) {
  var r = !0;
  return Ru(t, function(n, a, i) {
    return r = !!e(n, a, i), r;
  }), r;
}
function Hi(t, e, r) {
  var n = jt(t) ? ibe : sbe;
  return n(t, Ia(e));
}
function aB(t, e) {
  var r = [];
  return Ru(t, function(n, a, i) {
    e(n, a, i) && r.push(n);
  }), r;
}
function Zr(t, e) {
  var r = jt(t) ? zC : aB;
  return r(t, Ia(e));
}
function obe(t) {
  return function(e, r, n) {
    var a = Object(e);
    if (!Es(e)) {
      var i = Ia(r);
      e = vn(e), r = function(o) {
        return i(a[o], o, a);
      };
    }
    var s = t(e, r, n);
    return s > -1 ? a[i ? e[s] : s] : void 0;
  };
}
var lbe = Math.max;
function ube(t, e, r) {
  var n = t == null ? 0 : t.length;
  if (!n)
    return -1;
  var a = r == null ? 0 : G1(r);
  return a < 0 && (a = lbe(n + a, 0)), zF(t, Ia(e), a);
}
var oo = obe(ube);
function Yi(t) {
  return t && t.length ? t[0] : void 0;
}
function iB(t, e) {
  var r = -1, n = Es(t) ? Array(t.length) : [];
  return Ru(t, function(a, i, s) {
    n[++r] = e(a, i, s);
  }), n;
}
function Xe(t, e) {
  var r = jt(t) ? Yl : iB;
  return r(t, Ia(e));
}
function ti(t, e) {
  return ap(Xe(t, e));
}
function cbe(t, e) {
  return t == null ? t : A5(t, WC(e), Eu);
}
function fbe(t, e) {
  return t && qC(t, WC(e));
}
var hbe = Object.prototype, dbe = hbe.hasOwnProperty, pbe = tbe(function(t, e, r) {
  dbe.call(t, r) ? t[r].push(e) : H0(t, r, [e]);
});
function gbe(t, e) {
  return t > e;
}
var vbe = Object.prototype, mbe = vbe.hasOwnProperty;
function ybe(t, e) {
  return t != null && mbe.call(t, e);
}
function Et(t, e) {
  return t != null && tB(t, e, ybe);
}
var bbe = "[object String]";
function _a(t) {
  return typeof t == "string" || !jt(t) && wi(t) && vo(t) == bbe;
}
function xbe(t, e) {
  return Yl(e, function(r) {
    return t[r];
  });
}
function wr(t) {
  return t == null ? [] : xbe(t, vn(t));
}
var wbe = Math.max;
function ya(t, e, r, n) {
  t = Es(t) ? t : wr(t), r = r ? G1(r) : 0;
  var a = t.length;
  return r < 0 && (r = wbe(a + r, 0)), _a(t) ? r <= a && t.indexOf(e, r) > -1 : !!a && $C(t, e, r) > -1;
}
function U7(t, e, r) {
  var n = t == null ? 0 : t.length;
  if (!n)
    return -1;
  var a = 0;
  return $C(t, e, a);
}
var Ebe = "[object RegExp]";
function Tbe(t) {
  return wi(t) && vo(t) == Ebe;
}
var H7 = Go && Go.isRegExp, lo = H7 ? q0(H7) : Tbe;
function dr(t) {
  return t === void 0;
}
function sB(t, e) {
  return t < e;
}
function W1(t, e) {
  var r = {};
  return e = Ia(e), qC(t, function(n, a, i) {
    H0(r, a, e(n, a, i));
  }), r;
}
function jC(t, e, r) {
  for (var n = -1, a = t.length; ++n < a; ) {
    var i = t[n], s = e(i);
    if (s != null && (o === void 0 ? s === s && !nu(s) : r(s, o)))
      var o = s, l = i;
  }
  return l;
}
function au(t) {
  return t && t.length ? jC(t, no, gbe) : void 0;
}
function lf(t) {
  return t && t.length ? jC(t, no, sB) : void 0;
}
function YC(t, e) {
  return t && t.length ? jC(t, Ia(e), sB) : void 0;
}
var Sbe = "Expected a function";
function Cbe(t) {
  if (typeof t != "function")
    throw new TypeError(Sbe);
  return function() {
    var e = arguments;
    switch (e.length) {
      case 0:
        return !t.call(this);
      case 1:
        return !t.call(this, e[0]);
      case 2:
        return !t.call(this, e[0], e[1]);
      case 3:
        return !t.call(this, e[0], e[1], e[2]);
    }
    return !t.apply(this, e);
  };
}
function Abe(t, e, r, n) {
  if (!Ma(t))
    return t;
  e = U1(e, t);
  for (var a = -1, i = e.length, s = i - 1, o = t; o != null && ++a < i; ) {
    var l = np(e[a]), u = r;
    if (l === "__proto__" || l === "constructor" || l === "prototype")
      return t;
    if (a != s) {
      var c = o[l];
      u = void 0, u === void 0 && (u = Ma(c) ? c : m1(e[a + 1]) ? [] : {});
    }
    W0(o, l, u), o = o[l];
  }
  return t;
}
function oB(t, e, r) {
  for (var n = -1, a = e.length, i = {}; ++n < a; ) {
    var s = e[n], o = H1(t, s);
    r(o, s) && Abe(i, U1(s, t), o);
  }
  return i;
}
function Ji(t, e) {
  if (t == null)
    return {};
  var r = Yl(jF(t), function(n) {
    return [n];
  });
  return e = Ia(e), oB(t, r, function(n, a) {
    return e(n, a[0]);
  });
}
function kbe(t, e) {
  var r = t.length;
  for (t.sort(e); r--; )
    t[r] = t[r].value;
  return t;
}
function Rbe(t, e) {
  if (t !== e) {
    var r = t !== void 0, n = t === null, a = t === t, i = nu(t), s = e !== void 0, o = e === null, l = e === e, u = nu(e);
    if (!o && !u && !i && t > e || i && s && l && !o && !u || n && s && l || !r && l || !a)
      return 1;
    if (!n && !i && !u && t < e || u && r && a && !n && !i || o && r && a || !s && a || !l)
      return -1;
  }
  return 0;
}
function Mbe(t, e, r) {
  for (var n = -1, a = t.criteria, i = e.criteria, s = a.length, o = r.length; ++n < s; ) {
    var l = Rbe(a[n], i[n]);
    if (l) {
      if (n >= o)
        return l;
      var u = r[n];
      return l * (u == "desc" ? -1 : 1);
    }
  }
  return t.index - e.index;
}
function _be(t, e, r) {
  e.length ? e = Yl(e, function(i) {
    return jt(i) ? function(s) {
      return H1(s, i.length === 1 ? i[0] : i);
    } : i;
  }) : e = [no];
  var n = -1;
  e = Yl(e, q0(Ia));
  var a = iB(t, function(i, s, o) {
    var l = Yl(e, function(u) {
      return u(i);
    });
    return { criteria: l, index: ++n, value: i };
  });
  return kbe(a, function(i, s) {
    return Mbe(i, s, r);
  });
}
function Lbe(t, e) {
  return oB(t, e, function(r, n) {
    return rB(t, n);
  });
}
var Im = Xme(function(t, e) {
  return t == null ? {} : Lbe(t, e);
}), Nbe = Math.ceil, Obe = Math.max;
function Ibe(t, e, r, n) {
  for (var a = -1, i = Obe(Nbe((e - t) / (r || 1)), 0), s = Array(i); i--; )
    s[++a] = t, t += r;
  return s;
}
function Pbe(t) {
  return function(e, r, n) {
    return n && typeof n != "number" && Qd(e, r, n) && (r = n = void 0), e = dv(e), r === void 0 ? (r = e, e = 0) : r = dv(r), n = n === void 0 ? e < r ? 1 : -1 : dv(n), Ibe(e, r, n);
  };
}
var uf = Pbe();
function Dbe(t, e, r, n, a) {
  return a(t, function(i, s, o) {
    r = n ? (n = !1, i) : e(r, i, s, o);
  }), r;
}
function fn(t, e, r) {
  var n = jt(t) ? Kme : Dbe, a = arguments.length < 3;
  return n(t, Ia(e), r, a, Ru);
}
function j1(t, e) {
  var r = jt(t) ? zC : aB;
  return r(t, Cbe(Ia(e)));
}
function $be(t, e) {
  var r;
  return Ru(t, function(n, a, i) {
    return r = e(n, a, i), !r;
  }), !!r;
}
function lB(t, e, r) {
  var n = jt(t) ? ZF : $be;
  return n(t, Ia(e));
}
var sp = j0(function(t, e) {
  if (t == null)
    return [];
  var r = e.length;
  return r > 1 && Qd(t, e[0], e[1]) ? e = [] : r > 2 && Qd(e[0], e[1], e[2]) && (e = [e[0]]), _be(t, ap(e), []);
}), Fbe = 1 / 0, Bbe = yc && 1 / HC(new yc([, -0]))[1] == Fbe ? function(t) {
  return new yc(t);
} : dn, zbe = 200;
function XC(t, e, r) {
  var n = -1, a = GF, i = t.length, s = !0, o = [], l = o;
  if (i >= zbe) {
    var u = e ? null : Bbe(t);
    if (u)
      return HC(u);
    s = !1, a = UC, l = new of();
  } else
    l = e ? [] : o;
  e:
    for (; ++n < i; ) {
      var c = t[n], f = e ? e(c) : c;
      if (c = c !== 0 ? c : 0, s && f === f) {
        for (var h = l.length; h--; )
          if (l[h] === f)
            continue e;
        e && l.push(f), o.push(c);
      } else a(l, f, r) || (l !== o && l.push(f), o.push(c));
    }
  return o;
}
var Gbe = j0(function(t) {
  return XC(ap(t, 1, fm, !0));
});
function KC(t) {
  return t && t.length ? XC(t) : [];
}
function Ube(t, e) {
  return t && t.length ? XC(t, Ia(e)) : [];
}
var Hbe = 0;
function ZC(t) {
  var e = ++Hbe;
  return UF(t) + e;
}
function Vbe(t, e, r) {
  for (var n = -1, a = t.length, i = e.length, s = {}; ++n < a; ) {
    var o = n < i ? e[n] : void 0;
    r(s, t[n], o);
  }
  return s;
}
function qbe(t, e) {
  return Vbe(t || [], e || [], W0);
}
var Wbe = "\0", Al = "\0", V7 = "";
class As {
  constructor(e = {}) {
    this._isDirected = Object.prototype.hasOwnProperty.call(e, "directed") ? e.directed : !0, this._isMultigraph = Object.prototype.hasOwnProperty.call(e, "multigraph") ? e.multigraph : !1, this._isCompound = Object.prototype.hasOwnProperty.call(e, "compound") ? e.compound : !1, this._label = void 0, this._defaultNodeLabelFn = lc(void 0), this._defaultEdgeLabelFn = lc(void 0), this._nodes = {}, this._isCompound && (this._parent = {}, this._children = {}, this._children[Al] = {}), this._in = {}, this._preds = {}, this._out = {}, this._sucs = {}, this._edgeObjs = {}, this._edgeLabels = {};
  }
  /* === Graph functions ========= */
  isDirected() {
    return this._isDirected;
  }
  isMultigraph() {
    return this._isMultigraph;
  }
  isCompound() {
    return this._isCompound;
  }
  setGraph(e) {
    return this._label = e, this;
  }
  graph() {
    return this._label;
  }
  /* === Node functions ========== */
  setDefaultNodeLabel(e) {
    return xi(e) || (e = lc(e)), this._defaultNodeLabelFn = e, this;
  }
  nodeCount() {
    return this._nodeCount;
  }
  nodes() {
    return vn(this._nodes);
  }
  sources() {
    var e = this;
    return Zr(this.nodes(), function(r) {
      return mr(e._in[r]);
    });
  }
  sinks() {
    var e = this;
    return Zr(this.nodes(), function(r) {
      return mr(e._out[r]);
    });
  }
  setNodes(e, r) {
    var n = arguments, a = this;
    return ve(e, function(i) {
      n.length > 1 ? a.setNode(i, r) : a.setNode(i);
    }), this;
  }
  setNode(e, r) {
    return Object.prototype.hasOwnProperty.call(this._nodes, e) ? (arguments.length > 1 && (this._nodes[e] = r), this) : (this._nodes[e] = arguments.length > 1 ? r : this._defaultNodeLabelFn(e), this._isCompound && (this._parent[e] = Al, this._children[e] = {}, this._children[Al][e] = !0), this._in[e] = {}, this._preds[e] = {}, this._out[e] = {}, this._sucs[e] = {}, ++this._nodeCount, this);
  }
  node(e) {
    return this._nodes[e];
  }
  hasNode(e) {
    return Object.prototype.hasOwnProperty.call(this._nodes, e);
  }
  removeNode(e) {
    if (Object.prototype.hasOwnProperty.call(this._nodes, e)) {
      var r = (n) => this.removeEdge(this._edgeObjs[n]);
      delete this._nodes[e], this._isCompound && (this._removeFromParentsChildList(e), delete this._parent[e], ve(this.children(e), (n) => {
        this.setParent(n);
      }), delete this._children[e]), ve(vn(this._in[e]), r), delete this._in[e], delete this._preds[e], ve(vn(this._out[e]), r), delete this._out[e], delete this._sucs[e], --this._nodeCount;
    }
    return this;
  }
  setParent(e, r) {
    if (!this._isCompound)
      throw new Error("Cannot set parent in a non-compound graph");
    if (dr(r))
      r = Al;
    else {
      r += "";
      for (var n = r; !dr(n); n = this.parent(n))
        if (n === e)
          throw new Error("Setting " + r + " as parent of " + e + " would create a cycle");
      this.setNode(r);
    }
    return this.setNode(e), this._removeFromParentsChildList(e), this._parent[e] = r, this._children[r][e] = !0, this;
  }
  _removeFromParentsChildList(e) {
    delete this._children[this._parent[e]][e];
  }
  parent(e) {
    if (this._isCompound) {
      var r = this._parent[e];
      if (r !== Al)
        return r;
    }
  }
  children(e) {
    if (dr(e) && (e = Al), this._isCompound) {
      var r = this._children[e];
      if (r)
        return vn(r);
    } else {
      if (e === Al)
        return this.nodes();
      if (this.hasNode(e))
        return [];
    }
  }
  predecessors(e) {
    var r = this._preds[e];
    if (r)
      return vn(r);
  }
  successors(e) {
    var r = this._sucs[e];
    if (r)
      return vn(r);
  }
  neighbors(e) {
    var r = this.predecessors(e);
    if (r)
      return Gbe(r, this.successors(e));
  }
  isLeaf(e) {
    var r;
    return this.isDirected() ? r = this.successors(e) : r = this.neighbors(e), r.length === 0;
  }
  filterNodes(e) {
    var r = new this.constructor({
      directed: this._isDirected,
      multigraph: this._isMultigraph,
      compound: this._isCompound
    });
    r.setGraph(this.graph());
    var n = this;
    ve(this._nodes, function(s, o) {
      e(o) && r.setNode(o, s);
    }), ve(this._edgeObjs, function(s) {
      r.hasNode(s.v) && r.hasNode(s.w) && r.setEdge(s, n.edge(s));
    });
    var a = {};
    function i(s) {
      var o = n.parent(s);
      return o === void 0 || r.hasNode(o) ? (a[s] = o, o) : o in a ? a[o] : i(o);
    }
    return this._isCompound && ve(r.nodes(), function(s) {
      r.setParent(s, i(s));
    }), r;
  }
  /* === Edge functions ========== */
  setDefaultEdgeLabel(e) {
    return xi(e) || (e = lc(e)), this._defaultEdgeLabelFn = e, this;
  }
  edgeCount() {
    return this._edgeCount;
  }
  edges() {
    return wr(this._edgeObjs);
  }
  setPath(e, r) {
    var n = this, a = arguments;
    return fn(e, function(i, s) {
      return a.length > 1 ? n.setEdge(i, s, r) : n.setEdge(i, s), s;
    }), this;
  }
  /*
   * setEdge(v, w, [value, [name]])
   * setEdge({ v, w, [name] }, [value])
   */
  setEdge() {
    var e, r, n, a, i = !1, s = arguments[0];
    typeof s == "object" && s !== null && "v" in s ? (e = s.v, r = s.w, n = s.name, arguments.length === 2 && (a = arguments[1], i = !0)) : (e = s, r = arguments[1], n = arguments[3], arguments.length > 2 && (a = arguments[2], i = !0)), e = "" + e, r = "" + r, dr(n) || (n = "" + n);
    var o = Mh(this._isDirected, e, r, n);
    if (Object.prototype.hasOwnProperty.call(this._edgeLabels, o))
      return i && (this._edgeLabels[o] = a), this;
    if (!dr(n) && !this._isMultigraph)
      throw new Error("Cannot set a named edge when isMultigraph = false");
    this.setNode(e), this.setNode(r), this._edgeLabels[o] = i ? a : this._defaultEdgeLabelFn(e, r, n);
    var l = jbe(this._isDirected, e, r, n);
    return e = l.v, r = l.w, Object.freeze(l), this._edgeObjs[o] = l, q7(this._preds[r], e), q7(this._sucs[e], r), this._in[r][o] = l, this._out[e][o] = l, this._edgeCount++, this;
  }
  edge(e, r, n) {
    var a = arguments.length === 1 ? Xx(this._isDirected, arguments[0]) : Mh(this._isDirected, e, r, n);
    return this._edgeLabels[a];
  }
  hasEdge(e, r, n) {
    var a = arguments.length === 1 ? Xx(this._isDirected, arguments[0]) : Mh(this._isDirected, e, r, n);
    return Object.prototype.hasOwnProperty.call(this._edgeLabels, a);
  }
  removeEdge(e, r, n) {
    var a = arguments.length === 1 ? Xx(this._isDirected, arguments[0]) : Mh(this._isDirected, e, r, n), i = this._edgeObjs[a];
    return i && (e = i.v, r = i.w, delete this._edgeLabels[a], delete this._edgeObjs[a], W7(this._preds[r], e), W7(this._sucs[e], r), delete this._in[r][a], delete this._out[e][a], this._edgeCount--), this;
  }
  inEdges(e, r) {
    var n = this._in[e];
    if (n) {
      var a = wr(n);
      return r ? Zr(a, function(i) {
        return i.v === r;
      }) : a;
    }
  }
  outEdges(e, r) {
    var n = this._out[e];
    if (n) {
      var a = wr(n);
      return r ? Zr(a, function(i) {
        return i.w === r;
      }) : a;
    }
  }
  nodeEdges(e, r) {
    var n = this.inEdges(e, r);
    if (n)
      return n.concat(this.outEdges(e, r));
  }
}
As.prototype._nodeCount = 0;
As.prototype._edgeCount = 0;
function q7(t, e) {
  t[e] ? t[e]++ : t[e] = 1;
}
function W7(t, e) {
  --t[e] || delete t[e];
}
function Mh(t, e, r, n) {
  var a = "" + e, i = "" + r;
  if (!t && a > i) {
    var s = a;
    a = i, i = s;
  }
  return a + V7 + i + V7 + (dr(n) ? Wbe : n);
}
function jbe(t, e, r, n) {
  var a = "" + e, i = "" + r;
  if (!t && a > i) {
    var s = a;
    a = i, i = s;
  }
  var o = { v: a, w: i };
  return n && (o.name = n), o;
}
function Xx(t, e) {
  return Mh(t, e.v, e.w, e.name);
}
class Ybe {
  constructor() {
    var e = {};
    e._next = e._prev = e, this._sentinel = e;
  }
  dequeue() {
    var e = this._sentinel, r = e._prev;
    if (r !== e)
      return j7(r), r;
  }
  enqueue(e) {
    var r = this._sentinel;
    e._prev && e._next && j7(e), e._next = r._next, r._next._prev = e, r._next = e, e._prev = r;
  }
  toString() {
    for (var e = [], r = this._sentinel, n = r._prev; n !== r; )
      e.push(JSON.stringify(n, Xbe)), n = n._prev;
    return "[" + e.join(", ") + "]";
  }
}
function j7(t) {
  t._prev._next = t._next, t._next._prev = t._prev, delete t._next, delete t._prev;
}
function Xbe(t, e) {
  if (t !== "_next" && t !== "_prev")
    return e;
}
var Kbe = lc(1);
function Zbe(t, e) {
  if (t.nodeCount() <= 1)
    return [];
  var r = Jbe(t, e || Kbe), n = Qbe(r.graph, r.buckets, r.zeroIdx);
  return kn(
    Xe(n, function(a) {
      return t.outEdges(a.v, a.w);
    })
  );
}
function Qbe(t, e, r) {
  for (var n = [], a = e[e.length - 1], i = e[0], s; t.nodeCount(); ) {
    for (; s = i.dequeue(); )
      Kx(t, e, r, s);
    for (; s = a.dequeue(); )
      Kx(t, e, r, s);
    if (t.nodeCount()) {
      for (var o = e.length - 2; o > 0; --o)
        if (s = e[o].dequeue(), s) {
          n = n.concat(Kx(t, e, r, s, !0));
          break;
        }
    }
  }
  return n;
}
function Kx(t, e, r, n, a) {
  var i = a ? [] : void 0;
  return ve(t.inEdges(n.v), function(s) {
    var o = t.edge(s), l = t.node(s.v);
    a && i.push({ v: s.v, w: s.w }), l.out -= o, v4(e, r, l);
  }), ve(t.outEdges(n.v), function(s) {
    var o = t.edge(s), l = s.w, u = t.node(l);
    u.in -= o, v4(e, r, u);
  }), t.removeNode(n.v), i;
}
function Jbe(t, e) {
  var r = new As(), n = 0, a = 0;
  ve(t.nodes(), function(o) {
    r.setNode(o, { v: o, in: 0, out: 0 });
  }), ve(t.edges(), function(o) {
    var l = r.edge(o.v, o.w) || 0, u = e(o), c = l + u;
    r.setEdge(o.v, o.w, c), a = Math.max(a, r.node(o.v).out += u), n = Math.max(n, r.node(o.w).in += u);
  });
  var i = uf(a + n + 3).map(function() {
    return new Ybe();
  }), s = n + 1;
  return ve(r.nodes(), function(o) {
    v4(i, s, r.node(o));
  }), { graph: r, buckets: i, zeroIdx: s };
}
function v4(t, e, r) {
  r.out ? r.in ? t[r.out - r.in + e].enqueue(r) : t[t.length - 1].enqueue(r) : t[0].enqueue(r);
}
function exe(t) {
  var e = t.graph().acyclicer === "greedy" ? Zbe(t, r(t)) : txe(t);
  ve(e, function(n) {
    var a = t.edge(n);
    t.removeEdge(n), a.forwardName = n.name, a.reversed = !0, t.setEdge(n.w, n.v, a, ZC("rev"));
  });
  function r(n) {
    return function(a) {
      return n.edge(a).weight;
    };
  }
}
function txe(t) {
  var e = [], r = {}, n = {};
  function a(i) {
    Object.prototype.hasOwnProperty.call(n, i) || (n[i] = !0, r[i] = !0, ve(t.outEdges(i), function(s) {
      Object.prototype.hasOwnProperty.call(r, s.w) ? e.push(s) : a(s.w);
    }), delete r[i]);
  }
  return ve(t.nodes(), a), e;
}
function rxe(t) {
  ve(t.edges(), function(e) {
    var r = t.edge(e);
    if (r.reversed) {
      t.removeEdge(e);
      var n = r.forwardName;
      delete r.reversed, delete r.forwardName, t.setEdge(e.w, e.v, r, n);
    }
  });
}
function Rf(t, e, r, n) {
  var a;
  do
    a = ZC(n);
  while (t.hasNode(a));
  return r.dummy = e, t.setNode(a, r), a;
}
function nxe(t) {
  var e = new As().setGraph(t.graph());
  return ve(t.nodes(), function(r) {
    e.setNode(r, t.node(r));
  }), ve(t.edges(), function(r) {
    var n = e.edge(r.v, r.w) || { weight: 0, minlen: 1 }, a = t.edge(r);
    e.setEdge(r.v, r.w, {
      weight: n.weight + a.weight,
      minlen: Math.max(n.minlen, a.minlen)
    });
  }), e;
}
function uB(t) {
  var e = new As({ multigraph: t.isMultigraph() }).setGraph(t.graph());
  return ve(t.nodes(), function(r) {
    t.children(r).length || e.setNode(r, t.node(r));
  }), ve(t.edges(), function(r) {
    e.setEdge(r, t.edge(r));
  }), e;
}
function Y7(t, e) {
  var r = t.x, n = t.y, a = e.x - r, i = e.y - n, s = t.width / 2, o = t.height / 2;
  if (!a && !i)
    throw new Error("Not possible to find intersection inside of the rectangle");
  var l, u;
  return Math.abs(i) * s > Math.abs(a) * o ? (i < 0 && (o = -o), l = o * a / i, u = o) : (a < 0 && (s = -s), l = s, u = s * i / a), { x: r + l, y: n + u };
}
function Y1(t) {
  var e = Xe(uf(cB(t) + 1), function() {
    return [];
  });
  return ve(t.nodes(), function(r) {
    var n = t.node(r), a = n.rank;
    dr(a) || (e[a][n.order] = r);
  }), e;
}
function axe(t) {
  var e = lf(
    Xe(t.nodes(), function(r) {
      return t.node(r).rank;
    })
  );
  ve(t.nodes(), function(r) {
    var n = t.node(r);
    Et(n, "rank") && (n.rank -= e);
  });
}
function ixe(t) {
  var e = lf(
    Xe(t.nodes(), function(i) {
      return t.node(i).rank;
    })
  ), r = [];
  ve(t.nodes(), function(i) {
    var s = t.node(i).rank - e;
    r[s] || (r[s] = []), r[s].push(i);
  });
  var n = 0, a = t.graph().nodeRankFactor;
  ve(r, function(i, s) {
    dr(i) && s % a !== 0 ? --n : n && ve(i, function(o) {
      t.node(o).rank += n;
    });
  });
}
function X7(t, e, r, n) {
  var a = {
    width: 0,
    height: 0
  };
  return arguments.length >= 4 && (a.rank = r, a.order = n), Rf(t, "border", a, e);
}
function cB(t) {
  return au(
    Xe(t.nodes(), function(e) {
      var r = t.node(e).rank;
      if (!dr(r))
        return r;
    })
  );
}
function sxe(t, e) {
  var r = { lhs: [], rhs: [] };
  return ve(t, function(n) {
    e(n) ? r.lhs.push(n) : r.rhs.push(n);
  }), r;
}
function oxe(t, e) {
  return e();
}
function lxe(t) {
  function e(r) {
    var n = t.children(r), a = t.node(r);
    if (n.length && ve(n, e), Object.prototype.hasOwnProperty.call(a, "minRank")) {
      a.borderLeft = [], a.borderRight = [];
      for (var i = a.minRank, s = a.maxRank + 1; i < s; ++i)
        K7(t, "borderLeft", "_bl", r, a, i), K7(t, "borderRight", "_br", r, a, i);
    }
  }
  ve(t.children(), e);
}
function K7(t, e, r, n, a, i) {
  var s = { width: 0, height: 0, rank: i, borderType: e }, o = a[e][i - 1], l = Rf(t, "border", s, r);
  a[e][i] = l, t.setParent(l, n), o && t.setEdge(o, l, { weight: 1 });
}
function uxe(t) {
  var e = t.graph().rankdir.toLowerCase();
  (e === "lr" || e === "rl") && fB(t);
}
function cxe(t) {
  var e = t.graph().rankdir.toLowerCase();
  (e === "bt" || e === "rl") && fxe(t), (e === "lr" || e === "rl") && (hxe(t), fB(t));
}
function fB(t) {
  ve(t.nodes(), function(e) {
    Z7(t.node(e));
  }), ve(t.edges(), function(e) {
    Z7(t.edge(e));
  });
}
function Z7(t) {
  var e = t.width;
  t.width = t.height, t.height = e;
}
function fxe(t) {
  ve(t.nodes(), function(e) {
    Zx(t.node(e));
  }), ve(t.edges(), function(e) {
    var r = t.edge(e);
    ve(r.points, Zx), Object.prototype.hasOwnProperty.call(r, "y") && Zx(r);
  });
}
function Zx(t) {
  t.y = -t.y;
}
function hxe(t) {
  ve(t.nodes(), function(e) {
    Qx(t.node(e));
  }), ve(t.edges(), function(e) {
    var r = t.edge(e);
    ve(r.points, Qx), Object.prototype.hasOwnProperty.call(r, "x") && Qx(r);
  });
}
function Qx(t) {
  var e = t.x;
  t.x = t.y, t.y = e;
}
function dxe(t) {
  t.graph().dummyChains = [], ve(t.edges(), function(e) {
    pxe(t, e);
  });
}
function pxe(t, e) {
  var r = e.v, n = t.node(r).rank, a = e.w, i = t.node(a).rank, s = e.name, o = t.edge(e), l = o.labelRank;
  if (i !== n + 1) {
    t.removeEdge(e);
    var u = void 0, c, f;
    for (f = 0, ++n; n < i; ++f, ++n)
      o.points = [], u = {
        width: 0,
        height: 0,
        edgeLabel: o,
        edgeObj: e,
        rank: n
      }, c = Rf(t, "edge", u, "_d"), n === l && (u.width = o.width, u.height = o.height, u.dummy = "edge-label", u.labelpos = o.labelpos), t.setEdge(r, c, { weight: o.weight }, s), f === 0 && t.graph().dummyChains.push(c), r = c;
    t.setEdge(r, a, { weight: o.weight }, s);
  }
}
function gxe(t) {
  ve(t.graph().dummyChains, function(e) {
    var r = t.node(e), n = r.edgeLabel, a;
    for (t.setEdge(r.edgeObj, n); r.dummy; )
      a = t.successors(e)[0], t.removeNode(e), n.points.push({ x: r.x, y: r.y }), r.dummy === "edge-label" && (n.x = r.x, n.y = r.y, n.width = r.width, n.height = r.height), e = a, r = t.node(e);
  });
}
function QC(t) {
  var e = {};
  function r(n) {
    var a = t.node(n);
    if (Object.prototype.hasOwnProperty.call(e, n))
      return a.rank;
    e[n] = !0;
    var i = lf(
      Xe(t.outEdges(n), function(s) {
        return r(s.w) - t.edge(s).minlen;
      })
    );
    return (i === Number.POSITIVE_INFINITY || // return value of _.map([]) for Lodash 3
    i === void 0 || // return value of _.map([]) for Lodash 4
    i === null) && (i = 0), a.rank = i;
  }
  ve(t.sources(), r);
}
function i0(t, e) {
  return t.node(e.w).rank - t.node(e.v).rank - t.edge(e).minlen;
}
function hB(t) {
  var e = new As({ directed: !1 }), r = t.nodes()[0], n = t.nodeCount();
  e.setNode(r, {});
  for (var a, i; vxe(e, t) < n; )
    a = mxe(e, t), i = e.hasNode(a.v) ? i0(t, a) : -i0(t, a), yxe(e, t, i);
  return e;
}
function vxe(t, e) {
  function r(n) {
    ve(e.nodeEdges(n), function(a) {
      var i = a.v, s = n === i ? a.w : i;
      !t.hasNode(s) && !i0(e, a) && (t.setNode(s, {}), t.setEdge(n, s, {}), r(s));
    });
  }
  return ve(t.nodes(), r), t.nodeCount();
}
function mxe(t, e) {
  return YC(e.edges(), function(r) {
    if (t.hasNode(r.v) !== t.hasNode(r.w))
      return i0(e, r);
  });
}
function yxe(t, e, r) {
  ve(t.nodes(), function(n) {
    e.node(n).rank += r;
  });
}
function bxe() {
}
bxe.prototype = new Error();
function dB(t, e, r) {
  jt(e) || (e = [e]);
  var n = (t.isDirected() ? t.successors : t.neighbors).bind(t), a = [], i = {};
  return ve(e, function(s) {
    if (!t.hasNode(s))
      throw new Error("Graph does not have node: " + s);
    pB(t, s, r === "post", i, n, a);
  }), a;
}
function pB(t, e, r, n, a, i) {
  Object.prototype.hasOwnProperty.call(n, e) || (n[e] = !0, r || i.push(e), ve(a(e), function(s) {
    pB(t, s, r, n, a, i);
  }), r && i.push(e));
}
function xxe(t, e) {
  return dB(t, e, "post");
}
function wxe(t, e) {
  return dB(t, e, "pre");
}
Mu.initLowLimValues = e3;
Mu.initCutValues = JC;
Mu.calcCutValue = gB;
Mu.leaveEdge = mB;
Mu.enterEdge = yB;
Mu.exchangeEdges = bB;
function Mu(t) {
  t = nxe(t), QC(t);
  var e = hB(t);
  e3(e), JC(e, t);
  for (var r, n; r = mB(e); )
    n = yB(e, t, r), bB(e, t, r, n);
}
function JC(t, e) {
  var r = xxe(t, t.nodes());
  r = r.slice(0, r.length - 1), ve(r, function(n) {
    Exe(t, e, n);
  });
}
function Exe(t, e, r) {
  var n = t.node(r), a = n.parent;
  t.edge(r, a).cutvalue = gB(t, e, r);
}
function gB(t, e, r) {
  var n = t.node(r), a = n.parent, i = !0, s = e.edge(r, a), o = 0;
  return s || (i = !1, s = e.edge(a, r)), o = s.weight, ve(e.nodeEdges(r), function(l) {
    var u = l.v === r, c = u ? l.w : l.v;
    if (c !== a) {
      var f = u === i, h = e.edge(l).weight;
      if (o += f ? h : -h, Sxe(t, r, c)) {
        var d = t.edge(r, c).cutvalue;
        o += f ? -d : d;
      }
    }
  }), o;
}
function e3(t, e) {
  arguments.length < 2 && (e = t.nodes()[0]), vB(t, {}, 1, e);
}
function vB(t, e, r, n, a) {
  var i = r, s = t.node(n);
  return e[n] = !0, ve(t.neighbors(n), function(o) {
    Object.prototype.hasOwnProperty.call(e, o) || (r = vB(t, e, r, o, n));
  }), s.low = i, s.lim = r++, a ? s.parent = a : delete s.parent, r;
}
function mB(t) {
  return oo(t.edges(), function(e) {
    return t.edge(e).cutvalue < 0;
  });
}
function yB(t, e, r) {
  var n = r.v, a = r.w;
  e.hasEdge(n, a) || (n = r.w, a = r.v);
  var i = t.node(n), s = t.node(a), o = i, l = !1;
  i.lim > s.lim && (o = s, l = !0);
  var u = Zr(e.edges(), function(c) {
    return l === Q7(t, t.node(c.v), o) && l !== Q7(t, t.node(c.w), o);
  });
  return YC(u, function(c) {
    return i0(e, c);
  });
}
function bB(t, e, r, n) {
  var a = r.v, i = r.w;
  t.removeEdge(a, i), t.setEdge(n.v, n.w, {}), e3(t), JC(t, e), Txe(t, e);
}
function Txe(t, e) {
  var r = oo(t.nodes(), function(a) {
    return !e.node(a).parent;
  }), n = wxe(t, r);
  n = n.slice(1), ve(n, function(a) {
    var i = t.node(a).parent, s = e.edge(a, i), o = !1;
    s || (s = e.edge(i, a), o = !0), e.node(a).rank = e.node(i).rank + (o ? s.minlen : -s.minlen);
  });
}
function Sxe(t, e, r) {
  return t.hasEdge(e, r);
}
function Q7(t, e, r) {
  return r.low <= e.lim && e.lim <= r.lim;
}
function Cxe(t) {
  switch (t.graph().ranker) {
    case "network-simplex":
      J7(t);
      break;
    case "tight-tree":
      kxe(t);
      break;
    case "longest-path":
      Axe(t);
      break;
    default:
      J7(t);
  }
}
var Axe = QC;
function kxe(t) {
  QC(t), hB(t);
}
function J7(t) {
  Mu(t);
}
function Rxe(t) {
  var e = Rf(t, "root", {}, "_root"), r = Mxe(t), n = au(wr(r)) - 1, a = 2 * n + 1;
  t.graph().nestingRoot = e, ve(t.edges(), function(s) {
    t.edge(s).minlen *= a;
  });
  var i = _xe(t) + 1;
  ve(t.children(), function(s) {
    xB(t, e, a, i, n, r, s);
  }), t.graph().nodeRankFactor = a;
}
function xB(t, e, r, n, a, i, s) {
  var o = t.children(s);
  if (!o.length) {
    s !== e && t.setEdge(e, s, { weight: 0, minlen: r });
    return;
  }
  var l = X7(t, "_bt"), u = X7(t, "_bb"), c = t.node(s);
  t.setParent(l, s), c.borderTop = l, t.setParent(u, s), c.borderBottom = u, ve(o, function(f) {
    xB(t, e, r, n, a, i, f);
    var h = t.node(f), d = h.borderTop ? h.borderTop : f, p = h.borderBottom ? h.borderBottom : f, g = h.borderTop ? n : 2 * n, v = d !== p ? 1 : a - i[s] + 1;
    t.setEdge(l, d, {
      weight: g,
      minlen: v,
      nestingEdge: !0
    }), t.setEdge(p, u, {
      weight: g,
      minlen: v,
      nestingEdge: !0
    });
  }), t.parent(s) || t.setEdge(e, l, { weight: 0, minlen: a + i[s] });
}
function Mxe(t) {
  var e = {};
  function r(n, a) {
    var i = t.children(n);
    i && i.length && ve(i, function(s) {
      r(s, a + 1);
    }), e[n] = a;
  }
  return ve(t.children(), function(n) {
    r(n, 1);
  }), e;
}
function _xe(t) {
  return fn(
    t.edges(),
    function(e, r) {
      return e + t.edge(r).weight;
    },
    0
  );
}
function Lxe(t) {
  var e = t.graph();
  t.removeNode(e.nestingRoot), delete e.nestingRoot, ve(t.edges(), function(r) {
    var n = t.edge(r);
    n.nestingEdge && t.removeEdge(r);
  });
}
function Nxe(t, e, r) {
  var n = {}, a;
  ve(r, function(i) {
    for (var s = t.parent(i), o, l; s; ) {
      if (o = t.parent(s), o ? (l = n[o], n[o] = s) : (l = a, a = s), l && l !== s) {
        e.setEdge(l, s);
        return;
      }
      s = o;
    }
  });
}
function Oxe(t, e, r) {
  var n = Ixe(t), a = new As({ compound: !0 }).setGraph({ root: n }).setDefaultNodeLabel(function(i) {
    return t.node(i);
  });
  return ve(t.nodes(), function(i) {
    var s = t.node(i), o = t.parent(i);
    (s.rank === e || s.minRank <= e && e <= s.maxRank) && (a.setNode(i), a.setParent(i, o || n), ve(t[r](i), function(l) {
      var u = l.v === i ? l.w : l.v, c = a.edge(u, i), f = dr(c) ? 0 : c.weight;
      a.setEdge(u, i, { weight: t.edge(l).weight + f });
    }), Object.prototype.hasOwnProperty.call(s, "minRank") && a.setNode(i, {
      borderLeft: s.borderLeft[e],
      borderRight: s.borderRight[e]
    }));
  }), a;
}
function Ixe(t) {
  for (var e; t.hasNode(e = ZC("_root")); ) ;
  return e;
}
function Pxe(t, e) {
  for (var r = 0, n = 1; n < e.length; ++n)
    r += Dxe(t, e[n - 1], e[n]);
  return r;
}
function Dxe(t, e, r) {
  for (var n = qbe(
    r,
    Xe(r, function(u, c) {
      return c;
    })
  ), a = kn(
    Xe(e, function(u) {
      return sp(
        Xe(t.outEdges(u), function(c) {
          return { pos: n[c.w], weight: t.edge(c).weight };
        }),
        "pos"
      );
    })
  ), i = 1; i < r.length; ) i <<= 1;
  var s = 2 * i - 1;
  i -= 1;
  var o = Xe(new Array(s), function() {
    return 0;
  }), l = 0;
  return ve(
    // @ts-expect-error
    a.forEach(function(u) {
      var c = u.pos + i;
      o[c] += u.weight;
      for (var f = 0; c > 0; )
        c % 2 && (f += o[c + 1]), c = c - 1 >> 1, o[c] += u.weight;
      l += u.weight * f;
    })
  ), l;
}
function $xe(t) {
  var e = {}, r = Zr(t.nodes(), function(o) {
    return !t.children(o).length;
  }), n = au(
    Xe(r, function(o) {
      return t.node(o).rank;
    })
  ), a = Xe(uf(n + 1), function() {
    return [];
  });
  function i(o) {
    if (!Et(e, o)) {
      e[o] = !0;
      var l = t.node(o);
      a[l.rank].push(o), ve(t.successors(o), i);
    }
  }
  var s = sp(r, function(o) {
    return t.node(o).rank;
  });
  return ve(s, i), a;
}
function Fxe(t, e) {
  return Xe(e, function(r) {
    var n = t.inEdges(r);
    if (n.length) {
      var a = fn(
        n,
        function(i, s) {
          var o = t.edge(s), l = t.node(s.v);
          return {
            sum: i.sum + o.weight * l.order,
            weight: i.weight + o.weight
          };
        },
        { sum: 0, weight: 0 }
      );
      return {
        v: r,
        barycenter: a.sum / a.weight,
        weight: a.weight
      };
    } else
      return { v: r };
  });
}
function Bxe(t, e) {
  var r = {};
  ve(t, function(a, i) {
    var s = r[a.v] = {
      indegree: 0,
      in: [],
      out: [],
      vs: [a.v],
      i
    };
    dr(a.barycenter) || (s.barycenter = a.barycenter, s.weight = a.weight);
  }), ve(e.edges(), function(a) {
    var i = r[a.v], s = r[a.w];
    !dr(i) && !dr(s) && (s.indegree++, i.out.push(r[a.w]));
  });
  var n = Zr(r, function(a) {
    return !a.indegree;
  });
  return zxe(n);
}
function zxe(t) {
  var e = [];
  function r(i) {
    return function(s) {
      s.merged || (dr(s.barycenter) || dr(i.barycenter) || s.barycenter >= i.barycenter) && Gxe(i, s);
    };
  }
  function n(i) {
    return function(s) {
      s.in.push(i), --s.indegree === 0 && t.push(s);
    };
  }
  for (; t.length; ) {
    var a = t.pop();
    e.push(a), ve(a.in.reverse(), r(a)), ve(a.out, n(a));
  }
  return Xe(
    Zr(e, function(i) {
      return !i.merged;
    }),
    function(i) {
      return Im(i, ["vs", "i", "barycenter", "weight"]);
    }
  );
}
function Gxe(t, e) {
  var r = 0, n = 0;
  t.weight && (r += t.barycenter * t.weight, n += t.weight), e.weight && (r += e.barycenter * e.weight, n += e.weight), t.vs = e.vs.concat(t.vs), t.barycenter = r / n, t.weight = n, t.i = Math.min(e.i, t.i), e.merged = !0;
}
function Uxe(t, e) {
  var r = sxe(t, function(c) {
    return Object.prototype.hasOwnProperty.call(c, "barycenter");
  }), n = r.lhs, a = sp(r.rhs, function(c) {
    return -c.i;
  }), i = [], s = 0, o = 0, l = 0;
  n.sort(Hxe(!!e)), l = eM(i, a, l), ve(n, function(c) {
    l += c.vs.length, i.push(c.vs), s += c.barycenter * c.weight, o += c.weight, l = eM(i, a, l);
  });
  var u = { vs: kn(i) };
  return o && (u.barycenter = s / o, u.weight = o), u;
}
function eM(t, e, r) {
  for (var n; e.length && (n = ms(e)).i <= r; )
    e.pop(), t.push(n.vs), r++;
  return r;
}
function Hxe(t) {
  return function(e, r) {
    return e.barycenter < r.barycenter ? -1 : e.barycenter > r.barycenter ? 1 : t ? r.i - e.i : e.i - r.i;
  };
}
function wB(t, e, r, n) {
  var a = t.children(e), i = t.node(e), s = i ? i.borderLeft : void 0, o = i ? i.borderRight : void 0, l = {};
  s && (a = Zr(a, function(p) {
    return p !== s && p !== o;
  }));
  var u = Fxe(t, a);
  ve(u, function(p) {
    if (t.children(p.v).length) {
      var g = wB(t, p.v, r, n);
      l[p.v] = g, Object.prototype.hasOwnProperty.call(g, "barycenter") && qxe(p, g);
    }
  });
  var c = Bxe(u, r);
  Vxe(c, l);
  var f = Uxe(c, n);
  if (s && (f.vs = kn([s, f.vs, o]), t.predecessors(s).length)) {
    var h = t.node(t.predecessors(s)[0]), d = t.node(t.predecessors(o)[0]);
    Object.prototype.hasOwnProperty.call(f, "barycenter") || (f.barycenter = 0, f.weight = 0), f.barycenter = (f.barycenter * f.weight + h.order + d.order) / (f.weight + 2), f.weight += 2;
  }
  return f;
}
function Vxe(t, e) {
  ve(t, function(r) {
    r.vs = kn(
      r.vs.map(function(n) {
        return e[n] ? e[n].vs : n;
      })
    );
  });
}
function qxe(t, e) {
  dr(t.barycenter) ? (t.barycenter = e.barycenter, t.weight = e.weight) : (t.barycenter = (t.barycenter * t.weight + e.barycenter * e.weight) / (t.weight + e.weight), t.weight += e.weight);
}
function Wxe(t) {
  var e = cB(t), r = tM(t, uf(1, e + 1), "inEdges"), n = tM(t, uf(e - 1, -1, -1), "outEdges"), a = $xe(t);
  rM(t, a);
  for (var i = Number.POSITIVE_INFINITY, s, o = 0, l = 0; l < 4; ++o, ++l) {
    jxe(o % 2 ? r : n, o % 4 >= 2), a = Y1(t);
    var u = Pxe(t, a);
    u < i && (l = 0, s = h1e(a), i = u);
  }
  rM(t, s);
}
function tM(t, e, r) {
  return Xe(e, function(n) {
    return Oxe(t, n, r);
  });
}
function jxe(t, e) {
  var r = new As();
  ve(t, function(n) {
    var a = n.graph().root, i = wB(n, a, r, e);
    ve(i.vs, function(s, o) {
      n.node(s).order = o;
    }), Nxe(n, r, i.vs);
  });
}
function rM(t, e) {
  ve(e, function(r) {
    ve(r, function(n, a) {
      t.node(n).order = a;
    });
  });
}
function Yxe(t) {
  var e = Kxe(t);
  ve(t.graph().dummyChains, function(r) {
    for (var n = t.node(r), a = n.edgeObj, i = Xxe(t, e, a.v, a.w), s = i.path, o = i.lca, l = 0, u = s[l], c = !0; r !== a.w; ) {
      if (n = t.node(r), c) {
        for (; (u = s[l]) !== o && t.node(u).maxRank < n.rank; )
          l++;
        u === o && (c = !1);
      }
      if (!c) {
        for (; l < s.length - 1 && t.node(u = s[l + 1]).minRank <= n.rank; )
          l++;
        u = s[l];
      }
      t.setParent(r, u), r = t.successors(r)[0];
    }
  });
}
function Xxe(t, e, r, n) {
  var a = [], i = [], s = Math.min(e[r].low, e[n].low), o = Math.max(e[r].lim, e[n].lim), l, u;
  l = r;
  do
    l = t.parent(l), a.push(l);
  while (l && (e[l].low > s || o > e[l].lim));
  for (u = l, l = n; (l = t.parent(l)) !== u; )
    i.push(l);
  return { path: a.concat(i.reverse()), lca: u };
}
function Kxe(t) {
  var e = {}, r = 0;
  function n(a) {
    var i = r;
    ve(t.children(a), n), e[a] = { low: i, lim: r++ };
  }
  return ve(t.children(), n), e;
}
function Zxe(t, e) {
  var r = {};
  function n(a, i) {
    var s = 0, o = 0, l = a.length, u = ms(i);
    return ve(i, function(c, f) {
      var h = Jxe(t, c), d = h ? t.node(h).order : l;
      (h || c === u) && (ve(i.slice(o, f + 1), function(p) {
        ve(t.predecessors(p), function(g) {
          var v = t.node(g), m = v.order;
          (m < s || d < m) && !(v.dummy && t.node(p).dummy) && EB(r, g, p);
        });
      }), o = f + 1, s = d);
    }), i;
  }
  return fn(e, n), r;
}
function Qxe(t, e) {
  var r = {};
  function n(i, s, o, l, u) {
    var c;
    ve(uf(s, o), function(f) {
      c = i[f], t.node(c).dummy && ve(t.predecessors(c), function(h) {
        var d = t.node(h);
        d.dummy && (d.order < l || d.order > u) && EB(r, h, c);
      });
    });
  }
  function a(i, s) {
    var o = -1, l, u = 0;
    return ve(s, function(c, f) {
      if (t.node(c).dummy === "border") {
        var h = t.predecessors(c);
        h.length && (l = t.node(h[0]).order, n(s, u, f, o, l), u = f, o = l);
      }
      n(s, u, s.length, l, i.length);
    }), s;
  }
  return fn(e, a), r;
}
function Jxe(t, e) {
  if (t.node(e).dummy)
    return oo(t.predecessors(e), function(r) {
      return t.node(r).dummy;
    });
}
function EB(t, e, r) {
  if (e > r) {
    var n = e;
    e = r, r = n;
  }
  Object.prototype.hasOwnProperty.call(t, e) || Object.defineProperty(t, e, {
    enumerable: !0,
    configurable: !0,
    value: {},
    writable: !0
  });
  var a = t[e];
  Object.defineProperty(a, r, {
    enumerable: !0,
    configurable: !0,
    value: !0,
    writable: !0
  });
}
function e2e(t, e, r) {
  if (e > r) {
    var n = e;
    e = r, r = n;
  }
  return !!t[e] && Object.prototype.hasOwnProperty.call(t[e], r);
}
function t2e(t, e, r, n) {
  var a = {}, i = {}, s = {};
  return ve(e, function(o) {
    ve(o, function(l, u) {
      a[l] = l, i[l] = l, s[l] = u;
    });
  }), ve(e, function(o) {
    var l = -1;
    ve(o, function(u) {
      var c = n(u);
      if (c.length) {
        c = sp(c, function(g) {
          return s[g];
        });
        for (var f = (c.length - 1) / 2, h = Math.floor(f), d = Math.ceil(f); h <= d; ++h) {
          var p = c[h];
          i[u] === u && l < s[p] && !e2e(r, u, p) && (i[p] = u, i[u] = a[u] = a[p], l = s[p]);
        }
      }
    });
  }), { root: a, align: i };
}
function r2e(t, e, r, n, a) {
  var i = {}, s = n2e(t, e, r, a), o = a ? "borderLeft" : "borderRight";
  function l(f, h) {
    for (var d = s.nodes(), p = d.pop(), g = {}; p; )
      g[p] ? f(p) : (g[p] = !0, d.push(p), d = d.concat(h(p))), p = d.pop();
  }
  function u(f) {
    i[f] = s.inEdges(f).reduce(function(h, d) {
      return Math.max(h, i[d.v] + s.edge(d));
    }, 0);
  }
  function c(f) {
    var h = s.outEdges(f).reduce(function(p, g) {
      return Math.min(p, i[g.w] - s.edge(g));
    }, Number.POSITIVE_INFINITY), d = t.node(f);
    h !== Number.POSITIVE_INFINITY && d.borderType !== o && (i[f] = Math.max(i[f], h));
  }
  return l(u, s.predecessors.bind(s)), l(c, s.successors.bind(s)), ve(n, function(f) {
    i[f] = i[r[f]];
  }), i;
}
function n2e(t, e, r, n) {
  var a = new As(), i = t.graph(), s = l2e(i.nodesep, i.edgesep, n);
  return ve(e, function(o) {
    var l;
    ve(o, function(u) {
      var c = r[u];
      if (a.setNode(c), l) {
        var f = r[l], h = a.edge(f, c);
        a.setEdge(f, c, Math.max(s(t, u, l), h || 0));
      }
      l = u;
    });
  }), a;
}
function a2e(t, e) {
  return YC(wr(e), function(r) {
    var n = Number.NEGATIVE_INFINITY, a = Number.POSITIVE_INFINITY;
    return cbe(r, function(i, s) {
      var o = u2e(t, s) / 2;
      n = Math.max(i + o, n), a = Math.min(i - o, a);
    }), n - a;
  });
}
function i2e(t, e) {
  var r = wr(e), n = lf(r), a = au(r);
  ve(["u", "d"], function(i) {
    ve(["l", "r"], function(s) {
      var o = i + s, l = t[o], u;
      if (l !== e) {
        var c = wr(l);
        u = s === "l" ? n - lf(c) : a - au(c), u && (t[o] = W1(l, function(f) {
          return f + u;
        }));
      }
    });
  });
}
function s2e(t, e) {
  return W1(t.ul, function(r, n) {
    if (e)
      return t[e.toLowerCase()][n];
    var a = sp(Xe(t, n));
    return (a[1] + a[2]) / 2;
  });
}
function o2e(t) {
  var e = Y1(t), r = kT(Zxe(t, e), Qxe(t, e)), n = {}, a;
  ve(["u", "d"], function(s) {
    a = s === "u" ? e : wr(e).reverse(), ve(["l", "r"], function(o) {
      o === "r" && (a = Xe(a, function(f) {
        return wr(f).reverse();
      }));
      var l = (s === "u" ? t.predecessors : t.successors).bind(t), u = t2e(t, a, r, l), c = r2e(t, a, u.root, u.align, o === "r");
      o === "r" && (c = W1(c, function(f) {
        return -f;
      })), n[s + o] = c;
    });
  });
  var i = a2e(t, n);
  return i2e(n, i), s2e(n, t.graph().align);
}
function l2e(t, e, r) {
  return function(n, a, i) {
    var s = n.node(a), o = n.node(i), l = 0, u;
    if (l += s.width / 2, Object.prototype.hasOwnProperty.call(s, "labelpos"))
      switch (s.labelpos.toLowerCase()) {
        case "l":
          u = -s.width / 2;
          break;
        case "r":
          u = s.width / 2;
          break;
      }
    if (u && (l += r ? u : -u), u = 0, l += (s.dummy ? e : t) / 2, l += (o.dummy ? e : t) / 2, l += o.width / 2, Object.prototype.hasOwnProperty.call(o, "labelpos"))
      switch (o.labelpos.toLowerCase()) {
        case "l":
          u = o.width / 2;
          break;
        case "r":
          u = -o.width / 2;
          break;
      }
    return u && (l += r ? u : -u), u = 0, l;
  };
}
function u2e(t, e) {
  return t.node(e).width;
}
function c2e(t) {
  t = uB(t), f2e(t), fbe(o2e(t), function(e, r) {
    t.node(r).x = e;
  });
}
function f2e(t) {
  var e = Y1(t), r = t.graph().ranksep, n = 0;
  ve(e, function(a) {
    var i = au(
      Xe(a, function(s) {
        return t.node(s).height;
      })
    );
    ve(a, function(s) {
      t.node(s).y = n + i / 2;
    }), n += i + r;
  });
}
function Z_e(t, e) {
  var r = oxe;
  r("layout", () => {
    var n = r("  buildLayoutGraph", () => E2e(t));
    r("  runLayout", () => h2e(n, r)), r("  updateInputGraph", () => d2e(t, n));
  });
}
function h2e(t, e) {
  e("    makeSpaceForEdgeLabels", () => T2e(t)), e("    removeSelfEdges", () => N2e(t)), e("    acyclic", () => exe(t)), e("    nestingGraph.run", () => Rxe(t)), e("    rank", () => Cxe(uB(t))), e("    injectEdgeLabelProxies", () => S2e(t)), e("    removeEmptyRanks", () => ixe(t)), e("    nestingGraph.cleanup", () => Lxe(t)), e("    normalizeRanks", () => axe(t)), e("    assignRankMinMax", () => C2e(t)), e("    removeEdgeLabelProxies", () => A2e(t)), e("    normalize.run", () => dxe(t)), e("    parentDummyChains", () => Yxe(t)), e("    addBorderSegments", () => lxe(t)), e("    order", () => Wxe(t)), e("    insertSelfEdges", () => O2e(t)), e("    adjustCoordinateSystem", () => uxe(t)), e("    position", () => c2e(t)), e("    positionSelfEdges", () => I2e(t)), e("    removeBorderNodes", () => L2e(t)), e("    normalize.undo", () => gxe(t)), e("    fixupEdgeLabelCoords", () => M2e(t)), e("    undoCoordinateSystem", () => cxe(t)), e("    translateGraph", () => k2e(t)), e("    assignNodeIntersects", () => R2e(t)), e("    reversePoints", () => _2e(t)), e("    acyclic.undo", () => rxe(t));
}
function d2e(t, e) {
  ve(t.nodes(), function(r) {
    var n = t.node(r), a = e.node(r);
    n && (n.x = a.x, n.y = a.y, e.children(r).length && (n.width = a.width, n.height = a.height));
  }), ve(t.edges(), function(r) {
    var n = t.edge(r), a = e.edge(r);
    n.points = a.points, Object.prototype.hasOwnProperty.call(a, "x") && (n.x = a.x, n.y = a.y);
  }), t.graph().width = e.graph().width, t.graph().height = e.graph().height;
}
var p2e = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"], g2e = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" }, v2e = ["acyclicer", "ranker", "rankdir", "align"], m2e = ["width", "height"], y2e = { width: 0, height: 0 }, b2e = ["minlen", "weight", "width", "height", "labeloffset"], x2e = {
  minlen: 1,
  weight: 1,
  width: 0,
  height: 0,
  labeloffset: 10,
  labelpos: "r"
}, w2e = ["labelpos"];
function E2e(t) {
  var e = new As({ multigraph: !0, compound: !0 }), r = e2(t.graph());
  return e.setGraph(
    kT({}, g2e, Jx(r, p2e), Im(r, v2e))
  ), ve(t.nodes(), function(n) {
    var a = e2(t.node(n));
    e.setNode(n, V1(Jx(a, m2e), y2e)), e.setParent(n, t.parent(n));
  }), ve(t.edges(), function(n) {
    var a = e2(t.edge(n));
    e.setEdge(
      n,
      kT({}, x2e, Jx(a, b2e), Im(a, w2e))
    );
  }), e;
}
function T2e(t) {
  var e = t.graph();
  e.ranksep /= 2, ve(t.edges(), function(r) {
    var n = t.edge(r);
    n.minlen *= 2, n.labelpos.toLowerCase() !== "c" && (e.rankdir === "TB" || e.rankdir === "BT" ? n.width += n.labeloffset : n.height += n.labeloffset);
  });
}
function S2e(t) {
  ve(t.edges(), function(e) {
    var r = t.edge(e);
    if (r.width && r.height) {
      var n = t.node(e.v), a = t.node(e.w), i = { rank: (a.rank - n.rank) / 2 + n.rank, e };
      Rf(t, "edge-proxy", i, "_ep");
    }
  });
}
function C2e(t) {
  var e = 0;
  ve(t.nodes(), function(r) {
    var n = t.node(r);
    n.borderTop && (n.minRank = t.node(n.borderTop).rank, n.maxRank = t.node(n.borderBottom).rank, e = au(e, n.maxRank));
  }), t.graph().maxRank = e;
}
function A2e(t) {
  ve(t.nodes(), function(e) {
    var r = t.node(e);
    r.dummy === "edge-proxy" && (t.edge(r.e).labelRank = r.rank, t.removeNode(e));
  });
}
function k2e(t) {
  var e = Number.POSITIVE_INFINITY, r = 0, n = Number.POSITIVE_INFINITY, a = 0, i = t.graph(), s = i.marginx || 0, o = i.marginy || 0;
  function l(u) {
    var c = u.x, f = u.y, h = u.width, d = u.height;
    e = Math.min(e, c - h / 2), r = Math.max(r, c + h / 2), n = Math.min(n, f - d / 2), a = Math.max(a, f + d / 2);
  }
  ve(t.nodes(), function(u) {
    l(t.node(u));
  }), ve(t.edges(), function(u) {
    var c = t.edge(u);
    Object.prototype.hasOwnProperty.call(c, "x") && l(c);
  }), e -= s, n -= o, ve(t.nodes(), function(u) {
    var c = t.node(u);
    c.x -= e, c.y -= n;
  }), ve(t.edges(), function(u) {
    var c = t.edge(u);
    ve(c.points, function(f) {
      f.x -= e, f.y -= n;
    }), Object.prototype.hasOwnProperty.call(c, "x") && (c.x -= e), Object.prototype.hasOwnProperty.call(c, "y") && (c.y -= n);
  }), i.width = r - e + s, i.height = a - n + o;
}
function R2e(t) {
  ve(t.edges(), function(e) {
    var r = t.edge(e), n = t.node(e.v), a = t.node(e.w), i, s;
    r.points ? (i = r.points[0], s = r.points[r.points.length - 1]) : (r.points = [], i = a, s = n), r.points.unshift(Y7(n, i)), r.points.push(Y7(a, s));
  });
}
function M2e(t) {
  ve(t.edges(), function(e) {
    var r = t.edge(e);
    if (Object.prototype.hasOwnProperty.call(r, "x"))
      switch ((r.labelpos === "l" || r.labelpos === "r") && (r.width -= r.labeloffset), r.labelpos) {
        case "l":
          r.x -= r.width / 2 + r.labeloffset;
          break;
        case "r":
          r.x += r.width / 2 + r.labeloffset;
          break;
      }
  });
}
function _2e(t) {
  ve(t.edges(), function(e) {
    var r = t.edge(e);
    r.reversed && r.points.reverse();
  });
}
function L2e(t) {
  ve(t.nodes(), function(e) {
    if (t.children(e).length) {
      var r = t.node(e), n = t.node(r.borderTop), a = t.node(r.borderBottom), i = t.node(ms(r.borderLeft)), s = t.node(ms(r.borderRight));
      r.width = Math.abs(s.x - i.x), r.height = Math.abs(a.y - n.y), r.x = i.x + r.width / 2, r.y = n.y + r.height / 2;
    }
  }), ve(t.nodes(), function(e) {
    t.node(e).dummy === "border" && t.removeNode(e);
  });
}
function N2e(t) {
  ve(t.edges(), function(e) {
    if (e.v === e.w) {
      var r = t.node(e.v);
      r.selfEdges || (r.selfEdges = []), r.selfEdges.push({ e, label: t.edge(e) }), t.removeEdge(e);
    }
  });
}
function O2e(t) {
  var e = Y1(t);
  ve(e, function(r) {
    var n = 0;
    ve(r, function(a, i) {
      var s = t.node(a);
      s.order = i + n, ve(s.selfEdges, function(o) {
        Rf(
          t,
          "selfedge",
          {
            width: o.label.width,
            height: o.label.height,
            rank: s.rank,
            order: i + ++n,
            e: o.e,
            label: o.label
          },
          "_se"
        );
      }), delete s.selfEdges;
    });
  });
}
function I2e(t) {
  ve(t.nodes(), function(e) {
    var r = t.node(e);
    if (r.dummy === "selfedge") {
      var n = t.node(r.e.v), a = n.x + n.width / 2, i = n.y, s = r.x - a, o = n.height / 2;
      t.setEdge(r.e, r.label), t.removeNode(e), r.label.points = [
        { x: a + 2 * s / 3, y: i - o },
        { x: a + 5 * s / 6, y: i - o },
        { x: a + s, y: i },
        { x: a + 5 * s / 6, y: i + o },
        { x: a + 2 * s / 3, y: i + o }
      ], r.label.x = r.x, r.label.y = r.y;
    }
  });
}
function Jx(t, e) {
  return W1(Im(t, e), Number);
}
function e2(t) {
  var e = {};
  return ve(t, function(r, n) {
    e[n.toLowerCase()] = r;
  }), e;
}
function Q_e(t) {
  var e = {
    options: {
      directed: t.isDirected(),
      multigraph: t.isMultigraph(),
      compound: t.isCompound()
    },
    nodes: P2e(t),
    edges: D2e(t)
  };
  return dr(t.graph()) || (e.value = _n(t.graph())), e;
}
function P2e(t) {
  return Xe(t.nodes(), function(e) {
    var r = t.node(e), n = t.parent(e), a = { v: e };
    return dr(r) || (a.value = r), dr(n) || (a.parent = n), a;
  });
}
function D2e(t) {
  return Xe(t.edges(), function(e) {
    var r = t.edge(e), n = { v: e.v, w: e.w };
    return dr(e.name) || (n.name = e.name), dr(r) || (n.value = r), n;
  });
}
function m4(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var r = 0, n = Array(e); r < e; r++) n[r] = t[r];
  return n;
}
function $2e(t) {
  if (Array.isArray(t)) return t;
}
function F2e(t) {
  if (Array.isArray(t)) return m4(t);
}
function hl(t, e) {
  if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
}
function B2e(t, e) {
  for (var r = 0; r < e.length; r++) {
    var n = e[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, SB(n.key), n);
  }
}
function dl(t, e, r) {
  return e && B2e(t.prototype, e), Object.defineProperty(t, "prototype", {
    writable: !1
  }), t;
}
function Ca(t, e) {
  var r = typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
  if (!r) {
    if (Array.isArray(t) || (r = t3(t)) || e) {
      r && (t = r);
      var n = 0, a = function() {
      };
      return {
        s: a,
        n: function() {
          return n >= t.length ? {
            done: !0
          } : {
            done: !1,
            value: t[n++]
          };
        },
        e: function(l) {
          throw l;
        },
        f: a
      };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  var i, s = !0, o = !1;
  return {
    s: function() {
      r = r.call(t);
    },
    n: function() {
      var l = r.next();
      return s = l.done, l;
    },
    e: function(l) {
      o = !0, i = l;
    },
    f: function() {
      try {
        s || r.return == null || r.return();
      } finally {
        if (o) throw i;
      }
    }
  };
}
function TB(t, e, r) {
  return (e = SB(e)) in t ? Object.defineProperty(t, e, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = r, t;
}
function z2e(t) {
  if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
}
function G2e(t, e) {
  var r = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
  if (r != null) {
    var n, a, i, s, o = [], l = !0, u = !1;
    try {
      if (i = (r = r.call(t)).next, e === 0) {
        if (Object(r) !== r) return;
        l = !1;
      } else for (; !(l = (n = i.call(r)).done) && (o.push(n.value), o.length !== e); l = !0) ;
    } catch (c) {
      u = !0, a = c;
    } finally {
      try {
        if (!l && r.return != null && (s = r.return(), Object(s) !== s)) return;
      } finally {
        if (u) throw a;
      }
    }
    return o;
  }
}
function U2e() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function H2e() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function ln(t, e) {
  return $2e(t) || G2e(t, e) || t3(t, e) || U2e();
}
function Pm(t) {
  return F2e(t) || z2e(t) || t3(t) || H2e();
}
function V2e(t, e) {
  if (typeof t != "object" || !t) return t;
  var r = t[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(t, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t);
}
function SB(t) {
  var e = V2e(t, "string");
  return typeof e == "symbol" ? e : e + "";
}
function xn(t) {
  "@babel/helpers - typeof";
  return xn = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, xn(t);
}
function t3(t, e) {
  if (t) {
    if (typeof t == "string") return m4(t, e);
    var r = {}.toString.call(t).slice(8, -1);
    return r === "Object" && t.constructor && (r = t.constructor.name), r === "Map" || r === "Set" ? Array.from(t) : r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? m4(t, e) : void 0;
  }
}
var pn = typeof window > "u" ? null : window, nM = pn ? pn.navigator : null;
pn && pn.document;
var q2e = xn(""), CB = xn({}), W2e = xn(function() {
}), j2e = typeof HTMLElement > "u" ? "undefined" : xn(HTMLElement), op = function(e) {
  return e && e.instanceString && Wr(e.instanceString) ? e.instanceString() : null;
}, xt = function(e) {
  return e != null && xn(e) == q2e;
}, Wr = function(e) {
  return e != null && xn(e) === W2e;
}, Sr = function(e) {
  return !ri(e) && (Array.isArray ? Array.isArray(e) : e != null && e instanceof Array);
}, Qt = function(e) {
  return e != null && xn(e) === CB && !Sr(e) && e.constructor === Object;
}, Y2e = function(e) {
  return e != null && xn(e) === CB;
}, tt = function(e) {
  return e != null && xn(e) === xn(1) && !isNaN(e);
}, X2e = function(e) {
  return tt(e) && Math.floor(e) === e;
}, Dm = function(e) {
  if (j2e !== "undefined")
    return e != null && e instanceof HTMLElement;
}, ri = function(e) {
  return lp(e) || AB(e);
}, lp = function(e) {
  return op(e) === "collection" && e._private.single;
}, AB = function(e) {
  return op(e) === "collection" && !e._private.single;
}, r3 = function(e) {
  return op(e) === "core";
}, kB = function(e) {
  return op(e) === "stylesheet";
}, K2e = function(e) {
  return op(e) === "event";
}, jo = function(e) {
  return e == null ? !0 : !!(e === "" || e.match(/^\s+$/));
}, Z2e = function(e) {
  return typeof HTMLElement > "u" ? !1 : e instanceof HTMLElement;
}, Q2e = function(e) {
  return Qt(e) && tt(e.x1) && tt(e.x2) && tt(e.y1) && tt(e.y2);
}, J2e = function(e) {
  return Y2e(e) && Wr(e.then);
}, ewe = function() {
  return nM && nM.userAgent.match(/msie|trident|edge/i);
}, cf = function(e, r) {
  r || (r = function() {
    if (arguments.length === 1)
      return arguments[0];
    if (arguments.length === 0)
      return "undefined";
    for (var i = [], s = 0; s < arguments.length; s++)
      i.push(arguments[s]);
    return i.join("$");
  });
  var n = function() {
    var i = this, s = arguments, o, l = r.apply(i, s), u = n.cache;
    return (o = u[l]) || (o = u[l] = e.apply(i, s)), o;
  };
  return n.cache = {}, n;
}, n3 = cf(function(t) {
  return t.replace(/([A-Z])/g, function(e) {
    return "-" + e.toLowerCase();
  });
}), X1 = cf(function(t) {
  return t.replace(/(-\w)/g, function(e) {
    return e[1].toUpperCase();
  });
}), RB = cf(function(t, e) {
  return t + e[0].toUpperCase() + e.substring(1);
}, function(t, e) {
  return t + "$" + e;
}), aM = function(e) {
  return jo(e) ? e : e.charAt(0).toUpperCase() + e.substring(1);
}, Po = function(e, r) {
  return e.slice(-1 * r.length) === r;
}, mn = "(?:[-+]?(?:(?:\\d+|\\d*\\.\\d+)(?:[Ee][+-]?\\d+)?))", twe = "rgb[a]?\\((" + mn + "[%]?)\\s*,\\s*(" + mn + "[%]?)\\s*,\\s*(" + mn + "[%]?)(?:\\s*,\\s*(" + mn + "))?\\)", rwe = "rgb[a]?\\((?:" + mn + "[%]?)\\s*,\\s*(?:" + mn + "[%]?)\\s*,\\s*(?:" + mn + "[%]?)(?:\\s*,\\s*(?:" + mn + "))?\\)", nwe = "hsl[a]?\\((" + mn + ")\\s*,\\s*(" + mn + "[%])\\s*,\\s*(" + mn + "[%])(?:\\s*,\\s*(" + mn + "))?\\)", awe = "hsl[a]?\\((?:" + mn + ")\\s*,\\s*(?:" + mn + "[%])\\s*,\\s*(?:" + mn + "[%])(?:\\s*,\\s*(?:" + mn + "))?\\)", iwe = "\\#[0-9a-fA-F]{3}", swe = "\\#[0-9a-fA-F]{6}", MB = function(e, r) {
  return e < r ? -1 : e > r ? 1 : 0;
}, owe = function(e, r) {
  return -1 * MB(e, r);
}, At = Object.assign != null ? Object.assign.bind(Object) : function(t) {
  for (var e = arguments, r = 1; r < e.length; r++) {
    var n = e[r];
    if (n != null)
      for (var a = Object.keys(n), i = 0; i < a.length; i++) {
        var s = a[i];
        t[s] = n[s];
      }
  }
  return t;
}, lwe = function(e) {
  if (!(!(e.length === 4 || e.length === 7) || e[0] !== "#")) {
    var r = e.length === 4, n, a, i, s = 16;
    return r ? (n = parseInt(e[1] + e[1], s), a = parseInt(e[2] + e[2], s), i = parseInt(e[3] + e[3], s)) : (n = parseInt(e[1] + e[2], s), a = parseInt(e[3] + e[4], s), i = parseInt(e[5] + e[6], s)), [n, a, i];
  }
}, uwe = function(e) {
  var r, n, a, i, s, o, l, u;
  function c(p, g, v) {
    return v < 0 && (v += 1), v > 1 && (v -= 1), v < 1 / 6 ? p + (g - p) * 6 * v : v < 1 / 2 ? g : v < 2 / 3 ? p + (g - p) * (2 / 3 - v) * 6 : p;
  }
  var f = new RegExp("^" + nwe + "$").exec(e);
  if (f) {
    if (n = parseInt(f[1]), n < 0 ? n = (360 - -1 * n % 360) % 360 : n > 360 && (n = n % 360), n /= 360, a = parseFloat(f[2]), a < 0 || a > 100 || (a = a / 100, i = parseFloat(f[3]), i < 0 || i > 100) || (i = i / 100, s = f[4], s !== void 0 && (s = parseFloat(s), s < 0 || s > 1)))
      return;
    if (a === 0)
      o = l = u = Math.round(i * 255);
    else {
      var h = i < 0.5 ? i * (1 + a) : i + a - i * a, d = 2 * i - h;
      o = Math.round(255 * c(d, h, n + 1 / 3)), l = Math.round(255 * c(d, h, n)), u = Math.round(255 * c(d, h, n - 1 / 3));
    }
    r = [o, l, u, s];
  }
  return r;
}, cwe = function(e) {
  var r, n = new RegExp("^" + twe + "$").exec(e);
  if (n) {
    r = [];
    for (var a = [], i = 1; i <= 3; i++) {
      var s = n[i];
      if (s[s.length - 1] === "%" && (a[i] = !0), s = parseFloat(s), a[i] && (s = s / 100 * 255), s < 0 || s > 255)
        return;
      r.push(Math.floor(s));
    }
    var o = a[1] || a[2] || a[3], l = a[1] && a[2] && a[3];
    if (o && !l)
      return;
    var u = n[4];
    if (u !== void 0) {
      if (u = parseFloat(u), u < 0 || u > 1)
        return;
      r.push(u);
    }
  }
  return r;
}, fwe = function(e) {
  return hwe[e.toLowerCase()];
}, _B = function(e) {
  return (Sr(e) ? e : null) || fwe(e) || lwe(e) || cwe(e) || uwe(e);
}, hwe = {
  // special colour names
  transparent: [0, 0, 0, 0],
  // NB alpha === 0
  // regular colours
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  grey: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
}, LB = function(e) {
  for (var r = e.map, n = e.keys, a = n.length, i = 0; i < a; i++) {
    var s = n[i];
    if (Qt(s))
      throw Error("Tried to set map with object key");
    i < n.length - 1 ? (r[s] == null && (r[s] = {}), r = r[s]) : r[s] = e.value;
  }
}, NB = function(e) {
  for (var r = e.map, n = e.keys, a = n.length, i = 0; i < a; i++) {
    var s = n[i];
    if (Qt(s))
      throw Error("Tried to get map with object key");
    if (r = r[s], r == null)
      return r;
  }
  return r;
}, lg = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function up(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var t2, iM;
function cp() {
  if (iM) return t2;
  iM = 1;
  function t(e) {
    var r = typeof e;
    return e != null && (r == "object" || r == "function");
  }
  return t2 = t, t2;
}
var r2, sM;
function dwe() {
  if (sM) return r2;
  sM = 1;
  var t = typeof lg == "object" && lg && lg.Object === Object && lg;
  return r2 = t, r2;
}
var n2, oM;
function K1() {
  if (oM) return n2;
  oM = 1;
  var t = dwe(), e = typeof self == "object" && self && self.Object === Object && self, r = t || e || Function("return this")();
  return n2 = r, n2;
}
var a2, lM;
function pwe() {
  if (lM) return a2;
  lM = 1;
  var t = K1(), e = function() {
    return t.Date.now();
  };
  return a2 = e, a2;
}
var i2, uM;
function gwe() {
  if (uM) return i2;
  uM = 1;
  var t = /\s/;
  function e(r) {
    for (var n = r.length; n-- && t.test(r.charAt(n)); )
      ;
    return n;
  }
  return i2 = e, i2;
}
var s2, cM;
function vwe() {
  if (cM) return s2;
  cM = 1;
  var t = gwe(), e = /^\s+/;
  function r(n) {
    return n && n.slice(0, t(n) + 1).replace(e, "");
  }
  return s2 = r, s2;
}
var o2, fM;
function a3() {
  if (fM) return o2;
  fM = 1;
  var t = K1(), e = t.Symbol;
  return o2 = e, o2;
}
var l2, hM;
function mwe() {
  if (hM) return l2;
  hM = 1;
  var t = a3(), e = Object.prototype, r = e.hasOwnProperty, n = e.toString, a = t ? t.toStringTag : void 0;
  function i(s) {
    var o = r.call(s, a), l = s[a];
    try {
      s[a] = void 0;
      var u = !0;
    } catch {
    }
    var c = n.call(s);
    return u && (o ? s[a] = l : delete s[a]), c;
  }
  return l2 = i, l2;
}
var u2, dM;
function ywe() {
  if (dM) return u2;
  dM = 1;
  var t = Object.prototype, e = t.toString;
  function r(n) {
    return e.call(n);
  }
  return u2 = r, u2;
}
var c2, pM;
function OB() {
  if (pM) return c2;
  pM = 1;
  var t = a3(), e = mwe(), r = ywe(), n = "[object Null]", a = "[object Undefined]", i = t ? t.toStringTag : void 0;
  function s(o) {
    return o == null ? o === void 0 ? a : n : i && i in Object(o) ? e(o) : r(o);
  }
  return c2 = s, c2;
}
var f2, gM;
function bwe() {
  if (gM) return f2;
  gM = 1;
  function t(e) {
    return e != null && typeof e == "object";
  }
  return f2 = t, f2;
}
var h2, vM;
function fp() {
  if (vM) return h2;
  vM = 1;
  var t = OB(), e = bwe(), r = "[object Symbol]";
  function n(a) {
    return typeof a == "symbol" || e(a) && t(a) == r;
  }
  return h2 = n, h2;
}
var d2, mM;
function xwe() {
  if (mM) return d2;
  mM = 1;
  var t = vwe(), e = cp(), r = fp(), n = NaN, a = /^[-+]0x[0-9a-f]+$/i, i = /^0b[01]+$/i, s = /^0o[0-7]+$/i, o = parseInt;
  function l(u) {
    if (typeof u == "number")
      return u;
    if (r(u))
      return n;
    if (e(u)) {
      var c = typeof u.valueOf == "function" ? u.valueOf() : u;
      u = e(c) ? c + "" : c;
    }
    if (typeof u != "string")
      return u === 0 ? u : +u;
    u = t(u);
    var f = i.test(u);
    return f || s.test(u) ? o(u.slice(2), f ? 2 : 8) : a.test(u) ? n : +u;
  }
  return d2 = l, d2;
}
var p2, yM;
function wwe() {
  if (yM) return p2;
  yM = 1;
  var t = cp(), e = pwe(), r = xwe(), n = "Expected a function", a = Math.max, i = Math.min;
  function s(o, l, u) {
    var c, f, h, d, p, g, v = 0, m = !1, b = !1, y = !0;
    if (typeof o != "function")
      throw new TypeError(n);
    l = r(l) || 0, t(u) && (m = !!u.leading, b = "maxWait" in u, h = b ? a(r(u.maxWait) || 0, l) : h, y = "trailing" in u ? !!u.trailing : y);
    function x(O) {
      var T = c, L = f;
      return c = f = void 0, v = O, d = o.apply(L, T), d;
    }
    function E(O) {
      return v = O, p = setTimeout(C, l), m ? x(O) : d;
    }
    function S(O) {
      var T = O - g, L = O - v, M = l - T;
      return b ? i(M, h - L) : M;
    }
    function w(O) {
      var T = O - g, L = O - v;
      return g === void 0 || T >= l || T < 0 || b && L >= h;
    }
    function C() {
      var O = e();
      if (w(O))
        return k(O);
      p = setTimeout(C, S(O));
    }
    function k(O) {
      return p = void 0, y && c ? x(O) : (c = f = void 0, d);
    }
    function N() {
      p !== void 0 && clearTimeout(p), v = 0, c = g = f = p = void 0;
    }
    function R() {
      return p === void 0 ? d : k(e());
    }
    function _() {
      var O = e(), T = w(O);
      if (c = arguments, f = this, g = O, T) {
        if (p === void 0)
          return E(g);
        if (b)
          return clearTimeout(p), p = setTimeout(C, l), x(g);
      }
      return p === void 0 && (p = setTimeout(C, l)), d;
    }
    return _.cancel = N, _.flush = R, _;
  }
  return p2 = s, p2;
}
var Ewe = wwe(), hp = /* @__PURE__ */ up(Ewe), g2 = pn ? pn.performance : null, IB = g2 && g2.now ? function() {
  return g2.now();
} : function() {
  return Date.now();
}, Twe = function() {
  if (pn) {
    if (pn.requestAnimationFrame)
      return function(t) {
        pn.requestAnimationFrame(t);
      };
    if (pn.mozRequestAnimationFrame)
      return function(t) {
        pn.mozRequestAnimationFrame(t);
      };
    if (pn.webkitRequestAnimationFrame)
      return function(t) {
        pn.webkitRequestAnimationFrame(t);
      };
    if (pn.msRequestAnimationFrame)
      return function(t) {
        pn.msRequestAnimationFrame(t);
      };
  }
  return function(t) {
    t && setTimeout(function() {
      t(IB());
    }, 1e3 / 60);
  };
}(), $m = function(e) {
  return Twe(e);
}, uo = IB, $l = 9261, PB = 65599, Ju = 5381, DB = function(e) {
  for (var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : $l, n = r, a; a = e.next(), !a.done; )
    n = n * PB + a.value | 0;
  return n;
}, s0 = function(e) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : $l;
  return r * PB + e | 0;
}, o0 = function(e) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ju;
  return (r << 5) + r + e | 0;
}, Swe = function(e, r) {
  return e * 2097152 + r;
}, So = function(e) {
  return e[0] * 2097152 + e[1];
}, ug = function(e, r) {
  return [s0(e[0], r[0]), o0(e[1], r[1])];
}, bM = function(e, r) {
  var n = {
    value: 0,
    done: !1
  }, a = 0, i = e.length, s = {
    next: function() {
      return a < i ? n.value = e[a++] : n.done = !0, n;
    }
  };
  return DB(s, r);
}, iu = function(e, r) {
  var n = {
    value: 0,
    done: !1
  }, a = 0, i = e.length, s = {
    next: function() {
      return a < i ? n.value = e.charCodeAt(a++) : n.done = !0, n;
    }
  };
  return DB(s, r);
}, $B = function() {
  return Cwe(arguments);
}, Cwe = function(e) {
  for (var r, n = 0; n < e.length; n++) {
    var a = e[n];
    n === 0 ? r = iu(a) : r = iu(a, r);
  }
  return r;
};
function Awe(t, e, r, n, a) {
  var i = a * Math.PI / 180, s = Math.cos(i) * (t - r) - Math.sin(i) * (e - n) + r, o = Math.sin(i) * (t - r) + Math.cos(i) * (e - n) + n;
  return {
    x: s,
    y: o
  };
}
var kwe = function(e, r, n, a, i, s) {
  return {
    x: (e - n) * i + n,
    y: (r - a) * s + a
  };
};
function Rwe(t, e, r) {
  if (r === 0) return t;
  var n = (e.x1 + e.x2) / 2, a = (e.y1 + e.y2) / 2, i = e.w / e.h, s = 1 / i, o = Awe(t.x, t.y, n, a, r), l = kwe(o.x, o.y, n, a, i, s);
  return {
    x: l.x,
    y: l.y
  };
}
var xM = !0, Mwe = console.warn != null, _we = console.trace != null, i3 = Number.MAX_SAFE_INTEGER || 9007199254740991, FB = function() {
  return !0;
}, Fm = function() {
  return !1;
}, wM = function() {
  return 0;
}, s3 = function() {
}, Fr = function(e) {
  throw new Error(e);
}, BB = function(e) {
  if (e !== void 0)
    xM = !!e;
  else
    return xM;
}, pr = function(e) {
  BB() && (Mwe ? console.warn(e) : (console.log(e), _we && console.trace()));
}, Lwe = function(e) {
  return At({}, e);
}, ds = function(e) {
  return e == null ? e : Sr(e) ? e.slice() : Qt(e) ? Lwe(e) : e;
}, Nwe = function(e) {
  return e.slice();
}, zB = function(e, r) {
  for (
    // loop :)
    r = e = "";
    // b - result , a - numeric letiable
    e++ < 36;
    //
    r += e * 51 & 52 ? (
      //  return a random number or 4
      (e ^ 15 ? (
        // generate a random number from 0 to 15
        8 ^ Math.random() * (e ^ 20 ? 16 : 4)
      ) : 4).toString(16)
    ) : "-"
  ) ;
  return r;
}, Owe = {}, GB = function() {
  return Owe;
}, Hn = function(e) {
  var r = Object.keys(e);
  return function(n) {
    for (var a = {}, i = 0; i < r.length; i++) {
      var s = r[i], o = n == null ? void 0 : n[s];
      a[s] = o === void 0 ? e[s] : o;
    }
    return a;
  };
}, Yo = function(e, r, n) {
  for (var a = e.length - 1; a >= 0; a--)
    e[a] === r && e.splice(a, 1);
}, o3 = function(e) {
  e.splice(0, e.length);
}, Iwe = function(e, r) {
  for (var n = 0; n < r.length; n++) {
    var a = r[n];
    e.push(a);
  }
}, Ta = function(e, r, n) {
  return n && (r = RB(n, r)), e[r];
}, Bs = function(e, r, n, a) {
  n && (r = RB(n, r)), e[r] = a;
}, Pwe = /* @__PURE__ */ function() {
  function t() {
    hl(this, t), this._obj = {};
  }
  return dl(t, [{
    key: "set",
    value: function(r, n) {
      return this._obj[r] = n, this;
    }
  }, {
    key: "delete",
    value: function(r) {
      return this._obj[r] = void 0, this;
    }
  }, {
    key: "clear",
    value: function() {
      this._obj = {};
    }
  }, {
    key: "has",
    value: function(r) {
      return this._obj[r] !== void 0;
    }
  }, {
    key: "get",
    value: function(r) {
      return this._obj[r];
    }
  }]);
}(), Xs = typeof Map < "u" ? Map : Pwe, Dwe = "undefined", $we = /* @__PURE__ */ function() {
  function t(e) {
    if (hl(this, t), this._obj = /* @__PURE__ */ Object.create(null), this.size = 0, e != null) {
      var r;
      e.instanceString != null && e.instanceString() === this.instanceString() ? r = e.toArray() : r = e;
      for (var n = 0; n < r.length; n++)
        this.add(r[n]);
    }
  }
  return dl(t, [{
    key: "instanceString",
    value: function() {
      return "set";
    }
  }, {
    key: "add",
    value: function(r) {
      var n = this._obj;
      n[r] !== 1 && (n[r] = 1, this.size++);
    }
  }, {
    key: "delete",
    value: function(r) {
      var n = this._obj;
      n[r] === 1 && (n[r] = 0, this.size--);
    }
  }, {
    key: "clear",
    value: function() {
      this._obj = /* @__PURE__ */ Object.create(null);
    }
  }, {
    key: "has",
    value: function(r) {
      return this._obj[r] === 1;
    }
  }, {
    key: "toArray",
    value: function() {
      var r = this;
      return Object.keys(this._obj).filter(function(n) {
        return r.has(n);
      });
    }
  }, {
    key: "forEach",
    value: function(r, n) {
      return this.toArray().forEach(r, n);
    }
  }]);
}(), Mf = (typeof Set > "u" ? "undefined" : xn(Set)) !== Dwe ? Set : $we, Z1 = function(e, r) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
  if (e === void 0 || r === void 0 || !r3(e)) {
    Fr("An element must have a core reference and parameters set");
    return;
  }
  var a = r.group;
  if (a == null && (r.data && r.data.source != null && r.data.target != null ? a = "edges" : a = "nodes"), a !== "nodes" && a !== "edges") {
    Fr("An element must be of type `nodes` or `edges`; you specified `" + a + "`");
    return;
  }
  this.length = 1, this[0] = this;
  var i = this._private = {
    cy: e,
    single: !0,
    // indicates this is an element
    data: r.data || {},
    // data object
    position: r.position || {
      x: 0,
      y: 0
    },
    // (x, y) position pair
    autoWidth: void 0,
    // width and height of nodes calculated by the renderer when set to special 'auto' value
    autoHeight: void 0,
    autoPadding: void 0,
    compoundBoundsClean: !1,
    // whether the compound dimensions need to be recalculated the next time dimensions are read
    listeners: [],
    // array of bound listeners
    group: a,
    // string; 'nodes' or 'edges'
    style: {},
    // properties as set by the style
    rstyle: {},
    // properties for style sent from the renderer to the core
    styleCxts: [],
    // applied style contexts from the styler
    styleKeys: {},
    // per-group keys of style property values
    removed: !0,
    // whether it's inside the vis; true if removed (set true here since we call restore)
    selected: !!r.selected,
    // whether it's selected
    selectable: r.selectable === void 0 ? !0 : !!r.selectable,
    // whether it's selectable
    locked: !!r.locked,
    // whether the element is locked (cannot be moved)
    grabbed: !1,
    // whether the element is grabbed by the mouse; renderer sets this privately
    grabbable: r.grabbable === void 0 ? !0 : !!r.grabbable,
    // whether the element can be grabbed
    pannable: r.pannable === void 0 ? a === "edges" : !!r.pannable,
    // whether the element has passthrough panning enabled
    active: !1,
    // whether the element is active from user interaction
    classes: new Mf(),
    // map ( className => true )
    animation: {
      // object for currently-running animations
      current: [],
      queue: []
    },
    rscratch: {},
    // object in which the renderer can store information
    scratch: r.scratch || {},
    // scratch objects
    edges: [],
    // array of connected edges
    children: [],
    // array of children
    parent: r.parent && r.parent.isNode() ? r.parent : null,
    // parent ref
    traversalCache: {},
    // cache of output of traversal functions
    backgrounding: !1,
    // whether background images are loading
    bbCache: null,
    // cache of the current bounding box
    bbCacheShift: {
      x: 0,
      y: 0
    },
    // shift applied to cached bb to be applied on next get
    bodyBounds: null,
    // bounds cache of element body, w/o overlay
    overlayBounds: null,
    // bounds cache of element body, including overlay
    labelBounds: {
      // bounds cache of labels
      all: null,
      source: null,
      target: null,
      main: null
    },
    arrowBounds: {
      // bounds cache of edge arrows
      source: null,
      target: null,
      "mid-source": null,
      "mid-target": null
    }
  };
  if (i.position.x == null && (i.position.x = 0), i.position.y == null && (i.position.y = 0), r.renderedPosition) {
    var s = r.renderedPosition, o = e.pan(), l = e.zoom();
    i.position = {
      x: (s.x - o.x) / l,
      y: (s.y - o.y) / l
    };
  }
  var u = [];
  Sr(r.classes) ? u = r.classes : xt(r.classes) && (u = r.classes.split(/\s+/));
  for (var c = 0, f = u.length; c < f; c++) {
    var h = u[c];
    !h || h === "" || i.classes.add(h);
  }
  this.createEmitter(), (n === void 0 || n) && this.restore();
  var d = r.style || r.css;
  d && (pr("Setting a `style` bypass at element creation should be done only when absolutely necessary.  Try to use the stylesheet instead."), this.style(d));
}, EM = function(e) {
  return e = {
    bfs: e.bfs || !e.dfs,
    dfs: e.dfs || !e.bfs
  }, function(n, a, i) {
    var s;
    Qt(n) && !ri(n) && (s = n, n = s.roots || s.root, a = s.visit, i = s.directed), i = arguments.length === 2 && !Wr(a) ? a : i, a = Wr(a) ? a : function() {
    };
    for (var o = this._private.cy, l = n = xt(n) ? this.filter(n) : n, u = [], c = [], f = {}, h = {}, d = {}, p = 0, g, v = this.byGroup(), m = v.nodes, b = v.edges, y = 0; y < l.length; y++) {
      var x = l[y], E = x.id();
      x.isNode() && (u.unshift(x), e.bfs && (d[E] = !0, c.push(x)), h[E] = 0);
    }
    for (var S = function() {
      var O = e.bfs ? u.shift() : u.pop(), T = O.id();
      if (e.dfs) {
        if (d[T])
          return 0;
        d[T] = !0, c.push(O);
      }
      var L = h[T], M = f[T], A = M != null ? M.source() : null, I = M != null ? M.target() : null, D = M == null ? void 0 : O.same(A) ? I[0] : A[0], F;
      if (F = a(O, M, D, p++, L), F === !0)
        return g = O, 1;
      if (F === !1)
        return 1;
      for (var B = O.connectedEdges().filter(function(Z) {
        return (!i || Z.source().same(O)) && b.has(Z);
      }), G = 0; G < B.length; G++) {
        var H = B[G], K = H.connectedNodes().filter(function(Z) {
          return !Z.same(O) && m.has(Z);
        }), j = K.id();
        K.length !== 0 && !d[j] && (K = K[0], u.push(K), e.bfs && (d[j] = !0, c.push(K)), f[j] = H, h[j] = h[T] + 1);
      }
    }, w; u.length !== 0 && (w = S(), !(w !== 0 && w === 1)); )
      ;
    for (var C = o.collection(), k = 0; k < c.length; k++) {
      var N = c[k], R = f[N.id()];
      R != null && C.push(R), C.push(N);
    }
    return {
      path: o.collection(C),
      found: o.collection(g)
    };
  };
}, l0 = {
  breadthFirstSearch: EM({
    bfs: !0
  }),
  depthFirstSearch: EM({
    dfs: !0
  })
};
l0.bfs = l0.breadthFirstSearch;
l0.dfs = l0.depthFirstSearch;
var pv = { exports: {} }, Fwe = pv.exports, TM;
function Bwe() {
  return TM || (TM = 1, function(t, e) {
    (function() {
      var r, n, a, i, s, o, l, u, c, f, h, d, p, g, v;
      a = Math.floor, f = Math.min, n = function(m, b) {
        return m < b ? -1 : m > b ? 1 : 0;
      }, c = function(m, b, y, x, E) {
        var S;
        if (y == null && (y = 0), E == null && (E = n), y < 0)
          throw new Error("lo must be non-negative");
        for (x == null && (x = m.length); y < x; )
          S = a((y + x) / 2), E(b, m[S]) < 0 ? x = S : y = S + 1;
        return [].splice.apply(m, [y, y - y].concat(b)), b;
      }, o = function(m, b, y) {
        return y == null && (y = n), m.push(b), g(m, 0, m.length - 1, y);
      }, s = function(m, b) {
        var y, x;
        return b == null && (b = n), y = m.pop(), m.length ? (x = m[0], m[0] = y, v(m, 0, b)) : x = y, x;
      }, u = function(m, b, y) {
        var x;
        return y == null && (y = n), x = m[0], m[0] = b, v(m, 0, y), x;
      }, l = function(m, b, y) {
        var x;
        return y == null && (y = n), m.length && y(m[0], b) < 0 && (x = [m[0], b], b = x[0], m[0] = x[1], v(m, 0, y)), b;
      }, i = function(m, b) {
        var y, x, E, S, w, C;
        for (b == null && (b = n), S = (function() {
          C = [];
          for (var k = 0, N = a(m.length / 2); 0 <= N ? k < N : k > N; 0 <= N ? k++ : k--)
            C.push(k);
          return C;
        }).apply(this).reverse(), w = [], x = 0, E = S.length; x < E; x++)
          y = S[x], w.push(v(m, y, b));
        return w;
      }, p = function(m, b, y) {
        var x;
        if (y == null && (y = n), x = m.indexOf(b), x !== -1)
          return g(m, 0, x, y), v(m, x, y);
      }, h = function(m, b, y) {
        var x, E, S, w, C;
        if (y == null && (y = n), E = m.slice(0, b), !E.length)
          return E;
        for (i(E, y), C = m.slice(b), S = 0, w = C.length; S < w; S++)
          x = C[S], l(E, x, y);
        return E.sort(y).reverse();
      }, d = function(m, b, y) {
        var x, E, S, w, C, k, N, R, _;
        if (y == null && (y = n), b * 10 <= m.length) {
          if (S = m.slice(0, b).sort(y), !S.length)
            return S;
          for (E = S[S.length - 1], N = m.slice(b), w = 0, k = N.length; w < k; w++)
            x = N[w], y(x, E) < 0 && (c(S, x, 0, null, y), S.pop(), E = S[S.length - 1]);
          return S;
        }
        for (i(m, y), _ = [], C = 0, R = f(b, m.length); 0 <= R ? C < R : C > R; 0 <= R ? ++C : --C)
          _.push(s(m, y));
        return _;
      }, g = function(m, b, y, x) {
        var E, S, w;
        for (x == null && (x = n), E = m[y]; y > b; ) {
          if (w = y - 1 >> 1, S = m[w], x(E, S) < 0) {
            m[y] = S, y = w;
            continue;
          }
          break;
        }
        return m[y] = E;
      }, v = function(m, b, y) {
        var x, E, S, w, C;
        for (y == null && (y = n), E = m.length, C = b, S = m[b], x = 2 * b + 1; x < E; )
          w = x + 1, w < E && !(y(m[x], m[w]) < 0) && (x = w), m[b] = m[x], b = x, x = 2 * b + 1;
        return m[b] = S, g(m, C, b, y);
      }, r = function() {
        m.push = o, m.pop = s, m.replace = u, m.pushpop = l, m.heapify = i, m.updateItem = p, m.nlargest = h, m.nsmallest = d;
        function m(b) {
          this.cmp = b ?? n, this.nodes = [];
        }
        return m.prototype.push = function(b) {
          return o(this.nodes, b, this.cmp);
        }, m.prototype.pop = function() {
          return s(this.nodes, this.cmp);
        }, m.prototype.peek = function() {
          return this.nodes[0];
        }, m.prototype.contains = function(b) {
          return this.nodes.indexOf(b) !== -1;
        }, m.prototype.replace = function(b) {
          return u(this.nodes, b, this.cmp);
        }, m.prototype.pushpop = function(b) {
          return l(this.nodes, b, this.cmp);
        }, m.prototype.heapify = function() {
          return i(this.nodes, this.cmp);
        }, m.prototype.updateItem = function(b) {
          return p(this.nodes, b, this.cmp);
        }, m.prototype.clear = function() {
          return this.nodes = [];
        }, m.prototype.empty = function() {
          return this.nodes.length === 0;
        }, m.prototype.size = function() {
          return this.nodes.length;
        }, m.prototype.clone = function() {
          var b;
          return b = new m(), b.nodes = this.nodes.slice(0), b;
        }, m.prototype.toArray = function() {
          return this.nodes.slice(0);
        }, m.prototype.insert = m.prototype.push, m.prototype.top = m.prototype.peek, m.prototype.front = m.prototype.peek, m.prototype.has = m.prototype.contains, m.prototype.copy = m.prototype.clone, m;
      }(), function(m, b) {
        return t.exports = b();
      }(this, function() {
        return r;
      });
    }).call(Fwe);
  }(pv)), pv.exports;
}
var v2, SM;
function zwe() {
  return SM || (SM = 1, v2 = Bwe()), v2;
}
var Gwe = zwe(), dp = /* @__PURE__ */ up(Gwe), Uwe = Hn({
  root: null,
  weight: function(e) {
    return 1;
  },
  directed: !1
}), Hwe = {
  dijkstra: function(e) {
    if (!Qt(e)) {
      var r = arguments;
      e = {
        root: r[0],
        weight: r[1],
        directed: r[2]
      };
    }
    var n = Uwe(e), a = n.root, i = n.weight, s = n.directed, o = this, l = i, u = xt(a) ? this.filter(a)[0] : a[0], c = {}, f = {}, h = {}, d = this.byGroup(), p = d.nodes, g = d.edges;
    g.unmergeBy(function(L) {
      return L.isLoop();
    });
    for (var v = function(M) {
      return c[M.id()];
    }, m = function(M, A) {
      c[M.id()] = A, b.updateItem(M);
    }, b = new dp(function(L, M) {
      return v(L) - v(M);
    }), y = 0; y < p.length; y++) {
      var x = p[y];
      c[x.id()] = x.same(u) ? 0 : 1 / 0, b.push(x);
    }
    for (var E = function(M, A) {
      for (var I = (s ? M.edgesTo(A) : M.edgesWith(A)).intersect(g), D = 1 / 0, F, B = 0; B < I.length; B++) {
        var G = I[B], H = l(G);
        (H < D || !F) && (D = H, F = G);
      }
      return {
        edge: F,
        dist: D
      };
    }; b.size() > 0; ) {
      var S = b.pop(), w = v(S), C = S.id();
      if (h[C] = w, w !== 1 / 0)
        for (var k = S.neighborhood().intersect(p), N = 0; N < k.length; N++) {
          var R = k[N], _ = R.id(), O = E(S, R), T = w + O.dist;
          T < v(R) && (m(R, T), f[_] = {
            node: S,
            edge: O.edge
          });
        }
    }
    return {
      distanceTo: function(M) {
        var A = xt(M) ? p.filter(M)[0] : M[0];
        return h[A.id()];
      },
      pathTo: function(M) {
        var A = xt(M) ? p.filter(M)[0] : M[0], I = [], D = A, F = D.id();
        if (A.length > 0)
          for (I.unshift(A); f[F]; ) {
            var B = f[F];
            I.unshift(B.edge), I.unshift(B.node), D = B.node, F = D.id();
          }
        return o.spawn(I);
      }
    };
  }
}, Vwe = {
  // kruskal's algorithm (finds min spanning tree, assuming undirected graph)
  // implemented from pseudocode from wikipedia
  kruskal: function(e) {
    e = e || function(y) {
      return 1;
    };
    for (var r = this.byGroup(), n = r.nodes, a = r.edges, i = n.length, s = new Array(i), o = n, l = function(x) {
      for (var E = 0; E < s.length; E++) {
        var S = s[E];
        if (S.has(x))
          return E;
      }
    }, u = 0; u < i; u++)
      s[u] = this.spawn(n[u]);
    for (var c = a.sort(function(y, x) {
      return e(y) - e(x);
    }), f = 0; f < c.length; f++) {
      var h = c[f], d = h.source()[0], p = h.target()[0], g = l(d), v = l(p), m = s[g], b = s[v];
      g !== v && (o.merge(h), m.merge(b), s.splice(v, 1));
    }
    return o;
  }
}, qwe = Hn({
  root: null,
  goal: null,
  weight: function(e) {
    return 1;
  },
  heuristic: function(e) {
    return 0;
  },
  directed: !1
}), Wwe = {
  // Implemented from pseudocode from wikipedia
  aStar: function(e) {
    var r = this.cy(), n = qwe(e), a = n.root, i = n.goal, s = n.heuristic, o = n.directed, l = n.weight;
    a = r.collection(a)[0], i = r.collection(i)[0];
    var u = a.id(), c = i.id(), f = {}, h = {}, d = {}, p = new dp(function(F, B) {
      return h[F.id()] - h[B.id()];
    }), g = new Mf(), v = {}, m = {}, b = function(B, G) {
      p.push(B), g.add(G);
    }, y, x, E = function() {
      y = p.pop(), x = y.id(), g.delete(x);
    }, S = function(B) {
      return g.has(B);
    };
    b(a, u), f[u] = 0, h[u] = s(a);
    for (var w = 0; p.size() > 0; ) {
      if (E(), w++, x === c) {
        for (var C = [], k = i, N = c, R = m[N]; C.unshift(k), R != null && C.unshift(R), k = v[N], k != null; )
          N = k.id(), R = m[N];
        return {
          found: !0,
          distance: f[x],
          path: this.spawn(C),
          steps: w
        };
      }
      d[x] = !0;
      for (var _ = y._private.edges, O = 0; O < _.length; O++) {
        var T = _[O];
        if (this.hasElementWithId(T.id()) && !(o && T.data("source") !== x)) {
          var L = T.source(), M = T.target(), A = L.id() !== x ? L : M, I = A.id();
          if (this.hasElementWithId(I) && !d[I]) {
            var D = f[x] + l(T);
            if (!S(I)) {
              f[I] = D, h[I] = D + s(A), b(A, I), v[I] = y, m[I] = T;
              continue;
            }
            D < f[I] && (f[I] = D, h[I] = D + s(A), v[I] = y, m[I] = T);
          }
        }
      }
    }
    return {
      found: !1,
      distance: void 0,
      path: void 0,
      steps: w
    };
  }
}, jwe = Hn({
  weight: function(e) {
    return 1;
  },
  directed: !1
}), Ywe = {
  // Implemented from pseudocode from wikipedia
  floydWarshall: function(e) {
    for (var r = this.cy(), n = jwe(e), a = n.weight, i = n.directed, s = a, o = this.byGroup(), l = o.nodes, u = o.edges, c = l.length, f = c * c, h = function(H) {
      return l.indexOf(H);
    }, d = function(H) {
      return l[H];
    }, p = new Array(f), g = 0; g < f; g++) {
      var v = g % c, m = (g - v) / c;
      m === v ? p[g] = 0 : p[g] = 1 / 0;
    }
    for (var b = new Array(f), y = new Array(f), x = 0; x < u.length; x++) {
      var E = u[x], S = E.source()[0], w = E.target()[0];
      if (S !== w) {
        var C = h(S), k = h(w), N = C * c + k, R = s(E);
        if (p[N] > R && (p[N] = R, b[N] = k, y[N] = E), !i) {
          var _ = k * c + C;
          !i && p[_] > R && (p[_] = R, b[_] = C, y[_] = E);
        }
      }
    }
    for (var O = 0; O < c; O++)
      for (var T = 0; T < c; T++)
        for (var L = T * c + O, M = 0; M < c; M++) {
          var A = T * c + M, I = O * c + M;
          p[L] + p[I] < p[A] && (p[A] = p[L] + p[I], b[A] = b[L]);
        }
    var D = function(H) {
      return (xt(H) ? r.filter(H) : H)[0];
    }, F = function(H) {
      return h(D(H));
    }, B = {
      distance: function(H, K) {
        var j = F(H), Z = F(K);
        return p[j * c + Z];
      },
      path: function(H, K) {
        var j = F(H), Z = F(K), te = d(j);
        if (j === Z)
          return te.collection();
        if (b[j * c + Z] == null)
          return r.collection();
        var ne = r.collection(), V = j, q;
        for (ne.merge(te); j !== Z; )
          V = j, j = b[j * c + Z], q = y[V * c + j], ne.merge(q), ne.merge(d(j));
        return ne;
      }
    };
    return B;
  }
  // floydWarshall
}, Xwe = Hn({
  weight: function(e) {
    return 1;
  },
  directed: !1,
  root: null
}), Kwe = {
  // Implemented from pseudocode from wikipedia
  bellmanFord: function(e) {
    var r = this, n = Xwe(e), a = n.weight, i = n.directed, s = n.root, o = a, l = this, u = this.cy(), c = this.byGroup(), f = c.edges, h = c.nodes, d = h.length, p = new Xs(), g = !1, v = [];
    s = u.collection(s)[0], f.unmergeBy(function(Te) {
      return Te.isLoop();
    });
    for (var m = f.length, b = function(me) {
      var we = p.get(me.id());
      return we || (we = {}, p.set(me.id(), we)), we;
    }, y = function(me) {
      return (xt(me) ? u.$(me) : me)[0];
    }, x = function(me) {
      return b(y(me)).dist;
    }, E = function(me) {
      for (var we = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : s, Ae = y(me), Ne = [], Ie = Ae; ; ) {
        if (Ie == null)
          return r.spawn();
        var Me = b(Ie), _e = Me.edge, Be = Me.pred;
        if (Ne.unshift(Ie[0]), Ie.same(we) && Ne.length > 0)
          break;
        _e != null && Ne.unshift(_e), Ie = Be;
      }
      return l.spawn(Ne);
    }, S = 0; S < d; S++) {
      var w = h[S], C = b(w);
      w.same(s) ? C.dist = 0 : C.dist = 1 / 0, C.pred = null, C.edge = null;
    }
    for (var k = !1, N = function(me, we, Ae, Ne, Ie, Me) {
      var _e = Ne.dist + Me;
      _e < Ie.dist && !Ae.same(Ne.edge) && (Ie.dist = _e, Ie.pred = me, Ie.edge = Ae, k = !0);
    }, R = 1; R < d; R++) {
      k = !1;
      for (var _ = 0; _ < m; _++) {
        var O = f[_], T = O.source(), L = O.target(), M = o(O), A = b(T), I = b(L);
        N(T, L, O, A, I, M), i || N(L, T, O, I, A, M);
      }
      if (!k)
        break;
    }
    if (k)
      for (var D = [], F = 0; F < m; F++) {
        var B = f[F], G = B.source(), H = B.target(), K = o(B), j = b(G).dist, Z = b(H).dist;
        if (j + K < Z || !i && Z + K < j)
          if (g || (pr("Graph contains a negative weight cycle for Bellman-Ford"), g = !0), e.findNegativeWeightCycles !== !1) {
            var te = [];
            j + K < Z && te.push(G), !i && Z + K < j && te.push(H);
            for (var ne = te.length, V = 0; V < ne; V++) {
              var q = te[V], X = [q];
              X.push(b(q).edge);
              for (var W = b(q).pred; X.indexOf(W) === -1; )
                X.push(W), X.push(b(W).edge), W = b(W).pred;
              X = X.slice(X.indexOf(W));
              for (var ue = X[0].id(), J = 0, Ce = 2; Ce < X.length; Ce += 2)
                X[Ce].id() < ue && (ue = X[Ce].id(), J = Ce);
              X = X.slice(J).concat(X.slice(0, J)), X.push(X[0]);
              var Ee = X.map(function(Te) {
                return Te.id();
              }).join(",");
              D.indexOf(Ee) === -1 && (v.push(l.spawn(X)), D.push(Ee));
            }
          } else
            break;
      }
    return {
      distanceTo: x,
      pathTo: E,
      hasNegativeWeightCycle: g,
      negativeWeightCycles: v
    };
  }
  // bellmanFord
}, Zwe = Math.sqrt(2), Qwe = function(e, r, n) {
  n.length === 0 && Fr("Karger-Stein must be run on a connected (sub)graph");
  for (var a = n[e], i = a[1], s = a[2], o = r[i], l = r[s], u = n, c = u.length - 1; c >= 0; c--) {
    var f = u[c], h = f[1], d = f[2];
    (r[h] === o && r[d] === l || r[h] === l && r[d] === o) && u.splice(c, 1);
  }
  for (var p = 0; p < u.length; p++) {
    var g = u[p];
    g[1] === l ? (u[p] = g.slice(), u[p][1] = o) : g[2] === l && (u[p] = g.slice(), u[p][2] = o);
  }
  for (var v = 0; v < r.length; v++)
    r[v] === l && (r[v] = o);
  return u;
}, m2 = function(e, r, n, a) {
  for (; n > a; ) {
    var i = Math.floor(Math.random() * r.length);
    r = Qwe(i, e, r), n--;
  }
  return r;
}, Jwe = {
  // Computes the minimum cut of an undirected graph
  // Returns the correct answer with high probability
  kargerStein: function() {
    var e = this, r = this.byGroup(), n = r.nodes, a = r.edges;
    a.unmergeBy(function(I) {
      return I.isLoop();
    });
    var i = n.length, s = a.length, o = Math.ceil(Math.pow(Math.log(i) / Math.LN2, 2)), l = Math.floor(i / Zwe);
    if (i < 2) {
      Fr("At least 2 nodes are required for Karger-Stein algorithm");
      return;
    }
    for (var u = [], c = 0; c < s; c++) {
      var f = a[c];
      u.push([c, n.indexOf(f.source()), n.indexOf(f.target())]);
    }
    for (var h = 1 / 0, d = [], p = new Array(i), g = new Array(i), v = new Array(i), m = function(D, F) {
      for (var B = 0; B < i; B++)
        F[B] = D[B];
    }, b = 0; b <= o; b++) {
      for (var y = 0; y < i; y++)
        g[y] = y;
      var x = m2(g, u.slice(), i, l), E = x.slice();
      m(g, v);
      var S = m2(g, x, l, 2), w = m2(v, E, l, 2);
      S.length <= w.length && S.length < h ? (h = S.length, d = S, m(g, p)) : w.length <= S.length && w.length < h && (h = w.length, d = w, m(v, p));
    }
    for (var C = this.spawn(d.map(function(I) {
      return a[I[0]];
    })), k = this.spawn(), N = this.spawn(), R = p[0], _ = 0; _ < p.length; _++) {
      var O = p[_], T = n[_];
      O === R ? k.merge(T) : N.merge(T);
    }
    var L = function(D) {
      var F = e.spawn();
      return D.forEach(function(B) {
        F.merge(B), B.connectedEdges().forEach(function(G) {
          e.contains(G) && !C.contains(G) && F.merge(G);
        });
      }), F;
    }, M = [L(k), L(N)], A = {
      cut: C,
      components: M,
      // n.b. partitions are included to be compatible with the old api spec
      // (could be removed in a future major version)
      partition1: k,
      partition2: N
    };
    return A;
  }
}, y2, eEe = function(e) {
  return {
    x: e.x,
    y: e.y
  };
}, Q1 = function(e, r, n) {
  return {
    x: e.x * r + n.x,
    y: e.y * r + n.y
  };
}, UB = function(e, r, n) {
  return {
    x: (e.x - n.x) / r,
    y: (e.y - n.y) / r
  };
}, uc = function(e) {
  return {
    x: e[0],
    y: e[1]
  };
}, tEe = function(e) {
  for (var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : e.length, a = 1 / 0, i = r; i < n; i++) {
    var s = e[i];
    isFinite(s) && (a = Math.min(s, a));
  }
  return a;
}, rEe = function(e) {
  for (var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : e.length, a = -1 / 0, i = r; i < n; i++) {
    var s = e[i];
    isFinite(s) && (a = Math.max(s, a));
  }
  return a;
}, nEe = function(e) {
  for (var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : e.length, a = 0, i = 0, s = r; s < n; s++) {
    var o = e[s];
    isFinite(o) && (a += o, i++);
  }
  return a / i;
}, aEe = function(e) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : e.length, a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !0, i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0, s = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : !0;
  a ? e = e.slice(r, n) : (n < e.length && e.splice(n, e.length - n), r > 0 && e.splice(0, r));
  for (var o = 0, l = e.length - 1; l >= 0; l--) {
    var u = e[l];
    s ? isFinite(u) || (e[l] = -1 / 0, o++) : e.splice(l, 1);
  }
  i && e.sort(function(h, d) {
    return h - d;
  });
  var c = e.length, f = Math.floor(c / 2);
  return c % 2 !== 0 ? e[f + 1 + o] : (e[f - 1 + o] + e[f + o]) / 2;
}, iEe = function(e) {
  return Math.PI * e / 180;
}, cg = function(e, r) {
  return Math.atan2(r, e) - Math.PI / 2;
}, l3 = Math.log2 || function(t) {
  return Math.log(t) / Math.log(2);
}, u3 = function(e) {
  return e > 0 ? 1 : e < 0 ? -1 : 0;
}, su = function(e, r) {
  return Math.sqrt(Ll(e, r));
}, Ll = function(e, r) {
  var n = r.x - e.x, a = r.y - e.y;
  return n * n + a * a;
}, sEe = function(e) {
  for (var r = e.length, n = 0, a = 0; a < r; a++)
    n += e[a];
  for (var i = 0; i < r; i++)
    e[i] = e[i] / n;
  return e;
}, Cn = function(e, r, n, a) {
  return (1 - a) * (1 - a) * e + 2 * (1 - a) * a * r + a * a * n;
}, wc = function(e, r, n, a) {
  return {
    x: Cn(e.x, r.x, n.x, a),
    y: Cn(e.y, r.y, n.y, a)
  };
}, oEe = function(e, r, n, a) {
  var i = {
    x: r.x - e.x,
    y: r.y - e.y
  }, s = su(e, r), o = {
    x: i.x / s,
    y: i.y / s
  };
  return n = n ?? 0, a = a ?? n * s, {
    x: e.x + o.x * a,
    y: e.y + o.y * a
  };
}, u0 = function(e, r, n) {
  return Math.max(e, Math.min(n, r));
}, da = function(e) {
  if (e == null)
    return {
      x1: 1 / 0,
      y1: 1 / 0,
      x2: -1 / 0,
      y2: -1 / 0,
      w: 0,
      h: 0
    };
  if (e.x1 != null && e.y1 != null) {
    if (e.x2 != null && e.y2 != null && e.x2 >= e.x1 && e.y2 >= e.y1)
      return {
        x1: e.x1,
        y1: e.y1,
        x2: e.x2,
        y2: e.y2,
        w: e.x2 - e.x1,
        h: e.y2 - e.y1
      };
    if (e.w != null && e.h != null && e.w >= 0 && e.h >= 0)
      return {
        x1: e.x1,
        y1: e.y1,
        x2: e.x1 + e.w,
        y2: e.y1 + e.h,
        w: e.w,
        h: e.h
      };
  }
}, lEe = function(e) {
  return {
    x1: e.x1,
    x2: e.x2,
    w: e.w,
    y1: e.y1,
    y2: e.y2,
    h: e.h
  };
}, uEe = function(e) {
  e.x1 = 1 / 0, e.y1 = 1 / 0, e.x2 = -1 / 0, e.y2 = -1 / 0, e.w = 0, e.h = 0;
}, cEe = function(e, r) {
  e.x1 = Math.min(e.x1, r.x1), e.x2 = Math.max(e.x2, r.x2), e.w = e.x2 - e.x1, e.y1 = Math.min(e.y1, r.y1), e.y2 = Math.max(e.y2, r.y2), e.h = e.y2 - e.y1;
}, HB = function(e, r, n) {
  e.x1 = Math.min(e.x1, r), e.x2 = Math.max(e.x2, r), e.w = e.x2 - e.x1, e.y1 = Math.min(e.y1, n), e.y2 = Math.max(e.y2, n), e.h = e.y2 - e.y1;
}, gv = function(e) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  return e.x1 -= r, e.x2 += r, e.y1 -= r, e.y2 += r, e.w = e.x2 - e.x1, e.h = e.y2 - e.y1, e;
}, vv = function(e) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0], n, a, i, s;
  if (r.length === 1)
    n = a = i = s = r[0];
  else if (r.length === 2)
    n = i = r[0], s = a = r[1];
  else if (r.length === 4) {
    var o = ln(r, 4);
    n = o[0], a = o[1], i = o[2], s = o[3];
  }
  return e.x1 -= s, e.x2 += a, e.y1 -= n, e.y2 += i, e.w = e.x2 - e.x1, e.h = e.y2 - e.y1, e;
}, CM = function(e, r) {
  e.x1 = r.x1, e.y1 = r.y1, e.x2 = r.x2, e.y2 = r.y2, e.w = e.x2 - e.x1, e.h = e.y2 - e.y1;
}, c3 = function(e, r) {
  return !(e.x1 > r.x2 || r.x1 > e.x2 || e.x2 < r.x1 || r.x2 < e.x1 || e.y2 < r.y1 || r.y2 < e.y1 || e.y1 > r.y2 || r.y1 > e.y2);
}, Do = function(e, r, n) {
  return e.x1 <= r && r <= e.x2 && e.y1 <= n && n <= e.y2;
}, AM = function(e, r) {
  return Do(e, r.x, r.y);
}, VB = function(e, r) {
  return Do(e, r.x1, r.y1) && Do(e, r.x2, r.y2);
}, fEe = (y2 = Math.hypot) !== null && y2 !== void 0 ? y2 : function(t, e) {
  return Math.sqrt(t * t + e * e);
};
function hEe(t, e) {
  if (t.length < 3)
    throw new Error("Need at least 3 vertices");
  var r = function(C, k) {
    return {
      x: C.x + k.x,
      y: C.y + k.y
    };
  }, n = function(C, k) {
    return {
      x: C.x - k.x,
      y: C.y - k.y
    };
  }, a = function(C, k) {
    return {
      x: C.x * k,
      y: C.y * k
    };
  }, i = function(C, k) {
    return C.x * k.y - C.y * k.x;
  }, s = function(C) {
    var k = fEe(C.x, C.y);
    return k === 0 ? {
      x: 0,
      y: 0
    } : {
      x: C.x / k,
      y: C.y / k
    };
  }, o = function(C) {
    for (var k = 0, N = 0; N < C.length; N++) {
      var R = C[N], _ = C[(N + 1) % C.length];
      k += R.x * _.y - _.x * R.y;
    }
    return k / 2;
  }, l = function(C, k, N, R) {
    var _ = n(k, C), O = n(R, N), T = i(_, O);
    if (Math.abs(T) < 1e-9)
      return r(C, a(_, 0.5));
    var L = i(n(N, C), O) / T;
    return r(C, a(_, L));
  }, u = t.map(function(w) {
    return {
      x: w.x,
      y: w.y
    };
  });
  o(u) < 0 && u.reverse();
  for (var c = u.length, f = [], h = 0; h < c; h++) {
    var d = u[h], p = u[(h + 1) % c], g = n(p, d), v = s({
      x: g.y,
      y: -g.x
    });
    f.push(v);
  }
  for (var m = f.map(function(w, C) {
    var k = r(u[C], a(w, e)), N = r(u[(C + 1) % c], a(w, e));
    return {
      p1: k,
      p2: N
    };
  }), b = [], y = 0; y < c; y++) {
    var x = m[(y - 1 + c) % c], E = m[y], S = l(x.p1, x.p2, E.p1, E.p2);
    b.push(S);
  }
  return b;
}
function dEe(t, e, r, n, a, i) {
  var s = EEe(t, e, r, n, a), o = hEe(s, i), l = da();
  return o.forEach(function(u) {
    return HB(l, u.x, u.y);
  }), l;
}
var qB = function(e, r, n, a, i, s, o) {
  var l = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : "auto", u = l === "auto" ? Xo(i, s) : l, c = i / 2, f = s / 2;
  u = Math.min(u, c, f);
  var h = u !== c, d = u !== f, p;
  if (h) {
    var g = n - c + u - o, v = a - f - o, m = n + c - u + o, b = v;
    if (p = $o(e, r, n, a, g, v, m, b, !1), p.length > 0)
      return p;
  }
  if (d) {
    var y = n + c + o, x = a - f + u - o, E = y, S = a + f - u + o;
    if (p = $o(e, r, n, a, y, x, E, S, !1), p.length > 0)
      return p;
  }
  if (h) {
    var w = n - c + u - o, C = a + f + o, k = n + c - u + o, N = C;
    if (p = $o(e, r, n, a, w, C, k, N, !1), p.length > 0)
      return p;
  }
  if (d) {
    var R = n - c - o, _ = a - f + u - o, O = R, T = a + f - u + o;
    if (p = $o(e, r, n, a, R, _, O, T, !1), p.length > 0)
      return p;
  }
  var L;
  {
    var M = n - c + u, A = a - f + u;
    if (L = _h(e, r, n, a, M, A, u + o), L.length > 0 && L[0] <= M && L[1] <= A)
      return [L[0], L[1]];
  }
  {
    var I = n + c - u, D = a - f + u;
    if (L = _h(e, r, n, a, I, D, u + o), L.length > 0 && L[0] >= I && L[1] <= D)
      return [L[0], L[1]];
  }
  {
    var F = n + c - u, B = a + f - u;
    if (L = _h(e, r, n, a, F, B, u + o), L.length > 0 && L[0] >= F && L[1] >= B)
      return [L[0], L[1]];
  }
  {
    var G = n - c + u, H = a + f - u;
    if (L = _h(e, r, n, a, G, H, u + o), L.length > 0 && L[0] <= G && L[1] >= H)
      return [L[0], L[1]];
  }
  return [];
}, pEe = function(e, r, n, a, i, s, o) {
  var l = o, u = Math.min(n, i), c = Math.max(n, i), f = Math.min(a, s), h = Math.max(a, s);
  return u - l <= e && e <= c + l && f - l <= r && r <= h + l;
}, gEe = function(e, r, n, a, i, s, o, l, u) {
  var c = {
    x1: Math.min(n, o, i) - u,
    x2: Math.max(n, o, i) + u,
    y1: Math.min(a, l, s) - u,
    y2: Math.max(a, l, s) + u
  };
  return !(e < c.x1 || e > c.x2 || r < c.y1 || r > c.y2);
}, vEe = function(e, r, n, a) {
  n -= a;
  var i = r * r - 4 * e * n;
  if (i < 0)
    return [];
  var s = Math.sqrt(i), o = 2 * e, l = (-r + s) / o, u = (-r - s) / o;
  return [l, u];
}, mEe = function(e, r, n, a, i) {
  var s = 1e-5;
  e === 0 && (e = s), r /= e, n /= e, a /= e;
  var o, l, u, c, f, h, d, p;
  if (l = (3 * n - r * r) / 9, u = -(27 * a) + r * (9 * n - 2 * (r * r)), u /= 54, o = l * l * l + u * u, i[1] = 0, d = r / 3, o > 0) {
    f = u + Math.sqrt(o), f = f < 0 ? -Math.pow(-f, 1 / 3) : Math.pow(f, 1 / 3), h = u - Math.sqrt(o), h = h < 0 ? -Math.pow(-h, 1 / 3) : Math.pow(h, 1 / 3), i[0] = -d + f + h, d += (f + h) / 2, i[4] = i[2] = -d, d = Math.sqrt(3) * (-h + f) / 2, i[3] = d, i[5] = -d;
    return;
  }
  if (i[5] = i[3] = 0, o === 0) {
    p = u < 0 ? -Math.pow(-u, 1 / 3) : Math.pow(u, 1 / 3), i[0] = -d + 2 * p, i[4] = i[2] = -(p + d);
    return;
  }
  l = -l, c = l * l * l, c = Math.acos(u / Math.sqrt(c)), p = 2 * Math.sqrt(l), i[0] = -d + p * Math.cos(c / 3), i[2] = -d + p * Math.cos((c + 2 * Math.PI) / 3), i[4] = -d + p * Math.cos((c + 4 * Math.PI) / 3);
}, yEe = function(e, r, n, a, i, s, o, l) {
  var u = 1 * n * n - 4 * n * i + 2 * n * o + 4 * i * i - 4 * i * o + o * o + a * a - 4 * a * s + 2 * a * l + 4 * s * s - 4 * s * l + l * l, c = 1 * 9 * n * i - 3 * n * n - 3 * n * o - 6 * i * i + 3 * i * o + 9 * a * s - 3 * a * a - 3 * a * l - 6 * s * s + 3 * s * l, f = 1 * 3 * n * n - 6 * n * i + n * o - n * e + 2 * i * i + 2 * i * e - o * e + 3 * a * a - 6 * a * s + a * l - a * r + 2 * s * s + 2 * s * r - l * r, h = 1 * n * i - n * n + n * e - i * e + a * s - a * a + a * r - s * r, d = [];
  mEe(u, c, f, h, d);
  for (var p = 1e-7, g = [], v = 0; v < 6; v += 2)
    Math.abs(d[v + 1]) < p && d[v] >= 0 && d[v] <= 1 && g.push(d[v]);
  g.push(1), g.push(0);
  for (var m = -1, b, y, x, E = 0; E < g.length; E++)
    b = Math.pow(1 - g[E], 2) * n + 2 * (1 - g[E]) * g[E] * i + g[E] * g[E] * o, y = Math.pow(1 - g[E], 2) * a + 2 * (1 - g[E]) * g[E] * s + g[E] * g[E] * l, x = Math.pow(b - e, 2) + Math.pow(y - r, 2), m >= 0 ? x < m && (m = x) : m = x;
  return m;
}, bEe = function(e, r, n, a, i, s) {
  var o = [e - n, r - a], l = [i - n, s - a], u = l[0] * l[0] + l[1] * l[1], c = o[0] * o[0] + o[1] * o[1], f = o[0] * l[0] + o[1] * l[1], h = f * f / u;
  return f < 0 ? c : h > u ? (e - i) * (e - i) + (r - s) * (r - s) : c - h;
}, Sa = function(e, r, n) {
  for (var a, i, s, o, l, u = 0, c = 0; c < n.length / 2; c++)
    if (a = n[c * 2], i = n[c * 2 + 1], c + 1 < n.length / 2 ? (s = n[(c + 1) * 2], o = n[(c + 1) * 2 + 1]) : (s = n[(c + 1 - n.length / 2) * 2], o = n[(c + 1 - n.length / 2) * 2 + 1]), !(a == e && s == e)) if (a >= e && e >= s || a <= e && e <= s)
      l = (e - a) / (s - a) * (o - i) + i, l > r && u++;
    else
      continue;
  return u % 2 !== 0;
}, co = function(e, r, n, a, i, s, o, l, u) {
  var c = new Array(n.length), f;
  l[0] != null ? (f = Math.atan(l[1] / l[0]), l[0] < 0 ? f = f + Math.PI / 2 : f = -f - Math.PI / 2) : f = l;
  for (var h = Math.cos(-f), d = Math.sin(-f), p = 0; p < c.length / 2; p++)
    c[p * 2] = s / 2 * (n[p * 2] * h - n[p * 2 + 1] * d), c[p * 2 + 1] = o / 2 * (n[p * 2 + 1] * h + n[p * 2] * d), c[p * 2] += a, c[p * 2 + 1] += i;
  var g;
  if (u > 0) {
    var v = zm(c, -u);
    g = Bm(v);
  } else
    g = c;
  return Sa(e, r, g);
}, xEe = function(e, r, n, a, i, s, o, l) {
  for (var u = new Array(n.length * 2), c = 0; c < l.length; c++) {
    var f = l[c];
    u[c * 4 + 0] = f.startX, u[c * 4 + 1] = f.startY, u[c * 4 + 2] = f.stopX, u[c * 4 + 3] = f.stopY;
    var h = Math.pow(f.cx - e, 2) + Math.pow(f.cy - r, 2);
    if (h <= Math.pow(f.radius, 2))
      return !0;
  }
  return Sa(e, r, u);
}, Bm = function(e) {
  for (var r = new Array(e.length / 2), n, a, i, s, o, l, u, c, f = 0; f < e.length / 4; f++) {
    n = e[f * 4], a = e[f * 4 + 1], i = e[f * 4 + 2], s = e[f * 4 + 3], f < e.length / 4 - 1 ? (o = e[(f + 1) * 4], l = e[(f + 1) * 4 + 1], u = e[(f + 1) * 4 + 2], c = e[(f + 1) * 4 + 3]) : (o = e[0], l = e[1], u = e[2], c = e[3]);
    var h = $o(n, a, i, s, o, l, u, c, !0);
    r[f * 2] = h[0], r[f * 2 + 1] = h[1];
  }
  return r;
}, zm = function(e, r) {
  for (var n = new Array(e.length * 2), a, i, s, o, l = 0; l < e.length / 2; l++) {
    a = e[l * 2], i = e[l * 2 + 1], l < e.length / 2 - 1 ? (s = e[(l + 1) * 2], o = e[(l + 1) * 2 + 1]) : (s = e[0], o = e[1]);
    var u = o - i, c = -(s - a), f = Math.sqrt(u * u + c * c), h = u / f, d = c / f;
    n[l * 4] = a + h * r, n[l * 4 + 1] = i + d * r, n[l * 4 + 2] = s + h * r, n[l * 4 + 3] = o + d * r;
  }
  return n;
}, wEe = function(e, r, n, a, i, s) {
  var o = n - e, l = a - r;
  o /= i, l /= s;
  var u = Math.sqrt(o * o + l * l), c = u - 1;
  if (c < 0)
    return [];
  var f = c / u;
  return [(n - e) * f + e, (a - r) * f + r];
}, Ul = function(e, r, n, a, i, s, o) {
  return e -= i, r -= s, e /= n / 2 + o, r /= a / 2 + o, e * e + r * r <= 1;
}, _h = function(e, r, n, a, i, s, o) {
  var l = [n - e, a - r], u = [e - i, r - s], c = l[0] * l[0] + l[1] * l[1], f = 2 * (u[0] * l[0] + u[1] * l[1]), h = u[0] * u[0] + u[1] * u[1] - o * o, d = f * f - 4 * c * h;
  if (d < 0)
    return [];
  var p = (-f + Math.sqrt(d)) / (2 * c), g = (-f - Math.sqrt(d)) / (2 * c), v = Math.min(p, g), m = Math.max(p, g), b = [];
  if (v >= 0 && v <= 1 && b.push(v), m >= 0 && m <= 1 && b.push(m), b.length === 0)
    return [];
  var y = b[0] * l[0] + e, x = b[0] * l[1] + r;
  if (b.length > 1) {
    if (b[0] == b[1])
      return [y, x];
    var E = b[1] * l[0] + e, S = b[1] * l[1] + r;
    return [y, x, E, S];
  } else
    return [y, x];
}, b2 = function(e, r, n) {
  return r <= e && e <= n || n <= e && e <= r ? e : e <= r && r <= n || n <= r && r <= e ? r : n;
}, $o = function(e, r, n, a, i, s, o, l, u) {
  var c = e - i, f = n - e, h = o - i, d = r - s, p = a - r, g = l - s, v = h * d - g * c, m = f * d - p * c, b = g * f - h * p;
  if (b !== 0) {
    var y = v / b, x = m / b, E = 1e-3, S = 0 - E, w = 1 + E;
    return S <= y && y <= w && S <= x && x <= w ? [e + y * f, r + y * p] : u ? [e + y * f, r + y * p] : [];
  } else
    return v === 0 || m === 0 ? b2(e, n, o) === o ? [o, l] : b2(e, n, i) === i ? [i, s] : b2(i, o, n) === n ? [n, a] : [] : [];
}, EEe = function(e, r, n, a, i) {
  var s = [], o = a / 2, l = i / 2, u = r, c = n;
  s.push({
    x: u + o * e[0],
    y: c + l * e[1]
  });
  for (var f = 1; f < e.length / 2; f++)
    s.push({
      x: u + o * e[f * 2],
      y: c + l * e[f * 2 + 1]
    });
  return s;
}, c0 = function(e, r, n, a, i, s, o, l) {
  var u = [], c, f = new Array(n.length), h = !0;
  s == null && (h = !1);
  var d;
  if (h) {
    for (var p = 0; p < f.length / 2; p++)
      f[p * 2] = n[p * 2] * s + a, f[p * 2 + 1] = n[p * 2 + 1] * o + i;
    if (l > 0) {
      var g = zm(f, -l);
      d = Bm(g);
    } else
      d = f;
  } else
    d = n;
  for (var v, m, b, y, x = 0; x < d.length / 2; x++)
    v = d[x * 2], m = d[x * 2 + 1], x < d.length / 2 - 1 ? (b = d[(x + 1) * 2], y = d[(x + 1) * 2 + 1]) : (b = d[0], y = d[1]), c = $o(e, r, a, i, v, m, b, y), c.length !== 0 && u.push(c[0], c[1]);
  return u;
}, TEe = function(e, r, n, a, i, s, o, l, u) {
  var c = [], f, h = new Array(n.length * 2);
  u.forEach(function(b, y) {
    y === 0 ? (h[h.length - 2] = b.startX, h[h.length - 1] = b.startY) : (h[y * 4 - 2] = b.startX, h[y * 4 - 1] = b.startY), h[y * 4] = b.stopX, h[y * 4 + 1] = b.stopY, f = _h(e, r, a, i, b.cx, b.cy, b.radius), f.length !== 0 && c.push(f[0], f[1]);
  });
  for (var d = 0; d < h.length / 4; d++)
    f = $o(e, r, a, i, h[d * 4], h[d * 4 + 1], h[d * 4 + 2], h[d * 4 + 3], !1), f.length !== 0 && c.push(f[0], f[1]);
  if (c.length > 2) {
    for (var p = [c[0], c[1]], g = Math.pow(p[0] - e, 2) + Math.pow(p[1] - r, 2), v = 1; v < c.length / 2; v++) {
      var m = Math.pow(c[v * 2] - e, 2) + Math.pow(c[v * 2 + 1] - r, 2);
      m <= g && (p[0] = c[v * 2], p[1] = c[v * 2 + 1], g = m);
    }
    return p;
  }
  return c;
}, fg = function(e, r, n) {
  var a = [e[0] - r[0], e[1] - r[1]], i = Math.sqrt(a[0] * a[0] + a[1] * a[1]), s = (i - n) / i;
  return s < 0 && (s = 1e-5), [r[0] + s * a[0], r[1] + s * a[1]];
}, oa = function(e, r) {
  var n = y4(e, r);
  return n = WB(n), n;
}, WB = function(e) {
  for (var r, n, a = e.length / 2, i = 1 / 0, s = 1 / 0, o = -1 / 0, l = -1 / 0, u = 0; u < a; u++)
    r = e[2 * u], n = e[2 * u + 1], i = Math.min(i, r), o = Math.max(o, r), s = Math.min(s, n), l = Math.max(l, n);
  for (var c = 2 / (o - i), f = 2 / (l - s), h = 0; h < a; h++)
    r = e[2 * h] = e[2 * h] * c, n = e[2 * h + 1] = e[2 * h + 1] * f, i = Math.min(i, r), o = Math.max(o, r), s = Math.min(s, n), l = Math.max(l, n);
  if (s < -1)
    for (var d = 0; d < a; d++)
      n = e[2 * d + 1] = e[2 * d + 1] + (-1 - s);
  return e;
}, y4 = function(e, r) {
  var n = 1 / e * 2 * Math.PI, a = e % 2 === 0 ? Math.PI / 2 + n / 2 : Math.PI / 2;
  a += r;
  for (var i = new Array(e * 2), s, o = 0; o < e; o++)
    s = o * n + a, i[2 * o] = Math.cos(s), i[2 * o + 1] = Math.sin(-s);
  return i;
}, Xo = function(e, r) {
  return Math.min(e / 4, r / 4, 8);
}, jB = function(e, r) {
  return Math.min(e / 10, r / 10, 8);
}, f3 = function() {
  return 8;
}, SEe = function(e, r, n) {
  return [e - 2 * r + n, 2 * (r - e), e];
}, b4 = function(e, r) {
  return {
    heightOffset: Math.min(15, 0.05 * r),
    widthOffset: Math.min(100, 0.25 * e),
    ctrlPtOffsetPct: 0.05
  };
};
function x2(t, e) {
  function r(f) {
    for (var h = [], d = 0; d < f.length; d++) {
      var p = f[d], g = f[(d + 1) % f.length], v = {
        x: g.x - p.x,
        y: g.y - p.y
      }, m = {
        x: -v.y,
        y: v.x
      }, b = Math.sqrt(m.x * m.x + m.y * m.y);
      h.push({
        x: m.x / b,
        y: m.y / b
      });
    }
    return h;
  }
  function n(f, h) {
    var d = 1 / 0, p = -1 / 0, g = Ca(f), v;
    try {
      for (g.s(); !(v = g.n()).done; ) {
        var m = v.value, b = m.x * h.x + m.y * h.y;
        d = Math.min(d, b), p = Math.max(p, b);
      }
    } catch (y) {
      g.e(y);
    } finally {
      g.f();
    }
    return {
      min: d,
      max: p
    };
  }
  function a(f, h) {
    return !(f.max < h.min || h.max < f.min);
  }
  var i = [].concat(Pm(r(t)), Pm(r(e))), s = Ca(i), o;
  try {
    for (s.s(); !(o = s.n()).done; ) {
      var l = o.value, u = n(t, l), c = n(e, l);
      if (!a(u, c))
        return !1;
    }
  } catch (f) {
    s.e(f);
  } finally {
    s.f();
  }
  return !0;
}
var CEe = Hn({
  dampingFactor: 0.8,
  precision: 1e-6,
  iterations: 200,
  weight: function(e) {
    return 1;
  }
}), AEe = {
  pageRank: function(e) {
    for (var r = CEe(e), n = r.dampingFactor, a = r.precision, i = r.iterations, s = r.weight, o = this._private.cy, l = this.byGroup(), u = l.nodes, c = l.edges, f = u.length, h = f * f, d = c.length, p = new Array(h), g = new Array(f), v = (1 - n) / f, m = 0; m < f; m++) {
      for (var b = 0; b < f; b++) {
        var y = m * f + b;
        p[y] = 0;
      }
      g[m] = 0;
    }
    for (var x = 0; x < d; x++) {
      var E = c[x], S = E.data("source"), w = E.data("target");
      if (S !== w) {
        var C = u.indexOfId(S), k = u.indexOfId(w), N = s(E), R = k * f + C;
        p[R] += N, g[C] += N;
      }
    }
    for (var _ = 1 / f + v, O = 0; O < f; O++)
      if (g[O] === 0)
        for (var T = 0; T < f; T++) {
          var L = T * f + O;
          p[L] = _;
        }
      else
        for (var M = 0; M < f; M++) {
          var A = M * f + O;
          p[A] = p[A] / g[O] + v;
        }
    for (var I = new Array(f), D = new Array(f), F, B = 0; B < f; B++)
      I[B] = 1;
    for (var G = 0; G < i; G++) {
      for (var H = 0; H < f; H++)
        D[H] = 0;
      for (var K = 0; K < f; K++)
        for (var j = 0; j < f; j++) {
          var Z = K * f + j;
          D[K] += p[Z] * I[j];
        }
      sEe(D), F = I, I = D, D = F;
      for (var te = 0, ne = 0; ne < f; ne++) {
        var V = F[ne] - I[ne];
        te += V * V;
      }
      if (te < a)
        break;
    }
    var q = {
      rank: function(W) {
        return W = o.collection(W)[0], I[u.indexOf(W)];
      }
    };
    return q;
  }
  // pageRank
}, kM = Hn({
  root: null,
  weight: function(e) {
    return 1;
  },
  directed: !1,
  alpha: 0
}), Ec = {
  degreeCentralityNormalized: function(e) {
    e = kM(e);
    var r = this.cy(), n = this.nodes(), a = n.length;
    if (e.directed) {
      for (var c = {}, f = {}, h = 0, d = 0, p = 0; p < a; p++) {
        var g = n[p], v = g.id();
        e.root = g;
        var m = this.degreeCentrality(e);
        h < m.indegree && (h = m.indegree), d < m.outdegree && (d = m.outdegree), c[v] = m.indegree, f[v] = m.outdegree;
      }
      return {
        indegree: function(y) {
          return h == 0 ? 0 : (xt(y) && (y = r.filter(y)), c[y.id()] / h);
        },
        outdegree: function(y) {
          return d === 0 ? 0 : (xt(y) && (y = r.filter(y)), f[y.id()] / d);
        }
      };
    } else {
      for (var i = {}, s = 0, o = 0; o < a; o++) {
        var l = n[o];
        e.root = l;
        var u = this.degreeCentrality(e);
        s < u.degree && (s = u.degree), i[l.id()] = u.degree;
      }
      return {
        degree: function(y) {
          return s === 0 ? 0 : (xt(y) && (y = r.filter(y)), i[y.id()] / s);
        }
      };
    }
  },
  // degreeCentralityNormalized
  // Implemented from the algorithm in Opsahl's paper
  // "Node centrality in weighted networks: Generalizing degree and shortest paths"
  // check the heading 2 "Degree"
  degreeCentrality: function(e) {
    e = kM(e);
    var r = this.cy(), n = this, a = e, i = a.root, s = a.weight, o = a.directed, l = a.alpha;
    if (i = r.collection(i)[0], o) {
      for (var d = i.connectedEdges(), p = d.filter(function(S) {
        return S.target().same(i) && n.has(S);
      }), g = d.filter(function(S) {
        return S.source().same(i) && n.has(S);
      }), v = p.length, m = g.length, b = 0, y = 0, x = 0; x < p.length; x++)
        b += s(p[x]);
      for (var E = 0; E < g.length; E++)
        y += s(g[E]);
      return {
        indegree: Math.pow(v, 1 - l) * Math.pow(b, l),
        outdegree: Math.pow(m, 1 - l) * Math.pow(y, l)
      };
    } else {
      for (var u = i.connectedEdges().intersection(n), c = u.length, f = 0, h = 0; h < u.length; h++)
        f += s(u[h]);
      return {
        degree: Math.pow(c, 1 - l) * Math.pow(f, l)
      };
    }
  }
  // degreeCentrality
};
Ec.dc = Ec.degreeCentrality;
Ec.dcn = Ec.degreeCentralityNormalised = Ec.degreeCentralityNormalized;
var RM = Hn({
  harmonic: !0,
  weight: function() {
    return 1;
  },
  directed: !1,
  root: null
}), Tc = {
  closenessCentralityNormalized: function(e) {
    for (var r = RM(e), n = r.harmonic, a = r.weight, i = r.directed, s = this.cy(), o = {}, l = 0, u = this.nodes(), c = this.floydWarshall({
      weight: a,
      directed: i
    }), f = 0; f < u.length; f++) {
      for (var h = 0, d = u[f], p = 0; p < u.length; p++)
        if (f !== p) {
          var g = c.distance(d, u[p]);
          n ? h += 1 / g : h += g;
        }
      n || (h = 1 / h), l < h && (l = h), o[d.id()] = h;
    }
    return {
      closeness: function(m) {
        return l == 0 ? 0 : (xt(m) ? m = s.filter(m)[0].id() : m = m.id(), o[m] / l);
      }
    };
  },
  // Implemented from pseudocode from wikipedia
  closenessCentrality: function(e) {
    var r = RM(e), n = r.root, a = r.weight, i = r.directed, s = r.harmonic;
    n = this.filter(n)[0];
    for (var o = this.dijkstra({
      root: n,
      weight: a,
      directed: i
    }), l = 0, u = this.nodes(), c = 0; c < u.length; c++) {
      var f = u[c];
      if (!f.same(n)) {
        var h = o.distanceTo(f);
        s ? l += 1 / h : l += h;
      }
    }
    return s ? l : 1 / l;
  }
  // closenessCentrality
};
Tc.cc = Tc.closenessCentrality;
Tc.ccn = Tc.closenessCentralityNormalised = Tc.closenessCentralityNormalized;
var kEe = Hn({
  weight: null,
  directed: !1
}), x4 = {
  // Implemented from the algorithm in the paper "On Variants of Shortest-Path Betweenness Centrality and their Generic Computation" by Ulrik Brandes
  betweennessCentrality: function(e) {
    for (var r = kEe(e), n = r.directed, a = r.weight, i = a != null, s = this.cy(), o = this.nodes(), l = {}, u = {}, c = 0, f = {
      set: function(y, x) {
        u[y] = x, x > c && (c = x);
      },
      get: function(y) {
        return u[y];
      }
    }, h = 0; h < o.length; h++) {
      var d = o[h], p = d.id();
      n ? l[p] = d.outgoers().nodes() : l[p] = d.openNeighborhood().nodes(), f.set(p, 0);
    }
    for (var g = function() {
      for (var y = o[v].id(), x = [], E = {}, S = {}, w = {}, C = new dp(function(K, j) {
        return w[K] - w[j];
      }), k = 0; k < o.length; k++) {
        var N = o[k].id();
        E[N] = [], S[N] = 0, w[N] = 1 / 0;
      }
      for (S[y] = 1, w[y] = 0, C.push(y); !C.empty(); ) {
        var R = C.pop();
        if (x.push(R), i)
          for (var _ = 0; _ < l[R].length; _++) {
            var O = l[R][_], T = s.getElementById(R), L = void 0;
            T.edgesTo(O).length > 0 ? L = T.edgesTo(O)[0] : L = O.edgesTo(T)[0];
            var M = a(L);
            O = O.id(), w[O] > w[R] + M && (w[O] = w[R] + M, C.nodes.indexOf(O) < 0 ? C.push(O) : C.updateItem(O), S[O] = 0, E[O] = []), w[O] == w[R] + M && (S[O] = S[O] + S[R], E[O].push(R));
          }
        else
          for (var A = 0; A < l[R].length; A++) {
            var I = l[R][A].id();
            w[I] == 1 / 0 && (C.push(I), w[I] = w[R] + 1), w[I] == w[R] + 1 && (S[I] = S[I] + S[R], E[I].push(R));
          }
      }
      for (var D = {}, F = 0; F < o.length; F++)
        D[o[F].id()] = 0;
      for (; x.length > 0; ) {
        for (var B = x.pop(), G = 0; G < E[B].length; G++) {
          var H = E[B][G];
          D[H] = D[H] + S[H] / S[B] * (1 + D[B]);
        }
        B != o[v].id() && f.set(B, f.get(B) + D[B]);
      }
    }, v = 0; v < o.length; v++)
      g();
    var m = {
      betweenness: function(y) {
        var x = s.collection(y).id();
        return f.get(x);
      },
      betweennessNormalized: function(y) {
        if (c == 0)
          return 0;
        var x = s.collection(y).id();
        return f.get(x) / c;
      }
    };
    return m.betweennessNormalised = m.betweennessNormalized, m;
  }
  // betweennessCentrality
};
x4.bc = x4.betweennessCentrality;
var REe = Hn({
  expandFactor: 2,
  // affects time of computation and cluster granularity to some extent: M * M
  inflateFactor: 2,
  // affects cluster granularity (the greater the value, the more clusters): M(i,j) / E(j)
  multFactor: 1,
  // optional self loops for each node. Use a neutral value to improve cluster computations.
  maxIterations: 20,
  // maximum number of iterations of the MCL algorithm in a single run
  attributes: [
    // attributes/features used to group nodes, ie. similarity values between nodes
    function(t) {
      return 1;
    }
  ]
}), MEe = function(e) {
  return REe(e);
}, _Ee = function(e, r) {
  for (var n = 0, a = 0; a < r.length; a++)
    n += r[a](e);
  return n;
}, LEe = function(e, r, n) {
  for (var a = 0; a < r; a++)
    e[a * r + a] = n;
}, YB = function(e, r) {
  for (var n, a = 0; a < r; a++) {
    n = 0;
    for (var i = 0; i < r; i++)
      n += e[i * r + a];
    for (var s = 0; s < r; s++)
      e[s * r + a] = e[s * r + a] / n;
  }
}, NEe = function(e, r, n) {
  for (var a = new Array(n * n), i = 0; i < n; i++) {
    for (var s = 0; s < n; s++)
      a[i * n + s] = 0;
    for (var o = 0; o < n; o++)
      for (var l = 0; l < n; l++)
        a[i * n + l] += e[i * n + o] * r[o * n + l];
  }
  return a;
}, OEe = function(e, r, n) {
  for (var a = e.slice(0), i = 1; i < n; i++)
    e = NEe(e, a, r);
  return e;
}, IEe = function(e, r, n) {
  for (var a = new Array(r * r), i = 0; i < r * r; i++)
    a[i] = Math.pow(e[i], n);
  return YB(a, r), a;
}, PEe = function(e, r, n, a) {
  for (var i = 0; i < n; i++) {
    var s = Math.round(e[i] * Math.pow(10, a)) / Math.pow(10, a), o = Math.round(r[i] * Math.pow(10, a)) / Math.pow(10, a);
    if (s !== o)
      return !1;
  }
  return !0;
}, DEe = function(e, r, n, a) {
  for (var i = [], s = 0; s < r; s++) {
    for (var o = [], l = 0; l < r; l++)
      Math.round(e[s * r + l] * 1e3) / 1e3 > 0 && o.push(n[l]);
    o.length !== 0 && i.push(a.collection(o));
  }
  return i;
}, $Ee = function(e, r) {
  for (var n = 0; n < e.length; n++)
    if (!r[n] || e[n].id() !== r[n].id())
      return !1;
  return !0;
}, FEe = function(e) {
  for (var r = 0; r < e.length; r++)
    for (var n = 0; n < e.length; n++)
      r != n && $Ee(e[r], e[n]) && e.splice(n, 1);
  return e;
}, MM = function(e) {
  for (var r = this.nodes(), n = this.edges(), a = this.cy(), i = MEe(e), s = {}, o = 0; o < r.length; o++)
    s[r[o].id()] = o;
  for (var l = r.length, u = l * l, c = new Array(u), f, h = 0; h < u; h++)
    c[h] = 0;
  for (var d = 0; d < n.length; d++) {
    var p = n[d], g = s[p.source().id()], v = s[p.target().id()], m = _Ee(p, i.attributes);
    c[g * l + v] += m, c[v * l + g] += m;
  }
  LEe(c, l, i.multFactor), YB(c, l);
  for (var b = !0, y = 0; b && y < i.maxIterations; )
    b = !1, f = OEe(c, l, i.expandFactor), c = IEe(f, l, i.inflateFactor), PEe(c, f, u, 4) || (b = !0), y++;
  var x = DEe(c, l, r, a);
  return x = FEe(x), x;
}, BEe = {
  markovClustering: MM,
  mcl: MM
}, zEe = function(e) {
  return e;
}, XB = function(e, r) {
  return Math.abs(r - e);
}, _M = function(e, r, n) {
  return e + XB(r, n);
}, LM = function(e, r, n) {
  return e + Math.pow(n - r, 2);
}, GEe = function(e) {
  return Math.sqrt(e);
}, UEe = function(e, r, n) {
  return Math.max(e, XB(r, n));
}, ch = function(e, r, n, a, i) {
  for (var s = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : zEe, o = a, l, u, c = 0; c < e; c++)
    l = r(c), u = n(c), o = i(o, l, u);
  return s(o);
}, ff = {
  euclidean: function(e, r, n) {
    return e >= 2 ? ch(e, r, n, 0, LM, GEe) : ch(e, r, n, 0, _M);
  },
  squaredEuclidean: function(e, r, n) {
    return ch(e, r, n, 0, LM);
  },
  manhattan: function(e, r, n) {
    return ch(e, r, n, 0, _M);
  },
  max: function(e, r, n) {
    return ch(e, r, n, -1 / 0, UEe);
  }
};
ff["squared-euclidean"] = ff.squaredEuclidean;
ff.squaredeuclidean = ff.squaredEuclidean;
function J1(t, e, r, n, a, i) {
  var s;
  return Wr(t) ? s = t : s = ff[t] || ff.euclidean, e === 0 && Wr(t) ? s(a, i) : s(e, r, n, a, i);
}
var HEe = Hn({
  k: 2,
  m: 2,
  sensitivityThreshold: 1e-4,
  distance: "euclidean",
  maxIterations: 10,
  attributes: [],
  testMode: !1,
  testCentroids: null
}), h3 = function(e) {
  return HEe(e);
}, Gm = function(e, r, n, a, i) {
  var s = i !== "kMedoids", o = s ? function(f) {
    return n[f];
  } : function(f) {
    return a[f](n);
  }, l = function(h) {
    return a[h](r);
  }, u = n, c = r;
  return J1(e, a.length, o, l, u, c);
}, w2 = function(e, r, n) {
  for (var a = n.length, i = new Array(a), s = new Array(a), o = new Array(r), l = null, u = 0; u < a; u++)
    i[u] = e.min(n[u]).value, s[u] = e.max(n[u]).value;
  for (var c = 0; c < r; c++) {
    l = [];
    for (var f = 0; f < a; f++)
      l[f] = Math.random() * (s[f] - i[f]) + i[f];
    o[c] = l;
  }
  return o;
}, KB = function(e, r, n, a, i) {
  for (var s = 1 / 0, o = 0, l = 0; l < r.length; l++) {
    var u = Gm(n, e, r[l], a, i);
    u < s && (s = u, o = l);
  }
  return o;
}, ZB = function(e, r, n) {
  for (var a = [], i = null, s = 0; s < r.length; s++)
    i = r[s], n[i.id()] === e && a.push(i);
  return a;
}, VEe = function(e, r, n) {
  return Math.abs(r - e) <= n;
}, qEe = function(e, r, n) {
  for (var a = 0; a < e.length; a++)
    for (var i = 0; i < e[a].length; i++) {
      var s = Math.abs(e[a][i] - r[a][i]);
      if (s > n)
        return !1;
    }
  return !0;
}, WEe = function(e, r, n) {
  for (var a = 0; a < n; a++)
    if (e === r[a]) return !0;
  return !1;
}, NM = function(e, r) {
  var n = new Array(r);
  if (e.length < 50)
    for (var a = 0; a < r; a++) {
      for (var i = e[Math.floor(Math.random() * e.length)]; WEe(i, n, a); )
        i = e[Math.floor(Math.random() * e.length)];
      n[a] = i;
    }
  else
    for (var s = 0; s < r; s++)
      n[s] = e[Math.floor(Math.random() * e.length)];
  return n;
}, OM = function(e, r, n) {
  for (var a = 0, i = 0; i < r.length; i++)
    a += Gm("manhattan", r[i], e, n, "kMedoids");
  return a;
}, jEe = function(e) {
  var r = this.cy(), n = this.nodes(), a = null, i = h3(e), s = new Array(i.k), o = {}, l;
  i.testMode ? typeof i.testCentroids == "number" ? (i.testCentroids, l = w2(n, i.k, i.attributes)) : xn(i.testCentroids) === "object" ? l = i.testCentroids : l = w2(n, i.k, i.attributes) : l = w2(n, i.k, i.attributes);
  for (var u = !0, c = 0; u && c < i.maxIterations; ) {
    for (var f = 0; f < n.length; f++)
      a = n[f], o[a.id()] = KB(a, l, i.distance, i.attributes, "kMeans");
    u = !1;
    for (var h = 0; h < i.k; h++) {
      var d = ZB(h, n, o);
      if (d.length !== 0) {
        for (var p = i.attributes.length, g = l[h], v = new Array(p), m = new Array(p), b = 0; b < p; b++) {
          m[b] = 0;
          for (var y = 0; y < d.length; y++)
            a = d[y], m[b] += i.attributes[b](a);
          v[b] = m[b] / d.length, VEe(v[b], g[b], i.sensitivityThreshold) || (u = !0);
        }
        l[h] = v, s[h] = r.collection(d);
      }
    }
    c++;
  }
  return s;
}, YEe = function(e) {
  var r = this.cy(), n = this.nodes(), a = null, i = h3(e), s = new Array(i.k), o, l = {}, u, c = new Array(i.k);
  i.testMode ? typeof i.testCentroids == "number" || (xn(i.testCentroids) === "object" ? o = i.testCentroids : o = NM(n, i.k)) : o = NM(n, i.k);
  for (var f = !0, h = 0; f && h < i.maxIterations; ) {
    for (var d = 0; d < n.length; d++)
      a = n[d], l[a.id()] = KB(a, o, i.distance, i.attributes, "kMedoids");
    f = !1;
    for (var p = 0; p < o.length; p++) {
      var g = ZB(p, n, l);
      if (g.length !== 0) {
        c[p] = OM(o[p], g, i.attributes);
        for (var v = 0; v < g.length; v++)
          u = OM(g[v], g, i.attributes), u < c[p] && (c[p] = u, o[p] = g[v], f = !0);
        s[p] = r.collection(g);
      }
    }
    h++;
  }
  return s;
}, XEe = function(e, r, n, a, i) {
  for (var s, o, l = 0; l < r.length; l++)
    for (var u = 0; u < e.length; u++)
      a[l][u] = Math.pow(n[l][u], i.m);
  for (var c = 0; c < e.length; c++)
    for (var f = 0; f < i.attributes.length; f++) {
      s = 0, o = 0;
      for (var h = 0; h < r.length; h++)
        s += a[h][c] * i.attributes[f](r[h]), o += a[h][c];
      e[c][f] = s / o;
    }
}, KEe = function(e, r, n, a, i) {
  for (var s = 0; s < e.length; s++)
    r[s] = e[s].slice();
  for (var o, l, u, c = 2 / (i.m - 1), f = 0; f < n.length; f++)
    for (var h = 0; h < a.length; h++) {
      o = 0;
      for (var d = 0; d < n.length; d++)
        l = Gm(i.distance, a[h], n[f], i.attributes, "cmeans"), u = Gm(i.distance, a[h], n[d], i.attributes, "cmeans"), o += Math.pow(l / u, c);
      e[h][f] = 1 / o;
    }
}, ZEe = function(e, r, n, a) {
  for (var i = new Array(n.k), s = 0; s < i.length; s++)
    i[s] = [];
  for (var o, l, u = 0; u < r.length; u++) {
    o = -1 / 0, l = -1;
    for (var c = 0; c < r[0].length; c++)
      r[u][c] > o && (o = r[u][c], l = c);
    i[l].push(e[u]);
  }
  for (var f = 0; f < i.length; f++)
    i[f] = a.collection(i[f]);
  return i;
}, IM = function(e) {
  var r = this.cy(), n = this.nodes(), a = h3(e), i, s, o, l, u;
  l = new Array(n.length);
  for (var c = 0; c < n.length; c++)
    l[c] = new Array(a.k);
  o = new Array(n.length);
  for (var f = 0; f < n.length; f++)
    o[f] = new Array(a.k);
  for (var h = 0; h < n.length; h++) {
    for (var d = 0, p = 0; p < a.k; p++)
      o[h][p] = Math.random(), d += o[h][p];
    for (var g = 0; g < a.k; g++)
      o[h][g] = o[h][g] / d;
  }
  s = new Array(a.k);
  for (var v = 0; v < a.k; v++)
    s[v] = new Array(a.attributes.length);
  u = new Array(n.length);
  for (var m = 0; m < n.length; m++)
    u[m] = new Array(a.k);
  for (var b = !0, y = 0; b && y < a.maxIterations; )
    b = !1, XEe(s, n, o, u, a), KEe(o, l, s, n, a), qEe(o, l, a.sensitivityThreshold) || (b = !0), y++;
  return i = ZEe(n, o, a, r), {
    clusters: i,
    degreeOfMembership: o
  };
}, QEe = {
  kMeans: jEe,
  kMedoids: YEe,
  fuzzyCMeans: IM,
  fcm: IM
}, JEe = Hn({
  distance: "euclidean",
  // distance metric to compare nodes
  linkage: "min",
  // linkage criterion : how to determine the distance between clusters of nodes
  mode: "threshold",
  // mode:'threshold' => clusters must be threshold distance apart
  threshold: 1 / 0,
  // the distance threshold
  // mode:'dendrogram' => the nodes are organised as leaves in a tree (siblings are close), merging makes clusters
  addDendrogram: !1,
  // whether to add the dendrogram to the graph for viz
  dendrogramDepth: 0,
  // depth at which dendrogram branches are merged into the returned clusters
  attributes: []
  // array of attr functions
}), eTe = {
  single: "min",
  complete: "max"
}, tTe = function(e) {
  var r = JEe(e), n = eTe[r.linkage];
  return n != null && (r.linkage = n), r;
}, PM = function(e, r, n, a, i) {
  for (var s = 0, o = 1 / 0, l, u = i.attributes, c = function(k, N) {
    return J1(i.distance, u.length, function(R) {
      return u[R](k);
    }, function(R) {
      return u[R](N);
    }, k, N);
  }, f = 0; f < e.length; f++) {
    var h = e[f].key, d = n[h][a[h]];
    d < o && (s = h, o = d);
  }
  if (i.mode === "threshold" && o >= i.threshold || i.mode === "dendrogram" && e.length === 1)
    return !1;
  var p = r[s], g = r[a[s]], v;
  i.mode === "dendrogram" ? v = {
    left: p,
    right: g,
    key: p.key
  } : v = {
    value: p.value.concat(g.value),
    key: p.key
  }, e[p.index] = v, e.splice(g.index, 1), r[p.key] = v;
  for (var m = 0; m < e.length; m++) {
    var b = e[m];
    p.key === b.key ? l = 1 / 0 : i.linkage === "min" ? (l = n[p.key][b.key], n[p.key][b.key] > n[g.key][b.key] && (l = n[g.key][b.key])) : i.linkage === "max" ? (l = n[p.key][b.key], n[p.key][b.key] < n[g.key][b.key] && (l = n[g.key][b.key])) : i.linkage === "mean" ? l = (n[p.key][b.key] * p.size + n[g.key][b.key] * g.size) / (p.size + g.size) : i.mode === "dendrogram" ? l = c(b.value, p.value) : l = c(b.value[0], p.value[0]), n[p.key][b.key] = n[b.key][p.key] = l;
  }
  for (var y = 0; y < e.length; y++) {
    var x = e[y].key;
    if (a[x] === p.key || a[x] === g.key) {
      for (var E = x, S = 0; S < e.length; S++) {
        var w = e[S].key;
        n[x][w] < n[x][E] && (E = w);
      }
      a[x] = E;
    }
    e[y].index = y;
  }
  return p.key = g.key = p.index = g.index = null, !0;
}, cc = function(e, r, n) {
  e && (e.value ? r.push(e.value) : (e.left && cc(e.left, r), e.right && cc(e.right, r)));
}, w4 = function(e, r) {
  if (!e) return "";
  if (e.left && e.right) {
    var n = w4(e.left, r), a = w4(e.right, r), i = r.add({
      group: "nodes",
      data: {
        id: n + "," + a
      }
    });
    return r.add({
      group: "edges",
      data: {
        source: n,
        target: i.id()
      }
    }), r.add({
      group: "edges",
      data: {
        source: a,
        target: i.id()
      }
    }), i.id();
  } else if (e.value)
    return e.value.id();
}, E4 = function(e, r, n) {
  if (!e) return [];
  var a = [], i = [], s = [];
  return r === 0 ? (e.left && cc(e.left, a), e.right && cc(e.right, i), s = a.concat(i), [n.collection(s)]) : r === 1 ? e.value ? [n.collection(e.value)] : (e.left && cc(e.left, a), e.right && cc(e.right, i), [n.collection(a), n.collection(i)]) : e.value ? [n.collection(e.value)] : (e.left && (a = E4(e.left, r - 1, n)), e.right && (i = E4(e.right, r - 1, n)), a.concat(i));
}, DM = function(e) {
  for (var r = this.cy(), n = this.nodes(), a = tTe(e), i = a.attributes, s = function(y, x) {
    return J1(a.distance, i.length, function(E) {
      return i[E](y);
    }, function(E) {
      return i[E](x);
    }, y, x);
  }, o = [], l = [], u = [], c = [], f = 0; f < n.length; f++) {
    var h = {
      value: a.mode === "dendrogram" ? n[f] : [n[f]],
      key: f,
      index: f
    };
    o[f] = h, c[f] = h, l[f] = [], u[f] = 0;
  }
  for (var d = 0; d < o.length; d++)
    for (var p = 0; p <= d; p++) {
      var g = void 0;
      a.mode === "dendrogram" ? g = d === p ? 1 / 0 : s(o[d].value, o[p].value) : g = d === p ? 1 / 0 : s(o[d].value[0], o[p].value[0]), l[d][p] = g, l[p][d] = g, g < l[d][u[d]] && (u[d] = p);
    }
  for (var v = PM(o, c, l, u, a); v; )
    v = PM(o, c, l, u, a);
  var m;
  return a.mode === "dendrogram" ? (m = E4(o[0], a.dendrogramDepth, r), a.addDendrogram && w4(o[0], r)) : (m = new Array(o.length), o.forEach(function(b, y) {
    b.key = b.index = null, m[y] = r.collection(b.value);
  })), m;
}, rTe = {
  hierarchicalClustering: DM,
  hca: DM
}, nTe = Hn({
  distance: "euclidean",
  // distance metric to compare attributes between two nodes
  preference: "median",
  // suitability of a data point to serve as an exemplar
  damping: 0.8,
  // damping factor between [0.5, 1)
  maxIterations: 1e3,
  // max number of iterations to run
  minIterations: 100,
  // min number of iterations to run in order for clustering to stop
  attributes: [
    // functions to quantify the similarity between any two points
    // e.g. node => node.data('weight')
  ]
}), aTe = function(e) {
  var r = e.damping, n = e.preference;
  0.5 <= r && r < 1 || Fr("Damping must range on [0.5, 1).  Got: ".concat(r));
  var a = ["median", "mean", "min", "max"];
  return a.some(function(i) {
    return i === n;
  }) || tt(n) || Fr("Preference must be one of [".concat(a.map(function(i) {
    return "'".concat(i, "'");
  }).join(", "), "] or a number.  Got: ").concat(n)), nTe(e);
}, iTe = function(e, r, n, a) {
  var i = function(o, l) {
    return a[l](o);
  };
  return -J1(e, a.length, function(s) {
    return i(r, s);
  }, function(s) {
    return i(n, s);
  }, r, n);
}, sTe = function(e, r) {
  var n = null;
  return r === "median" ? n = aEe(e) : r === "mean" ? n = nEe(e) : r === "min" ? n = tEe(e) : r === "max" ? n = rEe(e) : n = r, n;
}, oTe = function(e, r, n) {
  for (var a = [], i = 0; i < e; i++)
    r[i * e + i] + n[i * e + i] > 0 && a.push(i);
  return a;
}, $M = function(e, r, n) {
  for (var a = [], i = 0; i < e; i++) {
    for (var s = -1, o = -1 / 0, l = 0; l < n.length; l++) {
      var u = n[l];
      r[i * e + u] > o && (s = u, o = r[i * e + u]);
    }
    s > 0 && a.push(s);
  }
  for (var c = 0; c < n.length; c++)
    a[n[c]] = n[c];
  return a;
}, lTe = function(e, r, n) {
  for (var a = $M(e, r, n), i = 0; i < n.length; i++) {
    for (var s = [], o = 0; o < a.length; o++)
      a[o] === n[i] && s.push(o);
    for (var l = -1, u = -1 / 0, c = 0; c < s.length; c++) {
      for (var f = 0, h = 0; h < s.length; h++)
        f += r[s[h] * e + s[c]];
      f > u && (l = c, u = f);
    }
    n[i] = s[l];
  }
  return a = $M(e, r, n), a;
}, FM = function(e) {
  for (var r = this.cy(), n = this.nodes(), a = aTe(e), i = {}, s = 0; s < n.length; s++)
    i[n[s].id()] = s;
  var o, l, u, c, f, h;
  o = n.length, l = o * o, u = new Array(l);
  for (var d = 0; d < l; d++)
    u[d] = -1 / 0;
  for (var p = 0; p < o; p++)
    for (var g = 0; g < o; g++)
      p !== g && (u[p * o + g] = iTe(a.distance, n[p], n[g], a.attributes));
  c = sTe(u, a.preference);
  for (var v = 0; v < o; v++)
    u[v * o + v] = c;
  f = new Array(l);
  for (var m = 0; m < l; m++)
    f[m] = 0;
  h = new Array(l);
  for (var b = 0; b < l; b++)
    h[b] = 0;
  for (var y = new Array(o), x = new Array(o), E = new Array(o), S = 0; S < o; S++)
    y[S] = 0, x[S] = 0, E[S] = 0;
  for (var w = new Array(o * a.minIterations), C = 0; C < w.length; C++)
    w[C] = 0;
  var k;
  for (k = 0; k < a.maxIterations; k++) {
    for (var N = 0; N < o; N++) {
      for (var R = -1 / 0, _ = -1 / 0, O = -1, T = 0, L = 0; L < o; L++)
        y[L] = f[N * o + L], T = h[N * o + L] + u[N * o + L], T >= R ? (_ = R, R = T, O = L) : T > _ && (_ = T);
      for (var M = 0; M < o; M++)
        f[N * o + M] = (1 - a.damping) * (u[N * o + M] - R) + a.damping * y[M];
      f[N * o + O] = (1 - a.damping) * (u[N * o + O] - _) + a.damping * y[O];
    }
    for (var A = 0; A < o; A++) {
      for (var I = 0, D = 0; D < o; D++)
        y[D] = h[D * o + A], x[D] = Math.max(0, f[D * o + A]), I += x[D];
      I -= x[A], x[A] = f[A * o + A], I += x[A];
      for (var F = 0; F < o; F++)
        h[F * o + A] = (1 - a.damping) * Math.min(0, I - x[F]) + a.damping * y[F];
      h[A * o + A] = (1 - a.damping) * (I - x[A]) + a.damping * y[A];
    }
    for (var B = 0, G = 0; G < o; G++) {
      var H = h[G * o + G] + f[G * o + G] > 0 ? 1 : 0;
      w[k % a.minIterations * o + G] = H, B += H;
    }
    if (B > 0 && (k >= a.minIterations - 1 || k == a.maxIterations - 1)) {
      for (var K = 0, j = 0; j < o; j++) {
        E[j] = 0;
        for (var Z = 0; Z < a.minIterations; Z++)
          E[j] += w[Z * o + j];
        (E[j] === 0 || E[j] === a.minIterations) && K++;
      }
      if (K === o)
        break;
    }
  }
  for (var te = oTe(o, f, h), ne = lTe(o, u, te), V = {}, q = 0; q < te.length; q++)
    V[te[q]] = [];
  for (var X = 0; X < n.length; X++) {
    var W = i[n[X].id()], ue = ne[W];
    ue != null && V[ue].push(n[X]);
  }
  for (var J = new Array(te.length), Ce = 0; Ce < te.length; Ce++)
    J[Ce] = r.collection(V[te[Ce]]);
  return J;
}, uTe = {
  affinityPropagation: FM,
  ap: FM
}, cTe = Hn({
  root: void 0,
  directed: !1
}), fTe = {
  hierholzer: function(e) {
    if (!Qt(e)) {
      var r = arguments;
      e = {
        root: r[0],
        directed: r[1]
      };
    }
    var n = cTe(e), a = n.root, i = n.directed, s = this, o = !1, l, u, c;
    a && (c = xt(a) ? this.filter(a)[0].id() : a[0].id());
    var f = {}, h = {};
    i ? s.forEach(function(b) {
      var y = b.id();
      if (b.isNode()) {
        var x = b.indegree(!0), E = b.outdegree(!0), S = x - E, w = E - x;
        S == 1 ? l ? o = !0 : l = y : w == 1 ? u ? o = !0 : u = y : (w > 1 || S > 1) && (o = !0), f[y] = [], b.outgoers().forEach(function(C) {
          C.isEdge() && f[y].push(C.id());
        });
      } else
        h[y] = [void 0, b.target().id()];
    }) : s.forEach(function(b) {
      var y = b.id();
      if (b.isNode()) {
        var x = b.degree(!0);
        x % 2 && (l ? u ? o = !0 : u = y : l = y), f[y] = [], b.connectedEdges().forEach(function(E) {
          return f[y].push(E.id());
        });
      } else
        h[y] = [b.source().id(), b.target().id()];
    });
    var d = {
      found: !1,
      trail: void 0
    };
    if (o) return d;
    if (u && l)
      if (i) {
        if (c && u != c)
          return d;
        c = u;
      } else {
        if (c && u != c && l != c)
          return d;
        c || (c = u);
      }
    else
      c || (c = s[0].id());
    var p = function(y) {
      for (var x = y, E = [y], S, w, C; f[x].length; )
        S = f[x].shift(), w = h[S][0], C = h[S][1], x != C ? (f[C] = f[C].filter(function(k) {
          return k != S;
        }), x = C) : !i && x != w && (f[w] = f[w].filter(function(k) {
          return k != S;
        }), x = w), E.unshift(S), E.unshift(x);
      return E;
    }, g = [], v = [];
    for (v = p(c); v.length != 1; )
      f[v[0]].length == 0 ? (g.unshift(s.getElementById(v.shift())), g.unshift(s.getElementById(v.shift()))) : v = p(v.shift()).concat(v);
    g.unshift(s.getElementById(v.shift()));
    for (var m in f)
      if (f[m].length)
        return d;
    return d.found = !0, d.trail = this.spawn(g, !0), d;
  }
}, hg = function() {
  var e = this, r = {}, n = 0, a = 0, i = [], s = [], o = {}, l = function(h, d) {
    for (var p = s.length - 1, g = [], v = e.spawn(); s[p].x != h || s[p].y != d; )
      g.push(s.pop().edge), p--;
    g.push(s.pop().edge), g.forEach(function(m) {
      var b = m.connectedNodes().intersection(e);
      v.merge(m), b.forEach(function(y) {
        var x = y.id(), E = y.connectedEdges().intersection(e);
        v.merge(y), r[x].cutVertex ? v.merge(E.filter(function(S) {
          return S.isLoop();
        })) : v.merge(E);
      });
    }), i.push(v);
  }, u = function(h, d, p) {
    h === p && (a += 1), r[d] = {
      id: n,
      low: n++,
      cutVertex: !1
    };
    var g = e.getElementById(d).connectedEdges().intersection(e);
    if (g.size() === 0)
      i.push(e.spawn(e.getElementById(d)));
    else {
      var v, m, b, y;
      g.forEach(function(x) {
        v = x.source().id(), m = x.target().id(), b = v === d ? m : v, b !== p && (y = x.id(), o[y] || (o[y] = !0, s.push({
          x: d,
          y: b,
          edge: x
        })), b in r ? r[d].low = Math.min(r[d].low, r[b].id) : (u(h, b, d), r[d].low = Math.min(r[d].low, r[b].low), r[d].id <= r[b].low && (r[d].cutVertex = !0, l(d, b))));
      });
    }
  };
  e.forEach(function(f) {
    if (f.isNode()) {
      var h = f.id();
      h in r || (a = 0, u(h, h), r[h].cutVertex = a > 1);
    }
  });
  var c = Object.keys(r).filter(function(f) {
    return r[f].cutVertex;
  }).map(function(f) {
    return e.getElementById(f);
  });
  return {
    cut: e.spawn(c),
    components: i
  };
}, hTe = {
  hopcroftTarjanBiconnected: hg,
  htbc: hg,
  htb: hg,
  hopcroftTarjanBiconnectedComponents: hg
}, dg = function() {
  var e = this, r = {}, n = 0, a = [], i = [], s = e.spawn(e), o = function(u) {
    i.push(u), r[u] = {
      index: n,
      low: n++,
      explored: !1
    };
    var c = e.getElementById(u).connectedEdges().intersection(e);
    if (c.forEach(function(g) {
      var v = g.target().id();
      v !== u && (v in r || o(v), r[v].explored || (r[u].low = Math.min(r[u].low, r[v].low)));
    }), r[u].index === r[u].low) {
      for (var f = e.spawn(); ; ) {
        var h = i.pop();
        if (f.merge(e.getElementById(h)), r[h].low = r[u].index, r[h].explored = !0, h === u)
          break;
      }
      var d = f.edgesWith(f), p = f.merge(d);
      a.push(p), s = s.difference(p);
    }
  };
  return e.forEach(function(l) {
    if (l.isNode()) {
      var u = l.id();
      u in r || o(u);
    }
  }), {
    cut: s,
    components: a
  };
}, dTe = {
  tarjanStronglyConnected: dg,
  tsc: dg,
  tscc: dg,
  tarjanStronglyConnectedComponents: dg
}, QB = {};
[l0, Hwe, Vwe, Wwe, Ywe, Kwe, Jwe, AEe, Ec, Tc, x4, BEe, QEe, rTe, uTe, fTe, hTe, dTe].forEach(function(t) {
  At(QB, t);
});
/*!
Embeddable Minimum Strictly-Compliant Promises/A+ 1.1.1 Thenable
Copyright (c) 2013-2014 Ralf S. Engelschall (http://engelschall.com)
Licensed under The MIT License (http://opensource.org/licenses/MIT)
*/
var JB = 0, ez = 1, tz = 2, Xi = function(e) {
  if (!(this instanceof Xi)) return new Xi(e);
  this.id = "Thenable/1.0.7", this.state = JB, this.fulfillValue = void 0, this.rejectReason = void 0, this.onFulfilled = [], this.onRejected = [], this.proxy = {
    then: this.then.bind(this)
  }, typeof e == "function" && e.call(this, this.fulfill.bind(this), this.reject.bind(this));
};
Xi.prototype = {
  /*  promise resolving methods  */
  fulfill: function(e) {
    return BM(this, ez, "fulfillValue", e);
  },
  reject: function(e) {
    return BM(this, tz, "rejectReason", e);
  },
  /*  "The then Method" [Promises/A+ 1.1, 1.2, 2.2]  */
  then: function(e, r) {
    var n = this, a = new Xi();
    return n.onFulfilled.push(GM(e, a, "fulfill")), n.onRejected.push(GM(r, a, "reject")), rz(n), a.proxy;
  }
};
var BM = function(e, r, n, a) {
  return e.state === JB && (e.state = r, e[n] = a, rz(e)), e;
}, rz = function(e) {
  e.state === ez ? zM(e, "onFulfilled", e.fulfillValue) : e.state === tz && zM(e, "onRejected", e.rejectReason);
}, zM = function(e, r, n) {
  if (e[r].length !== 0) {
    var a = e[r];
    e[r] = [];
    var i = function() {
      for (var o = 0; o < a.length; o++) a[o](n);
    };
    typeof setImmediate == "function" ? setImmediate(i) : setTimeout(i, 0);
  }
}, GM = function(e, r, n) {
  return function(a) {
    if (typeof e != "function")
      r[n].call(r, a);
    else {
      var i;
      try {
        i = e(a);
      } catch (s) {
        r.reject(s);
        return;
      }
      nz(r, i);
    }
  };
}, nz = function(e, r) {
  if (e === r || e.proxy === r) {
    e.reject(new TypeError("cannot resolve promise with itself"));
    return;
  }
  var n;
  if (xn(r) === "object" && r !== null || typeof r == "function")
    try {
      n = r.then;
    } catch (i) {
      e.reject(i);
      return;
    }
  if (typeof n == "function") {
    var a = !1;
    try {
      n.call(
        r,
        /*  resolvePromise  */
        /*  [Promises/A+ 2.3.3.3.1]  */
        function(i) {
          a || (a = !0, i === r ? e.reject(new TypeError("circular thenable chain")) : nz(e, i));
        },
        /*  rejectPromise  */
        /*  [Promises/A+ 2.3.3.3.2]  */
        function(i) {
          a || (a = !0, e.reject(i));
        }
      );
    } catch (i) {
      a || e.reject(i);
    }
    return;
  }
  e.fulfill(r);
};
Xi.all = function(t) {
  return new Xi(function(e, r) {
    for (var n = new Array(t.length), a = 0, i = function(l, u) {
      n[l] = u, a++, a === t.length && e(n);
    }, s = 0; s < t.length; s++)
      (function(o) {
        var l = t[o], u = l != null && l.then != null;
        if (u)
          l.then(function(f) {
            i(o, f);
          }, function(f) {
            r(f);
          });
        else {
          var c = l;
          i(o, c);
        }
      })(s);
  });
};
Xi.resolve = function(t) {
  return new Xi(function(e, r) {
    e(t);
  });
};
Xi.reject = function(t) {
  return new Xi(function(e, r) {
    r(t);
  });
};
var _f = typeof Promise < "u" ? Promise : Xi, T4 = function(e, r, n) {
  var a = r3(e), i = !a, s = this._private = At({
    duration: 1e3
  }, r, n);
  if (s.target = e, s.style = s.style || s.css, s.started = !1, s.playing = !1, s.hooked = !1, s.applying = !1, s.progress = 0, s.completes = [], s.frames = [], s.complete && Wr(s.complete) && s.completes.push(s.complete), i) {
    var o = e.position();
    s.startPosition = s.startPosition || {
      x: o.x,
      y: o.y
    }, s.startStyle = s.startStyle || e.cy().style().getAnimationStartStyle(e, s.style);
  }
  if (a) {
    var l = e.pan();
    s.startPan = {
      x: l.x,
      y: l.y
    }, s.startZoom = e.zoom();
  }
  this.length = 1, this[0] = this;
}, ou = T4.prototype;
At(ou, {
  instanceString: function() {
    return "animation";
  },
  hook: function() {
    var e = this._private;
    if (!e.hooked) {
      var r, n = e.target._private.animation;
      e.queue ? r = n.queue : r = n.current, r.push(this), ri(e.target) && e.target.cy().addToAnimationPool(e.target), e.hooked = !0;
    }
    return this;
  },
  play: function() {
    var e = this._private;
    return e.progress === 1 && (e.progress = 0), e.playing = !0, e.started = !1, e.stopped = !1, this.hook(), this;
  },
  playing: function() {
    return this._private.playing;
  },
  apply: function() {
    var e = this._private;
    return e.applying = !0, e.started = !1, e.stopped = !1, this.hook(), this;
  },
  applying: function() {
    return this._private.applying;
  },
  pause: function() {
    var e = this._private;
    return e.playing = !1, e.started = !1, this;
  },
  stop: function() {
    var e = this._private;
    return e.playing = !1, e.started = !1, e.stopped = !0, this;
  },
  rewind: function() {
    return this.progress(0);
  },
  fastforward: function() {
    return this.progress(1);
  },
  time: function(e) {
    var r = this._private;
    return e === void 0 ? r.progress * r.duration : this.progress(e / r.duration);
  },
  progress: function(e) {
    var r = this._private, n = r.playing;
    return e === void 0 ? r.progress : (n && this.pause(), r.progress = e, r.started = !1, n && this.play(), this);
  },
  completed: function() {
    return this._private.progress === 1;
  },
  reverse: function() {
    var e = this._private, r = e.playing;
    r && this.pause(), e.progress = 1 - e.progress, e.started = !1;
    var n = function(u, c) {
      var f = e[u];
      f != null && (e[u] = e[c], e[c] = f);
    };
    if (n("zoom", "startZoom"), n("pan", "startPan"), n("position", "startPosition"), e.style)
      for (var a = 0; a < e.style.length; a++) {
        var i = e.style[a], s = i.name, o = e.startStyle[s];
        e.startStyle[s] = i, e.style[a] = o;
      }
    return r && this.play(), this;
  },
  promise: function(e) {
    var r = this._private, n;
    switch (e) {
      case "frame":
        n = r.frames;
        break;
      default:
      case "complete":
      case "completed":
        n = r.completes;
    }
    return new _f(function(a, i) {
      n.push(function() {
        a();
      });
    });
  }
});
ou.complete = ou.completed;
ou.run = ou.play;
ou.running = ou.playing;
var pTe = {
  animated: function() {
    return function() {
      var r = this, n = r.length !== void 0, a = n ? r : [r], i = this._private.cy || this;
      if (!i.styleEnabled())
        return !1;
      var s = a[0];
      if (s)
        return s._private.animation.current.length > 0;
    };
  },
  // animated
  clearQueue: function() {
    return function() {
      var r = this, n = r.length !== void 0, a = n ? r : [r], i = this._private.cy || this;
      if (!i.styleEnabled())
        return this;
      for (var s = 0; s < a.length; s++) {
        var o = a[s];
        o._private.animation.queue = [];
      }
      return this;
    };
  },
  // clearQueue
  delay: function() {
    return function(r, n) {
      var a = this._private.cy || this;
      return a.styleEnabled() ? this.animate({
        delay: r,
        duration: r,
        complete: n
      }) : this;
    };
  },
  // delay
  delayAnimation: function() {
    return function(r, n) {
      var a = this._private.cy || this;
      return a.styleEnabled() ? this.animation({
        delay: r,
        duration: r,
        complete: n
      }) : this;
    };
  },
  // delay
  animation: function() {
    return function(r, n) {
      var a = this, i = a.length !== void 0, s = i ? a : [a], o = this._private.cy || this, l = !i, u = !l;
      if (!o.styleEnabled())
        return this;
      var c = o.style();
      r = At({}, r, n);
      var f = Object.keys(r).length === 0;
      if (f)
        return new T4(s[0], r);
      switch (r.duration === void 0 && (r.duration = 400), r.duration) {
        case "slow":
          r.duration = 600;
          break;
        case "fast":
          r.duration = 200;
          break;
      }
      if (u && (r.style = c.getPropsList(r.style || r.css), r.css = void 0), u && r.renderedPosition != null) {
        var h = r.renderedPosition, d = o.pan(), p = o.zoom();
        r.position = UB(h, p, d);
      }
      if (l && r.panBy != null) {
        var g = r.panBy, v = o.pan();
        r.pan = {
          x: v.x + g.x,
          y: v.y + g.y
        };
      }
      var m = r.center || r.centre;
      if (l && m != null) {
        var b = o.getCenterPan(m.eles, r.zoom);
        b != null && (r.pan = b);
      }
      if (l && r.fit != null) {
        var y = r.fit, x = o.getFitViewport(y.eles || y.boundingBox, y.padding);
        x != null && (r.pan = x.pan, r.zoom = x.zoom);
      }
      if (l && Qt(r.zoom)) {
        var E = o.getZoomedViewport(r.zoom);
        E != null ? (E.zoomed && (r.zoom = E.zoom), E.panned && (r.pan = E.pan)) : r.zoom = null;
      }
      return new T4(s[0], r);
    };
  },
  // animate
  animate: function() {
    return function(r, n) {
      var a = this, i = a.length !== void 0, s = i ? a : [a], o = this._private.cy || this;
      if (!o.styleEnabled())
        return this;
      n && (r = At({}, r, n));
      for (var l = 0; l < s.length; l++) {
        var u = s[l], c = u.animated() && (r.queue === void 0 || r.queue), f = u.animation(r, c ? {
          queue: !0
        } : void 0);
        f.play();
      }
      return this;
    };
  },
  // animate
  stop: function() {
    return function(r, n) {
      var a = this, i = a.length !== void 0, s = i ? a : [a], o = this._private.cy || this;
      if (!o.styleEnabled())
        return this;
      for (var l = 0; l < s.length; l++) {
        for (var u = s[l], c = u._private, f = c.animation.current, h = 0; h < f.length; h++) {
          var d = f[h], p = d._private;
          n && (p.duration = 0);
        }
        r && (c.animation.queue = []), n || (c.animation.current = []);
      }
      return o.notify("draw"), this;
    };
  }
  // stop
}, E2, UM;
function eb() {
  if (UM) return E2;
  UM = 1;
  var t = Array.isArray;
  return E2 = t, E2;
}
var T2, HM;
function gTe() {
  if (HM) return T2;
  HM = 1;
  var t = eb(), e = fp(), r = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, n = /^\w*$/;
  function a(i, s) {
    if (t(i))
      return !1;
    var o = typeof i;
    return o == "number" || o == "symbol" || o == "boolean" || i == null || e(i) ? !0 : n.test(i) || !r.test(i) || s != null && i in Object(s);
  }
  return T2 = a, T2;
}
var S2, VM;
function vTe() {
  if (VM) return S2;
  VM = 1;
  var t = OB(), e = cp(), r = "[object AsyncFunction]", n = "[object Function]", a = "[object GeneratorFunction]", i = "[object Proxy]";
  function s(o) {
    if (!e(o))
      return !1;
    var l = t(o);
    return l == n || l == a || l == r || l == i;
  }
  return S2 = s, S2;
}
var C2, qM;
function mTe() {
  if (qM) return C2;
  qM = 1;
  var t = K1(), e = t["__core-js_shared__"];
  return C2 = e, C2;
}
var A2, WM;
function yTe() {
  if (WM) return A2;
  WM = 1;
  var t = mTe(), e = function() {
    var n = /[^.]+$/.exec(t && t.keys && t.keys.IE_PROTO || "");
    return n ? "Symbol(src)_1." + n : "";
  }();
  function r(n) {
    return !!e && e in n;
  }
  return A2 = r, A2;
}
var k2, jM;
function bTe() {
  if (jM) return k2;
  jM = 1;
  var t = Function.prototype, e = t.toString;
  function r(n) {
    if (n != null) {
      try {
        return e.call(n);
      } catch {
      }
      try {
        return n + "";
      } catch {
      }
    }
    return "";
  }
  return k2 = r, k2;
}
var R2, YM;
function xTe() {
  if (YM) return R2;
  YM = 1;
  var t = vTe(), e = yTe(), r = cp(), n = bTe(), a = /[\\^$.*+?()[\]{}|]/g, i = /^\[object .+?Constructor\]$/, s = Function.prototype, o = Object.prototype, l = s.toString, u = o.hasOwnProperty, c = RegExp(
    "^" + l.call(u).replace(a, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function f(h) {
    if (!r(h) || e(h))
      return !1;
    var d = t(h) ? c : i;
    return d.test(n(h));
  }
  return R2 = f, R2;
}
var M2, XM;
function wTe() {
  if (XM) return M2;
  XM = 1;
  function t(e, r) {
    return e == null ? void 0 : e[r];
  }
  return M2 = t, M2;
}
var _2, KM;
function d3() {
  if (KM) return _2;
  KM = 1;
  var t = xTe(), e = wTe();
  function r(n, a) {
    var i = e(n, a);
    return t(i) ? i : void 0;
  }
  return _2 = r, _2;
}
var L2, ZM;
function tb() {
  if (ZM) return L2;
  ZM = 1;
  var t = d3(), e = t(Object, "create");
  return L2 = e, L2;
}
var N2, QM;
function ETe() {
  if (QM) return N2;
  QM = 1;
  var t = tb();
  function e() {
    this.__data__ = t ? t(null) : {}, this.size = 0;
  }
  return N2 = e, N2;
}
var O2, JM;
function TTe() {
  if (JM) return O2;
  JM = 1;
  function t(e) {
    var r = this.has(e) && delete this.__data__[e];
    return this.size -= r ? 1 : 0, r;
  }
  return O2 = t, O2;
}
var I2, e_;
function STe() {
  if (e_) return I2;
  e_ = 1;
  var t = tb(), e = "__lodash_hash_undefined__", r = Object.prototype, n = r.hasOwnProperty;
  function a(i) {
    var s = this.__data__;
    if (t) {
      var o = s[i];
      return o === e ? void 0 : o;
    }
    return n.call(s, i) ? s[i] : void 0;
  }
  return I2 = a, I2;
}
var P2, t_;
function CTe() {
  if (t_) return P2;
  t_ = 1;
  var t = tb(), e = Object.prototype, r = e.hasOwnProperty;
  function n(a) {
    var i = this.__data__;
    return t ? i[a] !== void 0 : r.call(i, a);
  }
  return P2 = n, P2;
}
var D2, r_;
function ATe() {
  if (r_) return D2;
  r_ = 1;
  var t = tb(), e = "__lodash_hash_undefined__";
  function r(n, a) {
    var i = this.__data__;
    return this.size += this.has(n) ? 0 : 1, i[n] = t && a === void 0 ? e : a, this;
  }
  return D2 = r, D2;
}
var $2, n_;
function kTe() {
  if (n_) return $2;
  n_ = 1;
  var t = ETe(), e = TTe(), r = STe(), n = CTe(), a = ATe();
  function i(s) {
    var o = -1, l = s == null ? 0 : s.length;
    for (this.clear(); ++o < l; ) {
      var u = s[o];
      this.set(u[0], u[1]);
    }
  }
  return i.prototype.clear = t, i.prototype.delete = e, i.prototype.get = r, i.prototype.has = n, i.prototype.set = a, $2 = i, $2;
}
var F2, a_;
function RTe() {
  if (a_) return F2;
  a_ = 1;
  function t() {
    this.__data__ = [], this.size = 0;
  }
  return F2 = t, F2;
}
var B2, i_;
function az() {
  if (i_) return B2;
  i_ = 1;
  function t(e, r) {
    return e === r || e !== e && r !== r;
  }
  return B2 = t, B2;
}
var z2, s_;
function rb() {
  if (s_) return z2;
  s_ = 1;
  var t = az();
  function e(r, n) {
    for (var a = r.length; a--; )
      if (t(r[a][0], n))
        return a;
    return -1;
  }
  return z2 = e, z2;
}
var G2, o_;
function MTe() {
  if (o_) return G2;
  o_ = 1;
  var t = rb(), e = Array.prototype, r = e.splice;
  function n(a) {
    var i = this.__data__, s = t(i, a);
    if (s < 0)
      return !1;
    var o = i.length - 1;
    return s == o ? i.pop() : r.call(i, s, 1), --this.size, !0;
  }
  return G2 = n, G2;
}
var U2, l_;
function _Te() {
  if (l_) return U2;
  l_ = 1;
  var t = rb();
  function e(r) {
    var n = this.__data__, a = t(n, r);
    return a < 0 ? void 0 : n[a][1];
  }
  return U2 = e, U2;
}
var H2, u_;
function LTe() {
  if (u_) return H2;
  u_ = 1;
  var t = rb();
  function e(r) {
    return t(this.__data__, r) > -1;
  }
  return H2 = e, H2;
}
var V2, c_;
function NTe() {
  if (c_) return V2;
  c_ = 1;
  var t = rb();
  function e(r, n) {
    var a = this.__data__, i = t(a, r);
    return i < 0 ? (++this.size, a.push([r, n])) : a[i][1] = n, this;
  }
  return V2 = e, V2;
}
var q2, f_;
function OTe() {
  if (f_) return q2;
  f_ = 1;
  var t = RTe(), e = MTe(), r = _Te(), n = LTe(), a = NTe();
  function i(s) {
    var o = -1, l = s == null ? 0 : s.length;
    for (this.clear(); ++o < l; ) {
      var u = s[o];
      this.set(u[0], u[1]);
    }
  }
  return i.prototype.clear = t, i.prototype.delete = e, i.prototype.get = r, i.prototype.has = n, i.prototype.set = a, q2 = i, q2;
}
var W2, h_;
function ITe() {
  if (h_) return W2;
  h_ = 1;
  var t = d3(), e = K1(), r = t(e, "Map");
  return W2 = r, W2;
}
var j2, d_;
function PTe() {
  if (d_) return j2;
  d_ = 1;
  var t = kTe(), e = OTe(), r = ITe();
  function n() {
    this.size = 0, this.__data__ = {
      hash: new t(),
      map: new (r || e)(),
      string: new t()
    };
  }
  return j2 = n, j2;
}
var Y2, p_;
function DTe() {
  if (p_) return Y2;
  p_ = 1;
  function t(e) {
    var r = typeof e;
    return r == "string" || r == "number" || r == "symbol" || r == "boolean" ? e !== "__proto__" : e === null;
  }
  return Y2 = t, Y2;
}
var X2, g_;
function nb() {
  if (g_) return X2;
  g_ = 1;
  var t = DTe();
  function e(r, n) {
    var a = r.__data__;
    return t(n) ? a[typeof n == "string" ? "string" : "hash"] : a.map;
  }
  return X2 = e, X2;
}
var K2, v_;
function $Te() {
  if (v_) return K2;
  v_ = 1;
  var t = nb();
  function e(r) {
    var n = t(this, r).delete(r);
    return this.size -= n ? 1 : 0, n;
  }
  return K2 = e, K2;
}
var Z2, m_;
function FTe() {
  if (m_) return Z2;
  m_ = 1;
  var t = nb();
  function e(r) {
    return t(this, r).get(r);
  }
  return Z2 = e, Z2;
}
var Q2, y_;
function BTe() {
  if (y_) return Q2;
  y_ = 1;
  var t = nb();
  function e(r) {
    return t(this, r).has(r);
  }
  return Q2 = e, Q2;
}
var J2, b_;
function zTe() {
  if (b_) return J2;
  b_ = 1;
  var t = nb();
  function e(r, n) {
    var a = t(this, r), i = a.size;
    return a.set(r, n), this.size += a.size == i ? 0 : 1, this;
  }
  return J2 = e, J2;
}
var ew, x_;
function GTe() {
  if (x_) return ew;
  x_ = 1;
  var t = PTe(), e = $Te(), r = FTe(), n = BTe(), a = zTe();
  function i(s) {
    var o = -1, l = s == null ? 0 : s.length;
    for (this.clear(); ++o < l; ) {
      var u = s[o];
      this.set(u[0], u[1]);
    }
  }
  return i.prototype.clear = t, i.prototype.delete = e, i.prototype.get = r, i.prototype.has = n, i.prototype.set = a, ew = i, ew;
}
var tw, w_;
function UTe() {
  if (w_) return tw;
  w_ = 1;
  var t = GTe(), e = "Expected a function";
  function r(n, a) {
    if (typeof n != "function" || a != null && typeof a != "function")
      throw new TypeError(e);
    var i = function() {
      var s = arguments, o = a ? a.apply(this, s) : s[0], l = i.cache;
      if (l.has(o))
        return l.get(o);
      var u = n.apply(this, s);
      return i.cache = l.set(o, u) || l, u;
    };
    return i.cache = new (r.Cache || t)(), i;
  }
  return r.Cache = t, tw = r, tw;
}
var rw, E_;
function HTe() {
  if (E_) return rw;
  E_ = 1;
  var t = UTe(), e = 500;
  function r(n) {
    var a = t(n, function(s) {
      return i.size === e && i.clear(), s;
    }), i = a.cache;
    return a;
  }
  return rw = r, rw;
}
var nw, T_;
function iz() {
  if (T_) return nw;
  T_ = 1;
  var t = HTe(), e = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, r = /\\(\\)?/g, n = t(function(a) {
    var i = [];
    return a.charCodeAt(0) === 46 && i.push(""), a.replace(e, function(s, o, l, u) {
      i.push(l ? u.replace(r, "$1") : o || s);
    }), i;
  });
  return nw = n, nw;
}
var aw, S_;
function sz() {
  if (S_) return aw;
  S_ = 1;
  function t(e, r) {
    for (var n = -1, a = e == null ? 0 : e.length, i = Array(a); ++n < a; )
      i[n] = r(e[n], n, e);
    return i;
  }
  return aw = t, aw;
}
var iw, C_;
function VTe() {
  if (C_) return iw;
  C_ = 1;
  var t = a3(), e = sz(), r = eb(), n = fp(), a = t ? t.prototype : void 0, i = a ? a.toString : void 0;
  function s(o) {
    if (typeof o == "string")
      return o;
    if (r(o))
      return e(o, s) + "";
    if (n(o))
      return i ? i.call(o) : "";
    var l = o + "";
    return l == "0" && 1 / o == -1 / 0 ? "-0" : l;
  }
  return iw = s, iw;
}
var sw, A_;
function oz() {
  if (A_) return sw;
  A_ = 1;
  var t = VTe();
  function e(r) {
    return r == null ? "" : t(r);
  }
  return sw = e, sw;
}
var ow, k_;
function lz() {
  if (k_) return ow;
  k_ = 1;
  var t = eb(), e = gTe(), r = iz(), n = oz();
  function a(i, s) {
    return t(i) ? i : e(i, s) ? [i] : r(n(i));
  }
  return ow = a, ow;
}
var lw, R_;
function p3() {
  if (R_) return lw;
  R_ = 1;
  var t = fp();
  function e(r) {
    if (typeof r == "string" || t(r))
      return r;
    var n = r + "";
    return n == "0" && 1 / r == -1 / 0 ? "-0" : n;
  }
  return lw = e, lw;
}
var uw, M_;
function qTe() {
  if (M_) return uw;
  M_ = 1;
  var t = lz(), e = p3();
  function r(n, a) {
    a = t(a, n);
    for (var i = 0, s = a.length; n != null && i < s; )
      n = n[e(a[i++])];
    return i && i == s ? n : void 0;
  }
  return uw = r, uw;
}
var cw, __;
function WTe() {
  if (__) return cw;
  __ = 1;
  var t = qTe();
  function e(r, n, a) {
    var i = r == null ? void 0 : t(r, n);
    return i === void 0 ? a : i;
  }
  return cw = e, cw;
}
var jTe = WTe(), YTe = /* @__PURE__ */ up(jTe), fw, L_;
function XTe() {
  if (L_) return fw;
  L_ = 1;
  var t = d3(), e = function() {
    try {
      var r = t(Object, "defineProperty");
      return r({}, "", {}), r;
    } catch {
    }
  }();
  return fw = e, fw;
}
var hw, N_;
function KTe() {
  if (N_) return hw;
  N_ = 1;
  var t = XTe();
  function e(r, n, a) {
    n == "__proto__" && t ? t(r, n, {
      configurable: !0,
      enumerable: !0,
      value: a,
      writable: !0
    }) : r[n] = a;
  }
  return hw = e, hw;
}
var dw, O_;
function ZTe() {
  if (O_) return dw;
  O_ = 1;
  var t = KTe(), e = az(), r = Object.prototype, n = r.hasOwnProperty;
  function a(i, s, o) {
    var l = i[s];
    (!(n.call(i, s) && e(l, o)) || o === void 0 && !(s in i)) && t(i, s, o);
  }
  return dw = a, dw;
}
var pw, I_;
function QTe() {
  if (I_) return pw;
  I_ = 1;
  var t = 9007199254740991, e = /^(?:0|[1-9]\d*)$/;
  function r(n, a) {
    var i = typeof n;
    return a = a ?? t, !!a && (i == "number" || i != "symbol" && e.test(n)) && n > -1 && n % 1 == 0 && n < a;
  }
  return pw = r, pw;
}
var gw, P_;
function JTe() {
  if (P_) return gw;
  P_ = 1;
  var t = ZTe(), e = lz(), r = QTe(), n = cp(), a = p3();
  function i(s, o, l, u) {
    if (!n(s))
      return s;
    o = e(o, s);
    for (var c = -1, f = o.length, h = f - 1, d = s; d != null && ++c < f; ) {
      var p = a(o[c]), g = l;
      if (p === "__proto__" || p === "constructor" || p === "prototype")
        return s;
      if (c != h) {
        var v = d[p];
        g = u ? u(v, p, d) : void 0, g === void 0 && (g = n(v) ? v : r(o[c + 1]) ? [] : {});
      }
      t(d, p, g), d = d[p];
    }
    return s;
  }
  return gw = i, gw;
}
var vw, D_;
function e4e() {
  if (D_) return vw;
  D_ = 1;
  var t = JTe();
  function e(r, n, a) {
    return r == null ? r : t(r, n, a);
  }
  return vw = e, vw;
}
var t4e = e4e(), r4e = /* @__PURE__ */ up(t4e), mw, $_;
function n4e() {
  if ($_) return mw;
  $_ = 1;
  function t(e, r) {
    var n = -1, a = e.length;
    for (r || (r = Array(a)); ++n < a; )
      r[n] = e[n];
    return r;
  }
  return mw = t, mw;
}
var yw, F_;
function a4e() {
  if (F_) return yw;
  F_ = 1;
  var t = sz(), e = n4e(), r = eb(), n = fp(), a = iz(), i = p3(), s = oz();
  function o(l) {
    return r(l) ? t(l, i) : n(l) ? [l] : e(a(s(l)));
  }
  return yw = o, yw;
}
var i4e = a4e(), s4e = /* @__PURE__ */ up(i4e), o4e = {
  // access data field
  data: function(e) {
    var r = {
      field: "data",
      bindingEvent: "data",
      allowBinding: !1,
      allowSetting: !1,
      allowGetting: !1,
      settingEvent: "data",
      settingTriggersEvent: !1,
      triggerFnName: "trigger",
      immutableKeys: {},
      // key => true if immutable
      updateStyle: !1,
      beforeGet: function(a) {
      },
      beforeSet: function(a, i) {
      },
      onSet: function(a) {
      },
      canSet: function(a) {
        return !0;
      }
    };
    return e = At({}, r, e), function(a, i) {
      var s = e, o = this, l = o.length !== void 0, u = l ? o : [o], c = l ? o[0] : o;
      if (xt(a)) {
        var f = a.indexOf(".") !== -1, h = f && s4e(a);
        if (s.allowGetting && i === void 0) {
          var d;
          return c && (s.beforeGet(c), h && c._private[s.field][a] === void 0 ? d = YTe(c._private[s.field], h) : d = c._private[s.field][a]), d;
        } else if (s.allowSetting && i !== void 0) {
          var p = !s.immutableKeys[a];
          if (p) {
            var g = TB({}, a, i);
            s.beforeSet(o, g);
            for (var v = 0, m = u.length; v < m; v++) {
              var b = u[v];
              s.canSet(b) && (h && c._private[s.field][a] === void 0 ? r4e(b._private[s.field], h, i) : b._private[s.field][a] = i);
            }
            s.updateStyle && o.updateStyle(), s.onSet(o), s.settingTriggersEvent && o[s.triggerFnName](s.settingEvent);
          }
        }
      } else if (s.allowSetting && Qt(a)) {
        var y = a, x, E, S = Object.keys(y);
        s.beforeSet(o, y);
        for (var w = 0; w < S.length; w++) {
          x = S[w], E = y[x];
          var C = !s.immutableKeys[x];
          if (C)
            for (var k = 0; k < u.length; k++) {
              var N = u[k];
              s.canSet(N) && (N._private[s.field][x] = E);
            }
        }
        s.updateStyle && o.updateStyle(), s.onSet(o), s.settingTriggersEvent && o[s.triggerFnName](s.settingEvent);
      } else if (s.allowBinding && Wr(a)) {
        var R = a;
        o.on(s.bindingEvent, R);
      } else if (s.allowGetting && a === void 0) {
        var _;
        return c && (s.beforeGet(c), _ = c._private[s.field]), _;
      }
      return o;
    };
  },
  // data
  // remove data field
  removeData: function(e) {
    var r = {
      field: "data",
      event: "data",
      triggerFnName: "trigger",
      triggerEvent: !1,
      immutableKeys: {}
      // key => true if immutable
    };
    return e = At({}, r, e), function(a) {
      var i = e, s = this, o = s.length !== void 0, l = o ? s : [s];
      if (xt(a)) {
        for (var u = a.split(/\s+/), c = u.length, f = 0; f < c; f++) {
          var h = u[f];
          if (!jo(h)) {
            var d = !i.immutableKeys[h];
            if (d)
              for (var p = 0, g = l.length; p < g; p++)
                l[p]._private[i.field][h] = void 0;
          }
        }
        i.triggerEvent && s[i.triggerFnName](i.event);
      } else if (a === void 0) {
        for (var v = 0, m = l.length; v < m; v++)
          for (var b = l[v]._private[i.field], y = Object.keys(b), x = 0; x < y.length; x++) {
            var E = y[x], S = !i.immutableKeys[E];
            S && (b[E] = void 0);
          }
        i.triggerEvent && s[i.triggerFnName](i.event);
      }
      return s;
    };
  }
  // removeData
}, l4e = {
  eventAliasesOn: function(e) {
    var r = e;
    r.addListener = r.listen = r.bind = r.on, r.unlisten = r.unbind = r.off = r.removeListener, r.trigger = r.emit, r.pon = r.promiseOn = function(n, a) {
      var i = this, s = Array.prototype.slice.call(arguments, 0);
      return new _f(function(o, l) {
        var u = function(d) {
          i.off.apply(i, f), o(d);
        }, c = s.concat([u]), f = c.concat([]);
        i.on.apply(i, c);
      });
    };
  }
}, hr = {};
[pTe, o4e, l4e].forEach(function(t) {
  At(hr, t);
});
var u4e = {
  animate: hr.animate(),
  animation: hr.animation(),
  animated: hr.animated(),
  clearQueue: hr.clearQueue(),
  delay: hr.delay(),
  delayAnimation: hr.delayAnimation(),
  stop: hr.stop()
}, mv = {
  classes: function(e) {
    var r = this;
    if (e === void 0) {
      var n = [];
      return r[0]._private.classes.forEach(function(p) {
        return n.push(p);
      }), n;
    } else Sr(e) || (e = (e || "").match(/\S+/g) || []);
    for (var a = [], i = new Mf(e), s = 0; s < r.length; s++) {
      for (var o = r[s], l = o._private, u = l.classes, c = !1, f = 0; f < e.length; f++) {
        var h = e[f], d = u.has(h);
        if (!d) {
          c = !0;
          break;
        }
      }
      c || (c = u.size !== e.length), c && (l.classes = i, a.push(o));
    }
    return a.length > 0 && this.spawn(a).updateStyle().emit("class"), r;
  },
  addClass: function(e) {
    return this.toggleClass(e, !0);
  },
  hasClass: function(e) {
    var r = this[0];
    return r != null && r._private.classes.has(e);
  },
  toggleClass: function(e, r) {
    Sr(e) || (e = e.match(/\S+/g) || []);
    for (var n = this, a = r === void 0, i = [], s = 0, o = n.length; s < o; s++)
      for (var l = n[s], u = l._private.classes, c = !1, f = 0; f < e.length; f++) {
        var h = e[f], d = u.has(h), p = !1;
        r || a && !d ? (u.add(h), p = !0) : (!r || a && d) && (u.delete(h), p = !0), !c && p && (i.push(l), c = !0);
      }
    return i.length > 0 && this.spawn(i).updateStyle().emit("class"), n;
  },
  removeClass: function(e) {
    return this.toggleClass(e, !1);
  },
  flashClass: function(e, r) {
    var n = this;
    if (r == null)
      r = 250;
    else if (r === 0)
      return n;
    return n.addClass(e), setTimeout(function() {
      n.removeClass(e);
    }, r), n;
  }
};
mv.className = mv.classNames = mv.classes;
var Zt = {
  metaChar: "[\\!\\\"\\#\\$\\%\\&\\'\\(\\)\\*\\+\\,\\.\\/\\:\\;\\<\\=\\>\\?\\@\\[\\]\\^\\`\\{\\|\\}\\~]",
  // chars we need to escape in let names, etc
  comparatorOp: "=|\\!=|>|>=|<|<=|\\$=|\\^=|\\*=",
  // binary comparison op (used in data selectors)
  boolOp: "\\?|\\!|\\^",
  // boolean (unary) operators (used in data selectors)
  string: `"(?:\\\\"|[^"])*"|'(?:\\\\'|[^'])*'`,
  // string literals (used in data selectors) -- doublequotes | singlequotes
  number: mn,
  // number literal (used in data selectors) --- e.g. 0.1234, 1234, 12e123
  meta: "degree|indegree|outdegree",
  // allowed metadata fields (i.e. allowed functions to use from Collection)
  separator: "\\s*,\\s*",
  // queries are separated by commas, e.g. edge[foo = 'bar'], node.someClass
  descendant: "\\s+",
  child: "\\s+>\\s+",
  subject: "\\$",
  group: "node|edge|\\*",
  directedEdge: "\\s+->\\s+",
  undirectedEdge: "\\s+<->\\s+"
};
Zt.variable = "(?:[\\w-.]|(?:\\\\" + Zt.metaChar + "))+";
Zt.className = "(?:[\\w-]|(?:\\\\" + Zt.metaChar + "))+";
Zt.value = Zt.string + "|" + Zt.number;
Zt.id = Zt.variable;
(function() {
  var t, e, r;
  for (t = Zt.comparatorOp.split("|"), r = 0; r < t.length; r++)
    e = t[r], Zt.comparatorOp += "|@" + e;
  for (t = Zt.comparatorOp.split("|"), r = 0; r < t.length; r++)
    e = t[r], !(e.indexOf("!") >= 0) && e !== "=" && (Zt.comparatorOp += "|\\!" + e);
})();
var xr = function() {
  return {
    checks: []
  };
}, ht = {
  /** E.g. node */
  GROUP: 0,
  /** A collection of elements */
  COLLECTION: 1,
  /** A filter(ele) function */
  FILTER: 2,
  /** E.g. [foo > 1] */
  DATA_COMPARE: 3,
  /** E.g. [foo] */
  DATA_EXIST: 4,
  /** E.g. [?foo] */
  DATA_BOOL: 5,
  /** E.g. [[degree > 2]] */
  META_COMPARE: 6,
  /** E.g. :selected */
  STATE: 7,
  /** E.g. #foo */
  ID: 8,
  /** E.g. .foo */
  CLASS: 9,
  /** E.g. #foo <-> #bar */
  UNDIRECTED_EDGE: 10,
  /** E.g. #foo -> #bar */
  DIRECTED_EDGE: 11,
  /** E.g. $#foo -> #bar */
  NODE_SOURCE: 12,
  /** E.g. #foo -> $#bar */
  NODE_TARGET: 13,
  /** E.g. $#foo <-> #bar */
  NODE_NEIGHBOR: 14,
  /** E.g. #foo > #bar */
  CHILD: 15,
  /** E.g. #foo #bar */
  DESCENDANT: 16,
  /** E.g. $#foo > #bar */
  PARENT: 17,
  /** E.g. $#foo #bar */
  ANCESTOR: 18,
  /** E.g. #foo > $bar > #baz */
  COMPOUND_SPLIT: 19,
  /** Always matches, useful placeholder for subject in `COMPOUND_SPLIT` */
  TRUE: 20
}, S4 = [{
  selector: ":selected",
  matches: function(e) {
    return e.selected();
  }
}, {
  selector: ":unselected",
  matches: function(e) {
    return !e.selected();
  }
}, {
  selector: ":selectable",
  matches: function(e) {
    return e.selectable();
  }
}, {
  selector: ":unselectable",
  matches: function(e) {
    return !e.selectable();
  }
}, {
  selector: ":locked",
  matches: function(e) {
    return e.locked();
  }
}, {
  selector: ":unlocked",
  matches: function(e) {
    return !e.locked();
  }
}, {
  selector: ":visible",
  matches: function(e) {
    return e.visible();
  }
}, {
  selector: ":hidden",
  matches: function(e) {
    return !e.visible();
  }
}, {
  selector: ":transparent",
  matches: function(e) {
    return e.transparent();
  }
}, {
  selector: ":grabbed",
  matches: function(e) {
    return e.grabbed();
  }
}, {
  selector: ":free",
  matches: function(e) {
    return !e.grabbed();
  }
}, {
  selector: ":removed",
  matches: function(e) {
    return e.removed();
  }
}, {
  selector: ":inside",
  matches: function(e) {
    return !e.removed();
  }
}, {
  selector: ":grabbable",
  matches: function(e) {
    return e.grabbable();
  }
}, {
  selector: ":ungrabbable",
  matches: function(e) {
    return !e.grabbable();
  }
}, {
  selector: ":animated",
  matches: function(e) {
    return e.animated();
  }
}, {
  selector: ":unanimated",
  matches: function(e) {
    return !e.animated();
  }
}, {
  selector: ":parent",
  matches: function(e) {
    return e.isParent();
  }
}, {
  selector: ":childless",
  matches: function(e) {
    return e.isChildless();
  }
}, {
  selector: ":child",
  matches: function(e) {
    return e.isChild();
  }
}, {
  selector: ":orphan",
  matches: function(e) {
    return e.isOrphan();
  }
}, {
  selector: ":nonorphan",
  matches: function(e) {
    return e.isChild();
  }
}, {
  selector: ":compound",
  matches: function(e) {
    return e.isNode() ? e.isParent() : e.source().isParent() || e.target().isParent();
  }
}, {
  selector: ":loop",
  matches: function(e) {
    return e.isLoop();
  }
}, {
  selector: ":simple",
  matches: function(e) {
    return e.isSimple();
  }
}, {
  selector: ":active",
  matches: function(e) {
    return e.active();
  }
}, {
  selector: ":inactive",
  matches: function(e) {
    return !e.active();
  }
}, {
  selector: ":backgrounding",
  matches: function(e) {
    return e.backgrounding();
  }
}, {
  selector: ":nonbackgrounding",
  matches: function(e) {
    return !e.backgrounding();
  }
}].sort(function(t, e) {
  return owe(t.selector, e.selector);
}), c4e = function() {
  for (var t = {}, e, r = 0; r < S4.length; r++)
    e = S4[r], t[e.selector] = e.matches;
  return t;
}(), f4e = function(e, r) {
  return c4e[e](r);
}, h4e = "(" + S4.map(function(t) {
  return t.selector;
}).join("|") + ")", Vu = function(e) {
  return e.replace(new RegExp("\\\\(" + Zt.metaChar + ")", "g"), function(r, n) {
    return n;
  });
}, Co = function(e, r, n) {
  e[e.length - 1] = n;
}, C4 = [{
  name: "group",
  // just used for identifying when debugging
  query: !0,
  regex: "(" + Zt.group + ")",
  populate: function(e, r, n) {
    var a = ln(n, 1), i = a[0];
    r.checks.push({
      type: ht.GROUP,
      value: i === "*" ? i : i + "s"
    });
  }
}, {
  name: "state",
  query: !0,
  regex: h4e,
  populate: function(e, r, n) {
    var a = ln(n, 1), i = a[0];
    r.checks.push({
      type: ht.STATE,
      value: i
    });
  }
}, {
  name: "id",
  query: !0,
  regex: "\\#(" + Zt.id + ")",
  populate: function(e, r, n) {
    var a = ln(n, 1), i = a[0];
    r.checks.push({
      type: ht.ID,
      value: Vu(i)
    });
  }
}, {
  name: "className",
  query: !0,
  regex: "\\.(" + Zt.className + ")",
  populate: function(e, r, n) {
    var a = ln(n, 1), i = a[0];
    r.checks.push({
      type: ht.CLASS,
      value: Vu(i)
    });
  }
}, {
  name: "dataExists",
  query: !0,
  regex: "\\[\\s*(" + Zt.variable + ")\\s*\\]",
  populate: function(e, r, n) {
    var a = ln(n, 1), i = a[0];
    r.checks.push({
      type: ht.DATA_EXIST,
      field: Vu(i)
    });
  }
}, {
  name: "dataCompare",
  query: !0,
  regex: "\\[\\s*(" + Zt.variable + ")\\s*(" + Zt.comparatorOp + ")\\s*(" + Zt.value + ")\\s*\\]",
  populate: function(e, r, n) {
    var a = ln(n, 3), i = a[0], s = a[1], o = a[2], l = new RegExp("^" + Zt.string + "$").exec(o) != null;
    l ? o = o.substring(1, o.length - 1) : o = parseFloat(o), r.checks.push({
      type: ht.DATA_COMPARE,
      field: Vu(i),
      operator: s,
      value: o
    });
  }
}, {
  name: "dataBool",
  query: !0,
  regex: "\\[\\s*(" + Zt.boolOp + ")\\s*(" + Zt.variable + ")\\s*\\]",
  populate: function(e, r, n) {
    var a = ln(n, 2), i = a[0], s = a[1];
    r.checks.push({
      type: ht.DATA_BOOL,
      field: Vu(s),
      operator: i
    });
  }
}, {
  name: "metaCompare",
  query: !0,
  regex: "\\[\\[\\s*(" + Zt.meta + ")\\s*(" + Zt.comparatorOp + ")\\s*(" + Zt.number + ")\\s*\\]\\]",
  populate: function(e, r, n) {
    var a = ln(n, 3), i = a[0], s = a[1], o = a[2];
    r.checks.push({
      type: ht.META_COMPARE,
      field: Vu(i),
      operator: s,
      value: parseFloat(o)
    });
  }
}, {
  name: "nextQuery",
  separator: !0,
  regex: Zt.separator,
  populate: function(e, r) {
    var n = e.currentSubject, a = e.edgeCount, i = e.compoundCount, s = e[e.length - 1];
    n != null && (s.subject = n, e.currentSubject = null), s.edgeCount = a, s.compoundCount = i, e.edgeCount = 0, e.compoundCount = 0;
    var o = e[e.length++] = xr();
    return o;
  }
}, {
  name: "directedEdge",
  separator: !0,
  regex: Zt.directedEdge,
  populate: function(e, r) {
    if (e.currentSubject == null) {
      var n = xr(), a = r, i = xr();
      return n.checks.push({
        type: ht.DIRECTED_EDGE,
        source: a,
        target: i
      }), Co(e, r, n), e.edgeCount++, i;
    } else {
      var s = xr(), o = r, l = xr();
      return s.checks.push({
        type: ht.NODE_SOURCE,
        source: o,
        target: l
      }), Co(e, r, s), e.edgeCount++, l;
    }
  }
}, {
  name: "undirectedEdge",
  separator: !0,
  regex: Zt.undirectedEdge,
  populate: function(e, r) {
    if (e.currentSubject == null) {
      var n = xr(), a = r, i = xr();
      return n.checks.push({
        type: ht.UNDIRECTED_EDGE,
        nodes: [a, i]
      }), Co(e, r, n), e.edgeCount++, i;
    } else {
      var s = xr(), o = r, l = xr();
      return s.checks.push({
        type: ht.NODE_NEIGHBOR,
        node: o,
        neighbor: l
      }), Co(e, r, s), l;
    }
  }
}, {
  name: "child",
  separator: !0,
  regex: Zt.child,
  populate: function(e, r) {
    if (e.currentSubject == null) {
      var n = xr(), a = xr(), i = e[e.length - 1];
      return n.checks.push({
        type: ht.CHILD,
        parent: i,
        child: a
      }), Co(e, r, n), e.compoundCount++, a;
    } else if (e.currentSubject === r) {
      var s = xr(), o = e[e.length - 1], l = xr(), u = xr(), c = xr(), f = xr();
      return s.checks.push({
        type: ht.COMPOUND_SPLIT,
        left: o,
        right: l,
        subject: u
      }), u.checks = r.checks, r.checks = [{
        type: ht.TRUE
      }], f.checks.push({
        type: ht.TRUE
      }), l.checks.push({
        type: ht.PARENT,
        // type is swapped on right side queries
        parent: f,
        child: c
        // empty for now
      }), Co(e, o, s), e.currentSubject = u, e.compoundCount++, c;
    } else {
      var h = xr(), d = xr(), p = [{
        type: ht.PARENT,
        parent: h,
        child: d
      }];
      return h.checks = r.checks, r.checks = p, e.compoundCount++, d;
    }
  }
}, {
  name: "descendant",
  separator: !0,
  regex: Zt.descendant,
  populate: function(e, r) {
    if (e.currentSubject == null) {
      var n = xr(), a = xr(), i = e[e.length - 1];
      return n.checks.push({
        type: ht.DESCENDANT,
        ancestor: i,
        descendant: a
      }), Co(e, r, n), e.compoundCount++, a;
    } else if (e.currentSubject === r) {
      var s = xr(), o = e[e.length - 1], l = xr(), u = xr(), c = xr(), f = xr();
      return s.checks.push({
        type: ht.COMPOUND_SPLIT,
        left: o,
        right: l,
        subject: u
      }), u.checks = r.checks, r.checks = [{
        type: ht.TRUE
      }], f.checks.push({
        type: ht.TRUE
      }), l.checks.push({
        type: ht.ANCESTOR,
        // type is swapped on right side queries
        ancestor: f,
        descendant: c
        // empty for now
      }), Co(e, o, s), e.currentSubject = u, e.compoundCount++, c;
    } else {
      var h = xr(), d = xr(), p = [{
        type: ht.ANCESTOR,
        ancestor: h,
        descendant: d
      }];
      return h.checks = r.checks, r.checks = p, e.compoundCount++, d;
    }
  }
}, {
  name: "subject",
  modifier: !0,
  regex: Zt.subject,
  populate: function(e, r) {
    if (e.currentSubject != null && e.currentSubject !== r)
      return pr("Redefinition of subject in selector `" + e.toString() + "`"), !1;
    e.currentSubject = r;
    var n = e[e.length - 1], a = n.checks[0], i = a == null ? null : a.type;
    i === ht.DIRECTED_EDGE ? a.type = ht.NODE_TARGET : i === ht.UNDIRECTED_EDGE && (a.type = ht.NODE_NEIGHBOR, a.node = a.nodes[1], a.neighbor = a.nodes[0], a.nodes = null);
  }
}];
C4.forEach(function(t) {
  return t.regexObj = new RegExp("^" + t.regex);
});
var d4e = function(e) {
  for (var r, n, a, i = 0; i < C4.length; i++) {
    var s = C4[i], o = s.name, l = e.match(s.regexObj);
    if (l != null) {
      n = l, r = s, a = o;
      var u = l[0];
      e = e.substring(u.length);
      break;
    }
  }
  return {
    expr: r,
    match: n,
    name: a,
    remaining: e
  };
}, p4e = function(e) {
  var r = e.match(/^\s+/);
  if (r) {
    var n = r[0];
    e = e.substring(n.length);
  }
  return e;
}, g4e = function(e) {
  var r = this, n = r.inputText = e, a = r[0] = xr();
  for (r.length = 1, n = p4e(n); ; ) {
    var i = d4e(n);
    if (i.expr == null)
      return pr("The selector `" + e + "`is invalid"), !1;
    var s = i.match.slice(1), o = i.expr.populate(r, a, s);
    if (o === !1)
      return !1;
    if (o != null && (a = o), n = i.remaining, n.match(/^\s*$/))
      break;
  }
  var l = r[r.length - 1];
  r.currentSubject != null && (l.subject = r.currentSubject), l.edgeCount = r.edgeCount, l.compoundCount = r.compoundCount;
  for (var u = 0; u < r.length; u++) {
    var c = r[u];
    if (c.compoundCount > 0 && c.edgeCount > 0)
      return pr("The selector `" + e + "` is invalid because it uses both a compound selector and an edge selector"), !1;
    if (c.edgeCount > 1)
      return pr("The selector `" + e + "` is invalid because it uses multiple edge selectors"), !1;
    c.edgeCount === 1 && pr("The selector `" + e + "` is deprecated.  Edge selectors do not take effect on changes to source and target nodes after an edge is added, for performance reasons.  Use a class or data selector on edges instead, updating the class or data of an edge when your app detects a change in source or target nodes.");
  }
  return !0;
}, v4e = function() {
  if (this.toStringCache != null)
    return this.toStringCache;
  for (var e = function(c) {
    return c ?? "";
  }, r = function(c) {
    return xt(c) ? '"' + c + '"' : e(c);
  }, n = function(c) {
    return " " + c + " ";
  }, a = function(c, f) {
    var h = c.type, d = c.value;
    switch (h) {
      case ht.GROUP: {
        var p = e(d);
        return p.substring(0, p.length - 1);
      }
      case ht.DATA_COMPARE: {
        var g = c.field, v = c.operator;
        return "[" + g + n(e(v)) + r(d) + "]";
      }
      case ht.DATA_BOOL: {
        var m = c.operator, b = c.field;
        return "[" + e(m) + b + "]";
      }
      case ht.DATA_EXIST: {
        var y = c.field;
        return "[" + y + "]";
      }
      case ht.META_COMPARE: {
        var x = c.operator, E = c.field;
        return "[[" + E + n(e(x)) + r(d) + "]]";
      }
      case ht.STATE:
        return d;
      case ht.ID:
        return "#" + d;
      case ht.CLASS:
        return "." + d;
      case ht.PARENT:
      case ht.CHILD:
        return i(c.parent, f) + n(">") + i(c.child, f);
      case ht.ANCESTOR:
      case ht.DESCENDANT:
        return i(c.ancestor, f) + " " + i(c.descendant, f);
      case ht.COMPOUND_SPLIT: {
        var S = i(c.left, f), w = i(c.subject, f), C = i(c.right, f);
        return S + (S.length > 0 ? " " : "") + w + C;
      }
      case ht.TRUE:
        return "";
    }
  }, i = function(c, f) {
    return c.checks.reduce(function(h, d, p) {
      return h + (f === c && p === 0 ? "$" : "") + a(d, f);
    }, "");
  }, s = "", o = 0; o < this.length; o++) {
    var l = this[o];
    s += i(l, l.subject), this.length > 1 && o < this.length - 1 && (s += ", ");
  }
  return this.toStringCache = s, s;
}, m4e = {
  parse: g4e,
  toString: v4e
}, uz = function(e, r, n) {
  var a, i = xt(e), s = tt(e), o = xt(n), l, u, c = !1, f = !1, h = !1;
  switch (r.indexOf("!") >= 0 && (r = r.replace("!", ""), f = !0), r.indexOf("@") >= 0 && (r = r.replace("@", ""), c = !0), (i || o || c) && (l = !i && !s ? "" : "" + e, u = "" + n), c && (e = l = l.toLowerCase(), n = u = u.toLowerCase()), r) {
    case "*=":
      a = l.indexOf(u) >= 0;
      break;
    case "$=":
      a = l.indexOf(u, l.length - u.length) >= 0;
      break;
    case "^=":
      a = l.indexOf(u) === 0;
      break;
    case "=":
      a = e === n;
      break;
    case ">":
      h = !0, a = e > n;
      break;
    case ">=":
      h = !0, a = e >= n;
      break;
    case "<":
      h = !0, a = e < n;
      break;
    case "<=":
      h = !0, a = e <= n;
      break;
    default:
      a = !1;
      break;
  }
  return f && (e != null || !h) && (a = !a), a;
}, y4e = function(e, r) {
  switch (r) {
    case "?":
      return !!e;
    case "!":
      return !e;
    case "^":
      return e === void 0;
  }
}, b4e = function(e) {
  return e !== void 0;
}, g3 = function(e, r) {
  return e.data(r);
}, x4e = function(e, r) {
  return e[r]();
}, Qr = [], Ir = function(e, r) {
  return e.checks.every(function(n) {
    return Qr[n.type](n, r);
  });
};
Qr[ht.GROUP] = function(t, e) {
  var r = t.value;
  return r === "*" || r === e.group();
};
Qr[ht.STATE] = function(t, e) {
  var r = t.value;
  return f4e(r, e);
};
Qr[ht.ID] = function(t, e) {
  var r = t.value;
  return e.id() === r;
};
Qr[ht.CLASS] = function(t, e) {
  var r = t.value;
  return e.hasClass(r);
};
Qr[ht.META_COMPARE] = function(t, e) {
  var r = t.field, n = t.operator, a = t.value;
  return uz(x4e(e, r), n, a);
};
Qr[ht.DATA_COMPARE] = function(t, e) {
  var r = t.field, n = t.operator, a = t.value;
  return uz(g3(e, r), n, a);
};
Qr[ht.DATA_BOOL] = function(t, e) {
  var r = t.field, n = t.operator;
  return y4e(g3(e, r), n);
};
Qr[ht.DATA_EXIST] = function(t, e) {
  var r = t.field;
  return t.operator, b4e(g3(e, r));
};
Qr[ht.UNDIRECTED_EDGE] = function(t, e) {
  var r = t.nodes[0], n = t.nodes[1], a = e.source(), i = e.target();
  return Ir(r, a) && Ir(n, i) || Ir(n, a) && Ir(r, i);
};
Qr[ht.NODE_NEIGHBOR] = function(t, e) {
  return Ir(t.node, e) && e.neighborhood().some(function(r) {
    return r.isNode() && Ir(t.neighbor, r);
  });
};
Qr[ht.DIRECTED_EDGE] = function(t, e) {
  return Ir(t.source, e.source()) && Ir(t.target, e.target());
};
Qr[ht.NODE_SOURCE] = function(t, e) {
  return Ir(t.source, e) && e.outgoers().some(function(r) {
    return r.isNode() && Ir(t.target, r);
  });
};
Qr[ht.NODE_TARGET] = function(t, e) {
  return Ir(t.target, e) && e.incomers().some(function(r) {
    return r.isNode() && Ir(t.source, r);
  });
};
Qr[ht.CHILD] = function(t, e) {
  return Ir(t.child, e) && Ir(t.parent, e.parent());
};
Qr[ht.PARENT] = function(t, e) {
  return Ir(t.parent, e) && e.children().some(function(r) {
    return Ir(t.child, r);
  });
};
Qr[ht.DESCENDANT] = function(t, e) {
  return Ir(t.descendant, e) && e.ancestors().some(function(r) {
    return Ir(t.ancestor, r);
  });
};
Qr[ht.ANCESTOR] = function(t, e) {
  return Ir(t.ancestor, e) && e.descendants().some(function(r) {
    return Ir(t.descendant, r);
  });
};
Qr[ht.COMPOUND_SPLIT] = function(t, e) {
  return Ir(t.subject, e) && Ir(t.left, e) && Ir(t.right, e);
};
Qr[ht.TRUE] = function() {
  return !0;
};
Qr[ht.COLLECTION] = function(t, e) {
  var r = t.value;
  return r.has(e);
};
Qr[ht.FILTER] = function(t, e) {
  var r = t.value;
  return r(e);
};
var w4e = function(e) {
  var r = this;
  if (r.length === 1 && r[0].checks.length === 1 && r[0].checks[0].type === ht.ID)
    return e.getElementById(r[0].checks[0].value).collection();
  var n = function(i) {
    for (var s = 0; s < r.length; s++) {
      var o = r[s];
      if (Ir(o, i))
        return !0;
    }
    return !1;
  };
  return r.text() == null && (n = function() {
    return !0;
  }), e.filter(n);
}, E4e = function(e) {
  for (var r = this, n = 0; n < r.length; n++) {
    var a = r[n];
    if (Ir(a, e))
      return !0;
  }
  return !1;
}, T4e = {
  matches: E4e,
  filter: w4e
}, Ko = function(e) {
  this.inputText = e, this.currentSubject = null, this.compoundCount = 0, this.edgeCount = 0, this.length = 0, e == null || xt(e) && e.match(/^\s*$/) || (ri(e) ? this.addQuery({
    checks: [{
      type: ht.COLLECTION,
      value: e.collection()
    }]
  }) : Wr(e) ? this.addQuery({
    checks: [{
      type: ht.FILTER,
      value: e
    }]
  }) : xt(e) ? this.parse(e) || (this.invalid = !0) : Fr("A selector must be created from a string; found "));
}, Zo = Ko.prototype;
[m4e, T4e].forEach(function(t) {
  return At(Zo, t);
});
Zo.text = function() {
  return this.inputText;
};
Zo.size = function() {
  return this.length;
};
Zo.eq = function(t) {
  return this[t];
};
Zo.sameText = function(t) {
  return !this.invalid && !t.invalid && this.text() === t.text();
};
Zo.addQuery = function(t) {
  this[this.length++] = t;
};
Zo.selector = Zo.toString;
var Fo = {
  allAre: function(e) {
    var r = new Ko(e);
    return this.every(function(n) {
      return r.matches(n);
    });
  },
  is: function(e) {
    var r = new Ko(e);
    return this.some(function(n) {
      return r.matches(n);
    });
  },
  some: function(e, r) {
    for (var n = 0; n < this.length; n++) {
      var a = r ? e.apply(r, [this[n], n, this]) : e(this[n], n, this);
      if (a)
        return !0;
    }
    return !1;
  },
  every: function(e, r) {
    for (var n = 0; n < this.length; n++) {
      var a = r ? e.apply(r, [this[n], n, this]) : e(this[n], n, this);
      if (!a)
        return !1;
    }
    return !0;
  },
  same: function(e) {
    if (this === e)
      return !0;
    e = this.cy().collection(e);
    var r = this.length, n = e.length;
    return r !== n ? !1 : r === 1 ? this[0] === e[0] : this.every(function(a) {
      return e.hasElementWithId(a.id());
    });
  },
  anySame: function(e) {
    return e = this.cy().collection(e), this.some(function(r) {
      return e.hasElementWithId(r.id());
    });
  },
  allAreNeighbors: function(e) {
    e = this.cy().collection(e);
    var r = this.neighborhood();
    return e.every(function(n) {
      return r.hasElementWithId(n.id());
    });
  },
  contains: function(e) {
    e = this.cy().collection(e);
    var r = this;
    return e.every(function(n) {
      return r.hasElementWithId(n.id());
    });
  }
};
Fo.allAreNeighbours = Fo.allAreNeighbors;
Fo.has = Fo.contains;
Fo.equal = Fo.equals = Fo.same;
var gi = function(e, r) {
  return function(a, i, s, o) {
    var l = a, u = this, c;
    if (l == null ? c = "" : ri(l) && l.length === 1 && (c = l.id()), u.length === 1 && c) {
      var f = u[0]._private, h = f.traversalCache = f.traversalCache || {}, d = h[r] = h[r] || [], p = iu(c), g = d[p];
      return g || (d[p] = e.call(u, a, i, s, o));
    } else
      return e.call(u, a, i, s, o);
  };
}, hf = {
  parent: function(e) {
    var r = [];
    if (this.length === 1) {
      var n = this[0]._private.parent;
      if (n)
        return n;
    }
    for (var a = 0; a < this.length; a++) {
      var i = this[a], s = i._private.parent;
      s && r.push(s);
    }
    return this.spawn(r, !0).filter(e);
  },
  parents: function(e) {
    for (var r = [], n = this.parent(); n.nonempty(); ) {
      for (var a = 0; a < n.length; a++) {
        var i = n[a];
        r.push(i);
      }
      n = n.parent();
    }
    return this.spawn(r, !0).filter(e);
  },
  commonAncestors: function(e) {
    for (var r, n = 0; n < this.length; n++) {
      var a = this[n], i = a.parents();
      r = r || i, r = r.intersect(i);
    }
    return r.filter(e);
  },
  orphans: function(e) {
    return this.stdFilter(function(r) {
      return r.isOrphan();
    }).filter(e);
  },
  nonorphans: function(e) {
    return this.stdFilter(function(r) {
      return r.isChild();
    }).filter(e);
  },
  children: gi(function(t) {
    for (var e = [], r = 0; r < this.length; r++)
      for (var n = this[r], a = n._private.children, i = 0; i < a.length; i++)
        e.push(a[i]);
    return this.spawn(e, !0).filter(t);
  }, "children"),
  siblings: function(e) {
    return this.parent().children().not(this).filter(e);
  },
  isParent: function() {
    var e = this[0];
    if (e)
      return e.isNode() && e._private.children.length !== 0;
  },
  isChildless: function() {
    var e = this[0];
    if (e)
      return e.isNode() && e._private.children.length === 0;
  },
  isChild: function() {
    var e = this[0];
    if (e)
      return e.isNode() && e._private.parent != null;
  },
  isOrphan: function() {
    var e = this[0];
    if (e)
      return e.isNode() && e._private.parent == null;
  },
  descendants: function(e) {
    var r = [];
    function n(a) {
      for (var i = 0; i < a.length; i++) {
        var s = a[i];
        r.push(s), s.children().nonempty() && n(s.children());
      }
    }
    return n(this.children()), this.spawn(r, !0).filter(e);
  }
};
function v3(t, e, r, n) {
  for (var a = [], i = new Mf(), s = t.cy(), o = s.hasCompoundNodes(), l = 0; l < t.length; l++) {
    var u = t[l];
    r ? a.push(u) : o && n(a, i, u);
  }
  for (; a.length > 0; ) {
    var c = a.shift();
    e(c), i.add(c.id()), o && n(a, i, c);
  }
  return t;
}
function cz(t, e, r) {
  if (r.isParent())
    for (var n = r._private.children, a = 0; a < n.length; a++) {
      var i = n[a];
      e.has(i.id()) || t.push(i);
    }
}
hf.forEachDown = function(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  return v3(this, t, e, cz);
};
function fz(t, e, r) {
  if (r.isChild()) {
    var n = r._private.parent;
    e.has(n.id()) || t.push(n);
  }
}
hf.forEachUp = function(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  return v3(this, t, e, fz);
};
function S4e(t, e, r) {
  fz(t, e, r), cz(t, e, r);
}
hf.forEachUpAndDown = function(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  return v3(this, t, e, S4e);
};
hf.ancestors = hf.parents;
var f0, hz;
f0 = hz = {
  data: hr.data({
    field: "data",
    bindingEvent: "data",
    allowBinding: !0,
    allowSetting: !0,
    settingEvent: "data",
    settingTriggersEvent: !0,
    triggerFnName: "trigger",
    allowGetting: !0,
    immutableKeys: {
      id: !0,
      source: !0,
      target: !0,
      parent: !0
    },
    updateStyle: !0
  }),
  removeData: hr.removeData({
    field: "data",
    event: "data",
    triggerFnName: "trigger",
    triggerEvent: !0,
    immutableKeys: {
      id: !0,
      source: !0,
      target: !0,
      parent: !0
    },
    updateStyle: !0
  }),
  scratch: hr.data({
    field: "scratch",
    bindingEvent: "scratch",
    allowBinding: !0,
    allowSetting: !0,
    settingEvent: "scratch",
    settingTriggersEvent: !0,
    triggerFnName: "trigger",
    allowGetting: !0,
    updateStyle: !0
  }),
  removeScratch: hr.removeData({
    field: "scratch",
    event: "scratch",
    triggerFnName: "trigger",
    triggerEvent: !0,
    updateStyle: !0
  }),
  rscratch: hr.data({
    field: "rscratch",
    allowBinding: !1,
    allowSetting: !0,
    settingTriggersEvent: !1,
    allowGetting: !0
  }),
  removeRscratch: hr.removeData({
    field: "rscratch",
    triggerEvent: !1
  }),
  id: function() {
    var e = this[0];
    if (e)
      return e._private.data.id;
  }
};
f0.attr = f0.data;
f0.removeAttr = f0.removeData;
var C4e = hz, ab = {};
function bw(t) {
  return function(e) {
    var r = this;
    if (e === void 0 && (e = !0), r.length !== 0)
      if (r.isNode() && !r.removed()) {
        for (var n = 0, a = r[0], i = a._private.edges, s = 0; s < i.length; s++) {
          var o = i[s];
          !e && o.isLoop() || (n += t(a, o));
        }
        return n;
      } else
        return;
  };
}
At(ab, {
  degree: bw(function(t, e) {
    return e.source().same(e.target()) ? 2 : 1;
  }),
  indegree: bw(function(t, e) {
    return e.target().same(t) ? 1 : 0;
  }),
  outdegree: bw(function(t, e) {
    return e.source().same(t) ? 1 : 0;
  })
});
function qu(t, e) {
  return function(r) {
    for (var n, a = this.nodes(), i = 0; i < a.length; i++) {
      var s = a[i], o = s[t](r);
      o !== void 0 && (n === void 0 || e(o, n)) && (n = o);
    }
    return n;
  };
}
At(ab, {
  minDegree: qu("degree", function(t, e) {
    return t < e;
  }),
  maxDegree: qu("degree", function(t, e) {
    return t > e;
  }),
  minIndegree: qu("indegree", function(t, e) {
    return t < e;
  }),
  maxIndegree: qu("indegree", function(t, e) {
    return t > e;
  }),
  minOutdegree: qu("outdegree", function(t, e) {
    return t < e;
  }),
  maxOutdegree: qu("outdegree", function(t, e) {
    return t > e;
  })
});
At(ab, {
  totalDegree: function(e) {
    for (var r = 0, n = this.nodes(), a = 0; a < n.length; a++)
      r += n[a].degree(e);
    return r;
  }
});
var Vi, dz, pz = function(e, r, n) {
  for (var a = 0; a < e.length; a++) {
    var i = e[a];
    if (!i.locked()) {
      var s = i._private.position, o = {
        x: r.x != null ? r.x - s.x : 0,
        y: r.y != null ? r.y - s.y : 0
      };
      i.isParent() && !(o.x === 0 && o.y === 0) && i.children().shift(o, n), i.dirtyBoundingBoxCache();
    }
  }
}, B_ = {
  field: "position",
  bindingEvent: "position",
  allowBinding: !0,
  allowSetting: !0,
  settingEvent: "position",
  settingTriggersEvent: !0,
  triggerFnName: "emitAndNotify",
  allowGetting: !0,
  validKeys: ["x", "y"],
  beforeGet: function(e) {
    e.updateCompoundBounds();
  },
  beforeSet: function(e, r) {
    pz(e, r, !1);
  },
  onSet: function(e) {
    e.dirtyCompoundBoundsCache();
  },
  canSet: function(e) {
    return !e.locked();
  }
};
Vi = dz = {
  position: hr.data(B_),
  // position but no notification to renderer
  silentPosition: hr.data(At({}, B_, {
    allowBinding: !1,
    allowSetting: !0,
    settingTriggersEvent: !1,
    allowGetting: !1,
    beforeSet: function(e, r) {
      pz(e, r, !0);
    },
    onSet: function(e) {
      e.dirtyCompoundBoundsCache();
    }
  })),
  positions: function(e, r) {
    if (Qt(e))
      r ? this.silentPosition(e) : this.position(e);
    else if (Wr(e)) {
      var n = e, a = this.cy();
      a.startBatch();
      for (var i = 0; i < this.length; i++) {
        var s = this[i], o = void 0;
        (o = n(s, i)) && (r ? s.silentPosition(o) : s.position(o));
      }
      a.endBatch();
    }
    return this;
  },
  silentPositions: function(e) {
    return this.positions(e, !0);
  },
  shift: function(e, r, n) {
    var a;
    if (Qt(e) ? (a = {
      x: tt(e.x) ? e.x : 0,
      y: tt(e.y) ? e.y : 0
    }, n = r) : xt(e) && tt(r) && (a = {
      x: 0,
      y: 0
    }, a[e] = r), a != null) {
      var i = this.cy();
      i.startBatch();
      for (var s = 0; s < this.length; s++) {
        var o = this[s];
        if (!(i.hasCompoundNodes() && o.isChild() && o.ancestors().anySame(this))) {
          var l = o.position(), u = {
            x: l.x + a.x,
            y: l.y + a.y
          };
          n ? o.silentPosition(u) : o.position(u);
        }
      }
      i.endBatch();
    }
    return this;
  },
  silentShift: function(e, r) {
    return Qt(e) ? this.shift(e, !0) : xt(e) && tt(r) && this.shift(e, r, !0), this;
  },
  // get/set the rendered (i.e. on screen) positon of the element
  renderedPosition: function(e, r) {
    var n = this[0], a = this.cy(), i = a.zoom(), s = a.pan(), o = Qt(e) ? e : void 0, l = o !== void 0 || r !== void 0 && xt(e);
    if (n && n.isNode())
      if (l)
        for (var u = 0; u < this.length; u++) {
          var c = this[u];
          r !== void 0 ? c.position(e, (r - s[e]) / i) : o !== void 0 && c.position(UB(o, i, s));
        }
      else {
        var f = n.position();
        return o = Q1(f, i, s), e === void 0 ? o : o[e];
      }
    else if (!l)
      return;
    return this;
  },
  // get/set the position relative to the parent
  relativePosition: function(e, r) {
    var n = this[0], a = this.cy(), i = Qt(e) ? e : void 0, s = i !== void 0 || r !== void 0 && xt(e), o = a.hasCompoundNodes();
    if (n && n.isNode())
      if (s)
        for (var l = 0; l < this.length; l++) {
          var u = this[l], c = o ? u.parent() : null, f = c && c.length > 0, h = f;
          f && (c = c[0]);
          var d = h ? c.position() : {
            x: 0,
            y: 0
          };
          r !== void 0 ? u.position(e, r + d[e]) : i !== void 0 && u.position({
            x: i.x + d.x,
            y: i.y + d.y
          });
        }
      else {
        var p = n.position(), g = o ? n.parent() : null, v = g && g.length > 0, m = v;
        v && (g = g[0]);
        var b = m ? g.position() : {
          x: 0,
          y: 0
        };
        return i = {
          x: p.x - b.x,
          y: p.y - b.y
        }, e === void 0 ? i : i[e];
      }
    else if (!s)
      return;
    return this;
  }
};
Vi.modelPosition = Vi.point = Vi.position;
Vi.modelPositions = Vi.points = Vi.positions;
Vi.renderedPoint = Vi.renderedPosition;
Vi.relativePoint = Vi.relativePosition;
var A4e = dz, Sc, pl;
Sc = pl = {};
pl.renderedBoundingBox = function(t) {
  var e = this.boundingBox(t), r = this.cy(), n = r.zoom(), a = r.pan(), i = e.x1 * n + a.x, s = e.x2 * n + a.x, o = e.y1 * n + a.y, l = e.y2 * n + a.y;
  return {
    x1: i,
    x2: s,
    y1: o,
    y2: l,
    w: s - i,
    h: l - o
  };
};
pl.dirtyCompoundBoundsCache = function() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, e = this.cy();
  return !e.styleEnabled() || !e.hasCompoundNodes() ? this : (this.forEachUp(function(r) {
    if (r.isParent()) {
      var n = r._private;
      n.compoundBoundsClean = !1, n.bbCache = null, t || r.emitAndNotify("bounds");
    }
  }), this);
};
pl.updateCompoundBounds = function() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, e = this.cy();
  if (!e.styleEnabled() || !e.hasCompoundNodes())
    return this;
  if (!t && e.batching())
    return this;
  function r(s) {
    if (!s.isParent())
      return;
    var o = s._private, l = s.children(), u = s.pstyle("compound-sizing-wrt-labels").value === "include", c = {
      width: {
        val: s.pstyle("min-width").pfValue,
        left: s.pstyle("min-width-bias-left"),
        right: s.pstyle("min-width-bias-right")
      },
      height: {
        val: s.pstyle("min-height").pfValue,
        top: s.pstyle("min-height-bias-top"),
        bottom: s.pstyle("min-height-bias-bottom")
      }
    }, f = l.boundingBox({
      includeLabels: u,
      includeOverlays: !1,
      // updating the compound bounds happens outside of the regular
      // cache cycle (i.e. before fired events)
      useCache: !1
    }), h = o.position;
    (f.w === 0 || f.h === 0) && (f = {
      w: s.pstyle("width").pfValue,
      h: s.pstyle("height").pfValue
    }, f.x1 = h.x - f.w / 2, f.x2 = h.x + f.w / 2, f.y1 = h.y - f.h / 2, f.y2 = h.y + f.h / 2);
    function d(k, N, R) {
      var _ = 0, O = 0, T = N + R;
      return k > 0 && T > 0 && (_ = N / T * k, O = R / T * k), {
        biasDiff: _,
        biasComplementDiff: O
      };
    }
    function p(k, N, R, _) {
      if (R.units === "%")
        switch (_) {
          case "width":
            return k > 0 ? R.pfValue * k : 0;
          case "height":
            return N > 0 ? R.pfValue * N : 0;
          case "average":
            return k > 0 && N > 0 ? R.pfValue * (k + N) / 2 : 0;
          case "min":
            return k > 0 && N > 0 ? k > N ? R.pfValue * N : R.pfValue * k : 0;
          case "max":
            return k > 0 && N > 0 ? k > N ? R.pfValue * k : R.pfValue * N : 0;
          default:
            return 0;
        }
      else return R.units === "px" ? R.pfValue : 0;
    }
    var g = c.width.left.value;
    c.width.left.units === "px" && c.width.val > 0 && (g = g * 100 / c.width.val);
    var v = c.width.right.value;
    c.width.right.units === "px" && c.width.val > 0 && (v = v * 100 / c.width.val);
    var m = c.height.top.value;
    c.height.top.units === "px" && c.height.val > 0 && (m = m * 100 / c.height.val);
    var b = c.height.bottom.value;
    c.height.bottom.units === "px" && c.height.val > 0 && (b = b * 100 / c.height.val);
    var y = d(c.width.val - f.w, g, v), x = y.biasDiff, E = y.biasComplementDiff, S = d(c.height.val - f.h, m, b), w = S.biasDiff, C = S.biasComplementDiff;
    o.autoPadding = p(f.w, f.h, s.pstyle("padding"), s.pstyle("padding-relative-to").value), o.autoWidth = Math.max(f.w, c.width.val), h.x = (-x + f.x1 + f.x2 + E) / 2, o.autoHeight = Math.max(f.h, c.height.val), h.y = (-w + f.y1 + f.y2 + C) / 2;
  }
  for (var n = 0; n < this.length; n++) {
    var a = this[n], i = a._private;
    (!i.compoundBoundsClean || t) && (r(a), e.batching() || (i.compoundBoundsClean = !0));
  }
  return this;
};
var hi = function(e) {
  return e === 1 / 0 || e === -1 / 0 ? 0 : e;
}, Ni = function(e, r, n, a, i) {
  a - r === 0 || i - n === 0 || r == null || n == null || a == null || i == null || (e.x1 = r < e.x1 ? r : e.x1, e.x2 = a > e.x2 ? a : e.x2, e.y1 = n < e.y1 ? n : e.y1, e.y2 = i > e.y2 ? i : e.y2, e.w = e.x2 - e.x1, e.h = e.y2 - e.y1);
}, Mo = function(e, r) {
  return r == null ? e : Ni(e, r.x1, r.y1, r.x2, r.y2);
}, fh = function(e, r, n) {
  return Ta(e, r, n);
}, pg = function(e, r, n) {
  if (!r.cy().headless()) {
    var a = r._private, i = a.rstyle, s = i.arrowWidth / 2, o = r.pstyle(n + "-arrow-shape").value, l, u;
    if (o !== "none") {
      n === "source" ? (l = i.srcX, u = i.srcY) : n === "target" ? (l = i.tgtX, u = i.tgtY) : (l = i.midX, u = i.midY);
      var c = a.arrowBounds = a.arrowBounds || {}, f = c[n] = c[n] || {};
      f.x1 = l - s, f.y1 = u - s, f.x2 = l + s, f.y2 = u + s, f.w = f.x2 - f.x1, f.h = f.y2 - f.y1, gv(f, 1), Ni(e, f.x1, f.y1, f.x2, f.y2);
    }
  }
}, xw = function(e, r, n) {
  if (!r.cy().headless()) {
    var a;
    n ? a = n + "-" : a = "";
    var i = r._private, s = i.rstyle, o = r.pstyle(a + "label").strValue;
    if (o) {
      var l = r.pstyle("text-halign"), u = r.pstyle("text-valign"), c = fh(s, "labelWidth", n), f = fh(s, "labelHeight", n), h = fh(s, "labelX", n), d = fh(s, "labelY", n), p = r.pstyle(a + "text-margin-x").pfValue, g = r.pstyle(a + "text-margin-y").pfValue, v = r.isEdge(), m = r.pstyle(a + "text-rotation"), b = r.pstyle("text-outline-width").pfValue, y = r.pstyle("text-border-width").pfValue, x = y / 2, E = r.pstyle("text-background-padding").pfValue, S = 2, w = f, C = c, k = C / 2, N = w / 2, R, _, O, T;
      if (v)
        R = h - k, _ = h + k, O = d - N, T = d + N;
      else {
        switch (l.value) {
          case "left":
            R = h - C, _ = h;
            break;
          case "center":
            R = h - k, _ = h + k;
            break;
          case "right":
            R = h, _ = h + C;
            break;
        }
        switch (u.value) {
          case "top":
            O = d - w, T = d;
            break;
          case "center":
            O = d - N, T = d + N;
            break;
          case "bottom":
            O = d, T = d + w;
            break;
        }
      }
      var L = p - Math.max(b, x) - E - S, M = p + Math.max(b, x) + E + S, A = g - Math.max(b, x) - E - S, I = g + Math.max(b, x) + E + S;
      R += L, _ += M, O += A, T += I;
      var D = n || "main", F = i.labelBounds, B = F[D] = F[D] || {};
      B.x1 = R, B.y1 = O, B.x2 = _, B.y2 = T, B.w = _ - R, B.h = T - O, B.leftPad = L, B.rightPad = M, B.topPad = A, B.botPad = I;
      var G = v && m.strValue === "autorotate", H = m.pfValue != null && m.pfValue !== 0;
      if (G || H) {
        var K = G ? fh(i.rstyle, "labelAngle", n) : m.pfValue, j = Math.cos(K), Z = Math.sin(K), te = (R + _) / 2, ne = (O + T) / 2;
        if (!v) {
          switch (l.value) {
            case "left":
              te = _;
              break;
            case "right":
              te = R;
              break;
          }
          switch (u.value) {
            case "top":
              ne = T;
              break;
            case "bottom":
              ne = O;
              break;
          }
        }
        var V = function(Te, me) {
          return Te = Te - te, me = me - ne, {
            x: Te * j - me * Z + te,
            y: Te * Z + me * j + ne
          };
        }, q = V(R, O), X = V(R, T), W = V(_, O), ue = V(_, T);
        R = Math.min(q.x, X.x, W.x, ue.x), _ = Math.max(q.x, X.x, W.x, ue.x), O = Math.min(q.y, X.y, W.y, ue.y), T = Math.max(q.y, X.y, W.y, ue.y);
      }
      var J = D + "Rot", Ce = F[J] = F[J] || {};
      Ce.x1 = R, Ce.y1 = O, Ce.x2 = _, Ce.y2 = T, Ce.w = _ - R, Ce.h = T - O, Ni(e, R, O, _, T), Ni(i.labelBounds.all, R, O, _, T);
    }
    return e;
  }
}, z_ = function(e, r) {
  if (!r.cy().headless()) {
    var n = r.pstyle("outline-opacity").value, a = r.pstyle("outline-width").value, i = r.pstyle("outline-offset").value, s = a + i;
    gz(e, r, n, s, "outside", s / 2);
  }
}, gz = function(e, r, n, a, i, s) {
  if (!(n === 0 || a <= 0 || i === "inside")) {
    var o = r.cy(), l = r.pstyle("shape").value, u = o.renderer().nodeShapes[l], c = r.position(), f = c.x, h = c.y, d = r.width(), p = r.height();
    if (u.hasMiterBounds) {
      i === "center" && (a /= 2);
      var g = u.miterBounds(f, h, d, p, a);
      Mo(e, g);
    } else s != null && s > 0 && vv(e, [s, s, s, s]);
  }
}, k4e = function(e, r) {
  if (!r.cy().headless()) {
    var n = r.pstyle("border-opacity").value, a = r.pstyle("border-width").pfValue, i = r.pstyle("border-position").value;
    gz(e, r, n, a, i);
  }
}, R4e = function(e, r) {
  var n = e._private.cy, a = n.styleEnabled(), i = n.headless(), s = da(), o = e._private, l = e.isNode(), u = e.isEdge(), c, f, h, d, p, g, v = o.rstyle, m = l && a ? e.pstyle("bounds-expansion").pfValue : [0], b = function(Ee) {
    return Ee.pstyle("display").value !== "none";
  }, y = !a || b(e) && (!u || b(e.source()) && b(e.target()));
  if (y) {
    var x = 0, E = 0;
    a && r.includeOverlays && (x = e.pstyle("overlay-opacity").value, x !== 0 && (E = e.pstyle("overlay-padding").value));
    var S = 0, w = 0;
    a && r.includeUnderlays && (S = e.pstyle("underlay-opacity").value, S !== 0 && (w = e.pstyle("underlay-padding").value));
    var C = Math.max(E, w), k = 0, N = 0;
    if (a && (k = e.pstyle("width").pfValue, N = k / 2), l && r.includeNodes) {
      var R = e.position();
      p = R.x, g = R.y;
      var _ = e.outerWidth(), O = _ / 2, T = e.outerHeight(), L = T / 2;
      c = p - O, f = p + O, h = g - L, d = g + L, Ni(s, c, h, f, d), a && z_(s, e), a && r.includeOutlines && !i && z_(s, e), a && k4e(s, e);
    } else if (u && r.includeEdges)
      if (a && !i) {
        var M = e.pstyle("curve-style").strValue;
        if (c = Math.min(v.srcX, v.midX, v.tgtX), f = Math.max(v.srcX, v.midX, v.tgtX), h = Math.min(v.srcY, v.midY, v.tgtY), d = Math.max(v.srcY, v.midY, v.tgtY), c -= N, f += N, h -= N, d += N, Ni(s, c, h, f, d), M === "haystack") {
          var A = v.haystackPts;
          if (A && A.length === 2) {
            if (c = A[0].x, h = A[0].y, f = A[1].x, d = A[1].y, c > f) {
              var I = c;
              c = f, f = I;
            }
            if (h > d) {
              var D = h;
              h = d, d = D;
            }
            Ni(s, c - N, h - N, f + N, d + N);
          }
        } else if (M === "bezier" || M === "unbundled-bezier" || Po(M, "segments") || Po(M, "taxi")) {
          var F;
          switch (M) {
            case "bezier":
            case "unbundled-bezier":
              F = v.bezierPts;
              break;
            case "segments":
            case "taxi":
            case "round-segments":
            case "round-taxi":
              F = v.linePts;
              break;
          }
          if (F != null)
            for (var B = 0; B < F.length; B++) {
              var G = F[B];
              c = G.x - N, f = G.x + N, h = G.y - N, d = G.y + N, Ni(s, c, h, f, d);
            }
        }
      } else {
        var H = e.source(), K = H.position(), j = e.target(), Z = j.position();
        if (c = K.x, f = Z.x, h = K.y, d = Z.y, c > f) {
          var te = c;
          c = f, f = te;
        }
        if (h > d) {
          var ne = h;
          h = d, d = ne;
        }
        c -= N, f += N, h -= N, d += N, Ni(s, c, h, f, d);
      }
    if (a && r.includeEdges && u && (pg(s, e, "mid-source"), pg(s, e, "mid-target"), pg(s, e, "source"), pg(s, e, "target")), a) {
      var V = e.pstyle("ghost").value === "yes";
      if (V) {
        var q = e.pstyle("ghost-offset-x").pfValue, X = e.pstyle("ghost-offset-y").pfValue;
        Ni(s, s.x1 + q, s.y1 + X, s.x2 + q, s.y2 + X);
      }
    }
    var W = o.bodyBounds = o.bodyBounds || {};
    CM(W, s), vv(W, m), gv(W, 1), a && (c = s.x1, f = s.x2, h = s.y1, d = s.y2, Ni(s, c - C, h - C, f + C, d + C));
    var ue = o.overlayBounds = o.overlayBounds || {};
    CM(ue, s), vv(ue, m), gv(ue, 1);
    var J = o.labelBounds = o.labelBounds || {};
    J.all != null ? uEe(J.all) : J.all = da(), a && r.includeLabels && (r.includeMainLabels && xw(s, e, null), u && (r.includeSourceLabels && xw(s, e, "source"), r.includeTargetLabels && xw(s, e, "target")));
  }
  return s.x1 = hi(s.x1), s.y1 = hi(s.y1), s.x2 = hi(s.x2), s.y2 = hi(s.y2), s.w = hi(s.x2 - s.x1), s.h = hi(s.y2 - s.y1), s.w > 0 && s.h > 0 && y && (vv(s, m), gv(s, 1)), s;
}, vz = function(e) {
  var r = 0, n = function(s) {
    return (s ? 1 : 0) << r++;
  }, a = 0;
  return a += n(e.incudeNodes), a += n(e.includeEdges), a += n(e.includeLabels), a += n(e.includeMainLabels), a += n(e.includeSourceLabels), a += n(e.includeTargetLabels), a += n(e.includeOverlays), a += n(e.includeOutlines), a;
}, mz = function(e) {
  var r = function(o) {
    return Math.round(o);
  };
  if (e.isEdge()) {
    var n = e.source().position(), a = e.target().position();
    return bM([r(n.x), r(n.y), r(a.x), r(a.y)]);
  } else {
    var i = e.position();
    return bM([r(i.x), r(i.y)]);
  }
}, G_ = function(e, r) {
  var n = e._private, a, i = e.isEdge(), s = r == null ? U_ : vz(r), o = s === U_;
  if (n.bbCache == null ? (a = R4e(e, h0), n.bbCache = a, n.bbCachePosKey = mz(e)) : a = n.bbCache, !o) {
    var l = e.isNode();
    a = da(), (r.includeNodes && l || r.includeEdges && !l) && (r.includeOverlays ? Mo(a, n.overlayBounds) : Mo(a, n.bodyBounds)), r.includeLabels && (r.includeMainLabels && (!i || r.includeSourceLabels && r.includeTargetLabels) ? Mo(a, n.labelBounds.all) : (r.includeMainLabels && Mo(a, n.labelBounds.mainRot), r.includeSourceLabels && Mo(a, n.labelBounds.sourceRot), r.includeTargetLabels && Mo(a, n.labelBounds.targetRot))), a.w = a.x2 - a.x1, a.h = a.y2 - a.y1;
  }
  return a;
}, h0 = {
  includeNodes: !0,
  includeEdges: !0,
  includeLabels: !0,
  includeMainLabels: !0,
  includeSourceLabels: !0,
  includeTargetLabels: !0,
  includeOverlays: !0,
  includeUnderlays: !0,
  includeOutlines: !0,
  useCache: !0
}, U_ = vz(h0), H_ = Hn(h0);
pl.boundingBox = function(t) {
  var e, r = t === void 0 || t.useCache === void 0 || t.useCache === !0, n = cf(function(c) {
    var f = c._private;
    return f.bbCache == null || f.styleDirty || f.bbCachePosKey !== mz(c);
  }, function(c) {
    return c.id();
  });
  if (r && this.length === 1 && !n(this[0]))
    t === void 0 ? t = h0 : t = H_(t), e = G_(this[0], t);
  else {
    e = da(), t = t || h0;
    var a = H_(t), i = this, s = i.cy(), o = s.styleEnabled();
    this.edges().forEach(n), this.nodes().forEach(n), o && this.recalculateRenderedStyle(r), this.updateCompoundBounds(!r);
    for (var l = 0; l < i.length; l++) {
      var u = i[l];
      n(u) && u.dirtyBoundingBoxCache(), Mo(e, G_(u, a));
    }
  }
  return e.x1 = hi(e.x1), e.y1 = hi(e.y1), e.x2 = hi(e.x2), e.y2 = hi(e.y2), e.w = hi(e.x2 - e.x1), e.h = hi(e.y2 - e.y1), e;
};
pl.dirtyBoundingBoxCache = function() {
  for (var t = 0; t < this.length; t++) {
    var e = this[t]._private;
    e.bbCache = null, e.bbCachePosKey = null, e.bodyBounds = null, e.overlayBounds = null, e.labelBounds.all = null, e.labelBounds.source = null, e.labelBounds.target = null, e.labelBounds.main = null, e.labelBounds.sourceRot = null, e.labelBounds.targetRot = null, e.labelBounds.mainRot = null, e.arrowBounds.source = null, e.arrowBounds.target = null, e.arrowBounds["mid-source"] = null, e.arrowBounds["mid-target"] = null;
  }
  return this.emitAndNotify("bounds"), this;
};
pl.boundingBoxAt = function(t) {
  var e = this.nodes(), r = this.cy(), n = r.hasCompoundNodes(), a = r.collection();
  if (n && (a = e.filter(function(u) {
    return u.isParent();
  }), e = e.not(a)), Qt(t)) {
    var i = t;
    t = function() {
      return i;
    };
  }
  var s = function(c, f) {
    return c._private.bbAtOldPos = t(c, f);
  }, o = function(c) {
    return c._private.bbAtOldPos;
  };
  r.startBatch(), e.forEach(s).silentPositions(t), n && (a.dirtyCompoundBoundsCache(), a.dirtyBoundingBoxCache(), a.updateCompoundBounds(!0));
  var l = lEe(this.boundingBox({
    useCache: !1
  }));
  return e.silentPositions(o), n && (a.dirtyCompoundBoundsCache(), a.dirtyBoundingBoxCache(), a.updateCompoundBounds(!0)), r.endBatch(), l;
};
Sc.boundingbox = Sc.bb = Sc.boundingBox;
Sc.renderedBoundingbox = Sc.renderedBoundingBox;
var M4e = pl, Lh, pp;
Lh = pp = {};
var yz = function(e) {
  e.uppercaseName = aM(e.name), e.autoName = "auto" + e.uppercaseName, e.labelName = "label" + e.uppercaseName, e.outerName = "outer" + e.uppercaseName, e.uppercaseOuterName = aM(e.outerName), Lh[e.name] = function() {
    var n = this[0], a = n._private, i = a.cy, s = i._private.styleEnabled;
    if (n)
      if (s) {
        if (n.isParent())
          return n.updateCompoundBounds(), a[e.autoName] || 0;
        var o = n.pstyle(e.name);
        switch (o.strValue) {
          case "label":
            return n.recalculateRenderedStyle(), a.rstyle[e.labelName] || 0;
          default:
            return o.pfValue;
        }
      } else
        return 1;
  }, Lh["outer" + e.uppercaseName] = function() {
    var n = this[0], a = n._private, i = a.cy, s = i._private.styleEnabled;
    if (n)
      if (s) {
        var o = n[e.name](), l = n.pstyle("border-position").value, u;
        l === "center" ? u = n.pstyle("border-width").pfValue : l === "outside" ? u = 2 * n.pstyle("border-width").pfValue : u = 0;
        var c = 2 * n.padding();
        return o + u + c;
      } else
        return 1;
  }, Lh["rendered" + e.uppercaseName] = function() {
    var n = this[0];
    if (n) {
      var a = n[e.name]();
      return a * this.cy().zoom();
    }
  }, Lh["rendered" + e.uppercaseOuterName] = function() {
    var n = this[0];
    if (n) {
      var a = n[e.outerName]();
      return a * this.cy().zoom();
    }
  };
};
yz({
  name: "width"
});
yz({
  name: "height"
});
pp.padding = function() {
  var t = this[0], e = t._private;
  return t.isParent() ? (t.updateCompoundBounds(), e.autoPadding !== void 0 ? e.autoPadding : t.pstyle("padding").pfValue) : t.pstyle("padding").pfValue;
};
pp.paddedHeight = function() {
  var t = this[0];
  return t.height() + 2 * t.padding();
};
pp.paddedWidth = function() {
  var t = this[0];
  return t.width() + 2 * t.padding();
};
var _4e = pp, L4e = function(e, r) {
  if (e.isEdge() && e.takesUpSpace())
    return r(e);
}, N4e = function(e, r) {
  if (e.isEdge() && e.takesUpSpace()) {
    var n = e.cy();
    return Q1(r(e), n.zoom(), n.pan());
  }
}, O4e = function(e, r) {
  if (e.isEdge() && e.takesUpSpace()) {
    var n = e.cy(), a = n.pan(), i = n.zoom();
    return r(e).map(function(s) {
      return Q1(s, i, a);
    });
  }
}, I4e = function(e) {
  return e.renderer().getControlPoints(e);
}, P4e = function(e) {
  return e.renderer().getSegmentPoints(e);
}, D4e = function(e) {
  return e.renderer().getSourceEndpoint(e);
}, $4e = function(e) {
  return e.renderer().getTargetEndpoint(e);
}, F4e = function(e) {
  return e.renderer().getEdgeMidpoint(e);
}, V_ = {
  controlPoints: {
    get: I4e,
    mult: !0
  },
  segmentPoints: {
    get: P4e,
    mult: !0
  },
  sourceEndpoint: {
    get: D4e
  },
  targetEndpoint: {
    get: $4e
  },
  midpoint: {
    get: F4e
  }
}, B4e = function(e) {
  return "rendered" + e[0].toUpperCase() + e.substr(1);
}, z4e = Object.keys(V_).reduce(function(t, e) {
  var r = V_[e], n = B4e(e);
  return t[e] = function() {
    return L4e(this, r.get);
  }, r.mult ? t[n] = function() {
    return O4e(this, r.get);
  } : t[n] = function() {
    return N4e(this, r.get);
  }, t;
}, {}), G4e = At({}, A4e, M4e, _4e, z4e);
/*!
Event object based on jQuery events, MIT license

https://jquery.org/license/
https://tldrlegal.com/license/mit-license
https://github.com/jquery/jquery/blob/master/src/event.js
*/
var bz = function(e, r) {
  this.recycle(e, r);
};
function hh() {
  return !1;
}
function gg() {
  return !0;
}
bz.prototype = {
  instanceString: function() {
    return "event";
  },
  recycle: function(e, r) {
    if (this.isImmediatePropagationStopped = this.isPropagationStopped = this.isDefaultPrevented = hh, e != null && e.preventDefault ? (this.type = e.type, this.isDefaultPrevented = e.defaultPrevented ? gg : hh) : e != null && e.type ? r = e : this.type = e, r != null && (this.originalEvent = r.originalEvent, this.type = r.type != null ? r.type : this.type, this.cy = r.cy, this.target = r.target, this.position = r.position, this.renderedPosition = r.renderedPosition, this.namespace = r.namespace, this.layout = r.layout), this.cy != null && this.position != null && this.renderedPosition == null) {
      var n = this.position, a = this.cy.zoom(), i = this.cy.pan();
      this.renderedPosition = {
        x: n.x * a + i.x,
        y: n.y * a + i.y
      };
    }
    this.timeStamp = e && e.timeStamp || Date.now();
  },
  preventDefault: function() {
    this.isDefaultPrevented = gg;
    var e = this.originalEvent;
    e && e.preventDefault && e.preventDefault();
  },
  stopPropagation: function() {
    this.isPropagationStopped = gg;
    var e = this.originalEvent;
    e && e.stopPropagation && e.stopPropagation();
  },
  stopImmediatePropagation: function() {
    this.isImmediatePropagationStopped = gg, this.stopPropagation();
  },
  isDefaultPrevented: hh,
  isPropagationStopped: hh,
  isImmediatePropagationStopped: hh
};
var xz = /^([^.]+)(\.(?:[^.]+))?$/, U4e = ".*", wz = {
  qualifierCompare: function(e, r) {
    return e === r;
  },
  eventMatches: function() {
    return !0;
  },
  addEventFields: function() {
  },
  callbackContext: function(e) {
    return e;
  },
  beforeEmit: function() {
  },
  afterEmit: function() {
  },
  bubble: function() {
    return !1;
  },
  parent: function() {
    return null;
  },
  context: null
}, q_ = Object.keys(wz), H4e = {};
function ib() {
  for (var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : H4e, e = arguments.length > 1 ? arguments[1] : void 0, r = 0; r < q_.length; r++) {
    var n = q_[r];
    this[n] = t[n] || wz[n];
  }
  this.context = e || this.context, this.listeners = [], this.emitting = 0;
}
var Qo = ib.prototype, Ez = function(e, r, n, a, i, s, o) {
  Wr(a) && (i = a, a = null), o && (s == null ? s = o : s = At({}, s, o));
  for (var l = Sr(n) ? n : n.split(/\s+/), u = 0; u < l.length; u++) {
    var c = l[u];
    if (!jo(c)) {
      var f = c.match(xz);
      if (f) {
        var h = f[1], d = f[2] ? f[2] : null, p = r(e, c, h, d, a, i, s);
        if (p === !1)
          break;
      }
    }
  }
}, W_ = function(e, r) {
  return e.addEventFields(e.context, r), new bz(r.type, r);
}, V4e = function(e, r, n) {
  if (K2e(n)) {
    r(e, n);
    return;
  } else if (Qt(n)) {
    r(e, W_(e, n));
    return;
  }
  for (var a = Sr(n) ? n : n.split(/\s+/), i = 0; i < a.length; i++) {
    var s = a[i];
    if (!jo(s)) {
      var o = s.match(xz);
      if (o) {
        var l = o[1], u = o[2] ? o[2] : null, c = W_(e, {
          type: l,
          namespace: u,
          target: e.context
        });
        r(e, c);
      }
    }
  }
};
Qo.on = Qo.addListener = function(t, e, r, n, a) {
  return Ez(this, function(i, s, o, l, u, c, f) {
    Wr(c) && i.listeners.push({
      event: s,
      // full event string
      callback: c,
      // callback to run
      type: o,
      // the event type (e.g. 'click')
      namespace: l,
      // the event namespace (e.g. ".foo")
      qualifier: u,
      // a restriction on whether to match this emitter
      conf: f
      // additional configuration
    });
  }, t, e, r, n, a), this;
};
Qo.one = function(t, e, r, n) {
  return this.on(t, e, r, n, {
    one: !0
  });
};
Qo.removeListener = Qo.off = function(t, e, r, n) {
  var a = this;
  this.emitting !== 0 && (this.listeners = Nwe(this.listeners));
  for (var i = this.listeners, s = function(u) {
    var c = i[u];
    Ez(a, function(f, h, d, p, g, v) {
      if ((c.type === d || t === "*") && (!p && c.namespace !== ".*" || c.namespace === p) && (!g || f.qualifierCompare(c.qualifier, g)) && (!v || c.callback === v))
        return i.splice(u, 1), !1;
    }, t, e, r, n);
  }, o = i.length - 1; o >= 0; o--)
    s(o);
  return this;
};
Qo.removeAllListeners = function() {
  return this.removeListener("*");
};
Qo.emit = Qo.trigger = function(t, e, r) {
  var n = this.listeners, a = n.length;
  return this.emitting++, Sr(e) || (e = [e]), V4e(this, function(i, s) {
    r != null && (n = [{
      event: s.event,
      type: s.type,
      namespace: s.namespace,
      callback: r
    }], a = n.length);
    for (var o = function() {
      var c = n[l];
      if (c.type === s.type && (!c.namespace || c.namespace === s.namespace || c.namespace === U4e) && i.eventMatches(i.context, c, s)) {
        var f = [s];
        e != null && Iwe(f, e), i.beforeEmit(i.context, c, s), c.conf && c.conf.one && (i.listeners = i.listeners.filter(function(p) {
          return p !== c;
        }));
        var h = i.callbackContext(i.context, c, s), d = c.callback.apply(h, f);
        i.afterEmit(i.context, c, s), d === !1 && (s.stopPropagation(), s.preventDefault());
      }
    }, l = 0; l < a; l++)
      o();
    i.bubble(i.context) && !s.isPropagationStopped() && i.parent(i.context).emit(s, e);
  }, t), this.emitting--, this;
};
var q4e = {
  qualifierCompare: function(e, r) {
    return e == null || r == null ? e == null && r == null : e.sameText(r);
  },
  eventMatches: function(e, r, n) {
    var a = r.qualifier;
    return a != null ? e !== n.target && lp(n.target) && a.matches(n.target) : !0;
  },
  addEventFields: function(e, r) {
    r.cy = e.cy(), r.target = e;
  },
  callbackContext: function(e, r, n) {
    return r.qualifier != null ? n.target : e;
  },
  beforeEmit: function(e, r) {
    r.conf && r.conf.once && r.conf.onceCollection.removeListener(r.event, r.qualifier, r.callback);
  },
  bubble: function() {
    return !0;
  },
  parent: function(e) {
    return e.isChild() ? e.parent() : e.cy();
  }
}, vg = function(e) {
  return xt(e) ? new Ko(e) : e;
}, Tz = {
  createEmitter: function() {
    for (var e = 0; e < this.length; e++) {
      var r = this[e], n = r._private;
      n.emitter || (n.emitter = new ib(q4e, r));
    }
    return this;
  },
  emitter: function() {
    return this._private.emitter;
  },
  on: function(e, r, n) {
    for (var a = vg(r), i = 0; i < this.length; i++) {
      var s = this[i];
      s.emitter().on(e, a, n);
    }
    return this;
  },
  removeListener: function(e, r, n) {
    for (var a = vg(r), i = 0; i < this.length; i++) {
      var s = this[i];
      s.emitter().removeListener(e, a, n);
    }
    return this;
  },
  removeAllListeners: function() {
    for (var e = 0; e < this.length; e++) {
      var r = this[e];
      r.emitter().removeAllListeners();
    }
    return this;
  },
  one: function(e, r, n) {
    for (var a = vg(r), i = 0; i < this.length; i++) {
      var s = this[i];
      s.emitter().one(e, a, n);
    }
    return this;
  },
  once: function(e, r, n) {
    for (var a = vg(r), i = 0; i < this.length; i++) {
      var s = this[i];
      s.emitter().on(e, a, n, {
        once: !0,
        onceCollection: this
      });
    }
  },
  emit: function(e, r) {
    for (var n = 0; n < this.length; n++) {
      var a = this[n];
      a.emitter().emit(e, r);
    }
    return this;
  },
  emitAndNotify: function(e, r) {
    if (this.length !== 0)
      return this.cy().notify(e, this), this.emit(e, r), this;
  }
};
hr.eventAliasesOn(Tz);
var Sz = {
  nodes: function(e) {
    return this.filter(function(r) {
      return r.isNode();
    }).filter(e);
  },
  edges: function(e) {
    return this.filter(function(r) {
      return r.isEdge();
    }).filter(e);
  },
  // internal helper to get nodes and edges as separate collections with single iteration over elements
  byGroup: function() {
    for (var e = this.spawn(), r = this.spawn(), n = 0; n < this.length; n++) {
      var a = this[n];
      a.isNode() ? e.push(a) : r.push(a);
    }
    return {
      nodes: e,
      edges: r
    };
  },
  filter: function(e, r) {
    if (e === void 0)
      return this;
    if (xt(e) || ri(e))
      return new Ko(e).filter(this);
    if (Wr(e)) {
      for (var n = this.spawn(), a = this, i = 0; i < a.length; i++) {
        var s = a[i], o = r ? e.apply(r, [s, i, a]) : e(s, i, a);
        o && n.push(s);
      }
      return n;
    }
    return this.spawn();
  },
  not: function(e) {
    if (e) {
      xt(e) && (e = this.filter(e));
      for (var r = this.spawn(), n = 0; n < this.length; n++) {
        var a = this[n], i = e.has(a);
        i || r.push(a);
      }
      return r;
    } else
      return this;
  },
  absoluteComplement: function() {
    var e = this.cy();
    return e.mutableElements().not(this);
  },
  intersect: function(e) {
    if (xt(e)) {
      var r = e;
      return this.filter(r);
    }
    for (var n = this.spawn(), a = this, i = e, s = this.length < e.length, o = s ? a : i, l = s ? i : a, u = 0; u < o.length; u++) {
      var c = o[u];
      l.has(c) && n.push(c);
    }
    return n;
  },
  xor: function(e) {
    var r = this._private.cy;
    xt(e) && (e = r.$(e));
    var n = this.spawn(), a = this, i = e, s = function(l, u) {
      for (var c = 0; c < l.length; c++) {
        var f = l[c], h = f._private.data.id, d = u.hasElementWithId(h);
        d || n.push(f);
      }
    };
    return s(a, i), s(i, a), n;
  },
  diff: function(e) {
    var r = this._private.cy;
    xt(e) && (e = r.$(e));
    var n = this.spawn(), a = this.spawn(), i = this.spawn(), s = this, o = e, l = function(c, f, h) {
      for (var d = 0; d < c.length; d++) {
        var p = c[d], g = p._private.data.id, v = f.hasElementWithId(g);
        v ? i.merge(p) : h.push(p);
      }
    };
    return l(s, o, n), l(o, s, a), {
      left: n,
      right: a,
      both: i
    };
  },
  add: function(e) {
    var r = this._private.cy;
    if (!e)
      return this;
    if (xt(e)) {
      var n = e;
      e = r.mutableElements().filter(n);
    }
    for (var a = this.spawnSelf(), i = 0; i < e.length; i++) {
      var s = e[i], o = !this.has(s);
      o && a.push(s);
    }
    return a;
  },
  // in place merge on calling collection
  merge: function(e) {
    var r = this._private, n = r.cy;
    if (!e)
      return this;
    if (e && xt(e)) {
      var a = e;
      e = n.mutableElements().filter(a);
    }
    for (var i = r.map, s = 0; s < e.length; s++) {
      var o = e[s], l = o._private.data.id, u = !i.has(l);
      if (u) {
        var c = this.length++;
        this[c] = o, i.set(l, {
          ele: o,
          index: c
        });
      }
    }
    return this;
  },
  unmergeAt: function(e) {
    var r = this[e], n = r.id(), a = this._private, i = a.map;
    this[e] = void 0, i.delete(n);
    var s = e === this.length - 1;
    if (this.length > 1 && !s) {
      var o = this.length - 1, l = this[o], u = l._private.data.id;
      this[o] = void 0, this[e] = l, i.set(u, {
        ele: l,
        index: e
      });
    }
    return this.length--, this;
  },
  // remove single ele in place in calling collection
  unmergeOne: function(e) {
    e = e[0];
    var r = this._private, n = e._private.data.id, a = r.map, i = a.get(n);
    if (!i)
      return this;
    var s = i.index;
    return this.unmergeAt(s), this;
  },
  // remove eles in place on calling collection
  unmerge: function(e) {
    var r = this._private.cy;
    if (!e)
      return this;
    if (e && xt(e)) {
      var n = e;
      e = r.mutableElements().filter(n);
    }
    for (var a = 0; a < e.length; a++)
      this.unmergeOne(e[a]);
    return this;
  },
  unmergeBy: function(e) {
    for (var r = this.length - 1; r >= 0; r--) {
      var n = this[r];
      e(n) && this.unmergeAt(r);
    }
    return this;
  },
  map: function(e, r) {
    for (var n = [], a = this, i = 0; i < a.length; i++) {
      var s = a[i], o = r ? e.apply(r, [s, i, a]) : e(s, i, a);
      n.push(o);
    }
    return n;
  },
  reduce: function(e, r) {
    for (var n = r, a = this, i = 0; i < a.length; i++)
      n = e(n, a[i], i, a);
    return n;
  },
  max: function(e, r) {
    for (var n = -1 / 0, a, i = this, s = 0; s < i.length; s++) {
      var o = i[s], l = r ? e.apply(r, [o, s, i]) : e(o, s, i);
      l > n && (n = l, a = o);
    }
    return {
      value: n,
      ele: a
    };
  },
  min: function(e, r) {
    for (var n = 1 / 0, a, i = this, s = 0; s < i.length; s++) {
      var o = i[s], l = r ? e.apply(r, [o, s, i]) : e(o, s, i);
      l < n && (n = l, a = o);
    }
    return {
      value: n,
      ele: a
    };
  }
}, tr = Sz;
tr.u = tr["|"] = tr["+"] = tr.union = tr.or = tr.add;
tr["\\"] = tr["!"] = tr["-"] = tr.difference = tr.relativeComplement = tr.subtract = tr.not;
tr.n = tr["&"] = tr["."] = tr.and = tr.intersection = tr.intersect;
tr["^"] = tr["(+)"] = tr["(-)"] = tr.symmetricDifference = tr.symdiff = tr.xor;
tr.fnFilter = tr.filterFn = tr.stdFilter = tr.filter;
tr.complement = tr.abscomp = tr.absoluteComplement;
var W4e = {
  isNode: function() {
    return this.group() === "nodes";
  },
  isEdge: function() {
    return this.group() === "edges";
  },
  isLoop: function() {
    return this.isEdge() && this.source()[0] === this.target()[0];
  },
  isSimple: function() {
    return this.isEdge() && this.source()[0] !== this.target()[0];
  },
  group: function() {
    var e = this[0];
    if (e)
      return e._private.group;
  }
}, Cz = function(e, r) {
  var n = e.cy(), a = n.hasCompoundNodes();
  function i(c) {
    var f = c.pstyle("z-compound-depth");
    return f.value === "auto" ? a ? c.zDepth() : 0 : f.value === "bottom" ? -1 : f.value === "top" ? i3 : 0;
  }
  var s = i(e) - i(r);
  if (s !== 0)
    return s;
  function o(c) {
    var f = c.pstyle("z-index-compare");
    return f.value === "auto" && c.isNode() ? 1 : 0;
  }
  var l = o(e) - o(r);
  if (l !== 0)
    return l;
  var u = e.pstyle("z-index").value - r.pstyle("z-index").value;
  return u !== 0 ? u : e.poolIndex() - r.poolIndex();
}, Um = {
  forEach: function(e, r) {
    if (Wr(e))
      for (var n = this.length, a = 0; a < n; a++) {
        var i = this[a], s = r ? e.apply(r, [i, a, this]) : e(i, a, this);
        if (s === !1)
          break;
      }
    return this;
  },
  toArray: function() {
    for (var e = [], r = 0; r < this.length; r++)
      e.push(this[r]);
    return e;
  },
  slice: function(e, r) {
    var n = [], a = this.length;
    r == null && (r = a), e == null && (e = 0), e < 0 && (e = a + e), r < 0 && (r = a + r);
    for (var i = e; i >= 0 && i < r && i < a; i++)
      n.push(this[i]);
    return this.spawn(n);
  },
  size: function() {
    return this.length;
  },
  eq: function(e) {
    return this[e] || this.spawn();
  },
  first: function() {
    return this[0] || this.spawn();
  },
  last: function() {
    return this[this.length - 1] || this.spawn();
  },
  empty: function() {
    return this.length === 0;
  },
  nonempty: function() {
    return !this.empty();
  },
  sort: function(e) {
    if (!Wr(e))
      return this;
    var r = this.toArray().sort(e);
    return this.spawn(r);
  },
  sortByZIndex: function() {
    return this.sort(Cz);
  },
  zDepth: function() {
    var e = this[0];
    if (e) {
      var r = e._private, n = r.group;
      if (n === "nodes") {
        var a = r.data.parent ? e.parents().size() : 0;
        return e.isParent() ? a : i3 - 1;
      } else {
        var i = r.source, s = r.target, o = i.zDepth(), l = s.zDepth();
        return Math.max(o, l, 0);
      }
    }
  }
};
Um.each = Um.forEach;
var j4e = function() {
  var e = "undefined", r = (typeof Symbol > "u" ? "undefined" : xn(Symbol)) != e && xn(Symbol.iterator) != e;
  r && (Um[Symbol.iterator] = function() {
    var n = this, a = {
      value: void 0,
      done: !1
    }, i = 0, s = this.length;
    return TB({
      next: function() {
        return i < s ? a.value = n[i++] : (a.value = void 0, a.done = !0), a;
      }
    }, Symbol.iterator, function() {
      return this;
    });
  });
};
j4e();
var Y4e = Hn({
  nodeDimensionsIncludeLabels: !1
}), yv = {
  // Calculates and returns node dimensions { x, y } based on options given
  layoutDimensions: function(e) {
    e = Y4e(e);
    var r;
    if (!this.takesUpSpace())
      r = {
        w: 0,
        h: 0
      };
    else if (e.nodeDimensionsIncludeLabels) {
      var n = this.boundingBox();
      r = {
        w: n.w,
        h: n.h
      };
    } else
      r = {
        w: this.outerWidth(),
        h: this.outerHeight()
      };
    return (r.w === 0 || r.h === 0) && (r.w = r.h = 1), r;
  },
  // using standard layout options, apply position function (w/ or w/o animation)
  layoutPositions: function(e, r, n) {
    var a = this.nodes().filter(function(E) {
      return !E.isParent();
    }), i = this.cy(), s = r.eles, o = function(S) {
      return S.id();
    }, l = cf(n, o);
    e.emit({
      type: "layoutstart",
      layout: e
    }), e.animations = [];
    var u = function(S, w, C) {
      var k = {
        x: w.x1 + w.w / 2,
        y: w.y1 + w.h / 2
      }, N = {
        // scale from center of bounding box (not necessarily 0,0)
        x: (C.x - k.x) * S,
        y: (C.y - k.y) * S
      };
      return {
        x: k.x + N.x,
        y: k.y + N.y
      };
    }, c = r.spacingFactor && r.spacingFactor !== 1, f = function() {
      if (!c)
        return null;
      for (var S = da(), w = 0; w < a.length; w++) {
        var C = a[w], k = l(C, w);
        HB(S, k.x, k.y);
      }
      return S;
    }, h = f(), d = cf(function(E, S) {
      var w = l(E, S);
      if (c) {
        var C = Math.abs(r.spacingFactor);
        w = u(C, h, w);
      }
      return r.transform != null && (w = r.transform(E, w)), w;
    }, o);
    if (r.animate) {
      for (var p = 0; p < a.length; p++) {
        var g = a[p], v = d(g, p), m = r.animateFilter == null || r.animateFilter(g, p);
        if (m) {
          var b = g.animation({
            position: v,
            duration: r.animationDuration,
            easing: r.animationEasing
          });
          e.animations.push(b);
        } else
          g.position(v);
      }
      if (r.fit) {
        var y = i.animation({
          fit: {
            boundingBox: s.boundingBoxAt(d),
            padding: r.padding
          },
          duration: r.animationDuration,
          easing: r.animationEasing
        });
        e.animations.push(y);
      } else if (r.zoom !== void 0 && r.pan !== void 0) {
        var x = i.animation({
          zoom: r.zoom,
          pan: r.pan,
          duration: r.animationDuration,
          easing: r.animationEasing
        });
        e.animations.push(x);
      }
      e.animations.forEach(function(E) {
        return E.play();
      }), e.one("layoutready", r.ready), e.emit({
        type: "layoutready",
        layout: e
      }), _f.all(e.animations.map(function(E) {
        return E.promise();
      })).then(function() {
        e.one("layoutstop", r.stop), e.emit({
          type: "layoutstop",
          layout: e
        });
      });
    } else
      a.positions(d), r.fit && i.fit(r.eles, r.padding), r.zoom != null && i.zoom(r.zoom), r.pan && i.pan(r.pan), e.one("layoutready", r.ready), e.emit({
        type: "layoutready",
        layout: e
      }), e.one("layoutstop", r.stop), e.emit({
        type: "layoutstop",
        layout: e
      });
    return this;
  },
  layout: function(e) {
    var r = this.cy();
    return r.makeLayout(At({}, e, {
      eles: this
    }));
  }
};
yv.createLayout = yv.makeLayout = yv.layout;
function Az(t, e, r) {
  var n = r._private, a = n.styleCache = n.styleCache || [], i;
  return (i = a[t]) != null || (i = a[t] = e(r)), i;
}
function sb(t, e) {
  return t = iu(t), function(n) {
    return Az(t, e, n);
  };
}
function ob(t, e) {
  t = iu(t);
  var r = function(a) {
    return e.call(a);
  };
  return function() {
    var a = this[0];
    if (a)
      return Az(t, r, a);
  };
}
var Bn = {
  recalculateRenderedStyle: function(e) {
    var r = this.cy(), n = r.renderer(), a = r.styleEnabled();
    return n && a && n.recalculateRenderedStyle(this, e), this;
  },
  dirtyStyleCache: function() {
    var e = this.cy(), r = function(i) {
      return i._private.styleCache = null;
    };
    if (e.hasCompoundNodes()) {
      var n;
      n = this.spawnSelf().merge(this.descendants()).merge(this.parents()), n.merge(n.connectedEdges()), n.forEach(r);
    } else
      this.forEach(function(a) {
        r(a), a.connectedEdges().forEach(r);
      });
    return this;
  },
  // fully updates (recalculates) the style for the elements
  updateStyle: function(e) {
    var r = this._private.cy;
    if (!r.styleEnabled())
      return this;
    if (r.batching()) {
      var n = r._private.batchStyleEles;
      return n.merge(this), this;
    }
    var a = r.hasCompoundNodes(), i = this;
    e = !!(e || e === void 0), a && (i = this.spawnSelf().merge(this.descendants()).merge(this.parents()));
    var s = i;
    return e ? s.emitAndNotify("style") : s.emit("style"), i.forEach(function(o) {
      return o._private.styleDirty = !0;
    }), this;
  },
  // private: clears dirty flag and recalculates style
  cleanStyle: function() {
    var e = this.cy();
    if (e.styleEnabled())
      for (var r = 0; r < this.length; r++) {
        var n = this[r];
        n._private.styleDirty && (n._private.styleDirty = !1, e.style().apply(n));
      }
  },
  // get the internal parsed style object for the specified property
  parsedStyle: function(e) {
    var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, n = this[0], a = n.cy();
    if (a.styleEnabled() && n) {
      n._private.styleDirty && (n._private.styleDirty = !1, a.style().apply(n));
      var i = n._private.style[e];
      return i ?? (r ? a.style().getDefaultProperty(e) : null);
    }
  },
  numericStyle: function(e) {
    var r = this[0];
    if (r.cy().styleEnabled() && r) {
      var n = r.pstyle(e);
      return n.pfValue !== void 0 ? n.pfValue : n.value;
    }
  },
  numericStyleUnits: function(e) {
    var r = this[0];
    if (r.cy().styleEnabled() && r)
      return r.pstyle(e).units;
  },
  // get the specified css property as a rendered value (i.e. on-screen value)
  // or get the whole rendered style if no property specified (NB doesn't allow setting)
  renderedStyle: function(e) {
    var r = this.cy();
    if (!r.styleEnabled())
      return this;
    var n = this[0];
    if (n)
      return r.style().getRenderedStyle(n, e);
  },
  // read the calculated css style of the element or override the style (via a bypass)
  style: function(e, r) {
    var n = this.cy();
    if (!n.styleEnabled())
      return this;
    var a = !1, i = n.style();
    if (Qt(e)) {
      var s = e;
      i.applyBypass(this, s, a), this.emitAndNotify("style");
    } else if (xt(e))
      if (r === void 0) {
        var o = this[0];
        return o ? i.getStylePropertyValue(o, e) : void 0;
      } else
        i.applyBypass(this, e, r, a), this.emitAndNotify("style");
    else if (e === void 0) {
      var l = this[0];
      return l ? i.getRawStyle(l) : void 0;
    }
    return this;
  },
  removeStyle: function(e) {
    var r = this.cy();
    if (!r.styleEnabled())
      return this;
    var n = !1, a = r.style(), i = this;
    if (e === void 0)
      for (var s = 0; s < i.length; s++) {
        var o = i[s];
        a.removeAllBypasses(o, n);
      }
    else {
      e = e.split(/\s+/);
      for (var l = 0; l < i.length; l++) {
        var u = i[l];
        a.removeBypasses(u, e, n);
      }
    }
    return this.emitAndNotify("style"), this;
  },
  show: function() {
    return this.css("display", "element"), this;
  },
  hide: function() {
    return this.css("display", "none"), this;
  },
  effectiveOpacity: function() {
    var e = this.cy();
    if (!e.styleEnabled())
      return 1;
    var r = e.hasCompoundNodes(), n = this[0];
    if (n) {
      var a = n._private, i = n.pstyle("opacity").value;
      if (!r)
        return i;
      var s = a.data.parent ? n.parents() : null;
      if (s)
        for (var o = 0; o < s.length; o++) {
          var l = s[o], u = l.pstyle("opacity").value;
          i = u * i;
        }
      return i;
    }
  },
  transparent: function() {
    var e = this.cy();
    if (!e.styleEnabled())
      return !1;
    var r = this[0], n = r.cy().hasCompoundNodes();
    if (r)
      return n ? r.effectiveOpacity() === 0 : r.pstyle("opacity").value === 0;
  },
  backgrounding: function() {
    var e = this.cy();
    if (!e.styleEnabled())
      return !1;
    var r = this[0];
    return !!r._private.backgrounding;
  }
};
function ww(t, e) {
  var r = t._private, n = r.data.parent ? t.parents() : null;
  if (n)
    for (var a = 0; a < n.length; a++) {
      var i = n[a];
      if (!e(i))
        return !1;
    }
  return !0;
}
function m3(t) {
  var e = t.ok, r = t.edgeOkViaNode || t.ok, n = t.parentOk || t.ok;
  return function() {
    var a = this.cy();
    if (!a.styleEnabled())
      return !0;
    var i = this[0], s = a.hasCompoundNodes();
    if (i) {
      var o = i._private;
      if (!e(i))
        return !1;
      if (i.isNode())
        return !s || ww(i, n);
      var l = o.source, u = o.target;
      return r(l) && (!s || ww(l, r)) && (l === u || r(u) && (!s || ww(u, r)));
    }
  };
}
var Lf = sb("eleTakesUpSpace", function(t) {
  return t.pstyle("display").value === "element" && t.width() !== 0 && (t.isNode() ? t.height() !== 0 : !0);
});
Bn.takesUpSpace = ob("takesUpSpace", m3({
  ok: Lf
}));
var X4e = sb("eleInteractive", function(t) {
  return t.pstyle("events").value === "yes" && t.pstyle("visibility").value === "visible" && Lf(t);
}), K4e = sb("parentInteractive", function(t) {
  return t.pstyle("visibility").value === "visible" && Lf(t);
});
Bn.interactive = ob("interactive", m3({
  ok: X4e,
  parentOk: K4e,
  edgeOkViaNode: Lf
}));
Bn.noninteractive = function() {
  var t = this[0];
  if (t)
    return !t.interactive();
};
var Z4e = sb("eleVisible", function(t) {
  return t.pstyle("visibility").value === "visible" && t.pstyle("opacity").pfValue !== 0 && Lf(t);
}), Q4e = Lf;
Bn.visible = ob("visible", m3({
  ok: Z4e,
  edgeOkViaNode: Q4e
}));
Bn.hidden = function() {
  var t = this[0];
  if (t)
    return !t.visible();
};
Bn.isBundledBezier = ob("isBundledBezier", function() {
  return this.cy().styleEnabled() ? !this.removed() && this.pstyle("curve-style").value === "bezier" && this.takesUpSpace() : !1;
});
Bn.bypass = Bn.css = Bn.style;
Bn.renderedCss = Bn.renderedStyle;
Bn.removeBypass = Bn.removeCss = Bn.removeStyle;
Bn.pstyle = Bn.parsedStyle;
var Bo = {};
function j_(t) {
  return function() {
    var e = arguments, r = [];
    if (e.length === 2) {
      var n = e[0], a = e[1];
      this.on(t.event, n, a);
    } else if (e.length === 1 && Wr(e[0])) {
      var i = e[0];
      this.on(t.event, i);
    } else if (e.length === 0 || e.length === 1 && Sr(e[0])) {
      for (var s = e.length === 1 ? e[0] : null, o = 0; o < this.length; o++) {
        var l = this[o], u = !t.ableField || l._private[t.ableField], c = l._private[t.field] != t.value;
        if (t.overrideAble) {
          var f = t.overrideAble(l);
          if (f !== void 0 && (u = f, !f))
            return this;
        }
        u && (l._private[t.field] = t.value, c && r.push(l));
      }
      var h = this.spawn(r);
      h.updateStyle(), h.emit(t.event), s && h.emit(s);
    }
    return this;
  };
}
function Nf(t) {
  Bo[t.field] = function() {
    var e = this[0];
    if (e) {
      if (t.overrideField) {
        var r = t.overrideField(e);
        if (r !== void 0)
          return r;
      }
      return e._private[t.field];
    }
  }, Bo[t.on] = j_({
    event: t.on,
    field: t.field,
    ableField: t.ableField,
    overrideAble: t.overrideAble,
    value: !0
  }), Bo[t.off] = j_({
    event: t.off,
    field: t.field,
    ableField: t.ableField,
    overrideAble: t.overrideAble,
    value: !1
  });
}
Nf({
  field: "locked",
  overrideField: function(e) {
    return e.cy().autolock() ? !0 : void 0;
  },
  on: "lock",
  off: "unlock"
});
Nf({
  field: "grabbable",
  overrideField: function(e) {
    return e.cy().autoungrabify() || e.pannable() ? !1 : void 0;
  },
  on: "grabify",
  off: "ungrabify"
});
Nf({
  field: "selected",
  ableField: "selectable",
  overrideAble: function(e) {
    return e.cy().autounselectify() ? !1 : void 0;
  },
  on: "select",
  off: "unselect"
});
Nf({
  field: "selectable",
  overrideField: function(e) {
    return e.cy().autounselectify() ? !1 : void 0;
  },
  on: "selectify",
  off: "unselectify"
});
Bo.deselect = Bo.unselect;
Bo.grabbed = function() {
  var t = this[0];
  if (t)
    return t._private.grabbed;
};
Nf({
  field: "active",
  on: "activate",
  off: "unactivate"
});
Nf({
  field: "pannable",
  on: "panify",
  off: "unpanify"
});
Bo.inactive = function() {
  var t = this[0];
  if (t)
    return !t._private.active;
};
var ea = {}, Y_ = function(e) {
  return function(n) {
    for (var a = this, i = [], s = 0; s < a.length; s++) {
      var o = a[s];
      if (o.isNode()) {
        for (var l = !1, u = o.connectedEdges(), c = 0; c < u.length; c++) {
          var f = u[c], h = f.source(), d = f.target();
          if (e.noIncomingEdges && d === o && h !== o || e.noOutgoingEdges && h === o && d !== o) {
            l = !0;
            break;
          }
        }
        l || i.push(o);
      }
    }
    return this.spawn(i, !0).filter(n);
  };
}, X_ = function(e) {
  return function(r) {
    for (var n = this, a = [], i = 0; i < n.length; i++) {
      var s = n[i];
      if (s.isNode())
        for (var o = s.connectedEdges(), l = 0; l < o.length; l++) {
          var u = o[l], c = u.source(), f = u.target();
          e.outgoing && c === s ? (a.push(u), a.push(f)) : e.incoming && f === s && (a.push(u), a.push(c));
        }
    }
    return this.spawn(a, !0).filter(r);
  };
}, K_ = function(e) {
  return function(r) {
    for (var n = this, a = [], i = {}; ; ) {
      var s = e.outgoing ? n.outgoers() : n.incomers();
      if (s.length === 0)
        break;
      for (var o = !1, l = 0; l < s.length; l++) {
        var u = s[l], c = u.id();
        i[c] || (i[c] = !0, a.push(u), o = !0);
      }
      if (!o)
        break;
      n = s;
    }
    return this.spawn(a, !0).filter(r);
  };
};
ea.clearTraversalCache = function() {
  for (var t = 0; t < this.length; t++)
    this[t]._private.traversalCache = null;
};
At(ea, {
  // get the root nodes in the DAG
  roots: Y_({
    noIncomingEdges: !0
  }),
  // get the leaf nodes in the DAG
  leaves: Y_({
    noOutgoingEdges: !0
  }),
  // normally called children in graph theory
  // these nodes =edges=> outgoing nodes
  outgoers: gi(X_({
    outgoing: !0
  }), "outgoers"),
  // aka DAG descendants
  successors: K_({
    outgoing: !0
  }),
  // normally called parents in graph theory
  // these nodes <=edges= incoming nodes
  incomers: gi(X_({
    incoming: !0
  }), "incomers"),
  // aka DAG ancestors
  predecessors: K_({})
});
At(ea, {
  neighborhood: gi(function(t) {
    for (var e = [], r = this.nodes(), n = 0; n < r.length; n++)
      for (var a = r[n], i = a.connectedEdges(), s = 0; s < i.length; s++) {
        var o = i[s], l = o.source(), u = o.target(), c = a === l ? u : l;
        c.length > 0 && e.push(c[0]), e.push(o[0]);
      }
    return this.spawn(e, !0).filter(t);
  }, "neighborhood"),
  closedNeighborhood: function(e) {
    return this.neighborhood().add(this).filter(e);
  },
  openNeighborhood: function(e) {
    return this.neighborhood(e);
  }
});
ea.neighbourhood = ea.neighborhood;
ea.closedNeighbourhood = ea.closedNeighborhood;
ea.openNeighbourhood = ea.openNeighborhood;
At(ea, {
  source: gi(function(e) {
    var r = this[0], n;
    return r && (n = r._private.source || r.cy().collection()), n && e ? n.filter(e) : n;
  }, "source"),
  target: gi(function(e) {
    var r = this[0], n;
    return r && (n = r._private.target || r.cy().collection()), n && e ? n.filter(e) : n;
  }, "target"),
  sources: Z_({
    attr: "source"
  }),
  targets: Z_({
    attr: "target"
  })
});
function Z_(t) {
  return function(r) {
    for (var n = [], a = 0; a < this.length; a++) {
      var i = this[a], s = i._private[t.attr];
      s && n.push(s);
    }
    return this.spawn(n, !0).filter(r);
  };
}
At(ea, {
  edgesWith: gi(Q_(), "edgesWith"),
  edgesTo: gi(Q_({
    thisIsSrc: !0
  }), "edgesTo")
});
function Q_(t) {
  return function(r) {
    var n = [], a = this._private.cy, i = t || {};
    xt(r) && (r = a.$(r));
    for (var s = 0; s < r.length; s++)
      for (var o = r[s]._private.edges, l = 0; l < o.length; l++) {
        var u = o[l], c = u._private.data, f = this.hasElementWithId(c.source) && r.hasElementWithId(c.target), h = r.hasElementWithId(c.source) && this.hasElementWithId(c.target), d = f || h;
        d && ((i.thisIsSrc || i.thisIsTgt) && (i.thisIsSrc && !f || i.thisIsTgt && !h) || n.push(u));
      }
    return this.spawn(n, !0);
  };
}
At(ea, {
  connectedEdges: gi(function(t) {
    for (var e = [], r = this, n = 0; n < r.length; n++) {
      var a = r[n];
      if (a.isNode())
        for (var i = a._private.edges, s = 0; s < i.length; s++) {
          var o = i[s];
          e.push(o);
        }
    }
    return this.spawn(e, !0).filter(t);
  }, "connectedEdges"),
  connectedNodes: gi(function(t) {
    for (var e = [], r = this, n = 0; n < r.length; n++) {
      var a = r[n];
      a.isEdge() && (e.push(a.source()[0]), e.push(a.target()[0]));
    }
    return this.spawn(e, !0).filter(t);
  }, "connectedNodes"),
  parallelEdges: gi(J_(), "parallelEdges"),
  codirectedEdges: gi(J_({
    codirected: !0
  }), "codirectedEdges")
});
function J_(t) {
  var e = {
    codirected: !1
  };
  return t = At({}, e, t), function(n) {
    for (var a = [], i = this.edges(), s = t, o = 0; o < i.length; o++)
      for (var l = i[o], u = l._private, c = u.source, f = c._private.data.id, h = u.data.target, d = c._private.edges, p = 0; p < d.length; p++) {
        var g = d[p], v = g._private.data, m = v.target, b = v.source, y = m === h && b === f, x = f === m && h === b;
        (s.codirected && y || !s.codirected && (y || x)) && a.push(g);
      }
    return this.spawn(a, !0).filter(n);
  };
}
At(ea, {
  components: function(e) {
    var r = this, n = r.cy(), a = n.collection(), i = e == null ? r.nodes() : e.nodes(), s = [];
    e != null && i.empty() && (i = e.sources());
    var o = function(c, f) {
      a.merge(c), i.unmerge(c), f.merge(c);
    };
    if (i.empty())
      return r.spawn();
    var l = function() {
      var c = n.collection();
      s.push(c);
      var f = i[0];
      o(f, c), r.bfs({
        directed: !1,
        roots: f,
        visit: function(d) {
          return o(d, c);
        }
      }), c.forEach(function(h) {
        h.connectedEdges().forEach(function(d) {
          r.has(d) && c.has(d.source()) && c.has(d.target()) && c.merge(d);
        });
      });
    };
    do
      l();
    while (i.length > 0);
    return s;
  },
  component: function() {
    var e = this[0];
    return e.cy().mutableElements().components(e)[0];
  }
});
ea.componentsOf = ea.components;
var zn = function(e, r) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  if (e === void 0) {
    Fr("A collection must have a reference to the core");
    return;
  }
  var i = new Xs(), s = !1;
  if (!r)
    r = [];
  else if (r.length > 0 && Qt(r[0]) && !lp(r[0])) {
    s = !0;
    for (var o = [], l = new Mf(), u = 0, c = r.length; u < c; u++) {
      var f = r[u];
      f.data == null && (f.data = {});
      var h = f.data;
      if (h.id == null)
        h.id = zB();
      else if (e.hasElementWithId(h.id) || l.has(h.id))
        continue;
      var d = new Z1(e, f, !1);
      o.push(d), l.add(h.id);
    }
    r = o;
  }
  this.length = 0;
  for (var p = 0, g = r.length; p < g; p++) {
    var v = r[p][0];
    if (v != null) {
      var m = v._private.data.id;
      (!n || !i.has(m)) && (n && i.set(m, {
        index: this.length,
        ele: v
      }), this[this.length] = v, this.length++);
    }
  }
  this._private = {
    eles: this,
    cy: e,
    get map() {
      return this.lazyMap == null && this.rebuildMap(), this.lazyMap;
    },
    set map(b) {
      this.lazyMap = b;
    },
    rebuildMap: function() {
      for (var y = this.lazyMap = new Xs(), x = this.eles, E = 0; E < x.length; E++) {
        var S = x[E];
        y.set(S.id(), {
          index: E,
          ele: S
        });
      }
    }
  }, n && (this._private.map = i), s && !a && this.restore();
}, _r = Z1.prototype = zn.prototype = Object.create(Array.prototype);
_r.instanceString = function() {
  return "collection";
};
_r.spawn = function(t, e) {
  return new zn(this.cy(), t, e);
};
_r.spawnSelf = function() {
  return this.spawn(this);
};
_r.cy = function() {
  return this._private.cy;
};
_r.renderer = function() {
  return this._private.cy.renderer();
};
_r.element = function() {
  return this[0];
};
_r.collection = function() {
  return AB(this) ? this : new zn(this._private.cy, [this]);
};
_r.unique = function() {
  return new zn(this._private.cy, this, !0);
};
_r.hasElementWithId = function(t) {
  return t = "" + t, this._private.map.has(t);
};
_r.getElementById = function(t) {
  t = "" + t;
  var e = this._private.cy, r = this._private.map.get(t);
  return r ? r.ele : new zn(e);
};
_r.$id = _r.getElementById;
_r.poolIndex = function() {
  var t = this._private.cy, e = t._private.elements, r = this[0]._private.data.id;
  return e._private.map.get(r).index;
};
_r.indexOf = function(t) {
  var e = t[0]._private.data.id;
  return this._private.map.get(e).index;
};
_r.indexOfId = function(t) {
  return t = "" + t, this._private.map.get(t).index;
};
_r.json = function(t) {
  var e = this.element(), r = this.cy();
  if (e == null && t)
    return this;
  if (e != null) {
    var n = e._private;
    if (Qt(t)) {
      if (r.startBatch(), t.data) {
        e.data(t.data);
        var a = n.data;
        if (e.isEdge()) {
          var i = !1, s = {}, o = t.data.source, l = t.data.target;
          o != null && o != a.source && (s.source = "" + o, i = !0), l != null && l != a.target && (s.target = "" + l, i = !0), i && (e = e.move(s));
        } else {
          var u = "parent" in t.data, c = t.data.parent;
          u && (c != null || a.parent != null) && c != a.parent && (c === void 0 && (c = null), c != null && (c = "" + c), e = e.move({
            parent: c
          }));
        }
      }
      t.position && e.position(t.position);
      var f = function(g, v, m) {
        var b = t[g];
        b != null && b !== n[g] && (b ? e[v]() : e[m]());
      };
      return f("removed", "remove", "restore"), f("selected", "select", "unselect"), f("selectable", "selectify", "unselectify"), f("locked", "lock", "unlock"), f("grabbable", "grabify", "ungrabify"), f("pannable", "panify", "unpanify"), t.classes != null && e.classes(t.classes), r.endBatch(), this;
    } else if (t === void 0) {
      var h = {
        data: ds(n.data),
        position: ds(n.position),
        group: n.group,
        removed: n.removed,
        selected: n.selected,
        selectable: n.selectable,
        locked: n.locked,
        grabbable: n.grabbable,
        pannable: n.pannable,
        classes: null
      };
      h.classes = "";
      var d = 0;
      return n.classes.forEach(function(p) {
        return h.classes += d++ === 0 ? p : " " + p;
      }), h;
    }
  }
};
_r.jsons = function() {
  for (var t = [], e = 0; e < this.length; e++) {
    var r = this[e], n = r.json();
    t.push(n);
  }
  return t;
};
_r.clone = function() {
  for (var t = this.cy(), e = [], r = 0; r < this.length; r++) {
    var n = this[r], a = n.json(), i = new Z1(t, a, !1);
    e.push(i);
  }
  return new zn(t, e);
};
_r.copy = _r.clone;
_r.restore = function() {
  for (var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0, e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, r = this, n = r.cy(), a = n._private, i = [], s = [], o, l = 0, u = r.length; l < u; l++) {
    var c = r[l];
    e && !c.removed() || (c.isNode() ? i.push(c) : s.push(c));
  }
  o = i.concat(s);
  var f, h = function() {
    o.splice(f, 1), f--;
  };
  for (f = 0; f < o.length; f++) {
    var d = o[f], p = d._private, g = p.data;
    if (d.clearTraversalCache(), !(!e && !p.removed)) {
      if (g.id === void 0)
        g.id = zB();
      else if (tt(g.id))
        g.id = "" + g.id;
      else if (jo(g.id) || !xt(g.id)) {
        Fr("Can not create element with invalid string ID `" + g.id + "`"), h();
        continue;
      } else if (n.hasElementWithId(g.id)) {
        Fr("Can not create second element with ID `" + g.id + "`"), h();
        continue;
      }
    }
    var v = g.id;
    if (d.isNode()) {
      var m = p.position;
      m.x == null && (m.x = 0), m.y == null && (m.y = 0);
    }
    if (d.isEdge()) {
      for (var b = d, y = ["source", "target"], x = y.length, E = !1, S = 0; S < x; S++) {
        var w = y[S], C = g[w];
        tt(C) && (C = g[w] = "" + g[w]), C == null || C === "" ? (Fr("Can not create edge `" + v + "` with unspecified " + w), E = !0) : n.hasElementWithId(C) || (Fr("Can not create edge `" + v + "` with nonexistant " + w + " `" + C + "`"), E = !0);
      }
      if (E) {
        h();
        continue;
      }
      var k = n.getElementById(g.source), N = n.getElementById(g.target);
      k.same(N) ? k._private.edges.push(b) : (k._private.edges.push(b), N._private.edges.push(b)), b._private.source = k, b._private.target = N;
    }
    p.map = new Xs(), p.map.set(v, {
      ele: d,
      index: 0
    }), p.removed = !1, e && n.addToPool(d);
  }
  for (var R = 0; R < i.length; R++) {
    var _ = i[R], O = _._private.data;
    tt(O.parent) && (O.parent = "" + O.parent);
    var T = O.parent, L = T != null;
    if (L || _._private.parent) {
      var M = _._private.parent ? n.collection().merge(_._private.parent) : n.getElementById(T);
      if (M.empty())
        O.parent = void 0;
      else if (M[0].removed())
        pr("Node added with missing parent, reference to parent removed"), O.parent = void 0, _._private.parent = null;
      else {
        for (var A = !1, I = M; !I.empty(); ) {
          if (_.same(I)) {
            A = !0, O.parent = void 0;
            break;
          }
          I = I.parent();
        }
        A || (M[0]._private.children.push(_), _._private.parent = M[0], a.hasCompoundNodes = !0);
      }
    }
  }
  if (o.length > 0) {
    for (var D = o.length === r.length ? r : new zn(n, o), F = 0; F < D.length; F++) {
      var B = D[F];
      B.isNode() || (B.parallelEdges().clearTraversalCache(), B.source().clearTraversalCache(), B.target().clearTraversalCache());
    }
    var G;
    a.hasCompoundNodes ? G = n.collection().merge(D).merge(D.connectedNodes()).merge(D.parent()) : G = D, G.dirtyCompoundBoundsCache().dirtyBoundingBoxCache().updateStyle(t), t ? D.emitAndNotify("add") : e && D.emit("add");
  }
  return r;
};
_r.removed = function() {
  var t = this[0];
  return t && t._private.removed;
};
_r.inside = function() {
  var t = this[0];
  return t && !t._private.removed;
};
_r.remove = function() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0, e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, r = this, n = [], a = {}, i = r._private.cy;
  function s(T) {
    for (var L = T._private.edges, M = 0; M < L.length; M++)
      l(L[M]);
  }
  function o(T) {
    for (var L = T._private.children, M = 0; M < L.length; M++)
      l(L[M]);
  }
  function l(T) {
    var L = a[T.id()];
    e && T.removed() || L || (a[T.id()] = !0, T.isNode() ? (n.push(T), s(T), o(T)) : n.unshift(T));
  }
  for (var u = 0, c = r.length; u < c; u++) {
    var f = r[u];
    l(f);
  }
  function h(T, L) {
    var M = T._private.edges;
    Yo(M, L), T.clearTraversalCache();
  }
  function d(T) {
    T.clearTraversalCache();
  }
  var p = [];
  p.ids = {};
  function g(T, L) {
    L = L[0], T = T[0];
    var M = T._private.children, A = T.id();
    Yo(M, L), L._private.parent = null, p.ids[A] || (p.ids[A] = !0, p.push(T));
  }
  r.dirtyCompoundBoundsCache(), e && i.removeFromPool(n);
  for (var v = 0; v < n.length; v++) {
    var m = n[v];
    if (m.isEdge()) {
      var b = m.source()[0], y = m.target()[0];
      h(b, m), h(y, m);
      for (var x = m.parallelEdges(), E = 0; E < x.length; E++) {
        var S = x[E];
        d(S), S.isBundledBezier() && S.dirtyBoundingBoxCache();
      }
    } else {
      var w = m.parent();
      w.length !== 0 && g(w, m);
    }
    e && (m._private.removed = !0);
  }
  var C = i._private.elements;
  i._private.hasCompoundNodes = !1;
  for (var k = 0; k < C.length; k++) {
    var N = C[k];
    if (N.isParent()) {
      i._private.hasCompoundNodes = !0;
      break;
    }
  }
  var R = new zn(this.cy(), n);
  R.size() > 0 && (t ? R.emitAndNotify("remove") : e && R.emit("remove"));
  for (var _ = 0; _ < p.length; _++) {
    var O = p[_];
    (!e || !O.removed()) && O.updateStyle();
  }
  return R;
};
_r.move = function(t) {
  var e = this._private.cy, r = this, n = !1, a = !1, i = function(p) {
    return p == null ? p : "" + p;
  };
  if (t.source !== void 0 || t.target !== void 0) {
    var s = i(t.source), o = i(t.target), l = s != null && e.hasElementWithId(s), u = o != null && e.hasElementWithId(o);
    (l || u) && (e.batch(function() {
      r.remove(n, a), r.emitAndNotify("moveout");
      for (var d = 0; d < r.length; d++) {
        var p = r[d], g = p._private.data;
        p.isEdge() && (l && (g.source = s), u && (g.target = o));
      }
      r.restore(n, a);
    }), r.emitAndNotify("move"));
  } else if (t.parent !== void 0) {
    var c = i(t.parent), f = c === null || e.hasElementWithId(c);
    if (f) {
      var h = c === null ? void 0 : c;
      e.batch(function() {
        var d = r.remove(n, a);
        d.emitAndNotify("moveout");
        for (var p = 0; p < r.length; p++) {
          var g = r[p], v = g._private.data;
          g.isNode() && (v.parent = h);
        }
        d.restore(n, a);
      }), r.emitAndNotify("move");
    }
  }
  return this;
};
[QB, u4e, mv, Fo, hf, C4e, ab, G4e, Tz, Sz, W4e, Um, yv, Bn, Bo, ea].forEach(function(t) {
  At(_r, t);
});
var J4e = {
  add: function(e) {
    var r, n = this;
    if (ri(e)) {
      var a = e;
      if (a._private.cy === n)
        r = a.restore();
      else {
        for (var i = [], s = 0; s < a.length; s++) {
          var o = a[s];
          i.push(o.json());
        }
        r = new zn(n, i);
      }
    } else if (Sr(e)) {
      var l = e;
      r = new zn(n, l);
    } else if (Qt(e) && (Sr(e.nodes) || Sr(e.edges))) {
      for (var u = e, c = [], f = ["nodes", "edges"], h = 0, d = f.length; h < d; h++) {
        var p = f[h], g = u[p];
        if (Sr(g))
          for (var v = 0, m = g.length; v < m; v++) {
            var b = At({
              group: p
            }, g[v]);
            c.push(b);
          }
      }
      r = new zn(n, c);
    } else {
      var y = e;
      r = new Z1(n, y).collection();
    }
    return r;
  },
  remove: function(e) {
    if (!ri(e)) {
      if (xt(e)) {
        var r = e;
        e = this.$(r);
      }
    }
    return e.remove();
  }
};
/*! Bezier curve function generator. Copyright Gaetan Renaudeau. MIT License: http://en.wikipedia.org/wiki/MIT_License */
function eSe(t, e, r, n) {
  var a = 4, i = 1e-3, s = 1e-7, o = 10, l = 11, u = 1 / (l - 1), c = typeof Float32Array < "u";
  if (arguments.length !== 4)
    return !1;
  for (var f = 0; f < 4; ++f)
    if (typeof arguments[f] != "number" || isNaN(arguments[f]) || !isFinite(arguments[f]))
      return !1;
  t = Math.min(t, 1), r = Math.min(r, 1), t = Math.max(t, 0), r = Math.max(r, 0);
  var h = c ? new Float32Array(l) : new Array(l);
  function d(N, R) {
    return 1 - 3 * R + 3 * N;
  }
  function p(N, R) {
    return 3 * R - 6 * N;
  }
  function g(N) {
    return 3 * N;
  }
  function v(N, R, _) {
    return ((d(R, _) * N + p(R, _)) * N + g(R)) * N;
  }
  function m(N, R, _) {
    return 3 * d(R, _) * N * N + 2 * p(R, _) * N + g(R);
  }
  function b(N, R) {
    for (var _ = 0; _ < a; ++_) {
      var O = m(R, t, r);
      if (O === 0)
        return R;
      var T = v(R, t, r) - N;
      R -= T / O;
    }
    return R;
  }
  function y() {
    for (var N = 0; N < l; ++N)
      h[N] = v(N * u, t, r);
  }
  function x(N, R, _) {
    var O, T, L = 0;
    do
      T = R + (_ - R) / 2, O = v(T, t, r) - N, O > 0 ? _ = T : R = T;
    while (Math.abs(O) > s && ++L < o);
    return T;
  }
  function E(N) {
    for (var R = 0, _ = 1, O = l - 1; _ !== O && h[_] <= N; ++_)
      R += u;
    --_;
    var T = (N - h[_]) / (h[_ + 1] - h[_]), L = R + T * u, M = m(L, t, r);
    return M >= i ? b(N, L) : M === 0 ? L : x(N, R, R + u);
  }
  var S = !1;
  function w() {
    S = !0, (t !== e || r !== n) && y();
  }
  var C = function(R) {
    return S || w(), t === e && r === n ? R : R === 0 ? 0 : R === 1 ? 1 : v(E(R), e, n);
  };
  C.getControlPoints = function() {
    return [{
      x: t,
      y: e
    }, {
      x: r,
      y: n
    }];
  };
  var k = "generateBezier(" + [t, e, r, n] + ")";
  return C.toString = function() {
    return k;
  }, C;
}
/*! Runge-Kutta spring physics function generator. Adapted from Framer.js, copyright Koen Bok. MIT License: http://en.wikipedia.org/wiki/MIT_License */
var tSe = /* @__PURE__ */ function() {
  function t(n) {
    return -n.tension * n.x - n.friction * n.v;
  }
  function e(n, a, i) {
    var s = {
      x: n.x + i.dx * a,
      v: n.v + i.dv * a,
      tension: n.tension,
      friction: n.friction
    };
    return {
      dx: s.v,
      dv: t(s)
    };
  }
  function r(n, a) {
    var i = {
      dx: n.v,
      dv: t(n)
    }, s = e(n, a * 0.5, i), o = e(n, a * 0.5, s), l = e(n, a, o), u = 1 / 6 * (i.dx + 2 * (s.dx + o.dx) + l.dx), c = 1 / 6 * (i.dv + 2 * (s.dv + o.dv) + l.dv);
    return n.x = n.x + u * a, n.v = n.v + c * a, n;
  }
  return function n(a, i, s) {
    var o = {
      x: -1,
      v: 0,
      tension: null,
      friction: null
    }, l = [0], u = 0, c = 1 / 1e4, f = 16 / 1e3, h, d, p;
    for (a = parseFloat(a) || 500, i = parseFloat(i) || 20, s = s || null, o.tension = a, o.friction = i, h = s !== null, h ? (u = n(a, i), d = u / s * f) : d = f; p = r(p || o, d), l.push(1 + p.x), u += 16, Math.abs(p.x) > c && Math.abs(p.v) > c; )
      ;
    return h ? function(g) {
      return l[g * (l.length - 1) | 0];
    } : u;
  };
}(), Ar = function(e, r, n, a) {
  var i = eSe(e, r, n, a);
  return function(s, o, l) {
    return s + (o - s) * i(l);
  };
}, bv = {
  linear: function(e, r, n) {
    return e + (r - e) * n;
  },
  // default easings
  ease: Ar(0.25, 0.1, 0.25, 1),
  "ease-in": Ar(0.42, 0, 1, 1),
  "ease-out": Ar(0, 0, 0.58, 1),
  "ease-in-out": Ar(0.42, 0, 0.58, 1),
  // sine
  "ease-in-sine": Ar(0.47, 0, 0.745, 0.715),
  "ease-out-sine": Ar(0.39, 0.575, 0.565, 1),
  "ease-in-out-sine": Ar(0.445, 0.05, 0.55, 0.95),
  // quad
  "ease-in-quad": Ar(0.55, 0.085, 0.68, 0.53),
  "ease-out-quad": Ar(0.25, 0.46, 0.45, 0.94),
  "ease-in-out-quad": Ar(0.455, 0.03, 0.515, 0.955),
  // cubic
  "ease-in-cubic": Ar(0.55, 0.055, 0.675, 0.19),
  "ease-out-cubic": Ar(0.215, 0.61, 0.355, 1),
  "ease-in-out-cubic": Ar(0.645, 0.045, 0.355, 1),
  // quart
  "ease-in-quart": Ar(0.895, 0.03, 0.685, 0.22),
  "ease-out-quart": Ar(0.165, 0.84, 0.44, 1),
  "ease-in-out-quart": Ar(0.77, 0, 0.175, 1),
  // quint
  "ease-in-quint": Ar(0.755, 0.05, 0.855, 0.06),
  "ease-out-quint": Ar(0.23, 1, 0.32, 1),
  "ease-in-out-quint": Ar(0.86, 0, 0.07, 1),
  // expo
  "ease-in-expo": Ar(0.95, 0.05, 0.795, 0.035),
  "ease-out-expo": Ar(0.19, 1, 0.22, 1),
  "ease-in-out-expo": Ar(1, 0, 0, 1),
  // circ
  "ease-in-circ": Ar(0.6, 0.04, 0.98, 0.335),
  "ease-out-circ": Ar(0.075, 0.82, 0.165, 1),
  "ease-in-out-circ": Ar(0.785, 0.135, 0.15, 0.86),
  // user param easings...
  spring: function(e, r, n) {
    if (n === 0)
      return bv.linear;
    var a = tSe(e, r, n);
    return function(i, s, o) {
      return i + (s - i) * a(o);
    };
  },
  "cubic-bezier": Ar
};
function eL(t, e, r, n, a) {
  if (n === 1 || e === r)
    return r;
  var i = a(e, r, n);
  return t == null || ((t.roundValue || t.color) && (i = Math.round(i)), t.min !== void 0 && (i = Math.max(i, t.min)), t.max !== void 0 && (i = Math.min(i, t.max))), i;
}
function tL(t, e) {
  return t.pfValue != null || t.value != null ? t.pfValue != null && (e == null || e.type.units !== "%") ? t.pfValue : t.value : t;
}
function Wu(t, e, r, n, a) {
  var i = a != null ? a.type : null;
  r < 0 ? r = 0 : r > 1 && (r = 1);
  var s = tL(t, a), o = tL(e, a);
  if (tt(s) && tt(o))
    return eL(i, s, o, r, n);
  if (Sr(s) && Sr(o)) {
    for (var l = [], u = 0; u < o.length; u++) {
      var c = s[u], f = o[u];
      if (c != null && f != null) {
        var h = eL(i, c, f, r, n);
        l.push(h);
      } else
        l.push(f);
    }
    return l;
  }
}
function rSe(t, e, r, n) {
  var a = !n, i = t._private, s = e._private, o = s.easing, l = s.startTime, u = n ? t : t.cy(), c = u.style();
  if (!s.easingImpl)
    if (o == null)
      s.easingImpl = bv.linear;
    else {
      var f;
      if (xt(o)) {
        var h = c.parse("transition-timing-function", o);
        f = h.value;
      } else
        f = o;
      var d, p;
      xt(f) ? (d = f, p = []) : (d = f[1], p = f.slice(2).map(function(D) {
        return +D;
      })), p.length > 0 ? (d === "spring" && p.push(s.duration), s.easingImpl = bv[d].apply(null, p)) : s.easingImpl = bv[d];
    }
  var g = s.easingImpl, v;
  if (s.duration === 0 ? v = 1 : v = (r - l) / s.duration, s.applying && (v = s.progress), v < 0 ? v = 0 : v > 1 && (v = 1), s.delay == null) {
    var m = s.startPosition, b = s.position;
    if (b && a && !t.locked()) {
      var y = {};
      dh(m.x, b.x) && (y.x = Wu(m.x, b.x, v, g)), dh(m.y, b.y) && (y.y = Wu(m.y, b.y, v, g)), t.position(y);
    }
    var x = s.startPan, E = s.pan, S = i.pan, w = E != null && n;
    w && (dh(x.x, E.x) && (S.x = Wu(x.x, E.x, v, g)), dh(x.y, E.y) && (S.y = Wu(x.y, E.y, v, g)), t.emit("pan"));
    var C = s.startZoom, k = s.zoom, N = k != null && n;
    N && (dh(C, k) && (i.zoom = u0(i.minZoom, Wu(C, k, v, g), i.maxZoom)), t.emit("zoom")), (w || N) && t.emit("viewport");
    var R = s.style;
    if (R && R.length > 0 && a) {
      for (var _ = 0; _ < R.length; _++) {
        var O = R[_], T = O.name, L = O, M = s.startStyle[T], A = c.properties[M.name], I = Wu(M, L, v, g, A);
        c.overrideBypass(t, T, I);
      }
      t.emit("style");
    }
  }
  return s.progress = v, v;
}
function dh(t, e) {
  return t == null || e == null ? !1 : tt(t) && tt(e) ? !0 : !!(t && e);
}
function nSe(t, e, r, n) {
  var a = e._private;
  a.started = !0, a.startTime = r - a.progress * a.duration;
}
function rL(t, e) {
  var r = e._private.aniEles, n = [];
  function a(c, f) {
    var h = c._private, d = h.animation.current, p = h.animation.queue, g = !1;
    if (d.length === 0) {
      var v = p.shift();
      v && d.push(v);
    }
    for (var m = function(S) {
      for (var w = S.length - 1; w >= 0; w--) {
        var C = S[w];
        C();
      }
      S.splice(0, S.length);
    }, b = d.length - 1; b >= 0; b--) {
      var y = d[b], x = y._private;
      if (x.stopped) {
        d.splice(b, 1), x.hooked = !1, x.playing = !1, x.started = !1, m(x.frames);
        continue;
      }
      !x.playing && !x.applying || (x.playing && x.applying && (x.applying = !1), x.started || nSe(c, y, t), rSe(c, y, t, f), x.applying && (x.applying = !1), m(x.frames), x.step != null && x.step(t), y.completed() && (d.splice(b, 1), x.hooked = !1, x.playing = !1, x.started = !1, m(x.completes)), g = !0);
    }
    return !f && d.length === 0 && p.length === 0 && n.push(c), g;
  }
  for (var i = !1, s = 0; s < r.length; s++) {
    var o = r[s], l = a(o);
    i = i || l;
  }
  var u = a(e, !0);
  (i || u) && (r.length > 0 ? e.notify("draw", r) : e.notify("draw")), r.unmerge(n), e.emit("step");
}
var aSe = {
  // pull in animation functions
  animate: hr.animate(),
  animation: hr.animation(),
  animated: hr.animated(),
  clearQueue: hr.clearQueue(),
  delay: hr.delay(),
  delayAnimation: hr.delayAnimation(),
  stop: hr.stop(),
  addToAnimationPool: function(e) {
    var r = this;
    r.styleEnabled() && r._private.aniEles.merge(e);
  },
  stopAnimationLoop: function() {
    this._private.animationsRunning = !1;
  },
  startAnimationLoop: function() {
    var e = this;
    if (e._private.animationsRunning = !0, !e.styleEnabled())
      return;
    function r() {
      e._private.animationsRunning && $m(function(i) {
        rL(i, e), r();
      });
    }
    var n = e.renderer();
    n && n.beforeRender ? n.beforeRender(function(i, s) {
      rL(s, e);
    }, n.beforeRenderPriorities.animations) : r();
  }
}, iSe = {
  qualifierCompare: function(e, r) {
    return e == null || r == null ? e == null && r == null : e.sameText(r);
  },
  eventMatches: function(e, r, n) {
    var a = r.qualifier;
    return a != null ? e !== n.target && lp(n.target) && a.matches(n.target) : !0;
  },
  addEventFields: function(e, r) {
    r.cy = e, r.target = e;
  },
  callbackContext: function(e, r, n) {
    return r.qualifier != null ? n.target : e;
  }
}, mg = function(e) {
  return xt(e) ? new Ko(e) : e;
}, kz = {
  createEmitter: function() {
    var e = this._private;
    return e.emitter || (e.emitter = new ib(iSe, this)), this;
  },
  emitter: function() {
    return this._private.emitter;
  },
  on: function(e, r, n) {
    return this.emitter().on(e, mg(r), n), this;
  },
  removeListener: function(e, r, n) {
    return this.emitter().removeListener(e, mg(r), n), this;
  },
  removeAllListeners: function() {
    return this.emitter().removeAllListeners(), this;
  },
  one: function(e, r, n) {
    return this.emitter().one(e, mg(r), n), this;
  },
  once: function(e, r, n) {
    return this.emitter().one(e, mg(r), n), this;
  },
  emit: function(e, r) {
    return this.emitter().emit(e, r), this;
  },
  emitAndNotify: function(e, r) {
    return this.emit(e), this.notify(e, r), this;
  }
};
hr.eventAliasesOn(kz);
var A4 = {
  png: function(e) {
    var r = this._private.renderer;
    return e = e || {}, r.png(e);
  },
  jpg: function(e) {
    var r = this._private.renderer;
    return e = e || {}, e.bg = e.bg || "#fff", r.jpg(e);
  }
};
A4.jpeg = A4.jpg;
var xv = {
  layout: function(e) {
    var r = this;
    if (e == null) {
      Fr("Layout options must be specified to make a layout");
      return;
    }
    if (e.name == null) {
      Fr("A `name` must be specified to make a layout");
      return;
    }
    var n = e.name, a = r.extension("layout", n);
    if (a == null) {
      Fr("No such layout `" + n + "` found.  Did you forget to import it and `cytoscape.use()` it?");
      return;
    }
    var i;
    xt(e.eles) ? i = r.$(e.eles) : i = e.eles != null ? e.eles : r.$();
    var s = new a(At({}, e, {
      cy: r,
      eles: i
    }));
    return s;
  }
};
xv.createLayout = xv.makeLayout = xv.layout;
var sSe = {
  notify: function(e, r) {
    var n = this._private;
    if (this.batching()) {
      n.batchNotifications = n.batchNotifications || {};
      var a = n.batchNotifications[e] = n.batchNotifications[e] || this.collection();
      r != null && a.merge(r);
      return;
    }
    if (n.notificationsEnabled) {
      var i = this.renderer();
      this.destroyed() || !i || i.notify(e, r);
    }
  },
  notifications: function(e) {
    var r = this._private;
    return e === void 0 ? r.notificationsEnabled : (r.notificationsEnabled = !!e, this);
  },
  noNotifications: function(e) {
    this.notifications(!1), e(), this.notifications(!0);
  },
  batching: function() {
    return this._private.batchCount > 0;
  },
  startBatch: function() {
    var e = this._private;
    return e.batchCount == null && (e.batchCount = 0), e.batchCount === 0 && (e.batchStyleEles = this.collection(), e.batchNotifications = {}), e.batchCount++, this;
  },
  endBatch: function() {
    var e = this._private;
    if (e.batchCount === 0)
      return this;
    if (e.batchCount--, e.batchCount === 0) {
      e.batchStyleEles.updateStyle();
      var r = this.renderer();
      Object.keys(e.batchNotifications).forEach(function(n) {
        var a = e.batchNotifications[n];
        a.empty() ? r.notify(n) : r.notify(n, a);
      });
    }
    return this;
  },
  batch: function(e) {
    return this.startBatch(), e(), this.endBatch(), this;
  },
  // for backwards compatibility
  batchData: function(e) {
    var r = this;
    return this.batch(function() {
      for (var n = Object.keys(e), a = 0; a < n.length; a++) {
        var i = n[a], s = e[i], o = r.getElementById(i);
        o.data(s);
      }
    });
  }
}, oSe = Hn({
  hideEdgesOnViewport: !1,
  textureOnViewport: !1,
  motionBlur: !1,
  motionBlurOpacity: 0.05,
  pixelRatio: void 0,
  desktopTapThreshold: 4,
  touchTapThreshold: 8,
  wheelSensitivity: 1,
  debug: !1,
  showFps: !1,
  // webgl options
  webgl: !1,
  webglDebug: !1,
  webglDebugShowAtlases: !1,
  // defaults good for mobile
  webglTexSize: 2048,
  webglTexRows: 36,
  webglTexRowsNodes: 18,
  webglBatchSize: 2048,
  webglTexPerBatch: 14,
  webglBgColor: [255, 255, 255]
}), k4 = {
  renderTo: function(e, r, n, a) {
    var i = this._private.renderer;
    return i.renderTo(e, r, n, a), this;
  },
  renderer: function() {
    return this._private.renderer;
  },
  forceRender: function() {
    return this.notify("draw"), this;
  },
  resize: function() {
    return this.invalidateSize(), this.emitAndNotify("resize"), this;
  },
  initRenderer: function(e) {
    var r = this, n = r.extension("renderer", e.name);
    if (n == null) {
      Fr("Can not initialise: No such renderer `".concat(e.name, "` found. Did you forget to import it and `cytoscape.use()` it?"));
      return;
    }
    e.wheelSensitivity !== void 0 && pr("You have set a custom wheel sensitivity.  This will make your app zoom unnaturally when using mainstream mice.  You should change this value from the default only if you can guarantee that all your users will use the same hardware and OS configuration as your current machine.");
    var a = oSe(e);
    a.cy = r, r._private.renderer = new n(a), this.notify("init");
  },
  destroyRenderer: function() {
    var e = this;
    e.notify("destroy");
    var r = e.container();
    if (r)
      for (r._cyreg = null; r.childNodes.length > 0; )
        r.removeChild(r.childNodes[0]);
    e._private.renderer = null, e.mutableElements().forEach(function(n) {
      var a = n._private;
      a.rscratch = {}, a.rstyle = {}, a.animation.current = [], a.animation.queue = [];
    });
  },
  onRender: function(e) {
    return this.on("render", e);
  },
  offRender: function(e) {
    return this.off("render", e);
  }
};
k4.invalidateDimensions = k4.resize;
var wv = {
  // get a collection
  // - empty collection on no args
  // - collection of elements in the graph on selector arg
  // - guarantee a returned collection when elements or collection specified
  collection: function(e, r) {
    return xt(e) ? this.$(e) : ri(e) ? e.collection() : Sr(e) ? (r || (r = {}), new zn(this, e, r.unique, r.removed)) : new zn(this);
  },
  nodes: function(e) {
    var r = this.$(function(n) {
      return n.isNode();
    });
    return e ? r.filter(e) : r;
  },
  edges: function(e) {
    var r = this.$(function(n) {
      return n.isEdge();
    });
    return e ? r.filter(e) : r;
  },
  // search the graph like jQuery
  $: function(e) {
    var r = this._private.elements;
    return e ? r.filter(e) : r.spawnSelf();
  },
  mutableElements: function() {
    return this._private.elements;
  }
};
wv.elements = wv.filter = wv.$;
var In = {}, Nd = "t", lSe = "f";
In.apply = function(t) {
  for (var e = this, r = e._private, n = r.cy, a = n.collection(), i = 0; i < t.length; i++) {
    var s = t[i], o = e.getContextMeta(s);
    if (!o.empty) {
      var l = e.getContextStyle(o), u = e.applyContextStyle(o, l, s);
      s._private.appliedInitStyle ? e.updateTransitions(s, u.diffProps) : s._private.appliedInitStyle = !0;
      var c = e.updateStyleHints(s);
      c && a.push(s);
    }
  }
  return a;
};
In.getPropertiesDiff = function(t, e) {
  var r = this, n = r._private.propDiffs = r._private.propDiffs || {}, a = t + "-" + e, i = n[a];
  if (i)
    return i;
  for (var s = [], o = {}, l = 0; l < r.length; l++) {
    var u = r[l], c = t[l] === Nd, f = e[l] === Nd, h = c !== f, d = u.mappedProperties.length > 0;
    if (h || f && d) {
      var p = void 0;
      h && d || h ? p = u.properties : d && (p = u.mappedProperties);
      for (var g = 0; g < p.length; g++) {
        for (var v = p[g], m = v.name, b = !1, y = l + 1; y < r.length; y++) {
          var x = r[y], E = e[y] === Nd;
          if (E && (b = x.properties[v.name] != null, b))
            break;
        }
        !o[m] && !b && (o[m] = !0, s.push(m));
      }
    }
  }
  return n[a] = s, s;
};
In.getContextMeta = function(t) {
  for (var e = this, r = "", n, a = t._private.styleCxtKey || "", i = 0; i < e.length; i++) {
    var s = e[i], o = s.selector && s.selector.matches(t);
    o ? r += Nd : r += lSe;
  }
  return n = e.getPropertiesDiff(a, r), t._private.styleCxtKey = r, {
    key: r,
    diffPropNames: n,
    empty: n.length === 0
  };
};
In.getContextStyle = function(t) {
  var e = t.key, r = this, n = this._private.contextStyles = this._private.contextStyles || {};
  if (n[e])
    return n[e];
  for (var a = {
    _private: {
      key: e
    }
  }, i = 0; i < r.length; i++) {
    var s = r[i], o = e[i] === Nd;
    if (o)
      for (var l = 0; l < s.properties.length; l++) {
        var u = s.properties[l];
        a[u.name] = u;
      }
  }
  return n[e] = a, a;
};
In.applyContextStyle = function(t, e, r) {
  for (var n = this, a = t.diffPropNames, i = {}, s = n.types, o = 0; o < a.length; o++) {
    var l = a[o], u = e[l], c = r.pstyle(l);
    if (!u)
      if (c)
        c.bypass ? u = {
          name: l,
          deleteBypassed: !0
        } : u = {
          name: l,
          delete: !0
        };
      else continue;
    if (c !== u) {
      if (u.mapped === s.fn && c != null && c.mapping != null && c.mapping.value === u.value) {
        var f = c.mapping, h = f.fnValue = u.value(r);
        if (h === f.prevFnValue)
          continue;
      }
      var d = i[l] = {
        prev: c
      };
      n.applyParsedProperty(r, u), d.next = r.pstyle(l), d.next && d.next.bypass && (d.next = d.next.bypassed);
    }
  }
  return {
    diffProps: i
  };
};
In.updateStyleHints = function(t) {
  var e = t._private, r = this, n = r.propertyGroupNames, a = r.propertyGroupKeys, i = function(W, ue, J) {
    return r.getPropertiesHash(W, ue, J);
  }, s = e.styleKey;
  if (t.removed())
    return !1;
  var o = e.group === "nodes", l = t._private.style;
  n = Object.keys(l);
  for (var u = 0; u < a.length; u++) {
    var c = a[u];
    e.styleKeys[c] = [$l, Ju];
  }
  for (var f = function(W, ue) {
    return e.styleKeys[ue][0] = s0(W, e.styleKeys[ue][0]);
  }, h = function(W, ue) {
    return e.styleKeys[ue][1] = o0(W, e.styleKeys[ue][1]);
  }, d = function(W, ue) {
    f(W, ue), h(W, ue);
  }, p = function(W, ue) {
    for (var J = 0; J < W.length; J++) {
      var Ce = W.charCodeAt(J);
      f(Ce, ue), h(Ce, ue);
    }
  }, g = 2e9, v = function(W) {
    return -128 < W && W < 128 && Math.floor(W) !== W ? g - (W * 1024 | 0) : W;
  }, m = 0; m < n.length; m++) {
    var b = n[m], y = l[b];
    if (y != null) {
      var x = this.properties[b], E = x.type, S = x.groupKey, w = void 0;
      x.hashOverride != null ? w = x.hashOverride(t, y) : y.pfValue != null && (w = y.pfValue);
      var C = x.enums == null ? y.value : null, k = w != null, N = C != null, R = k || N, _ = y.units;
      if (E.number && R && !E.multiple) {
        var O = k ? w : C;
        d(v(O), S), !k && _ != null && p(_, S);
      } else
        p(y.strValue, S);
    }
  }
  for (var T = [$l, Ju], L = 0; L < a.length; L++) {
    var M = a[L], A = e.styleKeys[M];
    T[0] = s0(A[0], T[0]), T[1] = o0(A[1], T[1]);
  }
  e.styleKey = Swe(T[0], T[1]);
  var I = e.styleKeys;
  e.labelDimsKey = So(I.labelDimensions);
  var D = i(t, ["label"], I.labelDimensions);
  if (e.labelKey = So(D), e.labelStyleKey = So(ug(I.commonLabel, D)), !o) {
    var F = i(t, ["source-label"], I.labelDimensions);
    e.sourceLabelKey = So(F), e.sourceLabelStyleKey = So(ug(I.commonLabel, F));
    var B = i(t, ["target-label"], I.labelDimensions);
    e.targetLabelKey = So(B), e.targetLabelStyleKey = So(ug(I.commonLabel, B));
  }
  if (o) {
    var G = e.styleKeys, H = G.nodeBody, K = G.nodeBorder, j = G.nodeOutline, Z = G.backgroundImage, te = G.compound, ne = G.pie, V = G.stripe, q = [H, K, j, Z, te, ne, V].filter(function(X) {
      return X != null;
    }).reduce(ug, [$l, Ju]);
    e.nodeKey = So(q), e.hasPie = ne != null && ne[0] !== $l && ne[1] !== Ju, e.hasStripe = V != null && V[0] !== $l && V[1] !== Ju;
  }
  return s !== e.styleKey;
};
In.clearStyleHints = function(t) {
  var e = t._private;
  e.styleCxtKey = "", e.styleKeys = {}, e.styleKey = null, e.labelKey = null, e.labelStyleKey = null, e.sourceLabelKey = null, e.sourceLabelStyleKey = null, e.targetLabelKey = null, e.targetLabelStyleKey = null, e.nodeKey = null, e.hasPie = null, e.hasStripe = null;
};
In.applyParsedProperty = function(t, e) {
  var r = this, n = e, a = t._private.style, i, s = r.types, o = r.properties[n.name].type, l = n.bypass, u = a[n.name], c = u && u.bypass, f = t._private, h = "mapping", d = function(H) {
    return H == null ? null : H.pfValue != null ? H.pfValue : H.value;
  }, p = function() {
    var H = d(u), K = d(n);
    r.checkTriggers(t, n.name, H, K);
  };
  if (e.name === "curve-style" && t.isEdge() && // loops must be bundled beziers
  (e.value !== "bezier" && t.isLoop() || // edges connected to compound nodes can not be haystacks
  e.value === "haystack" && (t.source().isParent() || t.target().isParent())) && (n = e = this.parse(e.name, "bezier", l)), n.delete)
    return a[n.name] = void 0, p(), !0;
  if (n.deleteBypassed)
    return u ? u.bypass ? (u.bypassed = void 0, p(), !0) : !1 : (p(), !0);
  if (n.deleteBypass)
    return u ? u.bypass ? (a[n.name] = u.bypassed, p(), !0) : !1 : (p(), !0);
  var g = function() {
    pr("Do not assign mappings to elements without corresponding data (i.e. ele `" + t.id() + "` has no mapping for property `" + n.name + "` with data field `" + n.field + "`); try a `[" + n.field + "]` selector to limit scope to elements with `" + n.field + "` defined");
  };
  switch (n.mapped) {
    case s.mapData: {
      for (var v = n.field.split("."), m = f.data, b = 0; b < v.length && m; b++) {
        var y = v[b];
        m = m[y];
      }
      if (m == null)
        return g(), !1;
      var x;
      if (tt(m)) {
        var E = n.fieldMax - n.fieldMin;
        E === 0 ? x = 0 : x = (m - n.fieldMin) / E;
      } else
        return pr("Do not use continuous mappers without specifying numeric data (i.e. `" + n.field + ": " + m + "` for `" + t.id() + "` is non-numeric)"), !1;
      if (x < 0 ? x = 0 : x > 1 && (x = 1), o.color) {
        var S = n.valueMin[0], w = n.valueMax[0], C = n.valueMin[1], k = n.valueMax[1], N = n.valueMin[2], R = n.valueMax[2], _ = n.valueMin[3] == null ? 1 : n.valueMin[3], O = n.valueMax[3] == null ? 1 : n.valueMax[3], T = [Math.round(S + (w - S) * x), Math.round(C + (k - C) * x), Math.round(N + (R - N) * x), Math.round(_ + (O - _) * x)];
        i = {
          // colours are simple, so just create the flat property instead of expensive string parsing
          bypass: n.bypass,
          // we're a bypass if the mapping property is a bypass
          name: n.name,
          value: T,
          strValue: "rgb(" + T[0] + ", " + T[1] + ", " + T[2] + ")"
        };
      } else if (o.number) {
        var L = n.valueMin + (n.valueMax - n.valueMin) * x;
        i = this.parse(n.name, L, n.bypass, h);
      } else
        return !1;
      if (!i)
        return g(), !1;
      i.mapping = n, n = i;
      break;
    }
    case s.data: {
      for (var M = n.field.split("."), A = f.data, I = 0; I < M.length && A; I++) {
        var D = M[I];
        A = A[D];
      }
      if (A != null && (i = this.parse(n.name, A, n.bypass, h)), !i)
        return g(), !1;
      i.mapping = n, n = i;
      break;
    }
    case s.fn: {
      var F = n.value, B = n.fnValue != null ? n.fnValue : F(t);
      if (n.prevFnValue = B, B == null)
        return pr("Custom function mappers may not return null (i.e. `" + n.name + "` for ele `" + t.id() + "` is null)"), !1;
      if (i = this.parse(n.name, B, n.bypass, h), !i)
        return pr("Custom function mappers may not return invalid values for the property type (i.e. `" + n.name + "` for ele `" + t.id() + "` is invalid)"), !1;
      i.mapping = ds(n), n = i;
      break;
    }
    case void 0:
      break;
    default:
      return !1;
  }
  return l ? (c ? n.bypassed = u.bypassed : n.bypassed = u, a[n.name] = n) : c ? u.bypassed = n : a[n.name] = n, p(), !0;
};
In.cleanElements = function(t, e) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    if (this.clearStyleHints(n), n.dirtyCompoundBoundsCache(), n.dirtyBoundingBoxCache(), !e)
      n._private.style = {};
    else
      for (var a = n._private.style, i = Object.keys(a), s = 0; s < i.length; s++) {
        var o = i[s], l = a[o];
        l != null && (l.bypass ? l.bypassed = null : a[o] = null);
      }
  }
};
In.update = function() {
  var t = this._private.cy, e = t.mutableElements();
  e.updateStyle();
};
In.updateTransitions = function(t, e) {
  var r = this, n = t._private, a = t.pstyle("transition-property").value, i = t.pstyle("transition-duration").pfValue, s = t.pstyle("transition-delay").pfValue;
  if (a.length > 0 && i > 0) {
    for (var o = {}, l = !1, u = 0; u < a.length; u++) {
      var c = a[u], f = t.pstyle(c), h = e[c];
      if (h) {
        var d = h.prev, p = d, g = h.next != null ? h.next : f, v = !1, m = void 0, b = 1e-6;
        p && (tt(p.pfValue) && tt(g.pfValue) ? (v = g.pfValue - p.pfValue, m = p.pfValue + b * v) : tt(p.value) && tt(g.value) ? (v = g.value - p.value, m = p.value + b * v) : Sr(p.value) && Sr(g.value) && (v = p.value[0] !== g.value[0] || p.value[1] !== g.value[1] || p.value[2] !== g.value[2], m = p.strValue), v && (o[c] = g.strValue, this.applyBypass(t, c, m), l = !0));
      }
    }
    if (!l)
      return;
    n.transitioning = !0, new _f(function(y) {
      s > 0 ? t.delayAnimation(s).play().promise().then(y) : y();
    }).then(function() {
      return t.animation({
        style: o,
        duration: i,
        easing: t.pstyle("transition-timing-function").value,
        queue: !1
      }).play().promise();
    }).then(function() {
      r.removeBypasses(t, a), t.emitAndNotify("style"), n.transitioning = !1;
    });
  } else n.transitioning && (this.removeBypasses(t, a), t.emitAndNotify("style"), n.transitioning = !1);
};
In.checkTrigger = function(t, e, r, n, a, i) {
  var s = this.properties[e], o = a(s);
  t.removed() || o != null && o(r, n, t) && i(s);
};
In.checkZOrderTrigger = function(t, e, r, n) {
  var a = this;
  this.checkTrigger(t, e, r, n, function(i) {
    return i.triggersZOrder;
  }, function() {
    a._private.cy.notify("zorder", t);
  });
};
In.checkBoundsTrigger = function(t, e, r, n) {
  this.checkTrigger(t, e, r, n, function(a) {
    return a.triggersBounds;
  }, function(a) {
    t.dirtyCompoundBoundsCache(), t.dirtyBoundingBoxCache();
  });
};
In.checkConnectedEdgesBoundsTrigger = function(t, e, r, n) {
  this.checkTrigger(t, e, r, n, function(a) {
    return a.triggersBoundsOfConnectedEdges;
  }, function(a) {
    t.connectedEdges().forEach(function(i) {
      i.dirtyBoundingBoxCache();
    });
  });
};
In.checkParallelEdgesBoundsTrigger = function(t, e, r, n) {
  this.checkTrigger(t, e, r, n, function(a) {
    return a.triggersBoundsOfParallelEdges;
  }, function(a) {
    t.parallelEdges().forEach(function(i) {
      i.dirtyBoundingBoxCache();
    });
  });
};
In.checkTriggers = function(t, e, r, n) {
  t.dirtyStyleCache(), this.checkZOrderTrigger(t, e, r, n), this.checkBoundsTrigger(t, e, r, n), this.checkConnectedEdgesBoundsTrigger(t, e, r, n), this.checkParallelEdgesBoundsTrigger(t, e, r, n);
};
var gp = {};
gp.applyBypass = function(t, e, r, n) {
  var a = this, i = [], s = !0;
  if (e === "*" || e === "**") {
    if (r !== void 0)
      for (var o = 0; o < a.properties.length; o++) {
        var l = a.properties[o], u = l.name, c = this.parse(u, r, !0);
        c && i.push(c);
      }
  } else if (xt(e)) {
    var f = this.parse(e, r, !0);
    f && i.push(f);
  } else if (Qt(e)) {
    var h = e;
    n = r;
    for (var d = Object.keys(h), p = 0; p < d.length; p++) {
      var g = d[p], v = h[g];
      if (v === void 0 && (v = h[X1(g)]), v !== void 0) {
        var m = this.parse(g, v, !0);
        m && i.push(m);
      }
    }
  } else
    return !1;
  if (i.length === 0)
    return !1;
  for (var b = !1, y = 0; y < t.length; y++) {
    for (var x = t[y], E = {}, S = void 0, w = 0; w < i.length; w++) {
      var C = i[w];
      if (n) {
        var k = x.pstyle(C.name);
        S = E[C.name] = {
          prev: k
        };
      }
      b = this.applyParsedProperty(x, ds(C)) || b, n && (S.next = x.pstyle(C.name));
    }
    b && this.updateStyleHints(x), n && this.updateTransitions(x, E, s);
  }
  return b;
};
gp.overrideBypass = function(t, e, r) {
  e = n3(e);
  for (var n = 0; n < t.length; n++) {
    var a = t[n], i = a._private.style[e], s = this.properties[e].type, o = s.color, l = s.mutiple, u = i ? i.pfValue != null ? i.pfValue : i.value : null;
    !i || !i.bypass ? this.applyBypass(a, e, r) : (i.value = r, i.pfValue != null && (i.pfValue = r), o ? i.strValue = "rgb(" + r.join(",") + ")" : l ? i.strValue = r.join(" ") : i.strValue = "" + r, this.updateStyleHints(a)), this.checkTriggers(a, e, u, r);
  }
};
gp.removeAllBypasses = function(t, e) {
  return this.removeBypasses(t, this.propertyNames, e);
};
gp.removeBypasses = function(t, e, r) {
  for (var n = !0, a = 0; a < t.length; a++) {
    for (var i = t[a], s = {}, o = 0; o < e.length; o++) {
      var l = e[o], u = this.properties[l], c = i.pstyle(u.name);
      if (!(!c || !c.bypass)) {
        var f = "", h = this.parse(l, f, !0), d = s[u.name] = {
          prev: c
        };
        this.applyParsedProperty(i, h), d.next = i.pstyle(u.name);
      }
    }
    this.updateStyleHints(i), r && this.updateTransitions(i, s, n);
  }
};
var y3 = {};
y3.getEmSizeInPixels = function() {
  var t = this.containerCss("font-size");
  return t != null ? parseFloat(t) : 1;
};
y3.containerCss = function(t) {
  var e = this._private.cy, r = e.container(), n = e.window();
  if (n && r && n.getComputedStyle)
    return n.getComputedStyle(r).getPropertyValue(t);
};
var ys = {};
ys.getRenderedStyle = function(t, e) {
  return e ? this.getStylePropertyValue(t, e, !0) : this.getRawStyle(t, !0);
};
ys.getRawStyle = function(t, e) {
  var r = this;
  if (t = t[0], t) {
    for (var n = {}, a = 0; a < r.properties.length; a++) {
      var i = r.properties[a], s = r.getStylePropertyValue(t, i.name, e);
      s != null && (n[i.name] = s, n[X1(i.name)] = s);
    }
    return n;
  }
};
ys.getIndexedStyle = function(t, e, r, n) {
  var a = t.pstyle(e)[r][n];
  return a ?? t.cy().style().getDefaultProperty(e)[r][0];
};
ys.getStylePropertyValue = function(t, e, r) {
  var n = this;
  if (t = t[0], t) {
    var a = n.properties[e];
    a.alias && (a = a.pointsTo);
    var i = a.type, s = t.pstyle(a.name);
    if (s) {
      var o = s.value, l = s.units, u = s.strValue;
      if (r && i.number && o != null && tt(o)) {
        var c = t.cy().zoom(), f = function(v) {
          return v * c;
        }, h = function(v, m) {
          return f(v) + m;
        }, d = Sr(o), p = d ? l.every(function(g) {
          return g != null;
        }) : l != null;
        return p ? d ? o.map(function(g, v) {
          return h(g, l[v]);
        }).join(" ") : h(o, l) : d ? o.map(function(g) {
          return xt(g) ? g : "" + f(g);
        }).join(" ") : "" + f(o);
      } else if (u != null)
        return u;
    }
    return null;
  }
};
ys.getAnimationStartStyle = function(t, e) {
  for (var r = {}, n = 0; n < e.length; n++) {
    var a = e[n], i = a.name, s = t.pstyle(i);
    s !== void 0 && (Qt(s) ? s = this.parse(i, s.strValue) : s = this.parse(i, s)), s && (r[i] = s);
  }
  return r;
};
ys.getPropsList = function(t) {
  var e = this, r = [], n = t, a = e.properties;
  if (n)
    for (var i = Object.keys(n), s = 0; s < i.length; s++) {
      var o = i[s], l = n[o], u = a[o] || a[n3(o)], c = this.parse(u.name, l);
      c && r.push(c);
    }
  return r;
};
ys.getNonDefaultPropertiesHash = function(t, e, r) {
  var n = r.slice(), a, i, s, o, l, u;
  for (l = 0; l < e.length; l++)
    if (a = e[l], i = t.pstyle(a, !1), i != null)
      if (i.pfValue != null)
        n[0] = s0(o, n[0]), n[1] = o0(o, n[1]);
      else
        for (s = i.strValue, u = 0; u < s.length; u++)
          o = s.charCodeAt(u), n[0] = s0(o, n[0]), n[1] = o0(o, n[1]);
  return n;
};
ys.getPropertiesHash = ys.getNonDefaultPropertiesHash;
var lb = {};
lb.appendFromJson = function(t) {
  for (var e = this, r = 0; r < t.length; r++) {
    var n = t[r], a = n.selector, i = n.style || n.css, s = Object.keys(i);
    e.selector(a);
    for (var o = 0; o < s.length; o++) {
      var l = s[o], u = i[l];
      e.css(l, u);
    }
  }
  return e;
};
lb.fromJson = function(t) {
  var e = this;
  return e.resetToDefault(), e.appendFromJson(t), e;
};
lb.json = function() {
  for (var t = [], e = this.defaultLength; e < this.length; e++) {
    for (var r = this[e], n = r.selector, a = r.properties, i = {}, s = 0; s < a.length; s++) {
      var o = a[s];
      i[o.name] = o.strValue;
    }
    t.push({
      selector: n ? n.toString() : "core",
      style: i
    });
  }
  return t;
};
var b3 = {};
b3.appendFromString = function(t) {
  var e = this, r = this, n = "" + t, a, i, s;
  n = n.replace(/[/][*](\s|.)+?[*][/]/g, "");
  function o() {
    n.length > a.length ? n = n.substr(a.length) : n = "";
  }
  function l() {
    i.length > s.length ? i = i.substr(s.length) : i = "";
  }
  for (; ; ) {
    var u = n.match(/^\s*$/);
    if (u)
      break;
    var c = n.match(/^\s*((?:.|\s)+?)\s*\{((?:.|\s)+?)\}/);
    if (!c) {
      pr("Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: " + n);
      break;
    }
    a = c[0];
    var f = c[1];
    if (f !== "core") {
      var h = new Ko(f);
      if (h.invalid) {
        pr("Skipping parsing of block: Invalid selector found in string stylesheet: " + f), o();
        continue;
      }
    }
    var d = c[2], p = !1;
    i = d;
    for (var g = []; ; ) {
      var v = i.match(/^\s*$/);
      if (v)
        break;
      var m = i.match(/^\s*(.+?)\s*:\s*(.+?)(?:\s*;|\s*$)/);
      if (!m) {
        pr("Skipping parsing of block: Invalid formatting of style property and value definitions found in:" + d), p = !0;
        break;
      }
      s = m[0];
      var b = m[1], y = m[2], x = e.properties[b];
      if (!x) {
        pr("Skipping property: Invalid property name in: " + s), l();
        continue;
      }
      var E = r.parse(b, y);
      if (!E) {
        pr("Skipping property: Invalid property definition in: " + s), l();
        continue;
      }
      g.push({
        name: b,
        val: y
      }), l();
    }
    if (p) {
      o();
      break;
    }
    r.selector(f);
    for (var S = 0; S < g.length; S++) {
      var w = g[S];
      r.css(w.name, w.val);
    }
    o();
  }
  return r;
};
b3.fromString = function(t) {
  var e = this;
  return e.resetToDefault(), e.appendFromString(t), e;
};
var on = {};
(function() {
  var t = mn, e = rwe, r = awe, n = iwe, a = swe, i = function(X) {
    return "^" + X + "\\s*\\(\\s*([\\w\\.]+)\\s*\\)$";
  }, s = function(X) {
    var W = t + "|\\w+|" + e + "|" + r + "|" + n + "|" + a;
    return "^" + X + "\\s*\\(([\\w\\.]+)\\s*\\,\\s*(" + t + ")\\s*\\,\\s*(" + t + ")\\s*,\\s*(" + W + ")\\s*\\,\\s*(" + W + ")\\)$";
  }, o = [`^url\\s*\\(\\s*['"]?(.+?)['"]?\\s*\\)$`, "^(none)$", "^(.+)$"];
  on.types = {
    time: {
      number: !0,
      min: 0,
      units: "s|ms",
      implicitUnits: "ms"
    },
    percent: {
      number: !0,
      min: 0,
      max: 100,
      units: "%",
      implicitUnits: "%"
    },
    percentages: {
      number: !0,
      min: 0,
      max: 100,
      units: "%",
      implicitUnits: "%",
      multiple: !0
    },
    zeroOneNumber: {
      number: !0,
      min: 0,
      max: 1,
      unitless: !0
    },
    zeroOneNumbers: {
      number: !0,
      min: 0,
      max: 1,
      unitless: !0,
      multiple: !0
    },
    nOneOneNumber: {
      number: !0,
      min: -1,
      max: 1,
      unitless: !0
    },
    nonNegativeInt: {
      number: !0,
      min: 0,
      integer: !0,
      unitless: !0
    },
    nonNegativeNumber: {
      number: !0,
      min: 0,
      unitless: !0
    },
    position: {
      enums: ["parent", "origin"]
    },
    nodeSize: {
      number: !0,
      min: 0,
      enums: ["label"]
    },
    number: {
      number: !0,
      unitless: !0
    },
    numbers: {
      number: !0,
      unitless: !0,
      multiple: !0
    },
    positiveNumber: {
      number: !0,
      unitless: !0,
      min: 0,
      strictMin: !0
    },
    size: {
      number: !0,
      min: 0
    },
    bidirectionalSize: {
      number: !0
    },
    // allows negative
    bidirectionalSizeMaybePercent: {
      number: !0,
      allowPercent: !0
    },
    // allows negative
    bidirectionalSizes: {
      number: !0,
      multiple: !0
    },
    // allows negative
    sizeMaybePercent: {
      number: !0,
      min: 0,
      allowPercent: !0
    },
    axisDirection: {
      enums: ["horizontal", "leftward", "rightward", "vertical", "upward", "downward", "auto"]
    },
    axisDirectionExplicit: {
      enums: ["leftward", "rightward", "upward", "downward"]
    },
    axisDirectionPrimary: {
      enums: ["horizontal", "vertical"]
    },
    paddingRelativeTo: {
      enums: ["width", "height", "average", "min", "max"]
    },
    bgWH: {
      number: !0,
      min: 0,
      allowPercent: !0,
      enums: ["auto"],
      multiple: !0
    },
    bgPos: {
      number: !0,
      allowPercent: !0,
      multiple: !0
    },
    bgRelativeTo: {
      enums: ["inner", "include-padding"],
      multiple: !0
    },
    bgRepeat: {
      enums: ["repeat", "repeat-x", "repeat-y", "no-repeat"],
      multiple: !0
    },
    bgFit: {
      enums: ["none", "contain", "cover"],
      multiple: !0
    },
    bgCrossOrigin: {
      enums: ["anonymous", "use-credentials", "null"],
      multiple: !0
    },
    bgClip: {
      enums: ["none", "node"],
      multiple: !0
    },
    bgContainment: {
      enums: ["inside", "over"],
      multiple: !0
    },
    boxSelection: {
      enums: ["contain", "overlap", "none"]
    },
    color: {
      color: !0
    },
    colors: {
      color: !0,
      multiple: !0
    },
    fill: {
      enums: ["solid", "linear-gradient", "radial-gradient"]
    },
    bool: {
      enums: ["yes", "no"]
    },
    bools: {
      enums: ["yes", "no"],
      multiple: !0
    },
    lineStyle: {
      enums: ["solid", "dotted", "dashed"]
    },
    lineCap: {
      enums: ["butt", "round", "square"]
    },
    linePosition: {
      enums: ["center", "inside", "outside"]
    },
    lineJoin: {
      enums: ["round", "bevel", "miter"]
    },
    borderStyle: {
      enums: ["solid", "dotted", "dashed", "double"]
    },
    curveStyle: {
      enums: ["bezier", "unbundled-bezier", "haystack", "segments", "straight", "straight-triangle", "taxi", "round-segments", "round-taxi"]
    },
    radiusType: {
      enums: ["arc-radius", "influence-radius"],
      multiple: !0
    },
    fontFamily: {
      regex: '^([\\w- \\"]+(?:\\s*,\\s*[\\w- \\"]+)*)$'
    },
    fontStyle: {
      enums: ["italic", "normal", "oblique"]
    },
    fontWeight: {
      enums: ["normal", "bold", "bolder", "lighter", "100", "200", "300", "400", "500", "600", "800", "900", 100, 200, 300, 400, 500, 600, 700, 800, 900]
    },
    textDecoration: {
      enums: ["none", "underline", "overline", "line-through"]
    },
    textTransform: {
      enums: ["none", "uppercase", "lowercase"]
    },
    textWrap: {
      enums: ["none", "wrap", "ellipsis"]
    },
    textOverflowWrap: {
      enums: ["whitespace", "anywhere"]
    },
    textBackgroundShape: {
      enums: ["rectangle", "roundrectangle", "round-rectangle", "circle"]
    },
    nodeShape: {
      enums: ["rectangle", "roundrectangle", "round-rectangle", "cutrectangle", "cut-rectangle", "bottomroundrectangle", "bottom-round-rectangle", "barrel", "ellipse", "triangle", "round-triangle", "square", "pentagon", "round-pentagon", "hexagon", "round-hexagon", "concavehexagon", "concave-hexagon", "heptagon", "round-heptagon", "octagon", "round-octagon", "tag", "round-tag", "star", "diamond", "round-diamond", "vee", "rhomboid", "right-rhomboid", "polygon"]
    },
    overlayShape: {
      enums: ["roundrectangle", "round-rectangle", "ellipse"]
    },
    cornerRadius: {
      number: !0,
      min: 0,
      units: "px|em",
      implicitUnits: "px",
      enums: ["auto"]
    },
    compoundIncludeLabels: {
      enums: ["include", "exclude"]
    },
    arrowShape: {
      enums: ["tee", "triangle", "triangle-tee", "circle-triangle", "triangle-cross", "triangle-backcurve", "vee", "square", "circle", "diamond", "chevron", "none"]
    },
    arrowFill: {
      enums: ["filled", "hollow"]
    },
    arrowWidth: {
      number: !0,
      units: "%|px|em",
      implicitUnits: "px",
      enums: ["match-line"]
    },
    display: {
      enums: ["element", "none"]
    },
    visibility: {
      enums: ["hidden", "visible"]
    },
    zCompoundDepth: {
      enums: ["bottom", "orphan", "auto", "top"]
    },
    zIndexCompare: {
      enums: ["auto", "manual"]
    },
    valign: {
      enums: ["top", "center", "bottom"]
    },
    halign: {
      enums: ["left", "center", "right"]
    },
    justification: {
      enums: ["left", "center", "right", "auto"]
    },
    text: {
      string: !0
    },
    data: {
      mapping: !0,
      regex: i("data")
    },
    layoutData: {
      mapping: !0,
      regex: i("layoutData")
    },
    scratch: {
      mapping: !0,
      regex: i("scratch")
    },
    mapData: {
      mapping: !0,
      regex: s("mapData")
    },
    mapLayoutData: {
      mapping: !0,
      regex: s("mapLayoutData")
    },
    mapScratch: {
      mapping: !0,
      regex: s("mapScratch")
    },
    fn: {
      mapping: !0,
      fn: !0
    },
    url: {
      regexes: o,
      singleRegexMatchValue: !0
    },
    urls: {
      regexes: o,
      singleRegexMatchValue: !0,
      multiple: !0
    },
    propList: {
      propList: !0
    },
    angle: {
      number: !0,
      units: "deg|rad",
      implicitUnits: "rad"
    },
    textRotation: {
      number: !0,
      units: "deg|rad",
      implicitUnits: "rad",
      enums: ["none", "autorotate"]
    },
    polygonPointList: {
      number: !0,
      multiple: !0,
      evenMultiple: !0,
      min: -1,
      max: 1,
      unitless: !0
    },
    edgeDistances: {
      enums: ["intersection", "node-position", "endpoints"]
    },
    edgeEndpoint: {
      number: !0,
      multiple: !0,
      units: "%|px|em|deg|rad",
      implicitUnits: "px",
      enums: ["inside-to-node", "outside-to-node", "outside-to-node-or-label", "outside-to-line", "outside-to-line-or-label"],
      singleEnum: !0,
      validate: function(X, W) {
        switch (X.length) {
          case 2:
            return W[0] !== "deg" && W[0] !== "rad" && W[1] !== "deg" && W[1] !== "rad";
          case 1:
            return xt(X[0]) || W[0] === "deg" || W[0] === "rad";
          default:
            return !1;
        }
      }
    },
    easing: {
      regexes: ["^(spring)\\s*\\(\\s*(" + t + ")\\s*,\\s*(" + t + ")\\s*\\)$", "^(cubic-bezier)\\s*\\(\\s*(" + t + ")\\s*,\\s*(" + t + ")\\s*,\\s*(" + t + ")\\s*,\\s*(" + t + ")\\s*\\)$"],
      enums: ["linear", "ease", "ease-in", "ease-out", "ease-in-out", "ease-in-sine", "ease-out-sine", "ease-in-out-sine", "ease-in-quad", "ease-out-quad", "ease-in-out-quad", "ease-in-cubic", "ease-out-cubic", "ease-in-out-cubic", "ease-in-quart", "ease-out-quart", "ease-in-out-quart", "ease-in-quint", "ease-out-quint", "ease-in-out-quint", "ease-in-expo", "ease-out-expo", "ease-in-out-expo", "ease-in-circ", "ease-out-circ", "ease-in-out-circ"]
    },
    gradientDirection: {
      enums: [
        "to-bottom",
        "to-top",
        "to-left",
        "to-right",
        "to-bottom-right",
        "to-bottom-left",
        "to-top-right",
        "to-top-left",
        "to-right-bottom",
        "to-left-bottom",
        "to-right-top",
        "to-left-top"
        // different order
      ]
    },
    boundsExpansion: {
      number: !0,
      multiple: !0,
      min: 0,
      validate: function(X) {
        var W = X.length;
        return W === 1 || W === 2 || W === 4;
      }
    }
  };
  var l = {
    zeroNonZero: function(X, W) {
      return (X == null || W == null) && X !== W || X == 0 && W != 0 ? !0 : X != 0 && W == 0;
    },
    any: function(X, W) {
      return X != W;
    },
    emptyNonEmpty: function(X, W) {
      var ue = jo(X), J = jo(W);
      return ue && !J || !ue && J;
    }
  }, u = on.types, c = [{
    name: "label",
    type: u.text,
    triggersBounds: l.any,
    triggersZOrder: l.emptyNonEmpty
  }, {
    name: "text-rotation",
    type: u.textRotation,
    triggersBounds: l.any
  }, {
    name: "text-margin-x",
    type: u.bidirectionalSize,
    triggersBounds: l.any
  }, {
    name: "text-margin-y",
    type: u.bidirectionalSize,
    triggersBounds: l.any
  }], f = [{
    name: "source-label",
    type: u.text,
    triggersBounds: l.any
  }, {
    name: "source-text-rotation",
    type: u.textRotation,
    triggersBounds: l.any
  }, {
    name: "source-text-margin-x",
    type: u.bidirectionalSize,
    triggersBounds: l.any
  }, {
    name: "source-text-margin-y",
    type: u.bidirectionalSize,
    triggersBounds: l.any
  }, {
    name: "source-text-offset",
    type: u.size,
    triggersBounds: l.any
  }], h = [{
    name: "target-label",
    type: u.text,
    triggersBounds: l.any
  }, {
    name: "target-text-rotation",
    type: u.textRotation,
    triggersBounds: l.any
  }, {
    name: "target-text-margin-x",
    type: u.bidirectionalSize,
    triggersBounds: l.any
  }, {
    name: "target-text-margin-y",
    type: u.bidirectionalSize,
    triggersBounds: l.any
  }, {
    name: "target-text-offset",
    type: u.size,
    triggersBounds: l.any
  }], d = [{
    name: "font-family",
    type: u.fontFamily,
    triggersBounds: l.any
  }, {
    name: "font-style",
    type: u.fontStyle,
    triggersBounds: l.any
  }, {
    name: "font-weight",
    type: u.fontWeight,
    triggersBounds: l.any
  }, {
    name: "font-size",
    type: u.size,
    triggersBounds: l.any
  }, {
    name: "text-transform",
    type: u.textTransform,
    triggersBounds: l.any
  }, {
    name: "text-wrap",
    type: u.textWrap,
    triggersBounds: l.any
  }, {
    name: "text-overflow-wrap",
    type: u.textOverflowWrap,
    triggersBounds: l.any
  }, {
    name: "text-max-width",
    type: u.size,
    triggersBounds: l.any
  }, {
    name: "text-outline-width",
    type: u.size,
    triggersBounds: l.any
  }, {
    name: "line-height",
    type: u.positiveNumber,
    triggersBounds: l.any
  }], p = [{
    name: "text-valign",
    type: u.valign,
    triggersBounds: l.any
  }, {
    name: "text-halign",
    type: u.halign,
    triggersBounds: l.any
  }, {
    name: "color",
    type: u.color
  }, {
    name: "text-outline-color",
    type: u.color
  }, {
    name: "text-outline-opacity",
    type: u.zeroOneNumber
  }, {
    name: "text-background-color",
    type: u.color
  }, {
    name: "text-background-opacity",
    type: u.zeroOneNumber
  }, {
    name: "text-background-padding",
    type: u.size,
    triggersBounds: l.any
  }, {
    name: "text-border-opacity",
    type: u.zeroOneNumber
  }, {
    name: "text-border-color",
    type: u.color
  }, {
    name: "text-border-width",
    type: u.size,
    triggersBounds: l.any
  }, {
    name: "text-border-style",
    type: u.borderStyle,
    triggersBounds: l.any
  }, {
    name: "text-background-shape",
    type: u.textBackgroundShape,
    triggersBounds: l.any
  }, {
    name: "text-justification",
    type: u.justification
  }, {
    name: "box-select-labels",
    type: u.bool,
    triggersBounds: l.any
  }], g = [{
    name: "events",
    type: u.bool,
    triggersZOrder: l.any
  }, {
    name: "text-events",
    type: u.bool,
    triggersZOrder: l.any
  }, {
    name: "box-selection",
    type: u.boxSelection,
    triggersZOrder: l.any
  }], v = [{
    name: "display",
    type: u.display,
    triggersZOrder: l.any,
    triggersBounds: l.any,
    triggersBoundsOfConnectedEdges: l.any,
    triggersBoundsOfParallelEdges: function(X, W, ue) {
      return X === W ? !1 : ue.pstyle("curve-style").value === "bezier";
    }
  }, {
    name: "visibility",
    type: u.visibility,
    triggersZOrder: l.any
  }, {
    name: "opacity",
    type: u.zeroOneNumber,
    triggersZOrder: l.zeroNonZero
  }, {
    name: "text-opacity",
    type: u.zeroOneNumber
  }, {
    name: "min-zoomed-font-size",
    type: u.size
  }, {
    name: "z-compound-depth",
    type: u.zCompoundDepth,
    triggersZOrder: l.any
  }, {
    name: "z-index-compare",
    type: u.zIndexCompare,
    triggersZOrder: l.any
  }, {
    name: "z-index",
    type: u.number,
    triggersZOrder: l.any
  }], m = [{
    name: "overlay-padding",
    type: u.size,
    triggersBounds: l.any
  }, {
    name: "overlay-color",
    type: u.color
  }, {
    name: "overlay-opacity",
    type: u.zeroOneNumber,
    triggersBounds: l.zeroNonZero
  }, {
    name: "overlay-shape",
    type: u.overlayShape,
    triggersBounds: l.any
  }, {
    name: "overlay-corner-radius",
    type: u.cornerRadius
  }], b = [{
    name: "underlay-padding",
    type: u.size,
    triggersBounds: l.any
  }, {
    name: "underlay-color",
    type: u.color
  }, {
    name: "underlay-opacity",
    type: u.zeroOneNumber,
    triggersBounds: l.zeroNonZero
  }, {
    name: "underlay-shape",
    type: u.overlayShape,
    triggersBounds: l.any
  }, {
    name: "underlay-corner-radius",
    type: u.cornerRadius
  }], y = [{
    name: "transition-property",
    type: u.propList
  }, {
    name: "transition-duration",
    type: u.time
  }, {
    name: "transition-delay",
    type: u.time
  }, {
    name: "transition-timing-function",
    type: u.easing
  }], x = function(X, W) {
    return W.value === "label" ? -X.poolIndex() : W.pfValue;
  }, E = [{
    name: "height",
    type: u.nodeSize,
    triggersBounds: l.any,
    hashOverride: x
  }, {
    name: "width",
    type: u.nodeSize,
    triggersBounds: l.any,
    hashOverride: x
  }, {
    name: "shape",
    type: u.nodeShape,
    triggersBounds: l.any
  }, {
    name: "shape-polygon-points",
    type: u.polygonPointList,
    triggersBounds: l.any
  }, {
    name: "corner-radius",
    type: u.cornerRadius
  }, {
    name: "background-color",
    type: u.color
  }, {
    name: "background-fill",
    type: u.fill
  }, {
    name: "background-opacity",
    type: u.zeroOneNumber
  }, {
    name: "background-blacken",
    type: u.nOneOneNumber
  }, {
    name: "background-gradient-stop-colors",
    type: u.colors
  }, {
    name: "background-gradient-stop-positions",
    type: u.percentages
  }, {
    name: "background-gradient-direction",
    type: u.gradientDirection
  }, {
    name: "padding",
    type: u.sizeMaybePercent,
    triggersBounds: l.any
  }, {
    name: "padding-relative-to",
    type: u.paddingRelativeTo,
    triggersBounds: l.any
  }, {
    name: "bounds-expansion",
    type: u.boundsExpansion,
    triggersBounds: l.any
  }], S = [{
    name: "border-color",
    type: u.color
  }, {
    name: "border-opacity",
    type: u.zeroOneNumber
  }, {
    name: "border-width",
    type: u.size,
    triggersBounds: l.any
  }, {
    name: "border-style",
    type: u.borderStyle
  }, {
    name: "border-cap",
    type: u.lineCap
  }, {
    name: "border-join",
    type: u.lineJoin
  }, {
    name: "border-dash-pattern",
    type: u.numbers
  }, {
    name: "border-dash-offset",
    type: u.number
  }, {
    name: "border-position",
    type: u.linePosition
  }], w = [{
    name: "outline-color",
    type: u.color
  }, {
    name: "outline-opacity",
    type: u.zeroOneNumber
  }, {
    name: "outline-width",
    type: u.size,
    triggersBounds: l.any
  }, {
    name: "outline-style",
    type: u.borderStyle
  }, {
    name: "outline-offset",
    type: u.size,
    triggersBounds: l.any
  }], C = [{
    name: "background-image",
    type: u.urls
  }, {
    name: "background-image-crossorigin",
    type: u.bgCrossOrigin
  }, {
    name: "background-image-opacity",
    type: u.zeroOneNumbers
  }, {
    name: "background-image-containment",
    type: u.bgContainment
  }, {
    name: "background-image-smoothing",
    type: u.bools
  }, {
    name: "background-position-x",
    type: u.bgPos
  }, {
    name: "background-position-y",
    type: u.bgPos
  }, {
    name: "background-width-relative-to",
    type: u.bgRelativeTo
  }, {
    name: "background-height-relative-to",
    type: u.bgRelativeTo
  }, {
    name: "background-repeat",
    type: u.bgRepeat
  }, {
    name: "background-fit",
    type: u.bgFit
  }, {
    name: "background-clip",
    type: u.bgClip
  }, {
    name: "background-width",
    type: u.bgWH
  }, {
    name: "background-height",
    type: u.bgWH
  }, {
    name: "background-offset-x",
    type: u.bgPos
  }, {
    name: "background-offset-y",
    type: u.bgPos
  }], k = [{
    name: "position",
    type: u.position,
    triggersBounds: l.any
  }, {
    name: "compound-sizing-wrt-labels",
    type: u.compoundIncludeLabels,
    triggersBounds: l.any
  }, {
    name: "min-width",
    type: u.size,
    triggersBounds: l.any
  }, {
    name: "min-width-bias-left",
    type: u.sizeMaybePercent,
    triggersBounds: l.any
  }, {
    name: "min-width-bias-right",
    type: u.sizeMaybePercent,
    triggersBounds: l.any
  }, {
    name: "min-height",
    type: u.size,
    triggersBounds: l.any
  }, {
    name: "min-height-bias-top",
    type: u.sizeMaybePercent,
    triggersBounds: l.any
  }, {
    name: "min-height-bias-bottom",
    type: u.sizeMaybePercent,
    triggersBounds: l.any
  }], N = [{
    name: "line-style",
    type: u.lineStyle
  }, {
    name: "line-color",
    type: u.color
  }, {
    name: "line-fill",
    type: u.fill
  }, {
    name: "line-cap",
    type: u.lineCap
  }, {
    name: "line-opacity",
    type: u.zeroOneNumber
  }, {
    name: "line-dash-pattern",
    type: u.numbers
  }, {
    name: "line-dash-offset",
    type: u.number
  }, {
    name: "line-outline-width",
    type: u.size
  }, {
    name: "line-outline-color",
    type: u.color
  }, {
    name: "line-gradient-stop-colors",
    type: u.colors
  }, {
    name: "line-gradient-stop-positions",
    type: u.percentages
  }, {
    name: "curve-style",
    type: u.curveStyle,
    triggersBounds: l.any,
    triggersBoundsOfParallelEdges: function(X, W) {
      return X === W ? !1 : X === "bezier" || // remove from bundle
      W === "bezier";
    }
  }, {
    name: "haystack-radius",
    type: u.zeroOneNumber,
    triggersBounds: l.any
  }, {
    name: "source-endpoint",
    type: u.edgeEndpoint,
    triggersBounds: l.any
  }, {
    name: "target-endpoint",
    type: u.edgeEndpoint,
    triggersBounds: l.any
  }, {
    name: "control-point-step-size",
    type: u.size,
    triggersBounds: l.any
  }, {
    name: "control-point-distances",
    type: u.bidirectionalSizes,
    triggersBounds: l.any
  }, {
    name: "control-point-weights",
    type: u.numbers,
    triggersBounds: l.any
  }, {
    name: "segment-distances",
    type: u.bidirectionalSizes,
    triggersBounds: l.any
  }, {
    name: "segment-weights",
    type: u.numbers,
    triggersBounds: l.any
  }, {
    name: "segment-radii",
    type: u.numbers,
    triggersBounds: l.any
  }, {
    name: "radius-type",
    type: u.radiusType,
    triggersBounds: l.any
  }, {
    name: "taxi-turn",
    type: u.bidirectionalSizeMaybePercent,
    triggersBounds: l.any
  }, {
    name: "taxi-turn-min-distance",
    type: u.size,
    triggersBounds: l.any
  }, {
    name: "taxi-direction",
    type: u.axisDirection,
    triggersBounds: l.any
  }, {
    name: "taxi-radius",
    type: u.number,
    triggersBounds: l.any
  }, {
    name: "edge-distances",
    type: u.edgeDistances,
    triggersBounds: l.any
  }, {
    name: "arrow-scale",
    type: u.positiveNumber,
    triggersBounds: l.any
  }, {
    name: "loop-direction",
    type: u.angle,
    triggersBounds: l.any
  }, {
    name: "loop-sweep",
    type: u.angle,
    triggersBounds: l.any
  }, {
    name: "source-distance-from-node",
    type: u.size,
    triggersBounds: l.any
  }, {
    name: "target-distance-from-node",
    type: u.size,
    triggersBounds: l.any
  }], R = [{
    name: "ghost",
    type: u.bool,
    triggersBounds: l.any
  }, {
    name: "ghost-offset-x",
    type: u.bidirectionalSize,
    triggersBounds: l.any
  }, {
    name: "ghost-offset-y",
    type: u.bidirectionalSize,
    triggersBounds: l.any
  }, {
    name: "ghost-opacity",
    type: u.zeroOneNumber
  }], _ = [{
    name: "selection-box-color",
    type: u.color
  }, {
    name: "selection-box-opacity",
    type: u.zeroOneNumber
  }, {
    name: "selection-box-border-color",
    type: u.color
  }, {
    name: "selection-box-border-width",
    type: u.size
  }, {
    name: "active-bg-color",
    type: u.color
  }, {
    name: "active-bg-opacity",
    type: u.zeroOneNumber
  }, {
    name: "active-bg-size",
    type: u.size
  }, {
    name: "outside-texture-bg-color",
    type: u.color
  }, {
    name: "outside-texture-bg-opacity",
    type: u.zeroOneNumber
  }], O = [];
  on.pieBackgroundN = 16, O.push({
    name: "pie-size",
    type: u.sizeMaybePercent
  }), O.push({
    name: "pie-hole",
    type: u.sizeMaybePercent
  }), O.push({
    name: "pie-start-angle",
    type: u.angle
  });
  for (var T = 1; T <= on.pieBackgroundN; T++)
    O.push({
      name: "pie-" + T + "-background-color",
      type: u.color
    }), O.push({
      name: "pie-" + T + "-background-size",
      type: u.percent
    }), O.push({
      name: "pie-" + T + "-background-opacity",
      type: u.zeroOneNumber
    });
  var L = [];
  on.stripeBackgroundN = 16, L.push({
    name: "stripe-size",
    type: u.sizeMaybePercent
  }), L.push({
    name: "stripe-direction",
    type: u.axisDirectionPrimary
  });
  for (var M = 1; M <= on.stripeBackgroundN; M++)
    L.push({
      name: "stripe-" + M + "-background-color",
      type: u.color
    }), L.push({
      name: "stripe-" + M + "-background-size",
      type: u.percent
    }), L.push({
      name: "stripe-" + M + "-background-opacity",
      type: u.zeroOneNumber
    });
  var A = [], I = on.arrowPrefixes = ["source", "mid-source", "target", "mid-target"];
  [{
    name: "arrow-shape",
    type: u.arrowShape,
    triggersBounds: l.any
  }, {
    name: "arrow-color",
    type: u.color
  }, {
    name: "arrow-fill",
    type: u.arrowFill
  }, {
    name: "arrow-width",
    type: u.arrowWidth
  }].forEach(function(q) {
    I.forEach(function(X) {
      var W = X + "-" + q.name, ue = q.type, J = q.triggersBounds;
      A.push({
        name: W,
        type: ue,
        triggersBounds: J
      });
    });
  }, {});
  var D = on.properties = [].concat(g, y, v, m, b, R, p, d, c, f, h, E, S, w, C, O, L, k, N, A, _), F = on.propertyGroups = {
    // common to all eles
    behavior: g,
    transition: y,
    visibility: v,
    overlay: m,
    underlay: b,
    ghost: R,
    // labels
    commonLabel: p,
    labelDimensions: d,
    mainLabel: c,
    sourceLabel: f,
    targetLabel: h,
    // node props
    nodeBody: E,
    nodeBorder: S,
    nodeOutline: w,
    backgroundImage: C,
    pie: O,
    stripe: L,
    compound: k,
    // edge props
    edgeLine: N,
    edgeArrow: A,
    core: _
  }, B = on.propertyGroupNames = {}, G = on.propertyGroupKeys = Object.keys(F);
  G.forEach(function(q) {
    B[q] = F[q].map(function(X) {
      return X.name;
    }), F[q].forEach(function(X) {
      return X.groupKey = q;
    });
  });
  var H = on.aliases = [{
    name: "content",
    pointsTo: "label"
  }, {
    name: "control-point-distance",
    pointsTo: "control-point-distances"
  }, {
    name: "control-point-weight",
    pointsTo: "control-point-weights"
  }, {
    name: "segment-distance",
    pointsTo: "segment-distances"
  }, {
    name: "segment-weight",
    pointsTo: "segment-weights"
  }, {
    name: "segment-radius",
    pointsTo: "segment-radii"
  }, {
    name: "edge-text-rotation",
    pointsTo: "text-rotation"
  }, {
    name: "padding-left",
    pointsTo: "padding"
  }, {
    name: "padding-right",
    pointsTo: "padding"
  }, {
    name: "padding-top",
    pointsTo: "padding"
  }, {
    name: "padding-bottom",
    pointsTo: "padding"
  }];
  on.propertyNames = D.map(function(q) {
    return q.name;
  });
  for (var K = 0; K < D.length; K++) {
    var j = D[K];
    D[j.name] = j;
  }
  for (var Z = 0; Z < H.length; Z++) {
    var te = H[Z], ne = D[te.pointsTo], V = {
      name: te.name,
      alias: !0,
      pointsTo: ne
    };
    D.push(V), D[te.name] = V;
  }
})();
on.getDefaultProperty = function(t) {
  return this.getDefaultProperties()[t];
};
on.getDefaultProperties = function() {
  var t = this._private;
  if (t.defaultProperties != null)
    return t.defaultProperties;
  for (var e = At({
    // core props
    "selection-box-color": "#ddd",
    "selection-box-opacity": 0.65,
    "selection-box-border-color": "#aaa",
    "selection-box-border-width": 1,
    "active-bg-color": "black",
    "active-bg-opacity": 0.15,
    "active-bg-size": 30,
    "outside-texture-bg-color": "#000",
    "outside-texture-bg-opacity": 0.125,
    // common node/edge props
    events: "yes",
    "text-events": "no",
    "text-valign": "top",
    "text-halign": "center",
    "text-justification": "auto",
    "line-height": 1,
    color: "#000",
    "box-selection": "contain",
    "text-outline-color": "#000",
    "text-outline-width": 0,
    "text-outline-opacity": 1,
    "text-opacity": 1,
    "text-decoration": "none",
    "text-transform": "none",
    "text-wrap": "none",
    "text-overflow-wrap": "whitespace",
    "text-max-width": 9999,
    "text-background-color": "#000",
    "text-background-opacity": 0,
    "text-background-shape": "rectangle",
    "text-background-padding": 0,
    "text-border-opacity": 0,
    "text-border-width": 0,
    "text-border-style": "solid",
    "text-border-color": "#000",
    "font-family": "Helvetica Neue, Helvetica, sans-serif",
    "font-style": "normal",
    "font-weight": "normal",
    "font-size": 16,
    "min-zoomed-font-size": 0,
    "text-rotation": "none",
    "source-text-rotation": "none",
    "target-text-rotation": "none",
    visibility: "visible",
    display: "element",
    opacity: 1,
    "z-compound-depth": "auto",
    "z-index-compare": "auto",
    "z-index": 0,
    label: "",
    "text-margin-x": 0,
    "text-margin-y": 0,
    "source-label": "",
    "source-text-offset": 0,
    "source-text-margin-x": 0,
    "source-text-margin-y": 0,
    "target-label": "",
    "target-text-offset": 0,
    "target-text-margin-x": 0,
    "target-text-margin-y": 0,
    "overlay-opacity": 0,
    "overlay-color": "#000",
    "overlay-padding": 10,
    "overlay-shape": "round-rectangle",
    "overlay-corner-radius": "auto",
    "underlay-opacity": 0,
    "underlay-color": "#000",
    "underlay-padding": 10,
    "underlay-shape": "round-rectangle",
    "underlay-corner-radius": "auto",
    "transition-property": "none",
    "transition-duration": 0,
    "transition-delay": 0,
    "transition-timing-function": "linear",
    "box-select-labels": "no",
    // node props
    "background-blacken": 0,
    "background-color": "#999",
    "background-fill": "solid",
    "background-opacity": 1,
    "background-image": "none",
    "background-image-crossorigin": "anonymous",
    "background-image-opacity": 1,
    "background-image-containment": "inside",
    "background-image-smoothing": "yes",
    "background-position-x": "50%",
    "background-position-y": "50%",
    "background-offset-x": 0,
    "background-offset-y": 0,
    "background-width-relative-to": "include-padding",
    "background-height-relative-to": "include-padding",
    "background-repeat": "no-repeat",
    "background-fit": "none",
    "background-clip": "node",
    "background-width": "auto",
    "background-height": "auto",
    "border-color": "#000",
    "border-opacity": 1,
    "border-width": 0,
    "border-style": "solid",
    "border-dash-pattern": [4, 2],
    "border-dash-offset": 0,
    "border-cap": "butt",
    "border-join": "miter",
    "border-position": "center",
    "outline-color": "#999",
    "outline-opacity": 1,
    "outline-width": 0,
    "outline-offset": 0,
    "outline-style": "solid",
    height: 30,
    width: 30,
    shape: "ellipse",
    "shape-polygon-points": "-1, -1,   1, -1,   1, 1,   -1, 1",
    "corner-radius": "auto",
    "bounds-expansion": 0,
    // node gradient
    "background-gradient-direction": "to-bottom",
    "background-gradient-stop-colors": "#999",
    "background-gradient-stop-positions": "0%",
    // ghost props
    ghost: "no",
    "ghost-offset-y": 0,
    "ghost-offset-x": 0,
    "ghost-opacity": 0,
    // compound props
    padding: 0,
    "padding-relative-to": "width",
    position: "origin",
    "compound-sizing-wrt-labels": "include",
    "min-width": 0,
    "min-width-bias-left": 0,
    "min-width-bias-right": 0,
    "min-height": 0,
    "min-height-bias-top": 0,
    "min-height-bias-bottom": 0
  }, {
    // node pie bg
    "pie-size": "100%",
    "pie-hole": 0,
    "pie-start-angle": "0deg"
  }, [{
    name: "pie-{{i}}-background-color",
    value: "black"
  }, {
    name: "pie-{{i}}-background-size",
    value: "0%"
  }, {
    name: "pie-{{i}}-background-opacity",
    value: 1
  }].reduce(function(l, u) {
    for (var c = 1; c <= on.pieBackgroundN; c++) {
      var f = u.name.replace("{{i}}", c), h = u.value;
      l[f] = h;
    }
    return l;
  }, {}), {
    // node stripes bg
    "stripe-size": "100%",
    "stripe-direction": "horizontal"
  }, [{
    name: "stripe-{{i}}-background-color",
    value: "black"
  }, {
    name: "stripe-{{i}}-background-size",
    value: "0%"
  }, {
    name: "stripe-{{i}}-background-opacity",
    value: 1
  }].reduce(function(l, u) {
    for (var c = 1; c <= on.stripeBackgroundN; c++) {
      var f = u.name.replace("{{i}}", c), h = u.value;
      l[f] = h;
    }
    return l;
  }, {}), {
    // edge props
    "line-style": "solid",
    "line-color": "#999",
    "line-fill": "solid",
    "line-cap": "butt",
    "line-opacity": 1,
    "line-outline-width": 0,
    "line-outline-color": "#000",
    "line-gradient-stop-colors": "#999",
    "line-gradient-stop-positions": "0%",
    "control-point-step-size": 40,
    "control-point-weights": 0.5,
    "segment-weights": 0.5,
    "segment-distances": 20,
    "segment-radii": 15,
    "radius-type": "arc-radius",
    "taxi-turn": "50%",
    "taxi-radius": 15,
    "taxi-turn-min-distance": 10,
    "taxi-direction": "auto",
    "edge-distances": "intersection",
    "curve-style": "haystack",
    "haystack-radius": 0,
    "arrow-scale": 1,
    "loop-direction": "-45deg",
    "loop-sweep": "-90deg",
    "source-distance-from-node": 0,
    "target-distance-from-node": 0,
    "source-endpoint": "outside-to-node",
    "target-endpoint": "outside-to-node",
    "line-dash-pattern": [6, 3],
    "line-dash-offset": 0
  }, [{
    name: "arrow-shape",
    value: "none"
  }, {
    name: "arrow-color",
    value: "#999"
  }, {
    name: "arrow-fill",
    value: "filled"
  }, {
    name: "arrow-width",
    value: 1
  }].reduce(function(l, u) {
    return on.arrowPrefixes.forEach(function(c) {
      var f = c + "-" + u.name, h = u.value;
      l[f] = h;
    }), l;
  }, {})), r = {}, n = 0; n < this.properties.length; n++) {
    var a = this.properties[n];
    if (!a.pointsTo) {
      var i = a.name, s = e[i], o = this.parse(i, s);
      r[i] = o;
    }
  }
  return t.defaultProperties = r, t.defaultProperties;
};
on.addDefaultStylesheet = function() {
  this.selector(":parent").css({
    shape: "rectangle",
    padding: 10,
    "background-color": "#eee",
    "border-color": "#ccc",
    "border-width": 1
  }).selector("edge").css({
    width: 3
  }).selector(":loop").css({
    "curve-style": "bezier"
  }).selector("edge:compound").css({
    "curve-style": "bezier",
    "source-endpoint": "outside-to-line",
    "target-endpoint": "outside-to-line"
  }).selector(":selected").css({
    "background-color": "#0169D9",
    "line-color": "#0169D9",
    "source-arrow-color": "#0169D9",
    "target-arrow-color": "#0169D9",
    "mid-source-arrow-color": "#0169D9",
    "mid-target-arrow-color": "#0169D9"
  }).selector(":parent:selected").css({
    "background-color": "#CCE1F9",
    "border-color": "#aec8e5"
  }).selector(":active").css({
    "overlay-color": "black",
    "overlay-padding": 10,
    "overlay-opacity": 0.25
  }), this.defaultLength = this.length;
};
var ub = {};
ub.parse = function(t, e, r, n) {
  var a = this;
  if (Wr(e))
    return a.parseImplWarn(t, e, r, n);
  var i = n === "mapping" || n === !0 || n === !1 || n == null ? "dontcare" : n, s = r ? "t" : "f", o = "" + e, l = $B(t, o, s, i), u = a.propCache = a.propCache || [], c;
  return (c = u[l]) || (c = u[l] = a.parseImplWarn(t, e, r, n)), (r || n === "mapping") && (c = ds(c), c && (c.value = ds(c.value))), c;
};
ub.parseImplWarn = function(t, e, r, n) {
  var a = this.parseImpl(t, e, r, n);
  return !a && e != null && pr("The style property `".concat(t, ": ").concat(e, "` is invalid")), a && (a.name === "width" || a.name === "height") && e === "label" && pr("The style value of `label` is deprecated for `" + a.name + "`"), a;
};
ub.parseImpl = function(t, e, r, n) {
  var a = this;
  t = n3(t);
  var i = a.properties[t], s = e, o = a.types;
  if (!i || e === void 0)
    return null;
  i.alias && (i = i.pointsTo, t = i.name);
  var l = xt(e);
  l && (e = e.trim());
  var u = i.type;
  if (!u)
    return null;
  if (r && (e === "" || e === null))
    return {
      name: t,
      value: e,
      bypass: !0,
      deleteBypass: !0
    };
  if (Wr(e))
    return {
      name: t,
      value: e,
      strValue: "fn",
      mapped: o.fn,
      bypass: r
    };
  var c, f;
  if (!(!l || n || e.length < 7 || e[1] !== "a")) {
    if (e.length >= 7 && e[0] === "d" && (c = new RegExp(o.data.regex).exec(e))) {
      if (r)
        return !1;
      var h = o.data;
      return {
        name: t,
        value: c,
        strValue: "" + e,
        mapped: h,
        field: c[1],
        bypass: r
      };
    } else if (e.length >= 10 && e[0] === "m" && (f = new RegExp(o.mapData.regex).exec(e))) {
      if (r || u.multiple)
        return !1;
      var d = o.mapData;
      if (!(u.color || u.number))
        return !1;
      var p = this.parse(t, f[4]);
      if (!p || p.mapped)
        return !1;
      var g = this.parse(t, f[5]);
      if (!g || g.mapped)
        return !1;
      if (p.pfValue === g.pfValue || p.strValue === g.strValue)
        return pr("`" + t + ": " + e + "` is not a valid mapper because the output range is zero; converting to `" + t + ": " + p.strValue + "`"), this.parse(t, p.strValue);
      if (u.color) {
        var v = p.value, m = g.value, b = v[0] === m[0] && v[1] === m[1] && v[2] === m[2] && // optional alpha
        (v[3] === m[3] || (v[3] == null || v[3] === 1) && (m[3] == null || m[3] === 1));
        if (b)
          return !1;
      }
      return {
        name: t,
        value: f,
        strValue: "" + e,
        mapped: d,
        field: f[1],
        fieldMin: parseFloat(f[2]),
        // min & max are numeric
        fieldMax: parseFloat(f[3]),
        valueMin: p.value,
        valueMax: g.value,
        bypass: r
      };
    }
  }
  if (u.multiple && n !== "multiple") {
    var y;
    if (l ? y = e.split(/\s+/) : Sr(e) ? y = e : y = [e], u.evenMultiple && y.length % 2 !== 0)
      return null;
    for (var x = [], E = [], S = [], w = "", C = !1, k = 0; k < y.length; k++) {
      var N = a.parse(t, y[k], r, "multiple");
      C = C || xt(N.value), x.push(N.value), S.push(N.pfValue != null ? N.pfValue : N.value), E.push(N.units), w += (k > 0 ? " " : "") + N.strValue;
    }
    return u.validate && !u.validate(x, E) ? null : u.singleEnum && C ? x.length === 1 && xt(x[0]) ? {
      name: t,
      value: x[0],
      strValue: x[0],
      bypass: r
    } : null : {
      name: t,
      value: x,
      pfValue: S,
      strValue: w,
      bypass: r,
      units: E
    };
  }
  var R = function() {
    for (var V = 0; V < u.enums.length; V++) {
      var q = u.enums[V];
      if (q === e)
        return {
          name: t,
          value: e,
          strValue: "" + e,
          bypass: r
        };
    }
    return null;
  };
  if (u.number) {
    var _, O = "px";
    if (u.units && (_ = u.units), u.implicitUnits && (O = u.implicitUnits), !u.unitless)
      if (l) {
        var T = "px|em" + (u.allowPercent ? "|\\%" : "");
        _ && (T = _);
        var L = e.match("^(" + mn + ")(" + T + ")?$");
        L && (e = L[1], _ = L[2] || O);
      } else (!_ || u.implicitUnits) && (_ = O);
    if (e = parseFloat(e), isNaN(e) && u.enums === void 0)
      return null;
    if (isNaN(e) && u.enums !== void 0)
      return e = s, R();
    if (u.integer && !X2e(e) || u.min !== void 0 && (e < u.min || u.strictMin && e === u.min) || u.max !== void 0 && (e > u.max || u.strictMax && e === u.max))
      return null;
    var M = {
      name: t,
      value: e,
      strValue: "" + e + (_ || ""),
      units: _,
      bypass: r
    };
    return u.unitless || _ !== "px" && _ !== "em" ? M.pfValue = e : M.pfValue = _ === "px" || !_ ? e : this.getEmSizeInPixels() * e, (_ === "ms" || _ === "s") && (M.pfValue = _ === "ms" ? e : 1e3 * e), (_ === "deg" || _ === "rad") && (M.pfValue = _ === "rad" ? e : iEe(e)), _ === "%" && (M.pfValue = e / 100), M;
  } else if (u.propList) {
    var A = [], I = "" + e;
    if (I !== "none") {
      for (var D = I.split(/\s*,\s*|\s+/), F = 0; F < D.length; F++) {
        var B = D[F].trim();
        a.properties[B] ? A.push(B) : pr("`" + B + "` is not a valid property name");
      }
      if (A.length === 0)
        return null;
    }
    return {
      name: t,
      value: A,
      strValue: A.length === 0 ? "none" : A.join(" "),
      bypass: r
    };
  } else if (u.color) {
    var G = _B(e);
    return G ? {
      name: t,
      value: G,
      pfValue: G,
      strValue: "rgb(" + G[0] + "," + G[1] + "," + G[2] + ")",
      // n.b. no spaces b/c of multiple support
      bypass: r
    } : null;
  } else if (u.regex || u.regexes) {
    if (u.enums) {
      var H = R();
      if (H)
        return H;
    }
    for (var K = u.regexes ? u.regexes : [u.regex], j = 0; j < K.length; j++) {
      var Z = new RegExp(K[j]), te = Z.exec(e);
      if (te)
        return {
          name: t,
          value: u.singleRegexMatchValue ? te[1] : te,
          strValue: "" + e,
          bypass: r
        };
    }
    return null;
  } else return u.string ? {
    name: t,
    value: "" + e,
    strValue: "" + e,
    bypass: r
  } : u.enums ? R() : null;
};
var Rn = function(e) {
  if (!(this instanceof Rn))
    return new Rn(e);
  if (!r3(e)) {
    Fr("A style must have a core reference");
    return;
  }
  this._private = {
    cy: e,
    coreStyle: {}
  }, this.length = 0, this.resetToDefault();
}, ta = Rn.prototype;
ta.instanceString = function() {
  return "style";
};
ta.clear = function() {
  for (var t = this._private, e = t.cy, r = e.elements(), n = 0; n < this.length; n++)
    this[n] = void 0;
  return this.length = 0, t.contextStyles = {}, t.propDiffs = {}, this.cleanElements(r, !0), r.forEach(function(a) {
    var i = a[0]._private;
    i.styleDirty = !0, i.appliedInitStyle = !1;
  }), this;
};
ta.resetToDefault = function() {
  return this.clear(), this.addDefaultStylesheet(), this;
};
ta.core = function(t) {
  return this._private.coreStyle[t] || this.getDefaultProperty(t);
};
ta.selector = function(t) {
  var e = t === "core" ? null : new Ko(t), r = this.length++;
  return this[r] = {
    selector: e,
    properties: [],
    mappedProperties: [],
    index: r
  }, this;
};
ta.css = function() {
  var t = this, e = arguments;
  if (e.length === 1)
    for (var r = e[0], n = 0; n < t.properties.length; n++) {
      var a = t.properties[n], i = r[a.name];
      i === void 0 && (i = r[X1(a.name)]), i !== void 0 && this.cssRule(a.name, i);
    }
  else e.length === 2 && this.cssRule(e[0], e[1]);
  return this;
};
ta.style = ta.css;
ta.cssRule = function(t, e) {
  var r = this.parse(t, e);
  if (r) {
    var n = this.length - 1;
    this[n].properties.push(r), this[n].properties[r.name] = r, r.name.match(/pie-(\d+)-background-size/) && r.value && (this._private.hasPie = !0), r.name.match(/stripe-(\d+)-background-size/) && r.value && (this._private.hasStripe = !0), r.mapped && this[n].mappedProperties.push(r);
    var a = !this[n].selector;
    a && (this._private.coreStyle[r.name] = r);
  }
  return this;
};
ta.append = function(t) {
  return kB(t) ? t.appendToStyle(this) : Sr(t) ? this.appendFromJson(t) : xt(t) && this.appendFromString(t), this;
};
Rn.fromJson = function(t, e) {
  var r = new Rn(t);
  return r.fromJson(e), r;
};
Rn.fromString = function(t, e) {
  return new Rn(t).fromString(e);
};
[In, gp, y3, ys, lb, b3, on, ub].forEach(function(t) {
  At(ta, t);
});
Rn.types = ta.types;
Rn.properties = ta.properties;
Rn.propertyGroups = ta.propertyGroups;
Rn.propertyGroupNames = ta.propertyGroupNames;
Rn.propertyGroupKeys = ta.propertyGroupKeys;
var uSe = {
  style: function(e) {
    if (e) {
      var r = this.setStyle(e);
      r.update();
    }
    return this._private.style;
  },
  setStyle: function(e) {
    var r = this._private;
    return kB(e) ? r.style = e.generateStyle(this) : Sr(e) ? r.style = Rn.fromJson(this, e) : xt(e) ? r.style = Rn.fromString(this, e) : r.style = Rn(this), r.style;
  },
  // e.g. cy.data() changed => recalc ele mappers
  updateStyle: function() {
    this.mutableElements().updateStyle();
  }
}, cSe = "single", lu = {
  autolock: function(e) {
    if (e !== void 0)
      this._private.autolock = !!e;
    else
      return this._private.autolock;
    return this;
  },
  autoungrabify: function(e) {
    if (e !== void 0)
      this._private.autoungrabify = !!e;
    else
      return this._private.autoungrabify;
    return this;
  },
  autounselectify: function(e) {
    if (e !== void 0)
      this._private.autounselectify = !!e;
    else
      return this._private.autounselectify;
    return this;
  },
  selectionType: function(e) {
    var r = this._private;
    if (r.selectionType == null && (r.selectionType = cSe), e !== void 0)
      (e === "additive" || e === "single") && (r.selectionType = e);
    else
      return r.selectionType;
    return this;
  },
  panningEnabled: function(e) {
    if (e !== void 0)
      this._private.panningEnabled = !!e;
    else
      return this._private.panningEnabled;
    return this;
  },
  userPanningEnabled: function(e) {
    if (e !== void 0)
      this._private.userPanningEnabled = !!e;
    else
      return this._private.userPanningEnabled;
    return this;
  },
  zoomingEnabled: function(e) {
    if (e !== void 0)
      this._private.zoomingEnabled = !!e;
    else
      return this._private.zoomingEnabled;
    return this;
  },
  userZoomingEnabled: function(e) {
    if (e !== void 0)
      this._private.userZoomingEnabled = !!e;
    else
      return this._private.userZoomingEnabled;
    return this;
  },
  boxSelectionEnabled: function(e) {
    if (e !== void 0)
      this._private.boxSelectionEnabled = !!e;
    else
      return this._private.boxSelectionEnabled;
    return this;
  },
  pan: function() {
    var e = arguments, r = this._private.pan, n, a, i, s, o;
    switch (e.length) {
      case 0:
        return r;
      case 1:
        if (xt(e[0]))
          return n = e[0], r[n];
        if (Qt(e[0])) {
          if (!this._private.panningEnabled)
            return this;
          i = e[0], s = i.x, o = i.y, tt(s) && (r.x = s), tt(o) && (r.y = o), this.emit("pan viewport");
        }
        break;
      case 2:
        if (!this._private.panningEnabled)
          return this;
        n = e[0], a = e[1], (n === "x" || n === "y") && tt(a) && (r[n] = a), this.emit("pan viewport");
        break;
    }
    return this.notify("viewport"), this;
  },
  panBy: function(e, r) {
    var n = arguments, a = this._private.pan, i, s, o, l, u;
    if (!this._private.panningEnabled)
      return this;
    switch (n.length) {
      case 1:
        Qt(e) && (o = n[0], l = o.x, u = o.y, tt(l) && (a.x += l), tt(u) && (a.y += u), this.emit("pan viewport"));
        break;
      case 2:
        i = e, s = r, (i === "x" || i === "y") && tt(s) && (a[i] += s), this.emit("pan viewport");
        break;
    }
    return this.notify("viewport"), this;
  },
  gc: function() {
    this.notify("gc");
  },
  fit: function(e, r) {
    var n = this.getFitViewport(e, r);
    if (n) {
      var a = this._private;
      a.zoom = n.zoom, a.pan = n.pan, this.emit("pan zoom viewport"), this.notify("viewport");
    }
    return this;
  },
  getFitViewport: function(e, r) {
    if (tt(e) && r === void 0 && (r = e, e = void 0), !(!this._private.panningEnabled || !this._private.zoomingEnabled)) {
      var n;
      if (xt(e)) {
        var a = e;
        e = this.$(a);
      } else if (Q2e(e)) {
        var i = e;
        n = {
          x1: i.x1,
          y1: i.y1,
          x2: i.x2,
          y2: i.y2
        }, n.w = n.x2 - n.x1, n.h = n.y2 - n.y1;
      } else ri(e) || (e = this.mutableElements());
      if (!(ri(e) && e.empty())) {
        n = n || e.boundingBox();
        var s = this.width(), o = this.height(), l;
        if (r = tt(r) ? r : 0, !isNaN(s) && !isNaN(o) && s > 0 && o > 0 && !isNaN(n.w) && !isNaN(n.h) && n.w > 0 && n.h > 0) {
          l = Math.min((s - 2 * r) / n.w, (o - 2 * r) / n.h), l = l > this._private.maxZoom ? this._private.maxZoom : l, l = l < this._private.minZoom ? this._private.minZoom : l;
          var u = {
            // now pan to middle
            x: (s - l * (n.x1 + n.x2)) / 2,
            y: (o - l * (n.y1 + n.y2)) / 2
          };
          return {
            zoom: l,
            pan: u
          };
        }
      }
    }
  },
  zoomRange: function(e, r) {
    var n = this._private;
    if (r == null) {
      var a = e;
      e = a.min, r = a.max;
    }
    return tt(e) && tt(r) && e <= r ? (n.minZoom = e, n.maxZoom = r) : tt(e) && r === void 0 && e <= n.maxZoom ? n.minZoom = e : tt(r) && e === void 0 && r >= n.minZoom && (n.maxZoom = r), this;
  },
  minZoom: function(e) {
    return e === void 0 ? this._private.minZoom : this.zoomRange({
      min: e
    });
  },
  maxZoom: function(e) {
    return e === void 0 ? this._private.maxZoom : this.zoomRange({
      max: e
    });
  },
  getZoomedViewport: function(e) {
    var r = this._private, n = r.pan, a = r.zoom, i, s, o = !1;
    if (r.zoomingEnabled || (o = !0), tt(e) ? s = e : Qt(e) && (s = e.level, e.position != null ? i = Q1(e.position, a, n) : e.renderedPosition != null && (i = e.renderedPosition), i != null && !r.panningEnabled && (o = !0)), s = s > r.maxZoom ? r.maxZoom : s, s = s < r.minZoom ? r.minZoom : s, o || !tt(s) || s === a || i != null && (!tt(i.x) || !tt(i.y)))
      return null;
    if (i != null) {
      var l = n, u = a, c = s, f = {
        x: -c / u * (i.x - l.x) + i.x,
        y: -c / u * (i.y - l.y) + i.y
      };
      return {
        zoomed: !0,
        panned: !0,
        zoom: c,
        pan: f
      };
    } else
      return {
        zoomed: !0,
        panned: !1,
        zoom: s,
        pan: n
      };
  },
  zoom: function(e) {
    if (e === void 0)
      return this._private.zoom;
    var r = this.getZoomedViewport(e), n = this._private;
    return r == null || !r.zoomed ? this : (n.zoom = r.zoom, r.panned && (n.pan.x = r.pan.x, n.pan.y = r.pan.y), this.emit("zoom" + (r.panned ? " pan" : "") + " viewport"), this.notify("viewport"), this);
  },
  viewport: function(e) {
    var r = this._private, n = !0, a = !0, i = [], s = !1, o = !1;
    if (!e)
      return this;
    if (tt(e.zoom) || (n = !1), Qt(e.pan) || (a = !1), !n && !a)
      return this;
    if (n) {
      var l = e.zoom;
      l < r.minZoom || l > r.maxZoom || !r.zoomingEnabled ? s = !0 : (r.zoom = l, i.push("zoom"));
    }
    if (a && (!s || !e.cancelOnFailedZoom) && r.panningEnabled) {
      var u = e.pan;
      tt(u.x) && (r.pan.x = u.x, o = !1), tt(u.y) && (r.pan.y = u.y, o = !1), o || i.push("pan");
    }
    return i.length > 0 && (i.push("viewport"), this.emit(i.join(" ")), this.notify("viewport")), this;
  },
  center: function(e) {
    var r = this.getCenterPan(e);
    return r && (this._private.pan = r, this.emit("pan viewport"), this.notify("viewport")), this;
  },
  getCenterPan: function(e, r) {
    if (this._private.panningEnabled) {
      if (xt(e)) {
        var n = e;
        e = this.mutableElements().filter(n);
      } else ri(e) || (e = this.mutableElements());
      if (e.length !== 0) {
        var a = e.boundingBox(), i = this.width(), s = this.height();
        r = r === void 0 ? this._private.zoom : r;
        var o = {
          // middle
          x: (i - r * (a.x1 + a.x2)) / 2,
          y: (s - r * (a.y1 + a.y2)) / 2
        };
        return o;
      }
    }
  },
  reset: function() {
    return !this._private.panningEnabled || !this._private.zoomingEnabled ? this : (this.viewport({
      pan: {
        x: 0,
        y: 0
      },
      zoom: 1
    }), this);
  },
  invalidateSize: function() {
    this._private.sizeCache = null;
  },
  size: function() {
    var e = this._private, r = e.container, n = this;
    return e.sizeCache = e.sizeCache || (r ? function() {
      var a = n.window().getComputedStyle(r), i = function(o) {
        return parseFloat(a.getPropertyValue(o));
      };
      return {
        width: r.clientWidth - i("padding-left") - i("padding-right"),
        height: r.clientHeight - i("padding-top") - i("padding-bottom")
      };
    }() : {
      // fallback if no container (not 0 b/c can be used for dividing etc)
      width: 1,
      height: 1
    });
  },
  width: function() {
    return this.size().width;
  },
  height: function() {
    return this.size().height;
  },
  extent: function() {
    var e = this._private.pan, r = this._private.zoom, n = this.renderedExtent(), a = {
      x1: (n.x1 - e.x) / r,
      x2: (n.x2 - e.x) / r,
      y1: (n.y1 - e.y) / r,
      y2: (n.y2 - e.y) / r
    };
    return a.w = a.x2 - a.x1, a.h = a.y2 - a.y1, a;
  },
  renderedExtent: function() {
    var e = this.width(), r = this.height();
    return {
      x1: 0,
      y1: 0,
      x2: e,
      y2: r,
      w: e,
      h: r
    };
  },
  multiClickDebounceTime: function(e) {
    if (e) this._private.multiClickDebounceTime = e;
    else return this._private.multiClickDebounceTime;
    return this;
  }
};
lu.centre = lu.center;
lu.autolockNodes = lu.autolock;
lu.autoungrabifyNodes = lu.autoungrabify;
var d0 = {
  data: hr.data({
    field: "data",
    bindingEvent: "data",
    allowBinding: !0,
    allowSetting: !0,
    settingEvent: "data",
    settingTriggersEvent: !0,
    triggerFnName: "trigger",
    allowGetting: !0,
    updateStyle: !0
  }),
  removeData: hr.removeData({
    field: "data",
    event: "data",
    triggerFnName: "trigger",
    triggerEvent: !0,
    updateStyle: !0
  }),
  scratch: hr.data({
    field: "scratch",
    bindingEvent: "scratch",
    allowBinding: !0,
    allowSetting: !0,
    settingEvent: "scratch",
    settingTriggersEvent: !0,
    triggerFnName: "trigger",
    allowGetting: !0,
    updateStyle: !0
  }),
  removeScratch: hr.removeData({
    field: "scratch",
    event: "scratch",
    triggerFnName: "trigger",
    triggerEvent: !0,
    updateStyle: !0
  })
};
d0.attr = d0.data;
d0.removeAttr = d0.removeData;
var p0 = function(e) {
  var r = this;
  e = At({}, e);
  var n = e.container;
  n && !Dm(n) && Dm(n[0]) && (n = n[0]);
  var a = n ? n._cyreg : null;
  a = a || {}, a && a.cy && (a.cy.destroy(), a = {});
  var i = a.readies = a.readies || [];
  n && (n._cyreg = a), a.cy = r;
  var s = pn !== void 0 && n !== void 0 && !e.headless, o = e;
  o.layout = At({
    name: s ? "grid" : "null"
  }, o.layout), o.renderer = At({
    name: s ? "canvas" : "null"
  }, o.renderer);
  var l = function(p, g, v) {
    return g !== void 0 ? g : v !== void 0 ? v : p;
  }, u = this._private = {
    container: n,
    // html dom ele container
    ready: !1,
    // whether ready has been triggered
    options: o,
    // cached options
    elements: new zn(this),
    // elements in the graph
    listeners: [],
    // list of listeners
    aniEles: new zn(this),
    // elements being animated
    data: o.data || {},
    // data for the core
    scratch: {},
    // scratch object for core
    layout: null,
    renderer: null,
    destroyed: !1,
    // whether destroy was called
    notificationsEnabled: !0,
    // whether notifications are sent to the renderer
    minZoom: 1e-50,
    maxZoom: 1e50,
    zoomingEnabled: l(!0, o.zoomingEnabled),
    userZoomingEnabled: l(!0, o.userZoomingEnabled),
    panningEnabled: l(!0, o.panningEnabled),
    userPanningEnabled: l(!0, o.userPanningEnabled),
    boxSelectionEnabled: l(!0, o.boxSelectionEnabled),
    autolock: l(!1, o.autolock, o.autolockNodes),
    autoungrabify: l(!1, o.autoungrabify, o.autoungrabifyNodes),
    autounselectify: l(!1, o.autounselectify),
    styleEnabled: o.styleEnabled === void 0 ? s : o.styleEnabled,
    zoom: tt(o.zoom) ? o.zoom : 1,
    pan: {
      x: Qt(o.pan) && tt(o.pan.x) ? o.pan.x : 0,
      y: Qt(o.pan) && tt(o.pan.y) ? o.pan.y : 0
    },
    animation: {
      // object for currently-running animations
      current: [],
      queue: []
    },
    hasCompoundNodes: !1,
    multiClickDebounceTime: l(250, o.multiClickDebounceTime)
  };
  this.createEmitter(), this.selectionType(o.selectionType), this.zoomRange({
    min: o.minZoom,
    max: o.maxZoom
  });
  var c = function(p, g) {
    var v = p.some(J2e);
    if (v)
      return _f.all(p).then(g);
    g(p);
  };
  u.styleEnabled && r.setStyle([]);
  var f = At({}, o, o.renderer);
  r.initRenderer(f);
  var h = function(p, g, v) {
    r.notifications(!1);
    var m = r.mutableElements();
    m.length > 0 && m.remove(), p != null && (Qt(p) || Sr(p)) && r.add(p), r.one("layoutready", function(y) {
      r.notifications(!0), r.emit(y), r.one("load", g), r.emitAndNotify("load");
    }).one("layoutstop", function() {
      r.one("done", v), r.emit("done");
    });
    var b = At({}, r._private.options.layout);
    b.eles = r.elements(), r.layout(b).run();
  };
  c([o.style, o.elements], function(d) {
    var p = d[0], g = d[1];
    u.styleEnabled && r.style().append(p), h(g, function() {
      r.startAnimationLoop(), u.ready = !0, Wr(o.ready) && r.on("ready", o.ready);
      for (var v = 0; v < i.length; v++) {
        var m = i[v];
        r.on("ready", m);
      }
      a && (a.readies = []), r.emit("ready");
    }, o.done);
  });
}, Hm = p0.prototype;
At(Hm, {
  instanceString: function() {
    return "core";
  },
  isReady: function() {
    return this._private.ready;
  },
  destroyed: function() {
    return this._private.destroyed;
  },
  ready: function(e) {
    return this.isReady() ? this.emitter().emit("ready", [], e) : this.on("ready", e), this;
  },
  destroy: function() {
    var e = this;
    if (!e.destroyed())
      return e.stopAnimationLoop(), e.destroyRenderer(), this.emit("destroy"), e._private.destroyed = !0, e;
  },
  hasElementWithId: function(e) {
    return this._private.elements.hasElementWithId(e);
  },
  getElementById: function(e) {
    return this._private.elements.getElementById(e);
  },
  hasCompoundNodes: function() {
    return this._private.hasCompoundNodes;
  },
  headless: function() {
    return this._private.renderer.isHeadless();
  },
  styleEnabled: function() {
    return this._private.styleEnabled;
  },
  addToPool: function(e) {
    return this._private.elements.merge(e), this;
  },
  removeFromPool: function(e) {
    return this._private.elements.unmerge(e), this;
  },
  container: function() {
    return this._private.container || null;
  },
  window: function() {
    var e = this._private.container;
    if (e == null) return pn;
    var r = this._private.container.ownerDocument;
    return r === void 0 || r == null ? pn : r.defaultView || pn;
  },
  mount: function(e) {
    if (e != null) {
      var r = this, n = r._private, a = n.options;
      return !Dm(e) && Dm(e[0]) && (e = e[0]), r.stopAnimationLoop(), r.destroyRenderer(), n.container = e, n.styleEnabled = !0, r.invalidateSize(), r.initRenderer(At({}, a, a.renderer, {
        // allow custom renderer name to be re-used, otherwise use canvas
        name: a.renderer.name === "null" ? "canvas" : a.renderer.name
      })), r.startAnimationLoop(), r.style(a.style), r.emit("mount"), r;
    }
  },
  unmount: function() {
    var e = this;
    return e.stopAnimationLoop(), e.destroyRenderer(), e.initRenderer({
      name: "null"
    }), e.emit("unmount"), e;
  },
  options: function() {
    return ds(this._private.options);
  },
  json: function(e) {
    var r = this, n = r._private, a = r.mutableElements(), i = function(x) {
      return r.getElementById(x.id());
    };
    if (Qt(e)) {
      if (r.startBatch(), e.elements) {
        var s = {}, o = function(x, E) {
          for (var S = [], w = [], C = 0; C < x.length; C++) {
            var k = x[C];
            if (!k.data.id) {
              pr("cy.json() cannot handle elements without an ID attribute");
              continue;
            }
            var N = "" + k.data.id, R = r.getElementById(N);
            s[N] = !0, R.length !== 0 ? w.push({
              ele: R,
              json: k
            }) : (E && (k.group = E), S.push(k));
          }
          r.add(S);
          for (var _ = 0; _ < w.length; _++) {
            var O = w[_], T = O.ele, L = O.json;
            T.json(L);
          }
        };
        if (Sr(e.elements))
          o(e.elements);
        else
          for (var l = ["nodes", "edges"], u = 0; u < l.length; u++) {
            var c = l[u], f = e.elements[c];
            Sr(f) && o(f, c);
          }
        var h = r.collection();
        a.filter(function(y) {
          return !s[y.id()];
        }).forEach(function(y) {
          y.isParent() ? h.merge(y) : y.remove();
        }), h.forEach(function(y) {
          return y.children().move({
            parent: null
          });
        }), h.forEach(function(y) {
          return i(y).remove();
        });
      }
      e.style && r.style(e.style), e.zoom != null && e.zoom !== n.zoom && r.zoom(e.zoom), e.pan && (e.pan.x !== n.pan.x || e.pan.y !== n.pan.y) && r.pan(e.pan), e.data && r.data(e.data);
      for (var d = ["minZoom", "maxZoom", "zoomingEnabled", "userZoomingEnabled", "panningEnabled", "userPanningEnabled", "boxSelectionEnabled", "autolock", "autoungrabify", "autounselectify", "multiClickDebounceTime"], p = 0; p < d.length; p++) {
        var g = d[p];
        e[g] != null && r[g](e[g]);
      }
      return r.endBatch(), this;
    } else {
      var v = !!e, m = {};
      v ? m.elements = this.elements().map(function(y) {
        return y.json();
      }) : (m.elements = {}, a.forEach(function(y) {
        var x = y.group();
        m.elements[x] || (m.elements[x] = []), m.elements[x].push(y.json());
      })), this._private.styleEnabled && (m.style = r.style().json()), m.data = ds(r.data());
      var b = n.options;
      return m.zoomingEnabled = n.zoomingEnabled, m.userZoomingEnabled = n.userZoomingEnabled, m.zoom = n.zoom, m.minZoom = n.minZoom, m.maxZoom = n.maxZoom, m.panningEnabled = n.panningEnabled, m.userPanningEnabled = n.userPanningEnabled, m.pan = ds(n.pan), m.boxSelectionEnabled = n.boxSelectionEnabled, m.renderer = ds(b.renderer), m.hideEdgesOnViewport = b.hideEdgesOnViewport, m.textureOnViewport = b.textureOnViewport, m.wheelSensitivity = b.wheelSensitivity, m.motionBlur = b.motionBlur, m.multiClickDebounceTime = b.multiClickDebounceTime, m;
    }
  }
});
Hm.$id = Hm.getElementById;
[J4e, aSe, kz, A4, xv, sSe, k4, wv, uSe, lu, d0].forEach(function(t) {
  At(Hm, t);
});
var fSe = {
  fit: !0,
  // whether to fit the viewport to the graph
  directed: !1,
  // whether the tree is directed downwards (or edges can point in any direction if false)
  direction: "downward",
  // determines the direction in which the tree structure is drawn.  The possible values are 'downward', 'upward', 'rightward', or 'leftward'.
  padding: 30,
  // padding on fit
  circle: !1,
  // put depths in concentric circles if true, put depths top down if false
  grid: !1,
  // whether to create an even grid into which the DAG is placed (circle:false only)
  spacingFactor: 1.75,
  // positive spacing factor, larger => more space between nodes (N.B. n/a if causes overlap)
  boundingBox: void 0,
  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: !0,
  // prevents node overlap, may overflow boundingBox if not enough space
  nodeDimensionsIncludeLabels: !1,
  // Excludes the label when calculating node bounding boxes for the layout algorithm
  roots: void 0,
  // the roots of the trees
  depthSort: void 0,
  // a sorting function to order nodes at equal depth. e.g. function(a, b){ return a.data('weight') - b.data('weight') }
  animate: !1,
  // whether to transition the node positions
  animationDuration: 500,
  // duration of animation in ms if enabled
  animationEasing: void 0,
  // easing of animation if enabled,
  animateFilter: function(e, r) {
    return !0;
  },
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: void 0,
  // callback on layoutready
  stop: void 0,
  // callback on layoutstop
  transform: function(e, r) {
    return r;
  }
  // transform a given node position. Useful for changing flow direction in discrete layouts
}, hSe = {
  maximal: !1,
  // whether to shift nodes down their natural BFS depths in order to avoid upwards edges (DAGS only); setting acyclic to true sets maximal to true also
  acyclic: !1
  // whether the tree is acyclic and thus a node could be shifted (due to the maximal option) multiple times without causing an infinite loop; setting to true sets maximal to true also; if you are uncertain whether a tree is acyclic, set to false to avoid potential infinite loops
}, ju = function(e) {
  return e.scratch("breadthfirst");
}, nL = function(e, r) {
  return e.scratch("breadthfirst", r);
};
function Rz(t) {
  this.options = At({}, fSe, hSe, t);
}
Rz.prototype.run = function() {
  var t = this.options, e = t.cy, r = t.eles, n = r.nodes().filter(function(we) {
    return we.isChildless();
  }), a = r, i = t.directed, s = t.acyclic || t.maximal || t.maximalAdjustments > 0, o = !!t.boundingBox, l = da(o ? t.boundingBox : structuredClone(e.extent())), u;
  if (ri(t.roots))
    u = t.roots;
  else if (Sr(t.roots)) {
    for (var c = [], f = 0; f < t.roots.length; f++) {
      var h = t.roots[f], d = e.getElementById(h);
      c.push(d);
    }
    u = e.collection(c);
  } else if (xt(t.roots))
    u = e.$(t.roots);
  else if (i)
    u = n.roots();
  else {
    var p = r.components();
    u = e.collection();
    for (var g = function() {
      var Ae = p[v], Ne = Ae.maxDegree(!1), Ie = Ae.filter(function(Me) {
        return Me.degree(!1) === Ne;
      });
      u = u.add(Ie);
    }, v = 0; v < p.length; v++)
      g();
  }
  var m = [], b = {}, y = function(Ae, Ne) {
    m[Ne] == null && (m[Ne] = []);
    var Ie = m[Ne].length;
    m[Ne].push(Ae), nL(Ae, {
      index: Ie,
      depth: Ne
    });
  }, x = function(Ae, Ne) {
    var Ie = ju(Ae), Me = Ie.depth, _e = Ie.index;
    m[Me][_e] = null, Ae.isChildless() && y(Ae, Ne);
  };
  a.bfs({
    roots: u,
    directed: t.directed,
    visit: function(Ae, Ne, Ie, Me, _e) {
      var Be = Ae[0], st = Be.id();
      Be.isChildless() && y(Be, _e), b[st] = !0;
    }
  });
  for (var E = [], S = 0; S < n.length; S++) {
    var w = n[S];
    b[w.id()] || E.push(w);
  }
  var C = function(Ae) {
    for (var Ne = m[Ae], Ie = 0; Ie < Ne.length; Ie++) {
      var Me = Ne[Ie];
      if (Me == null) {
        Ne.splice(Ie, 1), Ie--;
        continue;
      }
      nL(Me, {
        depth: Ae,
        index: Ie
      });
    }
  }, k = function(Ae, Ne) {
    for (var Ie = ju(Ae), Me = Ae.incomers().filter(function(rt) {
      return rt.isNode() && r.has(rt);
    }), _e = -1, Be = Ae.id(), st = 0; st < Me.length; st++) {
      var ct = Me[st], dt = ju(ct);
      _e = Math.max(_e, dt.depth);
    }
    if (Ie.depth <= _e) {
      if (!t.acyclic && Ne[Be])
        return null;
      var ft = _e + 1;
      return x(Ae, ft), Ne[Be] = ft, !0;
    }
    return !1;
  };
  if (i && s) {
    var N = [], R = {}, _ = function(Ae) {
      return N.push(Ae);
    }, O = function() {
      return N.shift();
    };
    for (n.forEach(function(we) {
      return N.push(we);
    }); N.length > 0; ) {
      var T = O(), L = k(T, R);
      if (L)
        T.outgoers().filter(function(we) {
          return we.isNode() && r.has(we);
        }).forEach(_);
      else if (L === null) {
        pr("Detected double maximal shift for node `" + T.id() + "`.  Bailing maximal adjustment due to cycle.  Use `options.maximal: true` only on DAGs.");
        break;
      }
    }
  }
  var M = 0;
  if (t.avoidOverlap)
    for (var A = 0; A < n.length; A++) {
      var I = n[A], D = I.layoutDimensions(t), F = D.w, B = D.h;
      M = Math.max(M, F, B);
    }
  var G = {}, H = function(Ae) {
    if (G[Ae.id()])
      return G[Ae.id()];
    for (var Ne = ju(Ae).depth, Ie = Ae.neighborhood(), Me = 0, _e = 0, Be = 0; Be < Ie.length; Be++) {
      var st = Ie[Be];
      if (!(st.isEdge() || st.isParent() || !n.has(st))) {
        var ct = ju(st);
        if (ct != null) {
          var dt = ct.index, ft = ct.depth;
          if (!(dt == null || ft == null)) {
            var rt = m[ft].length;
            ft < Ne && (Me += dt / rt, _e++);
          }
        }
      }
    }
    return _e = Math.max(1, _e), Me = Me / _e, _e === 0 && (Me = 0), G[Ae.id()] = Me, Me;
  }, K = function(Ae, Ne) {
    var Ie = H(Ae), Me = H(Ne), _e = Ie - Me;
    return _e === 0 ? MB(Ae.id(), Ne.id()) : _e;
  };
  t.depthSort !== void 0 && (K = t.depthSort);
  for (var j = m.length, Z = 0; Z < j; Z++)
    m[Z].sort(K), C(Z);
  for (var te = [], ne = 0; ne < E.length; ne++)
    te.push(E[ne]);
  var V = function() {
    for (var Ae = 0; Ae < j; Ae++)
      C(Ae);
  };
  te.length && (m.unshift(te), j = m.length, V());
  for (var q = 0, X = 0; X < j; X++)
    q = Math.max(m[X].length, q);
  var W = {
    x: l.x1 + l.w / 2,
    y: l.y1 + l.h / 2
  }, ue = n.reduce(function(we, Ae) {
    return function(Ne) {
      return {
        w: we.w === -1 ? Ne.w : (we.w + Ne.w) / 2,
        h: we.h === -1 ? Ne.h : (we.h + Ne.h) / 2
      };
    }(Ae.boundingBox({
      includeLabels: t.nodeDimensionsIncludeLabels
    }));
  }, {
    w: -1,
    h: -1
  }), J = Math.max(
    // only one depth
    j === 1 ? 0 : (
      // inside a bounding box, no need for top & bottom padding
      o ? (l.h - t.padding * 2 - ue.h) / (j - 1) : (l.h - t.padding * 2 - ue.h) / (j + 1)
    ),
    M
  ), Ce = m.reduce(function(we, Ae) {
    return Math.max(we, Ae.length);
  }, 0), Ee = function(Ae) {
    var Ne = ju(Ae), Ie = Ne.depth, Me = Ne.index;
    if (t.circle) {
      var _e = Math.min(l.w / 2 / j, l.h / 2 / j);
      _e = Math.max(_e, M);
      var Be = _e * Ie + _e - (j > 0 && m[0].length <= 3 ? _e / 2 : 0), st = 2 * Math.PI / m[Ie].length * Me;
      return Ie === 0 && m[0].length === 1 && (Be = 1), {
        x: W.x + Be * Math.cos(st),
        y: W.y + Be * Math.sin(st)
      };
    } else {
      var ct = m[Ie].length, dt = Math.max(
        // only one depth
        ct === 1 ? 0 : (
          // inside a bounding box, no need for left & right padding
          o ? (l.w - t.padding * 2 - ue.w) / ((t.grid ? Ce : ct) - 1) : (l.w - t.padding * 2 - ue.w) / ((t.grid ? Ce : ct) + 1)
        ),
        M
      ), ft = {
        x: W.x + (Me + 1 - (ct + 1) / 2) * dt,
        y: W.y + (Ie + 1 - (j + 1) / 2) * J
      };
      return ft;
    }
  }, Te = {
    downward: 0,
    leftward: 90,
    upward: 180,
    rightward: -90
  };
  Object.keys(Te).indexOf(t.direction) === -1 && Fr("Invalid direction '".concat(t.direction, "' specified for breadthfirst layout. Valid values are: ").concat(Object.keys(Te).join(", ")));
  var me = function(Ae) {
    return Rwe(Ee(Ae), l, Te[t.direction]);
  };
  return r.nodes().layoutPositions(this, t, me), this;
};
var dSe = {
  fit: !0,
  // whether to fit the viewport to the graph
  padding: 30,
  // the padding on fit
  boundingBox: void 0,
  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: !0,
  // prevents node overlap, may overflow boundingBox and radius if not enough space
  nodeDimensionsIncludeLabels: !1,
  // Excludes the label when calculating node bounding boxes for the layout algorithm
  spacingFactor: void 0,
  // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
  radius: void 0,
  // the radius of the circle
  startAngle: 3 / 2 * Math.PI,
  // where nodes start in radians
  sweep: void 0,
  // how many radians should be between the first and last node (defaults to full circle)
  clockwise: !0,
  // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
  sort: void 0,
  // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
  animate: !1,
  // whether to transition the node positions
  animationDuration: 500,
  // duration of animation in ms if enabled
  animationEasing: void 0,
  // easing of animation if enabled
  animateFilter: function(e, r) {
    return !0;
  },
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: void 0,
  // callback on layoutready
  stop: void 0,
  // callback on layoutstop
  transform: function(e, r) {
    return r;
  }
  // transform a given node position. Useful for changing flow direction in discrete layouts 
};
function Mz(t) {
  this.options = At({}, dSe, t);
}
Mz.prototype.run = function() {
  var t = this.options, e = t, r = t.cy, n = e.eles, a = e.counterclockwise !== void 0 ? !e.counterclockwise : e.clockwise, i = n.nodes().not(":parent");
  e.sort && (i = i.sort(e.sort));
  for (var s = da(e.boundingBox ? e.boundingBox : {
    x1: 0,
    y1: 0,
    w: r.width(),
    h: r.height()
  }), o = {
    x: s.x1 + s.w / 2,
    y: s.y1 + s.h / 2
  }, l = e.sweep === void 0 ? 2 * Math.PI - 2 * Math.PI / i.length : e.sweep, u = l / Math.max(1, i.length - 1), c, f = 0, h = 0; h < i.length; h++) {
    var d = i[h], p = d.layoutDimensions(e), g = p.w, v = p.h;
    f = Math.max(f, g, v);
  }
  if (tt(e.radius) ? c = e.radius : i.length <= 1 ? c = 0 : c = Math.min(s.h, s.w) / 2 - f, i.length > 1 && e.avoidOverlap) {
    f *= 1.75;
    var m = Math.cos(u) - Math.cos(0), b = Math.sin(u) - Math.sin(0), y = Math.sqrt(f * f / (m * m + b * b));
    c = Math.max(y, c);
  }
  var x = function(S, w) {
    var C = e.startAngle + w * u * (a ? 1 : -1), k = c * Math.cos(C), N = c * Math.sin(C), R = {
      x: o.x + k,
      y: o.y + N
    };
    return R;
  };
  return n.nodes().layoutPositions(this, e, x), this;
};
var pSe = {
  fit: !0,
  // whether to fit the viewport to the graph
  padding: 30,
  // the padding on fit
  startAngle: 3 / 2 * Math.PI,
  // where nodes start in radians
  sweep: void 0,
  // how many radians should be between the first and last node (defaults to full circle)
  clockwise: !0,
  // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
  equidistant: !1,
  // whether levels have an equal radial distance betwen them, may cause bounding box overflow
  minNodeSpacing: 10,
  // min spacing between outside of nodes (used for radius adjustment)
  boundingBox: void 0,
  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: !0,
  // prevents node overlap, may overflow boundingBox if not enough space
  nodeDimensionsIncludeLabels: !1,
  // Excludes the label when calculating node bounding boxes for the layout algorithm
  height: void 0,
  // height of layout area (overrides container height)
  width: void 0,
  // width of layout area (overrides container width)
  spacingFactor: void 0,
  // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
  concentric: function(e) {
    return e.degree();
  },
  levelWidth: function(e) {
    return e.maxDegree() / 4;
  },
  animate: !1,
  // whether to transition the node positions
  animationDuration: 500,
  // duration of animation in ms if enabled
  animationEasing: void 0,
  // easing of animation if enabled
  animateFilter: function(e, r) {
    return !0;
  },
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: void 0,
  // callback on layoutready
  stop: void 0,
  // callback on layoutstop
  transform: function(e, r) {
    return r;
  }
  // transform a given node position. Useful for changing flow direction in discrete layouts
};
function _z(t) {
  this.options = At({}, pSe, t);
}
_z.prototype.run = function() {
  for (var t = this.options, e = t, r = e.counterclockwise !== void 0 ? !e.counterclockwise : e.clockwise, n = t.cy, a = e.eles, i = a.nodes().not(":parent"), s = da(e.boundingBox ? e.boundingBox : {
    x1: 0,
    y1: 0,
    w: n.width(),
    h: n.height()
  }), o = {
    x: s.x1 + s.w / 2,
    y: s.y1 + s.h / 2
  }, l = [], u = 0, c = 0; c < i.length; c++) {
    var f = i[c], h = void 0;
    h = e.concentric(f), l.push({
      value: h,
      node: f
    }), f._private.scratch.concentric = h;
  }
  i.updateStyle();
  for (var d = 0; d < i.length; d++) {
    var p = i[d], g = p.layoutDimensions(e);
    u = Math.max(u, g.w, g.h);
  }
  l.sort(function(J, Ce) {
    return Ce.value - J.value;
  });
  for (var v = e.levelWidth(i), m = [[]], b = m[0], y = 0; y < l.length; y++) {
    var x = l[y];
    if (b.length > 0) {
      var E = Math.abs(b[0].value - x.value);
      E >= v && (b = [], m.push(b));
    }
    b.push(x);
  }
  var S = u + e.minNodeSpacing;
  if (!e.avoidOverlap) {
    var w = m.length > 0 && m[0].length > 1, C = Math.min(s.w, s.h) / 2 - S, k = C / (m.length + w ? 1 : 0);
    S = Math.min(S, k);
  }
  for (var N = 0, R = 0; R < m.length; R++) {
    var _ = m[R], O = e.sweep === void 0 ? 2 * Math.PI - 2 * Math.PI / _.length : e.sweep, T = _.dTheta = O / Math.max(1, _.length - 1);
    if (_.length > 1 && e.avoidOverlap) {
      var L = Math.cos(T) - Math.cos(0), M = Math.sin(T) - Math.sin(0), A = Math.sqrt(S * S / (L * L + M * M));
      N = Math.max(A, N);
    }
    _.r = N, N += S;
  }
  if (e.equidistant) {
    for (var I = 0, D = 0, F = 0; F < m.length; F++) {
      var B = m[F], G = B.r - D;
      I = Math.max(I, G);
    }
    D = 0;
    for (var H = 0; H < m.length; H++) {
      var K = m[H];
      H === 0 && (D = K.r), K.r = D, D += I;
    }
  }
  for (var j = {}, Z = 0; Z < m.length; Z++)
    for (var te = m[Z], ne = te.dTheta, V = te.r, q = 0; q < te.length; q++) {
      var X = te[q], W = e.startAngle + (r ? 1 : -1) * ne * q, ue = {
        x: o.x + V * Math.cos(W),
        y: o.y + V * Math.sin(W)
      };
      j[X.node.id()] = ue;
    }
  return a.nodes().layoutPositions(this, e, function(J) {
    var Ce = J.id();
    return j[Ce];
  }), this;
};
var Ew, gSe = {
  // Called on `layoutready`
  ready: function() {
  },
  // Called on `layoutstop`
  stop: function() {
  },
  // Whether to animate while running the layout
  // true : Animate continuously as the layout is running
  // false : Just show the end result
  // 'end' : Animate with the end result, from the initial positions to the end positions
  animate: !0,
  // Easing of the animation for animate:'end'
  animationEasing: void 0,
  // The duration of the animation for animate:'end'
  animationDuration: void 0,
  // A function that determines whether the node should be animated
  // All nodes animated by default on animate enabled
  // Non-animated nodes are positioned immediately when the layout starts
  animateFilter: function(e, r) {
    return !0;
  },
  // The layout animates only after this many milliseconds for animate:true
  // (prevents flashing on fast runs)
  animationThreshold: 250,
  // Number of iterations between consecutive screen positions update
  refresh: 20,
  // Whether to fit the network view after when done
  fit: !0,
  // Padding on fit
  padding: 30,
  // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  boundingBox: void 0,
  // Excludes the label when calculating node bounding boxes for the layout algorithm
  nodeDimensionsIncludeLabels: !1,
  // Randomize the initial positions of the nodes (true) or use existing positions (false)
  randomize: !1,
  // Extra spacing between components in non-compound graphs
  componentSpacing: 40,
  // Node repulsion (non overlapping) multiplier
  nodeRepulsion: function(e) {
    return 2048;
  },
  // Node repulsion (overlapping) multiplier
  nodeOverlap: 4,
  // Ideal edge (non nested) length
  idealEdgeLength: function(e) {
    return 32;
  },
  // Divisor to compute edge forces
  edgeElasticity: function(e) {
    return 32;
  },
  // Nesting factor (multiplier) to compute ideal edge length for nested edges
  nestingFactor: 1.2,
  // Gravity force (constant)
  gravity: 1,
  // Maximum number of iterations to perform
  numIter: 1e3,
  // Initial temperature (maximum node displacement)
  initialTemp: 1e3,
  // Cooling factor (how the temperature is reduced between consecutive iterations
  coolingFactor: 0.99,
  // Lower temperature threshold (below this point the layout will end)
  minTemp: 1
};
function cb(t) {
  this.options = At({}, gSe, t), this.options.layout = this;
  var e = this.options.eles.nodes(), r = this.options.eles.edges(), n = r.filter(function(a) {
    var i = a.source().data("id"), s = a.target().data("id"), o = e.some(function(u) {
      return u.data("id") === i;
    }), l = e.some(function(u) {
      return u.data("id") === s;
    });
    return !o || !l;
  });
  this.options.eles = this.options.eles.not(n);
}
cb.prototype.run = function() {
  var t = this.options, e = t.cy, r = this;
  r.stopped = !1, (t.animate === !0 || t.animate === !1) && r.emit({
    type: "layoutstart",
    layout: r
  }), t.debug === !0 ? Ew = !0 : Ew = !1;
  var n = vSe(e, r, t);
  Ew && ySe(n), t.randomize && bSe(n);
  var a = uo(), i = function() {
    xSe(n, e, t), t.fit === !0 && e.fit(t.padding);
  }, s = function(h) {
    return !(r.stopped || h >= t.numIter || (wSe(n, t), n.temperature = n.temperature * t.coolingFactor, n.temperature < t.minTemp));
  }, o = function() {
    if (t.animate === !0 || t.animate === !1)
      i(), r.one("layoutstop", t.stop), r.emit({
        type: "layoutstop",
        layout: r
      });
    else {
      var h = t.eles.nodes(), d = Nz(n, t, h);
      h.layoutPositions(r, t, d);
    }
  }, l = 0, u = !0;
  if (t.animate === !0) {
    var c = function() {
      for (var h = 0; u && h < t.refresh; )
        u = s(l), l++, h++;
      if (!u)
        iL(n, t), o();
      else {
        var d = uo();
        d - a >= t.animationThreshold && i(), $m(c);
      }
    };
    c();
  } else {
    for (; u; )
      u = s(l), l++;
    iL(n, t), o();
  }
  return this;
};
cb.prototype.stop = function() {
  return this.stopped = !0, this.thread && this.thread.stop(), this.emit("layoutstop"), this;
};
cb.prototype.destroy = function() {
  return this.thread && this.thread.stop(), this;
};
var vSe = function(e, r, n) {
  for (var a = n.eles.edges(), i = n.eles.nodes(), s = da(n.boundingBox ? n.boundingBox : {
    x1: 0,
    y1: 0,
    w: e.width(),
    h: e.height()
  }), o = {
    isCompound: e.hasCompoundNodes(),
    layoutNodes: [],
    idToIndex: {},
    nodeSize: i.size(),
    graphSet: [],
    indexToGraph: [],
    layoutEdges: [],
    edgeSize: a.size(),
    temperature: n.initialTemp,
    clientWidth: s.w,
    clientHeight: s.h,
    boundingBox: s
  }, l = n.eles.components(), u = {}, c = 0; c < l.length; c++)
    for (var f = l[c], h = 0; h < f.length; h++) {
      var d = f[h];
      u[d.id()] = c;
    }
  for (var c = 0; c < o.nodeSize; c++) {
    var p = i[c], g = p.layoutDimensions(n), v = {};
    v.isLocked = p.locked(), v.id = p.data("id"), v.parentId = p.data("parent"), v.cmptId = u[p.id()], v.children = [], v.positionX = p.position("x"), v.positionY = p.position("y"), v.offsetX = 0, v.offsetY = 0, v.height = g.w, v.width = g.h, v.maxX = v.positionX + v.width / 2, v.minX = v.positionX - v.width / 2, v.maxY = v.positionY + v.height / 2, v.minY = v.positionY - v.height / 2, v.padLeft = parseFloat(p.style("padding")), v.padRight = parseFloat(p.style("padding")), v.padTop = parseFloat(p.style("padding")), v.padBottom = parseFloat(p.style("padding")), v.nodeRepulsion = Wr(n.nodeRepulsion) ? n.nodeRepulsion(p) : n.nodeRepulsion, o.layoutNodes.push(v), o.idToIndex[v.id] = c;
  }
  for (var m = [], b = 0, y = -1, x = [], c = 0; c < o.nodeSize; c++) {
    var p = o.layoutNodes[c], E = p.parentId;
    E != null ? o.layoutNodes[o.idToIndex[E]].children.push(p.id) : (m[++y] = p.id, x.push(p.id));
  }
  for (o.graphSet.push(x); b <= y; ) {
    var S = m[b++], w = o.idToIndex[S], d = o.layoutNodes[w], C = d.children;
    if (C.length > 0) {
      o.graphSet.push(C);
      for (var c = 0; c < C.length; c++)
        m[++y] = C[c];
    }
  }
  for (var c = 0; c < o.graphSet.length; c++)
    for (var k = o.graphSet[c], h = 0; h < k.length; h++) {
      var N = o.idToIndex[k[h]];
      o.indexToGraph[N] = c;
    }
  for (var c = 0; c < o.edgeSize; c++) {
    var R = a[c], _ = {};
    _.id = R.data("id"), _.sourceId = R.data("source"), _.targetId = R.data("target");
    var O = Wr(n.idealEdgeLength) ? n.idealEdgeLength(R) : n.idealEdgeLength, T = Wr(n.edgeElasticity) ? n.edgeElasticity(R) : n.edgeElasticity, L = o.idToIndex[_.sourceId], M = o.idToIndex[_.targetId], A = o.indexToGraph[L], I = o.indexToGraph[M];
    if (A != I) {
      for (var D = mSe(_.sourceId, _.targetId, o), F = o.graphSet[D], B = 0, v = o.layoutNodes[L]; F.indexOf(v.id) === -1; )
        v = o.layoutNodes[o.idToIndex[v.parentId]], B++;
      for (v = o.layoutNodes[M]; F.indexOf(v.id) === -1; )
        v = o.layoutNodes[o.idToIndex[v.parentId]], B++;
      O *= B * n.nestingFactor;
    }
    _.idealLength = O, _.elasticity = T, o.layoutEdges.push(_);
  }
  return o;
}, mSe = function(e, r, n) {
  var a = Lz(e, r, 0, n);
  return 2 > a.count ? 0 : a.graph;
}, Lz = function(e, r, n, a) {
  var i = a.graphSet[n];
  if (-1 < i.indexOf(e) && -1 < i.indexOf(r))
    return {
      count: 2,
      graph: n
    };
  for (var s = 0, o = 0; o < i.length; o++) {
    var l = i[o], u = a.idToIndex[l], c = a.layoutNodes[u].children;
    if (c.length !== 0) {
      var f = a.indexToGraph[a.idToIndex[c[0]]], h = Lz(e, r, f, a);
      if (h.count !== 0)
        if (h.count === 1) {
          if (s++, s === 2)
            break;
        } else
          return h;
    }
  }
  return {
    count: s,
    graph: n
  };
}, ySe, bSe = function(e, r) {
  for (var n = e.clientWidth, a = e.clientHeight, i = 0; i < e.nodeSize; i++) {
    var s = e.layoutNodes[i];
    s.children.length === 0 && !s.isLocked && (s.positionX = Math.random() * n, s.positionY = Math.random() * a);
  }
}, Nz = function(e, r, n) {
  var a = e.boundingBox, i = {
    x1: 1 / 0,
    x2: -1 / 0,
    y1: 1 / 0,
    y2: -1 / 0
  };
  return r.boundingBox && (n.forEach(function(s) {
    var o = e.layoutNodes[e.idToIndex[s.data("id")]];
    i.x1 = Math.min(i.x1, o.positionX), i.x2 = Math.max(i.x2, o.positionX), i.y1 = Math.min(i.y1, o.positionY), i.y2 = Math.max(i.y2, o.positionY);
  }), i.w = i.x2 - i.x1, i.h = i.y2 - i.y1), function(s, o) {
    var l = e.layoutNodes[e.idToIndex[s.data("id")]];
    if (r.boundingBox) {
      var u = i.w === 0 ? 0.5 : (l.positionX - i.x1) / i.w, c = i.h === 0 ? 0.5 : (l.positionY - i.y1) / i.h;
      return {
        x: a.x1 + u * a.w,
        y: a.y1 + c * a.h
      };
    } else
      return {
        x: l.positionX,
        y: l.positionY
      };
  };
}, xSe = function(e, r, n) {
  var a = n.layout, i = n.eles.nodes(), s = Nz(e, n, i);
  i.positions(s), e.ready !== !0 && (e.ready = !0, a.one("layoutready", n.ready), a.emit({
    type: "layoutready",
    layout: this
  }));
}, wSe = function(e, r, n) {
  ESe(e, r), CSe(e), ASe(e, r), kSe(e), RSe(e);
}, ESe = function(e, r) {
  for (var n = 0; n < e.graphSet.length; n++)
    for (var a = e.graphSet[n], i = a.length, s = 0; s < i; s++)
      for (var o = e.layoutNodes[e.idToIndex[a[s]]], l = s + 1; l < i; l++) {
        var u = e.layoutNodes[e.idToIndex[a[l]]];
        TSe(o, u, e, r);
      }
}, aL = function(e) {
  return -1 + 2 * e * Math.random();
}, TSe = function(e, r, n, a) {
  var i = e.cmptId, s = r.cmptId;
  if (!(i !== s && !n.isCompound)) {
    var o = r.positionX - e.positionX, l = r.positionY - e.positionY, u = 1;
    o === 0 && l === 0 && (o = aL(u), l = aL(u));
    var c = SSe(e, r, o, l);
    if (c > 0)
      var f = a.nodeOverlap * c, h = Math.sqrt(o * o + l * l), d = f * o / h, p = f * l / h;
    else
      var g = Vm(e, o, l), v = Vm(r, -1 * o, -1 * l), m = v.x - g.x, b = v.y - g.y, y = m * m + b * b, h = Math.sqrt(y), f = (e.nodeRepulsion + r.nodeRepulsion) / y, d = f * m / h, p = f * b / h;
    e.isLocked || (e.offsetX -= d, e.offsetY -= p), r.isLocked || (r.offsetX += d, r.offsetY += p);
  }
}, SSe = function(e, r, n, a) {
  if (n > 0)
    var i = e.maxX - r.minX;
  else
    var i = r.maxX - e.minX;
  if (a > 0)
    var s = e.maxY - r.minY;
  else
    var s = r.maxY - e.minY;
  return i >= 0 && s >= 0 ? Math.sqrt(i * i + s * s) : 0;
}, Vm = function(e, r, n) {
  var a = e.positionX, i = e.positionY, s = e.height || 1, o = e.width || 1, l = n / r, u = s / o, c = {};
  return r === 0 && 0 < n || r === 0 && 0 > n ? (c.x = a, c.y = i + s / 2, c) : 0 < r && -1 * u <= l && l <= u ? (c.x = a + o / 2, c.y = i + o * n / 2 / r, c) : 0 > r && -1 * u <= l && l <= u ? (c.x = a - o / 2, c.y = i - o * n / 2 / r, c) : 0 < n && (l <= -1 * u || l >= u) ? (c.x = a + s * r / 2 / n, c.y = i + s / 2, c) : (0 > n && (l <= -1 * u || l >= u) && (c.x = a - s * r / 2 / n, c.y = i - s / 2), c);
}, CSe = function(e, r) {
  for (var n = 0; n < e.edgeSize; n++) {
    var a = e.layoutEdges[n], i = e.idToIndex[a.sourceId], s = e.layoutNodes[i], o = e.idToIndex[a.targetId], l = e.layoutNodes[o], u = l.positionX - s.positionX, c = l.positionY - s.positionY;
    if (!(u === 0 && c === 0)) {
      var f = Vm(s, u, c), h = Vm(l, -1 * u, -1 * c), d = h.x - f.x, p = h.y - f.y, g = Math.sqrt(d * d + p * p), v = Math.pow(a.idealLength - g, 2) / a.elasticity;
      if (g !== 0)
        var m = v * d / g, b = v * p / g;
      else
        var m = 0, b = 0;
      s.isLocked || (s.offsetX += m, s.offsetY += b), l.isLocked || (l.offsetX -= m, l.offsetY -= b);
    }
  }
}, ASe = function(e, r) {
  if (r.gravity !== 0)
    for (var n = 1, a = 0; a < e.graphSet.length; a++) {
      var i = e.graphSet[a], s = i.length;
      if (a === 0)
        var o = e.clientHeight / 2, l = e.clientWidth / 2;
      else
        var u = e.layoutNodes[e.idToIndex[i[0]]], c = e.layoutNodes[e.idToIndex[u.parentId]], o = c.positionX, l = c.positionY;
      for (var f = 0; f < s; f++) {
        var h = e.layoutNodes[e.idToIndex[i[f]]];
        if (!h.isLocked) {
          var d = o - h.positionX, p = l - h.positionY, g = Math.sqrt(d * d + p * p);
          if (g > n) {
            var v = r.gravity * d / g, m = r.gravity * p / g;
            h.offsetX += v, h.offsetY += m;
          }
        }
      }
    }
}, kSe = function(e, r) {
  var n = [], a = 0, i = -1;
  for (n.push.apply(n, e.graphSet[0]), i += e.graphSet[0].length; a <= i; ) {
    var s = n[a++], o = e.idToIndex[s], l = e.layoutNodes[o], u = l.children;
    if (0 < u.length && !l.isLocked) {
      for (var c = l.offsetX, f = l.offsetY, h = 0; h < u.length; h++) {
        var d = e.layoutNodes[e.idToIndex[u[h]]];
        d.offsetX += c, d.offsetY += f, n[++i] = u[h];
      }
      l.offsetX = 0, l.offsetY = 0;
    }
  }
}, RSe = function(e, r) {
  for (var n = 0; n < e.nodeSize; n++) {
    var a = e.layoutNodes[n];
    0 < a.children.length && (a.maxX = void 0, a.minX = void 0, a.maxY = void 0, a.minY = void 0);
  }
  for (var n = 0; n < e.nodeSize; n++) {
    var a = e.layoutNodes[n];
    if (!(0 < a.children.length || a.isLocked)) {
      var i = MSe(a.offsetX, a.offsetY, e.temperature);
      a.positionX += i.x, a.positionY += i.y, a.offsetX = 0, a.offsetY = 0, a.minX = a.positionX - a.width, a.maxX = a.positionX + a.width, a.minY = a.positionY - a.height, a.maxY = a.positionY + a.height, Oz(a, e);
    }
  }
  for (var n = 0; n < e.nodeSize; n++) {
    var a = e.layoutNodes[n];
    0 < a.children.length && !a.isLocked && (a.positionX = (a.maxX + a.minX) / 2, a.positionY = (a.maxY + a.minY) / 2, a.width = a.maxX - a.minX, a.height = a.maxY - a.minY);
  }
}, MSe = function(e, r, n) {
  var a = Math.sqrt(e * e + r * r);
  if (a > n)
    var i = {
      x: n * e / a,
      y: n * r / a
    };
  else
    var i = {
      x: e,
      y: r
    };
  return i;
}, Oz = function(e, r) {
  var n = e.parentId;
  if (n != null) {
    var a = r.layoutNodes[r.idToIndex[n]], i = !1;
    if ((a.maxX == null || e.maxX + a.padRight > a.maxX) && (a.maxX = e.maxX + a.padRight, i = !0), (a.minX == null || e.minX - a.padLeft < a.minX) && (a.minX = e.minX - a.padLeft, i = !0), (a.maxY == null || e.maxY + a.padBottom > a.maxY) && (a.maxY = e.maxY + a.padBottom, i = !0), (a.minY == null || e.minY - a.padTop < a.minY) && (a.minY = e.minY - a.padTop, i = !0), i)
      return Oz(a, r);
  }
}, iL = function(e, r) {
  for (var n = e.layoutNodes, a = [], i = 0; i < n.length; i++) {
    var s = n[i], o = s.cmptId, l = a[o] = a[o] || [];
    l.push(s);
  }
  for (var u = 0, i = 0; i < a.length; i++) {
    var c = a[i];
    if (c) {
      c.x1 = 1 / 0, c.x2 = -1 / 0, c.y1 = 1 / 0, c.y2 = -1 / 0;
      for (var f = 0; f < c.length; f++) {
        var h = c[f];
        c.x1 = Math.min(c.x1, h.positionX - h.width / 2), c.x2 = Math.max(c.x2, h.positionX + h.width / 2), c.y1 = Math.min(c.y1, h.positionY - h.height / 2), c.y2 = Math.max(c.y2, h.positionY + h.height / 2);
      }
      c.w = c.x2 - c.x1, c.h = c.y2 - c.y1, u += c.w * c.h;
    }
  }
  a.sort(function(b, y) {
    return y.w * y.h - b.w * b.h;
  });
  for (var d = 0, p = 0, g = 0, v = 0, m = Math.sqrt(u) * e.clientWidth / e.clientHeight, i = 0; i < a.length; i++) {
    var c = a[i];
    if (c) {
      for (var f = 0; f < c.length; f++) {
        var h = c[f];
        h.isLocked || (h.positionX += d - c.x1, h.positionY += p - c.y1);
      }
      d += c.w + r.componentSpacing, g += c.w + r.componentSpacing, v = Math.max(v, c.h), g > m && (p += v + r.componentSpacing, d = 0, g = 0, v = 0);
    }
  }
}, _Se = {
  fit: !0,
  // whether to fit the viewport to the graph
  padding: 30,
  // padding used on fit
  boundingBox: void 0,
  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: !0,
  // prevents node overlap, may overflow boundingBox if not enough space
  avoidOverlapPadding: 10,
  // extra spacing around nodes when avoidOverlap: true
  nodeDimensionsIncludeLabels: !1,
  // Excludes the label when calculating node bounding boxes for the layout algorithm
  spacingFactor: void 0,
  // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
  condense: !1,
  // uses all available space on false, uses minimal space on true
  rows: void 0,
  // force num of rows in the grid
  cols: void 0,
  // force num of columns in the grid
  position: function(e) {
  },
  // returns { row, col } for element
  sort: void 0,
  // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
  animate: !1,
  // whether to transition the node positions
  animationDuration: 500,
  // duration of animation in ms if enabled
  animationEasing: void 0,
  // easing of animation if enabled
  animateFilter: function(e, r) {
    return !0;
  },
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: void 0,
  // callback on layoutready
  stop: void 0,
  // callback on layoutstop
  transform: function(e, r) {
    return r;
  }
  // transform a given node position. Useful for changing flow direction in discrete layouts 
};
function Iz(t) {
  this.options = At({}, _Se, t);
}
Iz.prototype.run = function() {
  var t = this.options, e = t, r = t.cy, n = e.eles, a = n.nodes().not(":parent");
  e.sort && (a = a.sort(e.sort));
  var i = da(e.boundingBox ? e.boundingBox : {
    x1: 0,
    y1: 0,
    w: r.width(),
    h: r.height()
  });
  if (i.h === 0 || i.w === 0)
    n.nodes().layoutPositions(this, e, function(H) {
      return {
        x: i.x1,
        y: i.y1
      };
    });
  else {
    var s = a.size(), o = Math.sqrt(s * i.h / i.w), l = Math.round(o), u = Math.round(i.w / i.h * o), c = function(K) {
      if (K == null)
        return Math.min(l, u);
      var j = Math.min(l, u);
      j == l ? l = K : u = K;
    }, f = function(K) {
      if (K == null)
        return Math.max(l, u);
      var j = Math.max(l, u);
      j == l ? l = K : u = K;
    }, h = e.rows, d = e.cols != null ? e.cols : e.columns;
    if (h != null && d != null)
      l = h, u = d;
    else if (h != null && d == null)
      l = h, u = Math.ceil(s / l);
    else if (h == null && d != null)
      u = d, l = Math.ceil(s / u);
    else if (u * l > s) {
      var p = c(), g = f();
      (p - 1) * g >= s ? c(p - 1) : (g - 1) * p >= s && f(g - 1);
    } else
      for (; u * l < s; ) {
        var v = c(), m = f();
        (m + 1) * v >= s ? f(m + 1) : c(v + 1);
      }
    var b = i.w / u, y = i.h / l;
    if (e.condense && (b = 0, y = 0), e.avoidOverlap)
      for (var x = 0; x < a.length; x++) {
        var E = a[x], S = E._private.position;
        (S.x == null || S.y == null) && (S.x = 0, S.y = 0);
        var w = E.layoutDimensions(e), C = e.avoidOverlapPadding, k = w.w + C, N = w.h + C;
        b = Math.max(b, k), y = Math.max(y, N);
      }
    for (var R = {}, _ = function(K, j) {
      return !!R["c-" + K + "-" + j];
    }, O = function(K, j) {
      R["c-" + K + "-" + j] = !0;
    }, T = 0, L = 0, M = function() {
      L++, L >= u && (L = 0, T++);
    }, A = {}, I = 0; I < a.length; I++) {
      var D = a[I], F = e.position(D);
      if (F && (F.row !== void 0 || F.col !== void 0)) {
        var B = {
          row: F.row,
          col: F.col
        };
        if (B.col === void 0)
          for (B.col = 0; _(B.row, B.col); )
            B.col++;
        else if (B.row === void 0)
          for (B.row = 0; _(B.row, B.col); )
            B.row++;
        A[D.id()] = B, O(B.row, B.col);
      }
    }
    var G = function(K, j) {
      var Z, te;
      if (K.locked() || K.isParent())
        return !1;
      var ne = A[K.id()];
      if (ne)
        Z = ne.col * b + b / 2 + i.x1, te = ne.row * y + y / 2 + i.y1;
      else {
        for (; _(T, L); )
          M();
        Z = L * b + b / 2 + i.x1, te = T * y + y / 2 + i.y1, O(T, L), M();
      }
      return {
        x: Z,
        y: te
      };
    };
    a.layoutPositions(this, e, G);
  }
  return this;
};
var LSe = {
  ready: function() {
  },
  // on layoutready
  stop: function() {
  }
  // on layoutstop
};
function x3(t) {
  this.options = At({}, LSe, t);
}
x3.prototype.run = function() {
  var t = this.options, e = t.eles, r = this;
  return t.cy, r.emit("layoutstart"), e.nodes().positions(function() {
    return {
      x: 0,
      y: 0
    };
  }), r.one("layoutready", t.ready), r.emit("layoutready"), r.one("layoutstop", t.stop), r.emit("layoutstop"), this;
};
x3.prototype.stop = function() {
  return this;
};
var NSe = {
  positions: void 0,
  // map of (node id) => (position obj); or function(node){ return somPos; }
  zoom: void 0,
  // the zoom level to set (prob want fit = false if set)
  pan: void 0,
  // the pan level to set (prob want fit = false if set)
  fit: !0,
  // whether to fit to viewport
  padding: 30,
  // padding on fit
  spacingFactor: void 0,
  // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
  animate: !1,
  // whether to transition the node positions
  animationDuration: 500,
  // duration of animation in ms if enabled
  animationEasing: void 0,
  // easing of animation if enabled
  animateFilter: function(e, r) {
    return !0;
  },
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: void 0,
  // callback on layoutready
  stop: void 0,
  // callback on layoutstop
  transform: function(e, r) {
    return r;
  }
  // transform a given node position. Useful for changing flow direction in discrete layouts
};
function Pz(t) {
  this.options = At({}, NSe, t);
}
Pz.prototype.run = function() {
  var t = this.options, e = t.eles, r = e.nodes(), n = Wr(t.positions);
  function a(i) {
    if (t.positions == null)
      return eEe(i.position());
    if (n)
      return t.positions(i);
    var s = t.positions[i._private.data.id];
    return s ?? null;
  }
  return r.layoutPositions(this, t, function(i, s) {
    var o = a(i);
    return i.locked() || o == null ? !1 : o;
  }), this;
};
var OSe = {
  fit: !0,
  // whether to fit to viewport
  padding: 30,
  // fit padding
  boundingBox: void 0,
  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  animate: !1,
  // whether to transition the node positions
  animationDuration: 500,
  // duration of animation in ms if enabled
  animationEasing: void 0,
  // easing of animation if enabled
  animateFilter: function(e, r) {
    return !0;
  },
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: void 0,
  // callback on layoutready
  stop: void 0,
  // callback on layoutstop
  transform: function(e, r) {
    return r;
  }
  // transform a given node position. Useful for changing flow direction in discrete layouts 
};
function Dz(t) {
  this.options = At({}, OSe, t);
}
Dz.prototype.run = function() {
  var t = this.options, e = t.cy, r = t.eles, n = da(t.boundingBox ? t.boundingBox : {
    x1: 0,
    y1: 0,
    w: e.width(),
    h: e.height()
  }), a = function(s, o) {
    return {
      x: n.x1 + Math.round(Math.random() * n.w),
      y: n.y1 + Math.round(Math.random() * n.h)
    };
  };
  return r.nodes().layoutPositions(this, t, a), this;
};
var ISe = [{
  name: "breadthfirst",
  impl: Rz
}, {
  name: "circle",
  impl: Mz
}, {
  name: "concentric",
  impl: _z
}, {
  name: "cose",
  impl: cb
}, {
  name: "grid",
  impl: Iz
}, {
  name: "null",
  impl: x3
}, {
  name: "preset",
  impl: Pz
}, {
  name: "random",
  impl: Dz
}];
function $z(t) {
  this.options = t, this.notifications = 0;
}
var sL = function() {
}, oL = function() {
  throw new Error("A headless instance can not render images");
};
$z.prototype = {
  recalculateRenderedStyle: sL,
  notify: function() {
    this.notifications++;
  },
  init: sL,
  isHeadless: function() {
    return !0;
  },
  png: oL,
  jpg: oL
};
var w3 = {};
w3.arrowShapeWidth = 0.3;
w3.registerArrowShapes = function() {
  var t = this.arrowShapes = {}, e = this, r = function(u, c, f, h, d, p, g) {
    var v = d.x - f / 2 - g, m = d.x + f / 2 + g, b = d.y - f / 2 - g, y = d.y + f / 2 + g, x = v <= u && u <= m && b <= c && c <= y;
    return x;
  }, n = function(u, c, f, h, d) {
    var p = u * Math.cos(h) - c * Math.sin(h), g = u * Math.sin(h) + c * Math.cos(h), v = p * f, m = g * f, b = v + d.x, y = m + d.y;
    return {
      x: b,
      y
    };
  }, a = function(u, c, f, h) {
    for (var d = [], p = 0; p < u.length; p += 2) {
      var g = u[p], v = u[p + 1];
      d.push(n(g, v, c, f, h));
    }
    return d;
  }, i = function(u) {
    for (var c = [], f = 0; f < u.length; f++) {
      var h = u[f];
      c.push(h.x, h.y);
    }
    return c;
  }, s = function(u) {
    return u.pstyle("width").pfValue * u.pstyle("arrow-scale").pfValue * 2;
  }, o = function(u, c) {
    xt(c) && (c = t[c]), t[u] = At({
      name: u,
      points: [-0.15, -0.3, 0.15, -0.3, 0.15, 0.3, -0.15, 0.3],
      collide: function(h, d, p, g, v, m) {
        var b = i(a(this.points, p + 2 * m, g, v)), y = Sa(h, d, b);
        return y;
      },
      roughCollide: r,
      draw: function(h, d, p, g) {
        var v = a(this.points, d, p, g);
        e.arrowShapeImpl("polygon")(h, v);
      },
      spacing: function(h) {
        return 0;
      },
      gap: s
    }, c);
  };
  o("none", {
    collide: Fm,
    roughCollide: Fm,
    draw: s3,
    spacing: wM,
    gap: wM
  }), o("triangle", {
    points: [-0.15, -0.3, 0, 0, 0.15, -0.3]
  }), o("arrow", "triangle"), o("triangle-backcurve", {
    points: t.triangle.points,
    controlPoint: [0, -0.15],
    roughCollide: r,
    draw: function(u, c, f, h, d) {
      var p = a(this.points, c, f, h), g = this.controlPoint, v = n(g[0], g[1], c, f, h);
      e.arrowShapeImpl(this.name)(u, p, v);
    },
    gap: function(u) {
      return s(u) * 0.8;
    }
  }), o("triangle-tee", {
    points: [0, 0, 0.15, -0.3, -0.15, -0.3, 0, 0],
    pointsTee: [-0.15, -0.4, -0.15, -0.5, 0.15, -0.5, 0.15, -0.4],
    collide: function(u, c, f, h, d, p, g) {
      var v = i(a(this.points, f + 2 * g, h, d)), m = i(a(this.pointsTee, f + 2 * g, h, d)), b = Sa(u, c, v) || Sa(u, c, m);
      return b;
    },
    draw: function(u, c, f, h, d) {
      var p = a(this.points, c, f, h), g = a(this.pointsTee, c, f, h);
      e.arrowShapeImpl(this.name)(u, p, g);
    }
  }), o("circle-triangle", {
    radius: 0.15,
    pointsTr: [0, -0.15, 0.15, -0.45, -0.15, -0.45, 0, -0.15],
    collide: function(u, c, f, h, d, p, g) {
      var v = d, m = Math.pow(v.x - u, 2) + Math.pow(v.y - c, 2) <= Math.pow((f + 2 * g) * this.radius, 2), b = i(a(this.points, f + 2 * g, h, d));
      return Sa(u, c, b) || m;
    },
    draw: function(u, c, f, h, d) {
      var p = a(this.pointsTr, c, f, h);
      e.arrowShapeImpl(this.name)(u, p, h.x, h.y, this.radius * c);
    },
    spacing: function(u) {
      return e.getArrowWidth(u.pstyle("width").pfValue, u.pstyle("arrow-scale").value) * this.radius;
    }
  }), o("triangle-cross", {
    points: [0, 0, 0.15, -0.3, -0.15, -0.3, 0, 0],
    baseCrossLinePts: [
      -0.15,
      -0.4,
      // first half of the rectangle
      -0.15,
      -0.4,
      0.15,
      -0.4,
      // second half of the rectangle
      0.15,
      -0.4
    ],
    crossLinePts: function(u, c) {
      var f = this.baseCrossLinePts.slice(), h = c / u, d = 3, p = 5;
      return f[d] = f[d] - h, f[p] = f[p] - h, f;
    },
    collide: function(u, c, f, h, d, p, g) {
      var v = i(a(this.points, f + 2 * g, h, d)), m = i(a(this.crossLinePts(f, p), f + 2 * g, h, d)), b = Sa(u, c, v) || Sa(u, c, m);
      return b;
    },
    draw: function(u, c, f, h, d) {
      var p = a(this.points, c, f, h), g = a(this.crossLinePts(c, d), c, f, h);
      e.arrowShapeImpl(this.name)(u, p, g);
    }
  }), o("vee", {
    points: [-0.15, -0.3, 0, 0, 0.15, -0.3, 0, -0.15],
    gap: function(u) {
      return s(u) * 0.525;
    }
  }), o("circle", {
    radius: 0.15,
    collide: function(u, c, f, h, d, p, g) {
      var v = d, m = Math.pow(v.x - u, 2) + Math.pow(v.y - c, 2) <= Math.pow((f + 2 * g) * this.radius, 2);
      return m;
    },
    draw: function(u, c, f, h, d) {
      e.arrowShapeImpl(this.name)(u, h.x, h.y, this.radius * c);
    },
    spacing: function(u) {
      return e.getArrowWidth(u.pstyle("width").pfValue, u.pstyle("arrow-scale").value) * this.radius;
    }
  }), o("tee", {
    points: [-0.15, 0, -0.15, -0.1, 0.15, -0.1, 0.15, 0],
    spacing: function(u) {
      return 1;
    },
    gap: function(u) {
      return 1;
    }
  }), o("square", {
    points: [-0.15, 0, 0.15, 0, 0.15, -0.3, -0.15, -0.3]
  }), o("diamond", {
    points: [-0.15, -0.15, 0, -0.3, 0.15, -0.15, 0, 0],
    gap: function(u) {
      return u.pstyle("width").pfValue * u.pstyle("arrow-scale").value;
    }
  }), o("chevron", {
    points: [0, 0, -0.15, -0.15, -0.1, -0.2, 0, -0.1, 0.1, -0.2, 0.15, -0.15],
    gap: function(u) {
      return 0.95 * u.pstyle("width").pfValue * u.pstyle("arrow-scale").value;
    }
  });
};
var _u = {};
_u.projectIntoViewport = function(t, e) {
  var r = this.cy, n = this.findContainerClientCoords(), a = n[0], i = n[1], s = n[4], o = r.pan(), l = r.zoom(), u = ((t - a) / s - o.x) / l, c = ((e - i) / s - o.y) / l;
  return [u, c];
};
_u.findContainerClientCoords = function() {
  if (this.containerBB)
    return this.containerBB;
  var t = this.container, e = t.getBoundingClientRect(), r = this.cy.window().getComputedStyle(t), n = function(m) {
    return parseFloat(r.getPropertyValue(m));
  }, a = {
    left: n("padding-left"),
    right: n("padding-right"),
    top: n("padding-top"),
    bottom: n("padding-bottom")
  }, i = {
    left: n("border-left-width"),
    right: n("border-right-width"),
    top: n("border-top-width"),
    bottom: n("border-bottom-width")
  }, s = t.clientWidth, o = t.clientHeight, l = a.left + a.right, u = a.top + a.bottom, c = i.left + i.right, f = e.width / (s + c), h = s - l, d = o - u, p = e.left + a.left + i.left, g = e.top + a.top + i.top;
  return this.containerBB = [p, g, h, d, f];
};
_u.invalidateContainerClientCoordsCache = function() {
  this.containerBB = null;
};
_u.findNearestElement = function(t, e, r, n) {
  return this.findNearestElements(t, e, r, n)[0];
};
_u.findNearestElements = function(t, e, r, n) {
  var a = this, i = this, s = i.getCachedZSortedEles(), o = [], l = i.cy.zoom(), u = i.cy.hasCompoundNodes(), c = (n ? 24 : 8) / l, f = (n ? 8 : 2) / l, h = (n ? 8 : 2) / l, d = 1 / 0, p, g;
  r && (s = s.interactive);
  function v(w, C) {
    if (w.isNode()) {
      if (g)
        return;
      g = w, o.push(w);
    }
    if (w.isEdge() && (C == null || C < d))
      if (p) {
        if (p.pstyle("z-compound-depth").value === w.pstyle("z-compound-depth").value && p.pstyle("z-compound-depth").value === w.pstyle("z-compound-depth").value) {
          for (var k = 0; k < o.length; k++)
            if (o[k].isEdge()) {
              o[k] = w, p = w, d = C ?? d;
              break;
            }
        }
      } else
        o.push(w), p = w, d = C ?? d;
  }
  function m(w) {
    var C = w.outerWidth() + 2 * f, k = w.outerHeight() + 2 * f, N = C / 2, R = k / 2, _ = w.position(), O = w.pstyle("corner-radius").value === "auto" ? "auto" : w.pstyle("corner-radius").pfValue, T = w._private.rscratch;
    if (_.x - N <= t && t <= _.x + N && _.y - R <= e && e <= _.y + R) {
      var L = i.nodeShapes[a.getNodeShape(w)];
      if (L.checkPoint(t, e, 0, C, k, _.x, _.y, O, T))
        return v(w, 0), !0;
    }
  }
  function b(w) {
    var C = w._private, k = C.rscratch, N = w.pstyle("width").pfValue, R = w.pstyle("arrow-scale").value, _ = N / 2 + c, O = _ * _, T = _ * 2, I = C.source, D = C.target, L;
    if (k.edgeType === "segments" || k.edgeType === "straight" || k.edgeType === "haystack") {
      for (var M = k.allpts, A = 0; A + 3 < M.length; A += 2)
        if (pEe(t, e, M[A], M[A + 1], M[A + 2], M[A + 3], T) && O > (L = bEe(t, e, M[A], M[A + 1], M[A + 2], M[A + 3])))
          return v(w, L), !0;
    } else if (k.edgeType === "bezier" || k.edgeType === "multibezier" || k.edgeType === "self" || k.edgeType === "compound") {
      for (var M = k.allpts, A = 0; A + 5 < k.allpts.length; A += 4)
        if (gEe(t, e, M[A], M[A + 1], M[A + 2], M[A + 3], M[A + 4], M[A + 5], T) && O > (L = yEe(t, e, M[A], M[A + 1], M[A + 2], M[A + 3], M[A + 4], M[A + 5])))
          return v(w, L), !0;
    }
    for (var I = I || C.source, D = D || C.target, F = a.getArrowWidth(N, R), B = [{
      name: "source",
      x: k.arrowStartX,
      y: k.arrowStartY,
      angle: k.srcArrowAngle
    }, {
      name: "target",
      x: k.arrowEndX,
      y: k.arrowEndY,
      angle: k.tgtArrowAngle
    }, {
      name: "mid-source",
      x: k.midX,
      y: k.midY,
      angle: k.midsrcArrowAngle
    }, {
      name: "mid-target",
      x: k.midX,
      y: k.midY,
      angle: k.midtgtArrowAngle
    }], A = 0; A < B.length; A++) {
      var G = B[A], H = i.arrowShapes[w.pstyle(G.name + "-arrow-shape").value], K = w.pstyle("width").pfValue;
      if (H.roughCollide(t, e, F, G.angle, {
        x: G.x,
        y: G.y
      }, K, c) && H.collide(t, e, F, G.angle, {
        x: G.x,
        y: G.y
      }, K, c))
        return v(w), !0;
    }
    u && o.length > 0 && (m(I), m(D));
  }
  function y(w, C, k) {
    return Ta(w, C, k);
  }
  function x(w, C) {
    var k = w._private, N = h, R;
    C ? R = C + "-" : R = "", w.boundingBox();
    var _ = k.labelBounds[C || "main"], O = w.pstyle(R + "label").value, T = w.pstyle("text-events").strValue === "yes";
    if (!(!T || !O)) {
      var L = y(k.rscratch, "labelX", C), M = y(k.rscratch, "labelY", C), A = y(k.rscratch, "labelAngle", C), I = w.pstyle(R + "text-margin-x").pfValue, D = w.pstyle(R + "text-margin-y").pfValue, F = _.x1 - N - I, B = _.x2 + N - I, G = _.y1 - N - D, H = _.y2 + N - D;
      if (A) {
        var K = Math.cos(A), j = Math.sin(A), Z = function(ue, J) {
          return ue = ue - L, J = J - M, {
            x: ue * K - J * j + L,
            y: ue * j + J * K + M
          };
        }, te = Z(F, G), ne = Z(F, H), V = Z(B, G), q = Z(B, H), X = [
          // with the margin added after the rotation is applied
          te.x + I,
          te.y + D,
          V.x + I,
          V.y + D,
          q.x + I,
          q.y + D,
          ne.x + I,
          ne.y + D
        ];
        if (Sa(t, e, X))
          return v(w), !0;
      } else if (Do(_, t, e))
        return v(w), !0;
    }
  }
  for (var E = s.length - 1; E >= 0; E--) {
    var S = s[E];
    S.isNode() ? m(S) || x(S) : b(S) || x(S) || x(S, "source") || x(S, "target");
  }
  return o;
};
_u.getAllInBox = function(t, e, r, n) {
  var a = this.getCachedZSortedEles().interactive, i = this.cy.zoom(), s = 2 / i, o = [], l = Math.min(t, r), u = Math.max(t, r), c = Math.min(e, n), f = Math.max(e, n);
  t = l, r = u, e = c, n = f;
  var h = da({
    x1: t,
    y1: e,
    x2: r,
    y2: n
  }), d = [{
    x: h.x1,
    y: h.y1
  }, {
    x: h.x2,
    y: h.y1
  }, {
    x: h.x2,
    y: h.y2
  }, {
    x: h.x1,
    y: h.y2
  }], p = [[d[0], d[1]], [d[1], d[2]], [d[2], d[3]], [d[3], d[0]]];
  function g(ue, J, Ce) {
    return Ta(ue, J, Ce);
  }
  function v(ue, J) {
    var Ce = ue._private, Ee = s, Te = "";
    ue.boundingBox();
    var me = Ce.labelBounds.main;
    if (!me)
      return null;
    var we = g(Ce.rscratch, "labelX", J), Ae = g(Ce.rscratch, "labelY", J), Ne = g(Ce.rscratch, "labelAngle", J), Ie = ue.pstyle(Te + "text-margin-x").pfValue, Me = ue.pstyle(Te + "text-margin-y").pfValue, _e = me.x1 - Ee - Ie, Be = me.x2 + Ee - Ie, st = me.y1 - Ee - Me, ct = me.y2 + Ee - Me;
    if (Ne) {
      var dt = Math.cos(Ne), ft = Math.sin(Ne), rt = function(ae, z) {
        return ae = ae - we, z = z - Ae, {
          x: ae * dt - z * ft + we,
          y: ae * ft + z * dt + Ae
        };
      };
      return [rt(_e, st), rt(Be, st), rt(Be, ct), rt(_e, ct)];
    } else
      return [{
        x: _e,
        y: st
      }, {
        x: Be,
        y: st
      }, {
        x: Be,
        y: ct
      }, {
        x: _e,
        y: ct
      }];
  }
  function m(ue, J, Ce, Ee) {
    function Te(me, we, Ae) {
      return (Ae.y - me.y) * (we.x - me.x) > (we.y - me.y) * (Ae.x - me.x);
    }
    return Te(ue, Ce, Ee) !== Te(J, Ce, Ee) && Te(ue, J, Ce) !== Te(ue, J, Ee);
  }
  for (var b = 0; b < a.length; b++) {
    var y = a[b];
    if (y.isNode()) {
      var x = y, E = x.pstyle("text-events").strValue === "yes", S = x.pstyle("box-selection").strValue, w = x.pstyle("box-select-labels").strValue === "yes";
      if (S === "none")
        continue;
      var C = (S === "overlap" || w) && E, k = x.boundingBox({
        includeNodes: !0,
        includeEdges: !1,
        includeLabels: C
      });
      if (S === "contain") {
        var N = !1;
        if (w && E) {
          var R = v(x);
          R && x2(R, d) && (o.push(x), N = !0);
        }
        !N && VB(h, k) && o.push(x);
      } else if (S === "overlap" && c3(h, k)) {
        var _ = x.boundingBox({
          includeNodes: !0,
          includeEdges: !0,
          includeLabels: !1,
          includeMainLabels: !1,
          includeSourceLabels: !1,
          includeTargetLabels: !1
        }), O = [{
          x: _.x1,
          y: _.y1
        }, {
          x: _.x2,
          y: _.y1
        }, {
          x: _.x2,
          y: _.y2
        }, {
          x: _.x1,
          y: _.y2
        }];
        if (x2(O, d))
          o.push(x);
        else {
          var T = v(x);
          T && x2(T, d) && o.push(x);
        }
      }
    } else {
      var L = y, M = L._private, A = M.rscratch, I = L.pstyle("box-selection").strValue;
      if (I === "none")
        continue;
      if (I === "contain") {
        if (A.startX != null && A.startY != null && !Do(h, A.startX, A.startY) || A.endX != null && A.endY != null && !Do(h, A.endX, A.endY))
          continue;
        if (A.edgeType === "bezier" || A.edgeType === "multibezier" || A.edgeType === "self" || A.edgeType === "compound" || A.edgeType === "segments" || A.edgeType === "haystack") {
          for (var D = M.rstyle.bezierPts || M.rstyle.linePts || M.rstyle.haystackPts, F = !0, B = 0; B < D.length; B++)
            if (!AM(h, D[B])) {
              F = !1;
              break;
            }
          F && o.push(L);
        } else A.edgeType === "straight" && o.push(L);
      } else if (I === "overlap") {
        var G = !1;
        if (A.startX != null && A.startY != null && A.endX != null && A.endY != null && (Do(h, A.startX, A.startY) || Do(h, A.endX, A.endY)))
          o.push(L), G = !0;
        else if (!G && A.edgeType === "haystack") {
          for (var H = M.rstyle.haystackPts, K = 0; K < H.length; K++)
            if (AM(h, H[K])) {
              o.push(L), G = !0;
              break;
            }
        }
        if (!G) {
          var j = M.rstyle.bezierPts || M.rstyle.linePts || M.rstyle.haystackPts;
          if ((!j || j.length < 2) && A.edgeType === "straight" && A.startX != null && A.startY != null && A.endX != null && A.endY != null && (j = [{
            x: A.startX,
            y: A.startY
          }, {
            x: A.endX,
            y: A.endY
          }]), !j || j.length < 2) continue;
          for (var Z = 0; Z < j.length - 1; Z++) {
            for (var te = j[Z], ne = j[Z + 1], V = 0; V < p.length; V++) {
              var q = ln(p[V], 2), X = q[0], W = q[1];
              if (m(te, ne, X, W)) {
                o.push(L), G = !0;
                break;
              }
            }
            if (G) break;
          }
        }
      }
    }
  }
  return o;
};
var qm = {};
qm.calculateArrowAngles = function(t) {
  var e = t._private.rscratch, r = e.edgeType === "haystack", n = e.edgeType === "bezier", a = e.edgeType === "multibezier", i = e.edgeType === "segments", s = e.edgeType === "compound", o = e.edgeType === "self", l, u, c, f, h, d, m, b;
  if (r ? (c = e.haystackPts[0], f = e.haystackPts[1], h = e.haystackPts[2], d = e.haystackPts[3]) : (c = e.arrowStartX, f = e.arrowStartY, h = e.arrowEndX, d = e.arrowEndY), m = e.midX, b = e.midY, i)
    l = c - e.segpts[0], u = f - e.segpts[1];
  else if (a || s || o || n) {
    var p = e.allpts, g = Cn(p[0], p[2], p[4], 0.1), v = Cn(p[1], p[3], p[5], 0.1);
    l = c - g, u = f - v;
  } else
    l = c - m, u = f - b;
  e.srcArrowAngle = cg(l, u);
  var m = e.midX, b = e.midY;
  if (r && (m = (c + h) / 2, b = (f + d) / 2), l = h - c, u = d - f, i) {
    var p = e.allpts;
    if (p.length / 2 % 2 === 0) {
      var y = p.length / 2, x = y - 2;
      l = p[y] - p[x], u = p[y + 1] - p[x + 1];
    } else if (e.isRound)
      l = e.midVector[1], u = -e.midVector[0];
    else {
      var y = p.length / 2 - 1, x = y - 2;
      l = p[y] - p[x], u = p[y + 1] - p[x + 1];
    }
  } else if (a || s || o) {
    var p = e.allpts, E = e.ctrlpts, S, w, C, k;
    if (E.length / 2 % 2 === 0) {
      var N = p.length / 2 - 1, R = N + 2, _ = R + 2;
      S = Cn(p[N], p[R], p[_], 0), w = Cn(p[N + 1], p[R + 1], p[_ + 1], 0), C = Cn(p[N], p[R], p[_], 1e-4), k = Cn(p[N + 1], p[R + 1], p[_ + 1], 1e-4);
    } else {
      var R = p.length / 2 - 1, N = R - 2, _ = R + 2;
      S = Cn(p[N], p[R], p[_], 0.4999), w = Cn(p[N + 1], p[R + 1], p[_ + 1], 0.4999), C = Cn(p[N], p[R], p[_], 0.5), k = Cn(p[N + 1], p[R + 1], p[_ + 1], 0.5);
    }
    l = C - S, u = k - w;
  }
  if (e.midtgtArrowAngle = cg(l, u), e.midDispX = l, e.midDispY = u, l *= -1, u *= -1, i) {
    var p = e.allpts;
    if (p.length / 2 % 2 !== 0) {
      if (!e.isRound) {
        var y = p.length / 2 - 1, O = y + 2;
        l = -(p[O] - p[y]), u = -(p[O + 1] - p[y + 1]);
      }
    }
  }
  if (e.midsrcArrowAngle = cg(l, u), i)
    l = h - e.segpts[e.segpts.length - 2], u = d - e.segpts[e.segpts.length - 1];
  else if (a || s || o || n) {
    var p = e.allpts, T = p.length, g = Cn(p[T - 6], p[T - 4], p[T - 2], 0.9), v = Cn(p[T - 5], p[T - 3], p[T - 1], 0.9);
    l = h - g, u = d - v;
  } else
    l = h - m, u = d - b;
  e.tgtArrowAngle = cg(l, u);
};
qm.getArrowWidth = qm.getArrowHeight = function(t, e) {
  var r = this.arrowWidthCache = this.arrowWidthCache || {}, n = r[t + ", " + e];
  return n || (n = Math.max(Math.pow(t * 13.37, 0.9), 29) * e, r[t + ", " + e] = n, n);
};
var R4, M4, ss = {}, ci = {}, lL, uL, Fl, Ev, Ns, kl, Nl, rs, Yu, yg, Fz, Bz, _4, L4, cL, fL = function(e, r, n) {
  n.x = r.x - e.x, n.y = r.y - e.y, n.len = Math.sqrt(n.x * n.x + n.y * n.y), n.nx = n.x / n.len, n.ny = n.y / n.len, n.ang = Math.atan2(n.ny, n.nx);
}, PSe = function(e, r) {
  r.x = e.x * -1, r.y = e.y * -1, r.nx = e.nx * -1, r.ny = e.ny * -1, r.ang = e.ang > 0 ? -(Math.PI - e.ang) : Math.PI + e.ang;
}, DSe = function(e, r, n, a, i) {
  if (e !== cL ? fL(r, e, ss) : PSe(ci, ss), fL(r, n, ci), lL = ss.nx * ci.ny - ss.ny * ci.nx, uL = ss.nx * ci.nx - ss.ny * -ci.ny, Ns = Math.asin(Math.max(-1, Math.min(1, lL))), Math.abs(Ns) < 1e-6) {
    R4 = r.x, M4 = r.y, Nl = Yu = 0;
    return;
  }
  Fl = 1, Ev = !1, uL < 0 ? Ns < 0 ? Ns = Math.PI + Ns : (Ns = Math.PI - Ns, Fl = -1, Ev = !0) : Ns > 0 && (Fl = -1, Ev = !0), r.radius !== void 0 ? Yu = r.radius : Yu = a, kl = Ns / 2, yg = Math.min(ss.len / 2, ci.len / 2), i ? (rs = Math.abs(Math.cos(kl) * Yu / Math.sin(kl)), rs > yg ? (rs = yg, Nl = Math.abs(rs * Math.sin(kl) / Math.cos(kl))) : Nl = Yu) : (rs = Math.min(yg, Yu), Nl = Math.abs(rs * Math.sin(kl) / Math.cos(kl))), _4 = r.x + ci.nx * rs, L4 = r.y + ci.ny * rs, R4 = _4 - ci.ny * Nl * Fl, M4 = L4 + ci.nx * Nl * Fl, Fz = r.x + ss.nx * rs, Bz = r.y + ss.ny * rs, cL = r;
};
function zz(t, e) {
  e.radius === 0 ? t.lineTo(e.cx, e.cy) : t.arc(e.cx, e.cy, e.radius, e.startAngle, e.endAngle, e.counterClockwise);
}
function E3(t, e, r, n) {
  var a = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0;
  return n === 0 || e.radius === 0 ? {
    cx: e.x,
    cy: e.y,
    radius: 0,
    startX: e.x,
    startY: e.y,
    stopX: e.x,
    stopY: e.y,
    startAngle: void 0,
    endAngle: void 0,
    counterClockwise: void 0
  } : (DSe(t, e, r, n, a), {
    cx: R4,
    cy: M4,
    radius: Nl,
    startX: Fz,
    startY: Bz,
    stopX: _4,
    stopY: L4,
    startAngle: ss.ang + Math.PI / 2 * Fl,
    endAngle: ci.ang - Math.PI / 2 * Fl,
    counterClockwise: Ev
  });
}
var g0 = 0.01, $Se = Math.sqrt(2 * g0), na = {};
na.findMidptPtsEtc = function(t, e) {
  var r = e.posPts, n = e.intersectionPts, a = e.vectorNormInverse, i, s = t.pstyle("source-endpoint"), o = t.pstyle("target-endpoint"), l = s.units != null && o.units != null, u = function(E, S, w, C) {
    var k = C - S, N = w - E, R = Math.sqrt(N * N + k * k);
    return {
      x: -k / R,
      y: N / R
    };
  }, c = t.pstyle("edge-distances").value;
  switch (c) {
    case "node-position":
      i = r;
      break;
    case "intersection":
      i = n;
      break;
    case "endpoints": {
      if (l) {
        var f = this.manualEndptToPx(t.source()[0], s), h = ln(f, 2), d = h[0], p = h[1], g = this.manualEndptToPx(t.target()[0], o), v = ln(g, 2), m = v[0], b = v[1], y = {
          x1: d,
          y1: p,
          x2: m,
          y2: b
        };
        a = u(d, p, m, b), i = y;
      } else
        pr("Edge ".concat(t.id(), " has edge-distances:endpoints specified without manual endpoints specified via source-endpoint and target-endpoint.  Falling back on edge-distances:intersection (default).")), i = n;
      break;
    }
  }
  return {
    midptPts: i,
    vectorNormInverse: a
  };
};
na.findHaystackPoints = function(t) {
  for (var e = 0; e < t.length; e++) {
    var r = t[e], n = r._private, a = n.rscratch;
    if (!a.haystack) {
      var i = Math.random() * 2 * Math.PI;
      a.source = {
        x: Math.cos(i),
        y: Math.sin(i)
      }, i = Math.random() * 2 * Math.PI, a.target = {
        x: Math.cos(i),
        y: Math.sin(i)
      };
    }
    var s = n.source, o = n.target, l = s.position(), u = o.position(), c = s.width(), f = o.width(), h = s.height(), d = o.height(), p = r.pstyle("haystack-radius").value, g = p / 2;
    a.haystackPts = a.allpts = [a.source.x * c * g + l.x, a.source.y * h * g + l.y, a.target.x * f * g + u.x, a.target.y * d * g + u.y], a.midX = (a.allpts[0] + a.allpts[2]) / 2, a.midY = (a.allpts[1] + a.allpts[3]) / 2, a.edgeType = "haystack", a.haystack = !0, this.storeEdgeProjections(r), this.calculateArrowAngles(r), this.recalculateEdgeLabelProjections(r), this.calculateLabelAngles(r);
  }
};
na.findSegmentsPoints = function(t, e) {
  var r = t._private.rscratch, n = t.pstyle("segment-weights"), a = t.pstyle("segment-distances"), i = t.pstyle("segment-radii"), s = t.pstyle("radius-type"), o = Math.min(n.pfValue.length, a.pfValue.length), l = i.pfValue[i.pfValue.length - 1], u = s.pfValue[s.pfValue.length - 1];
  r.edgeType = "segments", r.segpts = [], r.radii = [], r.isArcRadius = [];
  for (var c = 0; c < o; c++) {
    var f = n.pfValue[c], h = a.pfValue[c], d = 1 - f, p = f, g = this.findMidptPtsEtc(t, e), v = g.midptPts, m = g.vectorNormInverse, b = {
      x: v.x1 * d + v.x2 * p,
      y: v.y1 * d + v.y2 * p
    };
    r.segpts.push(b.x + m.x * h, b.y + m.y * h), r.radii.push(i.pfValue[c] !== void 0 ? i.pfValue[c] : l), r.isArcRadius.push((s.pfValue[c] !== void 0 ? s.pfValue[c] : u) === "arc-radius");
  }
};
na.findLoopPoints = function(t, e, r, n) {
  var a = t._private.rscratch, i = e.dirCounts, s = e.srcPos, o = t.pstyle("control-point-distances"), l = o ? o.pfValue[0] : void 0, u = t.pstyle("loop-direction").pfValue, c = t.pstyle("loop-sweep").pfValue, f = t.pstyle("control-point-step-size").pfValue;
  a.edgeType = "self";
  var h = r, d = f;
  n && (h = 0, d = l);
  var p = u - Math.PI / 2, g = p - c / 2, v = p + c / 2, m = u + "_" + c;
  h = i[m] === void 0 ? i[m] = 0 : ++i[m], a.ctrlpts = [s.x + Math.cos(g) * 1.4 * d * (h / 3 + 1), s.y + Math.sin(g) * 1.4 * d * (h / 3 + 1), s.x + Math.cos(v) * 1.4 * d * (h / 3 + 1), s.y + Math.sin(v) * 1.4 * d * (h / 3 + 1)];
};
na.findCompoundLoopPoints = function(t, e, r, n) {
  var a = t._private.rscratch;
  a.edgeType = "compound";
  var i = e.srcPos, s = e.tgtPos, o = e.srcW, l = e.srcH, u = e.tgtW, c = e.tgtH, f = t.pstyle("control-point-step-size").pfValue, h = t.pstyle("control-point-distances"), d = h ? h.pfValue[0] : void 0, p = r, g = f;
  n && (p = 0, g = d);
  var v = 50, m = {
    x: i.x - o / 2,
    y: i.y - l / 2
  }, b = {
    x: s.x - u / 2,
    y: s.y - c / 2
  }, y = {
    x: Math.min(m.x, b.x),
    y: Math.min(m.y, b.y)
  }, x = 0.5, E = Math.max(x, Math.log(o * g0)), S = Math.max(x, Math.log(u * g0));
  a.ctrlpts = [y.x, y.y - (1 + Math.pow(v, 1.12) / 100) * g * (p / 3 + 1) * E, y.x - (1 + Math.pow(v, 1.12) / 100) * g * (p / 3 + 1) * S, y.y];
};
na.findStraightEdgePoints = function(t) {
  t._private.rscratch.edgeType = "straight";
};
na.findBezierPoints = function(t, e, r, n, a) {
  var i = t._private.rscratch, s = t.pstyle("control-point-step-size").pfValue, o = t.pstyle("control-point-distances"), l = t.pstyle("control-point-weights"), u = o && l ? Math.min(o.value.length, l.value.length) : 1, c = o ? o.pfValue[0] : void 0, f = l.value[0], h = n;
  i.edgeType = h ? "multibezier" : "bezier", i.ctrlpts = [];
  for (var d = 0; d < u; d++) {
    var p = (0.5 - e.eles.length / 2 + r) * s * (a ? -1 : 1), g = void 0, v = u3(p);
    h && (c = o ? o.pfValue[d] : s, f = l.value[d]), n ? g = c : g = c !== void 0 ? v * c : void 0;
    var m = g !== void 0 ? g : p, b = 1 - f, y = f, x = this.findMidptPtsEtc(t, e), E = x.midptPts, S = x.vectorNormInverse, w = {
      x: E.x1 * b + E.x2 * y,
      y: E.y1 * b + E.y2 * y
    };
    i.ctrlpts.push(w.x + S.x * m, w.y + S.y * m);
  }
};
na.findTaxiPoints = function(t, e) {
  var r = t._private.rscratch;
  r.edgeType = "segments";
  var n = "vertical", a = "horizontal", i = "leftward", s = "rightward", o = "downward", l = "upward", u = "auto", c = e.posPts, f = e.srcW, h = e.srcH, d = e.tgtW, p = e.tgtH, g = t.pstyle("edge-distances").value, v = g !== "node-position", m = t.pstyle("taxi-direction").value, b = m, y = t.pstyle("taxi-turn"), x = y.units === "%", E = y.pfValue, S = E < 0, w = t.pstyle("taxi-turn-min-distance").pfValue, C = v ? (f + d) / 2 : 0, k = v ? (h + p) / 2 : 0, N = c.x2 - c.x1, R = c.y2 - c.y1, _ = function(z, Q) {
    return z > 0 ? Math.max(z - Q, 0) : Math.min(z + Q, 0);
  }, O = _(N, C), T = _(R, k), L = !1;
  b === u ? m = Math.abs(O) > Math.abs(T) ? a : n : b === l || b === o ? (m = n, L = !0) : (b === i || b === s) && (m = a, L = !0);
  var M = m === n, A = M ? T : O, I = M ? R : N, D = u3(I), F = !1;
  !(L && (x || S)) && (b === o && I < 0 || b === l && I > 0 || b === i && I > 0 || b === s && I < 0) && (D *= -1, A = D * Math.abs(A), F = !0);
  var B;
  if (x) {
    var G = E < 0 ? 1 + E : E;
    B = G * A;
  } else {
    var H = E < 0 ? A : 0;
    B = H + E * D;
  }
  var K = function(z) {
    return Math.abs(z) < w || Math.abs(z) >= Math.abs(A);
  }, j = K(B), Z = K(Math.abs(A) - Math.abs(B)), te = j || Z;
  if (te && !F)
    if (M) {
      var ne = Math.abs(I) <= h / 2, V = Math.abs(N) <= d / 2;
      if (ne) {
        var q = (c.x1 + c.x2) / 2, X = c.y1, W = c.y2;
        r.segpts = [q, X, q, W];
      } else if (V) {
        var ue = (c.y1 + c.y2) / 2, J = c.x1, Ce = c.x2;
        r.segpts = [J, ue, Ce, ue];
      } else
        r.segpts = [c.x1, c.y2];
    } else {
      var Ee = Math.abs(I) <= f / 2, Te = Math.abs(R) <= p / 2;
      if (Ee) {
        var me = (c.y1 + c.y2) / 2, we = c.x1, Ae = c.x2;
        r.segpts = [we, me, Ae, me];
      } else if (Te) {
        var Ne = (c.x1 + c.x2) / 2, Ie = c.y1, Me = c.y2;
        r.segpts = [Ne, Ie, Ne, Me];
      } else
        r.segpts = [c.x2, c.y1];
    }
  else if (M) {
    var _e = c.y1 + B + (v ? h / 2 * D : 0), Be = c.x1, st = c.x2;
    r.segpts = [Be, _e, st, _e];
  } else {
    var ct = c.x1 + B + (v ? f / 2 * D : 0), dt = c.y1, ft = c.y2;
    r.segpts = [ct, dt, ct, ft];
  }
  if (r.isRound) {
    var rt = t.pstyle("taxi-radius").value, je = t.pstyle("radius-type").value[0] === "arc-radius";
    r.radii = new Array(r.segpts.length / 2).fill(rt), r.isArcRadius = new Array(r.segpts.length / 2).fill(je);
  }
};
na.tryToCorrectInvalidPoints = function(t, e) {
  var r = t._private.rscratch;
  if (r.edgeType === "bezier") {
    var n = e.srcPos, a = e.tgtPos, i = e.srcW, s = e.srcH, o = e.tgtW, l = e.tgtH, u = e.srcShape, c = e.tgtShape, f = e.srcCornerRadius, h = e.tgtCornerRadius, d = e.srcRs, p = e.tgtRs, g = !tt(r.startX) || !tt(r.startY), v = !tt(r.arrowStartX) || !tt(r.arrowStartY), m = !tt(r.endX) || !tt(r.endY), b = !tt(r.arrowEndX) || !tt(r.arrowEndY), y = 3, x = this.getArrowWidth(t.pstyle("width").pfValue, t.pstyle("arrow-scale").value) * this.arrowShapeWidth, E = y * x, S = su({
      x: r.ctrlpts[0],
      y: r.ctrlpts[1]
    }, {
      x: r.startX,
      y: r.startY
    }), w = S < E, C = su({
      x: r.ctrlpts[0],
      y: r.ctrlpts[1]
    }, {
      x: r.endX,
      y: r.endY
    }), k = C < E, N = !1;
    if (g || v || w) {
      N = !0;
      var R = {
        // delta
        x: r.ctrlpts[0] - n.x,
        y: r.ctrlpts[1] - n.y
      }, _ = Math.sqrt(R.x * R.x + R.y * R.y), O = {
        // normalised delta
        x: R.x / _,
        y: R.y / _
      }, T = Math.max(i, s), L = {
        // *2 radius guarantees outside shape
        x: r.ctrlpts[0] + O.x * 2 * T,
        y: r.ctrlpts[1] + O.y * 2 * T
      }, M = u.intersectLine(n.x, n.y, i, s, L.x, L.y, 0, f, d);
      w ? (r.ctrlpts[0] = r.ctrlpts[0] + O.x * (E - S), r.ctrlpts[1] = r.ctrlpts[1] + O.y * (E - S)) : (r.ctrlpts[0] = M[0] + O.x * E, r.ctrlpts[1] = M[1] + O.y * E);
    }
    if (m || b || k) {
      N = !0;
      var A = {
        // delta
        x: r.ctrlpts[0] - a.x,
        y: r.ctrlpts[1] - a.y
      }, I = Math.sqrt(A.x * A.x + A.y * A.y), D = {
        // normalised delta
        x: A.x / I,
        y: A.y / I
      }, F = Math.max(i, s), B = {
        // *2 radius guarantees outside shape
        x: r.ctrlpts[0] + D.x * 2 * F,
        y: r.ctrlpts[1] + D.y * 2 * F
      }, G = c.intersectLine(a.x, a.y, o, l, B.x, B.y, 0, h, p);
      k ? (r.ctrlpts[0] = r.ctrlpts[0] + D.x * (E - C), r.ctrlpts[1] = r.ctrlpts[1] + D.y * (E - C)) : (r.ctrlpts[0] = G[0] + D.x * E, r.ctrlpts[1] = G[1] + D.y * E);
    }
    N && this.findEndpoints(t);
  }
};
na.storeAllpts = function(t) {
  var e = t._private.rscratch;
  if (e.edgeType === "multibezier" || e.edgeType === "bezier" || e.edgeType === "self" || e.edgeType === "compound") {
    e.allpts = [], e.allpts.push(e.startX, e.startY);
    for (var r = 0; r + 1 < e.ctrlpts.length; r += 2)
      e.allpts.push(e.ctrlpts[r], e.ctrlpts[r + 1]), r + 3 < e.ctrlpts.length && e.allpts.push((e.ctrlpts[r] + e.ctrlpts[r + 2]) / 2, (e.ctrlpts[r + 1] + e.ctrlpts[r + 3]) / 2);
    e.allpts.push(e.endX, e.endY);
    var n, a;
    e.ctrlpts.length / 2 % 2 === 0 ? (n = e.allpts.length / 2 - 1, e.midX = e.allpts[n], e.midY = e.allpts[n + 1]) : (n = e.allpts.length / 2 - 3, a = 0.5, e.midX = Cn(e.allpts[n], e.allpts[n + 2], e.allpts[n + 4], a), e.midY = Cn(e.allpts[n + 1], e.allpts[n + 3], e.allpts[n + 5], a));
  } else if (e.edgeType === "straight")
    e.allpts = [e.startX, e.startY, e.endX, e.endY], e.midX = (e.startX + e.endX + e.arrowStartX + e.arrowEndX) / 4, e.midY = (e.startY + e.endY + e.arrowStartY + e.arrowEndY) / 4;
  else if (e.edgeType === "segments") {
    if (e.allpts = [], e.allpts.push(e.startX, e.startY), e.allpts.push.apply(e.allpts, e.segpts), e.allpts.push(e.endX, e.endY), e.isRound) {
      e.roundCorners = [];
      for (var i = 2; i + 3 < e.allpts.length; i += 2) {
        var s = e.radii[i / 2 - 1], o = e.isArcRadius[i / 2 - 1];
        e.roundCorners.push(E3({
          x: e.allpts[i - 2],
          y: e.allpts[i - 1]
        }, {
          x: e.allpts[i],
          y: e.allpts[i + 1],
          radius: s
        }, {
          x: e.allpts[i + 2],
          y: e.allpts[i + 3]
        }, s, o));
      }
    }
    if (e.segpts.length % 4 === 0) {
      var l = e.segpts.length / 2, u = l - 2;
      e.midX = (e.segpts[u] + e.segpts[l]) / 2, e.midY = (e.segpts[u + 1] + e.segpts[l + 1]) / 2;
    } else {
      var c = e.segpts.length / 2 - 1;
      if (!e.isRound)
        e.midX = e.segpts[c], e.midY = e.segpts[c + 1];
      else {
        var f = {
          x: e.segpts[c],
          y: e.segpts[c + 1]
        }, h = e.roundCorners[c / 2];
        if (h.radius === 0) {
          var d = {
            x: e.segpts[c + 2],
            y: e.segpts[c + 3]
          };
          e.midX = f.x, e.midY = f.y, e.midVector = [f.y - d.y, d.x - f.x];
        } else {
          var p = [f.x - h.cx, f.y - h.cy], g = h.radius / Math.sqrt(Math.pow(p[0], 2) + Math.pow(p[1], 2));
          p = p.map(function(v) {
            return v * g;
          }), e.midX = h.cx + p[0], e.midY = h.cy + p[1], e.midVector = p;
        }
      }
    }
  }
};
na.checkForInvalidEdgeWarning = function(t) {
  var e = t[0]._private.rscratch;
  e.nodesOverlap || tt(e.startX) && tt(e.startY) && tt(e.endX) && tt(e.endY) ? e.loggedErr = !1 : e.loggedErr || (e.loggedErr = !0, pr("Edge `" + t.id() + "` has invalid endpoints and so it is impossible to draw.  Adjust your edge style (e.g. control points) accordingly or use an alternative edge type.  This is expected behaviour when the source node and the target node overlap."));
};
na.findEdgeControlPoints = function(t) {
  var e = this;
  if (!(!t || t.length === 0)) {
    for (var r = this, n = r.cy, a = n.hasCompoundNodes(), i = new Xs(), s = function(k, N) {
      return [].concat(Pm(k), [N ? 1 : 0]).join("-");
    }, o = [], l = [], u = 0; u < t.length; u++) {
      var c = t[u], f = c._private, h = c.pstyle("curve-style").value;
      if (!(c.removed() || !c.takesUpSpace())) {
        if (h === "haystack") {
          l.push(c);
          continue;
        }
        var d = h === "unbundled-bezier" || Po(h, "segments") || h === "straight" || h === "straight-triangle" || Po(h, "taxi"), p = h === "unbundled-bezier" || h === "bezier", g = f.source, v = f.target, m = g.poolIndex(), b = v.poolIndex(), y = [m, b].sort(), x = s(y, d), E = i.get(x);
        E == null && (E = {
          eles: []
        }, o.push({
          pairId: y,
          edgeIsUnbundled: d
        }), i.set(x, E)), E.eles.push(c), d && (E.hasUnbundled = !0), p && (E.hasBezier = !0);
      }
    }
    for (var S = function() {
      var k = o[w], N = k.pairId, R = k.edgeIsUnbundled, _ = s(N, R), O = i.get(_), T;
      if (!O.hasUnbundled) {
        var L = O.eles[0].parallelEdges().filter(function(je) {
          return je.isBundledBezier();
        });
        o3(O.eles), L.forEach(function(je) {
          return O.eles.push(je);
        }), O.eles.sort(function(je, ae) {
          return je.poolIndex() - ae.poolIndex();
        });
      }
      var M = O.eles[0], A = M.source(), I = M.target();
      if (A.poolIndex() > I.poolIndex()) {
        var D = A;
        A = I, I = D;
      }
      var F = O.srcPos = A.position(), B = O.tgtPos = I.position(), G = O.srcW = A.outerWidth(), H = O.srcH = A.outerHeight(), K = O.tgtW = I.outerWidth(), j = O.tgtH = I.outerHeight(), Z = O.srcShape = r.nodeShapes[e.getNodeShape(A)], te = O.tgtShape = r.nodeShapes[e.getNodeShape(I)], ne = O.srcCornerRadius = A.pstyle("corner-radius").value === "auto" ? "auto" : A.pstyle("corner-radius").pfValue, V = O.tgtCornerRadius = I.pstyle("corner-radius").value === "auto" ? "auto" : I.pstyle("corner-radius").pfValue, q = O.tgtRs = I._private.rscratch, X = O.srcRs = A._private.rscratch;
      O.dirCounts = {
        north: 0,
        west: 0,
        south: 0,
        east: 0,
        northwest: 0,
        southwest: 0,
        northeast: 0,
        southeast: 0
      };
      for (var W = 0; W < O.eles.length; W++) {
        var ue = O.eles[W], J = ue[0]._private.rscratch, Ce = ue.pstyle("curve-style").value, Ee = Ce === "unbundled-bezier" || Po(Ce, "segments") || Po(Ce, "taxi"), Te = !A.same(ue.source());
        if (!O.calculatedIntersection && A !== I && (O.hasBezier || O.hasUnbundled)) {
          O.calculatedIntersection = !0;
          var me = Z.intersectLine(F.x, F.y, G, H, B.x, B.y, 0, ne, X), we = O.srcIntn = me, Ae = te.intersectLine(B.x, B.y, K, j, F.x, F.y, 0, V, q), Ne = O.tgtIntn = Ae, Ie = O.intersectionPts = {
            x1: me[0],
            x2: Ae[0],
            y1: me[1],
            y2: Ae[1]
          }, Me = O.posPts = {
            x1: F.x,
            x2: B.x,
            y1: F.y,
            y2: B.y
          }, _e = Ae[1] - me[1], Be = Ae[0] - me[0], st = Math.sqrt(Be * Be + _e * _e);
          tt(st) && st >= $Se || (st = Math.sqrt(Math.max(Be * Be, g0) + Math.max(_e * _e, g0)));
          var ct = O.vector = {
            x: Be,
            y: _e
          }, dt = O.vectorNorm = {
            x: ct.x / st,
            y: ct.y / st
          }, ft = {
            x: -dt.y,
            y: dt.x
          };
          O.nodesOverlap = !tt(st) || te.checkPoint(me[0], me[1], 0, K, j, B.x, B.y, V, q) || Z.checkPoint(Ae[0], Ae[1], 0, G, H, F.x, F.y, ne, X), O.vectorNormInverse = ft, T = {
            nodesOverlap: O.nodesOverlap,
            dirCounts: O.dirCounts,
            calculatedIntersection: !0,
            hasBezier: O.hasBezier,
            hasUnbundled: O.hasUnbundled,
            eles: O.eles,
            srcPos: B,
            srcRs: q,
            tgtPos: F,
            tgtRs: X,
            srcW: K,
            srcH: j,
            tgtW: G,
            tgtH: H,
            srcIntn: Ne,
            tgtIntn: we,
            srcShape: te,
            tgtShape: Z,
            posPts: {
              x1: Me.x2,
              y1: Me.y2,
              x2: Me.x1,
              y2: Me.y1
            },
            intersectionPts: {
              x1: Ie.x2,
              y1: Ie.y2,
              x2: Ie.x1,
              y2: Ie.y1
            },
            vector: {
              x: -ct.x,
              y: -ct.y
            },
            vectorNorm: {
              x: -dt.x,
              y: -dt.y
            },
            vectorNormInverse: {
              x: -ft.x,
              y: -ft.y
            }
          };
        }
        var rt = Te ? T : O;
        J.nodesOverlap = rt.nodesOverlap, J.srcIntn = rt.srcIntn, J.tgtIntn = rt.tgtIntn, J.isRound = Ce.startsWith("round"), a && (A.isParent() || A.isChild() || I.isParent() || I.isChild()) && (A.parents().anySame(I) || I.parents().anySame(A) || A.same(I) && A.isParent()) ? e.findCompoundLoopPoints(ue, rt, W, Ee) : A === I ? e.findLoopPoints(ue, rt, W, Ee) : Ce.endsWith("segments") ? e.findSegmentsPoints(ue, rt) : Ce.endsWith("taxi") ? e.findTaxiPoints(ue, rt) : Ce === "straight" || !Ee && O.eles.length % 2 === 1 && W === Math.floor(O.eles.length / 2) ? e.findStraightEdgePoints(ue) : e.findBezierPoints(ue, rt, W, Ee, Te), e.findEndpoints(ue), e.tryToCorrectInvalidPoints(ue, rt), e.checkForInvalidEdgeWarning(ue), e.storeAllpts(ue), e.storeEdgeProjections(ue), e.calculateArrowAngles(ue), e.recalculateEdgeLabelProjections(ue), e.calculateLabelAngles(ue);
      }
    }, w = 0; w < o.length; w++)
      S();
    this.findHaystackPoints(l);
  }
};
function Gz(t) {
  var e = [];
  if (t != null) {
    for (var r = 0; r < t.length; r += 2) {
      var n = t[r], a = t[r + 1];
      e.push({
        x: n,
        y: a
      });
    }
    return e;
  }
}
na.getSegmentPoints = function(t) {
  var e = t[0]._private.rscratch;
  this.recalculateRenderedStyle(t);
  var r = e.edgeType;
  if (r === "segments")
    return Gz(e.segpts);
};
na.getControlPoints = function(t) {
  var e = t[0]._private.rscratch;
  this.recalculateRenderedStyle(t);
  var r = e.edgeType;
  if (r === "bezier" || r === "multibezier" || r === "self" || r === "compound")
    return Gz(e.ctrlpts);
};
na.getEdgeMidpoint = function(t) {
  var e = t[0]._private.rscratch;
  return this.recalculateRenderedStyle(t), {
    x: e.midX,
    y: e.midY
  };
};
var vp = {};
vp.manualEndptToPx = function(t, e) {
  var r = this, n = t.position(), a = t.outerWidth(), i = t.outerHeight(), s = t._private.rscratch;
  if (e.value.length === 2) {
    var o = [e.pfValue[0], e.pfValue[1]];
    return e.units[0] === "%" && (o[0] = o[0] * a), e.units[1] === "%" && (o[1] = o[1] * i), o[0] += n.x, o[1] += n.y, o;
  } else {
    var l = e.pfValue[0];
    l = -Math.PI / 2 + l;
    var u = 2 * Math.max(a, i), c = [n.x + Math.cos(l) * u, n.y + Math.sin(l) * u];
    return r.nodeShapes[this.getNodeShape(t)].intersectLine(n.x, n.y, a, i, c[0], c[1], 0, t.pstyle("corner-radius").value === "auto" ? "auto" : t.pstyle("corner-radius").pfValue, s);
  }
};
vp.findEndpoints = function(t) {
  var e, r, n, a, i = this, s, o = t.source()[0], l = t.target()[0], u = o.position(), c = l.position(), f = t.pstyle("target-arrow-shape").value, h = t.pstyle("source-arrow-shape").value, d = t.pstyle("target-distance-from-node").pfValue, p = t.pstyle("source-distance-from-node").pfValue, g = o._private.rscratch, v = l._private.rscratch, m = t.pstyle("curve-style").value, b = t._private.rscratch, y = b.edgeType, x = Po(m, "taxi"), E = y === "self" || y === "compound", S = y === "bezier" || y === "multibezier" || E, w = y !== "bezier", C = y === "straight" || y === "segments", k = y === "segments", N = S || w || C, R = E || x, _ = t.pstyle("source-endpoint"), O = R ? "outside-to-node" : _.value, T = o.pstyle("corner-radius").value === "auto" ? "auto" : o.pstyle("corner-radius").pfValue, L = t.pstyle("target-endpoint"), M = R ? "outside-to-node" : L.value, A = l.pstyle("corner-radius").value === "auto" ? "auto" : l.pstyle("corner-radius").pfValue;
  b.srcManEndpt = _, b.tgtManEndpt = L;
  var I, D, F, B, G = (e = (L == null || (r = L.pfValue) === null || r === void 0 ? void 0 : r.length) === 2 ? L.pfValue : null) !== null && e !== void 0 ? e : [0, 0], H = (n = (_ == null || (a = _.pfValue) === null || a === void 0 ? void 0 : a.length) === 2 ? _.pfValue : null) !== null && n !== void 0 ? n : [0, 0];
  if (S) {
    var K = [b.ctrlpts[0], b.ctrlpts[1]], j = w ? [b.ctrlpts[b.ctrlpts.length - 2], b.ctrlpts[b.ctrlpts.length - 1]] : K;
    I = j, D = K;
  } else if (C) {
    var Z = k ? b.segpts.slice(0, 2) : [c.x + G[0], c.y + G[1]], te = k ? b.segpts.slice(b.segpts.length - 2) : [u.x + H[0], u.y + H[1]];
    I = te, D = Z;
  }
  if (M === "inside-to-node")
    s = [c.x, c.y];
  else if (L.units)
    s = this.manualEndptToPx(l, L);
  else if (M === "outside-to-line")
    s = b.tgtIntn;
  else if (M === "outside-to-node" || M === "outside-to-node-or-label" ? F = I : (M === "outside-to-line" || M === "outside-to-line-or-label") && (F = [u.x, u.y]), s = i.nodeShapes[this.getNodeShape(l)].intersectLine(c.x, c.y, l.outerWidth(), l.outerHeight(), F[0], F[1], 0, A, v), M === "outside-to-node-or-label" || M === "outside-to-line-or-label") {
    var ne = l._private.rscratch, V = ne.labelWidth, q = ne.labelHeight, X = ne.labelX, W = ne.labelY, ue = V / 2, J = q / 2, Ce = l.pstyle("text-valign").value;
    Ce === "top" ? W -= J : Ce === "bottom" && (W += J);
    var Ee = l.pstyle("text-halign").value;
    Ee === "left" ? X -= ue : Ee === "right" && (X += ue);
    var Te = c0(F[0], F[1], [X - ue, W - J, X + ue, W - J, X + ue, W + J, X - ue, W + J], c.x, c.y);
    if (Te.length > 0) {
      var me = u, we = Ll(me, uc(s)), Ae = Ll(me, uc(Te)), Ne = we;
      if (Ae < we && (s = Te, Ne = Ae), Te.length > 2) {
        var Ie = Ll(me, {
          x: Te[2],
          y: Te[3]
        });
        Ie < Ne && (s = [Te[2], Te[3]]);
      }
    }
  }
  var Me = fg(s, I, i.arrowShapes[f].spacing(t) + d), _e = fg(s, I, i.arrowShapes[f].gap(t) + d);
  if (b.endX = _e[0], b.endY = _e[1], b.arrowEndX = Me[0], b.arrowEndY = Me[1], O === "inside-to-node")
    s = [u.x, u.y];
  else if (_.units)
    s = this.manualEndptToPx(o, _);
  else if (O === "outside-to-line")
    s = b.srcIntn;
  else if (O === "outside-to-node" || O === "outside-to-node-or-label" ? B = D : (O === "outside-to-line" || O === "outside-to-line-or-label") && (B = [c.x, c.y]), s = i.nodeShapes[this.getNodeShape(o)].intersectLine(u.x, u.y, o.outerWidth(), o.outerHeight(), B[0], B[1], 0, T, g), O === "outside-to-node-or-label" || O === "outside-to-line-or-label") {
    var Be = o._private.rscratch, st = Be.labelWidth, ct = Be.labelHeight, dt = Be.labelX, ft = Be.labelY, rt = st / 2, je = ct / 2, ae = o.pstyle("text-valign").value;
    ae === "top" ? ft -= je : ae === "bottom" && (ft += je);
    var z = o.pstyle("text-halign").value;
    z === "left" ? dt -= rt : z === "right" && (dt += rt);
    var Q = c0(B[0], B[1], [dt - rt, ft - je, dt + rt, ft - je, dt + rt, ft + je, dt - rt, ft + je], u.x, u.y);
    if (Q.length > 0) {
      var se = c, oe = Ll(se, uc(s)), he = Ll(se, uc(Q)), Le = oe;
      if (he < oe && (s = [Q[0], Q[1]], Le = he), Q.length > 2) {
        var ge = Ll(se, {
          x: Q[2],
          y: Q[3]
        });
        ge < Le && (s = [Q[2], Q[3]]);
      }
    }
  }
  var Se = fg(s, D, i.arrowShapes[h].spacing(t) + p), xe = fg(s, D, i.arrowShapes[h].gap(t) + p);
  b.startX = xe[0], b.startY = xe[1], b.arrowStartX = Se[0], b.arrowStartY = Se[1], N && (!tt(b.startX) || !tt(b.startY) || !tt(b.endX) || !tt(b.endY) ? b.badLine = !0 : b.badLine = !1);
};
vp.getSourceEndpoint = function(t) {
  var e = t[0]._private.rscratch;
  switch (this.recalculateRenderedStyle(t), e.edgeType) {
    case "haystack":
      return {
        x: e.haystackPts[0],
        y: e.haystackPts[1]
      };
    default:
      return {
        x: e.arrowStartX,
        y: e.arrowStartY
      };
  }
};
vp.getTargetEndpoint = function(t) {
  var e = t[0]._private.rscratch;
  switch (this.recalculateRenderedStyle(t), e.edgeType) {
    case "haystack":
      return {
        x: e.haystackPts[2],
        y: e.haystackPts[3]
      };
    default:
      return {
        x: e.arrowEndX,
        y: e.arrowEndY
      };
  }
};
var T3 = {};
function FSe(t, e, r) {
  for (var n = function(u, c, f, h) {
    return Cn(u, c, f, h);
  }, a = e._private, i = a.rstyle.bezierPts, s = 0; s < t.bezierProjPcts.length; s++) {
    var o = t.bezierProjPcts[s];
    i.push({
      x: n(r[0], r[2], r[4], o),
      y: n(r[1], r[3], r[5], o)
    });
  }
}
T3.storeEdgeProjections = function(t) {
  var e = t._private, r = e.rscratch, n = r.edgeType;
  if (e.rstyle.bezierPts = null, e.rstyle.linePts = null, e.rstyle.haystackPts = null, n === "multibezier" || n === "bezier" || n === "self" || n === "compound") {
    e.rstyle.bezierPts = [];
    for (var a = 0; a + 5 < r.allpts.length; a += 4)
      FSe(this, t, r.allpts.slice(a, a + 6));
  } else if (n === "segments")
    for (var i = e.rstyle.linePts = [], a = 0; a + 1 < r.allpts.length; a += 2)
      i.push({
        x: r.allpts[a],
        y: r.allpts[a + 1]
      });
  else if (n === "haystack") {
    var s = r.haystackPts;
    e.rstyle.haystackPts = [{
      x: s[0],
      y: s[1]
    }, {
      x: s[2],
      y: s[3]
    }];
  }
  e.rstyle.arrowWidth = this.getArrowWidth(t.pstyle("width").pfValue, t.pstyle("arrow-scale").value) * this.arrowShapeWidth;
};
T3.recalculateEdgeProjections = function(t) {
  this.findEdgeControlPoints(t);
};
var ks = {};
ks.recalculateNodeLabelProjection = function(t) {
  var e = t.pstyle("label").strValue;
  if (!jo(e)) {
    var r, n, a = t._private, i = t.width(), s = t.height(), o = t.padding(), l = t.position(), u = t.pstyle("text-halign").strValue, c = t.pstyle("text-valign").strValue, f = a.rscratch, h = a.rstyle;
    switch (u) {
      case "left":
        r = l.x - i / 2 - o;
        break;
      case "right":
        r = l.x + i / 2 + o;
        break;
      default:
        r = l.x;
    }
    switch (c) {
      case "top":
        n = l.y - s / 2 - o;
        break;
      case "bottom":
        n = l.y + s / 2 + o;
        break;
      default:
        n = l.y;
    }
    f.labelX = r, f.labelY = n, h.labelX = r, h.labelY = n, this.calculateLabelAngles(t), this.applyLabelDimensions(t);
  }
};
var Uz = function(e, r) {
  var n = Math.atan(r / e);
  return e === 0 && n < 0 && (n = n * -1), n;
}, Hz = function(e, r) {
  var n = r.x - e.x, a = r.y - e.y;
  return Uz(n, a);
}, BSe = function(e, r, n, a) {
  var i = u0(0, a - 1e-3, 1), s = u0(0, a + 1e-3, 1), o = wc(e, r, n, i), l = wc(e, r, n, s);
  return Hz(o, l);
};
ks.recalculateEdgeLabelProjections = function(t) {
  var e, r = t._private, n = r.rscratch, a = this, i = {
    mid: t.pstyle("label").strValue,
    source: t.pstyle("source-label").strValue,
    target: t.pstyle("target-label").strValue
  };
  if (i.mid || i.source || i.target) {
    e = {
      x: n.midX,
      y: n.midY
    };
    var s = function(f, h, d) {
      Bs(r.rscratch, f, h, d), Bs(r.rstyle, f, h, d);
    };
    s("labelX", null, e.x), s("labelY", null, e.y);
    var o = Uz(n.midDispX, n.midDispY);
    s("labelAutoAngle", null, o);
    var l = function() {
      if (l.cache)
        return l.cache;
      for (var f = [], h = 0; h + 5 < n.allpts.length; h += 4) {
        var d = {
          x: n.allpts[h],
          y: n.allpts[h + 1]
        }, p = {
          x: n.allpts[h + 2],
          y: n.allpts[h + 3]
        }, g = {
          x: n.allpts[h + 4],
          y: n.allpts[h + 5]
        };
        f.push({
          p0: d,
          p1: p,
          p2: g,
          startDist: 0,
          length: 0,
          segments: []
        });
      }
      var v = r.rstyle.bezierPts, m = a.bezierProjPcts.length;
      function b(w, C, k, N, R) {
        var _ = su(C, k), O = w.segments[w.segments.length - 1], T = {
          p0: C,
          p1: k,
          t0: N,
          t1: R,
          startDist: O ? O.startDist + O.length : 0,
          length: _
        };
        w.segments.push(T), w.length += _;
      }
      for (var y = 0; y < f.length; y++) {
        var x = f[y], E = f[y - 1];
        E && (x.startDist = E.startDist + E.length), b(x, x.p0, v[y * m], 0, a.bezierProjPcts[0]);
        for (var S = 0; S < m - 1; S++)
          b(x, v[y * m + S], v[y * m + S + 1], a.bezierProjPcts[S], a.bezierProjPcts[S + 1]);
        b(x, v[y * m + m - 1], x.p2, a.bezierProjPcts[m - 1], 1);
      }
      return l.cache = f;
    }, u = function(f) {
      var h, d = f === "source";
      if (i[f]) {
        var p = t.pstyle(f + "-text-offset").pfValue;
        switch (n.edgeType) {
          case "self":
          case "compound":
          case "bezier":
          case "multibezier": {
            for (var g = l(), v, m = 0, b = 0, y = 0; y < g.length; y++) {
              for (var x = g[d ? y : g.length - 1 - y], E = 0; E < x.segments.length; E++) {
                var S = x.segments[d ? E : x.segments.length - 1 - E], w = y === g.length - 1 && E === x.segments.length - 1;
                if (m = b, b += S.length, b >= p || w) {
                  v = {
                    cp: x,
                    segment: S
                  };
                  break;
                }
              }
              if (v)
                break;
            }
            var C = v.cp, k = v.segment, N = (p - m) / k.length, R = k.t1 - k.t0, _ = d ? k.t0 + R * N : k.t1 - R * N;
            _ = u0(0, _, 1), e = wc(C.p0, C.p1, C.p2, _), h = BSe(C.p0, C.p1, C.p2, _);
            break;
          }
          case "straight":
          case "segments":
          case "haystack": {
            for (var O = 0, T, L, M, A, I = n.allpts.length, D = 0; D + 3 < I && (d ? (M = {
              x: n.allpts[D],
              y: n.allpts[D + 1]
            }, A = {
              x: n.allpts[D + 2],
              y: n.allpts[D + 3]
            }) : (M = {
              x: n.allpts[I - 2 - D],
              y: n.allpts[I - 1 - D]
            }, A = {
              x: n.allpts[I - 4 - D],
              y: n.allpts[I - 3 - D]
            }), T = su(M, A), L = O, O += T, !(O >= p)); D += 2)
              ;
            var F = p - L, B = F / T;
            B = u0(0, B, 1), e = oEe(M, A, B), h = Hz(M, A);
            break;
          }
        }
        s("labelX", f, e.x), s("labelY", f, e.y), s("labelAutoAngle", f, h);
      }
    };
    u("source"), u("target"), this.applyLabelDimensions(t);
  }
};
ks.applyLabelDimensions = function(t) {
  this.applyPrefixedLabelDimensions(t), t.isEdge() && (this.applyPrefixedLabelDimensions(t, "source"), this.applyPrefixedLabelDimensions(t, "target"));
};
ks.applyPrefixedLabelDimensions = function(t, e) {
  var r = t._private, n = this.getLabelText(t, e), a = iu(n, t._private.labelDimsKey);
  if (Ta(r.rscratch, "prefixedLabelDimsKey", e) !== a) {
    Bs(r.rscratch, "prefixedLabelDimsKey", e, a);
    var i = this.calculateLabelDimensions(t, n), s = t.pstyle("line-height").pfValue, o = t.pstyle("text-wrap").strValue, l = Ta(r.rscratch, "labelWrapCachedLines", e) || [], u = o !== "wrap" ? 1 : Math.max(l.length, 1), c = i.height / u, f = c * s, h = i.width, d = i.height + (u - 1) * (s - 1) * c;
    Bs(r.rstyle, "labelWidth", e, h), Bs(r.rscratch, "labelWidth", e, h), Bs(r.rstyle, "labelHeight", e, d), Bs(r.rscratch, "labelHeight", e, d), Bs(r.rscratch, "labelLineHeight", e, f);
  }
};
ks.getLabelText = function(t, e) {
  var r = t._private, n = e ? e + "-" : "", a = t.pstyle(n + "label").strValue, i = t.pstyle("text-transform").value, s = function(H, K) {
    return K ? (Bs(r.rscratch, H, e, K), K) : Ta(r.rscratch, H, e);
  };
  if (!a)
    return "";
  i == "none" || (i == "uppercase" ? a = a.toUpperCase() : i == "lowercase" && (a = a.toLowerCase()));
  var o = t.pstyle("text-wrap").value;
  if (o === "wrap") {
    var l = s("labelKey");
    if (l != null && s("labelWrapKey") === l)
      return s("labelWrapCachedText");
    for (var u = "​", c = a.split(`
`), f = t.pstyle("text-max-width").pfValue, h = t.pstyle("text-overflow-wrap").value, d = h === "anywhere", p = [], g = /[\s\u200b]+|$/g, v = 0; v < c.length; v++) {
      var m = c[v], b = this.calculateLabelDimensions(t, m), y = b.width;
      if (d) {
        var x = m.split("").join(u);
        m = x;
      }
      if (y > f) {
        var E = m.matchAll(g), S = "", w = 0, C = Ca(E), k;
        try {
          for (C.s(); !(k = C.n()).done; ) {
            var N = k.value, R = N[0], _ = m.substring(w, N.index);
            w = N.index + R.length;
            var O = S.length === 0 ? _ : S + _ + R, T = this.calculateLabelDimensions(t, O), L = T.width;
            L <= f ? S += _ + R : (S && p.push(S), S = _ + R);
          }
        } catch (G) {
          C.e(G);
        } finally {
          C.f();
        }
        S.match(/^[\s\u200b]+$/) || p.push(S);
      } else
        p.push(m);
    }
    s("labelWrapCachedLines", p), a = s("labelWrapCachedText", p.join(`
`)), s("labelWrapKey", l);
  } else if (o === "ellipsis") {
    var M = t.pstyle("text-max-width").pfValue, A = "", I = "…", D = !1;
    if (this.calculateLabelDimensions(t, a).width < M)
      return a;
    for (var F = 0; F < a.length; F++) {
      var B = this.calculateLabelDimensions(t, A + a[F] + I).width;
      if (B > M)
        break;
      A += a[F], F === a.length - 1 && (D = !0);
    }
    return D || (A += I), A;
  }
  return a;
};
ks.getLabelJustification = function(t) {
  var e = t.pstyle("text-justification").strValue, r = t.pstyle("text-halign").strValue;
  if (e === "auto")
    if (t.isNode())
      switch (r) {
        case "left":
          return "right";
        case "right":
          return "left";
        default:
          return "center";
      }
    else
      return "center";
  else
    return e;
};
ks.calculateLabelDimensions = function(t, e) {
  var r = this, n = r.cy.window(), a = n.document, i = 0, s = t.pstyle("font-style").strValue, o = t.pstyle("font-size").pfValue, l = t.pstyle("font-family").strValue, u = t.pstyle("font-weight").strValue, c = this.labelCalcCanvas, f = this.labelCalcCanvasContext;
  if (!c) {
    c = this.labelCalcCanvas = a.createElement("canvas"), f = this.labelCalcCanvasContext = c.getContext("2d");
    var h = c.style;
    h.position = "absolute", h.left = "-9999px", h.top = "-9999px", h.zIndex = "-1", h.visibility = "hidden", h.pointerEvents = "none";
  }
  f.font = "".concat(s, " ").concat(u, " ").concat(o, "px ").concat(l);
  for (var d = 0, p = 0, g = e.split(`
`), v = 0; v < g.length; v++) {
    var m = g[v], b = f.measureText(m), y = Math.ceil(b.width), x = o;
    d = Math.max(y, d), p += x;
  }
  return d += i, p += i, {
    width: d,
    height: p
  };
};
ks.calculateLabelAngle = function(t, e) {
  var r = t._private, n = r.rscratch, a = t.isEdge(), i = e ? e + "-" : "", s = t.pstyle(i + "text-rotation"), o = s.strValue;
  return o === "none" ? 0 : a && o === "autorotate" ? n.labelAutoAngle : o === "autorotate" ? 0 : s.pfValue;
};
ks.calculateLabelAngles = function(t) {
  var e = this, r = t.isEdge(), n = t._private, a = n.rscratch;
  a.labelAngle = e.calculateLabelAngle(t), r && (a.sourceLabelAngle = e.calculateLabelAngle(t, "source"), a.targetLabelAngle = e.calculateLabelAngle(t, "target"));
};
var Vz = {}, hL = 28, dL = !1;
Vz.getNodeShape = function(t) {
  var e = this, r = t.pstyle("shape").value;
  if (r === "cutrectangle" && (t.width() < hL || t.height() < hL))
    return dL || (pr("The `cutrectangle` node shape can not be used at small sizes so `rectangle` is used instead"), dL = !0), "rectangle";
  if (t.isParent())
    return r === "rectangle" || r === "roundrectangle" || r === "round-rectangle" || r === "cutrectangle" || r === "cut-rectangle" || r === "barrel" ? r : "rectangle";
  if (r === "polygon") {
    var n = t.pstyle("shape-polygon-points").value;
    return e.nodeShapes.makePolygon(n).name;
  }
  return r;
};
var fb = {};
fb.registerCalculationListeners = function() {
  var t = this.cy, e = t.collection(), r = this, n = function(s) {
    var o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    if (e.merge(s), o)
      for (var l = 0; l < s.length; l++) {
        var u = s[l], c = u._private, f = c.rstyle;
        f.clean = !1, f.cleanConnected = !1;
      }
  };
  r.binder(t).on("bounds.* dirty.*", function(s) {
    var o = s.target;
    n(o);
  }).on("style.* background.*", function(s) {
    var o = s.target;
    n(o, !1);
  });
  var a = function(s) {
    if (s) {
      var o = r.onUpdateEleCalcsFns;
      e.cleanStyle();
      for (var l = 0; l < e.length; l++) {
        var u = e[l], c = u._private.rstyle;
        u.isNode() && !c.cleanConnected && (n(u.connectedEdges()), c.cleanConnected = !0);
      }
      if (o)
        for (var f = 0; f < o.length; f++) {
          var h = o[f];
          h(s, e);
        }
      r.recalculateRenderedStyle(e), e = t.collection();
    }
  };
  r.flushRenderedStyleQueue = function() {
    a(!0);
  }, r.beforeRender(a, r.beforeRenderPriorities.eleCalcs);
};
fb.onUpdateEleCalcs = function(t) {
  var e = this.onUpdateEleCalcsFns = this.onUpdateEleCalcsFns || [];
  e.push(t);
};
fb.recalculateRenderedStyle = function(t, e) {
  var r = function(x) {
    return x._private.rstyle.cleanConnected;
  };
  if (t.length !== 0) {
    var n = [], a = [];
    if (!this.destroyed) {
      e === void 0 && (e = !0);
      for (var i = 0; i < t.length; i++) {
        var s = t[i], o = s._private, l = o.rstyle;
        s.isEdge() && (!r(s.source()) || !r(s.target())) && (l.clean = !1), s.isEdge() && s.isBundledBezier() && s.parallelEdges().some(function(y) {
          return !y._private.rstyle.clean && y.isBundledBezier();
        }) && (l.clean = !1), !(e && l.clean || s.removed()) && s.pstyle("display").value !== "none" && (o.group === "nodes" ? a.push(s) : n.push(s), l.clean = !0);
      }
      for (var u = 0; u < a.length; u++) {
        var c = a[u], f = c._private, h = f.rstyle, d = c.position();
        this.recalculateNodeLabelProjection(c), h.nodeX = d.x, h.nodeY = d.y, h.nodeW = c.pstyle("width").pfValue, h.nodeH = c.pstyle("height").pfValue;
      }
      this.recalculateEdgeProjections(n);
      for (var p = 0; p < n.length; p++) {
        var g = n[p], v = g._private, m = v.rstyle, b = v.rscratch;
        m.srcX = b.arrowStartX, m.srcY = b.arrowStartY, m.tgtX = b.arrowEndX, m.tgtY = b.arrowEndY, m.midX = b.midX, m.midY = b.midY, m.labelAngle = b.labelAngle, m.sourceLabelAngle = b.sourceLabelAngle, m.targetLabelAngle = b.targetLabelAngle;
      }
    }
  }
};
var hb = {};
hb.updateCachedGrabbedEles = function() {
  var t = this.cachedZSortedEles;
  if (t) {
    t.drag = [], t.nondrag = [];
    for (var e = [], r = 0; r < t.length; r++) {
      var n = t[r], a = n._private.rscratch;
      n.grabbed() && !n.isParent() ? e.push(n) : a.inDragLayer ? t.drag.push(n) : t.nondrag.push(n);
    }
    for (var r = 0; r < e.length; r++) {
      var n = e[r];
      t.drag.push(n);
    }
  }
};
hb.invalidateCachedZSortedEles = function() {
  this.cachedZSortedEles = null;
};
hb.getCachedZSortedEles = function(t) {
  if (t || !this.cachedZSortedEles) {
    var e = this.cy.mutableElements().toArray();
    e.sort(Cz), e.interactive = e.filter(function(r) {
      return r.interactive();
    }), this.cachedZSortedEles = e, this.updateCachedGrabbedEles();
  } else
    e = this.cachedZSortedEles;
  return e;
};
var qz = {};
[_u, qm, na, vp, T3, ks, Vz, fb, hb].forEach(function(t) {
  At(qz, t);
});
var Wz = {};
Wz.getCachedImage = function(t, e, r) {
  var n = this, a = n.imageCache = n.imageCache || {}, i = a[t];
  if (i)
    return i.image.complete || i.image.addEventListener("load", r), i.image;
  i = a[t] = a[t] || {};
  var s = i.image = new Image();
  s.addEventListener("load", r), s.addEventListener("error", function() {
    s.error = !0;
  });
  var o = "data:", l = t.substring(0, o.length).toLowerCase() === o;
  return l || (e = e === "null" ? null : e, s.crossOrigin = e), s.src = t, s;
};
var Of = {};
Of.registerBinding = function(t, e, r, n) {
  var a = Array.prototype.slice.apply(arguments, [1]);
  if (Array.isArray(t)) {
    for (var i = [], s = 0; s < t.length; s++) {
      var o = t[s];
      if (o !== void 0) {
        var l = this.binder(o);
        i.push(l.on.apply(l, a));
      }
    }
    return i;
  }
  var l = this.binder(t);
  return l.on.apply(l, a);
};
Of.binder = function(t) {
  var e = this, r = e.cy.window(), n = t === r || t === r.document || t === r.document.body || Z2e(t);
  if (e.supportsPassiveEvents == null) {
    var a = !1;
    try {
      var i = Object.defineProperty({}, "passive", {
        get: function() {
          return a = !0, !0;
        }
      });
      r.addEventListener("test", null, i);
    } catch {
    }
    e.supportsPassiveEvents = a;
  }
  var s = function(l, u, c) {
    var f = Array.prototype.slice.call(arguments);
    return n && e.supportsPassiveEvents && (f[2] = {
      capture: c ?? !1,
      passive: !1,
      once: !1
    }), e.bindings.push({
      target: t,
      args: f
    }), (t.addEventListener || t.on).apply(t, f), this;
  };
  return {
    on: s,
    addEventListener: s,
    addListener: s,
    bind: s
  };
};
Of.nodeIsDraggable = function(t) {
  return t && t.isNode() && !t.locked() && t.grabbable();
};
Of.nodeIsGrabbable = function(t) {
  return this.nodeIsDraggable(t) && t.interactive();
};
Of.load = function() {
  var t = this, e = t.cy.window(), r = function(z) {
    return z.selected();
  }, n = function(z) {
    var Q = z.getRootNode();
    if (Q && Q.nodeType === 11 && Q.host !== void 0)
      return Q;
  }, a = function(z, Q, se, oe) {
    z == null && (z = t.cy);
    for (var he = 0; he < Q.length; he++) {
      var Le = Q[he];
      z.emit({
        originalEvent: se,
        type: Le,
        position: oe
      });
    }
  }, i = function(z) {
    return z.shiftKey || z.metaKey || z.ctrlKey;
  }, s = function(z, Q) {
    var se = !0;
    if (t.cy.hasCompoundNodes() && z && z.pannable())
      for (var oe = 0; Q && oe < Q.length; oe++) {
        var z = Q[oe];
        if (z.isNode() && z.isParent() && !z.pannable()) {
          se = !1;
          break;
        }
      }
    else
      se = !0;
    return se;
  }, o = function(z) {
    z[0]._private.grabbed = !0;
  }, l = function(z) {
    z[0]._private.grabbed = !1;
  }, u = function(z) {
    z[0]._private.rscratch.inDragLayer = !0;
  }, c = function(z) {
    z[0]._private.rscratch.inDragLayer = !1;
  }, f = function(z) {
    z[0]._private.rscratch.isGrabTarget = !0;
  }, h = function(z) {
    z[0]._private.rscratch.isGrabTarget = !1;
  }, d = function(z, Q) {
    var se = Q.addToList, oe = se.has(z);
    !oe && z.grabbable() && !z.locked() && (se.merge(z), o(z));
  }, p = function(z, Q) {
    if (z.cy().hasCompoundNodes() && !(Q.inDragLayer == null && Q.addToList == null)) {
      var se = z.descendants();
      Q.inDragLayer && (se.forEach(u), se.connectedEdges().forEach(u)), Q.addToList && d(se, Q);
    }
  }, g = function(z, Q) {
    Q = Q || {};
    var se = z.cy().hasCompoundNodes();
    Q.inDragLayer && (z.forEach(u), z.neighborhood().stdFilter(function(oe) {
      return !se || oe.isEdge();
    }).forEach(u)), Q.addToList && z.forEach(function(oe) {
      d(oe, Q);
    }), p(z, Q), b(z, {
      inDragLayer: Q.inDragLayer
    }), t.updateCachedGrabbedEles();
  }, v = g, m = function(z) {
    z && (t.getCachedZSortedEles().forEach(function(Q) {
      l(Q), c(Q), h(Q);
    }), t.updateCachedGrabbedEles());
  }, b = function(z, Q) {
    if (!(Q.inDragLayer == null && Q.addToList == null) && z.cy().hasCompoundNodes()) {
      var se = z.ancestors().orphans();
      if (!se.same(z)) {
        var oe = se.descendants().spawnSelf().merge(se).unmerge(z).unmerge(z.descendants()), he = oe.connectedEdges();
        Q.inDragLayer && (he.forEach(u), oe.forEach(u)), Q.addToList && oe.forEach(function(Le) {
          d(Le, Q);
        });
      }
    }
  }, y = function() {
    document.activeElement != null && document.activeElement.blur != null && document.activeElement.blur();
  }, x = typeof MutationObserver < "u", E = typeof ResizeObserver < "u";
  x ? (t.removeObserver = new MutationObserver(function(ae) {
    for (var z = 0; z < ae.length; z++) {
      var Q = ae[z], se = Q.removedNodes;
      if (se)
        for (var oe = 0; oe < se.length; oe++) {
          var he = se[oe];
          if (he === t.container) {
            t.destroy();
            break;
          }
        }
    }
  }), t.container.parentNode && t.removeObserver.observe(t.container.parentNode, {
    childList: !0
  })) : t.registerBinding(t.container, "DOMNodeRemoved", function(ae) {
    t.destroy();
  });
  var S = hp(function() {
    t.cy.resize();
  }, 100);
  x && (t.styleObserver = new MutationObserver(S), t.styleObserver.observe(t.container, {
    attributes: !0
  })), t.registerBinding(e, "resize", S), E && (t.resizeObserver = new ResizeObserver(S), t.resizeObserver.observe(t.container));
  var w = function(z, Q) {
    for (; z != null; )
      Q(z), z = z.parentNode;
  }, C = function() {
    t.invalidateContainerClientCoordsCache();
  };
  w(t.container, function(ae) {
    t.registerBinding(ae, "transitionend", C), t.registerBinding(ae, "animationend", C), t.registerBinding(ae, "scroll", C);
  }), t.registerBinding(t.container, "contextmenu", function(ae) {
    ae.preventDefault();
  });
  var k = function() {
    return t.selection[4] !== 0;
  }, N = function(z) {
    for (var Q = t.findContainerClientCoords(), se = Q[0], oe = Q[1], he = Q[2], Le = Q[3], ge = z.touches ? z.touches : [z], Se = !1, xe = 0; xe < ge.length; xe++) {
      var $e = ge[xe];
      if (se <= $e.clientX && $e.clientX <= se + he && oe <= $e.clientY && $e.clientY <= oe + Le) {
        Se = !0;
        break;
      }
    }
    if (!Se)
      return !1;
    for (var Ze = t.container, We = z.target, He = We.parentNode, Pe = !1; He; ) {
      if (He === Ze) {
        Pe = !0;
        break;
      }
      He = He.parentNode;
    }
    return !!Pe;
  };
  t.registerBinding(t.container, "mousedown", function(z) {
    if (N(z) && !(t.hoverData.which === 1 && z.which !== 1)) {
      z.preventDefault(), y(), t.hoverData.capture = !0, t.hoverData.which = z.which;
      var Q = t.cy, se = [z.clientX, z.clientY], oe = t.projectIntoViewport(se[0], se[1]), he = t.selection, Le = t.findNearestElements(oe[0], oe[1], !0, !1), ge = Le[0], Se = t.dragData.possibleDragElements;
      t.hoverData.mdownPos = oe, t.hoverData.mdownGPos = se;
      var xe = function(De) {
        return {
          originalEvent: z,
          type: De,
          position: {
            x: oe[0],
            y: oe[1]
          }
        };
      }, $e = function() {
        t.hoverData.tapholdCancelled = !1, clearTimeout(t.hoverData.tapholdTimeout), t.hoverData.tapholdTimeout = setTimeout(function() {
          if (!t.hoverData.tapholdCancelled) {
            var De = t.hoverData.down;
            De ? De.emit(xe("taphold")) : Q.emit(xe("taphold"));
          }
        }, t.tapholdDuration);
      };
      if (z.which == 3) {
        t.hoverData.cxtStarted = !0;
        var Ze = {
          originalEvent: z,
          type: "cxttapstart",
          position: {
            x: oe[0],
            y: oe[1]
          }
        };
        ge ? (ge.activate(), ge.emit(Ze), t.hoverData.down = ge) : Q.emit(Ze), t.hoverData.downTime = (/* @__PURE__ */ new Date()).getTime(), t.hoverData.cxtDragged = !1;
      } else if (z.which == 1) {
        ge && ge.activate();
        {
          if (ge != null && t.nodeIsGrabbable(ge)) {
            var We = function(De) {
              De.emit(xe("grab"));
            };
            if (f(ge), !ge.selected())
              Se = t.dragData.possibleDragElements = Q.collection(), v(ge, {
                addToList: Se
              }), ge.emit(xe("grabon")).emit(xe("grab"));
            else {
              Se = t.dragData.possibleDragElements = Q.collection();
              var He = Q.$(function(Pe) {
                return Pe.isNode() && Pe.selected() && t.nodeIsGrabbable(Pe);
              });
              g(He, {
                addToList: Se
              }), ge.emit(xe("grabon")), He.forEach(We);
            }
            t.redrawHint("eles", !0), t.redrawHint("drag", !0);
          }
          t.hoverData.down = ge, t.hoverData.downs = Le, t.hoverData.downTime = (/* @__PURE__ */ new Date()).getTime();
        }
        a(ge, ["mousedown", "tapstart", "vmousedown"], z, {
          x: oe[0],
          y: oe[1]
        }), ge == null ? (he[4] = 1, t.data.bgActivePosistion = {
          x: oe[0],
          y: oe[1]
        }, t.redrawHint("select", !0), t.redraw()) : ge.pannable() && (he[4] = 1), $e();
      }
      he[0] = he[2] = oe[0], he[1] = he[3] = oe[1];
    }
  }, !1);
  var R = n(t.container);
  t.registerBinding([e, R], "mousemove", function(z) {
    var Q = t.hoverData.capture;
    if (!(!Q && !N(z))) {
      var se = !1, oe = t.cy, he = oe.zoom(), Le = [z.clientX, z.clientY], ge = t.projectIntoViewport(Le[0], Le[1]), Se = t.hoverData.mdownPos, xe = t.hoverData.mdownGPos, $e = t.selection, Ze = null;
      !t.hoverData.draggingEles && !t.hoverData.dragging && !t.hoverData.selecting && (Ze = t.findNearestElement(ge[0], ge[1], !0, !1));
      var We = t.hoverData.last, He = t.hoverData.down, Pe = [ge[0] - $e[2], ge[1] - $e[3]], De = t.dragData.possibleDragElements, mt;
      if (xe) {
        var Ke = Le[0] - xe[0], et = Ke * Ke, Pt = Le[1] - xe[1], vt = Pt * Pt, nt = et + vt;
        t.hoverData.isOverThresholdDrag = mt = nt >= t.desktopTapThreshold2;
      }
      var Dt = i(z);
      mt && (t.hoverData.tapholdCancelled = !0);
      var Gt = function() {
        var ze = t.hoverData.dragDelta = t.hoverData.dragDelta || [];
        ze.length === 0 ? (ze.push(Pe[0]), ze.push(Pe[1])) : (ze[0] += Pe[0], ze[1] += Pe[1]);
      };
      se = !0, a(Ze, ["mousemove", "vmousemove", "tapdrag"], z, {
        x: ge[0],
        y: ge[1]
      });
      var yt = function(ze) {
        return {
          originalEvent: z,
          type: ze,
          position: {
            x: ge[0],
            y: ge[1]
          }
        };
      }, ee = function() {
        t.data.bgActivePosistion = void 0, t.hoverData.selecting || oe.emit(yt("boxstart")), $e[4] = 1, t.hoverData.selecting = !0, t.redrawHint("select", !0), t.redraw();
      };
      if (t.hoverData.which === 3) {
        if (mt) {
          var Re = yt("cxtdrag");
          He ? He.emit(Re) : oe.emit(Re), t.hoverData.cxtDragged = !0, (!t.hoverData.cxtOver || Ze !== t.hoverData.cxtOver) && (t.hoverData.cxtOver && t.hoverData.cxtOver.emit(yt("cxtdragout")), t.hoverData.cxtOver = Ze, Ze && Ze.emit(yt("cxtdragover")));
        }
      } else if (t.hoverData.dragging) {
        if (se = !0, oe.panningEnabled() && oe.userPanningEnabled()) {
          var Ge;
          if (t.hoverData.justStartedPan) {
            var ot = t.hoverData.mdownPos;
            Ge = {
              x: (ge[0] - ot[0]) * he,
              y: (ge[1] - ot[1]) * he
            }, t.hoverData.justStartedPan = !1;
          } else
            Ge = {
              x: Pe[0] * he,
              y: Pe[1] * he
            };
          oe.panBy(Ge), oe.emit(yt("dragpan")), t.hoverData.dragged = !0;
        }
        ge = t.projectIntoViewport(z.clientX, z.clientY);
      } else if ($e[4] == 1 && (He == null || He.pannable())) {
        if (mt) {
          if (!t.hoverData.dragging && oe.boxSelectionEnabled() && (Dt || !oe.panningEnabled() || !oe.userPanningEnabled()))
            ee();
          else if (!t.hoverData.selecting && oe.panningEnabled() && oe.userPanningEnabled()) {
            var kt = s(He, t.hoverData.downs);
            kt && (t.hoverData.dragging = !0, t.hoverData.justStartedPan = !0, $e[4] = 0, t.data.bgActivePosistion = uc(Se), t.redrawHint("select", !0), t.redraw());
          }
          He && He.pannable() && He.active() && He.unactivate();
        }
      } else {
        if (He && He.pannable() && He.active() && He.unactivate(), (!He || !He.grabbed()) && Ze != We && (We && a(We, ["mouseout", "tapdragout"], z, {
          x: ge[0],
          y: ge[1]
        }), Ze && a(Ze, ["mouseover", "tapdragover"], z, {
          x: ge[0],
          y: ge[1]
        }), t.hoverData.last = Ze), He)
          if (mt) {
            if (oe.boxSelectionEnabled() && Dt)
              He && He.grabbed() && (m(De), He.emit(yt("freeon")), De.emit(yt("free")), t.dragData.didDrag && (He.emit(yt("dragfreeon")), De.emit(yt("dragfree")))), ee();
            else if (He && He.grabbed() && t.nodeIsDraggable(He)) {
              var wt = !t.dragData.didDrag;
              wt && t.redrawHint("eles", !0), t.dragData.didDrag = !0, t.hoverData.draggingEles || g(De, {
                inDragLayer: !0
              });
              var pt = {
                x: 0,
                y: 0
              };
              if (tt(Pe[0]) && tt(Pe[1]) && (pt.x += Pe[0], pt.y += Pe[1], wt)) {
                var gt = t.hoverData.dragDelta;
                gt && tt(gt[0]) && tt(gt[1]) && (pt.x += gt[0], pt.y += gt[1]);
              }
              t.hoverData.draggingEles = !0, De.silentShift(pt).emit(yt("position")).emit(yt("drag")), t.redrawHint("drag", !0), t.redraw();
            }
          } else
            Gt();
        se = !0;
      }
      if ($e[2] = ge[0], $e[3] = ge[1], se)
        return z.stopPropagation && z.stopPropagation(), z.preventDefault && z.preventDefault(), !1;
    }
  }, !1);
  var _, O, T;
  t.registerBinding(e, "mouseup", function(z) {
    if (!(t.hoverData.which === 1 && z.which !== 1 && t.hoverData.capture)) {
      var Q = t.hoverData.capture;
      if (Q) {
        t.hoverData.capture = !1;
        var se = t.cy, oe = t.projectIntoViewport(z.clientX, z.clientY), he = t.selection, Le = t.findNearestElement(oe[0], oe[1], !0, !1), ge = t.dragData.possibleDragElements, Se = t.hoverData.down, xe = i(z);
        t.data.bgActivePosistion && (t.redrawHint("select", !0), t.redraw()), t.hoverData.tapholdCancelled = !0, t.data.bgActivePosistion = void 0, Se && Se.unactivate();
        var $e = function(Ke) {
          return {
            originalEvent: z,
            type: Ke,
            position: {
              x: oe[0],
              y: oe[1]
            }
          };
        };
        if (t.hoverData.which === 3) {
          var Ze = $e("cxttapend");
          if (Se ? Se.emit(Ze) : se.emit(Ze), !t.hoverData.cxtDragged) {
            var We = $e("cxttap");
            Se ? Se.emit(We) : se.emit(We);
          }
          t.hoverData.cxtDragged = !1, t.hoverData.which = null;
        } else if (t.hoverData.which === 1) {
          if (a(Le, ["mouseup", "tapend", "vmouseup"], z, {
            x: oe[0],
            y: oe[1]
          }), !t.dragData.didDrag && // didn't move a node around
          !t.hoverData.dragged && // didn't pan
          !t.hoverData.selecting && // not box selection
          !t.hoverData.isOverThresholdDrag && (a(Se, ["click", "tap", "vclick"], z, {
            x: oe[0],
            y: oe[1]
          }), O = !1, z.timeStamp - T <= se.multiClickDebounceTime() ? (_ && clearTimeout(_), O = !0, T = null, a(Se, ["dblclick", "dbltap", "vdblclick"], z, {
            x: oe[0],
            y: oe[1]
          })) : (_ = setTimeout(function() {
            O || a(Se, ["oneclick", "onetap", "voneclick"], z, {
              x: oe[0],
              y: oe[1]
            });
          }, se.multiClickDebounceTime()), T = z.timeStamp)), Se == null && !t.dragData.didDrag && !t.hoverData.selecting && !t.hoverData.dragged && !i(z) && (se.$(r).unselect(["tapunselect"]), ge.length > 0 && t.redrawHint("eles", !0), t.dragData.possibleDragElements = ge = se.collection()), Le == Se && !t.dragData.didDrag && !t.hoverData.selecting && Le != null && Le._private.selectable && (t.hoverData.dragging || (se.selectionType() === "additive" || xe ? Le.selected() ? Le.unselect(["tapunselect"]) : Le.select(["tapselect"]) : xe || (se.$(r).unmerge(Le).unselect(["tapunselect"]), Le.select(["tapselect"]))), t.redrawHint("eles", !0)), t.hoverData.selecting) {
            var He = se.collection(t.getAllInBox(he[0], he[1], he[2], he[3]));
            t.redrawHint("select", !0), He.length > 0 && t.redrawHint("eles", !0), se.emit($e("boxend"));
            var Pe = function(Ke) {
              return Ke.selectable() && !Ke.selected();
            };
            se.selectionType() === "additive" || xe || se.$(r).unmerge(He).unselect(), He.emit($e("box")).stdFilter(Pe).select().emit($e("boxselect")), t.redraw();
          }
          if (t.hoverData.dragging && (t.hoverData.dragging = !1, t.redrawHint("select", !0), t.redrawHint("eles", !0), t.redraw()), !he[4]) {
            t.redrawHint("drag", !0), t.redrawHint("eles", !0);
            var De = Se && Se.grabbed();
            m(ge), De && (Se.emit($e("freeon")), ge.emit($e("free")), t.dragData.didDrag && (Se.emit($e("dragfreeon")), ge.emit($e("dragfree"))));
          }
        }
        he[4] = 0, t.hoverData.down = null, t.hoverData.cxtStarted = !1, t.hoverData.draggingEles = !1, t.hoverData.selecting = !1, t.hoverData.isOverThresholdDrag = !1, t.dragData.didDrag = !1, t.hoverData.dragged = !1, t.hoverData.dragDelta = [], t.hoverData.mdownPos = null, t.hoverData.mdownGPos = null, t.hoverData.which = null;
      }
    }
  }, !1);
  var L = [], M = 4, A, I = 1e5, D = function(z, Q) {
    for (var se = 0; se < z.length; se++)
      if (z[se] % Q !== 0)
        return !1;
    return !0;
  }, F = function(z) {
    for (var Q = Math.abs(z[0]), se = 1; se < z.length; se++)
      if (Math.abs(z[se]) !== Q)
        return !1;
    return !0;
  }, B = function(z) {
    var Q = !1, se = z.deltaY;
    if (se == null && (z.wheelDeltaY != null ? se = z.wheelDeltaY / 4 : z.wheelDelta != null && (se = z.wheelDelta / 4)), se !== 0) {
      if (A == null)
        if (L.length >= M) {
          var oe = L;
          if (A = D(oe, 5), !A) {
            var he = Math.abs(oe[0]);
            A = F(oe) && he > 5;
          }
          if (A)
            for (var Le = 0; Le < oe.length; Le++)
              I = Math.min(Math.abs(oe[Le]), I);
        } else
          L.push(se), Q = !0;
      else A && (I = Math.min(Math.abs(se), I));
      if (!t.scrollingPage) {
        var ge = t.cy, Se = ge.zoom(), xe = ge.pan(), $e = t.projectIntoViewport(z.clientX, z.clientY), Ze = [$e[0] * Se + xe.x, $e[1] * Se + xe.y];
        if (t.hoverData.draggingEles || t.hoverData.dragging || t.hoverData.cxtStarted || k()) {
          z.preventDefault();
          return;
        }
        if (ge.panningEnabled() && ge.userPanningEnabled() && ge.zoomingEnabled() && ge.userZoomingEnabled()) {
          z.preventDefault(), t.data.wheelZooming = !0, clearTimeout(t.data.wheelTimeout), t.data.wheelTimeout = setTimeout(function() {
            t.data.wheelZooming = !1, t.redrawHint("eles", !0), t.redraw();
          }, 150);
          var We;
          Q && Math.abs(se) > 5 && (se = u3(se) * 5), We = se / -250, A && (We /= I, We *= 3), We = We * t.wheelSensitivity;
          var He = z.deltaMode === 1;
          He && (We *= 33);
          var Pe = ge.zoom() * Math.pow(10, We);
          z.type === "gesturechange" && (Pe = t.gestureStartZoom * z.scale), ge.zoom({
            level: Pe,
            renderedPosition: {
              x: Ze[0],
              y: Ze[1]
            }
          }), ge.emit({
            type: z.type === "gesturechange" ? "pinchzoom" : "scrollzoom",
            originalEvent: z,
            position: {
              x: $e[0],
              y: $e[1]
            }
          });
        }
      }
    }
  };
  t.registerBinding(t.container, "wheel", B, !0), t.registerBinding(e, "scroll", function(z) {
    t.scrollingPage = !0, clearTimeout(t.scrollingPageTimeout), t.scrollingPageTimeout = setTimeout(function() {
      t.scrollingPage = !1;
    }, 250);
  }, !0), t.registerBinding(t.container, "gesturestart", function(z) {
    t.gestureStartZoom = t.cy.zoom(), t.hasTouchStarted || z.preventDefault();
  }, !0), t.registerBinding(t.container, "gesturechange", function(ae) {
    t.hasTouchStarted || B(ae);
  }, !0), t.registerBinding(t.container, "mouseout", function(z) {
    var Q = t.projectIntoViewport(z.clientX, z.clientY);
    t.cy.emit({
      originalEvent: z,
      type: "mouseout",
      position: {
        x: Q[0],
        y: Q[1]
      }
    });
  }, !1), t.registerBinding(t.container, "mouseover", function(z) {
    var Q = t.projectIntoViewport(z.clientX, z.clientY);
    t.cy.emit({
      originalEvent: z,
      type: "mouseover",
      position: {
        x: Q[0],
        y: Q[1]
      }
    });
  }, !1);
  var G, H, K, j, Z, te, ne, V, q, X, W, ue, J, Ce = function(z, Q, se, oe) {
    return Math.sqrt((se - z) * (se - z) + (oe - Q) * (oe - Q));
  }, Ee = function(z, Q, se, oe) {
    return (se - z) * (se - z) + (oe - Q) * (oe - Q);
  }, Te;
  t.registerBinding(t.container, "touchstart", Te = function(z) {
    if (t.hasTouchStarted = !0, !!N(z)) {
      y(), t.touchData.capture = !0, t.data.bgActivePosistion = void 0;
      var Q = t.cy, se = t.touchData.now, oe = t.touchData.earlier;
      if (z.touches[0]) {
        var he = t.projectIntoViewport(z.touches[0].clientX, z.touches[0].clientY);
        se[0] = he[0], se[1] = he[1];
      }
      if (z.touches[1]) {
        var he = t.projectIntoViewport(z.touches[1].clientX, z.touches[1].clientY);
        se[2] = he[0], se[3] = he[1];
      }
      if (z.touches[2]) {
        var he = t.projectIntoViewport(z.touches[2].clientX, z.touches[2].clientY);
        se[4] = he[0], se[5] = he[1];
      }
      var Le = function(Dt) {
        return {
          originalEvent: z,
          type: Dt,
          position: {
            x: se[0],
            y: se[1]
          }
        };
      };
      if (z.touches[1]) {
        t.touchData.singleTouchMoved = !0, m(t.dragData.touchDragEles);
        var ge = t.findContainerClientCoords();
        q = ge[0], X = ge[1], W = ge[2], ue = ge[3], G = z.touches[0].clientX - q, H = z.touches[0].clientY - X, K = z.touches[1].clientX - q, j = z.touches[1].clientY - X, J = 0 <= G && G <= W && 0 <= K && K <= W && 0 <= H && H <= ue && 0 <= j && j <= ue;
        var Se = Q.pan(), xe = Q.zoom();
        Z = Ce(G, H, K, j), te = Ee(G, H, K, j), ne = [(G + K) / 2, (H + j) / 2], V = [(ne[0] - Se.x) / xe, (ne[1] - Se.y) / xe];
        var $e = 200, Ze = $e * $e;
        if (te < Ze && !z.touches[2]) {
          var We = t.findNearestElement(se[0], se[1], !0, !0), He = t.findNearestElement(se[2], se[3], !0, !0);
          We && We.isNode() ? (We.activate().emit(Le("cxttapstart")), t.touchData.start = We) : He && He.isNode() ? (He.activate().emit(Le("cxttapstart")), t.touchData.start = He) : Q.emit(Le("cxttapstart")), t.touchData.start && (t.touchData.start._private.grabbed = !1), t.touchData.cxt = !0, t.touchData.cxtDragged = !1, t.data.bgActivePosistion = void 0, t.redraw();
          return;
        }
      }
      if (z.touches[2])
        Q.boxSelectionEnabled() && z.preventDefault();
      else if (!z.touches[1]) {
        if (z.touches[0]) {
          var Pe = t.findNearestElements(se[0], se[1], !0, !0), De = Pe[0];
          if (De != null && (De.activate(), t.touchData.start = De, t.touchData.starts = Pe, t.nodeIsGrabbable(De))) {
            var mt = t.dragData.touchDragEles = Q.collection(), Ke = null;
            t.redrawHint("eles", !0), t.redrawHint("drag", !0), De.selected() ? (Ke = Q.$(function(nt) {
              return nt.selected() && t.nodeIsGrabbable(nt);
            }), g(Ke, {
              addToList: mt
            })) : v(De, {
              addToList: mt
            }), f(De), De.emit(Le("grabon")), Ke ? Ke.forEach(function(nt) {
              nt.emit(Le("grab"));
            }) : De.emit(Le("grab"));
          }
          a(De, ["touchstart", "tapstart", "vmousedown"], z, {
            x: se[0],
            y: se[1]
          }), De == null && (t.data.bgActivePosistion = {
            x: he[0],
            y: he[1]
          }, t.redrawHint("select", !0), t.redraw()), t.touchData.singleTouchMoved = !1, t.touchData.singleTouchStartTime = +/* @__PURE__ */ new Date(), clearTimeout(t.touchData.tapholdTimeout), t.touchData.tapholdTimeout = setTimeout(function() {
            t.touchData.singleTouchMoved === !1 && !t.pinching && !t.touchData.selecting && a(t.touchData.start, ["taphold"], z, {
              x: se[0],
              y: se[1]
            });
          }, t.tapholdDuration);
        }
      }
      if (z.touches.length >= 1) {
        for (var et = t.touchData.startPosition = [null, null, null, null, null, null], Pt = 0; Pt < se.length; Pt++)
          et[Pt] = oe[Pt] = se[Pt];
        var vt = z.touches[0];
        t.touchData.startGPosition = [vt.clientX, vt.clientY];
      }
    }
  }, !1);
  var me;
  t.registerBinding(e, "touchmove", me = function(z) {
    var Q = t.touchData.capture;
    if (!(!Q && !N(z))) {
      var se = t.selection, oe = t.cy, he = t.touchData.now, Le = t.touchData.earlier, ge = oe.zoom();
      if (z.touches[0]) {
        var Se = t.projectIntoViewport(z.touches[0].clientX, z.touches[0].clientY);
        he[0] = Se[0], he[1] = Se[1];
      }
      if (z.touches[1]) {
        var Se = t.projectIntoViewport(z.touches[1].clientX, z.touches[1].clientY);
        he[2] = Se[0], he[3] = Se[1];
      }
      if (z.touches[2]) {
        var Se = t.projectIntoViewport(z.touches[2].clientX, z.touches[2].clientY);
        he[4] = Se[0], he[5] = Se[1];
      }
      var xe = function(bH) {
        return {
          originalEvent: z,
          type: bH,
          position: {
            x: he[0],
            y: he[1]
          }
        };
      }, $e = t.touchData.startGPosition, Ze;
      if (Q && z.touches[0] && $e) {
        for (var We = [], He = 0; He < he.length; He++)
          We[He] = he[He] - Le[He];
        var Pe = z.touches[0].clientX - $e[0], De = Pe * Pe, mt = z.touches[0].clientY - $e[1], Ke = mt * mt, et = De + Ke;
        Ze = et >= t.touchTapThreshold2;
      }
      if (Q && t.touchData.cxt) {
        z.preventDefault();
        var Pt = z.touches[0].clientX - q, vt = z.touches[0].clientY - X, nt = z.touches[1].clientX - q, Dt = z.touches[1].clientY - X, Gt = Ee(Pt, vt, nt, Dt), yt = Gt / te, ee = 150, Re = ee * ee, Ge = 1.5, ot = Ge * Ge;
        if (yt >= ot || Gt >= Re) {
          t.touchData.cxt = !1, t.data.bgActivePosistion = void 0, t.redrawHint("select", !0);
          var kt = xe("cxttapend");
          t.touchData.start ? (t.touchData.start.unactivate().emit(kt), t.touchData.start = null) : oe.emit(kt);
        }
      }
      if (Q && t.touchData.cxt) {
        var kt = xe("cxtdrag");
        t.data.bgActivePosistion = void 0, t.redrawHint("select", !0), t.touchData.start ? t.touchData.start.emit(kt) : oe.emit(kt), t.touchData.start && (t.touchData.start._private.grabbed = !1), t.touchData.cxtDragged = !0;
        var wt = t.findNearestElement(he[0], he[1], !0, !0);
        (!t.touchData.cxtOver || wt !== t.touchData.cxtOver) && (t.touchData.cxtOver && t.touchData.cxtOver.emit(xe("cxtdragout")), t.touchData.cxtOver = wt, wt && wt.emit(xe("cxtdragover")));
      } else if (Q && z.touches[2] && oe.boxSelectionEnabled())
        z.preventDefault(), t.data.bgActivePosistion = void 0, this.lastThreeTouch = +/* @__PURE__ */ new Date(), t.touchData.selecting || oe.emit(xe("boxstart")), t.touchData.selecting = !0, t.touchData.didSelect = !0, se[4] = 1, !se || se.length === 0 || se[0] === void 0 ? (se[0] = (he[0] + he[2] + he[4]) / 3, se[1] = (he[1] + he[3] + he[5]) / 3, se[2] = (he[0] + he[2] + he[4]) / 3 + 1, se[3] = (he[1] + he[3] + he[5]) / 3 + 1) : (se[2] = (he[0] + he[2] + he[4]) / 3, se[3] = (he[1] + he[3] + he[5]) / 3), t.redrawHint("select", !0), t.redraw();
      else if (Q && z.touches[1] && !t.touchData.didSelect && oe.zoomingEnabled() && oe.panningEnabled() && oe.userZoomingEnabled() && oe.userPanningEnabled()) {
        z.preventDefault(), t.data.bgActivePosistion = void 0, t.redrawHint("select", !0);
        var pt = t.dragData.touchDragEles;
        if (pt) {
          t.redrawHint("drag", !0);
          for (var gt = 0; gt < pt.length; gt++) {
            var or = pt[gt]._private;
            or.grabbed = !1, or.rscratch.inDragLayer = !1;
          }
        }
        var ze = t.touchData.start, Pt = z.touches[0].clientX - q, vt = z.touches[0].clientY - X, nt = z.touches[1].clientX - q, Dt = z.touches[1].clientY - X, le = Ce(Pt, vt, nt, Dt), Oe = le / Z;
        if (J) {
          var at = Pt - G, Ht = vt - H, Vt = nt - K, yr = Dt - j, jr = (at + Vt) / 2, qn = (Ht + yr) / 2, aa = oe.zoom(), Ci = aa * Oe, Lr = oe.pan(), zr = V[0] * aa + Lr.x, It = V[1] * aa + Lr.y, ir = {
            x: -Ci / aa * (zr - Lr.x - jr) + zr,
            y: -Ci / aa * (It - Lr.y - qn) + It
          };
          if (ze && ze.active()) {
            var pt = t.dragData.touchDragEles;
            m(pt), t.redrawHint("drag", !0), t.redrawHint("eles", !0), ze.unactivate().emit(xe("freeon")), pt.emit(xe("free")), t.dragData.didDrag && (ze.emit(xe("dragfreeon")), pt.emit(xe("dragfree")));
          }
          oe.viewport({
            zoom: Ci,
            pan: ir,
            cancelOnFailedZoom: !0
          }), oe.emit(xe("pinchzoom")), Z = le, G = Pt, H = vt, K = nt, j = Dt, t.pinching = !0;
        }
        if (z.touches[0]) {
          var Se = t.projectIntoViewport(z.touches[0].clientX, z.touches[0].clientY);
          he[0] = Se[0], he[1] = Se[1];
        }
        if (z.touches[1]) {
          var Se = t.projectIntoViewport(z.touches[1].clientX, z.touches[1].clientY);
          he[2] = Se[0], he[3] = Se[1];
        }
        if (z.touches[2]) {
          var Se = t.projectIntoViewport(z.touches[2].clientX, z.touches[2].clientY);
          he[4] = Se[0], he[5] = Se[1];
        }
      } else if (z.touches[0] && !t.touchData.didSelect) {
        var an = t.touchData.start, Wn = t.touchData.last, wt;
        if (!t.hoverData.draggingEles && !t.swipePanning && (wt = t.findNearestElement(he[0], he[1], !0, !0)), Q && an != null && z.preventDefault(), Q && an != null && t.nodeIsDraggable(an))
          if (Ze) {
            var pt = t.dragData.touchDragEles, K3 = !t.dragData.didDrag;
            K3 && g(pt, {
              inDragLayer: !0
            }), t.dragData.didDrag = !0;
            var Bf = {
              x: 0,
              y: 0
            };
            if (tt(We[0]) && tt(We[1]) && (Bf.x += We[0], Bf.y += We[1], K3)) {
              t.redrawHint("eles", !0);
              var Ai = t.touchData.dragDelta;
              Ai && tt(Ai[0]) && tt(Ai[1]) && (Bf.x += Ai[0], Bf.y += Ai[1]);
            }
            t.hoverData.draggingEles = !0, pt.silentShift(Bf).emit(xe("position")).emit(xe("drag")), t.redrawHint("drag", !0), t.touchData.startPosition[0] == Le[0] && t.touchData.startPosition[1] == Le[1] && t.redrawHint("eles", !0), t.redraw();
          } else {
            var Ai = t.touchData.dragDelta = t.touchData.dragDelta || [];
            Ai.length === 0 ? (Ai.push(We[0]), Ai.push(We[1])) : (Ai[0] += We[0], Ai[1] += We[1]);
          }
        if (a(an || wt, ["touchmove", "tapdrag", "vmousemove"], z, {
          x: he[0],
          y: he[1]
        }), (!an || !an.grabbed()) && wt != Wn && (Wn && Wn.emit(xe("tapdragout")), wt && wt.emit(xe("tapdragover"))), t.touchData.last = wt, Q)
          for (var gt = 0; gt < he.length; gt++)
            he[gt] && t.touchData.startPosition[gt] && Ze && (t.touchData.singleTouchMoved = !0);
        if (Q && (an == null || an.pannable()) && oe.panningEnabled() && oe.userPanningEnabled()) {
          var yH = s(an, t.touchData.starts);
          yH && (z.preventDefault(), t.data.bgActivePosistion || (t.data.bgActivePosistion = uc(t.touchData.startPosition)), t.swipePanning ? (oe.panBy({
            x: We[0] * ge,
            y: We[1] * ge
          }), oe.emit(xe("dragpan"))) : Ze && (t.swipePanning = !0, oe.panBy({
            x: Pe * ge,
            y: mt * ge
          }), oe.emit(xe("dragpan")), an && (an.unactivate(), t.redrawHint("select", !0), t.touchData.start = null)));
          var Se = t.projectIntoViewport(z.touches[0].clientX, z.touches[0].clientY);
          he[0] = Se[0], he[1] = Se[1];
        }
      }
      for (var He = 0; He < he.length; He++)
        Le[He] = he[He];
      Q && z.touches.length > 0 && !t.hoverData.draggingEles && !t.swipePanning && t.data.bgActivePosistion != null && (t.data.bgActivePosistion = void 0, t.redrawHint("select", !0), t.redraw());
    }
  }, !1);
  var we;
  t.registerBinding(e, "touchcancel", we = function(z) {
    var Q = t.touchData.start;
    t.touchData.capture = !1, Q && Q.unactivate();
  });
  var Ae, Ne, Ie, Me;
  if (t.registerBinding(e, "touchend", Ae = function(z) {
    var Q = t.touchData.start, se = t.touchData.capture;
    if (se)
      z.touches.length === 0 && (t.touchData.capture = !1), z.preventDefault();
    else
      return;
    var oe = t.selection;
    t.swipePanning = !1, t.hoverData.draggingEles = !1;
    var he = t.cy, Le = he.zoom(), ge = t.touchData.now, Se = t.touchData.earlier;
    if (z.touches[0]) {
      var xe = t.projectIntoViewport(z.touches[0].clientX, z.touches[0].clientY);
      ge[0] = xe[0], ge[1] = xe[1];
    }
    if (z.touches[1]) {
      var xe = t.projectIntoViewport(z.touches[1].clientX, z.touches[1].clientY);
      ge[2] = xe[0], ge[3] = xe[1];
    }
    if (z.touches[2]) {
      var xe = t.projectIntoViewport(z.touches[2].clientX, z.touches[2].clientY);
      ge[4] = xe[0], ge[5] = xe[1];
    }
    var $e = function(Re) {
      return {
        originalEvent: z,
        type: Re,
        position: {
          x: ge[0],
          y: ge[1]
        }
      };
    };
    Q && Q.unactivate();
    var Ze;
    if (t.touchData.cxt) {
      if (Ze = $e("cxttapend"), Q ? Q.emit(Ze) : he.emit(Ze), !t.touchData.cxtDragged) {
        var We = $e("cxttap");
        Q ? Q.emit(We) : he.emit(We);
      }
      t.touchData.start && (t.touchData.start._private.grabbed = !1), t.touchData.cxt = !1, t.touchData.start = null, t.redraw();
      return;
    }
    if (!z.touches[2] && he.boxSelectionEnabled() && t.touchData.selecting) {
      t.touchData.selecting = !1;
      var He = he.collection(t.getAllInBox(oe[0], oe[1], oe[2], oe[3]));
      oe[0] = void 0, oe[1] = void 0, oe[2] = void 0, oe[3] = void 0, oe[4] = 0, t.redrawHint("select", !0), he.emit($e("boxend"));
      var Pe = function(Re) {
        return Re.selectable() && !Re.selected();
      };
      He.emit($e("box")).stdFilter(Pe).select().emit($e("boxselect")), He.nonempty() && t.redrawHint("eles", !0), t.redraw();
    }
    if (Q != null && Q.unactivate(), z.touches[2])
      t.data.bgActivePosistion = void 0, t.redrawHint("select", !0);
    else if (!z.touches[1]) {
      if (!z.touches[0]) {
        if (!z.touches[0]) {
          t.data.bgActivePosistion = void 0, t.redrawHint("select", !0);
          var De = t.dragData.touchDragEles;
          if (Q != null) {
            var mt = Q._private.grabbed;
            m(De), t.redrawHint("drag", !0), t.redrawHint("eles", !0), mt && (Q.emit($e("freeon")), De.emit($e("free")), t.dragData.didDrag && (Q.emit($e("dragfreeon")), De.emit($e("dragfree")))), a(Q, ["touchend", "tapend", "vmouseup", "tapdragout"], z, {
              x: ge[0],
              y: ge[1]
            }), Q.unactivate(), t.touchData.start = null;
          } else {
            var Ke = t.findNearestElement(ge[0], ge[1], !0, !0);
            a(Ke, ["touchend", "tapend", "vmouseup", "tapdragout"], z, {
              x: ge[0],
              y: ge[1]
            });
          }
          var et = t.touchData.startPosition[0] - ge[0], Pt = et * et, vt = t.touchData.startPosition[1] - ge[1], nt = vt * vt, Dt = Pt + nt, Gt = Dt * Le * Le;
          t.touchData.singleTouchMoved || (Q || he.$(":selected").unselect(["tapunselect"]), a(Q, ["tap", "vclick"], z, {
            x: ge[0],
            y: ge[1]
          }), Ne = !1, z.timeStamp - Me <= he.multiClickDebounceTime() ? (Ie && clearTimeout(Ie), Ne = !0, Me = null, a(Q, ["dbltap", "vdblclick"], z, {
            x: ge[0],
            y: ge[1]
          })) : (Ie = setTimeout(function() {
            Ne || a(Q, ["onetap", "voneclick"], z, {
              x: ge[0],
              y: ge[1]
            });
          }, he.multiClickDebounceTime()), Me = z.timeStamp)), Q != null && !t.dragData.didDrag && Q._private.selectable && Gt < t.touchTapThreshold2 && !t.pinching && (he.selectionType() === "single" ? (he.$(r).unmerge(Q).unselect(["tapunselect"]), Q.select(["tapselect"])) : Q.selected() ? Q.unselect(["tapunselect"]) : Q.select(["tapselect"]), t.redrawHint("eles", !0)), t.touchData.singleTouchMoved = !0;
        }
      }
    }
    for (var yt = 0; yt < ge.length; yt++)
      Se[yt] = ge[yt];
    t.dragData.didDrag = !1, z.touches.length === 0 && (t.touchData.dragDelta = [], t.touchData.startPosition = [null, null, null, null, null, null], t.touchData.startGPosition = null, t.touchData.didSelect = !1), z.touches.length < 2 && (z.touches.length === 1 && (t.touchData.startGPosition = [z.touches[0].clientX, z.touches[0].clientY]), t.pinching = !1, t.redrawHint("eles", !0), t.redraw());
  }, !1), typeof TouchEvent > "u") {
    var _e = [], Be = function(z) {
      return {
        clientX: z.clientX,
        clientY: z.clientY,
        force: 1,
        identifier: z.pointerId,
        pageX: z.pageX,
        pageY: z.pageY,
        radiusX: z.width / 2,
        radiusY: z.height / 2,
        screenX: z.screenX,
        screenY: z.screenY,
        target: z.target
      };
    }, st = function(z) {
      return {
        event: z,
        touch: Be(z)
      };
    }, ct = function(z) {
      _e.push(st(z));
    }, dt = function(z) {
      for (var Q = 0; Q < _e.length; Q++) {
        var se = _e[Q];
        if (se.event.pointerId === z.pointerId) {
          _e.splice(Q, 1);
          return;
        }
      }
    }, ft = function(z) {
      var Q = _e.filter(function(se) {
        return se.event.pointerId === z.pointerId;
      })[0];
      Q.event = z, Q.touch = Be(z);
    }, rt = function(z) {
      z.touches = _e.map(function(Q) {
        return Q.touch;
      });
    }, je = function(z) {
      return z.pointerType === "mouse" || z.pointerType === 4;
    };
    t.registerBinding(t.container, "pointerdown", function(ae) {
      je(ae) || (ae.preventDefault(), ct(ae), rt(ae), Te(ae));
    }), t.registerBinding(t.container, "pointerup", function(ae) {
      je(ae) || (dt(ae), rt(ae), Ae(ae));
    }), t.registerBinding(t.container, "pointercancel", function(ae) {
      je(ae) || (dt(ae), rt(ae), we(ae));
    }), t.registerBinding(t.container, "pointermove", function(ae) {
      je(ae) || (ae.preventDefault(), ft(ae), rt(ae), me(ae));
    });
  }
};
var xo = {};
xo.generatePolygon = function(t, e) {
  return this.nodeShapes[t] = {
    renderer: this,
    name: t,
    points: e,
    draw: function(n, a, i, s, o, l) {
      this.renderer.nodeShapeImpl("polygon", n, a, i, s, o, this.points);
    },
    intersectLine: function(n, a, i, s, o, l, u, c) {
      return c0(o, l, this.points, n, a, i / 2, s / 2, u);
    },
    checkPoint: function(n, a, i, s, o, l, u, c) {
      return co(n, a, this.points, l, u, s, o, [0, -1], i);
    },
    hasMiterBounds: t !== "rectangle",
    miterBounds: function(n, a, i, s, o, l) {
      return dEe(this.points, n, a, i, s, o);
    }
  };
};
xo.generateEllipse = function() {
  return this.nodeShapes.ellipse = {
    renderer: this,
    name: "ellipse",
    draw: function(e, r, n, a, i, s) {
      this.renderer.nodeShapeImpl(this.name, e, r, n, a, i);
    },
    intersectLine: function(e, r, n, a, i, s, o, l) {
      return wEe(i, s, e, r, n / 2 + o, a / 2 + o);
    },
    checkPoint: function(e, r, n, a, i, s, o, l) {
      return Ul(e, r, a, i, s, o, n);
    }
  };
};
xo.generateRoundPolygon = function(t, e) {
  return this.nodeShapes[t] = {
    renderer: this,
    name: t,
    points: e,
    getOrCreateCorners: function(n, a, i, s, o, l, u) {
      if (l[u] !== void 0 && l[u + "-cx"] === n && l[u + "-cy"] === a)
        return l[u];
      l[u] = new Array(e.length / 2), l[u + "-cx"] = n, l[u + "-cy"] = a;
      var c = i / 2, f = s / 2;
      o = o === "auto" ? jB(i, s) : o;
      for (var h = new Array(e.length / 2), d = 0; d < e.length / 2; d++)
        h[d] = {
          x: n + c * e[d * 2],
          y: a + f * e[d * 2 + 1]
        };
      var p, g, v, m, b = h.length;
      for (g = h[b - 1], p = 0; p < b; p++)
        v = h[p % b], m = h[(p + 1) % b], l[u][p] = E3(g, v, m, o), g = v, v = m;
      return l[u];
    },
    draw: function(n, a, i, s, o, l, u) {
      this.renderer.nodeShapeImpl("round-polygon", n, a, i, s, o, this.points, this.getOrCreateCorners(a, i, s, o, l, u, "drawCorners"));
    },
    intersectLine: function(n, a, i, s, o, l, u, c, f) {
      return TEe(o, l, this.points, n, a, i, s, u, this.getOrCreateCorners(n, a, i, s, c, f, "corners"));
    },
    checkPoint: function(n, a, i, s, o, l, u, c, f) {
      return xEe(n, a, this.points, l, u, s, o, this.getOrCreateCorners(l, u, s, o, c, f, "corners"));
    }
  };
};
xo.generateRoundRectangle = function() {
  return this.nodeShapes["round-rectangle"] = this.nodeShapes.roundrectangle = {
    renderer: this,
    name: "round-rectangle",
    points: oa(4, 0),
    draw: function(e, r, n, a, i, s) {
      this.renderer.nodeShapeImpl(this.name, e, r, n, a, i, this.points, s);
    },
    intersectLine: function(e, r, n, a, i, s, o, l) {
      return qB(i, s, e, r, n, a, o, l);
    },
    checkPoint: function(e, r, n, a, i, s, o, l) {
      var u = a / 2, c = i / 2;
      l = l === "auto" ? Xo(a, i) : l, l = Math.min(u, c, l);
      var f = l * 2;
      return !!(co(e, r, this.points, s, o, a, i - f, [0, -1], n) || co(e, r, this.points, s, o, a - f, i, [0, -1], n) || Ul(e, r, f, f, s - u + l, o - c + l, n) || Ul(e, r, f, f, s + u - l, o - c + l, n) || Ul(e, r, f, f, s + u - l, o + c - l, n) || Ul(e, r, f, f, s - u + l, o + c - l, n));
    }
  };
};
xo.generateCutRectangle = function() {
  return this.nodeShapes["cut-rectangle"] = this.nodeShapes.cutrectangle = {
    renderer: this,
    name: "cut-rectangle",
    cornerLength: f3(),
    points: oa(4, 0),
    draw: function(e, r, n, a, i, s) {
      this.renderer.nodeShapeImpl(this.name, e, r, n, a, i, null, s);
    },
    generateCutTrianglePts: function(e, r, n, a, i) {
      var s = i === "auto" ? this.cornerLength : i, o = r / 2, l = e / 2, u = n - l, c = n + l, f = a - o, h = a + o;
      return {
        topLeft: [u, f + s, u + s, f, u + s, f + s],
        topRight: [c - s, f, c, f + s, c - s, f + s],
        bottomRight: [c, h - s, c - s, h, c - s, h - s],
        bottomLeft: [u + s, h, u, h - s, u + s, h - s]
      };
    },
    intersectLine: function(e, r, n, a, i, s, o, l) {
      var u = this.generateCutTrianglePts(n + 2 * o, a + 2 * o, e, r, l), c = [].concat.apply([], [u.topLeft.splice(0, 4), u.topRight.splice(0, 4), u.bottomRight.splice(0, 4), u.bottomLeft.splice(0, 4)]);
      return c0(i, s, c, e, r);
    },
    checkPoint: function(e, r, n, a, i, s, o, l) {
      var u = l === "auto" ? this.cornerLength : l;
      if (co(e, r, this.points, s, o, a, i - 2 * u, [0, -1], n) || co(e, r, this.points, s, o, a - 2 * u, i, [0, -1], n))
        return !0;
      var c = this.generateCutTrianglePts(a, i, s, o);
      return Sa(e, r, c.topLeft) || Sa(e, r, c.topRight) || Sa(e, r, c.bottomRight) || Sa(e, r, c.bottomLeft);
    }
  };
};
xo.generateBarrel = function() {
  return this.nodeShapes.barrel = {
    renderer: this,
    name: "barrel",
    points: oa(4, 0),
    draw: function(e, r, n, a, i, s) {
      this.renderer.nodeShapeImpl(this.name, e, r, n, a, i);
    },
    intersectLine: function(e, r, n, a, i, s, o, l) {
      var u = 0.15, c = 0.5, f = 0.85, h = this.generateBarrelBezierPts(n + 2 * o, a + 2 * o, e, r), d = function(v) {
        var m = wc({
          x: v[0],
          y: v[1]
        }, {
          x: v[2],
          y: v[3]
        }, {
          x: v[4],
          y: v[5]
        }, u), b = wc({
          x: v[0],
          y: v[1]
        }, {
          x: v[2],
          y: v[3]
        }, {
          x: v[4],
          y: v[5]
        }, c), y = wc({
          x: v[0],
          y: v[1]
        }, {
          x: v[2],
          y: v[3]
        }, {
          x: v[4],
          y: v[5]
        }, f);
        return [v[0], v[1], m.x, m.y, b.x, b.y, y.x, y.y, v[4], v[5]];
      }, p = [].concat(d(h.topLeft), d(h.topRight), d(h.bottomRight), d(h.bottomLeft));
      return c0(i, s, p, e, r);
    },
    generateBarrelBezierPts: function(e, r, n, a) {
      var i = r / 2, s = e / 2, o = n - s, l = n + s, u = a - i, c = a + i, f = b4(e, r), h = f.heightOffset, d = f.widthOffset, p = f.ctrlPtOffsetPct * e, g = {
        topLeft: [o, u + h, o + p, u, o + d, u],
        topRight: [l - d, u, l - p, u, l, u + h],
        bottomRight: [l, c - h, l - p, c, l - d, c],
        bottomLeft: [o + d, c, o + p, c, o, c - h]
      };
      return g.topLeft.isTop = !0, g.topRight.isTop = !0, g.bottomLeft.isBottom = !0, g.bottomRight.isBottom = !0, g;
    },
    checkPoint: function(e, r, n, a, i, s, o, l) {
      var u = b4(a, i), c = u.heightOffset, f = u.widthOffset;
      if (co(e, r, this.points, s, o, a, i - 2 * c, [0, -1], n) || co(e, r, this.points, s, o, a - 2 * f, i, [0, -1], n))
        return !0;
      for (var h = this.generateBarrelBezierPts(a, i, s, o), d = function(C, k, N) {
        var R = N[4], _ = N[2], O = N[0], T = N[5], L = N[1], M = Math.min(R, O), A = Math.max(R, O), I = Math.min(T, L), D = Math.max(T, L);
        if (M <= C && C <= A && I <= k && k <= D) {
          var F = SEe(R, _, O), B = vEe(F[0], F[1], F[2], C), G = B.filter(function(H) {
            return 0 <= H && H <= 1;
          });
          if (G.length > 0)
            return G[0];
        }
        return null;
      }, p = Object.keys(h), g = 0; g < p.length; g++) {
        var v = p[g], m = h[v], b = d(e, r, m);
        if (b != null) {
          var y = m[5], x = m[3], E = m[1], S = Cn(y, x, E, b);
          if (m.isTop && S <= r || m.isBottom && r <= S)
            return !0;
        }
      }
      return !1;
    }
  };
};
xo.generateBottomRoundrectangle = function() {
  return this.nodeShapes["bottom-round-rectangle"] = this.nodeShapes.bottomroundrectangle = {
    renderer: this,
    name: "bottom-round-rectangle",
    points: oa(4, 0),
    draw: function(e, r, n, a, i, s) {
      this.renderer.nodeShapeImpl(this.name, e, r, n, a, i, this.points, s);
    },
    intersectLine: function(e, r, n, a, i, s, o, l) {
      var u = e - (n / 2 + o), c = r - (a / 2 + o), f = c, h = e + (n / 2 + o), d = $o(i, s, e, r, u, c, h, f, !1);
      return d.length > 0 ? d : qB(i, s, e, r, n, a, o, l);
    },
    checkPoint: function(e, r, n, a, i, s, o, l) {
      l = l === "auto" ? Xo(a, i) : l;
      var u = 2 * l;
      if (co(e, r, this.points, s, o, a, i - u, [0, -1], n) || co(e, r, this.points, s, o, a - u, i, [0, -1], n))
        return !0;
      var c = a / 2 + 2 * n, f = i / 2 + 2 * n, h = [s - c, o - f, s - c, o, s + c, o, s + c, o - f];
      return !!(Sa(e, r, h) || Ul(e, r, u, u, s + a / 2 - l, o + i / 2 - l, n) || Ul(e, r, u, u, s - a / 2 + l, o + i / 2 - l, n));
    }
  };
};
xo.registerNodeShapes = function() {
  var t = this.nodeShapes = {}, e = this;
  this.generateEllipse(), this.generatePolygon("triangle", oa(3, 0)), this.generateRoundPolygon("round-triangle", oa(3, 0)), this.generatePolygon("rectangle", oa(4, 0)), t.square = t.rectangle, this.generateRoundRectangle(), this.generateCutRectangle(), this.generateBarrel(), this.generateBottomRoundrectangle();
  {
    var r = [0, 1, 1, 0, 0, -1, -1, 0];
    this.generatePolygon("diamond", r), this.generateRoundPolygon("round-diamond", r);
  }
  this.generatePolygon("pentagon", oa(5, 0)), this.generateRoundPolygon("round-pentagon", oa(5, 0)), this.generatePolygon("hexagon", oa(6, 0)), this.generateRoundPolygon("round-hexagon", oa(6, 0)), this.generatePolygon("heptagon", oa(7, 0)), this.generateRoundPolygon("round-heptagon", oa(7, 0)), this.generatePolygon("octagon", oa(8, 0)), this.generateRoundPolygon("round-octagon", oa(8, 0));
  var n = new Array(20);
  {
    var a = y4(5, 0), i = y4(5, Math.PI / 5), s = 0.5 * (3 - Math.sqrt(5));
    s *= 1.57;
    for (var o = 0; o < i.length / 2; o++)
      i[o * 2] *= s, i[o * 2 + 1] *= s;
    for (var o = 0; o < 20 / 4; o++)
      n[o * 4] = a[o * 2], n[o * 4 + 1] = a[o * 2 + 1], n[o * 4 + 2] = i[o * 2], n[o * 4 + 3] = i[o * 2 + 1];
  }
  n = WB(n), this.generatePolygon("star", n), this.generatePolygon("vee", [-1, -1, 0, -0.333, 1, -1, 0, 1]), this.generatePolygon("rhomboid", [-1, -1, 0.333, -1, 1, 1, -0.333, 1]), this.generatePolygon("right-rhomboid", [-0.333, -1, 1, -1, 0.333, 1, -1, 1]), this.nodeShapes.concavehexagon = this.generatePolygon("concave-hexagon", [-1, -0.95, -0.75, 0, -1, 0.95, 1, 0.95, 0.75, 0, 1, -0.95]);
  {
    var l = [-1, -1, 0.25, -1, 1, 0, 0.25, 1, -1, 1];
    this.generatePolygon("tag", l), this.generateRoundPolygon("round-tag", l);
  }
  t.makePolygon = function(u) {
    var c = u.join("$"), f = "polygon-" + c, h;
    return (h = this[f]) ? h : e.generatePolygon(f, u);
  };
};
var mp = {};
mp.timeToRender = function() {
  return this.redrawTotalTime / this.redrawCount;
};
mp.redraw = function(t) {
  t = t || GB();
  var e = this;
  e.averageRedrawTime === void 0 && (e.averageRedrawTime = 0), e.lastRedrawTime === void 0 && (e.lastRedrawTime = 0), e.lastDrawTime === void 0 && (e.lastDrawTime = 0), e.requestedFrame = !0, e.renderOptions = t;
};
mp.beforeRender = function(t, e) {
  if (!this.destroyed) {
    e == null && Fr("Priority is not optional for beforeRender");
    var r = this.beforeRenderCallbacks;
    r.push({
      fn: t,
      priority: e
    }), r.sort(function(n, a) {
      return a.priority - n.priority;
    });
  }
};
var pL = function(e, r, n) {
  for (var a = e.beforeRenderCallbacks, i = 0; i < a.length; i++)
    a[i].fn(r, n);
};
mp.startRenderLoop = function() {
  var t = this, e = t.cy;
  if (!t.renderLoopStarted) {
    t.renderLoopStarted = !0;
    var r = function(a) {
      if (!t.destroyed) {
        if (!e.batching()) if (t.requestedFrame && !t.skipFrame) {
          pL(t, !0, a);
          var i = uo();
          t.render(t.renderOptions);
          var s = t.lastDrawTime = uo();
          t.averageRedrawTime === void 0 && (t.averageRedrawTime = s - i), t.redrawCount === void 0 && (t.redrawCount = 0), t.redrawCount++, t.redrawTotalTime === void 0 && (t.redrawTotalTime = 0);
          var o = s - i;
          t.redrawTotalTime += o, t.lastRedrawTime = o, t.averageRedrawTime = t.averageRedrawTime / 2 + o / 2, t.requestedFrame = !1;
        } else
          pL(t, !1, a);
        t.skipFrame = !1, $m(r);
      }
    };
    $m(r);
  }
};
var zSe = function(e) {
  this.init(e);
}, jz = zSe, If = jz.prototype;
If.clientFunctions = ["redrawHint", "render", "renderTo", "matchCanvasSize", "nodeShapeImpl", "arrowShapeImpl"];
If.init = function(t) {
  var e = this;
  e.options = t, e.cy = t.cy;
  var r = e.container = t.cy.container(), n = e.cy.window();
  if (n) {
    var a = n.document, i = a.head, s = "__________cytoscape_stylesheet", o = "__________cytoscape_container", l = a.getElementById(s) != null;
    if (r.className.indexOf(o) < 0 && (r.className = (r.className || "") + " " + o), !l) {
      var u = a.createElement("style");
      u.id = s, u.textContent = "." + o + " { position: relative; }", i.insertBefore(u, i.children[0]);
    }
    var c = n.getComputedStyle(r), f = c.getPropertyValue("position");
    f === "static" && pr("A Cytoscape container has style position:static and so can not use UI extensions properly");
  }
  e.selection = [void 0, void 0, void 0, void 0, 0], e.bezierProjPcts = [0.05, 0.225, 0.4, 0.5, 0.6, 0.775, 0.95], e.hoverData = {
    down: null,
    last: null,
    downTime: null,
    triggerMode: null,
    dragging: !1,
    initialPan: [null, null],
    capture: !1
  }, e.dragData = {
    possibleDragElements: []
  }, e.touchData = {
    start: null,
    capture: !1,
    // These 3 fields related to tap, taphold events
    startPosition: [null, null, null, null, null, null],
    singleTouchStartTime: null,
    singleTouchMoved: !0,
    now: [null, null, null, null, null, null],
    earlier: [null, null, null, null, null, null]
  }, e.redraws = 0, e.showFps = t.showFps, e.debug = t.debug, e.webgl = t.webgl, e.hideEdgesOnViewport = t.hideEdgesOnViewport, e.textureOnViewport = t.textureOnViewport, e.wheelSensitivity = t.wheelSensitivity, e.motionBlurEnabled = t.motionBlur, e.forcedPixelRatio = tt(t.pixelRatio) ? t.pixelRatio : null, e.motionBlur = t.motionBlur, e.motionBlurOpacity = t.motionBlurOpacity, e.motionBlurTransparency = 1 - e.motionBlurOpacity, e.motionBlurPxRatio = 1, e.mbPxRBlurry = 1, e.minMbLowQualFrames = 4, e.fullQualityMb = !1, e.clearedForMotionBlur = [], e.desktopTapThreshold = t.desktopTapThreshold, e.desktopTapThreshold2 = t.desktopTapThreshold * t.desktopTapThreshold, e.touchTapThreshold = t.touchTapThreshold, e.touchTapThreshold2 = t.touchTapThreshold * t.touchTapThreshold, e.tapholdDuration = 500, e.bindings = [], e.beforeRenderCallbacks = [], e.beforeRenderPriorities = {
    // higher priority execs before lower one
    animations: 400,
    eleCalcs: 300,
    eleTxrDeq: 200,
    lyrTxrDeq: 150,
    lyrTxrSkip: 100
  }, e.registerNodeShapes(), e.registerArrowShapes(), e.registerCalculationListeners();
};
If.notify = function(t, e) {
  var r = this, n = r.cy;
  if (!this.destroyed) {
    if (t === "init") {
      r.load();
      return;
    }
    if (t === "destroy") {
      r.destroy();
      return;
    }
    (t === "add" || t === "remove" || t === "move" && n.hasCompoundNodes() || t === "load" || t === "zorder" || t === "mount") && r.invalidateCachedZSortedEles(), t === "viewport" && r.redrawHint("select", !0), t === "gc" && r.redrawHint("gc", !0), (t === "load" || t === "resize" || t === "mount") && (r.invalidateContainerClientCoordsCache(), r.matchCanvasSize(r.container)), r.redrawHint("eles", !0), r.redrawHint("drag", !0), this.startRenderLoop(), this.redraw();
  }
};
If.destroy = function() {
  var t = this;
  t.destroyed = !0, t.cy.stopAnimationLoop();
  for (var e = 0; e < t.bindings.length; e++) {
    var r = t.bindings[e], n = r, a = n.target;
    (a.off || a.removeEventListener).apply(a, n.args);
  }
  if (t.bindings = [], t.beforeRenderCallbacks = [], t.onUpdateEleCalcsFns = [], t.removeObserver && t.removeObserver.disconnect(), t.styleObserver && t.styleObserver.disconnect(), t.resizeObserver && t.resizeObserver.disconnect(), t.labelCalcDiv)
    try {
      document.body.removeChild(t.labelCalcDiv);
    } catch {
    }
};
If.isHeadless = function() {
  return !1;
};
[w3, qz, Wz, Of, xo, mp].forEach(function(t) {
  At(If, t);
});
var Tw = 1e3 / 60, Yz = {
  setupDequeueing: function(e) {
    return function() {
      var n = this, a = this.renderer;
      if (!n.dequeueingSetup) {
        n.dequeueingSetup = !0;
        var i = hp(function() {
          a.redrawHint("eles", !0), a.redrawHint("drag", !0), a.redraw();
        }, e.deqRedrawThreshold), s = function(u, c) {
          var f = uo(), h = a.averageRedrawTime, d = a.lastRedrawTime, p = [], g = a.cy.extent(), v = a.getPixelRatio();
          for (u || a.flushRenderedStyleQueue(); ; ) {
            var m = uo(), b = m - f, y = m - c;
            if (d < Tw) {
              var x = Tw - (u ? h : 0);
              if (y >= e.deqFastCost * x)
                break;
            } else if (u) {
              if (b >= e.deqCost * d || b >= e.deqAvgCost * h)
                break;
            } else if (y >= e.deqNoDrawCost * Tw)
              break;
            var E = e.deq(n, v, g);
            if (E.length > 0)
              for (var S = 0; S < E.length; S++)
                p.push(E[S]);
            else
              break;
          }
          p.length > 0 && (e.onDeqd(n, p), !u && e.shouldRedraw(n, p, v, g) && i());
        }, o = e.priority || s3;
        a.beforeRender(s, o(n));
      }
    };
  }
}, GSe = /* @__PURE__ */ function() {
  function t(e) {
    var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Fm;
    hl(this, t), this.idsByKey = new Xs(), this.keyForId = new Xs(), this.cachesByLvl = new Xs(), this.lvls = [], this.getKey = e, this.doesEleInvalidateKey = r;
  }
  return dl(t, [{
    key: "getIdsFor",
    value: function(r) {
      r == null && Fr("Can not get id list for null key");
      var n = this.idsByKey, a = this.idsByKey.get(r);
      return a || (a = new Mf(), n.set(r, a)), a;
    }
  }, {
    key: "addIdForKey",
    value: function(r, n) {
      r != null && this.getIdsFor(r).add(n);
    }
  }, {
    key: "deleteIdForKey",
    value: function(r, n) {
      r != null && this.getIdsFor(r).delete(n);
    }
  }, {
    key: "getNumberOfIdsForKey",
    value: function(r) {
      return r == null ? 0 : this.getIdsFor(r).size;
    }
  }, {
    key: "updateKeyMappingFor",
    value: function(r) {
      var n = r.id(), a = this.keyForId.get(n), i = this.getKey(r);
      this.deleteIdForKey(a, n), this.addIdForKey(i, n), this.keyForId.set(n, i);
    }
  }, {
    key: "deleteKeyMappingFor",
    value: function(r) {
      var n = r.id(), a = this.keyForId.get(n);
      this.deleteIdForKey(a, n), this.keyForId.delete(n);
    }
  }, {
    key: "keyHasChangedFor",
    value: function(r) {
      var n = r.id(), a = this.keyForId.get(n), i = this.getKey(r);
      return a !== i;
    }
  }, {
    key: "isInvalid",
    value: function(r) {
      return this.keyHasChangedFor(r) || this.doesEleInvalidateKey(r);
    }
  }, {
    key: "getCachesAt",
    value: function(r) {
      var n = this.cachesByLvl, a = this.lvls, i = n.get(r);
      return i || (i = new Xs(), n.set(r, i), a.push(r)), i;
    }
  }, {
    key: "getCache",
    value: function(r, n) {
      return this.getCachesAt(n).get(r);
    }
  }, {
    key: "get",
    value: function(r, n) {
      var a = this.getKey(r), i = this.getCache(a, n);
      return i != null && this.updateKeyMappingFor(r), i;
    }
  }, {
    key: "getForCachedKey",
    value: function(r, n) {
      var a = this.keyForId.get(r.id()), i = this.getCache(a, n);
      return i;
    }
  }, {
    key: "hasCache",
    value: function(r, n) {
      return this.getCachesAt(n).has(r);
    }
  }, {
    key: "has",
    value: function(r, n) {
      var a = this.getKey(r);
      return this.hasCache(a, n);
    }
  }, {
    key: "setCache",
    value: function(r, n, a) {
      a.key = r, this.getCachesAt(n).set(r, a);
    }
  }, {
    key: "set",
    value: function(r, n, a) {
      var i = this.getKey(r);
      this.setCache(i, n, a), this.updateKeyMappingFor(r);
    }
  }, {
    key: "deleteCache",
    value: function(r, n) {
      this.getCachesAt(n).delete(r);
    }
  }, {
    key: "delete",
    value: function(r, n) {
      var a = this.getKey(r);
      this.deleteCache(a, n);
    }
  }, {
    key: "invalidateKey",
    value: function(r) {
      var n = this;
      this.lvls.forEach(function(a) {
        return n.deleteCache(r, a);
      });
    }
    // returns true if no other eles reference the invalidated cache (n.b. other eles may need the cache with the same key)
  }, {
    key: "invalidate",
    value: function(r) {
      var n = r.id(), a = this.keyForId.get(n);
      this.deleteKeyMappingFor(r);
      var i = this.doesEleInvalidateKey(r);
      return i && this.invalidateKey(a), i || this.getNumberOfIdsForKey(a) === 0;
    }
  }]);
}(), gL = 25, bg = 50, Tv = -4, N4 = 3, Xz = 7.99, USe = 8, HSe = 1024, VSe = 1024, qSe = 1024, WSe = 0.2, jSe = 0.8, YSe = 10, XSe = 0.15, KSe = 0.1, ZSe = 0.9, QSe = 0.9, JSe = 100, e5e = 1, fc = {
  dequeue: "dequeue",
  downscale: "downscale",
  highQuality: "highQuality"
}, t5e = Hn({
  getKey: null,
  doesEleInvalidateKey: Fm,
  drawElement: null,
  getBoundingBox: null,
  getRotationPoint: null,
  getRotationOffset: null,
  isVisible: FB,
  allowEdgeTxrCaching: !0,
  allowParentTxrCaching: !0
}), Nh = function(e, r) {
  var n = this;
  n.renderer = e, n.onDequeues = [];
  var a = t5e(r);
  At(n, a), n.lookup = new GSe(a.getKey, a.doesEleInvalidateKey), n.setupDequeueing();
}, En = Nh.prototype;
En.reasons = fc;
En.getTextureQueue = function(t) {
  var e = this;
  return e.eleImgCaches = e.eleImgCaches || {}, e.eleImgCaches[t] = e.eleImgCaches[t] || [];
};
En.getRetiredTextureQueue = function(t) {
  var e = this, r = e.eleImgCaches.retired = e.eleImgCaches.retired || {}, n = r[t] = r[t] || [];
  return n;
};
En.getElementQueue = function() {
  var t = this, e = t.eleCacheQueue = t.eleCacheQueue || new dp(function(r, n) {
    return n.reqs - r.reqs;
  });
  return e;
};
En.getElementKeyToQueue = function() {
  var t = this, e = t.eleKeyToCacheQueue = t.eleKeyToCacheQueue || {};
  return e;
};
En.getElement = function(t, e, r, n, a) {
  var i = this, s = this.renderer, o = s.cy.zoom(), l = this.lookup;
  if (!e || e.w === 0 || e.h === 0 || isNaN(e.w) || isNaN(e.h) || !t.visible() || t.removed() || !i.allowEdgeTxrCaching && t.isEdge() || !i.allowParentTxrCaching && t.isParent())
    return null;
  if (n == null && (n = Math.ceil(l3(o * r))), n < Tv)
    n = Tv;
  else if (o >= Xz || n > N4)
    return null;
  var u = Math.pow(2, n), c = e.h * u, f = e.w * u, h = s.eleTextBiggerThanMin(t, u);
  if (!this.isVisible(t, h))
    return null;
  var d = l.get(t, n);
  if (d && d.invalidated && (d.invalidated = !1, d.texture.invalidatedWidth -= d.width), d)
    return d;
  var p;
  if (c <= gL ? p = gL : c <= bg ? p = bg : p = Math.ceil(c / bg) * bg, c > qSe || f > VSe)
    return null;
  var g = i.getTextureQueue(p), v = g[g.length - 2], m = function() {
    return i.recycleTexture(p, f) || i.addTexture(p, f);
  };
  v || (v = g[g.length - 1]), v || (v = m()), v.width - v.usedWidth < f && (v = m());
  for (var b = function(M) {
    return M && M.scaledLabelShown === h;
  }, y = a && a === fc.dequeue, x = a && a === fc.highQuality, E = a && a === fc.downscale, S, w = n + 1; w <= N4; w++) {
    var C = l.get(t, w);
    if (C) {
      S = C;
      break;
    }
  }
  var k = S && S.level === n + 1 ? S : null, N = function() {
    v.context.drawImage(k.texture.canvas, k.x, 0, k.width, k.height, v.usedWidth, 0, f, c);
  };
  if (v.context.setTransform(1, 0, 0, 1, 0, 0), v.context.clearRect(v.usedWidth, 0, f, p), b(k))
    N();
  else if (b(S))
    if (x) {
      for (var R = S.level; R > n; R--)
        k = i.getElement(t, e, r, R, fc.downscale);
      N();
    } else
      return i.queueElement(t, S.level - 1), S;
  else {
    var _;
    if (!y && !x && !E)
      for (var O = n - 1; O >= Tv; O--) {
        var T = l.get(t, O);
        if (T) {
          _ = T;
          break;
        }
      }
    if (b(_))
      return i.queueElement(t, n), _;
    v.context.translate(v.usedWidth, 0), v.context.scale(u, u), this.drawElement(v.context, t, e, h, !1), v.context.scale(1 / u, 1 / u), v.context.translate(-v.usedWidth, 0);
  }
  return d = {
    x: v.usedWidth,
    texture: v,
    level: n,
    scale: u,
    width: f,
    height: c,
    scaledLabelShown: h
  }, v.usedWidth += Math.ceil(f + USe), v.eleCaches.push(d), l.set(t, n, d), i.checkTextureFullness(v), d;
};
En.invalidateElements = function(t) {
  for (var e = 0; e < t.length; e++)
    this.invalidateElement(t[e]);
};
En.invalidateElement = function(t) {
  var e = this, r = e.lookup, n = [], a = r.isInvalid(t);
  if (a) {
    for (var i = Tv; i <= N4; i++) {
      var s = r.getForCachedKey(t, i);
      s && n.push(s);
    }
    var o = r.invalidate(t);
    if (o)
      for (var l = 0; l < n.length; l++) {
        var u = n[l], c = u.texture;
        c.invalidatedWidth += u.width, u.invalidated = !0, e.checkTextureUtility(c);
      }
    e.removeFromQueue(t);
  }
};
En.checkTextureUtility = function(t) {
  t.invalidatedWidth >= WSe * t.width && this.retireTexture(t);
};
En.checkTextureFullness = function(t) {
  var e = this, r = e.getTextureQueue(t.height);
  t.usedWidth / t.width > jSe && t.fullnessChecks >= YSe ? Yo(r, t) : t.fullnessChecks++;
};
En.retireTexture = function(t) {
  var e = this, r = t.height, n = e.getTextureQueue(r), a = this.lookup;
  Yo(n, t), t.retired = !0;
  for (var i = t.eleCaches, s = 0; s < i.length; s++) {
    var o = i[s];
    a.deleteCache(o.key, o.level);
  }
  o3(i);
  var l = e.getRetiredTextureQueue(r);
  l.push(t);
};
En.addTexture = function(t, e) {
  var r = this, n = r.getTextureQueue(t), a = {};
  return n.push(a), a.eleCaches = [], a.height = t, a.width = Math.max(HSe, e), a.usedWidth = 0, a.invalidatedWidth = 0, a.fullnessChecks = 0, a.canvas = r.renderer.makeOffscreenCanvas(a.width, a.height), a.context = a.canvas.getContext("2d"), a;
};
En.recycleTexture = function(t, e) {
  for (var r = this, n = r.getTextureQueue(t), a = r.getRetiredTextureQueue(t), i = 0; i < a.length; i++) {
    var s = a[i];
    if (s.width >= e)
      return s.retired = !1, s.usedWidth = 0, s.invalidatedWidth = 0, s.fullnessChecks = 0, o3(s.eleCaches), s.context.setTransform(1, 0, 0, 1, 0, 0), s.context.clearRect(0, 0, s.width, s.height), Yo(a, s), n.push(s), s;
  }
};
En.queueElement = function(t, e) {
  var r = this, n = r.getElementQueue(), a = r.getElementKeyToQueue(), i = this.getKey(t), s = a[i];
  if (s)
    s.level = Math.max(s.level, e), s.eles.merge(t), s.reqs++, n.updateItem(s);
  else {
    var o = {
      eles: t.spawn().merge(t),
      level: e,
      reqs: 1,
      key: i
    };
    n.push(o), a[i] = o;
  }
};
En.dequeue = function(t) {
  for (var e = this, r = e.getElementQueue(), n = e.getElementKeyToQueue(), a = [], i = e.lookup, s = 0; s < e5e && r.size() > 0; s++) {
    var o = r.pop(), l = o.key, u = o.eles[0], c = i.hasCache(u, o.level);
    if (n[l] = null, c)
      continue;
    a.push(o);
    var f = e.getBoundingBox(u);
    e.getElement(u, f, t, o.level, fc.dequeue);
  }
  return a;
};
En.removeFromQueue = function(t) {
  var e = this, r = e.getElementQueue(), n = e.getElementKeyToQueue(), a = this.getKey(t), i = n[a];
  i != null && (i.eles.length === 1 ? (i.reqs = i3, r.updateItem(i), r.pop(), n[a] = null) : i.eles.unmerge(t));
};
En.onDequeue = function(t) {
  this.onDequeues.push(t);
};
En.offDequeue = function(t) {
  Yo(this.onDequeues, t);
};
En.setupDequeueing = Yz.setupDequeueing({
  deqRedrawThreshold: JSe,
  deqCost: XSe,
  deqAvgCost: KSe,
  deqNoDrawCost: ZSe,
  deqFastCost: QSe,
  deq: function(e, r, n) {
    return e.dequeue(r, n);
  },
  onDeqd: function(e, r) {
    for (var n = 0; n < e.onDequeues.length; n++) {
      var a = e.onDequeues[n];
      a(r);
    }
  },
  shouldRedraw: function(e, r, n, a) {
    for (var i = 0; i < r.length; i++)
      for (var s = r[i].eles, o = 0; o < s.length; o++) {
        var l = s[o].boundingBox();
        if (c3(l, a))
          return !0;
      }
    return !1;
  },
  priority: function(e) {
    return e.renderer.beforeRenderPriorities.eleTxrDeq;
  }
});
var r5e = 1, Od = -4, Wm = 2, n5e = 3.99, a5e = 50, i5e = 50, s5e = 0.15, o5e = 0.1, l5e = 0.9, u5e = 0.9, c5e = 1, vL = 250, f5e = 4e3 * 4e3, mL = 32767, h5e = !0, Kz = function(e) {
  var r = this, n = r.renderer = e, a = n.cy;
  r.layersByLevel = {}, r.firstGet = !0, r.lastInvalidationTime = uo() - 2 * vL, r.skipping = !1, r.eleTxrDeqs = a.collection(), r.scheduleElementRefinement = hp(function() {
    r.refineElementTextures(r.eleTxrDeqs), r.eleTxrDeqs.unmerge(r.eleTxrDeqs);
  }, i5e), n.beforeRender(function(s, o) {
    o - r.lastInvalidationTime <= vL ? r.skipping = !0 : r.skipping = !1;
  }, n.beforeRenderPriorities.lyrTxrSkip);
  var i = function(o, l) {
    return l.reqs - o.reqs;
  };
  r.layersQueue = new dp(i), r.setupDequeueing();
}, Vn = Kz.prototype, yL = 0, d5e = Math.pow(2, 53) - 1;
Vn.makeLayer = function(t, e) {
  var r = Math.pow(2, e), n = Math.ceil(t.w * r), a = Math.ceil(t.h * r), i = this.renderer.makeOffscreenCanvas(n, a), s = {
    id: yL = ++yL % d5e,
    bb: t,
    level: e,
    width: n,
    height: a,
    canvas: i,
    context: i.getContext("2d"),
    eles: [],
    elesQueue: [],
    reqs: 0
  }, o = s.context, l = -s.bb.x1, u = -s.bb.y1;
  return o.scale(r, r), o.translate(l, u), s;
};
Vn.getLayers = function(t, e, r) {
  var n = this, a = n.renderer, i = a.cy, s = i.zoom(), o = n.firstGet;
  if (n.firstGet = !1, r == null) {
    if (r = Math.ceil(l3(s * e)), r < Od)
      r = Od;
    else if (s >= n5e || r > Wm)
      return null;
  }
  n.validateLayersElesOrdering(r, t);
  var l = n.layersByLevel, u = Math.pow(2, r), c = l[r] = l[r] || [], f, h = n.levelIsComplete(r, t), d, p = function() {
    var N = function(L) {
      if (n.validateLayersElesOrdering(L, t), n.levelIsComplete(L, t))
        return d = l[L], !0;
    }, R = function(L) {
      if (!d)
        for (var M = r + L; Od <= M && M <= Wm && !N(M); M += L)
          ;
    };
    R(1), R(-1);
    for (var _ = c.length - 1; _ >= 0; _--) {
      var O = c[_];
      O.invalid && Yo(c, O);
    }
  };
  if (!h)
    p();
  else
    return c;
  var g = function() {
    if (!f) {
      f = da();
      for (var N = 0; N < t.length; N++)
        cEe(f, t[N].boundingBox());
    }
    return f;
  }, v = function(N) {
    N = N || {};
    var R = N.after;
    g();
    var _ = Math.ceil(f.w * u), O = Math.ceil(f.h * u);
    if (_ > mL || O > mL)
      return null;
    var T = _ * O;
    if (T > f5e)
      return null;
    var L = n.makeLayer(f, r);
    if (R != null) {
      var M = c.indexOf(R) + 1;
      c.splice(M, 0, L);
    } else (N.insert === void 0 || N.insert) && c.unshift(L);
    return L;
  };
  if (n.skipping && !o)
    return null;
  for (var m = null, b = t.length / r5e, y = !o, x = 0; x < t.length; x++) {
    var E = t[x], S = E._private.rscratch, w = S.imgLayerCaches = S.imgLayerCaches || {}, C = w[r];
    if (C) {
      m = C;
      continue;
    }
    if ((!m || m.eles.length >= b || !VB(m.bb, E.boundingBox())) && (m = v({
      insert: !0,
      after: m
    }), !m))
      return null;
    d || y ? n.queueLayer(m, E) : n.drawEleInLayer(m, E, r, e), m.eles.push(E), w[r] = m;
  }
  return d || (y ? null : c);
};
Vn.getEleLevelForLayerLevel = function(t, e) {
  return t;
};
Vn.drawEleInLayer = function(t, e, r, n) {
  var a = this, i = this.renderer, s = t.context, o = e.boundingBox();
  o.w === 0 || o.h === 0 || !e.visible() || (r = a.getEleLevelForLayerLevel(r, n), i.setImgSmoothing(s, !1), i.drawCachedElement(s, e, null, null, r, h5e), i.setImgSmoothing(s, !0));
};
Vn.levelIsComplete = function(t, e) {
  var r = this, n = r.layersByLevel[t];
  if (!n || n.length === 0)
    return !1;
  for (var a = 0, i = 0; i < n.length; i++) {
    var s = n[i];
    if (s.reqs > 0 || s.invalid)
      return !1;
    a += s.eles.length;
  }
  return a === e.length;
};
Vn.validateLayersElesOrdering = function(t, e) {
  var r = this.layersByLevel[t];
  if (r)
    for (var n = 0; n < r.length; n++) {
      for (var a = r[n], i = -1, s = 0; s < e.length; s++)
        if (a.eles[0] === e[s]) {
          i = s;
          break;
        }
      if (i < 0) {
        this.invalidateLayer(a);
        continue;
      }
      for (var o = i, s = 0; s < a.eles.length; s++)
        if (a.eles[s] !== e[o + s]) {
          this.invalidateLayer(a);
          break;
        }
    }
};
Vn.updateElementsInLayers = function(t, e) {
  for (var r = this, n = lp(t[0]), a = 0; a < t.length; a++)
    for (var i = n ? null : t[a], s = n ? t[a] : t[a].ele, o = s._private.rscratch, l = o.imgLayerCaches = o.imgLayerCaches || {}, u = Od; u <= Wm; u++) {
      var c = l[u];
      c && (i && r.getEleLevelForLayerLevel(c.level) !== i.level || e(c, s, i));
    }
};
Vn.haveLayers = function() {
  for (var t = this, e = !1, r = Od; r <= Wm; r++) {
    var n = t.layersByLevel[r];
    if (n && n.length > 0) {
      e = !0;
      break;
    }
  }
  return e;
};
Vn.invalidateElements = function(t) {
  var e = this;
  t.length !== 0 && (e.lastInvalidationTime = uo(), !(t.length === 0 || !e.haveLayers()) && e.updateElementsInLayers(t, function(n, a, i) {
    e.invalidateLayer(n);
  }));
};
Vn.invalidateLayer = function(t) {
  if (this.lastInvalidationTime = uo(), !t.invalid) {
    var e = t.level, r = t.eles, n = this.layersByLevel[e];
    Yo(n, t), t.elesQueue = [], t.invalid = !0, t.replacement && (t.replacement.invalid = !0);
    for (var a = 0; a < r.length; a++) {
      var i = r[a]._private.rscratch.imgLayerCaches;
      i && (i[e] = null);
    }
  }
};
Vn.refineElementTextures = function(t) {
  var e = this;
  e.updateElementsInLayers(t, function(n, a, i) {
    var s = n.replacement;
    if (s || (s = n.replacement = e.makeLayer(n.bb, n.level), s.replaces = n, s.eles = n.eles), !s.reqs)
      for (var o = 0; o < s.eles.length; o++)
        e.queueLayer(s, s.eles[o]);
  });
};
Vn.enqueueElementRefinement = function(t) {
  this.eleTxrDeqs.merge(t), this.scheduleElementRefinement();
};
Vn.queueLayer = function(t, e) {
  var r = this, n = r.layersQueue, a = t.elesQueue, i = a.hasId = a.hasId || {};
  if (!t.replacement) {
    if (e) {
      if (i[e.id()])
        return;
      a.push(e), i[e.id()] = !0;
    }
    t.reqs ? (t.reqs++, n.updateItem(t)) : (t.reqs = 1, n.push(t));
  }
};
Vn.dequeue = function(t) {
  for (var e = this, r = e.layersQueue, n = [], a = 0; a < c5e && r.size() !== 0; ) {
    var i = r.peek();
    if (i.replacement) {
      r.pop();
      continue;
    }
    if (i.replaces && i !== i.replaces.replacement) {
      r.pop();
      continue;
    }
    if (i.invalid) {
      r.pop();
      continue;
    }
    var s = i.elesQueue.shift();
    s && (e.drawEleInLayer(i, s, i.level, t), a++), n.length === 0 && n.push(!0), i.elesQueue.length === 0 && (r.pop(), i.reqs = 0, i.replaces && e.applyLayerReplacement(i), e.requestRedraw());
  }
  return n;
};
Vn.applyLayerReplacement = function(t) {
  var e = this, r = e.layersByLevel[t.level], n = t.replaces, a = r.indexOf(n);
  if (!(a < 0 || n.invalid)) {
    r[a] = t;
    for (var i = 0; i < t.eles.length; i++) {
      var s = t.eles[i]._private, o = s.imgLayerCaches = s.imgLayerCaches || {};
      o && (o[t.level] = t);
    }
    e.requestRedraw();
  }
};
Vn.requestRedraw = hp(function() {
  var t = this.renderer;
  t.redrawHint("eles", !0), t.redrawHint("drag", !0), t.redraw();
}, 100);
Vn.setupDequeueing = Yz.setupDequeueing({
  deqRedrawThreshold: a5e,
  deqCost: s5e,
  deqAvgCost: o5e,
  deqNoDrawCost: l5e,
  deqFastCost: u5e,
  deq: function(e, r) {
    return e.dequeue(r);
  },
  onDeqd: s3,
  shouldRedraw: FB,
  priority: function(e) {
    return e.renderer.beforeRenderPriorities.lyrTxrDeq;
  }
});
var Zz = {}, bL;
function p5e(t, e) {
  for (var r = 0; r < e.length; r++) {
    var n = e[r];
    t.lineTo(n.x, n.y);
  }
}
function g5e(t, e, r) {
  for (var n, a = 0; a < e.length; a++) {
    var i = e[a];
    a === 0 && (n = i), t.lineTo(i.x, i.y);
  }
  t.quadraticCurveTo(r.x, r.y, n.x, n.y);
}
function xL(t, e, r) {
  t.beginPath && t.beginPath();
  for (var n = e, a = 0; a < n.length; a++) {
    var i = n[a];
    t.lineTo(i.x, i.y);
  }
  var s = r, o = r[0];
  t.moveTo(o.x, o.y);
  for (var a = 1; a < s.length; a++) {
    var i = s[a];
    t.lineTo(i.x, i.y);
  }
  t.closePath && t.closePath();
}
function v5e(t, e, r, n, a) {
  t.beginPath && t.beginPath(), t.arc(r, n, a, 0, Math.PI * 2, !1);
  var i = e, s = i[0];
  t.moveTo(s.x, s.y);
  for (var o = 0; o < i.length; o++) {
    var l = i[o];
    t.lineTo(l.x, l.y);
  }
  t.closePath && t.closePath();
}
function m5e(t, e, r, n) {
  t.arc(e, r, n, 0, Math.PI * 2, !1);
}
Zz.arrowShapeImpl = function(t) {
  return (bL || (bL = {
    polygon: p5e,
    "triangle-backcurve": g5e,
    "triangle-tee": xL,
    "circle-triangle": v5e,
    "triangle-cross": xL,
    circle: m5e
  }))[t];
};
var Rs = {};
Rs.drawElement = function(t, e, r, n, a, i) {
  var s = this;
  e.isNode() ? s.drawNode(t, e, r, n, a, i) : s.drawEdge(t, e, r, n, a, i);
};
Rs.drawElementOverlay = function(t, e) {
  var r = this;
  e.isNode() ? r.drawNodeOverlay(t, e) : r.drawEdgeOverlay(t, e);
};
Rs.drawElementUnderlay = function(t, e) {
  var r = this;
  e.isNode() ? r.drawNodeUnderlay(t, e) : r.drawEdgeUnderlay(t, e);
};
Rs.drawCachedElementPortion = function(t, e, r, n, a, i, s, o) {
  var l = this, u = r.getBoundingBox(e);
  if (!(u.w === 0 || u.h === 0)) {
    var c = r.getElement(e, u, n, a, i);
    if (c != null) {
      var f = o(l, e);
      if (f === 0)
        return;
      var h = s(l, e), d = u.x1, p = u.y1, g = u.w, v = u.h, m, b, y, x, E;
      if (h !== 0) {
        var S = r.getRotationPoint(e);
        y = S.x, x = S.y, t.translate(y, x), t.rotate(h), E = l.getImgSmoothing(t), E || l.setImgSmoothing(t, !0);
        var w = r.getRotationOffset(e);
        m = w.x, b = w.y;
      } else
        m = d, b = p;
      var C;
      f !== 1 && (C = t.globalAlpha, t.globalAlpha = C * f), t.drawImage(c.texture.canvas, c.x, 0, c.width, c.height, m, b, g, v), f !== 1 && (t.globalAlpha = C), h !== 0 && (t.rotate(-h), t.translate(-y, -x), E || l.setImgSmoothing(t, !1));
    } else
      r.drawElement(t, e);
  }
};
var y5e = function() {
  return 0;
}, b5e = function(e, r) {
  return e.getTextAngle(r, null);
}, x5e = function(e, r) {
  return e.getTextAngle(r, "source");
}, w5e = function(e, r) {
  return e.getTextAngle(r, "target");
}, E5e = function(e, r) {
  return r.effectiveOpacity();
}, Sw = function(e, r) {
  return r.pstyle("text-opacity").pfValue * r.effectiveOpacity();
};
Rs.drawCachedElement = function(t, e, r, n, a, i) {
  var s = this, o = s.data, l = o.eleTxrCache, u = o.lblTxrCache, c = o.slbTxrCache, f = o.tlbTxrCache, h = e.boundingBox(), d = i === !0 ? l.reasons.highQuality : null;
  if (!(h.w === 0 || h.h === 0 || !e.visible()) && (!n || c3(h, n))) {
    var p = e.isEdge(), g = e.element()._private.rscratch.badLine;
    s.drawElementUnderlay(t, e), s.drawCachedElementPortion(t, e, l, r, a, d, y5e, E5e), (!p || !g) && s.drawCachedElementPortion(t, e, u, r, a, d, b5e, Sw), p && !g && (s.drawCachedElementPortion(t, e, c, r, a, d, x5e, Sw), s.drawCachedElementPortion(t, e, f, r, a, d, w5e, Sw)), s.drawElementOverlay(t, e);
  }
};
Rs.drawElements = function(t, e) {
  for (var r = this, n = 0; n < e.length; n++) {
    var a = e[n];
    r.drawElement(t, a);
  }
};
Rs.drawCachedElements = function(t, e, r, n) {
  for (var a = this, i = 0; i < e.length; i++) {
    var s = e[i];
    a.drawCachedElement(t, s, r, n);
  }
};
Rs.drawCachedNodes = function(t, e, r, n) {
  for (var a = this, i = 0; i < e.length; i++) {
    var s = e[i];
    s.isNode() && a.drawCachedElement(t, s, r, n);
  }
};
Rs.drawLayeredElements = function(t, e, r, n) {
  var a = this, i = a.data.lyrTxrCache.getLayers(e, r);
  if (i)
    for (var s = 0; s < i.length; s++) {
      var o = i[s], l = o.bb;
      l.w === 0 || l.h === 0 || t.drawImage(o.canvas, l.x1, l.y1, l.w, l.h);
    }
  else
    a.drawCachedElements(t, e, r, n);
};
var wo = {};
wo.drawEdge = function(t, e, r) {
  var n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !0, a = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0, i = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : !0, s = this, o = e._private.rscratch;
  if (!(i && !e.visible()) && !(o.badLine || o.allpts == null || isNaN(o.allpts[0]))) {
    var l;
    r && (l = r, t.translate(-l.x1, -l.y1));
    var u = i ? e.pstyle("opacity").value : 1, c = i ? e.pstyle("line-opacity").value : 1, f = e.pstyle("curve-style").value, h = e.pstyle("line-style").value, d = e.pstyle("width").pfValue, p = e.pstyle("line-cap").value, g = e.pstyle("line-outline-width").value, v = e.pstyle("line-outline-color").value, m = u * c, b = u * c, y = function() {
      var L = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : m;
      f === "straight-triangle" ? (s.eleStrokeStyle(t, e, L), s.drawEdgeTrianglePath(e, t, o.allpts)) : (t.lineWidth = d, t.lineCap = p, s.eleStrokeStyle(t, e, L), s.drawEdgePath(e, t, o.allpts, h), t.lineCap = "butt");
    }, x = function() {
      var L = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : m;
      if (t.lineWidth = d + g, t.lineCap = p, g > 0)
        s.colorStrokeStyle(t, v[0], v[1], v[2], L);
      else {
        t.lineCap = "butt";
        return;
      }
      f === "straight-triangle" ? s.drawEdgeTrianglePath(e, t, o.allpts) : (s.drawEdgePath(e, t, o.allpts, h), t.lineCap = "butt");
    }, E = function() {
      a && s.drawEdgeOverlay(t, e);
    }, S = function() {
      a && s.drawEdgeUnderlay(t, e);
    }, w = function() {
      var L = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : b;
      s.drawArrowheads(t, e, L);
    }, C = function() {
      s.drawElementText(t, e, null, n);
    };
    t.lineJoin = "round";
    var k = e.pstyle("ghost").value === "yes";
    if (k) {
      var N = e.pstyle("ghost-offset-x").pfValue, R = e.pstyle("ghost-offset-y").pfValue, _ = e.pstyle("ghost-opacity").value, O = m * _;
      t.translate(N, R), y(O), w(O), t.translate(-N, -R);
    } else
      x();
    S(), y(), w(), E(), C(), r && t.translate(l.x1, l.y1);
  }
};
var Qz = function(e) {
  if (!["overlay", "underlay"].includes(e))
    throw new Error("Invalid state");
  return function(r, n) {
    if (n.visible()) {
      var a = n.pstyle("".concat(e, "-opacity")).value;
      if (a !== 0) {
        var i = this, s = i.usePaths(), o = n._private.rscratch, l = n.pstyle("".concat(e, "-padding")).pfValue, u = 2 * l, c = n.pstyle("".concat(e, "-color")).value;
        r.lineWidth = u, o.edgeType === "self" && !s ? r.lineCap = "butt" : r.lineCap = "round", i.colorStrokeStyle(r, c[0], c[1], c[2], a), i.drawEdgePath(n, r, o.allpts, "solid");
      }
    }
  };
};
wo.drawEdgeOverlay = Qz("overlay");
wo.drawEdgeUnderlay = Qz("underlay");
wo.drawEdgePath = function(t, e, r, n) {
  var a = t._private.rscratch, i = e, s, o = !1, l = this.usePaths(), u = t.pstyle("line-dash-pattern").pfValue, c = t.pstyle("line-dash-offset").pfValue;
  if (l) {
    var f = r.join("$"), h = a.pathCacheKey && a.pathCacheKey === f;
    h ? (s = e = a.pathCache, o = !0) : (s = e = new Path2D(), a.pathCacheKey = f, a.pathCache = s);
  }
  if (i.setLineDash)
    switch (n) {
      case "dotted":
        i.setLineDash([1, 1]);
        break;
      case "dashed":
        i.setLineDash(u), i.lineDashOffset = c;
        break;
      case "solid":
        i.setLineDash([]);
        break;
    }
  if (!o && !a.badLine)
    switch (e.beginPath && e.beginPath(), e.moveTo(r[0], r[1]), a.edgeType) {
      case "bezier":
      case "self":
      case "compound":
      case "multibezier":
        for (var d = 2; d + 3 < r.length; d += 4)
          e.quadraticCurveTo(r[d], r[d + 1], r[d + 2], r[d + 3]);
        break;
      case "straight":
      case "haystack":
        for (var p = 2; p + 1 < r.length; p += 2)
          e.lineTo(r[p], r[p + 1]);
        break;
      case "segments":
        if (a.isRound) {
          var g = Ca(a.roundCorners), v;
          try {
            for (g.s(); !(v = g.n()).done; ) {
              var m = v.value;
              zz(e, m);
            }
          } catch (y) {
            g.e(y);
          } finally {
            g.f();
          }
          e.lineTo(r[r.length - 2], r[r.length - 1]);
        } else
          for (var b = 2; b + 1 < r.length; b += 2)
            e.lineTo(r[b], r[b + 1]);
        break;
    }
  e = i, l ? e.stroke(s) : e.stroke(), e.setLineDash && e.setLineDash([]);
};
wo.drawEdgeTrianglePath = function(t, e, r) {
  e.fillStyle = e.strokeStyle;
  for (var n = t.pstyle("width").pfValue, a = 0; a + 1 < r.length; a += 2) {
    var i = [r[a + 2] - r[a], r[a + 3] - r[a + 1]], s = Math.sqrt(i[0] * i[0] + i[1] * i[1]), o = [i[1] / s, -i[0] / s], l = [o[0] * n / 2, o[1] * n / 2];
    e.beginPath(), e.moveTo(r[a] - l[0], r[a + 1] - l[1]), e.lineTo(r[a] + l[0], r[a + 1] + l[1]), e.lineTo(r[a + 2], r[a + 3]), e.closePath(), e.fill();
  }
};
wo.drawArrowheads = function(t, e, r) {
  var n = e._private.rscratch, a = n.edgeType === "haystack";
  a || this.drawArrowhead(t, e, "source", n.arrowStartX, n.arrowStartY, n.srcArrowAngle, r), this.drawArrowhead(t, e, "mid-target", n.midX, n.midY, n.midtgtArrowAngle, r), this.drawArrowhead(t, e, "mid-source", n.midX, n.midY, n.midsrcArrowAngle, r), a || this.drawArrowhead(t, e, "target", n.arrowEndX, n.arrowEndY, n.tgtArrowAngle, r);
};
wo.drawArrowhead = function(t, e, r, n, a, i, s) {
  if (!(isNaN(n) || n == null || isNaN(a) || a == null || isNaN(i) || i == null)) {
    var o = this, l = e.pstyle(r + "-arrow-shape").value;
    if (l !== "none") {
      var u = e.pstyle(r + "-arrow-fill").value === "hollow" ? "both" : "filled", c = e.pstyle(r + "-arrow-fill").value, f = e.pstyle("width").pfValue, h = e.pstyle(r + "-arrow-width"), d = h.value === "match-line" ? f : h.pfValue;
      h.units === "%" && (d *= f);
      var p = e.pstyle("opacity").value;
      s === void 0 && (s = p);
      var g = t.globalCompositeOperation;
      (s !== 1 || c === "hollow") && (t.globalCompositeOperation = "destination-out", o.colorFillStyle(t, 255, 255, 255, 1), o.colorStrokeStyle(t, 255, 255, 255, 1), o.drawArrowShape(e, t, u, f, l, d, n, a, i), t.globalCompositeOperation = g);
      var v = e.pstyle(r + "-arrow-color").value;
      o.colorFillStyle(t, v[0], v[1], v[2], s), o.colorStrokeStyle(t, v[0], v[1], v[2], s), o.drawArrowShape(e, t, c, f, l, d, n, a, i);
    }
  }
};
wo.drawArrowShape = function(t, e, r, n, a, i, s, o, l) {
  var u = this, c = this.usePaths() && a !== "triangle-cross", f = !1, h, d = e, p = {
    x: s,
    y: o
  }, g = t.pstyle("arrow-scale").value, v = this.getArrowWidth(n, g), m = u.arrowShapes[a];
  if (c) {
    var b = u.arrowPathCache = u.arrowPathCache || [], y = iu(a), x = b[y];
    x != null ? (h = e = x, f = !0) : (h = e = new Path2D(), b[y] = h);
  }
  f || (e.beginPath && e.beginPath(), c ? m.draw(e, 1, 0, {
    x: 0,
    y: 0
  }, 1) : m.draw(e, v, l, p, n), e.closePath && e.closePath()), e = d, c && (e.translate(s, o), e.rotate(l), e.scale(v, v)), (r === "filled" || r === "both") && (c ? e.fill(h) : e.fill()), (r === "hollow" || r === "both") && (e.lineWidth = i / (c ? v : 1), e.lineJoin = "miter", c ? e.stroke(h) : e.stroke()), c && (e.scale(1 / v, 1 / v), e.rotate(-l), e.translate(-s, -o));
};
var S3 = {};
S3.safeDrawImage = function(t, e, r, n, a, i, s, o, l, u) {
  if (!(a <= 0 || i <= 0 || l <= 0 || u <= 0))
    try {
      t.drawImage(e, r, n, a, i, s, o, l, u);
    } catch (c) {
      pr(c);
    }
};
S3.drawInscribedImage = function(t, e, r, n, a) {
  var i = this, s = r.position(), o = s.x, l = s.y, u = r.cy().style(), c = u.getIndexedStyle.bind(u), f = c(r, "background-fit", "value", n), h = c(r, "background-repeat", "value", n), d = r.width(), p = r.height(), g = r.padding() * 2, v = d + (c(r, "background-width-relative-to", "value", n) === "inner" ? 0 : g), m = p + (c(r, "background-height-relative-to", "value", n) === "inner" ? 0 : g), b = r._private.rscratch, y = c(r, "background-clip", "value", n), x = y === "node", E = c(r, "background-image-opacity", "value", n) * a, S = c(r, "background-image-smoothing", "value", n), w = r.pstyle("corner-radius").value;
  w !== "auto" && (w = r.pstyle("corner-radius").pfValue);
  var C = e.width || e.cachedW, k = e.height || e.cachedH;
  (C == null || k == null) && (document.body.appendChild(e), C = e.cachedW = e.width || e.offsetWidth, k = e.cachedH = e.height || e.offsetHeight, document.body.removeChild(e));
  var N = C, R = k;
  if (c(r, "background-width", "value", n) !== "auto" && (c(r, "background-width", "units", n) === "%" ? N = c(r, "background-width", "pfValue", n) * v : N = c(r, "background-width", "pfValue", n)), c(r, "background-height", "value", n) !== "auto" && (c(r, "background-height", "units", n) === "%" ? R = c(r, "background-height", "pfValue", n) * m : R = c(r, "background-height", "pfValue", n)), !(N === 0 || R === 0)) {
    if (f === "contain") {
      var _ = Math.min(v / N, m / R);
      N *= _, R *= _;
    } else if (f === "cover") {
      var _ = Math.max(v / N, m / R);
      N *= _, R *= _;
    }
    var O = o - v / 2, T = c(r, "background-position-x", "units", n), L = c(r, "background-position-x", "pfValue", n);
    T === "%" ? O += (v - N) * L : O += L;
    var M = c(r, "background-offset-x", "units", n), A = c(r, "background-offset-x", "pfValue", n);
    M === "%" ? O += (v - N) * A : O += A;
    var I = l - m / 2, D = c(r, "background-position-y", "units", n), F = c(r, "background-position-y", "pfValue", n);
    D === "%" ? I += (m - R) * F : I += F;
    var B = c(r, "background-offset-y", "units", n), G = c(r, "background-offset-y", "pfValue", n);
    B === "%" ? I += (m - R) * G : I += G, b.pathCache && (O -= o, I -= l, o = 0, l = 0);
    var H = t.globalAlpha;
    t.globalAlpha = E;
    var K = i.getImgSmoothing(t), j = !1;
    if (S === "no" && K ? (i.setImgSmoothing(t, !1), j = !0) : S === "yes" && !K && (i.setImgSmoothing(t, !0), j = !0), h === "no-repeat")
      x && (t.save(), b.pathCache ? t.clip(b.pathCache) : (i.nodeShapes[i.getNodeShape(r)].draw(t, o, l, v, m, w, b), t.clip())), i.safeDrawImage(t, e, 0, 0, C, k, O, I, N, R), x && t.restore();
    else {
      var Z = t.createPattern(e, h);
      t.fillStyle = Z, i.nodeShapes[i.getNodeShape(r)].draw(t, o, l, v, m, w, b), t.translate(O, I), t.fill(), t.translate(-O, -I);
    }
    t.globalAlpha = H, j && i.setImgSmoothing(t, K);
  }
};
var Lu = {};
Lu.eleTextBiggerThanMin = function(t, e) {
  if (!e) {
    var r = t.cy().zoom(), n = this.getPixelRatio(), a = Math.ceil(l3(r * n));
    e = Math.pow(2, a);
  }
  var i = t.pstyle("font-size").pfValue * e, s = t.pstyle("min-zoomed-font-size").pfValue;
  return !(i < s);
};
Lu.drawElementText = function(t, e, r, n, a) {
  var i = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : !0, s = this;
  if (n == null) {
    if (i && !s.eleTextBiggerThanMin(e))
      return;
  } else if (n === !1)
    return;
  if (e.isNode()) {
    var o = e.pstyle("label");
    if (!o || !o.value)
      return;
    var l = s.getLabelJustification(e);
    t.textAlign = l, t.textBaseline = "bottom";
  } else {
    var u = e.element()._private.rscratch.badLine, c = e.pstyle("label"), f = e.pstyle("source-label"), h = e.pstyle("target-label");
    if (u || (!c || !c.value) && (!f || !f.value) && (!h || !h.value))
      return;
    t.textAlign = "center", t.textBaseline = "bottom";
  }
  var d = !r, p;
  r && (p = r, t.translate(-p.x1, -p.y1)), a == null ? (s.drawText(t, e, null, d, i), e.isEdge() && (s.drawText(t, e, "source", d, i), s.drawText(t, e, "target", d, i))) : s.drawText(t, e, a, d, i), r && t.translate(p.x1, p.y1);
};
Lu.getFontCache = function(t) {
  var e;
  this.fontCaches = this.fontCaches || [];
  for (var r = 0; r < this.fontCaches.length; r++)
    if (e = this.fontCaches[r], e.context === t)
      return e;
  return e = {
    context: t
  }, this.fontCaches.push(e), e;
};
Lu.setupTextStyle = function(t, e) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, n = e.pstyle("font-style").strValue, a = e.pstyle("font-size").pfValue + "px", i = e.pstyle("font-family").strValue, s = e.pstyle("font-weight").strValue, o = r ? e.effectiveOpacity() * e.pstyle("text-opacity").value : 1, l = e.pstyle("text-outline-opacity").value * o, u = e.pstyle("color").value, c = e.pstyle("text-outline-color").value;
  t.font = n + " " + s + " " + a + " " + i, t.lineJoin = "round", this.colorFillStyle(t, u[0], u[1], u[2], o), this.colorStrokeStyle(t, c[0], c[1], c[2], l);
};
function T5e(t, e, r, n, a) {
  var i = Math.min(n, a), s = i / 2, o = e + n / 2, l = r + a / 2;
  t.beginPath(), t.arc(o, l, s, 0, Math.PI * 2), t.closePath();
}
function wL(t, e, r, n, a) {
  var i = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 5, s = Math.min(i, n / 2, a / 2);
  t.beginPath(), t.moveTo(e + s, r), t.lineTo(e + n - s, r), t.quadraticCurveTo(e + n, r, e + n, r + s), t.lineTo(e + n, r + a - s), t.quadraticCurveTo(e + n, r + a, e + n - s, r + a), t.lineTo(e + s, r + a), t.quadraticCurveTo(e, r + a, e, r + a - s), t.lineTo(e, r + s), t.quadraticCurveTo(e, r, e + s, r), t.closePath();
}
Lu.getTextAngle = function(t, e) {
  var r, n = t._private, a = n.rscratch, i = e ? e + "-" : "", s = t.pstyle(i + "text-rotation");
  if (s.strValue === "autorotate") {
    var o = Ta(a, "labelAngle", e);
    r = t.isEdge() ? o : 0;
  } else s.strValue === "none" ? r = 0 : r = s.pfValue;
  return r;
};
Lu.drawText = function(t, e, r) {
  var n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !0, a = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0, i = e._private, s = i.rscratch, o = a ? e.effectiveOpacity() : 1;
  if (!(a && (o === 0 || e.pstyle("text-opacity").value === 0))) {
    r === "main" && (r = null);
    var l = Ta(s, "labelX", r), u = Ta(s, "labelY", r), c, f, h = this.getLabelText(e, r);
    if (h != null && h !== "" && !isNaN(l) && !isNaN(u)) {
      this.setupTextStyle(t, e, a);
      var d = r ? r + "-" : "", p = Ta(s, "labelWidth", r), g = Ta(s, "labelHeight", r), v = e.pstyle(d + "text-margin-x").pfValue, m = e.pstyle(d + "text-margin-y").pfValue, b = e.isEdge(), y = e.pstyle("text-halign").value, x = e.pstyle("text-valign").value;
      b && (y = "center", x = "center"), l += v, u += m;
      var E;
      switch (n ? E = this.getTextAngle(e, r) : E = 0, E !== 0 && (c = l, f = u, t.translate(c, f), t.rotate(E), l = 0, u = 0), x) {
        case "top":
          break;
        case "center":
          u += g / 2;
          break;
        case "bottom":
          u += g;
          break;
      }
      var S = e.pstyle("text-background-opacity").value, w = e.pstyle("text-border-opacity").value, C = e.pstyle("text-border-width").pfValue, k = e.pstyle("text-background-padding").pfValue, N = e.pstyle("text-background-shape").strValue, R = N === "round-rectangle" || N === "roundrectangle", _ = N === "circle", O = 2;
      if (S > 0 || C > 0 && w > 0) {
        var T = t.fillStyle, L = t.strokeStyle, M = t.lineWidth, A = e.pstyle("text-background-color").value, I = e.pstyle("text-border-color").value, D = e.pstyle("text-border-style").value, F = S > 0, B = C > 0 && w > 0, G = l - k;
        switch (y) {
          case "left":
            G -= p;
            break;
          case "center":
            G -= p / 2;
            break;
        }
        var H = u - g - k, K = p + 2 * k, j = g + 2 * k;
        if (F && (t.fillStyle = "rgba(".concat(A[0], ",").concat(A[1], ",").concat(A[2], ",").concat(S * o, ")")), B && (t.strokeStyle = "rgba(".concat(I[0], ",").concat(I[1], ",").concat(I[2], ",").concat(w * o, ")"), t.lineWidth = C, t.setLineDash))
          switch (D) {
            case "dotted":
              t.setLineDash([1, 1]);
              break;
            case "dashed":
              t.setLineDash([4, 2]);
              break;
            case "double":
              t.lineWidth = C / 4, t.setLineDash([]);
              break;
            case "solid":
            default:
              t.setLineDash([]);
              break;
          }
        if (R ? (t.beginPath(), wL(t, G, H, K, j, O)) : _ ? (t.beginPath(), T5e(t, G, H, K, j)) : (t.beginPath(), t.rect(G, H, K, j)), F && t.fill(), B && t.stroke(), B && D === "double") {
          var Z = C / 2;
          t.beginPath(), R ? wL(t, G + Z, H + Z, K - 2 * Z, j - 2 * Z, O) : t.rect(G + Z, H + Z, K - 2 * Z, j - 2 * Z), t.stroke();
        }
        t.fillStyle = T, t.strokeStyle = L, t.lineWidth = M, t.setLineDash && t.setLineDash([]);
      }
      var te = 2 * e.pstyle("text-outline-width").pfValue;
      if (te > 0 && (t.lineWidth = te), e.pstyle("text-wrap").value === "wrap") {
        var ne = Ta(s, "labelWrapCachedLines", r), V = Ta(s, "labelLineHeight", r), q = p / 2, X = this.getLabelJustification(e);
        switch (X === "auto" || (y === "left" ? X === "left" ? l += -p : X === "center" && (l += -q) : y === "center" ? X === "left" ? l += -q : X === "right" && (l += q) : y === "right" && (X === "center" ? l += q : X === "right" && (l += p))), x) {
          case "top":
            u -= (ne.length - 1) * V;
            break;
          case "center":
          case "bottom":
            u -= (ne.length - 1) * V;
            break;
        }
        for (var W = 0; W < ne.length; W++)
          te > 0 && t.strokeText(ne[W], l, u), t.fillText(ne[W], l, u), u += V;
      } else
        te > 0 && t.strokeText(h, l, u), t.fillText(h, l, u);
      E !== 0 && (t.rotate(-E), t.translate(-c, -f));
    }
  }
};
var gl = {};
gl.drawNode = function(t, e, r) {
  var n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !0, a = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0, i = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : !0, s = this, o, l, u = e._private, c = u.rscratch, f = e.position();
  if (!(!tt(f.x) || !tt(f.y)) && !(i && !e.visible())) {
    var h = i ? e.effectiveOpacity() : 1, d = s.usePaths(), p, g = !1, v = e.padding();
    o = e.width() + 2 * v, l = e.height() + 2 * v;
    var m;
    r && (m = r, t.translate(-m.x1, -m.y1));
    for (var b = e.pstyle("background-image"), y = b.value, x = new Array(y.length), E = new Array(y.length), S = 0, w = 0; w < y.length; w++) {
      var C = y[w], k = x[w] = C != null && C !== "none";
      if (k) {
        var N = e.cy().style().getIndexedStyle(e, "background-image-crossorigin", "value", w);
        S++, E[w] = s.getCachedImage(C, N, function() {
          u.backgroundTimestamp = Date.now(), e.emitAndNotify("background");
        });
      }
    }
    var R = e.pstyle("background-blacken").value, _ = e.pstyle("border-width").pfValue, O = e.pstyle("background-opacity").value * h, T = e.pstyle("border-color").value, L = e.pstyle("border-style").value, M = e.pstyle("border-join").value, A = e.pstyle("border-cap").value, I = e.pstyle("border-position").value, D = e.pstyle("border-dash-pattern").pfValue, F = e.pstyle("border-dash-offset").pfValue, B = e.pstyle("border-opacity").value * h, G = e.pstyle("outline-width").pfValue, H = e.pstyle("outline-color").value, K = e.pstyle("outline-style").value, j = e.pstyle("outline-opacity").value * h, Z = e.pstyle("outline-offset").value, te = e.pstyle("corner-radius").value;
    te !== "auto" && (te = e.pstyle("corner-radius").pfValue);
    var ne = function() {
      var je = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : O;
      s.eleFillStyle(t, e, je);
    }, V = function() {
      var je = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : B;
      s.colorStrokeStyle(t, T[0], T[1], T[2], je);
    }, q = function() {
      var je = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : j;
      s.colorStrokeStyle(t, H[0], H[1], H[2], je);
    }, X = function(je, ae, z, Q) {
      var se = s.nodePathCache = s.nodePathCache || [], oe = $B(z === "polygon" ? z + "," + Q.join(",") : z, "" + ae, "" + je, "" + te), he = se[oe], Le, ge = !1;
      return he != null ? (Le = he, ge = !0, c.pathCache = Le) : (Le = new Path2D(), se[oe] = c.pathCache = Le), {
        path: Le,
        cacheHit: ge
      };
    }, W = e.pstyle("shape").strValue, ue = e.pstyle("shape-polygon-points").pfValue;
    if (d) {
      t.translate(f.x, f.y);
      var J = X(o, l, W, ue);
      p = J.path, g = J.cacheHit;
    }
    var Ce = function() {
      if (!g) {
        var je = f;
        d && (je = {
          x: 0,
          y: 0
        }), s.nodeShapes[s.getNodeShape(e)].draw(p || t, je.x, je.y, o, l, te, c);
      }
      d ? t.fill(p) : t.fill();
    }, Ee = function() {
      for (var je = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : h, ae = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, z = u.backgrounding, Q = 0, se = 0; se < E.length; se++) {
        var oe = e.cy().style().getIndexedStyle(e, "background-image-containment", "value", se);
        if (ae && oe === "over" || !ae && oe === "inside") {
          Q++;
          continue;
        }
        x[se] && E[se].complete && !E[se].error && (Q++, s.drawInscribedImage(t, E[se], e, se, je));
      }
      u.backgrounding = Q !== S, z !== u.backgrounding && e.updateStyle(!1);
    }, Te = function() {
      var je = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, ae = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : h;
      s.hasPie(e) && (s.drawPie(t, e, ae), je && (d || s.nodeShapes[s.getNodeShape(e)].draw(t, f.x, f.y, o, l, te, c)));
    }, me = function() {
      var je = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, ae = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : h;
      s.hasStripe(e) && (t.save(), d ? t.clip(c.pathCache) : (s.nodeShapes[s.getNodeShape(e)].draw(t, f.x, f.y, o, l, te, c), t.clip()), s.drawStripe(t, e, ae), t.restore(), je && (d || s.nodeShapes[s.getNodeShape(e)].draw(t, f.x, f.y, o, l, te, c)));
    }, we = function() {
      var je = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : h, ae = (R > 0 ? R : -R) * je, z = R > 0 ? 0 : 255;
      R !== 0 && (s.colorFillStyle(t, z, z, z, ae), d ? t.fill(p) : t.fill());
    }, Ae = function() {
      if (_ > 0) {
        if (t.lineWidth = _, t.lineCap = A, t.lineJoin = M, t.setLineDash)
          switch (L) {
            case "dotted":
              t.setLineDash([1, 1]);
              break;
            case "dashed":
              t.setLineDash(D), t.lineDashOffset = F;
              break;
            case "solid":
            case "double":
              t.setLineDash([]);
              break;
          }
        if (I !== "center") {
          if (t.save(), t.lineWidth *= 2, I === "inside")
            d ? t.clip(p) : t.clip();
          else {
            var je = new Path2D();
            je.rect(-o / 2 - _, -l / 2 - _, o + 2 * _, l + 2 * _), je.addPath(p), t.clip(je, "evenodd");
          }
          d ? t.stroke(p) : t.stroke(), t.restore();
        } else
          d ? t.stroke(p) : t.stroke();
        if (L === "double") {
          t.lineWidth = _ / 3;
          var ae = t.globalCompositeOperation;
          t.globalCompositeOperation = "destination-out", d ? t.stroke(p) : t.stroke(), t.globalCompositeOperation = ae;
        }
        t.setLineDash && t.setLineDash([]);
      }
    }, Ne = function() {
      if (G > 0) {
        if (t.lineWidth = G, t.lineCap = "butt", t.setLineDash)
          switch (K) {
            case "dotted":
              t.setLineDash([1, 1]);
              break;
            case "dashed":
              t.setLineDash([4, 2]);
              break;
            case "solid":
            case "double":
              t.setLineDash([]);
              break;
          }
        var je = f;
        d && (je = {
          x: 0,
          y: 0
        });
        var ae = s.getNodeShape(e), z = _;
        I === "inside" && (z = 0), I === "outside" && (z *= 2);
        var Q = (o + z + (G + Z)) / o, se = (l + z + (G + Z)) / l, oe = o * Q, he = l * se, Le = s.nodeShapes[ae].points, ge;
        if (d) {
          var Se = X(oe, he, ae, Le);
          ge = Se.path;
        }
        if (ae === "ellipse")
          s.drawEllipsePath(ge || t, je.x, je.y, oe, he);
        else if (["round-diamond", "round-heptagon", "round-hexagon", "round-octagon", "round-pentagon", "round-polygon", "round-triangle", "round-tag"].includes(ae)) {
          var xe = 0, $e = 0, Ze = 0;
          ae === "round-diamond" ? xe = (z + Z + G) * 1.4 : ae === "round-heptagon" ? (xe = (z + Z + G) * 1.075, Ze = -(z / 2 + Z + G) / 35) : ae === "round-hexagon" ? xe = (z + Z + G) * 1.12 : ae === "round-pentagon" ? (xe = (z + Z + G) * 1.13, Ze = -(z / 2 + Z + G) / 15) : ae === "round-tag" ? (xe = (z + Z + G) * 1.12, $e = (z / 2 + G + Z) * 0.07) : ae === "round-triangle" && (xe = (z + Z + G) * (Math.PI / 2), Ze = -(z + Z / 2 + G) / Math.PI), xe !== 0 && (Q = (o + xe) / o, oe = o * Q, ["round-hexagon", "round-tag"].includes(ae) || (se = (l + xe) / l, he = l * se)), te = te === "auto" ? jB(oe, he) : te;
          for (var We = oe / 2, He = he / 2, Pe = te + (z + G + Z) / 2, De = new Array(Le.length / 2), mt = new Array(Le.length / 2), Ke = 0; Ke < Le.length / 2; Ke++)
            De[Ke] = {
              x: je.x + $e + We * Le[Ke * 2],
              y: je.y + Ze + He * Le[Ke * 2 + 1]
            };
          var et, Pt, vt, nt, Dt = De.length;
          for (Pt = De[Dt - 1], et = 0; et < Dt; et++)
            vt = De[et % Dt], nt = De[(et + 1) % Dt], mt[et] = E3(Pt, vt, nt, Pe), Pt = vt, vt = nt;
          s.drawRoundPolygonPath(ge || t, je.x + $e, je.y + Ze, o * Q, l * se, Le, mt);
        } else if (["roundrectangle", "round-rectangle"].includes(ae))
          te = te === "auto" ? Xo(oe, he) : te, s.drawRoundRectanglePath(ge || t, je.x, je.y, oe, he, te + (z + G + Z) / 2);
        else if (["cutrectangle", "cut-rectangle"].includes(ae))
          te = te === "auto" ? f3() : te, s.drawCutRectanglePath(ge || t, je.x, je.y, oe, he, null, te + (z + G + Z) / 4);
        else if (["bottomroundrectangle", "bottom-round-rectangle"].includes(ae))
          te = te === "auto" ? Xo(oe, he) : te, s.drawBottomRoundRectanglePath(ge || t, je.x, je.y, oe, he, te + (z + G + Z) / 2);
        else if (ae === "barrel")
          s.drawBarrelPath(ge || t, je.x, je.y, oe, he);
        else if (ae.startsWith("polygon") || ["rhomboid", "right-rhomboid", "round-tag", "tag", "vee"].includes(ae)) {
          var Gt = (z + G + Z) / o;
          Le = Bm(zm(Le, Gt)), s.drawPolygonPath(ge || t, je.x, je.y, o, l, Le);
        } else {
          var yt = (z + G + Z) / o;
          Le = Bm(zm(Le, -yt)), s.drawPolygonPath(ge || t, je.x, je.y, o, l, Le);
        }
        if (d ? t.stroke(ge) : t.stroke(), K === "double") {
          t.lineWidth = z / 3;
          var ee = t.globalCompositeOperation;
          t.globalCompositeOperation = "destination-out", d ? t.stroke(ge) : t.stroke(), t.globalCompositeOperation = ee;
        }
        t.setLineDash && t.setLineDash([]);
      }
    }, Ie = function() {
      a && s.drawNodeOverlay(t, e, f, o, l);
    }, Me = function() {
      a && s.drawNodeUnderlay(t, e, f, o, l);
    }, _e = function() {
      s.drawElementText(t, e, null, n);
    }, Be = e.pstyle("ghost").value === "yes";
    if (Be) {
      var st = e.pstyle("ghost-offset-x").pfValue, ct = e.pstyle("ghost-offset-y").pfValue, dt = e.pstyle("ghost-opacity").value, ft = dt * h;
      t.translate(st, ct), q(), Ne(), ne(dt * O), Ce(), Ee(ft, !0), V(dt * B), Ae(), Te(R !== 0 || _ !== 0), me(R !== 0 || _ !== 0), Ee(ft, !1), we(ft), t.translate(-st, -ct);
    }
    d && t.translate(-f.x, -f.y), Me(), d && t.translate(f.x, f.y), q(), Ne(), ne(), Ce(), Ee(h, !0), V(), Ae(), Te(R !== 0 || _ !== 0), me(R !== 0 || _ !== 0), Ee(h, !1), we(), d && t.translate(-f.x, -f.y), _e(), Ie(), r && t.translate(m.x1, m.y1);
  }
};
var Jz = function(e) {
  if (!["overlay", "underlay"].includes(e))
    throw new Error("Invalid state");
  return function(r, n, a, i, s) {
    var o = this;
    if (n.visible()) {
      var l = n.pstyle("".concat(e, "-padding")).pfValue, u = n.pstyle("".concat(e, "-opacity")).value, c = n.pstyle("".concat(e, "-color")).value, f = n.pstyle("".concat(e, "-shape")).value, h = n.pstyle("".concat(e, "-corner-radius")).value;
      if (u > 0) {
        if (a = a || n.position(), i == null || s == null) {
          var d = n.padding();
          i = n.width() + 2 * d, s = n.height() + 2 * d;
        }
        o.colorFillStyle(r, c[0], c[1], c[2], u), o.nodeShapes[f].draw(r, a.x, a.y, i + l * 2, s + l * 2, h), r.fill();
      }
    }
  };
};
gl.drawNodeOverlay = Jz("overlay");
gl.drawNodeUnderlay = Jz("underlay");
gl.hasPie = function(t) {
  return t = t[0], t._private.hasPie;
};
gl.hasStripe = function(t) {
  return t = t[0], t._private.hasStripe;
};
gl.drawPie = function(t, e, r, n) {
  e = e[0], n = n || e.position();
  var a = e.cy().style(), i = e.pstyle("pie-size"), s = e.pstyle("pie-hole"), o = e.pstyle("pie-start-angle").pfValue, l = n.x, u = n.y, c = e.width(), f = e.height(), h = Math.min(c, f) / 2, d, p = 0, g = this.usePaths();
  if (g && (l = 0, u = 0), i.units === "%" ? h = h * i.pfValue : i.pfValue !== void 0 && (h = i.pfValue / 2), s.units === "%" ? d = h * s.pfValue : s.pfValue !== void 0 && (d = s.pfValue / 2), !(d >= h))
    for (var v = 1; v <= a.pieBackgroundN; v++) {
      var m = e.pstyle("pie-" + v + "-background-size").value, b = e.pstyle("pie-" + v + "-background-color").value, y = e.pstyle("pie-" + v + "-background-opacity").value * r, x = m / 100;
      x + p > 1 && (x = 1 - p);
      var E = 1.5 * Math.PI + 2 * Math.PI * p;
      E += o;
      var S = 2 * Math.PI * x, w = E + S;
      m === 0 || p >= 1 || p + x > 1 || (d === 0 ? (t.beginPath(), t.moveTo(l, u), t.arc(l, u, h, E, w), t.closePath()) : (t.beginPath(), t.arc(l, u, h, E, w), t.arc(l, u, d, w, E, !0), t.closePath()), this.colorFillStyle(t, b[0], b[1], b[2], y), t.fill(), p += x);
    }
};
gl.drawStripe = function(t, e, r, n) {
  e = e[0], n = n || e.position();
  var a = e.cy().style(), i = n.x, s = n.y, o = e.width(), l = e.height(), u = 0, c = this.usePaths();
  t.save();
  var f = e.pstyle("stripe-direction").value, h = e.pstyle("stripe-size");
  switch (f) {
    case "vertical":
      break;
    case "righward":
      t.rotate(-Math.PI / 2);
      break;
  }
  var d = o, p = l;
  h.units === "%" ? (d = d * h.pfValue, p = p * h.pfValue) : h.pfValue !== void 0 && (d = h.pfValue, p = h.pfValue), c && (i = 0, s = 0), s -= d / 2, i -= p / 2;
  for (var g = 1; g <= a.stripeBackgroundN; g++) {
    var v = e.pstyle("stripe-" + g + "-background-size").value, m = e.pstyle("stripe-" + g + "-background-color").value, b = e.pstyle("stripe-" + g + "-background-opacity").value * r, y = v / 100;
    y + u > 1 && (y = 1 - u), !(v === 0 || u >= 1 || u + y > 1) && (t.beginPath(), t.rect(i, s + p * u, d, p * y), t.closePath(), this.colorFillStyle(t, m[0], m[1], m[2], b), t.fill(), u += y);
  }
  t.restore();
};
var ba = {}, S5e = 100;
ba.getPixelRatio = function() {
  var t = this.data.contexts[0];
  if (this.forcedPixelRatio != null)
    return this.forcedPixelRatio;
  var e = this.cy.window(), r = t.backingStorePixelRatio || t.webkitBackingStorePixelRatio || t.mozBackingStorePixelRatio || t.msBackingStorePixelRatio || t.oBackingStorePixelRatio || t.backingStorePixelRatio || 1;
  return (e.devicePixelRatio || 1) / r;
};
ba.paintCache = function(t) {
  for (var e = this.paintCaches = this.paintCaches || [], r = !0, n, a = 0; a < e.length; a++)
    if (n = e[a], n.context === t) {
      r = !1;
      break;
    }
  return r && (n = {
    context: t
  }, e.push(n)), n;
};
ba.createGradientStyleFor = function(t, e, r, n, a) {
  var i, s = this.usePaths(), o = r.pstyle(e + "-gradient-stop-colors").value, l = r.pstyle(e + "-gradient-stop-positions").pfValue;
  if (n === "radial-gradient")
    if (r.isEdge()) {
      var u = r.sourceEndpoint(), c = r.targetEndpoint(), f = r.midpoint(), h = su(u, f), d = su(c, f);
      i = t.createRadialGradient(f.x, f.y, 0, f.x, f.y, Math.max(h, d));
    } else {
      var p = s ? {
        x: 0,
        y: 0
      } : r.position(), g = r.paddedWidth(), v = r.paddedHeight();
      i = t.createRadialGradient(p.x, p.y, 0, p.x, p.y, Math.max(g, v));
    }
  else if (r.isEdge()) {
    var m = r.sourceEndpoint(), b = r.targetEndpoint();
    i = t.createLinearGradient(m.x, m.y, b.x, b.y);
  } else {
    var y = s ? {
      x: 0,
      y: 0
    } : r.position(), x = r.paddedWidth(), E = r.paddedHeight(), S = x / 2, w = E / 2, C = r.pstyle("background-gradient-direction").value;
    switch (C) {
      case "to-bottom":
        i = t.createLinearGradient(y.x, y.y - w, y.x, y.y + w);
        break;
      case "to-top":
        i = t.createLinearGradient(y.x, y.y + w, y.x, y.y - w);
        break;
      case "to-left":
        i = t.createLinearGradient(y.x + S, y.y, y.x - S, y.y);
        break;
      case "to-right":
        i = t.createLinearGradient(y.x - S, y.y, y.x + S, y.y);
        break;
      case "to-bottom-right":
      case "to-right-bottom":
        i = t.createLinearGradient(y.x - S, y.y - w, y.x + S, y.y + w);
        break;
      case "to-top-right":
      case "to-right-top":
        i = t.createLinearGradient(y.x - S, y.y + w, y.x + S, y.y - w);
        break;
      case "to-bottom-left":
      case "to-left-bottom":
        i = t.createLinearGradient(y.x + S, y.y - w, y.x - S, y.y + w);
        break;
      case "to-top-left":
      case "to-left-top":
        i = t.createLinearGradient(y.x + S, y.y + w, y.x - S, y.y - w);
        break;
    }
  }
  if (!i) return null;
  for (var k = l.length === o.length, N = o.length, R = 0; R < N; R++)
    i.addColorStop(k ? l[R] : R / (N - 1), "rgba(" + o[R][0] + "," + o[R][1] + "," + o[R][2] + "," + a + ")");
  return i;
};
ba.gradientFillStyle = function(t, e, r, n) {
  var a = this.createGradientStyleFor(t, "background", e, r, n);
  if (!a) return null;
  t.fillStyle = a;
};
ba.colorFillStyle = function(t, e, r, n, a) {
  t.fillStyle = "rgba(" + e + "," + r + "," + n + "," + a + ")";
};
ba.eleFillStyle = function(t, e, r) {
  var n = e.pstyle("background-fill").value;
  if (n === "linear-gradient" || n === "radial-gradient")
    this.gradientFillStyle(t, e, n, r);
  else {
    var a = e.pstyle("background-color").value;
    this.colorFillStyle(t, a[0], a[1], a[2], r);
  }
};
ba.gradientStrokeStyle = function(t, e, r, n) {
  var a = this.createGradientStyleFor(t, "line", e, r, n);
  if (!a) return null;
  t.strokeStyle = a;
};
ba.colorStrokeStyle = function(t, e, r, n, a) {
  t.strokeStyle = "rgba(" + e + "," + r + "," + n + "," + a + ")";
};
ba.eleStrokeStyle = function(t, e, r) {
  var n = e.pstyle("line-fill").value;
  if (n === "linear-gradient" || n === "radial-gradient")
    this.gradientStrokeStyle(t, e, n, r);
  else {
    var a = e.pstyle("line-color").value;
    this.colorStrokeStyle(t, a[0], a[1], a[2], r);
  }
};
ba.matchCanvasSize = function(t) {
  var e = this, r = e.data, n = e.findContainerClientCoords(), a = n[2], i = n[3], s = e.getPixelRatio(), o = e.motionBlurPxRatio;
  (t === e.data.bufferCanvases[e.MOTIONBLUR_BUFFER_NODE] || t === e.data.bufferCanvases[e.MOTIONBLUR_BUFFER_DRAG]) && (s = o);
  var l = a * s, u = i * s, c;
  if (!(l === e.canvasWidth && u === e.canvasHeight)) {
    e.fontCaches = null;
    var f = r.canvasContainer;
    f.style.width = a + "px", f.style.height = i + "px";
    for (var h = 0; h < e.CANVAS_LAYERS; h++)
      c = r.canvases[h], c.width = l, c.height = u, c.style.width = a + "px", c.style.height = i + "px";
    for (var h = 0; h < e.BUFFER_COUNT; h++)
      c = r.bufferCanvases[h], c.width = l, c.height = u, c.style.width = a + "px", c.style.height = i + "px";
    e.textureMult = 1, s <= 1 && (c = r.bufferCanvases[e.TEXTURE_BUFFER], e.textureMult = 2, c.width = l * e.textureMult, c.height = u * e.textureMult), e.canvasWidth = l, e.canvasHeight = u, e.pixelRatio = s;
  }
};
ba.renderTo = function(t, e, r, n) {
  this.render({
    forcedContext: t,
    forcedZoom: e,
    forcedPan: r,
    drawAllLayers: !0,
    forcedPxRatio: n
  });
};
ba.clearCanvas = function() {
  var t = this, e = t.data;
  function r(n) {
    n.clearRect(0, 0, t.canvasWidth, t.canvasHeight);
  }
  r(e.contexts[t.NODE]), r(e.contexts[t.DRAG]);
};
ba.render = function(t) {
  var e = this;
  t = t || GB();
  var r = e.cy, n = t.forcedContext, a = t.drawAllLayers, i = t.drawOnlyNodeLayer, s = t.forcedZoom, o = t.forcedPan, l = t.forcedPxRatio === void 0 ? this.getPixelRatio() : t.forcedPxRatio, u = e.data, c = u.canvasNeedsRedraw, f = e.textureOnViewport && !n && (e.pinching || e.hoverData.dragging || e.swipePanning || e.data.wheelZooming), h = t.motionBlur !== void 0 ? t.motionBlur : e.motionBlur, d = e.motionBlurPxRatio, p = r.hasCompoundNodes(), g = e.hoverData.draggingEles, v = !!(e.hoverData.selecting || e.touchData.selecting);
  h = h && !n && e.motionBlurEnabled && !v;
  var m = h;
  n || (e.prevPxRatio !== l && (e.invalidateContainerClientCoordsCache(), e.matchCanvasSize(e.container), e.redrawHint("eles", !0), e.redrawHint("drag", !0)), e.prevPxRatio = l), !n && e.motionBlurTimeout && clearTimeout(e.motionBlurTimeout), h && (e.mbFrames == null && (e.mbFrames = 0), e.mbFrames++, e.mbFrames < 3 && (m = !1), e.mbFrames > e.minMbLowQualFrames && (e.motionBlurPxRatio = e.mbPxRBlurry)), e.clearingMotionBlur && (e.motionBlurPxRatio = 1), e.textureDrawLastFrame && !f && (c[e.NODE] = !0, c[e.SELECT_BOX] = !0);
  var b = r.style(), y = r.zoom(), x = s !== void 0 ? s : y, E = r.pan(), S = {
    x: E.x,
    y: E.y
  }, w = {
    zoom: y,
    pan: {
      x: E.x,
      y: E.y
    }
  }, C = e.prevViewport, k = C === void 0 || w.zoom !== C.zoom || w.pan.x !== C.pan.x || w.pan.y !== C.pan.y;
  !k && !(g && !p) && (e.motionBlurPxRatio = 1), o && (S = o), x *= l, S.x *= l, S.y *= l;
  var N = e.getCachedZSortedEles();
  function R(V, q, X, W, ue) {
    var J = V.globalCompositeOperation;
    V.globalCompositeOperation = "destination-out", e.colorFillStyle(V, 255, 255, 255, e.motionBlurTransparency), V.fillRect(q, X, W, ue), V.globalCompositeOperation = J;
  }
  function _(V, q) {
    var X, W, ue, J;
    !e.clearingMotionBlur && (V === u.bufferContexts[e.MOTIONBLUR_BUFFER_NODE] || V === u.bufferContexts[e.MOTIONBLUR_BUFFER_DRAG]) ? (X = {
      x: E.x * d,
      y: E.y * d
    }, W = y * d, ue = e.canvasWidth * d, J = e.canvasHeight * d) : (X = S, W = x, ue = e.canvasWidth, J = e.canvasHeight), V.setTransform(1, 0, 0, 1, 0, 0), q === "motionBlur" ? R(V, 0, 0, ue, J) : !n && (q === void 0 || q) && V.clearRect(0, 0, ue, J), a || (V.translate(X.x, X.y), V.scale(W, W)), o && V.translate(o.x, o.y), s && V.scale(s, s);
  }
  if (f || (e.textureDrawLastFrame = !1), f) {
    if (e.textureDrawLastFrame = !0, !e.textureCache) {
      e.textureCache = {}, e.textureCache.bb = r.mutableElements().boundingBox(), e.textureCache.texture = e.data.bufferCanvases[e.TEXTURE_BUFFER];
      var O = e.data.bufferContexts[e.TEXTURE_BUFFER];
      O.setTransform(1, 0, 0, 1, 0, 0), O.clearRect(0, 0, e.canvasWidth * e.textureMult, e.canvasHeight * e.textureMult), e.render({
        forcedContext: O,
        drawOnlyNodeLayer: !0,
        forcedPxRatio: l * e.textureMult
      });
      var w = e.textureCache.viewport = {
        zoom: r.zoom(),
        pan: r.pan(),
        width: e.canvasWidth,
        height: e.canvasHeight
      };
      w.mpan = {
        x: (0 - w.pan.x) / w.zoom,
        y: (0 - w.pan.y) / w.zoom
      };
    }
    c[e.DRAG] = !1, c[e.NODE] = !1;
    var T = u.contexts[e.NODE], L = e.textureCache.texture, w = e.textureCache.viewport;
    T.setTransform(1, 0, 0, 1, 0, 0), h ? R(T, 0, 0, w.width, w.height) : T.clearRect(0, 0, w.width, w.height);
    var M = b.core("outside-texture-bg-color").value, A = b.core("outside-texture-bg-opacity").value;
    e.colorFillStyle(T, M[0], M[1], M[2], A), T.fillRect(0, 0, w.width, w.height);
    var y = r.zoom();
    _(T, !1), T.clearRect(w.mpan.x, w.mpan.y, w.width / w.zoom / l, w.height / w.zoom / l), T.drawImage(L, w.mpan.x, w.mpan.y, w.width / w.zoom / l, w.height / w.zoom / l);
  } else e.textureOnViewport && !n && (e.textureCache = null);
  var I = r.extent(), D = e.pinching || e.hoverData.dragging || e.swipePanning || e.data.wheelZooming || e.hoverData.draggingEles || e.cy.animated(), F = e.hideEdgesOnViewport && D, B = [];
  if (B[e.NODE] = !c[e.NODE] && h && !e.clearedForMotionBlur[e.NODE] || e.clearingMotionBlur, B[e.NODE] && (e.clearedForMotionBlur[e.NODE] = !0), B[e.DRAG] = !c[e.DRAG] && h && !e.clearedForMotionBlur[e.DRAG] || e.clearingMotionBlur, B[e.DRAG] && (e.clearedForMotionBlur[e.DRAG] = !0), c[e.NODE] || a || i || B[e.NODE]) {
    var G = h && !B[e.NODE] && d !== 1, T = n || (G ? e.data.bufferContexts[e.MOTIONBLUR_BUFFER_NODE] : u.contexts[e.NODE]), H = h && !G ? "motionBlur" : void 0;
    _(T, H), F ? e.drawCachedNodes(T, N.nondrag, l, I) : e.drawLayeredElements(T, N.nondrag, l, I), e.debug && e.drawDebugPoints(T, N.nondrag), !a && !h && (c[e.NODE] = !1);
  }
  if (!i && (c[e.DRAG] || a || B[e.DRAG])) {
    var G = h && !B[e.DRAG] && d !== 1, T = n || (G ? e.data.bufferContexts[e.MOTIONBLUR_BUFFER_DRAG] : u.contexts[e.DRAG]);
    _(T, h && !G ? "motionBlur" : void 0), F ? e.drawCachedNodes(T, N.drag, l, I) : e.drawCachedElements(T, N.drag, l, I), e.debug && e.drawDebugPoints(T, N.drag), !a && !h && (c[e.DRAG] = !1);
  }
  if (this.drawSelectionRectangle(t, _), h && d !== 1) {
    var K = u.contexts[e.NODE], j = e.data.bufferCanvases[e.MOTIONBLUR_BUFFER_NODE], Z = u.contexts[e.DRAG], te = e.data.bufferCanvases[e.MOTIONBLUR_BUFFER_DRAG], ne = function(q, X, W) {
      q.setTransform(1, 0, 0, 1, 0, 0), W || !m ? q.clearRect(0, 0, e.canvasWidth, e.canvasHeight) : R(q, 0, 0, e.canvasWidth, e.canvasHeight);
      var ue = d;
      q.drawImage(
        X,
        // img
        0,
        0,
        // sx, sy
        e.canvasWidth * ue,
        e.canvasHeight * ue,
        // sw, sh
        0,
        0,
        // x, y
        e.canvasWidth,
        e.canvasHeight
        // w, h
      );
    };
    (c[e.NODE] || B[e.NODE]) && (ne(K, j, B[e.NODE]), c[e.NODE] = !1), (c[e.DRAG] || B[e.DRAG]) && (ne(Z, te, B[e.DRAG]), c[e.DRAG] = !1);
  }
  e.prevViewport = w, e.clearingMotionBlur && (e.clearingMotionBlur = !1, e.motionBlurCleared = !0, e.motionBlur = !0), h && (e.motionBlurTimeout = setTimeout(function() {
    e.motionBlurTimeout = null, e.clearedForMotionBlur[e.NODE] = !1, e.clearedForMotionBlur[e.DRAG] = !1, e.motionBlur = !1, e.clearingMotionBlur = !f, e.mbFrames = 0, c[e.NODE] = !0, c[e.DRAG] = !0, e.redraw();
  }, S5e)), n || r.emit("render");
};
var ph;
ba.drawSelectionRectangle = function(t, e) {
  var r = this, n = r.cy, a = r.data, i = n.style(), s = t.drawOnlyNodeLayer, o = t.drawAllLayers, l = a.canvasNeedsRedraw, u = t.forcedContext;
  if (r.showFps || !s && l[r.SELECT_BOX] && !o) {
    var c = u || a.contexts[r.SELECT_BOX];
    if (e(c), r.selection[4] == 1 && (r.hoverData.selecting || r.touchData.selecting)) {
      var f = r.cy.zoom(), h = i.core("selection-box-border-width").value / f;
      c.lineWidth = h, c.fillStyle = "rgba(" + i.core("selection-box-color").value[0] + "," + i.core("selection-box-color").value[1] + "," + i.core("selection-box-color").value[2] + "," + i.core("selection-box-opacity").value + ")", c.fillRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]), h > 0 && (c.strokeStyle = "rgba(" + i.core("selection-box-border-color").value[0] + "," + i.core("selection-box-border-color").value[1] + "," + i.core("selection-box-border-color").value[2] + "," + i.core("selection-box-opacity").value + ")", c.strokeRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]));
    }
    if (a.bgActivePosistion && !r.hoverData.selecting) {
      var f = r.cy.zoom(), d = a.bgActivePosistion;
      c.fillStyle = "rgba(" + i.core("active-bg-color").value[0] + "," + i.core("active-bg-color").value[1] + "," + i.core("active-bg-color").value[2] + "," + i.core("active-bg-opacity").value + ")", c.beginPath(), c.arc(d.x, d.y, i.core("active-bg-size").pfValue / f, 0, 2 * Math.PI), c.fill();
    }
    var p = r.lastRedrawTime;
    if (r.showFps && p) {
      p = Math.round(p);
      var g = Math.round(1e3 / p), v = "1 frame = " + p + " ms = " + g + " fps";
      if (c.setTransform(1, 0, 0, 1, 0, 0), c.fillStyle = "rgba(255, 0, 0, 0.75)", c.strokeStyle = "rgba(255, 0, 0, 0.75)", c.font = "30px Arial", !ph) {
        var m = c.measureText(v);
        ph = m.actualBoundingBoxAscent;
      }
      c.fillText(v, 0, ph);
      var b = 60;
      c.strokeRect(0, ph + 10, 250, 20), c.fillRect(0, ph + 10, 250 * Math.min(g / b, 1), 20);
    }
    o || (l[r.SELECT_BOX] = !1);
  }
};
function EL(t, e, r) {
  var n = t.createShader(e);
  if (t.shaderSource(n, r), t.compileShader(n), !t.getShaderParameter(n, t.COMPILE_STATUS))
    throw new Error(t.getShaderInfoLog(n));
  return n;
}
function C5e(t, e, r) {
  var n = EL(t, t.VERTEX_SHADER, e), a = EL(t, t.FRAGMENT_SHADER, r), i = t.createProgram();
  if (t.attachShader(i, n), t.attachShader(i, a), t.linkProgram(i), !t.getProgramParameter(i, t.LINK_STATUS))
    throw new Error("Could not initialize shaders");
  return i;
}
function A5e(t, e, r) {
  r === void 0 && (r = e);
  var n = t.makeOffscreenCanvas(e, r), a = n.context = n.getContext("2d");
  return n.clear = function() {
    return a.clearRect(0, 0, n.width, n.height);
  }, n.clear(), n;
}
function C3(t) {
  var e = t.pixelRatio, r = t.cy.zoom(), n = t.cy.pan();
  return {
    zoom: r * e,
    pan: {
      x: n.x * e,
      y: n.y * e
    }
  };
}
function k5e(t) {
  var e = t.pixelRatio, r = t.cy.zoom();
  return r * e;
}
function R5e(t, e, r, n, a) {
  var i = n * r + e.x, s = a * r + e.y;
  return s = Math.round(t.canvasHeight - s), [i, s];
}
function M5e(t) {
  return t.pstyle("background-fill").value !== "solid" || t.pstyle("background-image").strValue !== "none" ? !1 : t.pstyle("border-width").value === 0 || t.pstyle("border-opacity").value === 0 ? !0 : t.pstyle("border-style").value === "solid";
}
function _5e(t, e) {
  if (t.length !== e.length)
    return !1;
  for (var r = 0; r < t.length; r++)
    if (t[r] !== e[r])
      return !1;
  return !0;
}
function Rl(t, e, r) {
  var n = t[0] / 255, a = t[1] / 255, i = t[2] / 255, s = e, o = r || new Array(4);
  return o[0] = n * s, o[1] = a * s, o[2] = i * s, o[3] = s, o;
}
function Xu(t, e) {
  var r = e || new Array(4);
  return r[0] = (t >> 0 & 255) / 255, r[1] = (t >> 8 & 255) / 255, r[2] = (t >> 16 & 255) / 255, r[3] = (t >> 24 & 255) / 255, r;
}
function L5e(t) {
  return t[0] + (t[1] << 8) + (t[2] << 16) + (t[3] << 24);
}
function N5e(t, e) {
  var r = t.createTexture();
  return r.buffer = function(n) {
    t.bindTexture(t.TEXTURE_2D, r), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR_MIPMAP_NEAREST), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, n), t.generateMipmap(t.TEXTURE_2D), t.bindTexture(t.TEXTURE_2D, null);
  }, r.deleteTexture = function() {
    t.deleteTexture(r);
  }, r;
}
function eG(t, e) {
  switch (e) {
    case "float":
      return [1, t.FLOAT, 4];
    case "vec2":
      return [2, t.FLOAT, 4];
    case "vec3":
      return [3, t.FLOAT, 4];
    case "vec4":
      return [4, t.FLOAT, 4];
    case "int":
      return [1, t.INT, 4];
    case "ivec2":
      return [2, t.INT, 4];
  }
}
function tG(t, e, r) {
  switch (e) {
    case t.FLOAT:
      return new Float32Array(r);
    case t.INT:
      return new Int32Array(r);
  }
}
function O5e(t, e, r, n, a, i) {
  switch (e) {
    case t.FLOAT:
      return new Float32Array(r.buffer, i * n, a);
    case t.INT:
      return new Int32Array(r.buffer, i * n, a);
  }
}
function I5e(t, e, r, n) {
  var a = eG(t, e), i = ln(a, 2), s = i[0], o = i[1], l = tG(t, o, n), u = t.createBuffer();
  return t.bindBuffer(t.ARRAY_BUFFER, u), t.bufferData(t.ARRAY_BUFFER, l, t.STATIC_DRAW), o === t.FLOAT ? t.vertexAttribPointer(r, s, o, !1, 0, 0) : o === t.INT && t.vertexAttribIPointer(r, s, o, 0, 0), t.enableVertexAttribArray(r), t.bindBuffer(t.ARRAY_BUFFER, null), u;
}
function ns(t, e, r, n) {
  var a = eG(t, r), i = ln(a, 3), s = i[0], o = i[1], l = i[2], u = tG(t, o, e * s), c = s * l, f = t.createBuffer();
  t.bindBuffer(t.ARRAY_BUFFER, f), t.bufferData(t.ARRAY_BUFFER, e * c, t.DYNAMIC_DRAW), t.enableVertexAttribArray(n), o === t.FLOAT ? t.vertexAttribPointer(n, s, o, !1, c, 0) : o === t.INT && t.vertexAttribIPointer(n, s, o, c, 0), t.vertexAttribDivisor(n, 1), t.bindBuffer(t.ARRAY_BUFFER, null);
  for (var h = new Array(e), d = 0; d < e; d++)
    h[d] = O5e(t, o, u, c, s, d);
  return f.dataArray = u, f.stride = c, f.size = s, f.getView = function(p) {
    return h[p];
  }, f.setPoint = function(p, g, v) {
    var m = h[p];
    m[0] = g, m[1] = v;
  }, f.bufferSubData = function(p) {
    t.bindBuffer(t.ARRAY_BUFFER, f), p ? t.bufferSubData(t.ARRAY_BUFFER, 0, u, 0, p * s) : t.bufferSubData(t.ARRAY_BUFFER, 0, u);
  }, f;
}
function P5e(t, e, r) {
  for (var n = 9, a = new Float32Array(e * n), i = new Array(e), s = 0; s < e; s++) {
    var o = s * n * 4;
    i[s] = new Float32Array(a.buffer, o, n);
  }
  var l = t.createBuffer();
  t.bindBuffer(t.ARRAY_BUFFER, l), t.bufferData(t.ARRAY_BUFFER, a.byteLength, t.DYNAMIC_DRAW);
  for (var u = 0; u < 3; u++) {
    var c = r + u;
    t.enableVertexAttribArray(c), t.vertexAttribPointer(c, 3, t.FLOAT, !1, 3 * 12, u * 12), t.vertexAttribDivisor(c, 1);
  }
  return t.bindBuffer(t.ARRAY_BUFFER, null), l.getMatrixView = function(f) {
    return i[f];
  }, l.setData = function(f, h) {
    i[h].set(f, 0);
  }, l.bufferSubData = function() {
    t.bindBuffer(t.ARRAY_BUFFER, l), t.bufferSubData(t.ARRAY_BUFFER, 0, a);
  }, l;
}
function D5e(t) {
  var e = t.createFramebuffer();
  t.bindFramebuffer(t.FRAMEBUFFER, e);
  var r = t.createTexture();
  return t.bindTexture(t.TEXTURE_2D, r), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, r, 0), t.bindFramebuffer(t.FRAMEBUFFER, null), e.setFramebufferAttachmentSizes = function(n, a) {
    t.bindTexture(t.TEXTURE_2D, r), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, n, a, 0, t.RGBA, t.UNSIGNED_BYTE, null);
  }, e;
}
var TL = typeof Float32Array < "u" ? Float32Array : Array;
Math.hypot || (Math.hypot = function() {
  for (var t = 0, e = arguments.length; e--; )
    t += arguments[e] * arguments[e];
  return Math.sqrt(t);
});
function Cw() {
  var t = new TL(9);
  return TL != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[5] = 0, t[6] = 0, t[7] = 0), t[0] = 1, t[4] = 1, t[8] = 1, t;
}
function SL(t) {
  return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;
}
function $5e(t, e, r) {
  var n = e[0], a = e[1], i = e[2], s = e[3], o = e[4], l = e[5], u = e[6], c = e[7], f = e[8], h = r[0], d = r[1], p = r[2], g = r[3], v = r[4], m = r[5], b = r[6], y = r[7], x = r[8];
  return t[0] = h * n + d * s + p * u, t[1] = h * a + d * o + p * c, t[2] = h * i + d * l + p * f, t[3] = g * n + v * s + m * u, t[4] = g * a + v * o + m * c, t[5] = g * i + v * l + m * f, t[6] = b * n + y * s + x * u, t[7] = b * a + y * o + x * c, t[8] = b * i + y * l + x * f, t;
}
function Sv(t, e, r) {
  var n = e[0], a = e[1], i = e[2], s = e[3], o = e[4], l = e[5], u = e[6], c = e[7], f = e[8], h = r[0], d = r[1];
  return t[0] = n, t[1] = a, t[2] = i, t[3] = s, t[4] = o, t[5] = l, t[6] = h * n + d * s + u, t[7] = h * a + d * o + c, t[8] = h * i + d * l + f, t;
}
function CL(t, e, r) {
  var n = e[0], a = e[1], i = e[2], s = e[3], o = e[4], l = e[5], u = e[6], c = e[7], f = e[8], h = Math.sin(r), d = Math.cos(r);
  return t[0] = d * n + h * s, t[1] = d * a + h * o, t[2] = d * i + h * l, t[3] = d * s - h * n, t[4] = d * o - h * a, t[5] = d * l - h * i, t[6] = u, t[7] = c, t[8] = f, t;
}
function O4(t, e, r) {
  var n = r[0], a = r[1];
  return t[0] = n * e[0], t[1] = n * e[1], t[2] = n * e[2], t[3] = a * e[3], t[4] = a * e[4], t[5] = a * e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t;
}
function F5e(t, e, r) {
  return t[0] = 2 / e, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = -2 / r, t[5] = 0, t[6] = -1, t[7] = 1, t[8] = 1, t;
}
var B5e = /* @__PURE__ */ function() {
  function t(e, r, n, a) {
    hl(this, t), this.debugID = Math.floor(Math.random() * 1e4), this.r = e, this.texSize = r, this.texRows = n, this.texHeight = Math.floor(r / n), this.enableWrapping = !0, this.locked = !1, this.texture = null, this.needsBuffer = !0, this.freePointer = {
      x: 0,
      row: 0
    }, this.keyToLocation = /* @__PURE__ */ new Map(), this.canvas = a(e, r, r), this.scratch = a(e, r, this.texHeight, "scratch");
  }
  return dl(t, [{
    key: "lock",
    value: function() {
      this.locked = !0;
    }
  }, {
    key: "getKeys",
    value: function() {
      return new Set(this.keyToLocation.keys());
    }
  }, {
    key: "getScale",
    value: function(r) {
      var n = r.w, a = r.h, i = this.texHeight, s = this.texSize, o = i / a, l = n * o, u = a * o;
      return l > s && (o = s / n, l = n * o, u = a * o), {
        scale: o,
        texW: l,
        texH: u
      };
    }
  }, {
    key: "draw",
    value: function(r, n, a) {
      var i = this;
      if (this.locked) throw new Error("can't draw, atlas is locked");
      var s = this.texSize, o = this.texRows, l = this.texHeight, u = this.getScale(n), c = u.scale, f = u.texW, h = u.texH, d = function(y, x) {
        if (a && x) {
          var E = x.context, S = y.x, w = y.row, C = S, k = l * w;
          E.save(), E.translate(C, k), E.scale(c, c), a(E, n), E.restore();
        }
      }, p = [null, null], g = function() {
        d(i.freePointer, i.canvas), p[0] = {
          x: i.freePointer.x,
          y: i.freePointer.row * l,
          w: f,
          h
        }, p[1] = {
          // create a second location with a width of 0, for convenience
          x: i.freePointer.x + f,
          y: i.freePointer.row * l,
          w: 0,
          h
        }, i.freePointer.x += f, i.freePointer.x == s && (i.freePointer.x = 0, i.freePointer.row++);
      }, v = function() {
        var y = i.scratch, x = i.canvas;
        y.clear(), d({
          x: 0,
          row: 0
        }, y);
        var E = s - i.freePointer.x, S = f - E, w = l;
        {
          var C = i.freePointer.x, k = i.freePointer.row * l, N = E;
          x.context.drawImage(y, 0, 0, N, w, C, k, N, w), p[0] = {
            x: C,
            y: k,
            w: N,
            h
          };
        }
        {
          var R = E, _ = (i.freePointer.row + 1) * l, O = S;
          x && x.context.drawImage(y, R, 0, O, w, 0, _, O, w), p[1] = {
            x: 0,
            y: _,
            w: O,
            h
          };
        }
        i.freePointer.x = S, i.freePointer.row++;
      }, m = function() {
        i.freePointer.x = 0, i.freePointer.row++;
      };
      if (this.freePointer.x + f <= s)
        g();
      else {
        if (this.freePointer.row >= o - 1)
          return !1;
        this.freePointer.x === s ? (m(), g()) : this.enableWrapping ? v() : (m(), g());
      }
      return this.keyToLocation.set(r, p), this.needsBuffer = !0, p;
    }
  }, {
    key: "getOffsets",
    value: function(r) {
      return this.keyToLocation.get(r);
    }
  }, {
    key: "isEmpty",
    value: function() {
      return this.freePointer.x === 0 && this.freePointer.row === 0;
    }
  }, {
    key: "canFit",
    value: function(r) {
      if (this.locked) return !1;
      var n = this.texSize, a = this.texRows, i = this.getScale(r), s = i.texW;
      return this.freePointer.x + s > n ? this.freePointer.row < a - 1 : !0;
    }
    // called on every frame
  }, {
    key: "bufferIfNeeded",
    value: function(r) {
      this.texture || (this.texture = N5e(r, this.debugID)), this.needsBuffer && (this.texture.buffer(this.canvas), this.needsBuffer = !1, this.locked && (this.canvas = null, this.scratch = null));
    }
  }, {
    key: "dispose",
    value: function() {
      this.texture && (this.texture.deleteTexture(), this.texture = null), this.canvas = null, this.scratch = null, this.locked = !0;
    }
  }]);
}(), z5e = /* @__PURE__ */ function() {
  function t(e, r, n, a) {
    hl(this, t), this.r = e, this.texSize = r, this.texRows = n, this.createTextureCanvas = a, this.atlases = [], this.styleKeyToAtlas = /* @__PURE__ */ new Map(), this.markedKeys = /* @__PURE__ */ new Set();
  }
  return dl(t, [{
    key: "getKeys",
    value: function() {
      return new Set(this.styleKeyToAtlas.keys());
    }
  }, {
    key: "_createAtlas",
    value: function() {
      var r = this.r, n = this.texSize, a = this.texRows, i = this.createTextureCanvas;
      return new B5e(r, n, a, i);
    }
  }, {
    key: "_getScratchCanvas",
    value: function() {
      if (!this.scratch) {
        var r = this.r, n = this.texSize, a = this.texRows, i = this.createTextureCanvas, s = Math.floor(n / a);
        this.scratch = i(r, n, s, "scratch");
      }
      return this.scratch;
    }
  }, {
    key: "draw",
    value: function(r, n, a) {
      var i = this.styleKeyToAtlas.get(r);
      return i || (i = this.atlases[this.atlases.length - 1], (!i || !i.canFit(n)) && (i && i.lock(), i = this._createAtlas(), this.atlases.push(i)), i.draw(r, n, a), this.styleKeyToAtlas.set(r, i)), i;
    }
  }, {
    key: "getAtlas",
    value: function(r) {
      return this.styleKeyToAtlas.get(r);
    }
  }, {
    key: "hasAtlas",
    value: function(r) {
      return this.styleKeyToAtlas.has(r);
    }
  }, {
    key: "markKeyForGC",
    value: function(r) {
      this.markedKeys.add(r);
    }
  }, {
    key: "gc",
    value: function() {
      var r = this, n = this.markedKeys;
      if (n.size === 0) {
        console.log("nothing to garbage collect");
        return;
      }
      var a = [], i = /* @__PURE__ */ new Map(), s = null, o = Ca(this.atlases), l;
      try {
        var u = function() {
          var f = l.value, h = f.getKeys(), d = G5e(n, h);
          if (d.size === 0)
            return a.push(f), h.forEach(function(E) {
              return i.set(E, f);
            }), 1;
          s || (s = r._createAtlas(), a.push(s));
          var p = Ca(h), g;
          try {
            for (p.s(); !(g = p.n()).done; ) {
              var v = g.value;
              if (!d.has(v)) {
                var m = f.getOffsets(v), b = ln(m, 2), y = b[0], x = b[1];
                s.canFit({
                  w: y.w + x.w,
                  h: y.h
                }) || (s.lock(), s = r._createAtlas(), a.push(s)), f.canvas && (r._copyTextureToNewAtlas(v, f, s), i.set(v, s));
              }
            }
          } catch (E) {
            p.e(E);
          } finally {
            p.f();
          }
          f.dispose();
        };
        for (o.s(); !(l = o.n()).done; )
          u();
      } catch (c) {
        o.e(c);
      } finally {
        o.f();
      }
      this.atlases = a, this.styleKeyToAtlas = i, this.markedKeys = /* @__PURE__ */ new Set();
    }
  }, {
    key: "_copyTextureToNewAtlas",
    value: function(r, n, a) {
      var i = n.getOffsets(r), s = ln(i, 2), o = s[0], l = s[1];
      if (l.w === 0)
        a.draw(r, o, function(h) {
          h.drawImage(n.canvas, o.x, o.y, o.w, o.h, 0, 0, o.w, o.h);
        });
      else {
        var u = this._getScratchCanvas();
        u.clear(), u.context.drawImage(n.canvas, o.x, o.y, o.w, o.h, 0, 0, o.w, o.h), u.context.drawImage(n.canvas, l.x, l.y, l.w, l.h, o.w, 0, l.w, l.h);
        var c = o.w + l.w, f = o.h;
        a.draw(r, {
          w: c,
          h: f
        }, function(h) {
          h.drawImage(
            u,
            0,
            0,
            c,
            f,
            0,
            0,
            c,
            f
            // the destination context has already been translated to the correct position
          );
        });
      }
    }
  }, {
    key: "getCounts",
    value: function() {
      return {
        keyCount: this.styleKeyToAtlas.size,
        atlasCount: new Set(this.styleKeyToAtlas.values()).size
      };
    }
  }]);
}();
function G5e(t, e) {
  return t.intersection ? t.intersection(e) : new Set(Pm(t).filter(function(r) {
    return e.has(r);
  }));
}
var U5e = /* @__PURE__ */ function() {
  function t(e, r) {
    hl(this, t), this.r = e, this.globalOptions = r, this.atlasSize = r.webglTexSize, this.maxAtlasesPerBatch = r.webglTexPerBatch, this.renderTypes = /* @__PURE__ */ new Map(), this.collections = /* @__PURE__ */ new Map(), this.typeAndIdToKey = /* @__PURE__ */ new Map();
  }
  return dl(t, [{
    key: "getAtlasSize",
    value: function() {
      return this.atlasSize;
    }
  }, {
    key: "addAtlasCollection",
    value: function(r, n) {
      var a = this.globalOptions, i = a.webglTexSize, s = a.createTextureCanvas, o = n.texRows, l = this._cacheScratchCanvas(s), u = new z5e(this.r, i, o, l);
      this.collections.set(r, u);
    }
  }, {
    key: "addRenderType",
    value: function(r, n) {
      var a = n.collection;
      if (!this.collections.has(a)) throw new Error("invalid atlas collection name '".concat(a, "'"));
      var i = this.collections.get(a), s = At({
        type: r,
        atlasCollection: i
      }, n);
      this.renderTypes.set(r, s);
    }
  }, {
    key: "getRenderTypeOpts",
    value: function(r) {
      return this.renderTypes.get(r);
    }
  }, {
    key: "getAtlasCollection",
    value: function(r) {
      return this.collections.get(r);
    }
  }, {
    key: "_cacheScratchCanvas",
    value: function(r) {
      var n = -1, a = -1, i = null;
      return function(s, o, l, u) {
        return u ? ((!i || o != n || l != a) && (n = o, a = l, i = r(s, o, l)), i) : r(s, o, l);
      };
    }
  }, {
    key: "_key",
    value: function(r, n) {
      return "".concat(r, "-").concat(n);
    }
    /** Marks textues associated with the element for garbage collection. */
  }, {
    key: "invalidate",
    value: function(r) {
      var n = this, a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = a.forceRedraw, s = i === void 0 ? !1 : i, o = a.filterEle, l = o === void 0 ? function() {
        return !0;
      } : o, u = a.filterType, c = u === void 0 ? function() {
        return !0;
      } : u, f = !1, h = !1, d = Ca(r), p;
      try {
        for (d.s(); !(p = d.n()).done; ) {
          var g = p.value;
          if (l(g)) {
            var v = Ca(this.renderTypes.values()), m;
            try {
              var b = function() {
                var x = m.value, E = x.type;
                if (c(E)) {
                  var S = n.collections.get(x.collection), w = x.getKey(g), C = Array.isArray(w) ? w : [w];
                  if (s)
                    C.forEach(function(_) {
                      return S.markKeyForGC(_);
                    }), h = !0;
                  else {
                    var k = x.getID ? x.getID(g) : g.id(), N = n._key(E, k), R = n.typeAndIdToKey.get(N);
                    R !== void 0 && !_5e(C, R) && (f = !0, n.typeAndIdToKey.delete(N), R.forEach(function(_) {
                      return S.markKeyForGC(_);
                    }));
                  }
                }
              };
              for (v.s(); !(m = v.n()).done; )
                b();
            } catch (y) {
              v.e(y);
            } finally {
              v.f();
            }
          }
        }
      } catch (y) {
        d.e(y);
      } finally {
        d.f();
      }
      return h && (this.gc(), f = !1), f;
    }
    /** Garbage collect */
  }, {
    key: "gc",
    value: function() {
      var r = Ca(this.collections.values()), n;
      try {
        for (r.s(); !(n = r.n()).done; ) {
          var a = n.value;
          a.gc();
        }
      } catch (i) {
        r.e(i);
      } finally {
        r.f();
      }
    }
  }, {
    key: "getOrCreateAtlas",
    value: function(r, n, a, i) {
      var s = this.renderTypes.get(n), o = this.collections.get(s.collection), l = !1, u = o.draw(i, a, function(h) {
        s.drawClipped ? (h.save(), h.beginPath(), h.rect(0, 0, a.w, a.h), h.clip(), s.drawElement(h, r, a, !0, !0), h.restore()) : s.drawElement(h, r, a, !0, !0), l = !0;
      });
      if (l) {
        var c = s.getID ? s.getID(r) : r.id(), f = this._key(n, c);
        this.typeAndIdToKey.has(f) ? this.typeAndIdToKey.get(f).push(i) : this.typeAndIdToKey.set(f, [i]);
      }
      return u;
    }
  }, {
    key: "getAtlasInfo",
    value: function(r, n) {
      var a = this, i = this.renderTypes.get(n), s = i.getKey(r), o = Array.isArray(s) ? s : [s];
      return o.map(function(l) {
        var u = i.getBoundingBox(r, l), c = a.getOrCreateAtlas(r, n, u, l), f = c.getOffsets(l), h = ln(f, 2), d = h[0], p = h[1];
        return {
          atlas: c,
          tex: d,
          tex1: d,
          tex2: p,
          bb: u
        };
      });
    }
  }, {
    key: "getDebugInfo",
    value: function() {
      var r = [], n = Ca(this.collections), a;
      try {
        for (n.s(); !(a = n.n()).done; ) {
          var i = ln(a.value, 2), s = i[0], o = i[1], l = o.getCounts(), u = l.keyCount, c = l.atlasCount;
          r.push({
            type: s,
            keyCount: u,
            atlasCount: c
          });
        }
      } catch (f) {
        n.e(f);
      } finally {
        n.f();
      }
      return r;
    }
  }]);
}(), H5e = /* @__PURE__ */ function() {
  function t(e) {
    hl(this, t), this.globalOptions = e, this.atlasSize = e.webglTexSize, this.maxAtlasesPerBatch = e.webglTexPerBatch, this.batchAtlases = [];
  }
  return dl(t, [{
    key: "getMaxAtlasesPerBatch",
    value: function() {
      return this.maxAtlasesPerBatch;
    }
  }, {
    key: "getAtlasSize",
    value: function() {
      return this.atlasSize;
    }
  }, {
    key: "getIndexArray",
    value: function() {
      return Array.from({
        length: this.maxAtlasesPerBatch
      }, function(r, n) {
        return n;
      });
    }
  }, {
    key: "startBatch",
    value: function() {
      this.batchAtlases = [];
    }
  }, {
    key: "getAtlasCount",
    value: function() {
      return this.batchAtlases.length;
    }
  }, {
    key: "getAtlases",
    value: function() {
      return this.batchAtlases;
    }
  }, {
    key: "canAddToCurrentBatch",
    value: function(r) {
      return this.batchAtlases.length === this.maxAtlasesPerBatch ? this.batchAtlases.includes(r) : !0;
    }
  }, {
    key: "getAtlasIndexForBatch",
    value: function(r) {
      var n = this.batchAtlases.indexOf(r);
      if (n < 0) {
        if (this.batchAtlases.length === this.maxAtlasesPerBatch)
          throw new Error("cannot add more atlases to batch");
        this.batchAtlases.push(r), n = this.batchAtlases.length - 1;
      }
      return n;
    }
  }]);
}(), V5e = `
  float circleSD(vec2 p, float r) {
    return distance(vec2(0), p) - r; // signed distance
  }
`, q5e = `
  float rectangleSD(vec2 p, vec2 b) {
    vec2 d = abs(p)-b;
    return distance(vec2(0),max(d,0.0)) + min(max(d.x,d.y),0.0);
  }
`, W5e = `
  float roundRectangleSD(vec2 p, vec2 b, vec4 cr) {
    cr.xy = (p.x > 0.0) ? cr.xy : cr.zw;
    cr.x  = (p.y > 0.0) ? cr.x  : cr.y;
    vec2 q = abs(p) - b + cr.x;
    return min(max(q.x, q.y), 0.0) + distance(vec2(0), max(q, 0.0)) - cr.x;
  }
`, j5e = `
  float ellipseSD(vec2 p, vec2 ab) {
    p = abs( p ); // symmetry

    // find root with Newton solver
    vec2 q = ab*(p-ab);
    float w = (q.x<q.y)? 1.570796327 : 0.0;
    for( int i=0; i<5; i++ ) {
      vec2 cs = vec2(cos(w),sin(w));
      vec2 u = ab*vec2( cs.x,cs.y);
      vec2 v = ab*vec2(-cs.y,cs.x);
      w = w + dot(p-u,v)/(dot(p-u,u)+dot(v,v));
    }
    
    // compute final point and distance
    float d = length(p-ab*vec2(cos(w),sin(w)));
    
    // return signed distance
    return (dot(p/ab,p/ab)>1.0) ? d : -d;
  }
`, Id = {
  SCREEN: {
    name: "screen",
    screen: !0
  },
  PICKING: {
    name: "picking",
    picking: !0
  }
}, jm = {
  // render the texture just like in RENDER_TARGET.SCREEN mode
  IGNORE: 1,
  // don't render the texture at all
  USE_BB: 2
  // render the bounding box as an opaque rectangle
}, Aw = 0, AL = 1, kL = 2, kw = 3, Ku = 4, xg = 5, gh = 6, vh = 7, Y5e = /* @__PURE__ */ function() {
  function t(e, r, n) {
    hl(this, t), this.r = e, this.gl = r, this.maxInstances = n.webglBatchSize, this.atlasSize = n.webglTexSize, this.bgColor = n.bgColor, this.debug = n.webglDebug, this.batchDebugInfo = [], n.enableWrapping = !0, n.createTextureCanvas = A5e, this.atlasManager = new U5e(e, n), this.batchManager = new H5e(n), this.simpleShapeOptions = /* @__PURE__ */ new Map(), this.program = this._createShaderProgram(Id.SCREEN), this.pickingProgram = this._createShaderProgram(Id.PICKING), this.vao = this._createVAO();
  }
  return dl(t, [{
    key: "addAtlasCollection",
    value: function(r, n) {
      this.atlasManager.addAtlasCollection(r, n);
    }
    /**
     * @typedef { Object } TextureRenderTypeOpts
     * @property { string } collection - name of atlas collection to render textures to
     * @property { function } getKey - returns the "style key" for an element, may be a single value or an array for multi-line lables
     * @property { function } drawElement - uses a canvas renderer to draw the element to the texture atlas
     * @property { boolean  } drawClipped - if true the context will be clipped to the bounding box before drawElement() is called, may affect performance
     * @property { function } getBoundingBox - returns the bounding box for an element
     * @property { function } getRotation
     * @property { function } getRotationPoint
     * @property { function } getRotationOffset
     * @property { function } isVisible - an extra check for visibility in addition to ele.visible()
     * @property { function } getTexPickingMode - returns a value from the TEX_PICKING_MODE enum
     */
    /**
     * @param { string } typeName
     * @param { TextureRenderTypeOpts } opts
     */
  }, {
    key: "addTextureAtlasRenderType",
    value: function(r, n) {
      this.atlasManager.addRenderType(r, n);
    }
    /**
     * @typedef { Object } SimpleShapeRenderTypeOpts
     * @property { function } getBoundingBox - returns the bounding box for an element
     * @property { function } isVisible - this is an extra check for visibility in addition to ele.visible()
     * @property { function } isSimple - check if element is a simple shape, or if it needs to fall back to texture rendering
     * @property { ShapeVisualProperties } shapeProps
     */
    /**
     * @typedef { Object } ShapeVisualProperties
     * @property { string } shape
     * @property { string } color
     * @property { string } opacity
     * @property { string } padding
     * @property { string } radius
     * @property { boolean } border
    */
    /**
     * @param { string } typeName
     * @param { SimpleShapeRenderTypeOpts } opts
     */
  }, {
    key: "addSimpleShapeRenderType",
    value: function(r, n) {
      this.simpleShapeOptions.set(r, n);
    }
    /**
     * Inform the atlasManager when element style keys may have changed.
     * The atlasManager can then mark unused textures for "garbage collection".
     */
  }, {
    key: "invalidate",
    value: function(r) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, a = n.type, i = this.atlasManager;
      return a ? i.invalidate(r, {
        filterType: function(o) {
          return o === a;
        },
        forceRedraw: !0
      }) : i.invalidate(r);
    }
    /**
     * Run texture garbage collection.
     */
  }, {
    key: "gc",
    value: function() {
      this.atlasManager.gc();
    }
  }, {
    key: "_createShaderProgram",
    value: function(r) {
      var n = this.gl, a = `#version 300 es
      precision highp float;

      uniform mat3 uPanZoomMatrix;
      uniform int  uAtlasSize;
      
      // instanced
      in vec2 aPosition; // a vertex from the unit square
      
      in mat3 aTransform; // used to transform verticies, eg into a bounding box
      in int aVertType; // the type of thing we are rendering

      // the z-index that is output when using picking mode
      in vec4 aIndex;
      
      // For textures
      in int aAtlasId; // which shader unit/atlas to use
      in vec4 aTex; // x/y/w/h of texture in atlas

      // for edges
      in vec4 aPointAPointB;
      in vec4 aPointCPointD;
      in vec2 aLineWidth; // also used for node border width

      // simple shapes
      in vec4 aCornerRadius; // for round-rectangle [top-right, bottom-right, top-left, bottom-left]
      in vec4 aColor; // also used for edges
      in vec4 aBorderColor; // aLineWidth is used for border width

      // output values passed to the fragment shader
      out vec2 vTexCoord;
      out vec4 vColor;
      out vec2 vPosition;
      // flat values are not interpolated
      flat out int vAtlasId; 
      flat out int vVertType;
      flat out vec2 vTopRight;
      flat out vec2 vBotLeft;
      flat out vec4 vCornerRadius;
      flat out vec4 vBorderColor;
      flat out vec2 vBorderWidth;
      flat out vec4 vIndex;
      
      void main(void) {
        int vid = gl_VertexID;
        vec2 position = aPosition; // TODO make this a vec3, simplifies some code below

        if(aVertType == `.concat(Aw, `) {
          float texX = aTex.x; // texture coordinates
          float texY = aTex.y;
          float texW = aTex.z;
          float texH = aTex.w;

          if(vid == 1 || vid == 2 || vid == 4) {
            texX += texW;
          }
          if(vid == 2 || vid == 4 || vid == 5) {
            texY += texH;
          }

          float d = float(uAtlasSize);
          vTexCoord = vec2(texX / d, texY / d); // tex coords must be between 0 and 1

          gl_Position = vec4(uPanZoomMatrix * aTransform * vec3(position, 1.0), 1.0);
        }
        else if(aVertType == `).concat(Ku, " || aVertType == ").concat(vh, ` 
             || aVertType == `).concat(xg, " || aVertType == ").concat(gh, `) { // simple shapes

          // the bounding box is needed by the fragment shader
          vBotLeft  = (aTransform * vec3(0, 0, 1)).xy; // flat
          vTopRight = (aTransform * vec3(1, 1, 1)).xy; // flat
          vPosition = (aTransform * vec3(position, 1)).xy; // will be interpolated

          // calculations are done in the fragment shader, just pass these along
          vColor = aColor;
          vCornerRadius = aCornerRadius;
          vBorderColor = aBorderColor;
          vBorderWidth = aLineWidth;

          gl_Position = vec4(uPanZoomMatrix * aTransform * vec3(position, 1.0), 1.0);
        }
        else if(aVertType == `).concat(AL, `) {
          vec2 source = aPointAPointB.xy;
          vec2 target = aPointAPointB.zw;

          // adjust the geometry so that the line is centered on the edge
          position.y = position.y - 0.5;

          // stretch the unit square into a long skinny rectangle
          vec2 xBasis = target - source;
          vec2 yBasis = normalize(vec2(-xBasis.y, xBasis.x));
          vec2 point = source + xBasis * position.x + yBasis * aLineWidth[0] * position.y;

          gl_Position = vec4(uPanZoomMatrix * vec3(point, 1.0), 1.0);
          vColor = aColor;
        } 
        else if(aVertType == `).concat(kL, `) {
          vec2 pointA = aPointAPointB.xy;
          vec2 pointB = aPointAPointB.zw;
          vec2 pointC = aPointCPointD.xy;
          vec2 pointD = aPointCPointD.zw;

          // adjust the geometry so that the line is centered on the edge
          position.y = position.y - 0.5;

          vec2 p0, p1, p2, pos;
          if(position.x == 0.0) { // The left side of the unit square
            p0 = pointA;
            p1 = pointB;
            p2 = pointC;
            pos = position;
          } else { // The right side of the unit square, use same approach but flip the geometry upside down
            p0 = pointD;
            p1 = pointC;
            p2 = pointB;
            pos = vec2(0.0, -position.y);
          }

          vec2 p01 = p1 - p0;
          vec2 p12 = p2 - p1;
          vec2 p21 = p1 - p2;

          // Find the normal vector.
          vec2 tangent = normalize(normalize(p12) + normalize(p01));
          vec2 normal = vec2(-tangent.y, tangent.x);

          // Find the vector perpendicular to p0 -> p1.
          vec2 p01Norm = normalize(vec2(-p01.y, p01.x));

          // Determine the bend direction.
          float sigma = sign(dot(p01 + p21, normal));
          float width = aLineWidth[0];

          if(sign(pos.y) == -sigma) {
            // This is an intersecting vertex. Adjust the position so that there's no overlap.
            vec2 point = 0.5 * width * normal * -sigma / dot(normal, p01Norm);
            gl_Position = vec4(uPanZoomMatrix * vec3(p1 + point, 1.0), 1.0);
          } else {
            // This is a non-intersecting vertex. Treat it like a mitre join.
            vec2 point = 0.5 * width * normal * sigma * dot(normal, p01Norm);
            gl_Position = vec4(uPanZoomMatrix * vec3(p1 + point, 1.0), 1.0);
          }

          vColor = aColor;
        } 
        else if(aVertType == `).concat(kw, ` && vid < 3) {
          // massage the first triangle into an edge arrow
          if(vid == 0)
            position = vec2(-0.15, -0.3);
          if(vid == 1)
            position = vec2(  0.0,  0.0);
          if(vid == 2)
            position = vec2( 0.15, -0.3);

          gl_Position = vec4(uPanZoomMatrix * aTransform * vec3(position, 1.0), 1.0);
          vColor = aColor;
        }
        else {
          gl_Position = vec4(2.0, 0.0, 0.0, 1.0); // discard vertex by putting it outside webgl clip space
        }

        vAtlasId = aAtlasId;
        vVertType = aVertType;
        vIndex = aIndex;
      }
    `), i = this.batchManager.getIndexArray(), s = `#version 300 es
      precision highp float;

      // declare texture unit for each texture atlas in the batch
      `.concat(i.map(function(u) {
        return "uniform sampler2D uTexture".concat(u, ";");
      }).join(`
	`), `

      uniform vec4 uBGColor;
      uniform float uZoom;

      in vec2 vTexCoord;
      in vec4 vColor;
      in vec2 vPosition; // model coordinates

      flat in int vAtlasId;
      flat in vec4 vIndex;
      flat in int vVertType;
      flat in vec2 vTopRight;
      flat in vec2 vBotLeft;
      flat in vec4 vCornerRadius;
      flat in vec4 vBorderColor;
      flat in vec2 vBorderWidth;

      out vec4 outColor;

      `).concat(V5e, `
      `).concat(q5e, `
      `).concat(W5e, `
      `).concat(j5e, `

      vec4 blend(vec4 top, vec4 bot) { // blend colors with premultiplied alpha
        return vec4( 
          top.rgb + (bot.rgb * (1.0 - top.a)),
          top.a   + (bot.a   * (1.0 - top.a)) 
        );
      }

      vec4 distInterp(vec4 cA, vec4 cB, float d) { // interpolate color using Signed Distance
        // scale to the zoom level so that borders don't look blurry when zoomed in
        // note 1.5 is an aribitrary value chosen because it looks good
        return mix(cA, cB, 1.0 - smoothstep(0.0, 1.5 / uZoom, abs(d))); 
      }

      void main(void) {
        if(vVertType == `).concat(Aw, `) {
          // look up the texel from the texture unit
          `).concat(i.map(function(u) {
        return "if(vAtlasId == ".concat(u, ") outColor = texture(uTexture").concat(u, ", vTexCoord);");
      }).join(`
	else `), `
        } 
        else if(vVertType == `).concat(kw, `) {
          // mimics how canvas renderer uses context.globalCompositeOperation = 'destination-out';
          outColor = blend(vColor, uBGColor);
          outColor.a = 1.0; // make opaque, masks out line under arrow
        }
        else if(vVertType == `).concat(Ku, ` && vBorderWidth == vec2(0.0)) { // simple rectangle with no border
          outColor = vColor; // unit square is already transformed to the rectangle, nothing else needs to be done
        }
        else if(vVertType == `).concat(Ku, " || vVertType == ").concat(vh, ` 
          || vVertType == `).concat(xg, " || vVertType == ").concat(gh, `) { // use SDF

          float outerBorder = vBorderWidth[0];
          float innerBorder = vBorderWidth[1];
          float borderPadding = outerBorder * 2.0;
          float w = vTopRight.x - vBotLeft.x - borderPadding;
          float h = vTopRight.y - vBotLeft.y - borderPadding;
          vec2 b = vec2(w/2.0, h/2.0); // half width, half height
          vec2 p = vPosition - vec2(vTopRight.x - b[0] - outerBorder, vTopRight.y - b[1] - outerBorder); // translate to center

          float d; // signed distance
          if(vVertType == `).concat(Ku, `) {
            d = rectangleSD(p, b);
          } else if(vVertType == `).concat(vh, ` && w == h) {
            d = circleSD(p, b.x); // faster than ellipse
          } else if(vVertType == `).concat(vh, `) {
            d = ellipseSD(p, b);
          } else {
            d = roundRectangleSD(p, b, vCornerRadius.wzyx);
          }

          // use the distance to interpolate a color to smooth the edges of the shape, doesn't need multisampling
          // we must smooth colors inwards, because we can't change pixels outside the shape's bounding box
          if(d > 0.0) {
            if(d > outerBorder) {
              discard;
            } else {
              outColor = distInterp(vBorderColor, vec4(0), d - outerBorder);
            }
          } else {
            if(d > innerBorder) {
              vec4 outerColor = outerBorder == 0.0 ? vec4(0) : vBorderColor;
              vec4 innerBorderColor = blend(vBorderColor, vColor);
              outColor = distInterp(innerBorderColor, outerColor, d);
            } 
            else {
              vec4 outerColor;
              if(innerBorder == 0.0 && outerBorder == 0.0) {
                outerColor = vec4(0);
              } else if(innerBorder == 0.0) {
                outerColor = vBorderColor;
              } else {
                outerColor = blend(vBorderColor, vColor);
              }
              outColor = distInterp(vColor, outerColor, d - innerBorder);
            }
          }
        }
        else {
          outColor = vColor;
        }

        `).concat(r.picking ? `if(outColor.a == 0.0) discard;
             else outColor = vIndex;` : "", `
      }
    `), o = C5e(n, a, s);
      o.aPosition = n.getAttribLocation(o, "aPosition"), o.aIndex = n.getAttribLocation(o, "aIndex"), o.aVertType = n.getAttribLocation(o, "aVertType"), o.aTransform = n.getAttribLocation(o, "aTransform"), o.aAtlasId = n.getAttribLocation(o, "aAtlasId"), o.aTex = n.getAttribLocation(o, "aTex"), o.aPointAPointB = n.getAttribLocation(o, "aPointAPointB"), o.aPointCPointD = n.getAttribLocation(o, "aPointCPointD"), o.aLineWidth = n.getAttribLocation(o, "aLineWidth"), o.aColor = n.getAttribLocation(o, "aColor"), o.aCornerRadius = n.getAttribLocation(o, "aCornerRadius"), o.aBorderColor = n.getAttribLocation(o, "aBorderColor"), o.uPanZoomMatrix = n.getUniformLocation(o, "uPanZoomMatrix"), o.uAtlasSize = n.getUniformLocation(o, "uAtlasSize"), o.uBGColor = n.getUniformLocation(o, "uBGColor"), o.uZoom = n.getUniformLocation(o, "uZoom"), o.uTextures = [];
      for (var l = 0; l < this.batchManager.getMaxAtlasesPerBatch(); l++)
        o.uTextures.push(n.getUniformLocation(o, "uTexture".concat(l)));
      return o;
    }
  }, {
    key: "_createVAO",
    value: function() {
      var r = [0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1];
      this.vertexCount = r.length / 2;
      var n = this.maxInstances, a = this.gl, i = this.program, s = a.createVertexArray();
      return a.bindVertexArray(s), I5e(a, "vec2", i.aPosition, r), this.transformBuffer = P5e(a, n, i.aTransform), this.indexBuffer = ns(a, n, "vec4", i.aIndex), this.vertTypeBuffer = ns(a, n, "int", i.aVertType), this.atlasIdBuffer = ns(a, n, "int", i.aAtlasId), this.texBuffer = ns(a, n, "vec4", i.aTex), this.pointAPointBBuffer = ns(a, n, "vec4", i.aPointAPointB), this.pointCPointDBuffer = ns(a, n, "vec4", i.aPointCPointD), this.lineWidthBuffer = ns(a, n, "vec2", i.aLineWidth), this.colorBuffer = ns(a, n, "vec4", i.aColor), this.cornerRadiusBuffer = ns(a, n, "vec4", i.aCornerRadius), this.borderColorBuffer = ns(a, n, "vec4", i.aBorderColor), a.bindVertexArray(null), s;
    }
  }, {
    key: "buffers",
    get: function() {
      var r = this;
      return this._buffers || (this._buffers = Object.keys(this).filter(function(n) {
        return Po(n, "Buffer");
      }).map(function(n) {
        return r[n];
      })), this._buffers;
    }
  }, {
    key: "startFrame",
    value: function(r) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Id.SCREEN;
      this.panZoomMatrix = r, this.renderTarget = n, this.batchDebugInfo = [], this.wrappedCount = 0, this.simpleCount = 0, this.startBatch();
    }
  }, {
    key: "startBatch",
    value: function() {
      this.instanceCount = 0, this.batchManager.startBatch();
    }
  }, {
    key: "endFrame",
    value: function() {
      this.endBatch();
    }
  }, {
    key: "_isVisible",
    value: function(r, n) {
      return r.visible() ? n && n.isVisible ? n.isVisible(r) : !0 : !1;
    }
    /**
     * Draws a texture using the texture atlas.
     */
  }, {
    key: "drawTexture",
    value: function(r, n, a) {
      var i = this.atlasManager, s = this.batchManager, o = i.getRenderTypeOpts(a);
      if (this._isVisible(r, o) && !(r.isEdge() && !this._isValidEdge(r))) {
        if (this.renderTarget.picking && o.getTexPickingMode) {
          var l = o.getTexPickingMode(r);
          if (l === jm.IGNORE)
            return;
          if (l == jm.USE_BB) {
            this.drawPickingRectangle(r, n, a);
            return;
          }
        }
        var u = i.getAtlasInfo(r, a), c = Ca(u), f;
        try {
          for (c.s(); !(f = c.n()).done; ) {
            var h = f.value, d = h.atlas, p = h.tex1, g = h.tex2;
            s.canAddToCurrentBatch(d) || this.endBatch();
            for (var v = s.getAtlasIndexForBatch(d), m = 0, b = [[p, !0], [g, !1]]; m < b.length; m++) {
              var y = ln(b[m], 2), x = y[0], E = y[1];
              if (x.w != 0) {
                var S = this.instanceCount;
                this.vertTypeBuffer.getView(S)[0] = Aw;
                var w = this.indexBuffer.getView(S);
                Xu(n, w);
                var C = this.atlasIdBuffer.getView(S);
                C[0] = v;
                var k = this.texBuffer.getView(S);
                k[0] = x.x, k[1] = x.y, k[2] = x.w, k[3] = x.h;
                var N = this.transformBuffer.getMatrixView(S);
                this.setTransformMatrix(r, N, o, h, E), this.instanceCount++, E || this.wrappedCount++, this.instanceCount >= this.maxInstances && this.endBatch();
              }
            }
          }
        } catch (R) {
          c.e(R);
        } finally {
          c.f();
        }
      }
    }
    /**
     * matrix is expected to be a 9 element array
     * this function follows same pattern as CRp.drawCachedElementPortion(...)
     */
  }, {
    key: "setTransformMatrix",
    value: function(r, n, a, i) {
      var s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0, o = 0;
      if (a.shapeProps && a.shapeProps.padding && (o = r.pstyle(a.shapeProps.padding).pfValue), i) {
        var l = i.bb, u = i.tex1, c = i.tex2, f = u.w / (u.w + c.w);
        s || (f = 1 - f);
        var h = this._getAdjustedBB(l, o, s, f);
        this._applyTransformMatrix(n, h, a, r);
      } else {
        var d = a.getBoundingBox(r), p = this._getAdjustedBB(d, o, !0, 1);
        this._applyTransformMatrix(n, p, a, r);
      }
    }
  }, {
    key: "_applyTransformMatrix",
    value: function(r, n, a, i) {
      var s, o;
      SL(r);
      var l = a.getRotation ? a.getRotation(i) : 0;
      if (l !== 0) {
        var u = a.getRotationPoint(i), c = u.x, f = u.y;
        Sv(r, r, [c, f]), CL(r, r, l);
        var h = a.getRotationOffset(i);
        s = h.x + (n.xOffset || 0), o = h.y + (n.yOffset || 0);
      } else
        s = n.x1, o = n.y1;
      Sv(r, r, [s, o]), O4(r, r, [n.w, n.h]);
    }
    /**
     * Adjusts a node or label BB to accomodate padding and split for wrapped textures.
     * @param bb - the original bounding box
     * @param padding - the padding to add to the bounding box
     * @param first - whether this is the first part of a wrapped texture
     * @param ratio - the ratio of the texture width of part of the text to the entire texture
     */
  }, {
    key: "_getAdjustedBB",
    value: function(r, n, a, i) {
      var s = r.x1, o = r.y1, l = r.w, u = r.h, c = r.yOffset;
      n && (s -= n, o -= n, l += 2 * n, u += 2 * n);
      var f = 0, h = l * i;
      return a && i < 1 ? l = h : !a && i < 1 && (f = l - h, s += f, l = h), {
        x1: s,
        y1: o,
        w: l,
        h: u,
        xOffset: f,
        yOffset: c
      };
    }
    /**
     * Draw a solid opaque rectangle matching the element's Bounding Box.
     * Used by the PICKING mode to make the entire BB of a label clickable.
     */
  }, {
    key: "drawPickingRectangle",
    value: function(r, n, a) {
      var i = this.atlasManager.getRenderTypeOpts(a), s = this.instanceCount;
      this.vertTypeBuffer.getView(s)[0] = Ku;
      var o = this.indexBuffer.getView(s);
      Xu(n, o);
      var l = this.colorBuffer.getView(s);
      Rl([0, 0, 0], 1, l);
      var u = this.transformBuffer.getMatrixView(s);
      this.setTransformMatrix(r, u, i), this.simpleCount++, this.instanceCount++, this.instanceCount >= this.maxInstances && this.endBatch();
    }
    /**
     * Draw a node using either a texture or a "simple shape".
     */
  }, {
    key: "drawNode",
    value: function(r, n, a) {
      var i = this.simpleShapeOptions.get(a);
      if (this._isVisible(r, i)) {
        var s = i.shapeProps, o = this._getVertTypeForShape(r, s.shape);
        if (o === void 0 || i.isSimple && !i.isSimple(r)) {
          this.drawTexture(r, n, a);
          return;
        }
        var l = this.instanceCount;
        if (this.vertTypeBuffer.getView(l)[0] = o, o === xg || o === gh) {
          var u = i.getBoundingBox(r), c = this._getCornerRadius(r, s.radius, u), f = this.cornerRadiusBuffer.getView(l);
          f[0] = c, f[1] = c, f[2] = c, f[3] = c, o === gh && (f[0] = 0, f[2] = 0);
        }
        var h = this.indexBuffer.getView(l);
        Xu(n, h);
        var d = r.pstyle(s.color).value, p = r.pstyle(s.opacity).value, g = this.colorBuffer.getView(l);
        Rl(d, p, g);
        var v = this.lineWidthBuffer.getView(l);
        if (v[0] = 0, v[1] = 0, s.border) {
          var m = r.pstyle("border-width").value;
          if (m > 0) {
            var b = r.pstyle("border-color").value, y = r.pstyle("border-opacity").value, x = this.borderColorBuffer.getView(l);
            Rl(b, y, x);
            var E = r.pstyle("border-position").value;
            if (E === "inside")
              v[0] = 0, v[1] = -m;
            else if (E === "outside")
              v[0] = m, v[1] = 0;
            else {
              var S = m / 2;
              v[0] = S, v[1] = -S;
            }
          }
        }
        var w = this.transformBuffer.getMatrixView(l);
        this.setTransformMatrix(r, w, i), this.simpleCount++, this.instanceCount++, this.instanceCount >= this.maxInstances && this.endBatch();
      }
    }
  }, {
    key: "_getVertTypeForShape",
    value: function(r, n) {
      var a = r.pstyle(n).value;
      switch (a) {
        case "rectangle":
          return Ku;
        case "ellipse":
          return vh;
        case "roundrectangle":
        case "round-rectangle":
          return xg;
        case "bottom-round-rectangle":
          return gh;
        default:
          return;
      }
    }
  }, {
    key: "_getCornerRadius",
    value: function(r, n, a) {
      var i = a.w, s = a.h;
      if (r.pstyle(n).value === "auto")
        return Xo(i, s);
      var o = r.pstyle(n).pfValue, l = i / 2, u = s / 2;
      return Math.min(o, u, l);
    }
    /**
     * Only supports drawing triangles at the moment.
     */
  }, {
    key: "drawEdgeArrow",
    value: function(r, n, a) {
      if (r.visible()) {
        var i = r._private.rscratch, s, o, l;
        if (a === "source" ? (s = i.arrowStartX, o = i.arrowStartY, l = i.srcArrowAngle) : (s = i.arrowEndX, o = i.arrowEndY, l = i.tgtArrowAngle), !(isNaN(s) || s == null || isNaN(o) || o == null || isNaN(l) || l == null)) {
          var u = r.pstyle(a + "-arrow-shape").value;
          if (u !== "none") {
            var c = r.pstyle(a + "-arrow-color").value, f = r.pstyle("opacity").value, h = r.pstyle("line-opacity").value, d = f * h, p = r.pstyle("width").pfValue, g = r.pstyle("arrow-scale").value, v = this.r.getArrowWidth(p, g), m = this.instanceCount, b = this.transformBuffer.getMatrixView(m);
            SL(b), Sv(b, b, [s, o]), O4(b, b, [v, v]), CL(b, b, l), this.vertTypeBuffer.getView(m)[0] = kw;
            var y = this.indexBuffer.getView(m);
            Xu(n, y);
            var x = this.colorBuffer.getView(m);
            Rl(c, d, x), this.instanceCount++, this.instanceCount >= this.maxInstances && this.endBatch();
          }
        }
      }
    }
    /**
     * Draw straight-line or bezier curve edges.
     */
  }, {
    key: "drawEdgeLine",
    value: function(r, n) {
      if (r.visible()) {
        var a = this._getEdgePoints(r);
        if (a) {
          var i = r.pstyle("opacity").value, s = r.pstyle("line-opacity").value, o = r.pstyle("width").pfValue, l = r.pstyle("line-color").value, u = i * s;
          if (a.length / 2 + this.instanceCount > this.maxInstances && this.endBatch(), a.length == 4) {
            var c = this.instanceCount;
            this.vertTypeBuffer.getView(c)[0] = AL;
            var f = this.indexBuffer.getView(c);
            Xu(n, f);
            var h = this.colorBuffer.getView(c);
            Rl(l, u, h);
            var d = this.lineWidthBuffer.getView(c);
            d[0] = o;
            var p = this.pointAPointBBuffer.getView(c);
            p[0] = a[0], p[1] = a[1], p[2] = a[2], p[3] = a[3], this.instanceCount++, this.instanceCount >= this.maxInstances && this.endBatch();
          } else
            for (var g = 0; g < a.length - 2; g += 2) {
              var v = this.instanceCount;
              this.vertTypeBuffer.getView(v)[0] = kL;
              var m = this.indexBuffer.getView(v);
              Xu(n, m);
              var b = this.colorBuffer.getView(v);
              Rl(l, u, b);
              var y = this.lineWidthBuffer.getView(v);
              y[0] = o;
              var x = a[g - 2], E = a[g - 1], S = a[g], w = a[g + 1], C = a[g + 2], k = a[g + 3], N = a[g + 4], R = a[g + 5];
              g == 0 && (x = 2 * S - C + 1e-3, E = 2 * w - k + 1e-3), g == a.length - 4 && (N = 2 * C - S + 1e-3, R = 2 * k - w + 1e-3);
              var _ = this.pointAPointBBuffer.getView(v);
              _[0] = x, _[1] = E, _[2] = S, _[3] = w;
              var O = this.pointCPointDBuffer.getView(v);
              O[0] = C, O[1] = k, O[2] = N, O[3] = R, this.instanceCount++, this.instanceCount >= this.maxInstances && this.endBatch();
            }
        }
      }
    }
  }, {
    key: "_isValidEdge",
    value: function(r) {
      var n = r._private.rscratch;
      return !(n.badLine || n.allpts == null || isNaN(n.allpts[0]));
    }
  }, {
    key: "_getEdgePoints",
    value: function(r) {
      var n = r._private.rscratch;
      if (this._isValidEdge(r)) {
        var a = n.allpts;
        if (a.length == 4)
          return a;
        var i = this._getNumSegments(r);
        return this._getCurveSegmentPoints(a, i);
      }
    }
  }, {
    key: "_getNumSegments",
    value: function(r) {
      var n = 15;
      return Math.min(Math.max(n, 5), this.maxInstances);
    }
  }, {
    key: "_getCurveSegmentPoints",
    value: function(r, n) {
      if (r.length == 4)
        return r;
      for (var a = Array((n + 1) * 2), i = 0; i <= n; i++)
        if (i == 0)
          a[0] = r[0], a[1] = r[1];
        else if (i == n)
          a[i * 2] = r[r.length - 2], a[i * 2 + 1] = r[r.length - 1];
        else {
          var s = i / n;
          this._setCurvePoint(r, s, a, i * 2);
        }
      return a;
    }
  }, {
    key: "_setCurvePoint",
    value: function(r, n, a, i) {
      if (r.length <= 2)
        a[i] = r[0], a[i + 1] = r[1];
      else {
        for (var s = Array(r.length - 2), o = 0; o < s.length; o += 2) {
          var l = (1 - n) * r[o] + n * r[o + 2], u = (1 - n) * r[o + 1] + n * r[o + 3];
          s[o] = l, s[o + 1] = u;
        }
        return this._setCurvePoint(s, n, a, i);
      }
    }
  }, {
    key: "endBatch",
    value: function() {
      var r = this.gl, n = this.vao, a = this.vertexCount, i = this.instanceCount;
      if (i !== 0) {
        var s = this.renderTarget.picking ? this.pickingProgram : this.program;
        r.useProgram(s), r.bindVertexArray(n);
        var o = Ca(this.buffers), l;
        try {
          for (o.s(); !(l = o.n()).done; ) {
            var u = l.value;
            u.bufferSubData(i);
          }
        } catch (p) {
          o.e(p);
        } finally {
          o.f();
        }
        for (var c = this.batchManager.getAtlases(), f = 0; f < c.length; f++)
          c[f].bufferIfNeeded(r);
        for (var h = 0; h < c.length; h++)
          r.activeTexture(r.TEXTURE0 + h), r.bindTexture(r.TEXTURE_2D, c[h].texture), r.uniform1i(s.uTextures[h], h);
        r.uniform1f(s.uZoom, k5e(this.r)), r.uniformMatrix3fv(s.uPanZoomMatrix, !1, this.panZoomMatrix), r.uniform1i(s.uAtlasSize, this.batchManager.getAtlasSize());
        var d = Rl(this.bgColor, 1);
        r.uniform4fv(s.uBGColor, d), r.drawArraysInstanced(r.TRIANGLES, 0, a, i), r.bindVertexArray(null), r.bindTexture(r.TEXTURE_2D, null), this.debug && this.batchDebugInfo.push({
          count: i,
          // instance count
          atlasCount: c.length
        }), this.startBatch();
      }
    }
  }, {
    key: "getDebugInfo",
    value: function() {
      var r = this.atlasManager.getDebugInfo(), n = r.reduce(function(s, o) {
        return s + o.atlasCount;
      }, 0), a = this.batchDebugInfo, i = a.reduce(function(s, o) {
        return s + o.count;
      }, 0);
      return {
        atlasInfo: r,
        totalAtlases: n,
        wrappedCount: this.wrappedCount,
        simpleCount: this.simpleCount,
        batchCount: a.length,
        batchInfo: a,
        totalInstances: i
      };
    }
  }]);
}(), rG = {};
rG.initWebgl = function(t, e) {
  var r = this, n = r.data.contexts[r.WEBGL];
  t.bgColor = X5e(r), t.webglTexSize = Math.min(t.webglTexSize, n.getParameter(n.MAX_TEXTURE_SIZE)), t.webglTexRows = Math.min(t.webglTexRows, 54), t.webglTexRowsNodes = Math.min(t.webglTexRowsNodes, 54), t.webglBatchSize = Math.min(t.webglBatchSize, 16384), t.webglTexPerBatch = Math.min(t.webglTexPerBatch, n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)), r.webglDebug = t.webglDebug, r.webglDebugShowAtlases = t.webglDebugShowAtlases, r.pickingFrameBuffer = D5e(n), r.pickingFrameBuffer.needsDraw = !0, r.drawing = new Y5e(r, n, t);
  var a = function(f) {
    return function(h) {
      return r.getTextAngle(h, f);
    };
  }, i = function(f) {
    return function(h) {
      var d = h.pstyle(f);
      return d && d.value;
    };
  }, s = function(f) {
    return function(h) {
      return h.pstyle("".concat(f, "-opacity")).value > 0;
    };
  }, o = function(f) {
    var h = f.pstyle("text-events").strValue === "yes";
    return h ? jm.USE_BB : jm.IGNORE;
  }, l = function(f) {
    var h = f.position(), d = h.x, p = h.y, g = f.outerWidth(), v = f.outerHeight();
    return {
      w: g,
      h: v,
      x1: d - g / 2,
      y1: p - v / 2
    };
  };
  r.drawing.addAtlasCollection("node", {
    texRows: t.webglTexRowsNodes
  }), r.drawing.addAtlasCollection("label", {
    texRows: t.webglTexRows
  }), r.drawing.addTextureAtlasRenderType("node-body", {
    collection: "node",
    getKey: e.getStyleKey,
    getBoundingBox: e.getElementBox,
    drawElement: e.drawElement
  }), r.drawing.addSimpleShapeRenderType("node-body", {
    getBoundingBox: l,
    isSimple: M5e,
    shapeProps: {
      shape: "shape",
      color: "background-color",
      opacity: "background-opacity",
      radius: "corner-radius",
      border: !0
    }
  }), r.drawing.addSimpleShapeRenderType("node-overlay", {
    getBoundingBox: l,
    isVisible: s("overlay"),
    shapeProps: {
      shape: "overlay-shape",
      color: "overlay-color",
      opacity: "overlay-opacity",
      padding: "overlay-padding",
      radius: "overlay-corner-radius"
    }
  }), r.drawing.addSimpleShapeRenderType("node-underlay", {
    getBoundingBox: l,
    isVisible: s("underlay"),
    shapeProps: {
      shape: "underlay-shape",
      color: "underlay-color",
      opacity: "underlay-opacity",
      padding: "underlay-padding",
      radius: "underlay-corner-radius"
    }
  }), r.drawing.addTextureAtlasRenderType("label", {
    // node label or edge mid label
    collection: "label",
    getTexPickingMode: o,
    getKey: Rw(e.getLabelKey, null),
    getBoundingBox: Mw(e.getLabelBox, null),
    drawClipped: !0,
    drawElement: e.drawLabel,
    getRotation: a(null),
    getRotationPoint: e.getLabelRotationPoint,
    getRotationOffset: e.getLabelRotationOffset,
    isVisible: i("label")
  }), r.drawing.addTextureAtlasRenderType("edge-source-label", {
    collection: "label",
    getTexPickingMode: o,
    getKey: Rw(e.getSourceLabelKey, "source"),
    getBoundingBox: Mw(e.getSourceLabelBox, "source"),
    drawClipped: !0,
    drawElement: e.drawSourceLabel,
    getRotation: a("source"),
    getRotationPoint: e.getSourceLabelRotationPoint,
    getRotationOffset: e.getSourceLabelRotationOffset,
    isVisible: i("source-label")
  }), r.drawing.addTextureAtlasRenderType("edge-target-label", {
    collection: "label",
    getTexPickingMode: o,
    getKey: Rw(e.getTargetLabelKey, "target"),
    getBoundingBox: Mw(e.getTargetLabelBox, "target"),
    drawClipped: !0,
    drawElement: e.drawTargetLabel,
    getRotation: a("target"),
    getRotationPoint: e.getTargetLabelRotationPoint,
    getRotationOffset: e.getTargetLabelRotationOffset,
    isVisible: i("target-label")
  });
  var u = hp(function() {
    console.log("garbage collect flag set"), r.data.gc = !0;
  }, 1e4);
  r.onUpdateEleCalcs(function(c, f) {
    var h = !1;
    f && f.length > 0 && (h |= r.drawing.invalidate(f)), h && u();
  }), K5e(r);
};
function X5e(t) {
  var e = t.cy.container(), r = e && e.style && e.style.backgroundColor || "white";
  return _B(r);
}
function nG(t, e) {
  var r = t._private.rscratch;
  return Ta(r, "labelWrapCachedLines", e) || [];
}
var Rw = function(e, r) {
  return function(n) {
    var a = e(n), i = nG(n, r);
    return i.length > 1 ? i.map(function(s, o) {
      return "".concat(a, "_").concat(o);
    }) : a;
  };
}, Mw = function(e, r) {
  return function(n, a) {
    var i = e(n);
    if (typeof a == "string") {
      var s = a.indexOf("_");
      if (s > 0) {
        var o = Number(a.substring(s + 1)), l = nG(n, r), u = i.h / l.length, c = u * o, f = i.y1 + c;
        return {
          x1: i.x1,
          w: i.w,
          y1: f,
          h: u,
          yOffset: c
        };
      }
    }
    return i;
  };
};
function K5e(t) {
  {
    var e = t.render;
    t.render = function(i) {
      i = i || {};
      var s = t.cy;
      t.webgl && (s.zoom() > Xz ? (Z5e(t), e.call(t, i)) : (Q5e(t), iG(t, i, Id.SCREEN)));
    };
  }
  {
    var r = t.matchCanvasSize;
    t.matchCanvasSize = function(i) {
      r.call(t, i), t.pickingFrameBuffer.setFramebufferAttachmentSizes(t.canvasWidth, t.canvasHeight), t.pickingFrameBuffer.needsDraw = !0;
    };
  }
  t.findNearestElements = function(i, s, o, l) {
    return aCe(t, i, s);
  };
  {
    var n = t.invalidateCachedZSortedEles;
    t.invalidateCachedZSortedEles = function() {
      n.call(t), t.pickingFrameBuffer.needsDraw = !0;
    };
  }
  {
    var a = t.notify;
    t.notify = function(i, s) {
      a.call(t, i, s), i === "viewport" || i === "bounds" ? t.pickingFrameBuffer.needsDraw = !0 : i === "background" && t.drawing.invalidate(s, {
        type: "node-body"
      });
    };
  }
}
function Z5e(t) {
  var e = t.data.contexts[t.WEBGL];
  e.clear(e.COLOR_BUFFER_BIT | e.DEPTH_BUFFER_BIT);
}
function Q5e(t) {
  var e = function(n) {
    n.save(), n.setTransform(1, 0, 0, 1, 0, 0), n.clearRect(0, 0, t.canvasWidth, t.canvasHeight), n.restore();
  };
  e(t.data.contexts[t.NODE]), e(t.data.contexts[t.DRAG]);
}
function J5e(t) {
  var e = t.canvasWidth, r = t.canvasHeight, n = C3(t), a = n.pan, i = n.zoom, s = Cw();
  Sv(s, s, [a.x, a.y]), O4(s, s, [i, i]);
  var o = Cw();
  F5e(o, e, r);
  var l = Cw();
  return $5e(l, o, s), l;
}
function aG(t, e) {
  var r = t.canvasWidth, n = t.canvasHeight, a = C3(t), i = a.pan, s = a.zoom;
  e.setTransform(1, 0, 0, 1, 0, 0), e.clearRect(0, 0, r, n), e.translate(i.x, i.y), e.scale(s, s);
}
function eCe(t, e) {
  t.drawSelectionRectangle(e, function(r) {
    return aG(t, r);
  });
}
function tCe(t) {
  var e = t.data.contexts[t.NODE];
  e.save(), aG(t, e), e.strokeStyle = "rgba(0, 0, 0, 0.3)", e.beginPath(), e.moveTo(-1e3, 0), e.lineTo(1e3, 0), e.stroke(), e.beginPath(), e.moveTo(0, -1e3), e.lineTo(0, 1e3), e.stroke(), e.restore();
}
function rCe(t) {
  var e = function(a, i, s) {
    for (var o = a.atlasManager.getAtlasCollection(i), l = t.data.contexts[t.NODE], u = o.atlases, c = 0; c < u.length; c++) {
      var f = u[c], h = f.canvas;
      if (h) {
        var d = h.width, p = h.height, g = d * c, v = h.height * s, m = 0.4;
        l.save(), l.scale(m, m), l.drawImage(h, g, v), l.strokeStyle = "black", l.rect(g, v, d, p), l.stroke(), l.restore();
      }
    }
  }, r = 0;
  e(t.drawing, "node", r++), e(t.drawing, "label", r++);
}
function nCe(t, e, r, n, a) {
  var i, s, o, l, u = C3(t), c = u.pan, f = u.zoom;
  {
    var h = R5e(t, c, f, e, r), d = ln(h, 2), p = d[0], g = d[1], v = 6;
    i = p - v / 2, s = g - v / 2, o = v, l = v;
  }
  if (o === 0 || l === 0)
    return [];
  var m = t.data.contexts[t.WEBGL];
  m.bindFramebuffer(m.FRAMEBUFFER, t.pickingFrameBuffer), t.pickingFrameBuffer.needsDraw && (m.viewport(0, 0, m.canvas.width, m.canvas.height), iG(t, null, Id.PICKING), t.pickingFrameBuffer.needsDraw = !1);
  var b = o * l, y = new Uint8Array(b * 4);
  m.readPixels(i, s, o, l, m.RGBA, m.UNSIGNED_BYTE, y), m.bindFramebuffer(m.FRAMEBUFFER, null);
  for (var x = /* @__PURE__ */ new Set(), E = 0; E < b; E++) {
    var S = y.slice(E * 4, E * 4 + 4), w = L5e(S) - 1;
    w >= 0 && x.add(w);
  }
  return x;
}
function aCe(t, e, r) {
  var n = nCe(t, e, r), a = t.getCachedZSortedEles(), i, s, o = Ca(n), l;
  try {
    for (o.s(); !(l = o.n()).done; ) {
      var u = l.value, c = a[u];
      if (!i && c.isNode() && (i = c), !s && c.isEdge() && (s = c), i && s)
        break;
    }
  } catch (f) {
    o.e(f);
  } finally {
    o.f();
  }
  return [i, s].filter(Boolean);
}
function _w(t, e, r) {
  var n = t.drawing;
  e += 1, r.isNode() ? (n.drawNode(r, e, "node-underlay"), n.drawNode(r, e, "node-body"), n.drawTexture(r, e, "label"), n.drawNode(r, e, "node-overlay")) : (n.drawEdgeLine(r, e), n.drawEdgeArrow(r, e, "source"), n.drawEdgeArrow(r, e, "target"), n.drawTexture(r, e, "label"), n.drawTexture(r, e, "edge-source-label"), n.drawTexture(r, e, "edge-target-label"));
}
function iG(t, e, r) {
  var n;
  t.webglDebug && (n = performance.now());
  var a = t.drawing, i = 0;
  if (r.screen && t.data.canvasNeedsRedraw[t.SELECT_BOX] && eCe(t, e), t.data.canvasNeedsRedraw[t.NODE] || r.picking) {
    var s = t.data.contexts[t.WEBGL];
    r.screen ? (s.clearColor(0, 0, 0, 0), s.enable(s.BLEND), s.blendFunc(s.ONE, s.ONE_MINUS_SRC_ALPHA)) : s.disable(s.BLEND), s.clear(s.COLOR_BUFFER_BIT | s.DEPTH_BUFFER_BIT), s.viewport(0, 0, s.canvas.width, s.canvas.height);
    var o = J5e(t), l = t.getCachedZSortedEles();
    if (i = l.length, a.startFrame(o, r), r.screen) {
      for (var u = 0; u < l.nondrag.length; u++)
        _w(t, u, l.nondrag[u]);
      for (var c = 0; c < l.drag.length; c++)
        _w(t, c, l.drag[c]);
    } else if (r.picking)
      for (var f = 0; f < l.length; f++)
        _w(t, f, l[f]);
    a.endFrame(), r.screen && t.webglDebugShowAtlases && (tCe(t), rCe(t)), t.data.canvasNeedsRedraw[t.NODE] = !1, t.data.canvasNeedsRedraw[t.DRAG] = !1;
  }
  if (t.webglDebug) {
    var h = performance.now(), d = !1, p = Math.ceil(h - n), g = a.getDebugInfo(), v = ["".concat(i, " elements"), "".concat(g.totalInstances, " instances"), "".concat(g.batchCount, " batches"), "".concat(g.totalAtlases, " atlases"), "".concat(g.wrappedCount, " wrapped textures"), "".concat(g.simpleCount, " simple shapes")].join(", ");
    if (d)
      console.log("WebGL (".concat(r.name, ") - time ").concat(p, "ms, ").concat(v));
    else {
      console.log("WebGL (".concat(r.name, ") - frame time ").concat(p, "ms")), console.log("Totals:"), console.log("  ".concat(v)), console.log("Texture Atlases Used:");
      var m = g.atlasInfo, b = Ca(m), y;
      try {
        for (b.s(); !(y = b.n()).done; ) {
          var x = y.value;
          console.log("  ".concat(x.type, ": ").concat(x.keyCount, " keys, ").concat(x.atlasCount, " atlases"));
        }
      } catch (E) {
        b.e(E);
      } finally {
        b.f();
      }
      console.log("");
    }
  }
  t.data.gc && (console.log("Garbage Collect!"), t.data.gc = !1, a.gc());
}
var vl = {};
vl.drawPolygonPath = function(t, e, r, n, a, i) {
  var s = n / 2, o = a / 2;
  t.beginPath && t.beginPath(), t.moveTo(e + s * i[0], r + o * i[1]);
  for (var l = 1; l < i.length / 2; l++)
    t.lineTo(e + s * i[l * 2], r + o * i[l * 2 + 1]);
  t.closePath();
};
vl.drawRoundPolygonPath = function(t, e, r, n, a, i, s) {
  s.forEach(function(o) {
    return zz(t, o);
  }), t.closePath();
};
vl.drawRoundRectanglePath = function(t, e, r, n, a, i) {
  var s = n / 2, o = a / 2, l = i === "auto" ? Xo(n, a) : Math.min(i, o, s);
  t.beginPath && t.beginPath(), t.moveTo(e, r - o), t.arcTo(e + s, r - o, e + s, r, l), t.arcTo(e + s, r + o, e, r + o, l), t.arcTo(e - s, r + o, e - s, r, l), t.arcTo(e - s, r - o, e, r - o, l), t.lineTo(e, r - o), t.closePath();
};
vl.drawBottomRoundRectanglePath = function(t, e, r, n, a, i) {
  var s = n / 2, o = a / 2, l = i === "auto" ? Xo(n, a) : i;
  t.beginPath && t.beginPath(), t.moveTo(e, r - o), t.lineTo(e + s, r - o), t.lineTo(e + s, r), t.arcTo(e + s, r + o, e, r + o, l), t.arcTo(e - s, r + o, e - s, r, l), t.lineTo(e - s, r - o), t.lineTo(e, r - o), t.closePath();
};
vl.drawCutRectanglePath = function(t, e, r, n, a, i, s) {
  var o = n / 2, l = a / 2, u = s === "auto" ? f3() : s;
  t.beginPath && t.beginPath(), t.moveTo(e - o + u, r - l), t.lineTo(e + o - u, r - l), t.lineTo(e + o, r - l + u), t.lineTo(e + o, r + l - u), t.lineTo(e + o - u, r + l), t.lineTo(e - o + u, r + l), t.lineTo(e - o, r + l - u), t.lineTo(e - o, r - l + u), t.closePath();
};
vl.drawBarrelPath = function(t, e, r, n, a) {
  var i = n / 2, s = a / 2, o = e - i, l = e + i, u = r - s, c = r + s, f = b4(n, a), h = f.widthOffset, d = f.heightOffset, p = f.ctrlPtOffsetPct * h;
  t.beginPath && t.beginPath(), t.moveTo(o, u + d), t.lineTo(o, c - d), t.quadraticCurveTo(o + p, c, o + h, c), t.lineTo(l - h, c), t.quadraticCurveTo(l - p, c, l, c - d), t.lineTo(l, u + d), t.quadraticCurveTo(l - p, u, l - h, u), t.lineTo(o + h, u), t.quadraticCurveTo(o + p, u, o, u + d), t.closePath();
};
var RL = Math.sin(0), ML = Math.cos(0), I4 = {}, P4 = {}, sG = Math.PI / 40;
for (var Zu = 0 * Math.PI; Zu < 2 * Math.PI; Zu += sG)
  I4[Zu] = Math.sin(Zu), P4[Zu] = Math.cos(Zu);
vl.drawEllipsePath = function(t, e, r, n, a) {
  if (t.beginPath && t.beginPath(), t.ellipse)
    t.ellipse(e, r, n / 2, a / 2, 0, 0, 2 * Math.PI);
  else
    for (var i, s, o = n / 2, l = a / 2, u = 0 * Math.PI; u < 2 * Math.PI; u += sG)
      i = e - o * I4[u] * RL + o * P4[u] * ML, s = r + l * P4[u] * RL + l * I4[u] * ML, u === 0 ? t.moveTo(i, s) : t.lineTo(i, s);
  t.closePath();
};
var yp = {};
yp.createBuffer = function(t, e) {
  var r = document.createElement("canvas");
  return r.width = t, r.height = e, [r, r.getContext("2d")];
};
yp.bufferCanvasImage = function(t) {
  var e = this.cy, r = e.mutableElements(), n = r.boundingBox(), a = this.findContainerClientCoords(), i = t.full ? Math.ceil(n.w) : a[2], s = t.full ? Math.ceil(n.h) : a[3], o = tt(t.maxWidth) || tt(t.maxHeight), l = this.getPixelRatio(), u = 1;
  if (t.scale !== void 0)
    i *= t.scale, s *= t.scale, u = t.scale;
  else if (o) {
    var c = 1 / 0, f = 1 / 0;
    tt(t.maxWidth) && (c = u * t.maxWidth / i), tt(t.maxHeight) && (f = u * t.maxHeight / s), u = Math.min(c, f), i *= u, s *= u;
  }
  o || (i *= l, s *= l, u *= l);
  var h = document.createElement("canvas");
  h.width = i, h.height = s, h.style.width = i + "px", h.style.height = s + "px";
  var d = h.getContext("2d");
  if (i > 0 && s > 0) {
    d.clearRect(0, 0, i, s), d.globalCompositeOperation = "source-over";
    var p = this.getCachedZSortedEles();
    if (t.full)
      d.translate(-n.x1 * u, -n.y1 * u), d.scale(u, u), this.drawElements(d, p), d.scale(1 / u, 1 / u), d.translate(n.x1 * u, n.y1 * u);
    else {
      var g = e.pan(), v = {
        x: g.x * u,
        y: g.y * u
      };
      u *= e.zoom(), d.translate(v.x, v.y), d.scale(u, u), this.drawElements(d, p), d.scale(1 / u, 1 / u), d.translate(-v.x, -v.y);
    }
    t.bg && (d.globalCompositeOperation = "destination-over", d.fillStyle = t.bg, d.rect(0, 0, i, s), d.fill());
  }
  return h;
};
function iCe(t, e) {
  for (var r = atob(t), n = new ArrayBuffer(r.length), a = new Uint8Array(n), i = 0; i < r.length; i++)
    a[i] = r.charCodeAt(i);
  return new Blob([n], {
    type: e
  });
}
function _L(t) {
  var e = t.indexOf(",");
  return t.substr(e + 1);
}
function oG(t, e, r) {
  var n = function() {
    return e.toDataURL(r, t.quality);
  };
  switch (t.output) {
    case "blob-promise":
      return new _f(function(a, i) {
        try {
          e.toBlob(function(s) {
            s != null ? a(s) : i(new Error("`canvas.toBlob()` sent a null value in its callback"));
          }, r, t.quality);
        } catch (s) {
          i(s);
        }
      });
    case "blob":
      return iCe(_L(n()), r);
    case "base64":
      return _L(n());
    case "base64uri":
    default:
      return n();
  }
}
yp.png = function(t) {
  return oG(t, this.bufferCanvasImage(t), "image/png");
};
yp.jpg = function(t) {
  return oG(t, this.bufferCanvasImage(t), "image/jpeg");
};
var lG = {};
lG.nodeShapeImpl = function(t, e, r, n, a, i, s, o) {
  switch (t) {
    case "ellipse":
      return this.drawEllipsePath(e, r, n, a, i);
    case "polygon":
      return this.drawPolygonPath(e, r, n, a, i, s);
    case "round-polygon":
      return this.drawRoundPolygonPath(e, r, n, a, i, s, o);
    case "roundrectangle":
    case "round-rectangle":
      return this.drawRoundRectanglePath(e, r, n, a, i, o);
    case "cutrectangle":
    case "cut-rectangle":
      return this.drawCutRectanglePath(e, r, n, a, i, s, o);
    case "bottomroundrectangle":
    case "bottom-round-rectangle":
      return this.drawBottomRoundRectanglePath(e, r, n, a, i, o);
    case "barrel":
      return this.drawBarrelPath(e, r, n, a, i);
  }
};
var sCe = uG, Ut = uG.prototype;
Ut.CANVAS_LAYERS = 3;
Ut.SELECT_BOX = 0;
Ut.DRAG = 1;
Ut.NODE = 2;
Ut.WEBGL = 3;
Ut.CANVAS_TYPES = ["2d", "2d", "2d", "webgl2"];
Ut.BUFFER_COUNT = 3;
Ut.TEXTURE_BUFFER = 0;
Ut.MOTIONBLUR_BUFFER_NODE = 1;
Ut.MOTIONBLUR_BUFFER_DRAG = 2;
function uG(t) {
  var e = this, r = e.cy.window(), n = r.document;
  t.webgl && (Ut.CANVAS_LAYERS = e.CANVAS_LAYERS = 4, console.log("webgl rendering enabled")), e.data = {
    canvases: new Array(Ut.CANVAS_LAYERS),
    contexts: new Array(Ut.CANVAS_LAYERS),
    canvasNeedsRedraw: new Array(Ut.CANVAS_LAYERS),
    bufferCanvases: new Array(Ut.BUFFER_COUNT),
    bufferContexts: new Array(Ut.CANVAS_LAYERS)
  };
  var a = "-webkit-tap-highlight-color", i = "rgba(0,0,0,0)";
  e.data.canvasContainer = n.createElement("div");
  var s = e.data.canvasContainer.style;
  e.data.canvasContainer.style[a] = i, s.position = "relative", s.zIndex = "0", s.overflow = "hidden";
  var o = t.cy.container();
  o.appendChild(e.data.canvasContainer), o.style[a] = i;
  var l = {
    "-webkit-user-select": "none",
    "-moz-user-select": "-moz-none",
    "user-select": "none",
    "-webkit-tap-highlight-color": "rgba(0,0,0,0)",
    "outline-style": "none"
  };
  ewe() && (l["-ms-touch-action"] = "none", l["touch-action"] = "none");
  for (var u = 0; u < Ut.CANVAS_LAYERS; u++) {
    var c = e.data.canvases[u] = n.createElement("canvas"), f = Ut.CANVAS_TYPES[u];
    e.data.contexts[u] = c.getContext(f), e.data.contexts[u] || Fr("Could not create canvas of type " + f), Object.keys(l).forEach(function(V) {
      c.style[V] = l[V];
    }), c.style.position = "absolute", c.setAttribute("data-id", "layer" + u), c.style.zIndex = String(Ut.CANVAS_LAYERS - u), e.data.canvasContainer.appendChild(c), e.data.canvasNeedsRedraw[u] = !1;
  }
  e.data.topCanvas = e.data.canvases[0], e.data.canvases[Ut.NODE].setAttribute("data-id", "layer" + Ut.NODE + "-node"), e.data.canvases[Ut.SELECT_BOX].setAttribute("data-id", "layer" + Ut.SELECT_BOX + "-selectbox"), e.data.canvases[Ut.DRAG].setAttribute("data-id", "layer" + Ut.DRAG + "-drag"), e.data.canvases[Ut.WEBGL] && e.data.canvases[Ut.WEBGL].setAttribute("data-id", "layer" + Ut.WEBGL + "-webgl");
  for (var u = 0; u < Ut.BUFFER_COUNT; u++)
    e.data.bufferCanvases[u] = n.createElement("canvas"), e.data.bufferContexts[u] = e.data.bufferCanvases[u].getContext("2d"), e.data.bufferCanvases[u].style.position = "absolute", e.data.bufferCanvases[u].setAttribute("data-id", "buffer" + u), e.data.bufferCanvases[u].style.zIndex = String(-u - 1), e.data.bufferCanvases[u].style.visibility = "hidden";
  e.pathsEnabled = !0;
  var h = da(), d = function(q) {
    return {
      x: (q.x1 + q.x2) / 2,
      y: (q.y1 + q.y2) / 2
    };
  }, p = function(q) {
    return {
      x: -q.w / 2,
      y: -q.h / 2
    };
  }, g = function(q) {
    var X = q[0]._private, W = X.oldBackgroundTimestamp === X.backgroundTimestamp;
    return !W;
  }, v = function(q) {
    return q[0]._private.nodeKey;
  }, m = function(q) {
    return q[0]._private.labelStyleKey;
  }, b = function(q) {
    return q[0]._private.sourceLabelStyleKey;
  }, y = function(q) {
    return q[0]._private.targetLabelStyleKey;
  }, x = function(q, X, W, ue, J) {
    return e.drawElement(q, X, W, !1, !1, J);
  }, E = function(q, X, W, ue, J) {
    return e.drawElementText(q, X, W, ue, "main", J);
  }, S = function(q, X, W, ue, J) {
    return e.drawElementText(q, X, W, ue, "source", J);
  }, w = function(q, X, W, ue, J) {
    return e.drawElementText(q, X, W, ue, "target", J);
  }, C = function(q) {
    return q.boundingBox(), q[0]._private.bodyBounds;
  }, k = function(q) {
    return q.boundingBox(), q[0]._private.labelBounds.main || h;
  }, N = function(q) {
    return q.boundingBox(), q[0]._private.labelBounds.source || h;
  }, R = function(q) {
    return q.boundingBox(), q[0]._private.labelBounds.target || h;
  }, _ = function(q, X) {
    return X;
  }, O = function(q) {
    return d(C(q));
  }, T = function(q, X, W) {
    var ue = q ? q + "-" : "";
    return {
      x: X.x + W.pstyle(ue + "text-margin-x").pfValue,
      y: X.y + W.pstyle(ue + "text-margin-y").pfValue
    };
  }, L = function(q, X, W) {
    var ue = q[0]._private.rscratch;
    return {
      x: ue[X],
      y: ue[W]
    };
  }, M = function(q) {
    return T("", L(q, "labelX", "labelY"), q);
  }, A = function(q) {
    return T("source", L(q, "sourceLabelX", "sourceLabelY"), q);
  }, I = function(q) {
    return T("target", L(q, "targetLabelX", "targetLabelY"), q);
  }, D = function(q) {
    return p(C(q));
  }, F = function(q) {
    return p(N(q));
  }, B = function(q) {
    return p(R(q));
  }, G = function(q) {
    var X = k(q), W = p(k(q));
    if (q.isNode()) {
      switch (q.pstyle("text-halign").value) {
        case "left":
          W.x = -X.w - (X.leftPad || 0);
          break;
        case "right":
          W.x = -(X.rightPad || 0);
          break;
      }
      switch (q.pstyle("text-valign").value) {
        case "top":
          W.y = -X.h - (X.topPad || 0);
          break;
        case "bottom":
          W.y = -(X.botPad || 0);
          break;
      }
    }
    return W;
  }, H = e.data.eleTxrCache = new Nh(e, {
    getKey: v,
    doesEleInvalidateKey: g,
    drawElement: x,
    getBoundingBox: C,
    getRotationPoint: O,
    getRotationOffset: D,
    allowEdgeTxrCaching: !1,
    allowParentTxrCaching: !1
  }), K = e.data.lblTxrCache = new Nh(e, {
    getKey: m,
    drawElement: E,
    getBoundingBox: k,
    getRotationPoint: M,
    getRotationOffset: G,
    isVisible: _
  }), j = e.data.slbTxrCache = new Nh(e, {
    getKey: b,
    drawElement: S,
    getBoundingBox: N,
    getRotationPoint: A,
    getRotationOffset: F,
    isVisible: _
  }), Z = e.data.tlbTxrCache = new Nh(e, {
    getKey: y,
    drawElement: w,
    getBoundingBox: R,
    getRotationPoint: I,
    getRotationOffset: B,
    isVisible: _
  }), te = e.data.lyrTxrCache = new Kz(e);
  e.onUpdateEleCalcs(function(q, X) {
    H.invalidateElements(X), K.invalidateElements(X), j.invalidateElements(X), Z.invalidateElements(X), te.invalidateElements(X);
    for (var W = 0; W < X.length; W++) {
      var ue = X[W]._private;
      ue.oldBackgroundTimestamp = ue.backgroundTimestamp;
    }
  });
  var ne = function(q) {
    for (var X = 0; X < q.length; X++)
      te.enqueueElementRefinement(q[X].ele);
  };
  H.onDequeue(ne), K.onDequeue(ne), j.onDequeue(ne), Z.onDequeue(ne), t.webgl && e.initWebgl(t, {
    getStyleKey: v,
    getLabelKey: m,
    getSourceLabelKey: b,
    getTargetLabelKey: y,
    drawElement: x,
    drawLabel: E,
    drawSourceLabel: S,
    drawTargetLabel: w,
    getElementBox: C,
    getLabelBox: k,
    getSourceLabelBox: N,
    getTargetLabelBox: R,
    getElementRotationPoint: O,
    getElementRotationOffset: D,
    getLabelRotationPoint: M,
    getSourceLabelRotationPoint: A,
    getTargetLabelRotationPoint: I,
    getLabelRotationOffset: G,
    getSourceLabelRotationOffset: F,
    getTargetLabelRotationOffset: B
  });
}
Ut.redrawHint = function(t, e) {
  var r = this;
  switch (t) {
    case "eles":
      r.data.canvasNeedsRedraw[Ut.NODE] = e;
      break;
    case "drag":
      r.data.canvasNeedsRedraw[Ut.DRAG] = e;
      break;
    case "select":
      r.data.canvasNeedsRedraw[Ut.SELECT_BOX] = e;
      break;
    case "gc":
      r.data.gc = !0;
      break;
  }
};
var oCe = typeof Path2D < "u";
Ut.path2dEnabled = function(t) {
  if (t === void 0)
    return this.pathsEnabled;
  this.pathsEnabled = !!t;
};
Ut.usePaths = function() {
  return oCe && this.pathsEnabled;
};
Ut.setImgSmoothing = function(t, e) {
  t.imageSmoothingEnabled != null ? t.imageSmoothingEnabled = e : (t.webkitImageSmoothingEnabled = e, t.mozImageSmoothingEnabled = e, t.msImageSmoothingEnabled = e);
};
Ut.getImgSmoothing = function(t) {
  return t.imageSmoothingEnabled != null ? t.imageSmoothingEnabled : t.webkitImageSmoothingEnabled || t.mozImageSmoothingEnabled || t.msImageSmoothingEnabled;
};
Ut.makeOffscreenCanvas = function(t, e) {
  var r;
  if ((typeof OffscreenCanvas > "u" ? "undefined" : xn(OffscreenCanvas)) !== "undefined")
    r = new OffscreenCanvas(t, e);
  else {
    var n = this.cy.window(), a = n.document;
    r = a.createElement("canvas"), r.width = t, r.height = e;
  }
  return r;
};
[Zz, Rs, wo, S3, Lu, gl, ba, rG, vl, yp, lG].forEach(function(t) {
  At(Ut, t);
});
var lCe = [{
  name: "null",
  impl: $z
}, {
  name: "base",
  impl: jz
}, {
  name: "canvas",
  impl: sCe
}], uCe = [{
  type: "layout",
  extensions: ISe
}, {
  type: "renderer",
  extensions: lCe
}], cG = {}, fG = {};
function hG(t, e, r) {
  var n = r, a = function(C) {
    pr("Can not register `" + e + "` for `" + t + "` since `" + C + "` already exists in the prototype and can not be overridden");
  };
  if (t === "core") {
    if (p0.prototype[e])
      return a(e);
    p0.prototype[e] = r;
  } else if (t === "collection") {
    if (zn.prototype[e])
      return a(e);
    zn.prototype[e] = r;
  } else if (t === "layout") {
    for (var i = function(C) {
      this.options = C, r.call(this, C), Qt(this._private) || (this._private = {}), this._private.cy = C.cy, this._private.listeners = [], this.createEmitter();
    }, s = i.prototype = Object.create(r.prototype), o = [], l = 0; l < o.length; l++) {
      var u = o[l];
      s[u] = s[u] || function() {
        return this;
      };
    }
    s.start && !s.run ? s.run = function() {
      return this.start(), this;
    } : !s.start && s.run && (s.start = function() {
      return this.run(), this;
    });
    var c = r.prototype.stop;
    s.stop = function() {
      var w = this.options;
      if (w && w.animate) {
        var C = this.animations;
        if (C)
          for (var k = 0; k < C.length; k++)
            C[k].stop();
      }
      return c ? c.call(this) : this.emit("layoutstop"), this;
    }, s.destroy || (s.destroy = function() {
      return this;
    }), s.cy = function() {
      return this._private.cy;
    };
    var f = function(C) {
      return C._private.cy;
    }, h = {
      addEventFields: function(C, k) {
        k.layout = C, k.cy = f(C), k.target = C;
      },
      bubble: function() {
        return !0;
      },
      parent: function(C) {
        return f(C);
      }
    };
    At(s, {
      createEmitter: function() {
        return this._private.emitter = new ib(h, this), this;
      },
      emitter: function() {
        return this._private.emitter;
      },
      on: function(C, k) {
        return this.emitter().on(C, k), this;
      },
      one: function(C, k) {
        return this.emitter().one(C, k), this;
      },
      once: function(C, k) {
        return this.emitter().one(C, k), this;
      },
      removeListener: function(C, k) {
        return this.emitter().removeListener(C, k), this;
      },
      removeAllListeners: function() {
        return this.emitter().removeAllListeners(), this;
      },
      emit: function(C, k) {
        return this.emitter().emit(C, k), this;
      }
    }), hr.eventAliasesOn(s), n = i;
  } else if (t === "renderer" && e !== "null" && e !== "base") {
    var d = dG("renderer", "base"), p = d.prototype, g = r, v = r.prototype, m = function() {
      d.apply(this, arguments), g.apply(this, arguments);
    }, b = m.prototype;
    for (var y in p) {
      var x = p[y], E = v[y] != null;
      if (E)
        return a(y);
      b[y] = x;
    }
    for (var S in v)
      b[S] = v[S];
    p.clientFunctions.forEach(function(w) {
      b[w] = b[w] || function() {
        Fr("Renderer does not implement `renderer." + w + "()` on its prototype");
      };
    }), n = m;
  } else if (t === "__proto__" || t === "constructor" || t === "prototype")
    return Fr(t + " is an illegal type to be registered, possibly lead to prototype pollutions");
  return LB({
    map: cG,
    keys: [t, e],
    value: n
  });
}
function dG(t, e) {
  return NB({
    map: cG,
    keys: [t, e]
  });
}
function cCe(t, e, r, n, a) {
  return LB({
    map: fG,
    keys: [t, e, r, n],
    value: a
  });
}
function fCe(t, e, r, n) {
  return NB({
    map: fG,
    keys: [t, e, r, n]
  });
}
var D4 = function() {
  if (arguments.length === 2)
    return dG.apply(null, arguments);
  if (arguments.length === 3)
    return hG.apply(null, arguments);
  if (arguments.length === 4)
    return fCe.apply(null, arguments);
  if (arguments.length === 5)
    return cCe.apply(null, arguments);
  Fr("Invalid extension access syntax");
};
p0.prototype.extension = D4;
uCe.forEach(function(t) {
  t.extensions.forEach(function(e) {
    hG(t.type, e.name, e.impl);
  });
});
var Ym = function() {
  if (!(this instanceof Ym))
    return new Ym();
  this.length = 0;
}, uu = Ym.prototype;
uu.instanceString = function() {
  return "stylesheet";
};
uu.selector = function(t) {
  var e = this.length++;
  return this[e] = {
    selector: t,
    properties: []
  }, this;
};
uu.css = function(t, e) {
  var r = this.length - 1;
  if (xt(t))
    this[r].properties.push({
      name: t,
      value: e
    });
  else if (Qt(t))
    for (var n = t, a = Object.keys(n), i = 0; i < a.length; i++) {
      var s = a[i], o = n[s];
      if (o != null) {
        var l = Rn.properties[s] || Rn.properties[X1(s)];
        if (l != null) {
          var u = l.name, c = o;
          this[r].properties.push({
            name: u,
            value: c
          });
        }
      }
    }
  return this;
};
uu.style = uu.css;
uu.generateStyle = function(t) {
  var e = new Rn(t);
  return this.appendToStyle(e);
};
uu.appendToStyle = function(t) {
  for (var e = 0; e < this.length; e++) {
    var r = this[e], n = r.selector, a = r.properties;
    t.selector(n);
    for (var i = 0; i < a.length; i++) {
      var s = a[i];
      t.css(s.name, s.value);
    }
  }
  return t;
};
var hCe = "3.33.1", df = function(e) {
  if (e === void 0 && (e = {}), Qt(e))
    return new p0(e);
  if (xt(e))
    return D4.apply(D4, arguments);
};
df.use = function(t) {
  var e = Array.prototype.slice.call(arguments, 1);
  return e.unshift(df), t.apply(null, e), this;
};
df.warnings = function(t) {
  return BB(t);
};
df.version = hCe;
df.stylesheet = df.Stylesheet = Ym;
var pG = { exports: {} }, Lw = { exports: {} }, Nw = { exports: {} }, LL;
function dCe() {
  return LL || (LL = 1, function(t, e) {
    (function(n, a) {
      t.exports = a();
    })(Jt, function() {
      return (
        /******/
        function(r) {
          var n = {};
          function a(i) {
            if (n[i])
              return n[i].exports;
            var s = n[i] = {
              /******/
              i,
              /******/
              l: !1,
              /******/
              exports: {}
              /******/
            };
            return r[i].call(s.exports, s, s.exports, a), s.l = !0, s.exports;
          }
          return a.m = r, a.c = n, a.i = function(i) {
            return i;
          }, a.d = function(i, s, o) {
            a.o(i, s) || Object.defineProperty(i, s, {
              /******/
              configurable: !1,
              /******/
              enumerable: !0,
              /******/
              get: o
              /******/
            });
          }, a.n = function(i) {
            var s = i && i.__esModule ? (
              /******/
              function() {
                return i.default;
              }
            ) : (
              /******/
              function() {
                return i;
              }
            );
            return a.d(s, "a", s), s;
          }, a.o = function(i, s) {
            return Object.prototype.hasOwnProperty.call(i, s);
          }, a.p = "", a(a.s = 26);
        }([
          /* 0 */
          /***/
          function(r, n, a) {
            function i() {
            }
            i.QUALITY = 1, i.DEFAULT_CREATE_BENDS_AS_NEEDED = !1, i.DEFAULT_INCREMENTAL = !1, i.DEFAULT_ANIMATION_ON_LAYOUT = !0, i.DEFAULT_ANIMATION_DURING_LAYOUT = !1, i.DEFAULT_ANIMATION_PERIOD = 50, i.DEFAULT_UNIFORM_LEAF_NODE_SIZES = !1, i.DEFAULT_GRAPH_MARGIN = 15, i.NODE_DIMENSIONS_INCLUDE_LABELS = !1, i.SIMPLE_NODE_SIZE = 40, i.SIMPLE_NODE_HALF_SIZE = i.SIMPLE_NODE_SIZE / 2, i.EMPTY_COMPOUND_NODE_SIZE = 40, i.MIN_EDGE_LENGTH = 1, i.WORLD_BOUNDARY = 1e6, i.INITIAL_WORLD_BOUNDARY = i.WORLD_BOUNDARY / 1e3, i.WORLD_CENTER_X = 1200, i.WORLD_CENTER_Y = 900, r.exports = i;
          },
          /* 1 */
          /***/
          function(r, n, a) {
            var i = a(2), s = a(8), o = a(9);
            function l(c, f, h) {
              i.call(this, h), this.isOverlapingSourceAndTarget = !1, this.vGraphObject = h, this.bendpoints = [], this.source = c, this.target = f;
            }
            l.prototype = Object.create(i.prototype);
            for (var u in i)
              l[u] = i[u];
            l.prototype.getSource = function() {
              return this.source;
            }, l.prototype.getTarget = function() {
              return this.target;
            }, l.prototype.isInterGraph = function() {
              return this.isInterGraph;
            }, l.prototype.getLength = function() {
              return this.length;
            }, l.prototype.isOverlapingSourceAndTarget = function() {
              return this.isOverlapingSourceAndTarget;
            }, l.prototype.getBendpoints = function() {
              return this.bendpoints;
            }, l.prototype.getLca = function() {
              return this.lca;
            }, l.prototype.getSourceInLca = function() {
              return this.sourceInLca;
            }, l.prototype.getTargetInLca = function() {
              return this.targetInLca;
            }, l.prototype.getOtherEnd = function(c) {
              if (this.source === c)
                return this.target;
              if (this.target === c)
                return this.source;
              throw "Node is not incident with this edge";
            }, l.prototype.getOtherEndInGraph = function(c, f) {
              for (var h = this.getOtherEnd(c), d = f.getGraphManager().getRoot(); ; ) {
                if (h.getOwner() == f)
                  return h;
                if (h.getOwner() == d)
                  break;
                h = h.getOwner().getParent();
              }
              return null;
            }, l.prototype.updateLength = function() {
              var c = new Array(4);
              this.isOverlapingSourceAndTarget = s.getIntersection(this.target.getRect(), this.source.getRect(), c), this.isOverlapingSourceAndTarget || (this.lengthX = c[0] - c[2], this.lengthY = c[1] - c[3], Math.abs(this.lengthX) < 1 && (this.lengthX = o.sign(this.lengthX)), Math.abs(this.lengthY) < 1 && (this.lengthY = o.sign(this.lengthY)), this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY));
            }, l.prototype.updateLengthSimple = function() {
              this.lengthX = this.target.getCenterX() - this.source.getCenterX(), this.lengthY = this.target.getCenterY() - this.source.getCenterY(), Math.abs(this.lengthX) < 1 && (this.lengthX = o.sign(this.lengthX)), Math.abs(this.lengthY) < 1 && (this.lengthY = o.sign(this.lengthY)), this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);
            }, r.exports = l;
          },
          /* 2 */
          /***/
          function(r, n, a) {
            function i(s) {
              this.vGraphObject = s;
            }
            r.exports = i;
          },
          /* 3 */
          /***/
          function(r, n, a) {
            var i = a(2), s = a(10), o = a(13), l = a(0), u = a(16), c = a(4);
            function f(d, p, g, v) {
              g == null && v == null && (v = p), i.call(this, v), d.graphManager != null && (d = d.graphManager), this.estimatedSize = s.MIN_VALUE, this.inclusionTreeDepth = s.MAX_VALUE, this.vGraphObject = v, this.edges = [], this.graphManager = d, g != null && p != null ? this.rect = new o(p.x, p.y, g.width, g.height) : this.rect = new o();
            }
            f.prototype = Object.create(i.prototype);
            for (var h in i)
              f[h] = i[h];
            f.prototype.getEdges = function() {
              return this.edges;
            }, f.prototype.getChild = function() {
              return this.child;
            }, f.prototype.getOwner = function() {
              return this.owner;
            }, f.prototype.getWidth = function() {
              return this.rect.width;
            }, f.prototype.setWidth = function(d) {
              this.rect.width = d;
            }, f.prototype.getHeight = function() {
              return this.rect.height;
            }, f.prototype.setHeight = function(d) {
              this.rect.height = d;
            }, f.prototype.getCenterX = function() {
              return this.rect.x + this.rect.width / 2;
            }, f.prototype.getCenterY = function() {
              return this.rect.y + this.rect.height / 2;
            }, f.prototype.getCenter = function() {
              return new c(this.rect.x + this.rect.width / 2, this.rect.y + this.rect.height / 2);
            }, f.prototype.getLocation = function() {
              return new c(this.rect.x, this.rect.y);
            }, f.prototype.getRect = function() {
              return this.rect;
            }, f.prototype.getDiagonal = function() {
              return Math.sqrt(this.rect.width * this.rect.width + this.rect.height * this.rect.height);
            }, f.prototype.getHalfTheDiagonal = function() {
              return Math.sqrt(this.rect.height * this.rect.height + this.rect.width * this.rect.width) / 2;
            }, f.prototype.setRect = function(d, p) {
              this.rect.x = d.x, this.rect.y = d.y, this.rect.width = p.width, this.rect.height = p.height;
            }, f.prototype.setCenter = function(d, p) {
              this.rect.x = d - this.rect.width / 2, this.rect.y = p - this.rect.height / 2;
            }, f.prototype.setLocation = function(d, p) {
              this.rect.x = d, this.rect.y = p;
            }, f.prototype.moveBy = function(d, p) {
              this.rect.x += d, this.rect.y += p;
            }, f.prototype.getEdgeListToNode = function(d) {
              var p = [], g = this;
              return g.edges.forEach(function(v) {
                if (v.target == d) {
                  if (v.source != g) throw "Incorrect edge source!";
                  p.push(v);
                }
              }), p;
            }, f.prototype.getEdgesBetween = function(d) {
              var p = [], g = this;
              return g.edges.forEach(function(v) {
                if (!(v.source == g || v.target == g)) throw "Incorrect edge source and/or target";
                (v.target == d || v.source == d) && p.push(v);
              }), p;
            }, f.prototype.getNeighborsList = function() {
              var d = /* @__PURE__ */ new Set(), p = this;
              return p.edges.forEach(function(g) {
                if (g.source == p)
                  d.add(g.target);
                else {
                  if (g.target != p)
                    throw "Incorrect incidency!";
                  d.add(g.source);
                }
              }), d;
            }, f.prototype.withChildren = function() {
              var d = /* @__PURE__ */ new Set(), p, g;
              if (d.add(this), this.child != null)
                for (var v = this.child.getNodes(), m = 0; m < v.length; m++)
                  p = v[m], g = p.withChildren(), g.forEach(function(b) {
                    d.add(b);
                  });
              return d;
            }, f.prototype.getNoOfChildren = function() {
              var d = 0, p;
              if (this.child == null)
                d = 1;
              else
                for (var g = this.child.getNodes(), v = 0; v < g.length; v++)
                  p = g[v], d += p.getNoOfChildren();
              return d == 0 && (d = 1), d;
            }, f.prototype.getEstimatedSize = function() {
              if (this.estimatedSize == s.MIN_VALUE)
                throw "assert failed";
              return this.estimatedSize;
            }, f.prototype.calcEstimatedSize = function() {
              return this.child == null ? this.estimatedSize = (this.rect.width + this.rect.height) / 2 : (this.estimatedSize = this.child.calcEstimatedSize(), this.rect.width = this.estimatedSize, this.rect.height = this.estimatedSize, this.estimatedSize);
            }, f.prototype.scatter = function() {
              var d, p, g = -l.INITIAL_WORLD_BOUNDARY, v = l.INITIAL_WORLD_BOUNDARY;
              d = l.WORLD_CENTER_X + u.nextDouble() * (v - g) + g;
              var m = -l.INITIAL_WORLD_BOUNDARY, b = l.INITIAL_WORLD_BOUNDARY;
              p = l.WORLD_CENTER_Y + u.nextDouble() * (b - m) + m, this.rect.x = d, this.rect.y = p;
            }, f.prototype.updateBounds = function() {
              if (this.getChild() == null)
                throw "assert failed";
              if (this.getChild().getNodes().length != 0) {
                var d = this.getChild();
                if (d.updateBounds(!0), this.rect.x = d.getLeft(), this.rect.y = d.getTop(), this.setWidth(d.getRight() - d.getLeft()), this.setHeight(d.getBottom() - d.getTop()), l.NODE_DIMENSIONS_INCLUDE_LABELS) {
                  var p = d.getRight() - d.getLeft(), g = d.getBottom() - d.getTop();
                  this.labelWidth > p && (this.rect.x -= (this.labelWidth - p) / 2, this.setWidth(this.labelWidth)), this.labelHeight > g && (this.labelPos == "center" ? this.rect.y -= (this.labelHeight - g) / 2 : this.labelPos == "top" && (this.rect.y -= this.labelHeight - g), this.setHeight(this.labelHeight));
                }
              }
            }, f.prototype.getInclusionTreeDepth = function() {
              if (this.inclusionTreeDepth == s.MAX_VALUE)
                throw "assert failed";
              return this.inclusionTreeDepth;
            }, f.prototype.transform = function(d) {
              var p = this.rect.x;
              p > l.WORLD_BOUNDARY ? p = l.WORLD_BOUNDARY : p < -l.WORLD_BOUNDARY && (p = -l.WORLD_BOUNDARY);
              var g = this.rect.y;
              g > l.WORLD_BOUNDARY ? g = l.WORLD_BOUNDARY : g < -l.WORLD_BOUNDARY && (g = -l.WORLD_BOUNDARY);
              var v = new c(p, g), m = d.inverseTransformPoint(v);
              this.setLocation(m.x, m.y);
            }, f.prototype.getLeft = function() {
              return this.rect.x;
            }, f.prototype.getRight = function() {
              return this.rect.x + this.rect.width;
            }, f.prototype.getTop = function() {
              return this.rect.y;
            }, f.prototype.getBottom = function() {
              return this.rect.y + this.rect.height;
            }, f.prototype.getParent = function() {
              return this.owner == null ? null : this.owner.getParent();
            }, r.exports = f;
          },
          /* 4 */
          /***/
          function(r, n, a) {
            function i(s, o) {
              s == null && o == null ? (this.x = 0, this.y = 0) : (this.x = s, this.y = o);
            }
            i.prototype.getX = function() {
              return this.x;
            }, i.prototype.getY = function() {
              return this.y;
            }, i.prototype.setX = function(s) {
              this.x = s;
            }, i.prototype.setY = function(s) {
              this.y = s;
            }, i.prototype.getDifference = function(s) {
              return new DimensionD(this.x - s.x, this.y - s.y);
            }, i.prototype.getCopy = function() {
              return new i(this.x, this.y);
            }, i.prototype.translate = function(s) {
              return this.x += s.width, this.y += s.height, this;
            }, r.exports = i;
          },
          /* 5 */
          /***/
          function(r, n, a) {
            var i = a(2), s = a(10), o = a(0), l = a(6), u = a(3), c = a(1), f = a(13), h = a(12), d = a(11);
            function p(v, m, b) {
              i.call(this, b), this.estimatedSize = s.MIN_VALUE, this.margin = o.DEFAULT_GRAPH_MARGIN, this.edges = [], this.nodes = [], this.isConnected = !1, this.parent = v, m != null && m instanceof l ? this.graphManager = m : m != null && m instanceof Layout && (this.graphManager = m.graphManager);
            }
            p.prototype = Object.create(i.prototype);
            for (var g in i)
              p[g] = i[g];
            p.prototype.getNodes = function() {
              return this.nodes;
            }, p.prototype.getEdges = function() {
              return this.edges;
            }, p.prototype.getGraphManager = function() {
              return this.graphManager;
            }, p.prototype.getParent = function() {
              return this.parent;
            }, p.prototype.getLeft = function() {
              return this.left;
            }, p.prototype.getRight = function() {
              return this.right;
            }, p.prototype.getTop = function() {
              return this.top;
            }, p.prototype.getBottom = function() {
              return this.bottom;
            }, p.prototype.isConnected = function() {
              return this.isConnected;
            }, p.prototype.add = function(v, m, b) {
              if (m == null && b == null) {
                var y = v;
                if (this.graphManager == null)
                  throw "Graph has no graph mgr!";
                if (this.getNodes().indexOf(y) > -1)
                  throw "Node already in graph!";
                return y.owner = this, this.getNodes().push(y), y;
              } else {
                var x = v;
                if (!(this.getNodes().indexOf(m) > -1 && this.getNodes().indexOf(b) > -1))
                  throw "Source or target not in graph!";
                if (!(m.owner == b.owner && m.owner == this))
                  throw "Both owners must be this graph!";
                return m.owner != b.owner ? null : (x.source = m, x.target = b, x.isInterGraph = !1, this.getEdges().push(x), m.edges.push(x), b != m && b.edges.push(x), x);
              }
            }, p.prototype.remove = function(v) {
              var m = v;
              if (v instanceof u) {
                if (m == null)
                  throw "Node is null!";
                if (!(m.owner != null && m.owner == this))
                  throw "Owner graph is invalid!";
                if (this.graphManager == null)
                  throw "Owner graph manager is invalid!";
                for (var b = m.edges.slice(), y, x = b.length, E = 0; E < x; E++)
                  y = b[E], y.isInterGraph ? this.graphManager.remove(y) : y.source.owner.remove(y);
                var S = this.nodes.indexOf(m);
                if (S == -1)
                  throw "Node not in owner node list!";
                this.nodes.splice(S, 1);
              } else if (v instanceof c) {
                var y = v;
                if (y == null)
                  throw "Edge is null!";
                if (!(y.source != null && y.target != null))
                  throw "Source and/or target is null!";
                if (!(y.source.owner != null && y.target.owner != null && y.source.owner == this && y.target.owner == this))
                  throw "Source and/or target owner is invalid!";
                var w = y.source.edges.indexOf(y), C = y.target.edges.indexOf(y);
                if (!(w > -1 && C > -1))
                  throw "Source and/or target doesn't know this edge!";
                y.source.edges.splice(w, 1), y.target != y.source && y.target.edges.splice(C, 1);
                var S = y.source.owner.getEdges().indexOf(y);
                if (S == -1)
                  throw "Not in owner's edge list!";
                y.source.owner.getEdges().splice(S, 1);
              }
            }, p.prototype.updateLeftTop = function() {
              for (var v = s.MAX_VALUE, m = s.MAX_VALUE, b, y, x, E = this.getNodes(), S = E.length, w = 0; w < S; w++) {
                var C = E[w];
                b = C.getTop(), y = C.getLeft(), v > b && (v = b), m > y && (m = y);
              }
              return v == s.MAX_VALUE ? null : (E[0].getParent().paddingLeft != null ? x = E[0].getParent().paddingLeft : x = this.margin, this.left = m - x, this.top = v - x, new h(this.left, this.top));
            }, p.prototype.updateBounds = function(v) {
              for (var m = s.MAX_VALUE, b = -s.MAX_VALUE, y = s.MAX_VALUE, x = -s.MAX_VALUE, E, S, w, C, k, N = this.nodes, R = N.length, _ = 0; _ < R; _++) {
                var O = N[_];
                v && O.child != null && O.updateBounds(), E = O.getLeft(), S = O.getRight(), w = O.getTop(), C = O.getBottom(), m > E && (m = E), b < S && (b = S), y > w && (y = w), x < C && (x = C);
              }
              var T = new f(m, y, b - m, x - y);
              m == s.MAX_VALUE && (this.left = this.parent.getLeft(), this.right = this.parent.getRight(), this.top = this.parent.getTop(), this.bottom = this.parent.getBottom()), N[0].getParent().paddingLeft != null ? k = N[0].getParent().paddingLeft : k = this.margin, this.left = T.x - k, this.right = T.x + T.width + k, this.top = T.y - k, this.bottom = T.y + T.height + k;
            }, p.calculateBounds = function(v) {
              for (var m = s.MAX_VALUE, b = -s.MAX_VALUE, y = s.MAX_VALUE, x = -s.MAX_VALUE, E, S, w, C, k = v.length, N = 0; N < k; N++) {
                var R = v[N];
                E = R.getLeft(), S = R.getRight(), w = R.getTop(), C = R.getBottom(), m > E && (m = E), b < S && (b = S), y > w && (y = w), x < C && (x = C);
              }
              var _ = new f(m, y, b - m, x - y);
              return _;
            }, p.prototype.getInclusionTreeDepth = function() {
              return this == this.graphManager.getRoot() ? 1 : this.parent.getInclusionTreeDepth();
            }, p.prototype.getEstimatedSize = function() {
              if (this.estimatedSize == s.MIN_VALUE)
                throw "assert failed";
              return this.estimatedSize;
            }, p.prototype.calcEstimatedSize = function() {
              for (var v = 0, m = this.nodes, b = m.length, y = 0; y < b; y++) {
                var x = m[y];
                v += x.calcEstimatedSize();
              }
              return v == 0 ? this.estimatedSize = o.EMPTY_COMPOUND_NODE_SIZE : this.estimatedSize = v / Math.sqrt(this.nodes.length), this.estimatedSize;
            }, p.prototype.updateConnected = function() {
              var v = this;
              if (this.nodes.length == 0) {
                this.isConnected = !0;
                return;
              }
              var m = new d(), b = /* @__PURE__ */ new Set(), y = this.nodes[0], x, E, S = y.withChildren();
              for (S.forEach(function(_) {
                m.push(_), b.add(_);
              }); m.length !== 0; ) {
                y = m.shift(), x = y.getEdges();
                for (var w = x.length, C = 0; C < w; C++) {
                  var k = x[C];
                  if (E = k.getOtherEndInGraph(y, this), E != null && !b.has(E)) {
                    var N = E.withChildren();
                    N.forEach(function(_) {
                      m.push(_), b.add(_);
                    });
                  }
                }
              }
              if (this.isConnected = !1, b.size >= this.nodes.length) {
                var R = 0;
                b.forEach(function(_) {
                  _.owner == v && R++;
                }), R == this.nodes.length && (this.isConnected = !0);
              }
            }, r.exports = p;
          },
          /* 6 */
          /***/
          function(r, n, a) {
            var i, s = a(1);
            function o(l) {
              i = a(5), this.layout = l, this.graphs = [], this.edges = [];
            }
            o.prototype.addRoot = function() {
              var l = this.layout.newGraph(), u = this.layout.newNode(null), c = this.add(l, u);
              return this.setRootGraph(c), this.rootGraph;
            }, o.prototype.add = function(l, u, c, f, h) {
              if (c == null && f == null && h == null) {
                if (l == null)
                  throw "Graph is null!";
                if (u == null)
                  throw "Parent node is null!";
                if (this.graphs.indexOf(l) > -1)
                  throw "Graph already in this graph mgr!";
                if (this.graphs.push(l), l.parent != null)
                  throw "Already has a parent!";
                if (u.child != null)
                  throw "Already has a child!";
                return l.parent = u, u.child = l, l;
              } else {
                h = c, f = u, c = l;
                var d = f.getOwner(), p = h.getOwner();
                if (!(d != null && d.getGraphManager() == this))
                  throw "Source not in this graph mgr!";
                if (!(p != null && p.getGraphManager() == this))
                  throw "Target not in this graph mgr!";
                if (d == p)
                  return c.isInterGraph = !1, d.add(c, f, h);
                if (c.isInterGraph = !0, c.source = f, c.target = h, this.edges.indexOf(c) > -1)
                  throw "Edge already in inter-graph edge list!";
                if (this.edges.push(c), !(c.source != null && c.target != null))
                  throw "Edge source and/or target is null!";
                if (!(c.source.edges.indexOf(c) == -1 && c.target.edges.indexOf(c) == -1))
                  throw "Edge already in source and/or target incidency list!";
                return c.source.edges.push(c), c.target.edges.push(c), c;
              }
            }, o.prototype.remove = function(l) {
              if (l instanceof i) {
                var u = l;
                if (u.getGraphManager() != this)
                  throw "Graph not in this graph mgr";
                if (!(u == this.rootGraph || u.parent != null && u.parent.graphManager == this))
                  throw "Invalid parent node!";
                var c = [];
                c = c.concat(u.getEdges());
                for (var f, h = c.length, d = 0; d < h; d++)
                  f = c[d], u.remove(f);
                var p = [];
                p = p.concat(u.getNodes());
                var g;
                h = p.length;
                for (var d = 0; d < h; d++)
                  g = p[d], u.remove(g);
                u == this.rootGraph && this.setRootGraph(null);
                var v = this.graphs.indexOf(u);
                this.graphs.splice(v, 1), u.parent = null;
              } else if (l instanceof s) {
                if (f = l, f == null)
                  throw "Edge is null!";
                if (!f.isInterGraph)
                  throw "Not an inter-graph edge!";
                if (!(f.source != null && f.target != null))
                  throw "Source and/or target is null!";
                if (!(f.source.edges.indexOf(f) != -1 && f.target.edges.indexOf(f) != -1))
                  throw "Source and/or target doesn't know this edge!";
                var v = f.source.edges.indexOf(f);
                if (f.source.edges.splice(v, 1), v = f.target.edges.indexOf(f), f.target.edges.splice(v, 1), !(f.source.owner != null && f.source.owner.getGraphManager() != null))
                  throw "Edge owner graph or owner graph manager is null!";
                if (f.source.owner.getGraphManager().edges.indexOf(f) == -1)
                  throw "Not in owner graph manager's edge list!";
                var v = f.source.owner.getGraphManager().edges.indexOf(f);
                f.source.owner.getGraphManager().edges.splice(v, 1);
              }
            }, o.prototype.updateBounds = function() {
              this.rootGraph.updateBounds(!0);
            }, o.prototype.getGraphs = function() {
              return this.graphs;
            }, o.prototype.getAllNodes = function() {
              if (this.allNodes == null) {
                for (var l = [], u = this.getGraphs(), c = u.length, f = 0; f < c; f++)
                  l = l.concat(u[f].getNodes());
                this.allNodes = l;
              }
              return this.allNodes;
            }, o.prototype.resetAllNodes = function() {
              this.allNodes = null;
            }, o.prototype.resetAllEdges = function() {
              this.allEdges = null;
            }, o.prototype.resetAllNodesToApplyGravitation = function() {
              this.allNodesToApplyGravitation = null;
            }, o.prototype.getAllEdges = function() {
              if (this.allEdges == null) {
                var l = [], u = this.getGraphs();
                u.length;
                for (var c = 0; c < u.length; c++)
                  l = l.concat(u[c].getEdges());
                l = l.concat(this.edges), this.allEdges = l;
              }
              return this.allEdges;
            }, o.prototype.getAllNodesToApplyGravitation = function() {
              return this.allNodesToApplyGravitation;
            }, o.prototype.setAllNodesToApplyGravitation = function(l) {
              if (this.allNodesToApplyGravitation != null)
                throw "assert failed";
              this.allNodesToApplyGravitation = l;
            }, o.prototype.getRoot = function() {
              return this.rootGraph;
            }, o.prototype.setRootGraph = function(l) {
              if (l.getGraphManager() != this)
                throw "Root not in this graph mgr!";
              this.rootGraph = l, l.parent == null && (l.parent = this.layout.newNode("Root node"));
            }, o.prototype.getLayout = function() {
              return this.layout;
            }, o.prototype.isOneAncestorOfOther = function(l, u) {
              if (!(l != null && u != null))
                throw "assert failed";
              if (l == u)
                return !0;
              var c = l.getOwner(), f;
              do {
                if (f = c.getParent(), f == null)
                  break;
                if (f == u)
                  return !0;
                if (c = f.getOwner(), c == null)
                  break;
              } while (!0);
              c = u.getOwner();
              do {
                if (f = c.getParent(), f == null)
                  break;
                if (f == l)
                  return !0;
                if (c = f.getOwner(), c == null)
                  break;
              } while (!0);
              return !1;
            }, o.prototype.calcLowestCommonAncestors = function() {
              for (var l, u, c, f, h, d = this.getAllEdges(), p = d.length, g = 0; g < p; g++) {
                if (l = d[g], u = l.source, c = l.target, l.lca = null, l.sourceInLca = u, l.targetInLca = c, u == c) {
                  l.lca = u.getOwner();
                  continue;
                }
                for (f = u.getOwner(); l.lca == null; ) {
                  for (l.targetInLca = c, h = c.getOwner(); l.lca == null; ) {
                    if (h == f) {
                      l.lca = h;
                      break;
                    }
                    if (h == this.rootGraph)
                      break;
                    if (l.lca != null)
                      throw "assert failed";
                    l.targetInLca = h.getParent(), h = l.targetInLca.getOwner();
                  }
                  if (f == this.rootGraph)
                    break;
                  l.lca == null && (l.sourceInLca = f.getParent(), f = l.sourceInLca.getOwner());
                }
                if (l.lca == null)
                  throw "assert failed";
              }
            }, o.prototype.calcLowestCommonAncestor = function(l, u) {
              if (l == u)
                return l.getOwner();
              var c = l.getOwner();
              do {
                if (c == null)
                  break;
                var f = u.getOwner();
                do {
                  if (f == null)
                    break;
                  if (f == c)
                    return f;
                  f = f.getParent().getOwner();
                } while (!0);
                c = c.getParent().getOwner();
              } while (!0);
              return c;
            }, o.prototype.calcInclusionTreeDepths = function(l, u) {
              l == null && u == null && (l = this.rootGraph, u = 1);
              for (var c, f = l.getNodes(), h = f.length, d = 0; d < h; d++)
                c = f[d], c.inclusionTreeDepth = u, c.child != null && this.calcInclusionTreeDepths(c.child, u + 1);
            }, o.prototype.includesInvalidEdge = function() {
              for (var l, u = this.edges.length, c = 0; c < u; c++)
                if (l = this.edges[c], this.isOneAncestorOfOther(l.source, l.target))
                  return !0;
              return !1;
            }, r.exports = o;
          },
          /* 7 */
          /***/
          function(r, n, a) {
            var i = a(0);
            function s() {
            }
            for (var o in i)
              s[o] = i[o];
            s.MAX_ITERATIONS = 2500, s.DEFAULT_EDGE_LENGTH = 50, s.DEFAULT_SPRING_STRENGTH = 0.45, s.DEFAULT_REPULSION_STRENGTH = 4500, s.DEFAULT_GRAVITY_STRENGTH = 0.4, s.DEFAULT_COMPOUND_GRAVITY_STRENGTH = 1, s.DEFAULT_GRAVITY_RANGE_FACTOR = 3.8, s.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = 1.5, s.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION = !0, s.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION = !0, s.DEFAULT_COOLING_FACTOR_INCREMENTAL = 0.3, s.COOLING_ADAPTATION_FACTOR = 0.33, s.ADAPTATION_LOWER_NODE_LIMIT = 1e3, s.ADAPTATION_UPPER_NODE_LIMIT = 5e3, s.MAX_NODE_DISPLACEMENT_INCREMENTAL = 100, s.MAX_NODE_DISPLACEMENT = s.MAX_NODE_DISPLACEMENT_INCREMENTAL * 3, s.MIN_REPULSION_DIST = s.DEFAULT_EDGE_LENGTH / 10, s.CONVERGENCE_CHECK_PERIOD = 100, s.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = 0.1, s.MIN_EDGE_LENGTH = 1, s.GRID_CALCULATION_CHECK_PERIOD = 10, r.exports = s;
          },
          /* 8 */
          /***/
          function(r, n, a) {
            var i = a(12);
            function s() {
            }
            s.calcSeparationAmount = function(o, l, u, c) {
              if (!o.intersects(l))
                throw "assert failed";
              var f = new Array(2);
              this.decideDirectionsForOverlappingNodes(o, l, f), u[0] = Math.min(o.getRight(), l.getRight()) - Math.max(o.x, l.x), u[1] = Math.min(o.getBottom(), l.getBottom()) - Math.max(o.y, l.y), o.getX() <= l.getX() && o.getRight() >= l.getRight() ? u[0] += Math.min(l.getX() - o.getX(), o.getRight() - l.getRight()) : l.getX() <= o.getX() && l.getRight() >= o.getRight() && (u[0] += Math.min(o.getX() - l.getX(), l.getRight() - o.getRight())), o.getY() <= l.getY() && o.getBottom() >= l.getBottom() ? u[1] += Math.min(l.getY() - o.getY(), o.getBottom() - l.getBottom()) : l.getY() <= o.getY() && l.getBottom() >= o.getBottom() && (u[1] += Math.min(o.getY() - l.getY(), l.getBottom() - o.getBottom()));
              var h = Math.abs((l.getCenterY() - o.getCenterY()) / (l.getCenterX() - o.getCenterX()));
              l.getCenterY() === o.getCenterY() && l.getCenterX() === o.getCenterX() && (h = 1);
              var d = h * u[0], p = u[1] / h;
              u[0] < p ? p = u[0] : d = u[1], u[0] = -1 * f[0] * (p / 2 + c), u[1] = -1 * f[1] * (d / 2 + c);
            }, s.decideDirectionsForOverlappingNodes = function(o, l, u) {
              o.getCenterX() < l.getCenterX() ? u[0] = -1 : u[0] = 1, o.getCenterY() < l.getCenterY() ? u[1] = -1 : u[1] = 1;
            }, s.getIntersection2 = function(o, l, u) {
              var c = o.getCenterX(), f = o.getCenterY(), h = l.getCenterX(), d = l.getCenterY();
              if (o.intersects(l))
                return u[0] = c, u[1] = f, u[2] = h, u[3] = d, !0;
              var p = o.getX(), g = o.getY(), v = o.getRight(), m = o.getX(), b = o.getBottom(), y = o.getRight(), x = o.getWidthHalf(), E = o.getHeightHalf(), S = l.getX(), w = l.getY(), C = l.getRight(), k = l.getX(), N = l.getBottom(), R = l.getRight(), _ = l.getWidthHalf(), O = l.getHeightHalf(), T = !1, L = !1;
              if (c === h) {
                if (f > d)
                  return u[0] = c, u[1] = g, u[2] = h, u[3] = N, !1;
                if (f < d)
                  return u[0] = c, u[1] = b, u[2] = h, u[3] = w, !1;
              } else if (f === d) {
                if (c > h)
                  return u[0] = p, u[1] = f, u[2] = C, u[3] = d, !1;
                if (c < h)
                  return u[0] = v, u[1] = f, u[2] = S, u[3] = d, !1;
              } else {
                var M = o.height / o.width, A = l.height / l.width, I = (d - f) / (h - c), D = void 0, F = void 0, B = void 0, G = void 0, H = void 0, K = void 0;
                if (-M === I ? c > h ? (u[0] = m, u[1] = b, T = !0) : (u[0] = v, u[1] = g, T = !0) : M === I && (c > h ? (u[0] = p, u[1] = g, T = !0) : (u[0] = y, u[1] = b, T = !0)), -A === I ? h > c ? (u[2] = k, u[3] = N, L = !0) : (u[2] = C, u[3] = w, L = !0) : A === I && (h > c ? (u[2] = S, u[3] = w, L = !0) : (u[2] = R, u[3] = N, L = !0)), T && L)
                  return !1;
                if (c > h ? f > d ? (D = this.getCardinalDirection(M, I, 4), F = this.getCardinalDirection(A, I, 2)) : (D = this.getCardinalDirection(-M, I, 3), F = this.getCardinalDirection(-A, I, 1)) : f > d ? (D = this.getCardinalDirection(-M, I, 1), F = this.getCardinalDirection(-A, I, 3)) : (D = this.getCardinalDirection(M, I, 2), F = this.getCardinalDirection(A, I, 4)), !T)
                  switch (D) {
                    case 1:
                      G = g, B = c + -E / I, u[0] = B, u[1] = G;
                      break;
                    case 2:
                      B = y, G = f + x * I, u[0] = B, u[1] = G;
                      break;
                    case 3:
                      G = b, B = c + E / I, u[0] = B, u[1] = G;
                      break;
                    case 4:
                      B = m, G = f + -x * I, u[0] = B, u[1] = G;
                      break;
                  }
                if (!L)
                  switch (F) {
                    case 1:
                      K = w, H = h + -O / I, u[2] = H, u[3] = K;
                      break;
                    case 2:
                      H = R, K = d + _ * I, u[2] = H, u[3] = K;
                      break;
                    case 3:
                      K = N, H = h + O / I, u[2] = H, u[3] = K;
                      break;
                    case 4:
                      H = k, K = d + -_ * I, u[2] = H, u[3] = K;
                      break;
                  }
              }
              return !1;
            }, s.getCardinalDirection = function(o, l, u) {
              return o > l ? u : 1 + u % 4;
            }, s.getIntersection = function(o, l, u, c) {
              if (c == null)
                return this.getIntersection2(o, l, u);
              var f = o.x, h = o.y, d = l.x, p = l.y, g = u.x, v = u.y, m = c.x, b = c.y, y = void 0, x = void 0, E = void 0, S = void 0, w = void 0, C = void 0, k = void 0, N = void 0, R = void 0;
              return E = p - h, w = f - d, k = d * h - f * p, S = b - v, C = g - m, N = m * v - g * b, R = E * C - S * w, R === 0 ? null : (y = (w * N - C * k) / R, x = (S * k - E * N) / R, new i(y, x));
            }, s.angleOfVector = function(o, l, u, c) {
              var f = void 0;
              return o !== u ? (f = Math.atan((c - l) / (u - o)), u < o ? f += Math.PI : c < l && (f += this.TWO_PI)) : c < l ? f = this.ONE_AND_HALF_PI : f = this.HALF_PI, f;
            }, s.doIntersect = function(o, l, u, c) {
              var f = o.x, h = o.y, d = l.x, p = l.y, g = u.x, v = u.y, m = c.x, b = c.y, y = (d - f) * (b - v) - (m - g) * (p - h);
              if (y === 0)
                return !1;
              var x = ((b - v) * (m - f) + (g - m) * (b - h)) / y, E = ((h - p) * (m - f) + (d - f) * (b - h)) / y;
              return 0 < x && x < 1 && 0 < E && E < 1;
            }, s.HALF_PI = 0.5 * Math.PI, s.ONE_AND_HALF_PI = 1.5 * Math.PI, s.TWO_PI = 2 * Math.PI, s.THREE_PI = 3 * Math.PI, r.exports = s;
          },
          /* 9 */
          /***/
          function(r, n, a) {
            function i() {
            }
            i.sign = function(s) {
              return s > 0 ? 1 : s < 0 ? -1 : 0;
            }, i.floor = function(s) {
              return s < 0 ? Math.ceil(s) : Math.floor(s);
            }, i.ceil = function(s) {
              return s < 0 ? Math.floor(s) : Math.ceil(s);
            }, r.exports = i;
          },
          /* 10 */
          /***/
          function(r, n, a) {
            function i() {
            }
            i.MAX_VALUE = 2147483647, i.MIN_VALUE = -2147483648, r.exports = i;
          },
          /* 11 */
          /***/
          function(r, n, a) {
            var i = /* @__PURE__ */ function() {
              function f(h, d) {
                for (var p = 0; p < d.length; p++) {
                  var g = d[p];
                  g.enumerable = g.enumerable || !1, g.configurable = !0, "value" in g && (g.writable = !0), Object.defineProperty(h, g.key, g);
                }
              }
              return function(h, d, p) {
                return d && f(h.prototype, d), p && f(h, p), h;
              };
            }();
            function s(f, h) {
              if (!(f instanceof h))
                throw new TypeError("Cannot call a class as a function");
            }
            var o = function(h) {
              return { value: h, next: null, prev: null };
            }, l = function(h, d, p, g) {
              return h !== null ? h.next = d : g.head = d, p !== null ? p.prev = d : g.tail = d, d.prev = h, d.next = p, g.length++, d;
            }, u = function(h, d) {
              var p = h.prev, g = h.next;
              return p !== null ? p.next = g : d.head = g, g !== null ? g.prev = p : d.tail = p, h.prev = h.next = null, d.length--, h;
            }, c = function() {
              function f(h) {
                var d = this;
                s(this, f), this.length = 0, this.head = null, this.tail = null, h != null && h.forEach(function(p) {
                  return d.push(p);
                });
              }
              return i(f, [{
                key: "size",
                value: function() {
                  return this.length;
                }
              }, {
                key: "insertBefore",
                value: function(d, p) {
                  return l(p.prev, o(d), p, this);
                }
              }, {
                key: "insertAfter",
                value: function(d, p) {
                  return l(p, o(d), p.next, this);
                }
              }, {
                key: "insertNodeBefore",
                value: function(d, p) {
                  return l(p.prev, d, p, this);
                }
              }, {
                key: "insertNodeAfter",
                value: function(d, p) {
                  return l(p, d, p.next, this);
                }
              }, {
                key: "push",
                value: function(d) {
                  return l(this.tail, o(d), null, this);
                }
              }, {
                key: "unshift",
                value: function(d) {
                  return l(null, o(d), this.head, this);
                }
              }, {
                key: "remove",
                value: function(d) {
                  return u(d, this);
                }
              }, {
                key: "pop",
                value: function() {
                  return u(this.tail, this).value;
                }
              }, {
                key: "popNode",
                value: function() {
                  return u(this.tail, this);
                }
              }, {
                key: "shift",
                value: function() {
                  return u(this.head, this).value;
                }
              }, {
                key: "shiftNode",
                value: function() {
                  return u(this.head, this);
                }
              }, {
                key: "get_object_at",
                value: function(d) {
                  if (d <= this.length()) {
                    for (var p = 1, g = this.head; p < d; )
                      g = g.next, p++;
                    return g.value;
                  }
                }
              }, {
                key: "set_object_at",
                value: function(d, p) {
                  if (d <= this.length()) {
                    for (var g = 1, v = this.head; g < d; )
                      v = v.next, g++;
                    v.value = p;
                  }
                }
              }]), f;
            }();
            r.exports = c;
          },
          /* 12 */
          /***/
          function(r, n, a) {
            function i(s, o, l) {
              this.x = null, this.y = null, s == null && o == null && l == null ? (this.x = 0, this.y = 0) : typeof s == "number" && typeof o == "number" && l == null ? (this.x = s, this.y = o) : s.constructor.name == "Point" && o == null && l == null && (l = s, this.x = l.x, this.y = l.y);
            }
            i.prototype.getX = function() {
              return this.x;
            }, i.prototype.getY = function() {
              return this.y;
            }, i.prototype.getLocation = function() {
              return new i(this.x, this.y);
            }, i.prototype.setLocation = function(s, o, l) {
              s.constructor.name == "Point" && o == null && l == null ? (l = s, this.setLocation(l.x, l.y)) : typeof s == "number" && typeof o == "number" && l == null && (parseInt(s) == s && parseInt(o) == o ? this.move(s, o) : (this.x = Math.floor(s + 0.5), this.y = Math.floor(o + 0.5)));
            }, i.prototype.move = function(s, o) {
              this.x = s, this.y = o;
            }, i.prototype.translate = function(s, o) {
              this.x += s, this.y += o;
            }, i.prototype.equals = function(s) {
              if (s.constructor.name == "Point") {
                var o = s;
                return this.x == o.x && this.y == o.y;
              }
              return this == s;
            }, i.prototype.toString = function() {
              return new i().constructor.name + "[x=" + this.x + ",y=" + this.y + "]";
            }, r.exports = i;
          },
          /* 13 */
          /***/
          function(r, n, a) {
            function i(s, o, l, u) {
              this.x = 0, this.y = 0, this.width = 0, this.height = 0, s != null && o != null && l != null && u != null && (this.x = s, this.y = o, this.width = l, this.height = u);
            }
            i.prototype.getX = function() {
              return this.x;
            }, i.prototype.setX = function(s) {
              this.x = s;
            }, i.prototype.getY = function() {
              return this.y;
            }, i.prototype.setY = function(s) {
              this.y = s;
            }, i.prototype.getWidth = function() {
              return this.width;
            }, i.prototype.setWidth = function(s) {
              this.width = s;
            }, i.prototype.getHeight = function() {
              return this.height;
            }, i.prototype.setHeight = function(s) {
              this.height = s;
            }, i.prototype.getRight = function() {
              return this.x + this.width;
            }, i.prototype.getBottom = function() {
              return this.y + this.height;
            }, i.prototype.intersects = function(s) {
              return !(this.getRight() < s.x || this.getBottom() < s.y || s.getRight() < this.x || s.getBottom() < this.y);
            }, i.prototype.getCenterX = function() {
              return this.x + this.width / 2;
            }, i.prototype.getMinX = function() {
              return this.getX();
            }, i.prototype.getMaxX = function() {
              return this.getX() + this.width;
            }, i.prototype.getCenterY = function() {
              return this.y + this.height / 2;
            }, i.prototype.getMinY = function() {
              return this.getY();
            }, i.prototype.getMaxY = function() {
              return this.getY() + this.height;
            }, i.prototype.getWidthHalf = function() {
              return this.width / 2;
            }, i.prototype.getHeightHalf = function() {
              return this.height / 2;
            }, r.exports = i;
          },
          /* 14 */
          /***/
          function(r, n, a) {
            var i = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o) {
              return typeof o;
            } : function(o) {
              return o && typeof Symbol == "function" && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
            };
            function s() {
            }
            s.lastID = 0, s.createID = function(o) {
              return s.isPrimitive(o) ? o : (o.uniqueID != null || (o.uniqueID = s.getString(), s.lastID++), o.uniqueID);
            }, s.getString = function(o) {
              return o == null && (o = s.lastID), "Object#" + o;
            }, s.isPrimitive = function(o) {
              var l = typeof o > "u" ? "undefined" : i(o);
              return o == null || l != "object" && l != "function";
            }, r.exports = s;
          },
          /* 15 */
          /***/
          function(r, n, a) {
            function i(g) {
              if (Array.isArray(g)) {
                for (var v = 0, m = Array(g.length); v < g.length; v++)
                  m[v] = g[v];
                return m;
              } else
                return Array.from(g);
            }
            var s = a(0), o = a(6), l = a(3), u = a(1), c = a(5), f = a(4), h = a(17), d = a(27);
            function p(g) {
              d.call(this), this.layoutQuality = s.QUALITY, this.createBendsAsNeeded = s.DEFAULT_CREATE_BENDS_AS_NEEDED, this.incremental = s.DEFAULT_INCREMENTAL, this.animationOnLayout = s.DEFAULT_ANIMATION_ON_LAYOUT, this.animationDuringLayout = s.DEFAULT_ANIMATION_DURING_LAYOUT, this.animationPeriod = s.DEFAULT_ANIMATION_PERIOD, this.uniformLeafNodeSizes = s.DEFAULT_UNIFORM_LEAF_NODE_SIZES, this.edgeToDummyNodes = /* @__PURE__ */ new Map(), this.graphManager = new o(this), this.isLayoutFinished = !1, this.isSubLayout = !1, this.isRemoteUse = !1, g != null && (this.isRemoteUse = g);
            }
            p.RANDOM_SEED = 1, p.prototype = Object.create(d.prototype), p.prototype.getGraphManager = function() {
              return this.graphManager;
            }, p.prototype.getAllNodes = function() {
              return this.graphManager.getAllNodes();
            }, p.prototype.getAllEdges = function() {
              return this.graphManager.getAllEdges();
            }, p.prototype.getAllNodesToApplyGravitation = function() {
              return this.graphManager.getAllNodesToApplyGravitation();
            }, p.prototype.newGraphManager = function() {
              var g = new o(this);
              return this.graphManager = g, g;
            }, p.prototype.newGraph = function(g) {
              return new c(null, this.graphManager, g);
            }, p.prototype.newNode = function(g) {
              return new l(this.graphManager, g);
            }, p.prototype.newEdge = function(g) {
              return new u(null, null, g);
            }, p.prototype.checkLayoutSuccess = function() {
              return this.graphManager.getRoot() == null || this.graphManager.getRoot().getNodes().length == 0 || this.graphManager.includesInvalidEdge();
            }, p.prototype.runLayout = function() {
              this.isLayoutFinished = !1, this.tilingPreLayout && this.tilingPreLayout(), this.initParameters();
              var g;
              return this.checkLayoutSuccess() ? g = !1 : g = this.layout(), s.ANIMATE === "during" ? !1 : (g && (this.isSubLayout || this.doPostLayout()), this.tilingPostLayout && this.tilingPostLayout(), this.isLayoutFinished = !0, g);
            }, p.prototype.doPostLayout = function() {
              this.incremental || this.transform(), this.update();
            }, p.prototype.update2 = function() {
              if (this.createBendsAsNeeded && (this.createBendpointsFromDummyNodes(), this.graphManager.resetAllEdges()), !this.isRemoteUse) {
                for (var g = this.graphManager.getAllEdges(), v = 0; v < g.length; v++)
                  g[v];
                for (var m = this.graphManager.getRoot().getNodes(), v = 0; v < m.length; v++)
                  m[v];
                this.update(this.graphManager.getRoot());
              }
            }, p.prototype.update = function(g) {
              if (g == null)
                this.update2();
              else if (g instanceof l) {
                var v = g;
                if (v.getChild() != null)
                  for (var m = v.getChild().getNodes(), b = 0; b < m.length; b++)
                    update(m[b]);
                if (v.vGraphObject != null) {
                  var y = v.vGraphObject;
                  y.update(v);
                }
              } else if (g instanceof u) {
                var x = g;
                if (x.vGraphObject != null) {
                  var E = x.vGraphObject;
                  E.update(x);
                }
              } else if (g instanceof c) {
                var S = g;
                if (S.vGraphObject != null) {
                  var w = S.vGraphObject;
                  w.update(S);
                }
              }
            }, p.prototype.initParameters = function() {
              this.isSubLayout || (this.layoutQuality = s.QUALITY, this.animationDuringLayout = s.DEFAULT_ANIMATION_DURING_LAYOUT, this.animationPeriod = s.DEFAULT_ANIMATION_PERIOD, this.animationOnLayout = s.DEFAULT_ANIMATION_ON_LAYOUT, this.incremental = s.DEFAULT_INCREMENTAL, this.createBendsAsNeeded = s.DEFAULT_CREATE_BENDS_AS_NEEDED, this.uniformLeafNodeSizes = s.DEFAULT_UNIFORM_LEAF_NODE_SIZES), this.animationDuringLayout && (this.animationOnLayout = !1);
            }, p.prototype.transform = function(g) {
              if (g == null)
                this.transform(new f(0, 0));
              else {
                var v = new h(), m = this.graphManager.getRoot().updateLeftTop();
                if (m != null) {
                  v.setWorldOrgX(g.x), v.setWorldOrgY(g.y), v.setDeviceOrgX(m.x), v.setDeviceOrgY(m.y);
                  for (var b = this.getAllNodes(), y, x = 0; x < b.length; x++)
                    y = b[x], y.transform(v);
                }
              }
            }, p.prototype.positionNodesRandomly = function(g) {
              if (g == null)
                this.positionNodesRandomly(this.getGraphManager().getRoot()), this.getGraphManager().getRoot().updateBounds(!0);
              else
                for (var v, m, b = g.getNodes(), y = 0; y < b.length; y++)
                  v = b[y], m = v.getChild(), m == null || m.getNodes().length == 0 ? v.scatter() : (this.positionNodesRandomly(m), v.updateBounds());
            }, p.prototype.getFlatForest = function() {
              for (var g = [], v = !0, m = this.graphManager.getRoot().getNodes(), b = !0, y = 0; y < m.length; y++)
                m[y].getChild() != null && (b = !1);
              if (!b)
                return g;
              var x = /* @__PURE__ */ new Set(), E = [], S = /* @__PURE__ */ new Map(), w = [];
              for (w = w.concat(m); w.length > 0 && v; ) {
                for (E.push(w[0]); E.length > 0 && v; ) {
                  var C = E[0];
                  E.splice(0, 1), x.add(C);
                  for (var k = C.getEdges(), y = 0; y < k.length; y++) {
                    var N = k[y].getOtherEnd(C);
                    if (S.get(C) != N)
                      if (!x.has(N))
                        E.push(N), S.set(N, C);
                      else {
                        v = !1;
                        break;
                      }
                  }
                }
                if (!v)
                  g = [];
                else {
                  var R = [].concat(i(x));
                  g.push(R);
                  for (var y = 0; y < R.length; y++) {
                    var _ = R[y], O = w.indexOf(_);
                    O > -1 && w.splice(O, 1);
                  }
                  x = /* @__PURE__ */ new Set(), S = /* @__PURE__ */ new Map();
                }
              }
              return g;
            }, p.prototype.createDummyNodesForBendpoints = function(g) {
              for (var v = [], m = g.source, b = this.graphManager.calcLowestCommonAncestor(g.source, g.target), y = 0; y < g.bendpoints.length; y++) {
                var x = this.newNode(null);
                x.setRect(new Point(0, 0), new Dimension(1, 1)), b.add(x);
                var E = this.newEdge(null);
                this.graphManager.add(E, m, x), v.add(x), m = x;
              }
              var E = this.newEdge(null);
              return this.graphManager.add(E, m, g.target), this.edgeToDummyNodes.set(g, v), g.isInterGraph() ? this.graphManager.remove(g) : b.remove(g), v;
            }, p.prototype.createBendpointsFromDummyNodes = function() {
              var g = [];
              g = g.concat(this.graphManager.getAllEdges()), g = [].concat(i(this.edgeToDummyNodes.keys())).concat(g);
              for (var v = 0; v < g.length; v++) {
                var m = g[v];
                if (m.bendpoints.length > 0) {
                  for (var b = this.edgeToDummyNodes.get(m), y = 0; y < b.length; y++) {
                    var x = b[y], E = new f(x.getCenterX(), x.getCenterY()), S = m.bendpoints.get(y);
                    S.x = E.x, S.y = E.y, x.getOwner().remove(x);
                  }
                  this.graphManager.add(m, m.source, m.target);
                }
              }
            }, p.transform = function(g, v, m, b) {
              if (m != null && b != null) {
                var y = v;
                if (g <= 50) {
                  var x = v / m;
                  y -= (v - x) / 50 * (50 - g);
                } else {
                  var E = v * b;
                  y += (E - v) / 50 * (g - 50);
                }
                return y;
              } else {
                var S, w;
                return g <= 50 ? (S = 9 * v / 500, w = v / 10) : (S = 9 * v / 50, w = -8 * v), S * g + w;
              }
            }, p.findCenterOfTree = function(g) {
              var v = [];
              v = v.concat(g);
              var m = [], b = /* @__PURE__ */ new Map(), y = !1, x = null;
              (v.length == 1 || v.length == 2) && (y = !0, x = v[0]);
              for (var E = 0; E < v.length; E++) {
                var S = v[E], w = S.getNeighborsList().size;
                b.set(S, S.getNeighborsList().size), w == 1 && m.push(S);
              }
              var C = [];
              for (C = C.concat(m); !y; ) {
                var k = [];
                k = k.concat(C), C = [];
                for (var E = 0; E < v.length; E++) {
                  var S = v[E], N = v.indexOf(S);
                  N >= 0 && v.splice(N, 1);
                  var R = S.getNeighborsList();
                  R.forEach(function(T) {
                    if (m.indexOf(T) < 0) {
                      var L = b.get(T), M = L - 1;
                      M == 1 && C.push(T), b.set(T, M);
                    }
                  });
                }
                m = m.concat(C), (v.length == 1 || v.length == 2) && (y = !0, x = v[0]);
              }
              return x;
            }, p.prototype.setGraphManager = function(g) {
              this.graphManager = g;
            }, r.exports = p;
          },
          /* 16 */
          /***/
          function(r, n, a) {
            function i() {
            }
            i.seed = 1, i.x = 0, i.nextDouble = function() {
              return i.x = Math.sin(i.seed++) * 1e4, i.x - Math.floor(i.x);
            }, r.exports = i;
          },
          /* 17 */
          /***/
          function(r, n, a) {
            var i = a(4);
            function s(o, l) {
              this.lworldOrgX = 0, this.lworldOrgY = 0, this.ldeviceOrgX = 0, this.ldeviceOrgY = 0, this.lworldExtX = 1, this.lworldExtY = 1, this.ldeviceExtX = 1, this.ldeviceExtY = 1;
            }
            s.prototype.getWorldOrgX = function() {
              return this.lworldOrgX;
            }, s.prototype.setWorldOrgX = function(o) {
              this.lworldOrgX = o;
            }, s.prototype.getWorldOrgY = function() {
              return this.lworldOrgY;
            }, s.prototype.setWorldOrgY = function(o) {
              this.lworldOrgY = o;
            }, s.prototype.getWorldExtX = function() {
              return this.lworldExtX;
            }, s.prototype.setWorldExtX = function(o) {
              this.lworldExtX = o;
            }, s.prototype.getWorldExtY = function() {
              return this.lworldExtY;
            }, s.prototype.setWorldExtY = function(o) {
              this.lworldExtY = o;
            }, s.prototype.getDeviceOrgX = function() {
              return this.ldeviceOrgX;
            }, s.prototype.setDeviceOrgX = function(o) {
              this.ldeviceOrgX = o;
            }, s.prototype.getDeviceOrgY = function() {
              return this.ldeviceOrgY;
            }, s.prototype.setDeviceOrgY = function(o) {
              this.ldeviceOrgY = o;
            }, s.prototype.getDeviceExtX = function() {
              return this.ldeviceExtX;
            }, s.prototype.setDeviceExtX = function(o) {
              this.ldeviceExtX = o;
            }, s.prototype.getDeviceExtY = function() {
              return this.ldeviceExtY;
            }, s.prototype.setDeviceExtY = function(o) {
              this.ldeviceExtY = o;
            }, s.prototype.transformX = function(o) {
              var l = 0, u = this.lworldExtX;
              return u != 0 && (l = this.ldeviceOrgX + (o - this.lworldOrgX) * this.ldeviceExtX / u), l;
            }, s.prototype.transformY = function(o) {
              var l = 0, u = this.lworldExtY;
              return u != 0 && (l = this.ldeviceOrgY + (o - this.lworldOrgY) * this.ldeviceExtY / u), l;
            }, s.prototype.inverseTransformX = function(o) {
              var l = 0, u = this.ldeviceExtX;
              return u != 0 && (l = this.lworldOrgX + (o - this.ldeviceOrgX) * this.lworldExtX / u), l;
            }, s.prototype.inverseTransformY = function(o) {
              var l = 0, u = this.ldeviceExtY;
              return u != 0 && (l = this.lworldOrgY + (o - this.ldeviceOrgY) * this.lworldExtY / u), l;
            }, s.prototype.inverseTransformPoint = function(o) {
              var l = new i(this.inverseTransformX(o.x), this.inverseTransformY(o.y));
              return l;
            }, r.exports = s;
          },
          /* 18 */
          /***/
          function(r, n, a) {
            function i(d) {
              if (Array.isArray(d)) {
                for (var p = 0, g = Array(d.length); p < d.length; p++)
                  g[p] = d[p];
                return g;
              } else
                return Array.from(d);
            }
            var s = a(15), o = a(7), l = a(0), u = a(8), c = a(9);
            function f() {
              s.call(this), this.useSmartIdealEdgeLengthCalculation = o.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION, this.idealEdgeLength = o.DEFAULT_EDGE_LENGTH, this.springConstant = o.DEFAULT_SPRING_STRENGTH, this.repulsionConstant = o.DEFAULT_REPULSION_STRENGTH, this.gravityConstant = o.DEFAULT_GRAVITY_STRENGTH, this.compoundGravityConstant = o.DEFAULT_COMPOUND_GRAVITY_STRENGTH, this.gravityRangeFactor = o.DEFAULT_GRAVITY_RANGE_FACTOR, this.compoundGravityRangeFactor = o.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR, this.displacementThresholdPerNode = 3 * o.DEFAULT_EDGE_LENGTH / 100, this.coolingFactor = o.DEFAULT_COOLING_FACTOR_INCREMENTAL, this.initialCoolingFactor = o.DEFAULT_COOLING_FACTOR_INCREMENTAL, this.totalDisplacement = 0, this.oldTotalDisplacement = 0, this.maxIterations = o.MAX_ITERATIONS;
            }
            f.prototype = Object.create(s.prototype);
            for (var h in s)
              f[h] = s[h];
            f.prototype.initParameters = function() {
              s.prototype.initParameters.call(this, arguments), this.totalIterations = 0, this.notAnimatedIterations = 0, this.useFRGridVariant = o.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION, this.grid = [];
            }, f.prototype.calcIdealEdgeLengths = function() {
              for (var d, p, g, v, m, b, y = this.getGraphManager().getAllEdges(), x = 0; x < y.length; x++)
                d = y[x], d.idealLength = this.idealEdgeLength, d.isInterGraph && (g = d.getSource(), v = d.getTarget(), m = d.getSourceInLca().getEstimatedSize(), b = d.getTargetInLca().getEstimatedSize(), this.useSmartIdealEdgeLengthCalculation && (d.idealLength += m + b - 2 * l.SIMPLE_NODE_SIZE), p = d.getLca().getInclusionTreeDepth(), d.idealLength += o.DEFAULT_EDGE_LENGTH * o.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR * (g.getInclusionTreeDepth() + v.getInclusionTreeDepth() - 2 * p));
            }, f.prototype.initSpringEmbedder = function() {
              var d = this.getAllNodes().length;
              this.incremental ? (d > o.ADAPTATION_LOWER_NODE_LIMIT && (this.coolingFactor = Math.max(this.coolingFactor * o.COOLING_ADAPTATION_FACTOR, this.coolingFactor - (d - o.ADAPTATION_LOWER_NODE_LIMIT) / (o.ADAPTATION_UPPER_NODE_LIMIT - o.ADAPTATION_LOWER_NODE_LIMIT) * this.coolingFactor * (1 - o.COOLING_ADAPTATION_FACTOR))), this.maxNodeDisplacement = o.MAX_NODE_DISPLACEMENT_INCREMENTAL) : (d > o.ADAPTATION_LOWER_NODE_LIMIT ? this.coolingFactor = Math.max(o.COOLING_ADAPTATION_FACTOR, 1 - (d - o.ADAPTATION_LOWER_NODE_LIMIT) / (o.ADAPTATION_UPPER_NODE_LIMIT - o.ADAPTATION_LOWER_NODE_LIMIT) * (1 - o.COOLING_ADAPTATION_FACTOR)) : this.coolingFactor = 1, this.initialCoolingFactor = this.coolingFactor, this.maxNodeDisplacement = o.MAX_NODE_DISPLACEMENT), this.maxIterations = Math.max(this.getAllNodes().length * 5, this.maxIterations), this.totalDisplacementThreshold = this.displacementThresholdPerNode * this.getAllNodes().length, this.repulsionRange = this.calcRepulsionRange();
            }, f.prototype.calcSpringForces = function() {
              for (var d = this.getAllEdges(), p, g = 0; g < d.length; g++)
                p = d[g], this.calcSpringForce(p, p.idealLength);
            }, f.prototype.calcRepulsionForces = function() {
              var d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0, p = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, g, v, m, b, y = this.getAllNodes(), x;
              if (this.useFRGridVariant)
                for (this.totalIterations % o.GRID_CALCULATION_CHECK_PERIOD == 1 && d && this.updateGrid(), x = /* @__PURE__ */ new Set(), g = 0; g < y.length; g++)
                  m = y[g], this.calculateRepulsionForceOfANode(m, x, d, p), x.add(m);
              else
                for (g = 0; g < y.length; g++)
                  for (m = y[g], v = g + 1; v < y.length; v++)
                    b = y[v], m.getOwner() == b.getOwner() && this.calcRepulsionForce(m, b);
            }, f.prototype.calcGravitationalForces = function() {
              for (var d, p = this.getAllNodesToApplyGravitation(), g = 0; g < p.length; g++)
                d = p[g], this.calcGravitationalForce(d);
            }, f.prototype.moveNodes = function() {
              for (var d = this.getAllNodes(), p, g = 0; g < d.length; g++)
                p = d[g], p.move();
            }, f.prototype.calcSpringForce = function(d, p) {
              var g = d.getSource(), v = d.getTarget(), m, b, y, x;
              if (this.uniformLeafNodeSizes && g.getChild() == null && v.getChild() == null)
                d.updateLengthSimple();
              else if (d.updateLength(), d.isOverlapingSourceAndTarget)
                return;
              m = d.getLength(), m != 0 && (b = this.springConstant * (m - p), y = b * (d.lengthX / m), x = b * (d.lengthY / m), g.springForceX += y, g.springForceY += x, v.springForceX -= y, v.springForceY -= x);
            }, f.prototype.calcRepulsionForce = function(d, p) {
              var g = d.getRect(), v = p.getRect(), m = new Array(2), b = new Array(4), y, x, E, S, w, C, k;
              if (g.intersects(v)) {
                u.calcSeparationAmount(g, v, m, o.DEFAULT_EDGE_LENGTH / 2), C = 2 * m[0], k = 2 * m[1];
                var N = d.noOfChildren * p.noOfChildren / (d.noOfChildren + p.noOfChildren);
                d.repulsionForceX -= N * C, d.repulsionForceY -= N * k, p.repulsionForceX += N * C, p.repulsionForceY += N * k;
              } else
                this.uniformLeafNodeSizes && d.getChild() == null && p.getChild() == null ? (y = v.getCenterX() - g.getCenterX(), x = v.getCenterY() - g.getCenterY()) : (u.getIntersection(g, v, b), y = b[2] - b[0], x = b[3] - b[1]), Math.abs(y) < o.MIN_REPULSION_DIST && (y = c.sign(y) * o.MIN_REPULSION_DIST), Math.abs(x) < o.MIN_REPULSION_DIST && (x = c.sign(x) * o.MIN_REPULSION_DIST), E = y * y + x * x, S = Math.sqrt(E), w = this.repulsionConstant * d.noOfChildren * p.noOfChildren / E, C = w * y / S, k = w * x / S, d.repulsionForceX -= C, d.repulsionForceY -= k, p.repulsionForceX += C, p.repulsionForceY += k;
            }, f.prototype.calcGravitationalForce = function(d) {
              var p, g, v, m, b, y, x, E;
              p = d.getOwner(), g = (p.getRight() + p.getLeft()) / 2, v = (p.getTop() + p.getBottom()) / 2, m = d.getCenterX() - g, b = d.getCenterY() - v, y = Math.abs(m) + d.getWidth() / 2, x = Math.abs(b) + d.getHeight() / 2, d.getOwner() == this.graphManager.getRoot() ? (E = p.getEstimatedSize() * this.gravityRangeFactor, (y > E || x > E) && (d.gravitationForceX = -this.gravityConstant * m, d.gravitationForceY = -this.gravityConstant * b)) : (E = p.getEstimatedSize() * this.compoundGravityRangeFactor, (y > E || x > E) && (d.gravitationForceX = -this.gravityConstant * m * this.compoundGravityConstant, d.gravitationForceY = -this.gravityConstant * b * this.compoundGravityConstant));
            }, f.prototype.isConverged = function() {
              var d, p = !1;
              return this.totalIterations > this.maxIterations / 3 && (p = Math.abs(this.totalDisplacement - this.oldTotalDisplacement) < 2), d = this.totalDisplacement < this.totalDisplacementThreshold, this.oldTotalDisplacement = this.totalDisplacement, d || p;
            }, f.prototype.animate = function() {
              this.animationDuringLayout && !this.isSubLayout && (this.notAnimatedIterations == this.animationPeriod ? (this.update(), this.notAnimatedIterations = 0) : this.notAnimatedIterations++);
            }, f.prototype.calcNoOfChildrenForAllNodes = function() {
              for (var d, p = this.graphManager.getAllNodes(), g = 0; g < p.length; g++)
                d = p[g], d.noOfChildren = d.getNoOfChildren();
            }, f.prototype.calcGrid = function(d) {
              var p = 0, g = 0;
              p = parseInt(Math.ceil((d.getRight() - d.getLeft()) / this.repulsionRange)), g = parseInt(Math.ceil((d.getBottom() - d.getTop()) / this.repulsionRange));
              for (var v = new Array(p), m = 0; m < p; m++)
                v[m] = new Array(g);
              for (var m = 0; m < p; m++)
                for (var b = 0; b < g; b++)
                  v[m][b] = new Array();
              return v;
            }, f.prototype.addNodeToGrid = function(d, p, g) {
              var v = 0, m = 0, b = 0, y = 0;
              v = parseInt(Math.floor((d.getRect().x - p) / this.repulsionRange)), m = parseInt(Math.floor((d.getRect().width + d.getRect().x - p) / this.repulsionRange)), b = parseInt(Math.floor((d.getRect().y - g) / this.repulsionRange)), y = parseInt(Math.floor((d.getRect().height + d.getRect().y - g) / this.repulsionRange));
              for (var x = v; x <= m; x++)
                for (var E = b; E <= y; E++)
                  this.grid[x][E].push(d), d.setGridCoordinates(v, m, b, y);
            }, f.prototype.updateGrid = function() {
              var d, p, g = this.getAllNodes();
              for (this.grid = this.calcGrid(this.graphManager.getRoot()), d = 0; d < g.length; d++)
                p = g[d], this.addNodeToGrid(p, this.graphManager.getRoot().getLeft(), this.graphManager.getRoot().getTop());
            }, f.prototype.calculateRepulsionForceOfANode = function(d, p, g, v) {
              if (this.totalIterations % o.GRID_CALCULATION_CHECK_PERIOD == 1 && g || v) {
                var m = /* @__PURE__ */ new Set();
                d.surrounding = new Array();
                for (var b, y = this.grid, x = d.startX - 1; x < d.finishX + 2; x++)
                  for (var E = d.startY - 1; E < d.finishY + 2; E++)
                    if (!(x < 0 || E < 0 || x >= y.length || E >= y[0].length)) {
                      for (var S = 0; S < y[x][E].length; S++)
                        if (b = y[x][E][S], !(d.getOwner() != b.getOwner() || d == b) && !p.has(b) && !m.has(b)) {
                          var w = Math.abs(d.getCenterX() - b.getCenterX()) - (d.getWidth() / 2 + b.getWidth() / 2), C = Math.abs(d.getCenterY() - b.getCenterY()) - (d.getHeight() / 2 + b.getHeight() / 2);
                          w <= this.repulsionRange && C <= this.repulsionRange && m.add(b);
                        }
                    }
                d.surrounding = [].concat(i(m));
              }
              for (x = 0; x < d.surrounding.length; x++)
                this.calcRepulsionForce(d, d.surrounding[x]);
            }, f.prototype.calcRepulsionRange = function() {
              return 0;
            }, r.exports = f;
          },
          /* 19 */
          /***/
          function(r, n, a) {
            var i = a(1), s = a(7);
            function o(u, c, f) {
              i.call(this, u, c, f), this.idealLength = s.DEFAULT_EDGE_LENGTH;
            }
            o.prototype = Object.create(i.prototype);
            for (var l in i)
              o[l] = i[l];
            r.exports = o;
          },
          /* 20 */
          /***/
          function(r, n, a) {
            var i = a(3);
            function s(l, u, c, f) {
              i.call(this, l, u, c, f), this.springForceX = 0, this.springForceY = 0, this.repulsionForceX = 0, this.repulsionForceY = 0, this.gravitationForceX = 0, this.gravitationForceY = 0, this.displacementX = 0, this.displacementY = 0, this.startX = 0, this.finishX = 0, this.startY = 0, this.finishY = 0, this.surrounding = [];
            }
            s.prototype = Object.create(i.prototype);
            for (var o in i)
              s[o] = i[o];
            s.prototype.setGridCoordinates = function(l, u, c, f) {
              this.startX = l, this.finishX = u, this.startY = c, this.finishY = f;
            }, r.exports = s;
          },
          /* 21 */
          /***/
          function(r, n, a) {
            function i(s, o) {
              this.width = 0, this.height = 0, s !== null && o !== null && (this.height = o, this.width = s);
            }
            i.prototype.getWidth = function() {
              return this.width;
            }, i.prototype.setWidth = function(s) {
              this.width = s;
            }, i.prototype.getHeight = function() {
              return this.height;
            }, i.prototype.setHeight = function(s) {
              this.height = s;
            }, r.exports = i;
          },
          /* 22 */
          /***/
          function(r, n, a) {
            var i = a(14);
            function s() {
              this.map = {}, this.keys = [];
            }
            s.prototype.put = function(o, l) {
              var u = i.createID(o);
              this.contains(u) || (this.map[u] = l, this.keys.push(o));
            }, s.prototype.contains = function(o) {
              return i.createID(o), this.map[o] != null;
            }, s.prototype.get = function(o) {
              var l = i.createID(o);
              return this.map[l];
            }, s.prototype.keySet = function() {
              return this.keys;
            }, r.exports = s;
          },
          /* 23 */
          /***/
          function(r, n, a) {
            var i = a(14);
            function s() {
              this.set = {};
            }
            s.prototype.add = function(o) {
              var l = i.createID(o);
              this.contains(l) || (this.set[l] = o);
            }, s.prototype.remove = function(o) {
              delete this.set[i.createID(o)];
            }, s.prototype.clear = function() {
              this.set = {};
            }, s.prototype.contains = function(o) {
              return this.set[i.createID(o)] == o;
            }, s.prototype.isEmpty = function() {
              return this.size() === 0;
            }, s.prototype.size = function() {
              return Object.keys(this.set).length;
            }, s.prototype.addAllTo = function(o) {
              for (var l = Object.keys(this.set), u = l.length, c = 0; c < u; c++)
                o.push(this.set[l[c]]);
            }, s.prototype.size = function() {
              return Object.keys(this.set).length;
            }, s.prototype.addAll = function(o) {
              for (var l = o.length, u = 0; u < l; u++) {
                var c = o[u];
                this.add(c);
              }
            }, r.exports = s;
          },
          /* 24 */
          /***/
          function(r, n, a) {
            var i = /* @__PURE__ */ function() {
              function u(c, f) {
                for (var h = 0; h < f.length; h++) {
                  var d = f[h];
                  d.enumerable = d.enumerable || !1, d.configurable = !0, "value" in d && (d.writable = !0), Object.defineProperty(c, d.key, d);
                }
              }
              return function(c, f, h) {
                return f && u(c.prototype, f), h && u(c, h), c;
              };
            }();
            function s(u, c) {
              if (!(u instanceof c))
                throw new TypeError("Cannot call a class as a function");
            }
            var o = a(11), l = function() {
              function u(c, f) {
                s(this, u), (f !== null || f !== void 0) && (this.compareFunction = this._defaultCompareFunction);
                var h = void 0;
                c instanceof o ? h = c.size() : h = c.length, this._quicksort(c, 0, h - 1);
              }
              return i(u, [{
                key: "_quicksort",
                value: function(f, h, d) {
                  if (h < d) {
                    var p = this._partition(f, h, d);
                    this._quicksort(f, h, p), this._quicksort(f, p + 1, d);
                  }
                }
              }, {
                key: "_partition",
                value: function(f, h, d) {
                  for (var p = this._get(f, h), g = h, v = d; ; ) {
                    for (; this.compareFunction(p, this._get(f, v)); )
                      v--;
                    for (; this.compareFunction(this._get(f, g), p); )
                      g++;
                    if (g < v)
                      this._swap(f, g, v), g++, v--;
                    else return v;
                  }
                }
              }, {
                key: "_get",
                value: function(f, h) {
                  return f instanceof o ? f.get_object_at(h) : f[h];
                }
              }, {
                key: "_set",
                value: function(f, h, d) {
                  f instanceof o ? f.set_object_at(h, d) : f[h] = d;
                }
              }, {
                key: "_swap",
                value: function(f, h, d) {
                  var p = this._get(f, h);
                  this._set(f, h, this._get(f, d)), this._set(f, d, p);
                }
              }, {
                key: "_defaultCompareFunction",
                value: function(f, h) {
                  return h > f;
                }
              }]), u;
            }();
            r.exports = l;
          },
          /* 25 */
          /***/
          function(r, n, a) {
            var i = /* @__PURE__ */ function() {
              function l(u, c) {
                for (var f = 0; f < c.length; f++) {
                  var h = c[f];
                  h.enumerable = h.enumerable || !1, h.configurable = !0, "value" in h && (h.writable = !0), Object.defineProperty(u, h.key, h);
                }
              }
              return function(u, c, f) {
                return c && l(u.prototype, c), f && l(u, f), u;
              };
            }();
            function s(l, u) {
              if (!(l instanceof u))
                throw new TypeError("Cannot call a class as a function");
            }
            var o = function() {
              function l(u, c) {
                var f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, h = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : -1, d = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : -1;
                s(this, l), this.sequence1 = u, this.sequence2 = c, this.match_score = f, this.mismatch_penalty = h, this.gap_penalty = d, this.iMax = u.length + 1, this.jMax = c.length + 1, this.grid = new Array(this.iMax);
                for (var p = 0; p < this.iMax; p++) {
                  this.grid[p] = new Array(this.jMax);
                  for (var g = 0; g < this.jMax; g++)
                    this.grid[p][g] = 0;
                }
                this.tracebackGrid = new Array(this.iMax);
                for (var v = 0; v < this.iMax; v++) {
                  this.tracebackGrid[v] = new Array(this.jMax);
                  for (var m = 0; m < this.jMax; m++)
                    this.tracebackGrid[v][m] = [null, null, null];
                }
                this.alignments = [], this.score = -1, this.computeGrids();
              }
              return i(l, [{
                key: "getScore",
                value: function() {
                  return this.score;
                }
              }, {
                key: "getAlignments",
                value: function() {
                  return this.alignments;
                }
                // Main dynamic programming procedure
              }, {
                key: "computeGrids",
                value: function() {
                  for (var c = 1; c < this.jMax; c++)
                    this.grid[0][c] = this.grid[0][c - 1] + this.gap_penalty, this.tracebackGrid[0][c] = [!1, !1, !0];
                  for (var f = 1; f < this.iMax; f++)
                    this.grid[f][0] = this.grid[f - 1][0] + this.gap_penalty, this.tracebackGrid[f][0] = [!1, !0, !1];
                  for (var h = 1; h < this.iMax; h++)
                    for (var d = 1; d < this.jMax; d++) {
                      var p = void 0;
                      this.sequence1[h - 1] === this.sequence2[d - 1] ? p = this.grid[h - 1][d - 1] + this.match_score : p = this.grid[h - 1][d - 1] + this.mismatch_penalty;
                      var g = this.grid[h - 1][d] + this.gap_penalty, v = this.grid[h][d - 1] + this.gap_penalty, m = [p, g, v], b = this.arrayAllMaxIndexes(m);
                      this.grid[h][d] = m[b[0]], this.tracebackGrid[h][d] = [b.includes(0), b.includes(1), b.includes(2)];
                    }
                  this.score = this.grid[this.iMax - 1][this.jMax - 1];
                }
                // Gets all possible valid sequence combinations
              }, {
                key: "alignmentTraceback",
                value: function() {
                  var c = [];
                  for (c.push({
                    pos: [this.sequence1.length, this.sequence2.length],
                    seq1: "",
                    seq2: ""
                  }); c[0]; ) {
                    var f = c[0], h = this.tracebackGrid[f.pos[0]][f.pos[1]];
                    h[0] && c.push({
                      pos: [f.pos[0] - 1, f.pos[1] - 1],
                      seq1: this.sequence1[f.pos[0] - 1] + f.seq1,
                      seq2: this.sequence2[f.pos[1] - 1] + f.seq2
                    }), h[1] && c.push({
                      pos: [f.pos[0] - 1, f.pos[1]],
                      seq1: this.sequence1[f.pos[0] - 1] + f.seq1,
                      seq2: "-" + f.seq2
                    }), h[2] && c.push({
                      pos: [f.pos[0], f.pos[1] - 1],
                      seq1: "-" + f.seq1,
                      seq2: this.sequence2[f.pos[1] - 1] + f.seq2
                    }), f.pos[0] === 0 && f.pos[1] === 0 && this.alignments.push({
                      sequence1: f.seq1,
                      sequence2: f.seq2
                    }), c.shift();
                  }
                  return this.alignments;
                }
                // Helper Functions
              }, {
                key: "getAllIndexes",
                value: function(c, f) {
                  for (var h = [], d = -1; (d = c.indexOf(f, d + 1)) !== -1; )
                    h.push(d);
                  return h;
                }
              }, {
                key: "arrayAllMaxIndexes",
                value: function(c) {
                  return this.getAllIndexes(c, Math.max.apply(null, c));
                }
              }]), l;
            }();
            r.exports = o;
          },
          /* 26 */
          /***/
          function(r, n, a) {
            var i = function() {
            };
            i.FDLayout = a(18), i.FDLayoutConstants = a(7), i.FDLayoutEdge = a(19), i.FDLayoutNode = a(20), i.DimensionD = a(21), i.HashMap = a(22), i.HashSet = a(23), i.IGeometry = a(8), i.IMath = a(9), i.Integer = a(10), i.Point = a(12), i.PointD = a(4), i.RandomSeed = a(16), i.RectangleD = a(13), i.Transform = a(17), i.UniqueIDGeneretor = a(14), i.Quicksort = a(24), i.LinkedList = a(11), i.LGraphObject = a(2), i.LGraph = a(5), i.LEdge = a(1), i.LGraphManager = a(6), i.LNode = a(3), i.Layout = a(15), i.LayoutConstants = a(0), i.NeedlemanWunsch = a(25), r.exports = i;
          },
          /* 27 */
          /***/
          function(r, n, a) {
            function i() {
              this.listeners = [];
            }
            var s = i.prototype;
            s.addListener = function(o, l) {
              this.listeners.push({
                event: o,
                callback: l
              });
            }, s.removeListener = function(o, l) {
              for (var u = this.listeners.length; u >= 0; u--) {
                var c = this.listeners[u];
                c.event === o && c.callback === l && this.listeners.splice(u, 1);
              }
            }, s.emit = function(o, l) {
              for (var u = 0; u < this.listeners.length; u++) {
                var c = this.listeners[u];
                o === c.event && c.callback(l);
              }
            }, r.exports = i;
          }
          /******/
        ])
      );
    });
  }(Nw)), Nw.exports;
}
var NL;
function pCe() {
  return NL || (NL = 1, function(t, e) {
    (function(n, a) {
      t.exports = a(dCe());
    })(Jt, function(r) {
      return (
        /******/
        function(n) {
          var a = {};
          function i(s) {
            if (a[s])
              return a[s].exports;
            var o = a[s] = {
              /******/
              i: s,
              /******/
              l: !1,
              /******/
              exports: {}
              /******/
            };
            return n[s].call(o.exports, o, o.exports, i), o.l = !0, o.exports;
          }
          return i.m = n, i.c = a, i.i = function(s) {
            return s;
          }, i.d = function(s, o, l) {
            i.o(s, o) || Object.defineProperty(s, o, {
              /******/
              configurable: !1,
              /******/
              enumerable: !0,
              /******/
              get: l
              /******/
            });
          }, i.n = function(s) {
            var o = s && s.__esModule ? (
              /******/
              function() {
                return s.default;
              }
            ) : (
              /******/
              function() {
                return s;
              }
            );
            return i.d(o, "a", o), o;
          }, i.o = function(s, o) {
            return Object.prototype.hasOwnProperty.call(s, o);
          }, i.p = "", i(i.s = 7);
        }([
          /* 0 */
          /***/
          function(n, a) {
            n.exports = r;
          },
          /* 1 */
          /***/
          function(n, a, i) {
            var s = i(0).FDLayoutConstants;
            function o() {
            }
            for (var l in s)
              o[l] = s[l];
            o.DEFAULT_USE_MULTI_LEVEL_SCALING = !1, o.DEFAULT_RADIAL_SEPARATION = s.DEFAULT_EDGE_LENGTH, o.DEFAULT_COMPONENT_SEPERATION = 60, o.TILE = !0, o.TILING_PADDING_VERTICAL = 10, o.TILING_PADDING_HORIZONTAL = 10, o.TREE_REDUCTION_ON_INCREMENTAL = !1, n.exports = o;
          },
          /* 2 */
          /***/
          function(n, a, i) {
            var s = i(0).FDLayoutEdge;
            function o(u, c, f) {
              s.call(this, u, c, f);
            }
            o.prototype = Object.create(s.prototype);
            for (var l in s)
              o[l] = s[l];
            n.exports = o;
          },
          /* 3 */
          /***/
          function(n, a, i) {
            var s = i(0).LGraph;
            function o(u, c, f) {
              s.call(this, u, c, f);
            }
            o.prototype = Object.create(s.prototype);
            for (var l in s)
              o[l] = s[l];
            n.exports = o;
          },
          /* 4 */
          /***/
          function(n, a, i) {
            var s = i(0).LGraphManager;
            function o(u) {
              s.call(this, u);
            }
            o.prototype = Object.create(s.prototype);
            for (var l in s)
              o[l] = s[l];
            n.exports = o;
          },
          /* 5 */
          /***/
          function(n, a, i) {
            var s = i(0).FDLayoutNode, o = i(0).IMath;
            function l(c, f, h, d) {
              s.call(this, c, f, h, d);
            }
            l.prototype = Object.create(s.prototype);
            for (var u in s)
              l[u] = s[u];
            l.prototype.move = function() {
              var c = this.graphManager.getLayout();
              this.displacementX = c.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.noOfChildren, this.displacementY = c.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.noOfChildren, Math.abs(this.displacementX) > c.coolingFactor * c.maxNodeDisplacement && (this.displacementX = c.coolingFactor * c.maxNodeDisplacement * o.sign(this.displacementX)), Math.abs(this.displacementY) > c.coolingFactor * c.maxNodeDisplacement && (this.displacementY = c.coolingFactor * c.maxNodeDisplacement * o.sign(this.displacementY)), this.child == null ? this.moveBy(this.displacementX, this.displacementY) : this.child.getNodes().length == 0 ? this.moveBy(this.displacementX, this.displacementY) : this.propogateDisplacementToChildren(this.displacementX, this.displacementY), c.totalDisplacement += Math.abs(this.displacementX) + Math.abs(this.displacementY), this.springForceX = 0, this.springForceY = 0, this.repulsionForceX = 0, this.repulsionForceY = 0, this.gravitationForceX = 0, this.gravitationForceY = 0, this.displacementX = 0, this.displacementY = 0;
            }, l.prototype.propogateDisplacementToChildren = function(c, f) {
              for (var h = this.getChild().getNodes(), d, p = 0; p < h.length; p++)
                d = h[p], d.getChild() == null ? (d.moveBy(c, f), d.displacementX += c, d.displacementY += f) : d.propogateDisplacementToChildren(c, f);
            }, l.prototype.setPred1 = function(c) {
              this.pred1 = c;
            }, l.prototype.getPred1 = function() {
              return pred1;
            }, l.prototype.getPred2 = function() {
              return pred2;
            }, l.prototype.setNext = function(c) {
              this.next = c;
            }, l.prototype.getNext = function() {
              return next;
            }, l.prototype.setProcessed = function(c) {
              this.processed = c;
            }, l.prototype.isProcessed = function() {
              return processed;
            }, n.exports = l;
          },
          /* 6 */
          /***/
          function(n, a, i) {
            var s = i(0).FDLayout, o = i(4), l = i(3), u = i(5), c = i(2), f = i(1), h = i(0).FDLayoutConstants, d = i(0).LayoutConstants, p = i(0).Point, g = i(0).PointD, v = i(0).Layout, m = i(0).Integer, b = i(0).IGeometry, y = i(0).LGraph, x = i(0).Transform;
            function E() {
              s.call(this), this.toBeTiled = {};
            }
            E.prototype = Object.create(s.prototype);
            for (var S in s)
              E[S] = s[S];
            E.prototype.newGraphManager = function() {
              var w = new o(this);
              return this.graphManager = w, w;
            }, E.prototype.newGraph = function(w) {
              return new l(null, this.graphManager, w);
            }, E.prototype.newNode = function(w) {
              return new u(this.graphManager, w);
            }, E.prototype.newEdge = function(w) {
              return new c(null, null, w);
            }, E.prototype.initParameters = function() {
              s.prototype.initParameters.call(this, arguments), this.isSubLayout || (f.DEFAULT_EDGE_LENGTH < 10 ? this.idealEdgeLength = 10 : this.idealEdgeLength = f.DEFAULT_EDGE_LENGTH, this.useSmartIdealEdgeLengthCalculation = f.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION, this.springConstant = h.DEFAULT_SPRING_STRENGTH, this.repulsionConstant = h.DEFAULT_REPULSION_STRENGTH, this.gravityConstant = h.DEFAULT_GRAVITY_STRENGTH, this.compoundGravityConstant = h.DEFAULT_COMPOUND_GRAVITY_STRENGTH, this.gravityRangeFactor = h.DEFAULT_GRAVITY_RANGE_FACTOR, this.compoundGravityRangeFactor = h.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR, this.prunedNodesAll = [], this.growTreeIterations = 0, this.afterGrowthIterations = 0, this.isTreeGrowing = !1, this.isGrowthFinished = !1, this.coolingCycle = 0, this.maxCoolingCycle = this.maxIterations / h.CONVERGENCE_CHECK_PERIOD, this.finalTemperature = h.CONVERGENCE_CHECK_PERIOD / this.maxIterations, this.coolingAdjuster = 1);
            }, E.prototype.layout = function() {
              var w = d.DEFAULT_CREATE_BENDS_AS_NEEDED;
              return w && (this.createBendpoints(), this.graphManager.resetAllEdges()), this.level = 0, this.classicLayout();
            }, E.prototype.classicLayout = function() {
              if (this.nodesWithGravity = this.calculateNodesToApplyGravitationTo(), this.graphManager.setAllNodesToApplyGravitation(this.nodesWithGravity), this.calcNoOfChildrenForAllNodes(), this.graphManager.calcLowestCommonAncestors(), this.graphManager.calcInclusionTreeDepths(), this.graphManager.getRoot().calcEstimatedSize(), this.calcIdealEdgeLengths(), this.incremental) {
                if (f.TREE_REDUCTION_ON_INCREMENTAL) {
                  this.reduceTrees(), this.graphManager.resetAllNodesToApplyGravitation();
                  var C = new Set(this.getAllNodes()), k = this.nodesWithGravity.filter(function(_) {
                    return C.has(_);
                  });
                  this.graphManager.setAllNodesToApplyGravitation(k);
                }
              } else {
                var w = this.getFlatForest();
                if (w.length > 0)
                  this.positionNodesRadially(w);
                else {
                  this.reduceTrees(), this.graphManager.resetAllNodesToApplyGravitation();
                  var C = new Set(this.getAllNodes()), k = this.nodesWithGravity.filter(function(N) {
                    return C.has(N);
                  });
                  this.graphManager.setAllNodesToApplyGravitation(k), this.positionNodesRandomly();
                }
              }
              return this.initSpringEmbedder(), this.runSpringEmbedder(), !0;
            }, E.prototype.tick = function() {
              if (this.totalIterations++, this.totalIterations === this.maxIterations && !this.isTreeGrowing && !this.isGrowthFinished)
                if (this.prunedNodesAll.length > 0)
                  this.isTreeGrowing = !0;
                else
                  return !0;
              if (this.totalIterations % h.CONVERGENCE_CHECK_PERIOD == 0 && !this.isTreeGrowing && !this.isGrowthFinished) {
                if (this.isConverged())
                  if (this.prunedNodesAll.length > 0)
                    this.isTreeGrowing = !0;
                  else
                    return !0;
                this.coolingCycle++, this.layoutQuality == 0 ? this.coolingAdjuster = this.coolingCycle : this.layoutQuality == 1 && (this.coolingAdjuster = this.coolingCycle / 3), this.coolingFactor = Math.max(this.initialCoolingFactor - Math.pow(this.coolingCycle, Math.log(100 * (this.initialCoolingFactor - this.finalTemperature)) / Math.log(this.maxCoolingCycle)) / 100 * this.coolingAdjuster, this.finalTemperature), this.animationPeriod = Math.ceil(this.initialAnimationPeriod * Math.sqrt(this.coolingFactor));
              }
              if (this.isTreeGrowing) {
                if (this.growTreeIterations % 10 == 0)
                  if (this.prunedNodesAll.length > 0) {
                    this.graphManager.updateBounds(), this.updateGrid(), this.growTree(this.prunedNodesAll), this.graphManager.resetAllNodesToApplyGravitation();
                    var w = new Set(this.getAllNodes()), C = this.nodesWithGravity.filter(function(R) {
                      return w.has(R);
                    });
                    this.graphManager.setAllNodesToApplyGravitation(C), this.graphManager.updateBounds(), this.updateGrid(), this.coolingFactor = h.DEFAULT_COOLING_FACTOR_INCREMENTAL;
                  } else
                    this.isTreeGrowing = !1, this.isGrowthFinished = !0;
                this.growTreeIterations++;
              }
              if (this.isGrowthFinished) {
                if (this.isConverged())
                  return !0;
                this.afterGrowthIterations % 10 == 0 && (this.graphManager.updateBounds(), this.updateGrid()), this.coolingFactor = h.DEFAULT_COOLING_FACTOR_INCREMENTAL * ((100 - this.afterGrowthIterations) / 100), this.afterGrowthIterations++;
              }
              var k = !this.isTreeGrowing && !this.isGrowthFinished, N = this.growTreeIterations % 10 == 1 && this.isTreeGrowing || this.afterGrowthIterations % 10 == 1 && this.isGrowthFinished;
              return this.totalDisplacement = 0, this.graphManager.updateBounds(), this.calcSpringForces(), this.calcRepulsionForces(k, N), this.calcGravitationalForces(), this.moveNodes(), this.animate(), !1;
            }, E.prototype.getPositionsData = function() {
              for (var w = this.graphManager.getAllNodes(), C = {}, k = 0; k < w.length; k++) {
                var N = w[k].rect, R = w[k].id;
                C[R] = {
                  id: R,
                  x: N.getCenterX(),
                  y: N.getCenterY(),
                  w: N.width,
                  h: N.height
                };
              }
              return C;
            }, E.prototype.runSpringEmbedder = function() {
              this.initialAnimationPeriod = 25, this.animationPeriod = this.initialAnimationPeriod;
              var w = !1;
              if (h.ANIMATE === "during")
                this.emit("layoutstarted");
              else {
                for (; !w; )
                  w = this.tick();
                this.graphManager.updateBounds();
              }
            }, E.prototype.calculateNodesToApplyGravitationTo = function() {
              var w = [], C, k = this.graphManager.getGraphs(), N = k.length, R;
              for (R = 0; R < N; R++)
                C = k[R], C.updateConnected(), C.isConnected || (w = w.concat(C.getNodes()));
              return w;
            }, E.prototype.createBendpoints = function() {
              var w = [];
              w = w.concat(this.graphManager.getAllEdges());
              var C = /* @__PURE__ */ new Set(), k;
              for (k = 0; k < w.length; k++) {
                var N = w[k];
                if (!C.has(N)) {
                  var R = N.getSource(), _ = N.getTarget();
                  if (R == _)
                    N.getBendpoints().push(new g()), N.getBendpoints().push(new g()), this.createDummyNodesForBendpoints(N), C.add(N);
                  else {
                    var O = [];
                    if (O = O.concat(R.getEdgeListToNode(_)), O = O.concat(_.getEdgeListToNode(R)), !C.has(O[0])) {
                      if (O.length > 1) {
                        var T;
                        for (T = 0; T < O.length; T++) {
                          var L = O[T];
                          L.getBendpoints().push(new g()), this.createDummyNodesForBendpoints(L);
                        }
                      }
                      O.forEach(function(M) {
                        C.add(M);
                      });
                    }
                  }
                }
                if (C.size == w.length)
                  break;
              }
            }, E.prototype.positionNodesRadially = function(w) {
              for (var C = new p(0, 0), k = Math.ceil(Math.sqrt(w.length)), N = 0, R = 0, _ = 0, O = new g(0, 0), T = 0; T < w.length; T++) {
                T % k == 0 && (_ = 0, R = N, T != 0 && (R += f.DEFAULT_COMPONENT_SEPERATION), N = 0);
                var L = w[T], M = v.findCenterOfTree(L);
                C.x = _, C.y = R, O = E.radialLayout(L, M, C), O.y > N && (N = Math.floor(O.y)), _ = Math.floor(O.x + f.DEFAULT_COMPONENT_SEPERATION);
              }
              this.transform(new g(d.WORLD_CENTER_X - O.x / 2, d.WORLD_CENTER_Y - O.y / 2));
            }, E.radialLayout = function(w, C, k) {
              var N = Math.max(this.maxDiagonalInTree(w), f.DEFAULT_RADIAL_SEPARATION);
              E.branchRadialLayout(C, null, 0, 359, 0, N);
              var R = y.calculateBounds(w), _ = new x();
              _.setDeviceOrgX(R.getMinX()), _.setDeviceOrgY(R.getMinY()), _.setWorldOrgX(k.x), _.setWorldOrgY(k.y);
              for (var O = 0; O < w.length; O++) {
                var T = w[O];
                T.transform(_);
              }
              var L = new g(R.getMaxX(), R.getMaxY());
              return _.inverseTransformPoint(L);
            }, E.branchRadialLayout = function(w, C, k, N, R, _) {
              var O = (N - k + 1) / 2;
              O < 0 && (O += 180);
              var T = (O + k) % 360, L = T * b.TWO_PI / 360, M = R * Math.cos(L), A = R * Math.sin(L);
              w.setCenter(M, A);
              var I = [];
              I = I.concat(w.getEdges());
              var D = I.length;
              C != null && D--;
              for (var F = 0, B = I.length, G, H = w.getEdgesBetween(C); H.length > 1; ) {
                var K = H[0];
                H.splice(0, 1);
                var j = I.indexOf(K);
                j >= 0 && I.splice(j, 1), B--, D--;
              }
              C != null ? G = (I.indexOf(H[0]) + 1) % B : G = 0;
              for (var Z = Math.abs(N - k) / D, te = G; F != D; te = ++te % B) {
                var ne = I[te].getOtherEnd(w);
                if (ne != C) {
                  var V = (k + F * Z) % 360, q = (V + Z) % 360;
                  E.branchRadialLayout(ne, w, V, q, R + _, _), F++;
                }
              }
            }, E.maxDiagonalInTree = function(w) {
              for (var C = m.MIN_VALUE, k = 0; k < w.length; k++) {
                var N = w[k], R = N.getDiagonal();
                R > C && (C = R);
              }
              return C;
            }, E.prototype.calcRepulsionRange = function() {
              return 2 * (this.level + 1) * this.idealEdgeLength;
            }, E.prototype.groupZeroDegreeMembers = function() {
              var w = this, C = {};
              this.memberGroups = {}, this.idToDummyNode = {};
              for (var k = [], N = this.graphManager.getAllNodes(), R = 0; R < N.length; R++) {
                var _ = N[R], O = _.getParent();
                this.getNodeDegreeWithChildren(_) === 0 && (O.id == null || !this.getToBeTiled(O)) && k.push(_);
              }
              for (var R = 0; R < k.length; R++) {
                var _ = k[R], T = _.getParent().id;
                typeof C[T] > "u" && (C[T] = []), C[T] = C[T].concat(_);
              }
              Object.keys(C).forEach(function(L) {
                if (C[L].length > 1) {
                  var M = "DummyCompound_" + L;
                  w.memberGroups[M] = C[L];
                  var A = C[L][0].getParent(), I = new u(w.graphManager);
                  I.id = M, I.paddingLeft = A.paddingLeft || 0, I.paddingRight = A.paddingRight || 0, I.paddingBottom = A.paddingBottom || 0, I.paddingTop = A.paddingTop || 0, w.idToDummyNode[M] = I;
                  var D = w.getGraphManager().add(w.newGraph(), I), F = A.getChild();
                  F.add(I);
                  for (var B = 0; B < C[L].length; B++) {
                    var G = C[L][B];
                    F.remove(G), D.add(G);
                  }
                }
              });
            }, E.prototype.clearCompounds = function() {
              var w = {}, C = {};
              this.performDFSOnCompounds();
              for (var k = 0; k < this.compoundOrder.length; k++)
                C[this.compoundOrder[k].id] = this.compoundOrder[k], w[this.compoundOrder[k].id] = [].concat(this.compoundOrder[k].getChild().getNodes()), this.graphManager.remove(this.compoundOrder[k].getChild()), this.compoundOrder[k].child = null;
              this.graphManager.resetAllNodes(), this.tileCompoundMembers(w, C);
            }, E.prototype.clearZeroDegreeMembers = function() {
              var w = this, C = this.tiledZeroDegreePack = [];
              Object.keys(this.memberGroups).forEach(function(k) {
                var N = w.idToDummyNode[k];
                C[k] = w.tileNodes(w.memberGroups[k], N.paddingLeft + N.paddingRight), N.rect.width = C[k].width, N.rect.height = C[k].height;
              });
            }, E.prototype.repopulateCompounds = function() {
              for (var w = this.compoundOrder.length - 1; w >= 0; w--) {
                var C = this.compoundOrder[w], k = C.id, N = C.paddingLeft, R = C.paddingTop;
                this.adjustLocations(this.tiledMemberPack[k], C.rect.x, C.rect.y, N, R);
              }
            }, E.prototype.repopulateZeroDegreeMembers = function() {
              var w = this, C = this.tiledZeroDegreePack;
              Object.keys(C).forEach(function(k) {
                var N = w.idToDummyNode[k], R = N.paddingLeft, _ = N.paddingTop;
                w.adjustLocations(C[k], N.rect.x, N.rect.y, R, _);
              });
            }, E.prototype.getToBeTiled = function(w) {
              var C = w.id;
              if (this.toBeTiled[C] != null)
                return this.toBeTiled[C];
              var k = w.getChild();
              if (k == null)
                return this.toBeTiled[C] = !1, !1;
              for (var N = k.getNodes(), R = 0; R < N.length; R++) {
                var _ = N[R];
                if (this.getNodeDegree(_) > 0)
                  return this.toBeTiled[C] = !1, !1;
                if (_.getChild() == null) {
                  this.toBeTiled[_.id] = !1;
                  continue;
                }
                if (!this.getToBeTiled(_))
                  return this.toBeTiled[C] = !1, !1;
              }
              return this.toBeTiled[C] = !0, !0;
            }, E.prototype.getNodeDegree = function(w) {
              w.id;
              for (var C = w.getEdges(), k = 0, N = 0; N < C.length; N++) {
                var R = C[N];
                R.getSource().id !== R.getTarget().id && (k = k + 1);
              }
              return k;
            }, E.prototype.getNodeDegreeWithChildren = function(w) {
              var C = this.getNodeDegree(w);
              if (w.getChild() == null)
                return C;
              for (var k = w.getChild().getNodes(), N = 0; N < k.length; N++) {
                var R = k[N];
                C += this.getNodeDegreeWithChildren(R);
              }
              return C;
            }, E.prototype.performDFSOnCompounds = function() {
              this.compoundOrder = [], this.fillCompexOrderByDFS(this.graphManager.getRoot().getNodes());
            }, E.prototype.fillCompexOrderByDFS = function(w) {
              for (var C = 0; C < w.length; C++) {
                var k = w[C];
                k.getChild() != null && this.fillCompexOrderByDFS(k.getChild().getNodes()), this.getToBeTiled(k) && this.compoundOrder.push(k);
              }
            }, E.prototype.adjustLocations = function(w, C, k, N, R) {
              C += N, k += R;
              for (var _ = C, O = 0; O < w.rows.length; O++) {
                var T = w.rows[O];
                C = _;
                for (var L = 0, M = 0; M < T.length; M++) {
                  var A = T[M];
                  A.rect.x = C, A.rect.y = k, C += A.rect.width + w.horizontalPadding, A.rect.height > L && (L = A.rect.height);
                }
                k += L + w.verticalPadding;
              }
            }, E.prototype.tileCompoundMembers = function(w, C) {
              var k = this;
              this.tiledMemberPack = [], Object.keys(w).forEach(function(N) {
                var R = C[N];
                k.tiledMemberPack[N] = k.tileNodes(w[N], R.paddingLeft + R.paddingRight), R.rect.width = k.tiledMemberPack[N].width, R.rect.height = k.tiledMemberPack[N].height;
              });
            }, E.prototype.tileNodes = function(w, C) {
              var k = f.TILING_PADDING_VERTICAL, N = f.TILING_PADDING_HORIZONTAL, R = {
                rows: [],
                rowWidth: [],
                rowHeight: [],
                width: 0,
                height: C,
                // assume minHeight equals to minWidth
                verticalPadding: k,
                horizontalPadding: N
              };
              w.sort(function(T, L) {
                return T.rect.width * T.rect.height > L.rect.width * L.rect.height ? -1 : T.rect.width * T.rect.height < L.rect.width * L.rect.height ? 1 : 0;
              });
              for (var _ = 0; _ < w.length; _++) {
                var O = w[_];
                R.rows.length == 0 ? this.insertNodeToRow(R, O, 0, C) : this.canAddHorizontal(R, O.rect.width, O.rect.height) ? this.insertNodeToRow(R, O, this.getShortestRowIndex(R), C) : this.insertNodeToRow(R, O, R.rows.length, C), this.shiftToLastRow(R);
              }
              return R;
            }, E.prototype.insertNodeToRow = function(w, C, k, N) {
              var R = N;
              if (k == w.rows.length) {
                var _ = [];
                w.rows.push(_), w.rowWidth.push(R), w.rowHeight.push(0);
              }
              var O = w.rowWidth[k] + C.rect.width;
              w.rows[k].length > 0 && (O += w.horizontalPadding), w.rowWidth[k] = O, w.width < O && (w.width = O);
              var T = C.rect.height;
              k > 0 && (T += w.verticalPadding);
              var L = 0;
              T > w.rowHeight[k] && (L = w.rowHeight[k], w.rowHeight[k] = T, L = w.rowHeight[k] - L), w.height += L, w.rows[k].push(C);
            }, E.prototype.getShortestRowIndex = function(w) {
              for (var C = -1, k = Number.MAX_VALUE, N = 0; N < w.rows.length; N++)
                w.rowWidth[N] < k && (C = N, k = w.rowWidth[N]);
              return C;
            }, E.prototype.getLongestRowIndex = function(w) {
              for (var C = -1, k = Number.MIN_VALUE, N = 0; N < w.rows.length; N++)
                w.rowWidth[N] > k && (C = N, k = w.rowWidth[N]);
              return C;
            }, E.prototype.canAddHorizontal = function(w, C, k) {
              var N = this.getShortestRowIndex(w);
              if (N < 0)
                return !0;
              var R = w.rowWidth[N];
              if (R + w.horizontalPadding + C <= w.width) return !0;
              var _ = 0;
              w.rowHeight[N] < k && N > 0 && (_ = k + w.verticalPadding - w.rowHeight[N]);
              var O;
              w.width - R >= C + w.horizontalPadding ? O = (w.height + _) / (R + C + w.horizontalPadding) : O = (w.height + _) / w.width, _ = k + w.verticalPadding;
              var T;
              return w.width < C ? T = (w.height + _) / C : T = (w.height + _) / w.width, T < 1 && (T = 1 / T), O < 1 && (O = 1 / O), O < T;
            }, E.prototype.shiftToLastRow = function(w) {
              var C = this.getLongestRowIndex(w), k = w.rowWidth.length - 1, N = w.rows[C], R = N[N.length - 1], _ = R.width + w.horizontalPadding;
              if (w.width - w.rowWidth[k] > _ && C != k) {
                N.splice(-1, 1), w.rows[k].push(R), w.rowWidth[C] = w.rowWidth[C] - _, w.rowWidth[k] = w.rowWidth[k] + _, w.width = w.rowWidth[instance.getLongestRowIndex(w)];
                for (var O = Number.MIN_VALUE, T = 0; T < N.length; T++)
                  N[T].height > O && (O = N[T].height);
                C > 0 && (O += w.verticalPadding);
                var L = w.rowHeight[C] + w.rowHeight[k];
                w.rowHeight[C] = O, w.rowHeight[k] < R.height + w.verticalPadding && (w.rowHeight[k] = R.height + w.verticalPadding);
                var M = w.rowHeight[C] + w.rowHeight[k];
                w.height += M - L, this.shiftToLastRow(w);
              }
            }, E.prototype.tilingPreLayout = function() {
              f.TILE && (this.groupZeroDegreeMembers(), this.clearCompounds(), this.clearZeroDegreeMembers());
            }, E.prototype.tilingPostLayout = function() {
              f.TILE && (this.repopulateZeroDegreeMembers(), this.repopulateCompounds());
            }, E.prototype.reduceTrees = function() {
              for (var w = [], C = !0, k; C; ) {
                var N = this.graphManager.getAllNodes(), R = [];
                C = !1;
                for (var _ = 0; _ < N.length; _++)
                  k = N[_], k.getEdges().length == 1 && !k.getEdges()[0].isInterGraph && k.getChild() == null && (R.push([k, k.getEdges()[0], k.getOwner()]), C = !0);
                if (C == !0) {
                  for (var O = [], T = 0; T < R.length; T++)
                    R[T][0].getEdges().length == 1 && (O.push(R[T]), R[T][0].getOwner().remove(R[T][0]));
                  w.push(O), this.graphManager.resetAllNodes(), this.graphManager.resetAllEdges();
                }
              }
              this.prunedNodesAll = w;
            }, E.prototype.growTree = function(w) {
              for (var C = w.length, k = w[C - 1], N, R = 0; R < k.length; R++)
                N = k[R], this.findPlaceforPrunedNode(N), N[2].add(N[0]), N[2].add(N[1], N[1].source, N[1].target);
              w.splice(w.length - 1, 1), this.graphManager.resetAllNodes(), this.graphManager.resetAllEdges();
            }, E.prototype.findPlaceforPrunedNode = function(w) {
              var C, k, N = w[0];
              N == w[1].source ? k = w[1].target : k = w[1].source;
              var R = k.startX, _ = k.finishX, O = k.startY, T = k.finishY, L = 0, M = 0, A = 0, I = 0, D = [L, A, M, I];
              if (O > 0)
                for (var F = R; F <= _; F++)
                  D[0] += this.grid[F][O - 1].length + this.grid[F][O].length - 1;
              if (_ < this.grid.length - 1)
                for (var F = O; F <= T; F++)
                  D[1] += this.grid[_ + 1][F].length + this.grid[_][F].length - 1;
              if (T < this.grid[0].length - 1)
                for (var F = R; F <= _; F++)
                  D[2] += this.grid[F][T + 1].length + this.grid[F][T].length - 1;
              if (R > 0)
                for (var F = O; F <= T; F++)
                  D[3] += this.grid[R - 1][F].length + this.grid[R][F].length - 1;
              for (var B = m.MAX_VALUE, G, H, K = 0; K < D.length; K++)
                D[K] < B ? (B = D[K], G = 1, H = K) : D[K] == B && G++;
              if (G == 3 && B == 0)
                D[0] == 0 && D[1] == 0 && D[2] == 0 ? C = 1 : D[0] == 0 && D[1] == 0 && D[3] == 0 ? C = 0 : D[0] == 0 && D[2] == 0 && D[3] == 0 ? C = 3 : D[1] == 0 && D[2] == 0 && D[3] == 0 && (C = 2);
              else if (G == 2 && B == 0) {
                var j = Math.floor(Math.random() * 2);
                D[0] == 0 && D[1] == 0 ? j == 0 ? C = 0 : C = 1 : D[0] == 0 && D[2] == 0 ? j == 0 ? C = 0 : C = 2 : D[0] == 0 && D[3] == 0 ? j == 0 ? C = 0 : C = 3 : D[1] == 0 && D[2] == 0 ? j == 0 ? C = 1 : C = 2 : D[1] == 0 && D[3] == 0 ? j == 0 ? C = 1 : C = 3 : j == 0 ? C = 2 : C = 3;
              } else if (G == 4 && B == 0) {
                var j = Math.floor(Math.random() * 4);
                C = j;
              } else
                C = H;
              C == 0 ? N.setCenter(k.getCenterX(), k.getCenterY() - k.getHeight() / 2 - h.DEFAULT_EDGE_LENGTH - N.getHeight() / 2) : C == 1 ? N.setCenter(k.getCenterX() + k.getWidth() / 2 + h.DEFAULT_EDGE_LENGTH + N.getWidth() / 2, k.getCenterY()) : C == 2 ? N.setCenter(k.getCenterX(), k.getCenterY() + k.getHeight() / 2 + h.DEFAULT_EDGE_LENGTH + N.getHeight() / 2) : N.setCenter(k.getCenterX() - k.getWidth() / 2 - h.DEFAULT_EDGE_LENGTH - N.getWidth() / 2, k.getCenterY());
            }, n.exports = E;
          },
          /* 7 */
          /***/
          function(n, a, i) {
            var s = {};
            s.layoutBase = i(0), s.CoSEConstants = i(1), s.CoSEEdge = i(2), s.CoSEGraph = i(3), s.CoSEGraphManager = i(4), s.CoSELayout = i(6), s.CoSENode = i(5), n.exports = s;
          }
          /******/
        ])
      );
    });
  }(Lw)), Lw.exports;
}
(function(t, e) {
  (function(n, a) {
    t.exports = a(pCe());
  })(Jt, function(r) {
    return (
      /******/
      function(n) {
        var a = {};
        function i(s) {
          if (a[s])
            return a[s].exports;
          var o = a[s] = {
            /******/
            i: s,
            /******/
            l: !1,
            /******/
            exports: {}
            /******/
          };
          return n[s].call(o.exports, o, o.exports, i), o.l = !0, o.exports;
        }
        return i.m = n, i.c = a, i.i = function(s) {
          return s;
        }, i.d = function(s, o, l) {
          i.o(s, o) || Object.defineProperty(s, o, {
            /******/
            configurable: !1,
            /******/
            enumerable: !0,
            /******/
            get: l
            /******/
          });
        }, i.n = function(s) {
          var o = s && s.__esModule ? (
            /******/
            function() {
              return s.default;
            }
          ) : (
            /******/
            function() {
              return s;
            }
          );
          return i.d(o, "a", o), o;
        }, i.o = function(s, o) {
          return Object.prototype.hasOwnProperty.call(s, o);
        }, i.p = "", i(i.s = 1);
      }([
        /* 0 */
        /***/
        function(n, a) {
          n.exports = r;
        },
        /* 1 */
        /***/
        function(n, a, i) {
          var s = i(0).layoutBase.LayoutConstants, o = i(0).layoutBase.FDLayoutConstants, l = i(0).CoSEConstants, u = i(0).CoSELayout, c = i(0).CoSENode, f = i(0).layoutBase.PointD, h = i(0).layoutBase.DimensionD, d = {
            // Called on `layoutready`
            ready: function() {
            },
            // Called on `layoutstop`
            stop: function() {
            },
            // 'draft', 'default' or 'proof" 
            // - 'draft' fast cooling rate 
            // - 'default' moderate cooling rate 
            // - "proof" slow cooling rate
            quality: "default",
            // include labels in node dimensions
            nodeDimensionsIncludeLabels: !1,
            // number of ticks per frame; higher is faster but more jerky
            refresh: 30,
            // Whether to fit the network view after when done
            fit: !0,
            // Padding on fit
            padding: 10,
            // Whether to enable incremental mode
            randomize: !0,
            // Node repulsion (non overlapping) multiplier
            nodeRepulsion: 4500,
            // Ideal edge (non nested) length
            idealEdgeLength: 50,
            // Divisor to compute edge forces
            edgeElasticity: 0.45,
            // Nesting factor (multiplier) to compute ideal edge length for nested edges
            nestingFactor: 0.1,
            // Gravity force (constant)
            gravity: 0.25,
            // Maximum number of iterations to perform
            numIter: 2500,
            // For enabling tiling
            tile: !0,
            // Type of layout animation. The option set is {'during', 'end', false}
            animate: "end",
            // Duration for animate:end
            animationDuration: 500,
            // Represents the amount of the vertical space to put between the zero degree members during the tiling operation(can also be a function)
            tilingPaddingVertical: 10,
            // Represents the amount of the horizontal space to put between the zero degree members during the tiling operation(can also be a function)
            tilingPaddingHorizontal: 10,
            // Gravity range (constant) for compounds
            gravityRangeCompound: 1.5,
            // Gravity force (constant) for compounds
            gravityCompound: 1,
            // Gravity range (constant)
            gravityRange: 3.8,
            // Initial cooling factor for incremental layout
            initialEnergyOnIncremental: 0.5
          };
          function p(b, y) {
            var x = {};
            for (var E in b)
              x[E] = b[E];
            for (var E in y)
              x[E] = y[E];
            return x;
          }
          function g(b) {
            this.options = p(d, b), v(this.options);
          }
          var v = function(y) {
            y.nodeRepulsion != null && (l.DEFAULT_REPULSION_STRENGTH = o.DEFAULT_REPULSION_STRENGTH = y.nodeRepulsion), y.idealEdgeLength != null && (l.DEFAULT_EDGE_LENGTH = o.DEFAULT_EDGE_LENGTH = y.idealEdgeLength), y.edgeElasticity != null && (l.DEFAULT_SPRING_STRENGTH = o.DEFAULT_SPRING_STRENGTH = y.edgeElasticity), y.nestingFactor != null && (l.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = o.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = y.nestingFactor), y.gravity != null && (l.DEFAULT_GRAVITY_STRENGTH = o.DEFAULT_GRAVITY_STRENGTH = y.gravity), y.numIter != null && (l.MAX_ITERATIONS = o.MAX_ITERATIONS = y.numIter), y.gravityRange != null && (l.DEFAULT_GRAVITY_RANGE_FACTOR = o.DEFAULT_GRAVITY_RANGE_FACTOR = y.gravityRange), y.gravityCompound != null && (l.DEFAULT_COMPOUND_GRAVITY_STRENGTH = o.DEFAULT_COMPOUND_GRAVITY_STRENGTH = y.gravityCompound), y.gravityRangeCompound != null && (l.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = o.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = y.gravityRangeCompound), y.initialEnergyOnIncremental != null && (l.DEFAULT_COOLING_FACTOR_INCREMENTAL = o.DEFAULT_COOLING_FACTOR_INCREMENTAL = y.initialEnergyOnIncremental), y.quality == "draft" ? s.QUALITY = 0 : y.quality == "proof" ? s.QUALITY = 2 : s.QUALITY = 1, l.NODE_DIMENSIONS_INCLUDE_LABELS = o.NODE_DIMENSIONS_INCLUDE_LABELS = s.NODE_DIMENSIONS_INCLUDE_LABELS = y.nodeDimensionsIncludeLabels, l.DEFAULT_INCREMENTAL = o.DEFAULT_INCREMENTAL = s.DEFAULT_INCREMENTAL = !y.randomize, l.ANIMATE = o.ANIMATE = s.ANIMATE = y.animate, l.TILE = y.tile, l.TILING_PADDING_VERTICAL = typeof y.tilingPaddingVertical == "function" ? y.tilingPaddingVertical.call() : y.tilingPaddingVertical, l.TILING_PADDING_HORIZONTAL = typeof y.tilingPaddingHorizontal == "function" ? y.tilingPaddingHorizontal.call() : y.tilingPaddingHorizontal;
          };
          g.prototype.run = function() {
            var b, y, x = this.options;
            this.idToLNode = {};
            var E = this.layout = new u(), S = this;
            S.stopped = !1, this.cy = this.options.cy, this.cy.trigger({ type: "layoutstart", layout: this });
            var w = E.newGraphManager();
            this.gm = w;
            var C = this.options.eles.nodes(), k = this.options.eles.edges();
            this.root = w.addRoot(), this.processChildrenList(this.root, this.getTopMostNodes(C), E);
            for (var N = 0; N < k.length; N++) {
              var R = k[N], _ = this.idToLNode[R.data("source")], O = this.idToLNode[R.data("target")];
              if (_ !== O && _.getEdgesBetween(O).length == 0) {
                var T = w.add(E.newEdge(), _, O);
                T.id = R.id();
              }
            }
            var L = function(I, D) {
              typeof I == "number" && (I = D);
              var F = I.data("id"), B = S.idToLNode[F];
              return {
                x: B.getRect().getCenterX(),
                y: B.getRect().getCenterY()
              };
            }, M = function A() {
              for (var I = function() {
                x.fit && x.cy.fit(x.eles, x.padding), b || (b = !0, S.cy.one("layoutready", x.ready), S.cy.trigger({ type: "layoutready", layout: S }));
              }, D = S.options.refresh, F, B = 0; B < D && !F; B++)
                F = S.stopped || S.layout.tick();
              if (F) {
                E.checkLayoutSuccess() && !E.isSubLayout && E.doPostLayout(), E.tilingPostLayout && E.tilingPostLayout(), E.isLayoutFinished = !0, S.options.eles.nodes().positions(L), I(), S.cy.one("layoutstop", S.options.stop), S.cy.trigger({ type: "layoutstop", layout: S }), y && cancelAnimationFrame(y), b = !1;
                return;
              }
              var G = S.layout.getPositionsData();
              x.eles.nodes().positions(function(H, K) {
                if (typeof H == "number" && (H = K), !H.isParent()) {
                  for (var j = H.id(), Z = G[j], te = H; Z == null && (Z = G[te.data("parent")] || G["DummyCompound_" + te.data("parent")], G[j] = Z, te = te.parent()[0], te != null); )
                    ;
                  return Z != null ? {
                    x: Z.x,
                    y: Z.y
                  } : {
                    x: H.position("x"),
                    y: H.position("y")
                  };
                }
              }), I(), y = requestAnimationFrame(A);
            };
            return E.addListener("layoutstarted", function() {
              S.options.animate === "during" && (y = requestAnimationFrame(M));
            }), E.runLayout(), this.options.animate !== "during" && (S.options.eles.nodes().not(":parent").layoutPositions(S, S.options, L), b = !1), this;
          }, g.prototype.getTopMostNodes = function(b) {
            for (var y = {}, x = 0; x < b.length; x++)
              y[b[x].id()] = !0;
            var E = b.filter(function(S, w) {
              typeof S == "number" && (S = w);
              for (var C = S.parent()[0]; C != null; ) {
                if (y[C.id()])
                  return !1;
                C = C.parent()[0];
              }
              return !0;
            });
            return E;
          }, g.prototype.processChildrenList = function(b, y, x) {
            for (var E = y.length, S = 0; S < E; S++) {
              var w = y[S], C = w.children(), k, N = w.layoutDimensions({
                nodeDimensionsIncludeLabels: this.options.nodeDimensionsIncludeLabels
              });
              if (w.outerWidth() != null && w.outerHeight() != null ? k = b.add(new c(x.graphManager, new f(w.position("x") - N.w / 2, w.position("y") - N.h / 2), new h(parseFloat(N.w), parseFloat(N.h)))) : k = b.add(new c(this.graphManager)), k.id = w.data("id"), k.paddingLeft = parseInt(w.css("padding")), k.paddingTop = parseInt(w.css("padding")), k.paddingRight = parseInt(w.css("padding")), k.paddingBottom = parseInt(w.css("padding")), this.options.nodeDimensionsIncludeLabels && w.isParent()) {
                var R = w.boundingBox({ includeLabels: !0, includeNodes: !1 }).w, _ = w.boundingBox({ includeLabels: !0, includeNodes: !1 }).h, O = w.css("text-halign");
                k.labelWidth = R, k.labelHeight = _, k.labelPos = O;
              }
              if (this.idToLNode[w.data("id")] = k, isNaN(k.rect.x) && (k.rect.x = 0), isNaN(k.rect.y) && (k.rect.y = 0), C != null && C.length > 0) {
                var T;
                T = x.getGraphManager().add(x.newGraph(), k), this.processChildrenList(T, C, x);
              }
            }
          }, g.prototype.stop = function() {
            return this.stopped = !0, this;
          };
          var m = function(y) {
            y("layout", "cose-bilkent", g);
          };
          typeof cytoscape < "u" && m(cytoscape), n.exports = m;
        }
        /******/
      ])
    );
  });
})(pG);
var gCe = pG.exports;
const J_e = /* @__PURE__ */ ho(gCe);
function Jn(t) {
  return typeof t == "object" && t !== null && typeof t.$type == "string";
}
function ps(t) {
  return typeof t == "object" && t !== null && typeof t.$refText == "string";
}
function vCe(t) {
  return typeof t == "object" && t !== null && typeof t.name == "string" && typeof t.type == "string" && typeof t.path == "string";
}
function Cv(t) {
  return typeof t == "object" && t !== null && Jn(t.container) && ps(t.reference) && typeof t.message == "string";
}
class gG {
  constructor() {
    this.subtypes = {}, this.allSubtypes = {};
  }
  isInstance(e, r) {
    return Jn(e) && this.isSubtype(e.$type, r);
  }
  isSubtype(e, r) {
    if (e === r)
      return !0;
    let n = this.subtypes[e];
    n || (n = this.subtypes[e] = {});
    const a = n[r];
    if (a !== void 0)
      return a;
    {
      const i = this.computeIsSubtype(e, r);
      return n[r] = i, i;
    }
  }
  getAllSubTypes(e) {
    const r = this.allSubtypes[e];
    if (r)
      return r;
    {
      const n = this.getAllTypes(), a = [];
      for (const i of n)
        this.isSubtype(i, e) && a.push(i);
      return this.allSubtypes[e] = a, a;
    }
  }
}
function v0(t) {
  return typeof t == "object" && t !== null && Array.isArray(t.content);
}
function vG(t) {
  return typeof t == "object" && t !== null && typeof t.tokenType == "object";
}
function mG(t) {
  return v0(t) && typeof t.fullText == "string";
}
class $n {
  constructor(e, r) {
    this.startFn = e, this.nextFn = r;
  }
  iterator() {
    const e = {
      state: this.startFn(),
      next: () => this.nextFn(e.state),
      [Symbol.iterator]: () => e
    };
    return e;
  }
  [Symbol.iterator]() {
    return this.iterator();
  }
  isEmpty() {
    return !!this.iterator().next().done;
  }
  count() {
    const e = this.iterator();
    let r = 0, n = e.next();
    for (; !n.done; )
      r++, n = e.next();
    return r;
  }
  toArray() {
    const e = [], r = this.iterator();
    let n;
    do
      n = r.next(), n.value !== void 0 && e.push(n.value);
    while (!n.done);
    return e;
  }
  toSet() {
    return new Set(this);
  }
  toMap(e, r) {
    const n = this.map((a) => [
      e ? e(a) : a,
      r ? r(a) : a
    ]);
    return new Map(n);
  }
  toString() {
    return this.join();
  }
  concat(e) {
    return new $n(() => ({ first: this.startFn(), firstDone: !1, iterator: e[Symbol.iterator]() }), (r) => {
      let n;
      if (!r.firstDone) {
        do
          if (n = this.nextFn(r.first), !n.done)
            return n;
        while (!n.done);
        r.firstDone = !0;
      }
      do
        if (n = r.iterator.next(), !n.done)
          return n;
      while (!n.done);
      return Xa;
    });
  }
  join(e = ",") {
    const r = this.iterator();
    let n = "", a, i = !1;
    do
      a = r.next(), a.done || (i && (n += e), n += mCe(a.value)), i = !0;
    while (!a.done);
    return n;
  }
  indexOf(e, r = 0) {
    const n = this.iterator();
    let a = 0, i = n.next();
    for (; !i.done; ) {
      if (a >= r && i.value === e)
        return a;
      i = n.next(), a++;
    }
    return -1;
  }
  every(e) {
    const r = this.iterator();
    let n = r.next();
    for (; !n.done; ) {
      if (!e(n.value))
        return !1;
      n = r.next();
    }
    return !0;
  }
  some(e) {
    const r = this.iterator();
    let n = r.next();
    for (; !n.done; ) {
      if (e(n.value))
        return !0;
      n = r.next();
    }
    return !1;
  }
  forEach(e) {
    const r = this.iterator();
    let n = 0, a = r.next();
    for (; !a.done; )
      e(a.value, n), a = r.next(), n++;
  }
  map(e) {
    return new $n(this.startFn, (r) => {
      const { done: n, value: a } = this.nextFn(r);
      return n ? Xa : { done: !1, value: e(a) };
    });
  }
  filter(e) {
    return new $n(this.startFn, (r) => {
      let n;
      do
        if (n = this.nextFn(r), !n.done && e(n.value))
          return n;
      while (!n.done);
      return Xa;
    });
  }
  nonNullable() {
    return this.filter((e) => e != null);
  }
  reduce(e, r) {
    const n = this.iterator();
    let a = r, i = n.next();
    for (; !i.done; )
      a === void 0 ? a = i.value : a = e(a, i.value), i = n.next();
    return a;
  }
  reduceRight(e, r) {
    return this.recursiveReduce(this.iterator(), e, r);
  }
  recursiveReduce(e, r, n) {
    const a = e.next();
    if (a.done)
      return n;
    const i = this.recursiveReduce(e, r, n);
    return i === void 0 ? a.value : r(i, a.value);
  }
  find(e) {
    const r = this.iterator();
    let n = r.next();
    for (; !n.done; ) {
      if (e(n.value))
        return n.value;
      n = r.next();
    }
  }
  findIndex(e) {
    const r = this.iterator();
    let n = 0, a = r.next();
    for (; !a.done; ) {
      if (e(a.value))
        return n;
      a = r.next(), n++;
    }
    return -1;
  }
  includes(e) {
    const r = this.iterator();
    let n = r.next();
    for (; !n.done; ) {
      if (n.value === e)
        return !0;
      n = r.next();
    }
    return !1;
  }
  flatMap(e) {
    return new $n(() => ({ this: this.startFn() }), (r) => {
      do {
        if (r.iterator) {
          const i = r.iterator.next();
          if (i.done)
            r.iterator = void 0;
          else
            return i;
        }
        const { done: n, value: a } = this.nextFn(r.this);
        if (!n) {
          const i = e(a);
          if (Xm(i))
            r.iterator = i[Symbol.iterator]();
          else
            return { done: !1, value: i };
        }
      } while (r.iterator);
      return Xa;
    });
  }
  flat(e) {
    if (e === void 0 && (e = 1), e <= 0)
      return this;
    const r = e > 1 ? this.flat(e - 1) : this;
    return new $n(() => ({ this: r.startFn() }), (n) => {
      do {
        if (n.iterator) {
          const s = n.iterator.next();
          if (s.done)
            n.iterator = void 0;
          else
            return s;
        }
        const { done: a, value: i } = r.nextFn(n.this);
        if (!a)
          if (Xm(i))
            n.iterator = i[Symbol.iterator]();
          else
            return { done: !1, value: i };
      } while (n.iterator);
      return Xa;
    });
  }
  head() {
    const r = this.iterator().next();
    if (!r.done)
      return r.value;
  }
  tail(e = 1) {
    return new $n(() => {
      const r = this.startFn();
      for (let n = 0; n < e; n++)
        if (this.nextFn(r).done)
          return r;
      return r;
    }, this.nextFn);
  }
  limit(e) {
    return new $n(() => ({ size: 0, state: this.startFn() }), (r) => (r.size++, r.size > e ? Xa : this.nextFn(r.state)));
  }
  distinct(e) {
    return new $n(() => ({ set: /* @__PURE__ */ new Set(), internalState: this.startFn() }), (r) => {
      let n;
      do
        if (n = this.nextFn(r.internalState), !n.done) {
          const a = e ? e(n.value) : n.value;
          if (!r.set.has(a))
            return r.set.add(a), n;
        }
      while (!n.done);
      return Xa;
    });
  }
  exclude(e, r) {
    const n = /* @__PURE__ */ new Set();
    for (const a of e) {
      const i = r ? r(a) : a;
      n.add(i);
    }
    return this.filter((a) => {
      const i = r ? r(a) : a;
      return !n.has(i);
    });
  }
}
function mCe(t) {
  return typeof t == "string" ? t : typeof t > "u" ? "undefined" : typeof t.toString == "function" ? t.toString() : Object.prototype.toString.call(t);
}
function Xm(t) {
  return !!t && typeof t[Symbol.iterator] == "function";
}
const yCe = new $n(() => {
}, () => Xa), Xa = Object.freeze({ done: !0, value: void 0 });
function Fn(...t) {
  if (t.length === 1) {
    const e = t[0];
    if (e instanceof $n)
      return e;
    if (Xm(e))
      return new $n(() => e[Symbol.iterator](), (r) => r.next());
    if (typeof e.length == "number")
      return new $n(() => ({ index: 0 }), (r) => r.index < e.length ? { done: !1, value: e[r.index++] } : Xa);
  }
  return t.length > 1 ? new $n(() => ({ collIndex: 0, arrIndex: 0 }), (e) => {
    do {
      if (e.iterator) {
        const r = e.iterator.next();
        if (!r.done)
          return r;
        e.iterator = void 0;
      }
      if (e.array) {
        if (e.arrIndex < e.array.length)
          return { done: !1, value: e.array[e.arrIndex++] };
        e.array = void 0, e.arrIndex = 0;
      }
      if (e.collIndex < t.length) {
        const r = t[e.collIndex++];
        Xm(r) ? e.iterator = r[Symbol.iterator]() : r && typeof r.length == "number" && (e.array = r);
      }
    } while (e.iterator || e.array || e.collIndex < t.length);
    return Xa;
  }) : yCe;
}
class A3 extends $n {
  constructor(e, r, n) {
    super(() => ({
      iterators: n != null && n.includeRoot ? [[e][Symbol.iterator]()] : [r(e)[Symbol.iterator]()],
      pruned: !1
    }), (a) => {
      for (a.pruned && (a.iterators.pop(), a.pruned = !1); a.iterators.length > 0; ) {
        const s = a.iterators[a.iterators.length - 1].next();
        if (s.done)
          a.iterators.pop();
        else
          return a.iterators.push(r(s.value)[Symbol.iterator]()), s;
      }
      return Xa;
    });
  }
  iterator() {
    const e = {
      state: this.startFn(),
      next: () => this.nextFn(e.state),
      prune: () => {
        e.state.pruned = !0;
      },
      [Symbol.iterator]: () => e
    };
    return e;
  }
}
var $4;
(function(t) {
  function e(i) {
    return i.reduce((s, o) => s + o, 0);
  }
  t.sum = e;
  function r(i) {
    return i.reduce((s, o) => s * o, 0);
  }
  t.product = r;
  function n(i) {
    return i.reduce((s, o) => Math.min(s, o));
  }
  t.min = n;
  function a(i) {
    return i.reduce((s, o) => Math.max(s, o));
  }
  t.max = a;
})($4 || ($4 = {}));
function F4(t) {
  return new A3(t, (e) => v0(e) ? e.content : [], { includeRoot: !0 });
}
function bCe(t, e) {
  for (; t.container; )
    if (t = t.container, t === e)
      return !0;
  return !1;
}
function B4(t) {
  return {
    start: {
      character: t.startColumn - 1,
      line: t.startLine - 1
    },
    end: {
      character: t.endColumn,
      // endColumn uses the correct index
      line: t.endLine - 1
    }
  };
}
function Km(t) {
  if (!t)
    return;
  const { offset: e, end: r, range: n } = t;
  return {
    range: n,
    offset: e,
    end: r,
    length: r - e
  };
}
var zs;
(function(t) {
  t[t.Before = 0] = "Before", t[t.After = 1] = "After", t[t.OverlapFront = 2] = "OverlapFront", t[t.OverlapBack = 3] = "OverlapBack", t[t.Inside = 4] = "Inside", t[t.Outside = 5] = "Outside";
})(zs || (zs = {}));
function xCe(t, e) {
  if (t.end.line < e.start.line || t.end.line === e.start.line && t.end.character <= e.start.character)
    return zs.Before;
  if (t.start.line > e.end.line || t.start.line === e.end.line && t.start.character >= e.end.character)
    return zs.After;
  const r = t.start.line > e.start.line || t.start.line === e.start.line && t.start.character >= e.start.character, n = t.end.line < e.end.line || t.end.line === e.end.line && t.end.character <= e.end.character;
  return r && n ? zs.Inside : r ? zs.OverlapBack : n ? zs.OverlapFront : zs.Outside;
}
function wCe(t, e) {
  return xCe(t, e) > zs.After;
}
const ECe = /^[\w\p{L}]$/u;
function TCe(t, e) {
  if (t) {
    const r = SCe(t, !0);
    if (r && OL(r, e))
      return r;
    if (mG(t)) {
      const n = t.content.findIndex((a) => !a.hidden);
      for (let a = n - 1; a >= 0; a--) {
        const i = t.content[a];
        if (OL(i, e))
          return i;
      }
    }
  }
}
function OL(t, e) {
  return vG(t) && e.includes(t.tokenType.name);
}
function SCe(t, e = !0) {
  for (; t.container; ) {
    const r = t.container;
    let n = r.content.indexOf(t);
    for (; n > 0; ) {
      n--;
      const a = r.content[n];
      if (e || !a.hidden)
        return a;
    }
    t = r;
  }
}
class yG extends Error {
  constructor(e, r) {
    super(e ? `${r} at ${e.range.start.line}:${e.range.start.character}` : r);
  }
}
function bp(t) {
  throw new Error("Error! The input value was not handled.");
}
const wg = "AbstractRule", Eg = "AbstractType", Ow = "Condition", IL = "TypeDefinition", Iw = "ValueLiteral", Oh = "AbstractElement";
function CCe(t) {
  return vr.isInstance(t, Oh);
}
const Tg = "ArrayLiteral", Sg = "ArrayType", Ih = "BooleanLiteral";
function ACe(t) {
  return vr.isInstance(t, Ih);
}
const Ph = "Conjunction";
function kCe(t) {
  return vr.isInstance(t, Ph);
}
const Dh = "Disjunction";
function RCe(t) {
  return vr.isInstance(t, Dh);
}
const Cg = "Grammar", Pw = "GrammarImport", $h = "InferredType";
function bG(t) {
  return vr.isInstance(t, $h);
}
const Fh = "Interface";
function xG(t) {
  return vr.isInstance(t, Fh);
}
const Dw = "NamedArgument", Bh = "Negation";
function MCe(t) {
  return vr.isInstance(t, Bh);
}
const Ag = "NumberLiteral", kg = "Parameter", zh = "ParameterReference";
function _Ce(t) {
  return vr.isInstance(t, zh);
}
const Gh = "ParserRule";
function Si(t) {
  return vr.isInstance(t, Gh);
}
const Rg = "ReferenceType", Av = "ReturnType";
function LCe(t) {
  return vr.isInstance(t, Av);
}
const Uh = "SimpleType";
function NCe(t) {
  return vr.isInstance(t, Uh);
}
const Mg = "StringLiteral", ec = "TerminalRule";
function Nu(t) {
  return vr.isInstance(t, ec);
}
const Hh = "Type";
function wG(t) {
  return vr.isInstance(t, Hh);
}
const $w = "TypeAttribute", _g = "UnionType", Vh = "Action";
function db(t) {
  return vr.isInstance(t, Vh);
}
const qh = "Alternatives";
function EG(t) {
  return vr.isInstance(t, qh);
}
const Wh = "Assignment";
function cu(t) {
  return vr.isInstance(t, Wh);
}
const jh = "CharacterRange";
function OCe(t) {
  return vr.isInstance(t, jh);
}
const Yh = "CrossReference";
function k3(t) {
  return vr.isInstance(t, Yh);
}
const Xh = "EndOfFile";
function ICe(t) {
  return vr.isInstance(t, Xh);
}
const Kh = "Group";
function R3(t) {
  return vr.isInstance(t, Kh);
}
const Zh = "Keyword";
function fu(t) {
  return vr.isInstance(t, Zh);
}
const Qh = "NegatedToken";
function PCe(t) {
  return vr.isInstance(t, Qh);
}
const Jh = "RegexToken";
function DCe(t) {
  return vr.isInstance(t, Jh);
}
const ed = "RuleCall";
function hu(t) {
  return vr.isInstance(t, ed);
}
const td = "TerminalAlternatives";
function $Ce(t) {
  return vr.isInstance(t, td);
}
const rd = "TerminalGroup";
function FCe(t) {
  return vr.isInstance(t, rd);
}
const nd = "TerminalRuleCall";
function BCe(t) {
  return vr.isInstance(t, nd);
}
const ad = "UnorderedGroup";
function TG(t) {
  return vr.isInstance(t, ad);
}
const id = "UntilToken";
function zCe(t) {
  return vr.isInstance(t, id);
}
const sd = "Wildcard";
function GCe(t) {
  return vr.isInstance(t, sd);
}
class SG extends gG {
  getAllTypes() {
    return [Oh, wg, Eg, Vh, qh, Tg, Sg, Wh, Ih, jh, Ow, Ph, Yh, Dh, Xh, Cg, Pw, Kh, $h, Fh, Zh, Dw, Qh, Bh, Ag, kg, zh, Gh, Rg, Jh, Av, ed, Uh, Mg, td, rd, ec, nd, Hh, $w, IL, _g, ad, id, Iw, sd];
  }
  computeIsSubtype(e, r) {
    switch (e) {
      case Vh:
      case qh:
      case Wh:
      case jh:
      case Yh:
      case Xh:
      case Kh:
      case Zh:
      case Qh:
      case Jh:
      case ed:
      case td:
      case rd:
      case nd:
      case ad:
      case id:
      case sd:
        return this.isSubtype(Oh, r);
      case Tg:
      case Ag:
      case Mg:
        return this.isSubtype(Iw, r);
      case Sg:
      case Rg:
      case Uh:
      case _g:
        return this.isSubtype(IL, r);
      case Ih:
        return this.isSubtype(Ow, r) || this.isSubtype(Iw, r);
      case Ph:
      case Dh:
      case Bh:
      case zh:
        return this.isSubtype(Ow, r);
      case $h:
      case Fh:
      case Hh:
        return this.isSubtype(Eg, r);
      case Gh:
        return this.isSubtype(wg, r) || this.isSubtype(Eg, r);
      case ec:
        return this.isSubtype(wg, r);
      default:
        return !1;
    }
  }
  getReferenceType(e) {
    const r = `${e.container.$type}:${e.property}`;
    switch (r) {
      case "Action:type":
      case "CrossReference:type":
      case "Interface:superTypes":
      case "ParserRule:returnType":
      case "SimpleType:typeRef":
        return Eg;
      case "Grammar:hiddenTokens":
      case "ParserRule:hiddenTokens":
      case "RuleCall:rule":
        return wg;
      case "Grammar:usedGrammars":
        return Cg;
      case "NamedArgument:parameter":
      case "ParameterReference:parameter":
        return kg;
      case "TerminalRuleCall:rule":
        return ec;
      default:
        throw new Error(`${r} is not a valid reference id.`);
    }
  }
  getTypeMetaData(e) {
    switch (e) {
      case Oh:
        return {
          name: Oh,
          properties: [
            { name: "cardinality" },
            { name: "lookahead" }
          ]
        };
      case Tg:
        return {
          name: Tg,
          properties: [
            { name: "elements", defaultValue: [] }
          ]
        };
      case Sg:
        return {
          name: Sg,
          properties: [
            { name: "elementType" }
          ]
        };
      case Ih:
        return {
          name: Ih,
          properties: [
            { name: "true", defaultValue: !1 }
          ]
        };
      case Ph:
        return {
          name: Ph,
          properties: [
            { name: "left" },
            { name: "right" }
          ]
        };
      case Dh:
        return {
          name: Dh,
          properties: [
            { name: "left" },
            { name: "right" }
          ]
        };
      case Cg:
        return {
          name: Cg,
          properties: [
            { name: "definesHiddenTokens", defaultValue: !1 },
            { name: "hiddenTokens", defaultValue: [] },
            { name: "imports", defaultValue: [] },
            { name: "interfaces", defaultValue: [] },
            { name: "isDeclared", defaultValue: !1 },
            { name: "name" },
            { name: "rules", defaultValue: [] },
            { name: "types", defaultValue: [] },
            { name: "usedGrammars", defaultValue: [] }
          ]
        };
      case Pw:
        return {
          name: Pw,
          properties: [
            { name: "path" }
          ]
        };
      case $h:
        return {
          name: $h,
          properties: [
            { name: "name" }
          ]
        };
      case Fh:
        return {
          name: Fh,
          properties: [
            { name: "attributes", defaultValue: [] },
            { name: "name" },
            { name: "superTypes", defaultValue: [] }
          ]
        };
      case Dw:
        return {
          name: Dw,
          properties: [
            { name: "calledByName", defaultValue: !1 },
            { name: "parameter" },
            { name: "value" }
          ]
        };
      case Bh:
        return {
          name: Bh,
          properties: [
            { name: "value" }
          ]
        };
      case Ag:
        return {
          name: Ag,
          properties: [
            { name: "value" }
          ]
        };
      case kg:
        return {
          name: kg,
          properties: [
            { name: "name" }
          ]
        };
      case zh:
        return {
          name: zh,
          properties: [
            { name: "parameter" }
          ]
        };
      case Gh:
        return {
          name: Gh,
          properties: [
            { name: "dataType" },
            { name: "definesHiddenTokens", defaultValue: !1 },
            { name: "definition" },
            { name: "entry", defaultValue: !1 },
            { name: "fragment", defaultValue: !1 },
            { name: "hiddenTokens", defaultValue: [] },
            { name: "inferredType" },
            { name: "name" },
            { name: "parameters", defaultValue: [] },
            { name: "returnType" },
            { name: "wildcard", defaultValue: !1 }
          ]
        };
      case Rg:
        return {
          name: Rg,
          properties: [
            { name: "referenceType" }
          ]
        };
      case Av:
        return {
          name: Av,
          properties: [
            { name: "name" }
          ]
        };
      case Uh:
        return {
          name: Uh,
          properties: [
            { name: "primitiveType" },
            { name: "stringType" },
            { name: "typeRef" }
          ]
        };
      case Mg:
        return {
          name: Mg,
          properties: [
            { name: "value" }
          ]
        };
      case ec:
        return {
          name: ec,
          properties: [
            { name: "definition" },
            { name: "fragment", defaultValue: !1 },
            { name: "hidden", defaultValue: !1 },
            { name: "name" },
            { name: "type" }
          ]
        };
      case Hh:
        return {
          name: Hh,
          properties: [
            { name: "name" },
            { name: "type" }
          ]
        };
      case $w:
        return {
          name: $w,
          properties: [
            { name: "defaultValue" },
            { name: "isOptional", defaultValue: !1 },
            { name: "name" },
            { name: "type" }
          ]
        };
      case _g:
        return {
          name: _g,
          properties: [
            { name: "types", defaultValue: [] }
          ]
        };
      case Vh:
        return {
          name: Vh,
          properties: [
            { name: "cardinality" },
            { name: "feature" },
            { name: "inferredType" },
            { name: "lookahead" },
            { name: "operator" },
            { name: "type" }
          ]
        };
      case qh:
        return {
          name: qh,
          properties: [
            { name: "cardinality" },
            { name: "elements", defaultValue: [] },
            { name: "lookahead" }
          ]
        };
      case Wh:
        return {
          name: Wh,
          properties: [
            { name: "cardinality" },
            { name: "feature" },
            { name: "lookahead" },
            { name: "operator" },
            { name: "terminal" }
          ]
        };
      case jh:
        return {
          name: jh,
          properties: [
            { name: "cardinality" },
            { name: "left" },
            { name: "lookahead" },
            { name: "right" }
          ]
        };
      case Yh:
        return {
          name: Yh,
          properties: [
            { name: "cardinality" },
            { name: "deprecatedSyntax", defaultValue: !1 },
            { name: "lookahead" },
            { name: "terminal" },
            { name: "type" }
          ]
        };
      case Xh:
        return {
          name: Xh,
          properties: [
            { name: "cardinality" },
            { name: "lookahead" }
          ]
        };
      case Kh:
        return {
          name: Kh,
          properties: [
            { name: "cardinality" },
            { name: "elements", defaultValue: [] },
            { name: "guardCondition" },
            { name: "lookahead" }
          ]
        };
      case Zh:
        return {
          name: Zh,
          properties: [
            { name: "cardinality" },
            { name: "lookahead" },
            { name: "value" }
          ]
        };
      case Qh:
        return {
          name: Qh,
          properties: [
            { name: "cardinality" },
            { name: "lookahead" },
            { name: "terminal" }
          ]
        };
      case Jh:
        return {
          name: Jh,
          properties: [
            { name: "cardinality" },
            { name: "lookahead" },
            { name: "regex" }
          ]
        };
      case ed:
        return {
          name: ed,
          properties: [
            { name: "arguments", defaultValue: [] },
            { name: "cardinality" },
            { name: "lookahead" },
            { name: "rule" }
          ]
        };
      case td:
        return {
          name: td,
          properties: [
            { name: "cardinality" },
            { name: "elements", defaultValue: [] },
            { name: "lookahead" }
          ]
        };
      case rd:
        return {
          name: rd,
          properties: [
            { name: "cardinality" },
            { name: "elements", defaultValue: [] },
            { name: "lookahead" }
          ]
        };
      case nd:
        return {
          name: nd,
          properties: [
            { name: "cardinality" },
            { name: "lookahead" },
            { name: "rule" }
          ]
        };
      case ad:
        return {
          name: ad,
          properties: [
            { name: "cardinality" },
            { name: "elements", defaultValue: [] },
            { name: "lookahead" }
          ]
        };
      case id:
        return {
          name: id,
          properties: [
            { name: "cardinality" },
            { name: "lookahead" },
            { name: "terminal" }
          ]
        };
      case sd:
        return {
          name: sd,
          properties: [
            { name: "cardinality" },
            { name: "lookahead" }
          ]
        };
      default:
        return {
          name: e,
          properties: []
        };
    }
  }
}
const vr = new SG();
function UCe(t) {
  for (const [e, r] of Object.entries(t))
    e.startsWith("$") || (Array.isArray(r) ? r.forEach((n, a) => {
      Jn(n) && (n.$container = t, n.$containerProperty = e, n.$containerIndex = a);
    }) : Jn(r) && (r.$container = t, r.$containerProperty = e));
}
function pb(t, e) {
  let r = t;
  for (; r; ) {
    if (e(r))
      return r;
    r = r.$container;
  }
}
function Jo(t) {
  const r = z4(t).$document;
  if (!r)
    throw new Error("AST node has no document.");
  return r;
}
function z4(t) {
  for (; t.$container; )
    t = t.$container;
  return t;
}
function M3(t, e) {
  if (!t)
    throw new Error("Node must be an AstNode.");
  const r = e == null ? void 0 : e.range;
  return new $n(() => ({
    keys: Object.keys(t),
    keyIndex: 0,
    arrayIndex: 0
  }), (n) => {
    for (; n.keyIndex < n.keys.length; ) {
      const a = n.keys[n.keyIndex];
      if (!a.startsWith("$")) {
        const i = t[a];
        if (Jn(i)) {
          if (n.keyIndex++, PL(i, r))
            return { done: !1, value: i };
        } else if (Array.isArray(i)) {
          for (; n.arrayIndex < i.length; ) {
            const s = n.arrayIndex++, o = i[s];
            if (Jn(o) && PL(o, r))
              return { done: !1, value: o };
          }
          n.arrayIndex = 0;
        }
      }
      n.keyIndex++;
    }
    return Xa;
  });
}
function xp(t, e) {
  if (!t)
    throw new Error("Root node must be an AstNode.");
  return new A3(t, (r) => M3(r, e));
}
function Cc(t, e) {
  if (!t)
    throw new Error("Root node must be an AstNode.");
  return new A3(t, (r) => M3(r, e), { includeRoot: !0 });
}
function PL(t, e) {
  var r;
  if (!e)
    return !0;
  const n = (r = t.$cstNode) === null || r === void 0 ? void 0 : r.range;
  return n ? wCe(n, e) : !1;
}
function CG(t) {
  return new $n(() => ({
    keys: Object.keys(t),
    keyIndex: 0,
    arrayIndex: 0
  }), (e) => {
    for (; e.keyIndex < e.keys.length; ) {
      const r = e.keys[e.keyIndex];
      if (!r.startsWith("$")) {
        const n = t[r];
        if (ps(n))
          return e.keyIndex++, { done: !1, value: { reference: n, container: t, property: r } };
        if (Array.isArray(n)) {
          for (; e.arrayIndex < n.length; ) {
            const a = e.arrayIndex++, i = n[a];
            if (ps(i))
              return { done: !1, value: { reference: i, container: t, property: r, index: a } };
          }
          e.arrayIndex = 0;
        }
      }
      e.keyIndex++;
    }
    return Xa;
  });
}
function HCe(t, e) {
  const r = t.getTypeMetaData(e.$type), n = e;
  for (const a of r.properties)
    a.defaultValue !== void 0 && n[a.name] === void 0 && (n[a.name] = AG(a.defaultValue));
}
function AG(t) {
  return Array.isArray(t) ? [...t.map(AG)] : t;
}
function Lt(t) {
  return t.charCodeAt(0);
}
function Fw(t, e) {
  Array.isArray(t) ? t.forEach(function(r) {
    e.push(r);
  }) : e.push(t);
}
function mh(t, e) {
  if (t[e] === !0)
    throw "duplicate flag " + e;
  t[e], t[e] = !0;
}
function Qu(t) {
  if (t === void 0)
    throw Error("Internal Error - Should never get here!");
  return !0;
}
function VCe() {
  throw Error("Internal Error - Should never get here!");
}
function DL(t) {
  return t.type === "Character";
}
const Zm = [];
for (let t = Lt("0"); t <= Lt("9"); t++)
  Zm.push(t);
const Qm = [Lt("_")].concat(Zm);
for (let t = Lt("a"); t <= Lt("z"); t++)
  Qm.push(t);
for (let t = Lt("A"); t <= Lt("Z"); t++)
  Qm.push(t);
const $L = [
  Lt(" "),
  Lt("\f"),
  Lt(`
`),
  Lt("\r"),
  Lt("	"),
  Lt("\v"),
  Lt("	"),
  Lt(" "),
  Lt(" "),
  Lt(" "),
  Lt(" "),
  Lt(" "),
  Lt(" "),
  Lt(" "),
  Lt(" "),
  Lt(" "),
  Lt(" "),
  Lt(" "),
  Lt(" "),
  Lt(" "),
  Lt("\u2028"),
  Lt("\u2029"),
  Lt(" "),
  Lt(" "),
  Lt("　"),
  Lt("\uFEFF")
], qCe = /[0-9a-fA-F]/, Lg = /[0-9]/, WCe = /[1-9]/;
class kG {
  constructor() {
    this.idx = 0, this.input = "", this.groupIdx = 0;
  }
  saveState() {
    return {
      idx: this.idx,
      input: this.input,
      groupIdx: this.groupIdx
    };
  }
  restoreState(e) {
    this.idx = e.idx, this.input = e.input, this.groupIdx = e.groupIdx;
  }
  pattern(e) {
    this.idx = 0, this.input = e, this.groupIdx = 0, this.consumeChar("/");
    const r = this.disjunction();
    this.consumeChar("/");
    const n = {
      type: "Flags",
      loc: { begin: this.idx, end: e.length },
      global: !1,
      ignoreCase: !1,
      multiLine: !1,
      unicode: !1,
      sticky: !1
    };
    for (; this.isRegExpFlag(); )
      switch (this.popChar()) {
        case "g":
          mh(n, "global");
          break;
        case "i":
          mh(n, "ignoreCase");
          break;
        case "m":
          mh(n, "multiLine");
          break;
        case "u":
          mh(n, "unicode");
          break;
        case "y":
          mh(n, "sticky");
          break;
      }
    if (this.idx !== this.input.length)
      throw Error("Redundant input: " + this.input.substring(this.idx));
    return {
      type: "Pattern",
      flags: n,
      value: r,
      loc: this.loc(0)
    };
  }
  disjunction() {
    const e = [], r = this.idx;
    for (e.push(this.alternative()); this.peekChar() === "|"; )
      this.consumeChar("|"), e.push(this.alternative());
    return { type: "Disjunction", value: e, loc: this.loc(r) };
  }
  alternative() {
    const e = [], r = this.idx;
    for (; this.isTerm(); )
      e.push(this.term());
    return { type: "Alternative", value: e, loc: this.loc(r) };
  }
  term() {
    return this.isAssertion() ? this.assertion() : this.atom();
  }
  assertion() {
    const e = this.idx;
    switch (this.popChar()) {
      case "^":
        return {
          type: "StartAnchor",
          loc: this.loc(e)
        };
      case "$":
        return { type: "EndAnchor", loc: this.loc(e) };
      case "\\":
        switch (this.popChar()) {
          case "b":
            return {
              type: "WordBoundary",
              loc: this.loc(e)
            };
          case "B":
            return {
              type: "NonWordBoundary",
              loc: this.loc(e)
            };
        }
        throw Error("Invalid Assertion Escape");
      case "(":
        this.consumeChar("?");
        let r;
        switch (this.popChar()) {
          case "=":
            r = "Lookahead";
            break;
          case "!":
            r = "NegativeLookahead";
            break;
        }
        Qu(r);
        const n = this.disjunction();
        return this.consumeChar(")"), {
          type: r,
          value: n,
          loc: this.loc(e)
        };
    }
    return VCe();
  }
  quantifier(e = !1) {
    let r;
    const n = this.idx;
    switch (this.popChar()) {
      case "*":
        r = {
          atLeast: 0,
          atMost: 1 / 0
        };
        break;
      case "+":
        r = {
          atLeast: 1,
          atMost: 1 / 0
        };
        break;
      case "?":
        r = {
          atLeast: 0,
          atMost: 1
        };
        break;
      case "{":
        const a = this.integerIncludingZero();
        switch (this.popChar()) {
          case "}":
            r = {
              atLeast: a,
              atMost: a
            };
            break;
          case ",":
            let i;
            this.isDigit() ? (i = this.integerIncludingZero(), r = {
              atLeast: a,
              atMost: i
            }) : r = {
              atLeast: a,
              atMost: 1 / 0
            }, this.consumeChar("}");
            break;
        }
        if (e === !0 && r === void 0)
          return;
        Qu(r);
        break;
    }
    if (!(e === !0 && r === void 0) && Qu(r))
      return this.peekChar(0) === "?" ? (this.consumeChar("?"), r.greedy = !1) : r.greedy = !0, r.type = "Quantifier", r.loc = this.loc(n), r;
  }
  atom() {
    let e;
    const r = this.idx;
    switch (this.peekChar()) {
      case ".":
        e = this.dotAll();
        break;
      case "\\":
        e = this.atomEscape();
        break;
      case "[":
        e = this.characterClass();
        break;
      case "(":
        e = this.group();
        break;
    }
    if (e === void 0 && this.isPatternCharacter() && (e = this.patternCharacter()), Qu(e))
      return e.loc = this.loc(r), this.isQuantifier() && (e.quantifier = this.quantifier()), e;
  }
  dotAll() {
    return this.consumeChar("."), {
      type: "Set",
      complement: !0,
      value: [Lt(`
`), Lt("\r"), Lt("\u2028"), Lt("\u2029")]
    };
  }
  atomEscape() {
    switch (this.consumeChar("\\"), this.peekChar()) {
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        return this.decimalEscapeAtom();
      case "d":
      case "D":
      case "s":
      case "S":
      case "w":
      case "W":
        return this.characterClassEscape();
      case "f":
      case "n":
      case "r":
      case "t":
      case "v":
        return this.controlEscapeAtom();
      case "c":
        return this.controlLetterEscapeAtom();
      case "0":
        return this.nulCharacterAtom();
      case "x":
        return this.hexEscapeSequenceAtom();
      case "u":
        return this.regExpUnicodeEscapeSequenceAtom();
      default:
        return this.identityEscapeAtom();
    }
  }
  decimalEscapeAtom() {
    return { type: "GroupBackReference", value: this.positiveInteger() };
  }
  characterClassEscape() {
    let e, r = !1;
    switch (this.popChar()) {
      case "d":
        e = Zm;
        break;
      case "D":
        e = Zm, r = !0;
        break;
      case "s":
        e = $L;
        break;
      case "S":
        e = $L, r = !0;
        break;
      case "w":
        e = Qm;
        break;
      case "W":
        e = Qm, r = !0;
        break;
    }
    if (Qu(e))
      return { type: "Set", value: e, complement: r };
  }
  controlEscapeAtom() {
    let e;
    switch (this.popChar()) {
      case "f":
        e = Lt("\f");
        break;
      case "n":
        e = Lt(`
`);
        break;
      case "r":
        e = Lt("\r");
        break;
      case "t":
        e = Lt("	");
        break;
      case "v":
        e = Lt("\v");
        break;
    }
    if (Qu(e))
      return { type: "Character", value: e };
  }
  controlLetterEscapeAtom() {
    this.consumeChar("c");
    const e = this.popChar();
    if (/[a-zA-Z]/.test(e) === !1)
      throw Error("Invalid ");
    return { type: "Character", value: e.toUpperCase().charCodeAt(0) - 64 };
  }
  nulCharacterAtom() {
    return this.consumeChar("0"), { type: "Character", value: Lt("\0") };
  }
  hexEscapeSequenceAtom() {
    return this.consumeChar("x"), this.parseHexDigits(2);
  }
  regExpUnicodeEscapeSequenceAtom() {
    return this.consumeChar("u"), this.parseHexDigits(4);
  }
  identityEscapeAtom() {
    const e = this.popChar();
    return { type: "Character", value: Lt(e) };
  }
  classPatternCharacterAtom() {
    switch (this.peekChar()) {
      case `
`:
      case "\r":
      case "\u2028":
      case "\u2029":
      case "\\":
      case "]":
        throw Error("TBD");
      default:
        const e = this.popChar();
        return { type: "Character", value: Lt(e) };
    }
  }
  characterClass() {
    const e = [];
    let r = !1;
    for (this.consumeChar("["), this.peekChar(0) === "^" && (this.consumeChar("^"), r = !0); this.isClassAtom(); ) {
      const n = this.classAtom();
      if (n.type, DL(n) && this.isRangeDash()) {
        this.consumeChar("-");
        const a = this.classAtom();
        if (a.type, DL(a)) {
          if (a.value < n.value)
            throw Error("Range out of order in character class");
          e.push({ from: n.value, to: a.value });
        } else
          Fw(n.value, e), e.push(Lt("-")), Fw(a.value, e);
      } else
        Fw(n.value, e);
    }
    return this.consumeChar("]"), { type: "Set", complement: r, value: e };
  }
  classAtom() {
    switch (this.peekChar()) {
      case "]":
      case `
`:
      case "\r":
      case "\u2028":
      case "\u2029":
        throw Error("TBD");
      case "\\":
        return this.classEscape();
      default:
        return this.classPatternCharacterAtom();
    }
  }
  classEscape() {
    switch (this.consumeChar("\\"), this.peekChar()) {
      case "b":
        return this.consumeChar("b"), { type: "Character", value: Lt("\b") };
      case "d":
      case "D":
      case "s":
      case "S":
      case "w":
      case "W":
        return this.characterClassEscape();
      case "f":
      case "n":
      case "r":
      case "t":
      case "v":
        return this.controlEscapeAtom();
      case "c":
        return this.controlLetterEscapeAtom();
      case "0":
        return this.nulCharacterAtom();
      case "x":
        return this.hexEscapeSequenceAtom();
      case "u":
        return this.regExpUnicodeEscapeSequenceAtom();
      default:
        return this.identityEscapeAtom();
    }
  }
  group() {
    let e = !0;
    switch (this.consumeChar("("), this.peekChar(0)) {
      case "?":
        this.consumeChar("?"), this.consumeChar(":"), e = !1;
        break;
      default:
        this.groupIdx++;
        break;
    }
    const r = this.disjunction();
    this.consumeChar(")");
    const n = {
      type: "Group",
      capturing: e,
      value: r
    };
    return e && (n.idx = this.groupIdx), n;
  }
  positiveInteger() {
    let e = this.popChar();
    if (WCe.test(e) === !1)
      throw Error("Expecting a positive integer");
    for (; Lg.test(this.peekChar(0)); )
      e += this.popChar();
    return parseInt(e, 10);
  }
  integerIncludingZero() {
    let e = this.popChar();
    if (Lg.test(e) === !1)
      throw Error("Expecting an integer");
    for (; Lg.test(this.peekChar(0)); )
      e += this.popChar();
    return parseInt(e, 10);
  }
  patternCharacter() {
    const e = this.popChar();
    switch (e) {
      case `
`:
      case "\r":
      case "\u2028":
      case "\u2029":
      case "^":
      case "$":
      case "\\":
      case ".":
      case "*":
      case "+":
      case "?":
      case "(":
      case ")":
      case "[":
      case "|":
        throw Error("TBD");
      default:
        return { type: "Character", value: Lt(e) };
    }
  }
  isRegExpFlag() {
    switch (this.peekChar(0)) {
      case "g":
      case "i":
      case "m":
      case "u":
      case "y":
        return !0;
      default:
        return !1;
    }
  }
  isRangeDash() {
    return this.peekChar() === "-" && this.isClassAtom(1);
  }
  isDigit() {
    return Lg.test(this.peekChar(0));
  }
  isClassAtom(e = 0) {
    switch (this.peekChar(e)) {
      case "]":
      case `
`:
      case "\r":
      case "\u2028":
      case "\u2029":
        return !1;
      default:
        return !0;
    }
  }
  isTerm() {
    return this.isAtom() || this.isAssertion();
  }
  isAtom() {
    if (this.isPatternCharacter())
      return !0;
    switch (this.peekChar(0)) {
      case ".":
      case "\\":
      case "[":
      case "(":
        return !0;
      default:
        return !1;
    }
  }
  isAssertion() {
    switch (this.peekChar(0)) {
      case "^":
      case "$":
        return !0;
      case "\\":
        switch (this.peekChar(1)) {
          case "b":
          case "B":
            return !0;
          default:
            return !1;
        }
      case "(":
        return this.peekChar(1) === "?" && (this.peekChar(2) === "=" || this.peekChar(2) === "!");
      default:
        return !1;
    }
  }
  isQuantifier() {
    const e = this.saveState();
    try {
      return this.quantifier(!0) !== void 0;
    } catch {
      return !1;
    } finally {
      this.restoreState(e);
    }
  }
  isPatternCharacter() {
    switch (this.peekChar()) {
      case "^":
      case "$":
      case "\\":
      case ".":
      case "*":
      case "+":
      case "?":
      case "(":
      case ")":
      case "[":
      case "|":
      case "/":
      case `
`:
      case "\r":
      case "\u2028":
      case "\u2029":
        return !1;
      default:
        return !0;
    }
  }
  parseHexDigits(e) {
    let r = "";
    for (let a = 0; a < e; a++) {
      const i = this.popChar();
      if (qCe.test(i) === !1)
        throw Error("Expecting a HexDecimal digits");
      r += i;
    }
    return { type: "Character", value: parseInt(r, 16) };
  }
  peekChar(e = 0) {
    return this.input[this.idx + e];
  }
  popChar() {
    const e = this.peekChar(0);
    return this.consumeChar(void 0), e;
  }
  consumeChar(e) {
    if (e !== void 0 && this.input[this.idx] !== e)
      throw Error("Expected: '" + e + "' but found: '" + this.input[this.idx] + "' at offset: " + this.idx);
    if (this.idx >= this.input.length)
      throw Error("Unexpected end of input");
    this.idx++;
  }
  loc(e) {
    return { begin: e, end: this.idx };
  }
}
class gb {
  visitChildren(e) {
    for (const r in e) {
      const n = e[r];
      e.hasOwnProperty(r) && (n.type !== void 0 ? this.visit(n) : Array.isArray(n) && n.forEach((a) => {
        this.visit(a);
      }, this));
    }
  }
  visit(e) {
    switch (e.type) {
      case "Pattern":
        this.visitPattern(e);
        break;
      case "Flags":
        this.visitFlags(e);
        break;
      case "Disjunction":
        this.visitDisjunction(e);
        break;
      case "Alternative":
        this.visitAlternative(e);
        break;
      case "StartAnchor":
        this.visitStartAnchor(e);
        break;
      case "EndAnchor":
        this.visitEndAnchor(e);
        break;
      case "WordBoundary":
        this.visitWordBoundary(e);
        break;
      case "NonWordBoundary":
        this.visitNonWordBoundary(e);
        break;
      case "Lookahead":
        this.visitLookahead(e);
        break;
      case "NegativeLookahead":
        this.visitNegativeLookahead(e);
        break;
      case "Character":
        this.visitCharacter(e);
        break;
      case "Set":
        this.visitSet(e);
        break;
      case "Group":
        this.visitGroup(e);
        break;
      case "GroupBackReference":
        this.visitGroupBackReference(e);
        break;
      case "Quantifier":
        this.visitQuantifier(e);
        break;
    }
    this.visitChildren(e);
  }
  visitPattern(e) {
  }
  visitFlags(e) {
  }
  visitDisjunction(e) {
  }
  visitAlternative(e) {
  }
  // Assertion
  visitStartAnchor(e) {
  }
  visitEndAnchor(e) {
  }
  visitWordBoundary(e) {
  }
  visitNonWordBoundary(e) {
  }
  visitLookahead(e) {
  }
  visitNegativeLookahead(e) {
  }
  // atoms
  visitCharacter(e) {
  }
  visitSet(e) {
  }
  visitGroup(e) {
  }
  visitGroupBackReference(e) {
  }
  visitQuantifier(e) {
  }
}
const jCe = /\r?\n/gm, YCe = new kG();
class XCe extends gb {
  constructor() {
    super(...arguments), this.isStarting = !0, this.endRegexpStack = [], this.multiline = !1;
  }
  get endRegex() {
    return this.endRegexpStack.join("");
  }
  reset(e) {
    this.multiline = !1, this.regex = e, this.startRegexp = "", this.isStarting = !0, this.endRegexpStack = [];
  }
  visitGroup(e) {
    e.quantifier && (this.isStarting = !1, this.endRegexpStack = []);
  }
  visitCharacter(e) {
    const r = String.fromCharCode(e.value);
    if (!this.multiline && r === `
` && (this.multiline = !0), e.quantifier)
      this.isStarting = !1, this.endRegexpStack = [];
    else {
      const n = vb(r);
      this.endRegexpStack.push(n), this.isStarting && (this.startRegexp += n);
    }
  }
  visitSet(e) {
    if (!this.multiline) {
      const r = this.regex.substring(e.loc.begin, e.loc.end), n = new RegExp(r);
      this.multiline = !!`
`.match(n);
    }
    if (e.quantifier)
      this.isStarting = !1, this.endRegexpStack = [];
    else {
      const r = this.regex.substring(e.loc.begin, e.loc.end);
      this.endRegexpStack.push(r), this.isStarting && (this.startRegexp += r);
    }
  }
  visitChildren(e) {
    e.type === "Group" && e.quantifier || super.visitChildren(e);
  }
}
const Bw = new XCe();
function KCe(t) {
  try {
    return typeof t == "string" && (t = new RegExp(t)), t = t.toString(), Bw.reset(t), Bw.visit(YCe.pattern(t)), Bw.multiline;
  } catch {
    return !1;
  }
}
const ZCe = `\f
\r	\v              \u2028\u2029  　\uFEFF`.split("");
function G4(t) {
  const e = typeof t == "string" ? new RegExp(t) : t;
  return ZCe.some((r) => e.test(r));
}
function vb(t) {
  return t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function QCe(t) {
  return Array.prototype.map.call(t, (e) => /\w/.test(e) ? `[${e.toLowerCase()}${e.toUpperCase()}]` : vb(e)).join("");
}
function JCe(t, e) {
  const r = e3e(t), n = e.match(r);
  return !!n && n[0].length > 0;
}
function e3e(t) {
  typeof t == "string" && (t = new RegExp(t));
  const e = t, r = t.source;
  let n = 0;
  function a() {
    let i = "", s;
    function o(u) {
      i += r.substr(n, u), n += u;
    }
    function l(u) {
      i += "(?:" + r.substr(n, u) + "|$)", n += u;
    }
    for (; n < r.length; )
      switch (r[n]) {
        case "\\":
          switch (r[n + 1]) {
            case "c":
              l(3);
              break;
            case "x":
              l(4);
              break;
            case "u":
              e.unicode ? r[n + 2] === "{" ? l(r.indexOf("}", n) - n + 1) : l(6) : l(2);
              break;
            case "p":
            case "P":
              e.unicode ? l(r.indexOf("}", n) - n + 1) : l(2);
              break;
            case "k":
              l(r.indexOf(">", n) - n + 1);
              break;
            default:
              l(2);
              break;
          }
          break;
        case "[":
          s = /\[(?:\\.|.)*?\]/g, s.lastIndex = n, s = s.exec(r) || [], l(s[0].length);
          break;
        case "|":
        case "^":
        case "$":
        case "*":
        case "+":
        case "?":
          o(1);
          break;
        case "{":
          s = /\{\d+,?\d*\}/g, s.lastIndex = n, s = s.exec(r), s ? o(s[0].length) : l(1);
          break;
        case "(":
          if (r[n + 1] === "?")
            switch (r[n + 2]) {
              case ":":
                i += "(?:", n += 3, i += a() + "|$)";
                break;
              case "=":
                i += "(?=", n += 3, i += a() + ")";
                break;
              case "!":
                s = n, n += 3, a(), i += r.substr(s, n - s);
                break;
              case "<":
                switch (r[n + 3]) {
                  case "=":
                  case "!":
                    s = n, n += 4, a(), i += r.substr(s, n - s);
                    break;
                  default:
                    o(r.indexOf(">", n) - n + 1), i += a() + "|$)";
                    break;
                }
                break;
            }
          else
            o(1), i += a() + "|$)";
          break;
        case ")":
          return ++n, i;
        default:
          l(1);
          break;
      }
    return i;
  }
  return new RegExp(a(), t.flags);
}
function t3e(t) {
  return t.rules.find((e) => Si(e) && e.entry);
}
function r3e(t) {
  return t.rules.filter((e) => Nu(e) && e.hidden);
}
function RG(t, e) {
  const r = /* @__PURE__ */ new Set(), n = t3e(t);
  if (!n)
    return new Set(t.rules);
  const a = [n].concat(r3e(t));
  for (const s of a)
    MG(s, r, e);
  const i = /* @__PURE__ */ new Set();
  for (const s of t.rules)
    (r.has(s.name) || Nu(s) && s.hidden) && i.add(s);
  return i;
}
function MG(t, e, r) {
  e.add(t.name), xp(t).forEach((n) => {
    if (hu(n) || r) {
      const a = n.rule.ref;
      a && !e.has(a.name) && MG(a, e, r);
    }
  });
}
function n3e(t) {
  if (t.terminal)
    return t.terminal;
  if (t.type.ref) {
    const e = LG(t.type.ref);
    return e == null ? void 0 : e.terminal;
  }
}
function a3e(t) {
  return t.hidden && !G4(O3(t));
}
function i3e(t, e) {
  return !t || !e ? [] : _3(t, e, t.astNode, !0);
}
function _G(t, e, r) {
  if (!t || !e)
    return;
  const n = _3(t, e, t.astNode, !0);
  if (n.length !== 0)
    return r !== void 0 ? r = Math.max(0, Math.min(r, n.length - 1)) : r = 0, n[r];
}
function _3(t, e, r, n) {
  if (!n) {
    const a = pb(t.grammarSource, cu);
    if (a && a.feature === e)
      return [t];
  }
  return v0(t) && t.astNode === r ? t.content.flatMap((a) => _3(a, e, r, !1)) : [];
}
function s3e(t, e, r) {
  if (!t)
    return;
  const n = o3e(t, e, t == null ? void 0 : t.astNode);
  if (n.length !== 0)
    return r !== void 0 ? r = Math.max(0, Math.min(r, n.length - 1)) : r = 0, n[r];
}
function o3e(t, e, r) {
  if (t.astNode !== r)
    return [];
  if (fu(t.grammarSource) && t.grammarSource.value === e)
    return [t];
  const n = F4(t).iterator();
  let a;
  const i = [];
  do
    if (a = n.next(), !a.done) {
      const s = a.value;
      s.astNode === r ? fu(s.grammarSource) && s.grammarSource.value === e && i.push(s) : n.prune();
    }
  while (!a.done);
  return i;
}
function l3e(t) {
  var e;
  const r = t.astNode;
  for (; r === ((e = t.container) === null || e === void 0 ? void 0 : e.astNode); ) {
    const n = pb(t.grammarSource, cu);
    if (n)
      return n;
    t = t.container;
  }
}
function LG(t) {
  let e = t;
  return bG(e) && (db(e.$container) ? e = e.$container.$container : Si(e.$container) ? e = e.$container : bp(e.$container)), NG(t, e, /* @__PURE__ */ new Map());
}
function NG(t, e, r) {
  var n;
  function a(i, s) {
    let o;
    return pb(i, cu) || (o = NG(s, s, r)), r.set(t, o), o;
  }
  if (r.has(t))
    return r.get(t);
  r.set(t, void 0);
  for (const i of xp(e)) {
    if (cu(i) && i.feature.toLowerCase() === "name")
      return r.set(t, i), i;
    if (hu(i) && Si(i.rule.ref))
      return a(i, i.rule.ref);
    if (NCe(i) && (!((n = i.typeRef) === null || n === void 0) && n.ref))
      return a(i, i.typeRef.ref);
  }
}
function OG(t) {
  return IG(t, /* @__PURE__ */ new Set());
}
function IG(t, e) {
  if (e.has(t))
    return !0;
  e.add(t);
  for (const r of xp(t))
    if (hu(r)) {
      if (!r.rule.ref || Si(r.rule.ref) && !IG(r.rule.ref, e))
        return !1;
    } else {
      if (cu(r))
        return !1;
      if (db(r))
        return !1;
    }
  return !!t.definition;
}
function L3(t) {
  if (t.inferredType)
    return t.inferredType.name;
  if (t.dataType)
    return t.dataType;
  if (t.returnType) {
    const e = t.returnType.ref;
    if (e) {
      if (Si(e))
        return e.name;
      if (xG(e) || wG(e))
        return e.name;
    }
  }
}
function N3(t) {
  var e;
  if (Si(t))
    return OG(t) ? t.name : (e = L3(t)) !== null && e !== void 0 ? e : t.name;
  if (xG(t) || wG(t) || LCe(t))
    return t.name;
  if (db(t)) {
    const r = u3e(t);
    if (r)
      return r;
  } else if (bG(t))
    return t.name;
  throw new Error("Cannot get name of Unknown Type");
}
function u3e(t) {
  var e;
  if (t.inferredType)
    return t.inferredType.name;
  if (!((e = t.type) === null || e === void 0) && e.ref)
    return N3(t.type.ref);
}
function c3e(t) {
  var e, r, n;
  return Nu(t) ? (r = (e = t.type) === null || e === void 0 ? void 0 : e.name) !== null && r !== void 0 ? r : "string" : (n = L3(t)) !== null && n !== void 0 ? n : t.name;
}
function O3(t) {
  const e = {
    s: !1,
    i: !1,
    u: !1
  }, r = Pf(t.definition, e), n = Object.entries(e).filter(([, a]) => a).map(([a]) => a).join("");
  return new RegExp(r, n);
}
const I3 = /[\s\S]/.source;
function Pf(t, e) {
  if ($Ce(t))
    return f3e(t);
  if (FCe(t))
    return h3e(t);
  if (OCe(t))
    return g3e(t);
  if (BCe(t)) {
    const r = t.rule.ref;
    if (!r)
      throw new Error("Missing rule reference.");
    return Js(Pf(r.definition), {
      cardinality: t.cardinality,
      lookahead: t.lookahead
    });
  } else {
    if (PCe(t))
      return p3e(t);
    if (zCe(t))
      return d3e(t);
    if (DCe(t)) {
      const r = t.regex.lastIndexOf("/"), n = t.regex.substring(1, r), a = t.regex.substring(r + 1);
      return e && (e.i = a.includes("i"), e.s = a.includes("s"), e.u = a.includes("u")), Js(n, {
        cardinality: t.cardinality,
        lookahead: t.lookahead,
        wrap: !1
      });
    } else {
      if (GCe(t))
        return Js(I3, {
          cardinality: t.cardinality,
          lookahead: t.lookahead
        });
      throw new Error(`Invalid terminal element: ${t == null ? void 0 : t.$type}`);
    }
  }
}
function f3e(t) {
  return Js(t.elements.map((e) => Pf(e)).join("|"), {
    cardinality: t.cardinality,
    lookahead: t.lookahead
  });
}
function h3e(t) {
  return Js(t.elements.map((e) => Pf(e)).join(""), {
    cardinality: t.cardinality,
    lookahead: t.lookahead
  });
}
function d3e(t) {
  return Js(`${I3}*?${Pf(t.terminal)}`, {
    cardinality: t.cardinality,
    lookahead: t.lookahead
  });
}
function p3e(t) {
  return Js(`(?!${Pf(t.terminal)})${I3}*?`, {
    cardinality: t.cardinality,
    lookahead: t.lookahead
  });
}
function g3e(t) {
  return t.right ? Js(`[${zw(t.left)}-${zw(t.right)}]`, {
    cardinality: t.cardinality,
    lookahead: t.lookahead,
    wrap: !1
  }) : Js(zw(t.left), {
    cardinality: t.cardinality,
    lookahead: t.lookahead,
    wrap: !1
  });
}
function zw(t) {
  return vb(t.value);
}
function Js(t, e) {
  var r;
  return (e.wrap !== !1 || e.lookahead) && (t = `(${(r = e.lookahead) !== null && r !== void 0 ? r : ""}${t})`), e.cardinality ? `${t}${e.cardinality}` : t;
}
function v3e(t) {
  const e = [], r = t.Grammar;
  for (const n of r.rules)
    Nu(n) && a3e(n) && KCe(O3(n)) && e.push(n.name);
  return {
    multilineCommentRules: e,
    nameRegexp: ECe
  };
}
function U4(t) {
  console && console.error && console.error(`Error: ${t}`);
}
function PG(t) {
  console && console.warn && console.warn(`Warning: ${t}`);
}
function DG(t) {
  const e = (/* @__PURE__ */ new Date()).getTime(), r = t();
  return { time: (/* @__PURE__ */ new Date()).getTime() - e, value: r };
}
function $G(t) {
  function e() {
  }
  e.prototype = t;
  const r = new e();
  function n() {
    return typeof r.bar;
  }
  return n(), n(), t;
}
function m3e(t) {
  return y3e(t) ? t.LABEL : t.name;
}
function y3e(t) {
  return _a(t.LABEL) && t.LABEL !== "";
}
class Ms {
  get definition() {
    return this._definition;
  }
  set definition(e) {
    this._definition = e;
  }
  constructor(e) {
    this._definition = e;
  }
  accept(e) {
    e.visit(this), ve(this.definition, (r) => {
      r.accept(e);
    });
  }
}
class pa extends Ms {
  constructor(e) {
    super([]), this.idx = 1, ai(this, Ji(e, (r) => r !== void 0));
  }
  set definition(e) {
  }
  get definition() {
    return this.referencedRule !== void 0 ? this.referencedRule.definition : [];
  }
  accept(e) {
    e.visit(this);
  }
}
class Df extends Ms {
  constructor(e) {
    super(e.definition), this.orgText = "", ai(this, Ji(e, (r) => r !== void 0));
  }
}
class La extends Ms {
  constructor(e) {
    super(e.definition), this.ignoreAmbiguities = !1, ai(this, Ji(e, (r) => r !== void 0));
  }
}
let Gn = class extends Ms {
  constructor(e) {
    super(e.definition), this.idx = 1, ai(this, Ji(e, (r) => r !== void 0));
  }
};
class si extends Ms {
  constructor(e) {
    super(e.definition), this.idx = 1, ai(this, Ji(e, (r) => r !== void 0));
  }
}
class oi extends Ms {
  constructor(e) {
    super(e.definition), this.idx = 1, ai(this, Ji(e, (r) => r !== void 0));
  }
}
class Xr extends Ms {
  constructor(e) {
    super(e.definition), this.idx = 1, ai(this, Ji(e, (r) => r !== void 0));
  }
}
class Pa extends Ms {
  constructor(e) {
    super(e.definition), this.idx = 1, ai(this, Ji(e, (r) => r !== void 0));
  }
}
class Da extends Ms {
  get definition() {
    return this._definition;
  }
  set definition(e) {
    this._definition = e;
  }
  constructor(e) {
    super(e.definition), this.idx = 1, this.ignoreAmbiguities = !1, this.hasPredicates = !1, ai(this, Ji(e, (r) => r !== void 0));
  }
}
class Pr {
  constructor(e) {
    this.idx = 1, ai(this, Ji(e, (r) => r !== void 0));
  }
  accept(e) {
    e.visit(this);
  }
}
function b3e(t) {
  return Xe(t, kv);
}
function kv(t) {
  function e(r) {
    return Xe(r, kv);
  }
  if (t instanceof pa) {
    const r = {
      type: "NonTerminal",
      name: t.nonTerminalName,
      idx: t.idx
    };
    return _a(t.label) && (r.label = t.label), r;
  } else {
    if (t instanceof La)
      return {
        type: "Alternative",
        definition: e(t.definition)
      };
    if (t instanceof Gn)
      return {
        type: "Option",
        idx: t.idx,
        definition: e(t.definition)
      };
    if (t instanceof si)
      return {
        type: "RepetitionMandatory",
        idx: t.idx,
        definition: e(t.definition)
      };
    if (t instanceof oi)
      return {
        type: "RepetitionMandatoryWithSeparator",
        idx: t.idx,
        separator: kv(new Pr({ terminalType: t.separator })),
        definition: e(t.definition)
      };
    if (t instanceof Pa)
      return {
        type: "RepetitionWithSeparator",
        idx: t.idx,
        separator: kv(new Pr({ terminalType: t.separator })),
        definition: e(t.definition)
      };
    if (t instanceof Xr)
      return {
        type: "Repetition",
        idx: t.idx,
        definition: e(t.definition)
      };
    if (t instanceof Da)
      return {
        type: "Alternation",
        idx: t.idx,
        definition: e(t.definition)
      };
    if (t instanceof Pr) {
      const r = {
        type: "Terminal",
        name: t.terminalType.name,
        label: m3e(t.terminalType),
        idx: t.idx
      };
      _a(t.label) && (r.terminalLabel = t.label);
      const n = t.terminalType.PATTERN;
      return t.terminalType.PATTERN && (r.pattern = lo(n) ? n.source : n), r;
    } else {
      if (t instanceof Df)
        return {
          type: "Rule",
          name: t.name,
          orgText: t.orgText,
          definition: e(t.definition)
        };
      throw Error("non exhaustive match");
    }
  }
}
class $f {
  visit(e) {
    const r = e;
    switch (r.constructor) {
      case pa:
        return this.visitNonTerminal(r);
      case La:
        return this.visitAlternative(r);
      case Gn:
        return this.visitOption(r);
      case si:
        return this.visitRepetitionMandatory(r);
      case oi:
        return this.visitRepetitionMandatoryWithSeparator(r);
      case Pa:
        return this.visitRepetitionWithSeparator(r);
      case Xr:
        return this.visitRepetition(r);
      case Da:
        return this.visitAlternation(r);
      case Pr:
        return this.visitTerminal(r);
      case Df:
        return this.visitRule(r);
      default:
        throw Error("non exhaustive match");
    }
  }
  /* c8 ignore next */
  visitNonTerminal(e) {
  }
  /* c8 ignore next */
  visitAlternative(e) {
  }
  /* c8 ignore next */
  visitOption(e) {
  }
  /* c8 ignore next */
  visitRepetition(e) {
  }
  /* c8 ignore next */
  visitRepetitionMandatory(e) {
  }
  /* c8 ignore next 3 */
  visitRepetitionMandatoryWithSeparator(e) {
  }
  /* c8 ignore next */
  visitRepetitionWithSeparator(e) {
  }
  /* c8 ignore next */
  visitAlternation(e) {
  }
  /* c8 ignore next */
  visitTerminal(e) {
  }
  /* c8 ignore next */
  visitRule(e) {
  }
}
function x3e(t) {
  return t instanceof La || t instanceof Gn || t instanceof Xr || t instanceof si || t instanceof oi || t instanceof Pa || t instanceof Pr || t instanceof Df;
}
function Jm(t, e = []) {
  return t instanceof Gn || t instanceof Xr || t instanceof Pa ? !0 : t instanceof Da ? lB(t.definition, (n) => Jm(n, e)) : t instanceof pa && ya(e, t) ? !1 : t instanceof Ms ? (t instanceof pa && e.push(t), Hi(t.definition, (n) => Jm(n, e))) : !1;
}
function w3e(t) {
  return t instanceof Da;
}
function ls(t) {
  if (t instanceof pa)
    return "SUBRULE";
  if (t instanceof Gn)
    return "OPTION";
  if (t instanceof Da)
    return "OR";
  if (t instanceof si)
    return "AT_LEAST_ONE";
  if (t instanceof oi)
    return "AT_LEAST_ONE_SEP";
  if (t instanceof Pa)
    return "MANY_SEP";
  if (t instanceof Xr)
    return "MANY";
  if (t instanceof Pr)
    return "CONSUME";
  throw Error("non exhaustive match");
}
class mb {
  walk(e, r = []) {
    ve(e.definition, (n, a) => {
      const i = Dn(e.definition, a + 1);
      if (n instanceof pa)
        this.walkProdRef(n, i, r);
      else if (n instanceof Pr)
        this.walkTerminal(n, i, r);
      else if (n instanceof La)
        this.walkFlat(n, i, r);
      else if (n instanceof Gn)
        this.walkOption(n, i, r);
      else if (n instanceof si)
        this.walkAtLeastOne(n, i, r);
      else if (n instanceof oi)
        this.walkAtLeastOneSep(n, i, r);
      else if (n instanceof Pa)
        this.walkManySep(n, i, r);
      else if (n instanceof Xr)
        this.walkMany(n, i, r);
      else if (n instanceof Da)
        this.walkOr(n, i, r);
      else
        throw Error("non exhaustive match");
    });
  }
  walkTerminal(e, r, n) {
  }
  walkProdRef(e, r, n) {
  }
  walkFlat(e, r, n) {
    const a = r.concat(n);
    this.walk(e, a);
  }
  walkOption(e, r, n) {
    const a = r.concat(n);
    this.walk(e, a);
  }
  walkAtLeastOne(e, r, n) {
    const a = [
      new Gn({ definition: e.definition })
    ].concat(r, n);
    this.walk(e, a);
  }
  walkAtLeastOneSep(e, r, n) {
    const a = FL(e, r, n);
    this.walk(e, a);
  }
  walkMany(e, r, n) {
    const a = [
      new Gn({ definition: e.definition })
    ].concat(r, n);
    this.walk(e, a);
  }
  walkManySep(e, r, n) {
    const a = FL(e, r, n);
    this.walk(e, a);
  }
  walkOr(e, r, n) {
    const a = r.concat(n);
    ve(e.definition, (i) => {
      const s = new La({ definition: [i] });
      this.walk(s, a);
    });
  }
}
function FL(t, e, r) {
  return [
    new Gn({
      definition: [
        new Pr({ terminalType: t.separator })
      ].concat(t.definition)
    })
  ].concat(e, r);
}
function wp(t) {
  if (t instanceof pa)
    return wp(t.referencedRule);
  if (t instanceof Pr)
    return S3e(t);
  if (x3e(t))
    return E3e(t);
  if (w3e(t))
    return T3e(t);
  throw Error("non exhaustive match");
}
function E3e(t) {
  let e = [];
  const r = t.definition;
  let n = 0, a = r.length > n, i, s = !0;
  for (; a && s; )
    i = r[n], s = Jm(i), e = e.concat(wp(i)), n = n + 1, a = r.length > n;
  return KC(e);
}
function T3e(t) {
  const e = Xe(t.definition, (r) => wp(r));
  return KC(kn(e));
}
function S3e(t) {
  return [t.terminalType];
}
const FG = "_~IN~_";
class C3e extends mb {
  constructor(e) {
    super(), this.topProd = e, this.follows = {};
  }
  startWalking() {
    return this.walk(this.topProd), this.follows;
  }
  walkTerminal(e, r, n) {
  }
  walkProdRef(e, r, n) {
    const a = k3e(e.referencedRule, e.idx) + this.topProd.name, i = r.concat(n), s = new La({ definition: i }), o = wp(s);
    this.follows[a] = o;
  }
}
function A3e(t) {
  const e = {};
  return ve(t, (r) => {
    const n = new C3e(r).startWalking();
    ai(e, n);
  }), e;
}
function k3e(t, e) {
  return t.name + e + FG;
}
let Rv = {};
const R3e = new kG();
function yb(t) {
  const e = t.toString();
  if (Rv.hasOwnProperty(e))
    return Rv[e];
  {
    const r = R3e.pattern(e);
    return Rv[e] = r, r;
  }
}
function M3e() {
  Rv = {};
}
const BG = "Complement Sets are not supported for first char optimization", ey = `Unable to use "first char" lexer optimizations:
`;
function _3e(t, e = !1) {
  try {
    const r = yb(t);
    return H4(r.value, {}, r.flags.ignoreCase);
  } catch (r) {
    if (r.message === BG)
      e && PG(`${ey}	Unable to optimize: < ${t.toString()} >
	Complement Sets cannot be automatically optimized.
	This will disable the lexer's first char optimizations.
	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.`);
    else {
      let n = "";
      e && (n = `
	This will disable the lexer's first char optimizations.
	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.`), U4(`${ey}
	Failed parsing: < ${t.toString()} >
	Using the @chevrotain/regexp-to-ast library
	Please open an issue at: https://github.com/chevrotain/chevrotain/issues` + n);
    }
  }
  return [];
}
function H4(t, e, r) {
  switch (t.type) {
    case "Disjunction":
      for (let a = 0; a < t.value.length; a++)
        H4(t.value[a], e, r);
      break;
    case "Alternative":
      const n = t.value;
      for (let a = 0; a < n.length; a++) {
        const i = n[a];
        switch (i.type) {
          case "EndAnchor":
          case "GroupBackReference":
          case "Lookahead":
          case "NegativeLookahead":
          case "StartAnchor":
          case "WordBoundary":
          case "NonWordBoundary":
            continue;
        }
        const s = i;
        switch (s.type) {
          case "Character":
            Ng(s.value, e, r);
            break;
          case "Set":
            if (s.complement === !0)
              throw Error(BG);
            ve(s.value, (l) => {
              if (typeof l == "number")
                Ng(l, e, r);
              else {
                const u = l;
                if (r === !0)
                  for (let c = u.from; c <= u.to; c++)
                    Ng(c, e, r);
                else {
                  for (let c = u.from; c <= u.to && c < ld; c++)
                    Ng(c, e, r);
                  if (u.to >= ld) {
                    const c = u.from >= ld ? u.from : ld, f = u.to, h = el(c), d = el(f);
                    for (let p = h; p <= d; p++)
                      e[p] = p;
                  }
                }
              }
            });
            break;
          case "Group":
            H4(s.value, e, r);
            break;
          default:
            throw Error("Non Exhaustive Match");
        }
        const o = s.quantifier !== void 0 && s.quantifier.atLeast === 0;
        if (
          // A group may be optional due to empty contents /(?:)/
          // or if everything inside it is optional /((a)?)/
          s.type === "Group" && V4(s) === !1 || // If this term is not a group it may only be optional if it has an optional quantifier
          s.type !== "Group" && o === !1
        )
          break;
      }
      break;
    default:
      throw Error("non exhaustive match!");
  }
  return wr(e);
}
function Ng(t, e, r) {
  const n = el(t);
  e[n] = n, r === !0 && L3e(t, e);
}
function L3e(t, e) {
  const r = String.fromCharCode(t), n = r.toUpperCase();
  if (n !== r) {
    const a = el(n.charCodeAt(0));
    e[a] = a;
  } else {
    const a = r.toLowerCase();
    if (a !== r) {
      const i = el(a.charCodeAt(0));
      e[i] = i;
    }
  }
}
function BL(t, e) {
  return oo(t.value, (r) => {
    if (typeof r == "number")
      return ya(e, r);
    {
      const n = r;
      return oo(e, (a) => n.from <= a && a <= n.to) !== void 0;
    }
  });
}
function V4(t) {
  const e = t.quantifier;
  return e && e.atLeast === 0 ? !0 : t.value ? jt(t.value) ? Hi(t.value, V4) : V4(t.value) : !1;
}
class N3e extends gb {
  constructor(e) {
    super(), this.targetCharCodes = e, this.found = !1;
  }
  visitChildren(e) {
    if (this.found !== !0) {
      switch (e.type) {
        case "Lookahead":
          this.visitLookahead(e);
          return;
        case "NegativeLookahead":
          this.visitNegativeLookahead(e);
          return;
      }
      super.visitChildren(e);
    }
  }
  visitCharacter(e) {
    ya(this.targetCharCodes, e.value) && (this.found = !0);
  }
  visitSet(e) {
    e.complement ? BL(e, this.targetCharCodes) === void 0 && (this.found = !0) : BL(e, this.targetCharCodes) !== void 0 && (this.found = !0);
  }
}
function P3(t, e) {
  if (e instanceof RegExp) {
    const r = yb(e), n = new N3e(t);
    return n.visit(r), n.found;
  } else
    return oo(e, (r) => ya(t, r.charCodeAt(0))) !== void 0;
}
const du = "PATTERN", od = "defaultMode", Og = "modes";
let zG = typeof new RegExp("(?:)").sticky == "boolean";
function O3e(t, e) {
  e = V1(e, {
    useSticky: zG,
    debug: !1,
    safeMode: !1,
    positionTracking: "full",
    lineTerminatorCharacters: ["\r", `
`],
    tracer: (b, y) => y()
  });
  const r = e.tracer;
  r("initCharCodeToOptimizedIndexMap", () => {
    rAe();
  });
  let n;
  r("Reject Lexer.NA", () => {
    n = j1(t, (b) => b[du] === ka.NA);
  });
  let a = !1, i;
  r("Transform Patterns", () => {
    a = !1, i = Xe(n, (b) => {
      const y = b[du];
      if (lo(y)) {
        const x = y.source;
        return x.length === 1 && // only these regExp meta characters which can appear in a length one regExp
        x !== "^" && x !== "$" && x !== "." && !y.ignoreCase ? x : x.length === 2 && x[0] === "\\" && // not a meta character
        !ya([
          "d",
          "D",
          "s",
          "S",
          "t",
          "r",
          "n",
          "t",
          "0",
          "c",
          "b",
          "B",
          "f",
          "v",
          "w",
          "W"
        ], x[1]) ? x[1] : e.useSticky ? GL(y) : zL(y);
      } else {
        if (xi(y))
          return a = !0, { exec: y };
        if (typeof y == "object")
          return a = !0, y;
        if (typeof y == "string") {
          if (y.length === 1)
            return y;
          {
            const x = y.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&"), E = new RegExp(x);
            return e.useSticky ? GL(E) : zL(E);
          }
        } else
          throw Error("non exhaustive match");
      }
    });
  });
  let s, o, l, u, c;
  r("misc mapping", () => {
    s = Xe(n, (b) => b.tokenTypeIdx), o = Xe(n, (b) => {
      const y = b.GROUP;
      if (y !== ka.SKIPPED) {
        if (_a(y))
          return y;
        if (dr(y))
          return !1;
        throw Error("non exhaustive match");
      }
    }), l = Xe(n, (b) => {
      const y = b.LONGER_ALT;
      if (y)
        return jt(y) ? Xe(y, (E) => U7(n, E)) : [U7(n, y)];
    }), u = Xe(n, (b) => b.PUSH_MODE), c = Xe(n, (b) => Et(b, "POP_MODE"));
  });
  let f;
  r("Line Terminator Handling", () => {
    const b = HG(e.lineTerminatorCharacters);
    f = Xe(n, (y) => !1), e.positionTracking !== "onlyOffset" && (f = Xe(n, (y) => Et(y, "LINE_BREAKS") ? !!y.LINE_BREAKS : UG(y, b) === !1 && P3(b, y.PATTERN)));
  });
  let h, d, p, g;
  r("Misc Mapping #2", () => {
    h = Xe(n, GG), d = Xe(i, J3e), p = fn(n, (b, y) => {
      const x = y.GROUP;
      return _a(x) && x !== ka.SKIPPED && (b[x] = []), b;
    }, {}), g = Xe(i, (b, y) => ({
      pattern: i[y],
      longerAlt: l[y],
      canLineTerminator: f[y],
      isCustom: h[y],
      short: d[y],
      group: o[y],
      push: u[y],
      pop: c[y],
      tokenTypeIdx: s[y],
      tokenType: n[y]
    }));
  });
  let v = !0, m = [];
  return e.safeMode || r("First Char Optimization", () => {
    m = fn(n, (b, y, x) => {
      if (typeof y.PATTERN == "string") {
        const E = y.PATTERN.charCodeAt(0), S = el(E);
        Gw(b, S, g[x]);
      } else if (jt(y.START_CHARS_HINT)) {
        let E;
        ve(y.START_CHARS_HINT, (S) => {
          const w = typeof S == "string" ? S.charCodeAt(0) : S, C = el(w);
          E !== C && (E = C, Gw(b, C, g[x]));
        });
      } else if (lo(y.PATTERN))
        if (y.PATTERN.unicode)
          v = !1, e.ensureOptimizations && U4(`${ey}	Unable to analyze < ${y.PATTERN.toString()} > pattern.
	The regexp unicode flag is not currently supported by the regexp-to-ast library.
	This will disable the lexer's first char optimizations.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE`);
        else {
          const E = _3e(y.PATTERN, e.ensureOptimizations);
          mr(E) && (v = !1), ve(E, (S) => {
            Gw(b, S, g[x]);
          });
        }
      else
        e.ensureOptimizations && U4(`${ey}	TokenType: <${y.name}> is using a custom token pattern without providing <start_chars_hint> parameter.
	This will disable the lexer's first char optimizations.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE`), v = !1;
      return b;
    }, []);
  }), {
    emptyGroups: p,
    patternIdxToConfig: g,
    charCodeToPatternIdxToConfig: m,
    hasCustom: a,
    canBeOptimized: v
  };
}
function I3e(t, e) {
  let r = [];
  const n = D3e(t);
  r = r.concat(n.errors);
  const a = $3e(n.valid), i = a.valid;
  return r = r.concat(a.errors), r = r.concat(P3e(i)), r = r.concat(q3e(i)), r = r.concat(W3e(i, e)), r = r.concat(j3e(i)), r;
}
function P3e(t) {
  let e = [];
  const r = Zr(t, (n) => lo(n[du]));
  return e = e.concat(B3e(r)), e = e.concat(U3e(r)), e = e.concat(H3e(r)), e = e.concat(V3e(r)), e = e.concat(z3e(r)), e;
}
function D3e(t) {
  const e = Zr(t, (a) => !Et(a, du)), r = Xe(e, (a) => ({
    message: "Token Type: ->" + a.name + "<- missing static 'PATTERN' property",
    type: Kr.MISSING_PATTERN,
    tokenTypes: [a]
  })), n = q1(t, e);
  return { errors: r, valid: n };
}
function $3e(t) {
  const e = Zr(t, (a) => {
    const i = a[du];
    return !lo(i) && !xi(i) && !Et(i, "exec") && !_a(i);
  }), r = Xe(e, (a) => ({
    message: "Token Type: ->" + a.name + "<- static 'PATTERN' can only be a RegExp, a Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.",
    type: Kr.INVALID_PATTERN,
    tokenTypes: [a]
  })), n = q1(t, e);
  return { errors: r, valid: n };
}
const F3e = /[^\\][$]/;
function B3e(t) {
  class e extends gb {
    constructor() {
      super(...arguments), this.found = !1;
    }
    visitEndAnchor(i) {
      this.found = !0;
    }
  }
  const r = Zr(t, (a) => {
    const i = a.PATTERN;
    try {
      const s = yb(i), o = new e();
      return o.visit(s), o.found;
    } catch {
      return F3e.test(i.source);
    }
  });
  return Xe(r, (a) => ({
    message: `Unexpected RegExp Anchor Error:
	Token Type: ->` + a.name + `<- static 'PATTERN' cannot contain end of input anchor '$'
	See chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.`,
    type: Kr.EOI_ANCHOR_FOUND,
    tokenTypes: [a]
  }));
}
function z3e(t) {
  const e = Zr(t, (n) => n.PATTERN.test(""));
  return Xe(e, (n) => ({
    message: "Token Type: ->" + n.name + "<- static 'PATTERN' must not match an empty string",
    type: Kr.EMPTY_MATCH_PATTERN,
    tokenTypes: [n]
  }));
}
const G3e = /[^\\[][\^]|^\^/;
function U3e(t) {
  class e extends gb {
    constructor() {
      super(...arguments), this.found = !1;
    }
    visitStartAnchor(i) {
      this.found = !0;
    }
  }
  const r = Zr(t, (a) => {
    const i = a.PATTERN;
    try {
      const s = yb(i), o = new e();
      return o.visit(s), o.found;
    } catch {
      return G3e.test(i.source);
    }
  });
  return Xe(r, (a) => ({
    message: `Unexpected RegExp Anchor Error:
	Token Type: ->` + a.name + `<- static 'PATTERN' cannot contain start of input anchor '^'
	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.`,
    type: Kr.SOI_ANCHOR_FOUND,
    tokenTypes: [a]
  }));
}
function H3e(t) {
  const e = Zr(t, (n) => {
    const a = n[du];
    return a instanceof RegExp && (a.multiline || a.global);
  });
  return Xe(e, (n) => ({
    message: "Token Type: ->" + n.name + "<- static 'PATTERN' may NOT contain global('g') or multiline('m')",
    type: Kr.UNSUPPORTED_FLAGS_FOUND,
    tokenTypes: [n]
  }));
}
function V3e(t) {
  const e = [];
  let r = Xe(t, (i) => fn(t, (s, o) => (i.PATTERN.source === o.PATTERN.source && !ya(e, o) && o.PATTERN !== ka.NA && (e.push(o), s.push(o)), s), []));
  r = ip(r);
  const n = Zr(r, (i) => i.length > 1);
  return Xe(n, (i) => {
    const s = Xe(i, (l) => l.name);
    return {
      message: `The same RegExp pattern ->${Yi(i).PATTERN}<-has been used in all of the following Token Types: ${s.join(", ")} <-`,
      type: Kr.DUPLICATE_PATTERNS_FOUND,
      tokenTypes: i
    };
  });
}
function q3e(t) {
  const e = Zr(t, (n) => {
    if (!Et(n, "GROUP"))
      return !1;
    const a = n.GROUP;
    return a !== ka.SKIPPED && a !== ka.NA && !_a(a);
  });
  return Xe(e, (n) => ({
    message: "Token Type: ->" + n.name + "<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String",
    type: Kr.INVALID_GROUP_TYPE_FOUND,
    tokenTypes: [n]
  }));
}
function W3e(t, e) {
  const r = Zr(t, (a) => a.PUSH_MODE !== void 0 && !ya(e, a.PUSH_MODE));
  return Xe(r, (a) => ({
    message: `Token Type: ->${a.name}<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->${a.PUSH_MODE}<-which does not exist`,
    type: Kr.PUSH_MODE_DOES_NOT_EXIST,
    tokenTypes: [a]
  }));
}
function j3e(t) {
  const e = [], r = fn(t, (n, a, i) => {
    const s = a.PATTERN;
    return s === ka.NA || (_a(s) ? n.push({ str: s, idx: i, tokenType: a }) : lo(s) && X3e(s) && n.push({ str: s.source, idx: i, tokenType: a })), n;
  }, []);
  return ve(t, (n, a) => {
    ve(r, ({ str: i, idx: s, tokenType: o }) => {
      if (a < s && Y3e(i, n.PATTERN)) {
        const l = `Token: ->${o.name}<- can never be matched.
Because it appears AFTER the Token Type ->${n.name}<-in the lexer's definition.
See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE`;
        e.push({
          message: l,
          type: Kr.UNREACHABLE_PATTERN,
          tokenTypes: [n, o]
        });
      }
    });
  }), e;
}
function Y3e(t, e) {
  if (lo(e)) {
    const r = e.exec(t);
    return r !== null && r.index === 0;
  } else {
    if (xi(e))
      return e(t, 0, [], {});
    if (Et(e, "exec"))
      return e.exec(t, 0, [], {});
    if (typeof e == "string")
      return e === t;
    throw Error("non exhaustive match");
  }
}
function X3e(t) {
  return oo([
    ".",
    "\\",
    "[",
    "]",
    "|",
    "^",
    "$",
    "(",
    ")",
    "?",
    "*",
    "+",
    "{"
  ], (r) => t.source.indexOf(r) !== -1) === void 0;
}
function zL(t) {
  const e = t.ignoreCase ? "i" : "";
  return new RegExp(`^(?:${t.source})`, e);
}
function GL(t) {
  const e = t.ignoreCase ? "iy" : "y";
  return new RegExp(`${t.source}`, e);
}
function K3e(t, e, r) {
  const n = [];
  return Et(t, od) || n.push({
    message: "A MultiMode Lexer cannot be initialized without a <" + od + `> property in its definition
`,
    type: Kr.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE
  }), Et(t, Og) || n.push({
    message: "A MultiMode Lexer cannot be initialized without a <" + Og + `> property in its definition
`,
    type: Kr.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY
  }), Et(t, Og) && Et(t, od) && !Et(t.modes, t.defaultMode) && n.push({
    message: `A MultiMode Lexer cannot be initialized with a ${od}: <${t.defaultMode}>which does not exist
`,
    type: Kr.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST
  }), Et(t, Og) && ve(t.modes, (a, i) => {
    ve(a, (s, o) => {
      if (dr(s))
        n.push({
          message: `A Lexer cannot be initialized using an undefined Token Type. Mode:<${i}> at index: <${o}>
`,
          type: Kr.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED
        });
      else if (Et(s, "LONGER_ALT")) {
        const l = jt(s.LONGER_ALT) ? s.LONGER_ALT : [s.LONGER_ALT];
        ve(l, (u) => {
          !dr(u) && !ya(a, u) && n.push({
            message: `A MultiMode Lexer cannot be initialized with a longer_alt <${u.name}> on token <${s.name}> outside of mode <${i}>
`,
            type: Kr.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE
          });
        });
      }
    });
  }), n;
}
function Z3e(t, e, r) {
  const n = [];
  let a = !1;
  const i = ip(kn(wr(t.modes))), s = j1(i, (l) => l[du] === ka.NA), o = HG(r);
  return e && ve(s, (l) => {
    const u = UG(l, o);
    if (u !== !1) {
      const f = {
        message: tAe(l, u),
        type: u.issue,
        tokenType: l
      };
      n.push(f);
    } else
      Et(l, "LINE_BREAKS") ? l.LINE_BREAKS === !0 && (a = !0) : P3(o, l.PATTERN) && (a = !0);
  }), e && !a && n.push({
    message: `Warning: No LINE_BREAKS Found.
	This Lexer has been defined to track line and column information,
	But none of the Token Types can be identified as matching a line terminator.
	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS 
	for details.`,
    type: Kr.NO_LINE_BREAKS_FLAGS
  }), n;
}
function Q3e(t) {
  const e = {}, r = vn(t);
  return ve(r, (n) => {
    const a = t[n];
    if (jt(a))
      e[n] = [];
    else
      throw Error("non exhaustive match");
  }), e;
}
function GG(t) {
  const e = t.PATTERN;
  if (lo(e))
    return !1;
  if (xi(e))
    return !0;
  if (Et(e, "exec"))
    return !0;
  if (_a(e))
    return !1;
  throw Error("non exhaustive match");
}
function J3e(t) {
  return _a(t) && t.length === 1 ? t.charCodeAt(0) : !1;
}
const eAe = {
  // implements /\n|\r\n?/g.test
  test: function(t) {
    const e = t.length;
    for (let r = this.lastIndex; r < e; r++) {
      const n = t.charCodeAt(r);
      if (n === 10)
        return this.lastIndex = r + 1, !0;
      if (n === 13)
        return t.charCodeAt(r + 1) === 10 ? this.lastIndex = r + 2 : this.lastIndex = r + 1, !0;
    }
    return !1;
  },
  lastIndex: 0
};
function UG(t, e) {
  if (Et(t, "LINE_BREAKS"))
    return !1;
  if (lo(t.PATTERN)) {
    try {
      P3(e, t.PATTERN);
    } catch (r) {
      return {
        issue: Kr.IDENTIFY_TERMINATOR,
        errMsg: r.message
      };
    }
    return !1;
  } else {
    if (_a(t.PATTERN))
      return !1;
    if (GG(t))
      return { issue: Kr.CUSTOM_LINE_BREAK };
    throw Error("non exhaustive match");
  }
}
function tAe(t, e) {
  if (e.issue === Kr.IDENTIFY_TERMINATOR)
    return `Warning: unable to identify line terminator usage in pattern.
	The problem is in the <${t.name}> Token Type
	 Root cause: ${e.errMsg}.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR`;
  if (e.issue === Kr.CUSTOM_LINE_BREAK)
    return `Warning: A Custom Token Pattern should specify the <line_breaks> option.
	The problem is in the <${t.name}> Token Type
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK`;
  throw Error("non exhaustive match");
}
function HG(t) {
  return Xe(t, (r) => _a(r) ? r.charCodeAt(0) : r);
}
function Gw(t, e, r) {
  t[e] === void 0 ? t[e] = [r] : t[e].push(r);
}
const ld = 256;
let Mv = [];
function el(t) {
  return t < ld ? t : Mv[t];
}
function rAe() {
  if (mr(Mv)) {
    Mv = new Array(65536);
    for (let t = 0; t < 65536; t++)
      Mv[t] = t > 255 ? 255 + ~~(t / 255) : t;
  }
}
function Ep(t, e) {
  const r = t.tokenTypeIdx;
  return r === e.tokenTypeIdx ? !0 : e.isParent === !0 && e.categoryMatchesMap[r] === !0;
}
function ty(t, e) {
  return t.tokenTypeIdx === e.tokenTypeIdx;
}
let UL = 1;
const VG = {};
function Tp(t) {
  const e = nAe(t);
  aAe(e), sAe(e), iAe(e), ve(e, (r) => {
    r.isParent = r.categoryMatches.length > 0;
  });
}
function nAe(t) {
  let e = _n(t), r = t, n = !0;
  for (; n; ) {
    r = ip(kn(Xe(r, (i) => i.CATEGORIES)));
    const a = q1(r, e);
    e = e.concat(a), mr(a) ? n = !1 : r = a;
  }
  return e;
}
function aAe(t) {
  ve(t, (e) => {
    WG(e) || (VG[UL] = e, e.tokenTypeIdx = UL++), HL(e) && !jt(e.CATEGORIES) && (e.CATEGORIES = [e.CATEGORIES]), HL(e) || (e.CATEGORIES = []), oAe(e) || (e.categoryMatches = []), lAe(e) || (e.categoryMatchesMap = {});
  });
}
function iAe(t) {
  ve(t, (e) => {
    e.categoryMatches = [], ve(e.categoryMatchesMap, (r, n) => {
      e.categoryMatches.push(VG[n].tokenTypeIdx);
    });
  });
}
function sAe(t) {
  ve(t, (e) => {
    qG([], e);
  });
}
function qG(t, e) {
  ve(t, (r) => {
    e.categoryMatchesMap[r.tokenTypeIdx] = !0;
  }), ve(e.CATEGORIES, (r) => {
    const n = t.concat(e);
    ya(n, r) || qG(n, r);
  });
}
function WG(t) {
  return Et(t, "tokenTypeIdx");
}
function HL(t) {
  return Et(t, "CATEGORIES");
}
function oAe(t) {
  return Et(t, "categoryMatches");
}
function lAe(t) {
  return Et(t, "categoryMatchesMap");
}
function uAe(t) {
  return Et(t, "tokenTypeIdx");
}
const q4 = {
  buildUnableToPopLexerModeMessage(t) {
    return `Unable to pop Lexer Mode after encountering Token ->${t.image}<- The Mode Stack is empty`;
  },
  buildUnexpectedCharactersMessage(t, e, r, n, a) {
    return `unexpected character: ->${t.charAt(e)}<- at offset: ${e}, skipped ${r} characters.`;
  }
};
var Kr;
(function(t) {
  t[t.MISSING_PATTERN = 0] = "MISSING_PATTERN", t[t.INVALID_PATTERN = 1] = "INVALID_PATTERN", t[t.EOI_ANCHOR_FOUND = 2] = "EOI_ANCHOR_FOUND", t[t.UNSUPPORTED_FLAGS_FOUND = 3] = "UNSUPPORTED_FLAGS_FOUND", t[t.DUPLICATE_PATTERNS_FOUND = 4] = "DUPLICATE_PATTERNS_FOUND", t[t.INVALID_GROUP_TYPE_FOUND = 5] = "INVALID_GROUP_TYPE_FOUND", t[t.PUSH_MODE_DOES_NOT_EXIST = 6] = "PUSH_MODE_DOES_NOT_EXIST", t[t.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE = 7] = "MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE", t[t.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY = 8] = "MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY", t[t.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST = 9] = "MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST", t[t.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED = 10] = "LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED", t[t.SOI_ANCHOR_FOUND = 11] = "SOI_ANCHOR_FOUND", t[t.EMPTY_MATCH_PATTERN = 12] = "EMPTY_MATCH_PATTERN", t[t.NO_LINE_BREAKS_FLAGS = 13] = "NO_LINE_BREAKS_FLAGS", t[t.UNREACHABLE_PATTERN = 14] = "UNREACHABLE_PATTERN", t[t.IDENTIFY_TERMINATOR = 15] = "IDENTIFY_TERMINATOR", t[t.CUSTOM_LINE_BREAK = 16] = "CUSTOM_LINE_BREAK", t[t.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE = 17] = "MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE";
})(Kr || (Kr = {}));
const ud = {
  deferDefinitionErrorsHandling: !1,
  positionTracking: "full",
  lineTerminatorsPattern: /\n|\r\n?/g,
  lineTerminatorCharacters: [`
`, "\r"],
  ensureOptimizations: !1,
  safeMode: !1,
  errorMessageProvider: q4,
  traceInitPerf: !1,
  skipValidations: !1,
  recoveryEnabled: !0
};
Object.freeze(ud);
class ka {
  constructor(e, r = ud) {
    if (this.lexerDefinition = e, this.lexerDefinitionErrors = [], this.lexerDefinitionWarning = [], this.patternIdxToConfig = {}, this.charCodeToPatternIdxToConfig = {}, this.modes = [], this.emptyGroups = {}, this.trackStartLines = !0, this.trackEndLines = !0, this.hasCustom = !1, this.canModeBeOptimized = {}, this.TRACE_INIT = (a, i) => {
      if (this.traceInitPerf === !0) {
        this.traceInitIndent++;
        const s = new Array(this.traceInitIndent + 1).join("	");
        this.traceInitIndent < this.traceInitMaxIdent && console.log(`${s}--> <${a}>`);
        const { time: o, value: l } = DG(i), u = o > 10 ? console.warn : console.log;
        return this.traceInitIndent < this.traceInitMaxIdent && u(`${s}<-- <${a}> time: ${o}ms`), this.traceInitIndent--, l;
      } else
        return i();
    }, typeof r == "boolean")
      throw Error(`The second argument to the Lexer constructor is now an ILexerConfig Object.
a boolean 2nd argument is no longer supported`);
    this.config = ai({}, ud, r);
    const n = this.config.traceInitPerf;
    n === !0 ? (this.traceInitMaxIdent = 1 / 0, this.traceInitPerf = !0) : typeof n == "number" && (this.traceInitMaxIdent = n, this.traceInitPerf = !0), this.traceInitIndent = -1, this.TRACE_INIT("Lexer Constructor", () => {
      let a, i = !0;
      this.TRACE_INIT("Lexer Config handling", () => {
        if (this.config.lineTerminatorsPattern === ud.lineTerminatorsPattern)
          this.config.lineTerminatorsPattern = eAe;
        else if (this.config.lineTerminatorCharacters === ud.lineTerminatorCharacters)
          throw Error(`Error: Missing <lineTerminatorCharacters> property on the Lexer config.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS`);
        if (r.safeMode && r.ensureOptimizations)
          throw Error('"safeMode" and "ensureOptimizations" flags are mutually exclusive.');
        this.trackStartLines = /full|onlyStart/i.test(this.config.positionTracking), this.trackEndLines = /full/i.test(this.config.positionTracking), jt(e) ? a = {
          modes: { defaultMode: _n(e) },
          defaultMode: od
        } : (i = !1, a = _n(e));
      }), this.config.skipValidations === !1 && (this.TRACE_INIT("performRuntimeChecks", () => {
        this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(K3e(a, this.trackStartLines, this.config.lineTerminatorCharacters));
      }), this.TRACE_INIT("performWarningRuntimeChecks", () => {
        this.lexerDefinitionWarning = this.lexerDefinitionWarning.concat(Z3e(a, this.trackStartLines, this.config.lineTerminatorCharacters));
      })), a.modes = a.modes ? a.modes : {}, ve(a.modes, (o, l) => {
        a.modes[l] = j1(o, (u) => dr(u));
      });
      const s = vn(a.modes);
      if (ve(a.modes, (o, l) => {
        this.TRACE_INIT(`Mode: <${l}> processing`, () => {
          if (this.modes.push(l), this.config.skipValidations === !1 && this.TRACE_INIT("validatePatterns", () => {
            this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(I3e(o, s));
          }), mr(this.lexerDefinitionErrors)) {
            Tp(o);
            let u;
            this.TRACE_INIT("analyzeTokenTypes", () => {
              u = O3e(o, {
                lineTerminatorCharacters: this.config.lineTerminatorCharacters,
                positionTracking: r.positionTracking,
                ensureOptimizations: r.ensureOptimizations,
                safeMode: r.safeMode,
                tracer: this.TRACE_INIT
              });
            }), this.patternIdxToConfig[l] = u.patternIdxToConfig, this.charCodeToPatternIdxToConfig[l] = u.charCodeToPatternIdxToConfig, this.emptyGroups = ai({}, this.emptyGroups, u.emptyGroups), this.hasCustom = u.hasCustom || this.hasCustom, this.canModeBeOptimized[l] = u.canBeOptimized;
          }
        });
      }), this.defaultMode = a.defaultMode, !mr(this.lexerDefinitionErrors) && !this.config.deferDefinitionErrorsHandling) {
        const l = Xe(this.lexerDefinitionErrors, (u) => u.message).join(`-----------------------
`);
        throw new Error(`Errors detected in definition of Lexer:
` + l);
      }
      ve(this.lexerDefinitionWarning, (o) => {
        PG(o.message);
      }), this.TRACE_INIT("Choosing sub-methods implementations", () => {
        if (zG ? (this.chopInput = no, this.match = this.matchWithTest) : (this.updateLastIndex = dn, this.match = this.matchWithExec), i && (this.handleModes = dn), this.trackStartLines === !1 && (this.computeNewColumn = no), this.trackEndLines === !1 && (this.updateTokenEndLineColumnLocation = dn), /full/i.test(this.config.positionTracking))
          this.createTokenInstance = this.createFullToken;
        else if (/onlyStart/i.test(this.config.positionTracking))
          this.createTokenInstance = this.createStartOnlyToken;
        else if (/onlyOffset/i.test(this.config.positionTracking))
          this.createTokenInstance = this.createOffsetOnlyToken;
        else
          throw Error(`Invalid <positionTracking> config option: "${this.config.positionTracking}"`);
        this.hasCustom ? (this.addToken = this.addTokenUsingPush, this.handlePayload = this.handlePayloadWithCustom) : (this.addToken = this.addTokenUsingMemberAccess, this.handlePayload = this.handlePayloadNoCustom);
      }), this.TRACE_INIT("Failed Optimization Warnings", () => {
        const o = fn(this.canModeBeOptimized, (l, u, c) => (u === !1 && l.push(c), l), []);
        if (r.ensureOptimizations && !mr(o))
          throw Error(`Lexer Modes: < ${o.join(", ")} > cannot be optimized.
	 Disable the "ensureOptimizations" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.
	 Or inspect the console log for details on how to resolve these issues.`);
      }), this.TRACE_INIT("clearRegExpParserCache", () => {
        M3e();
      }), this.TRACE_INIT("toFastProperties", () => {
        $G(this);
      });
    });
  }
  tokenize(e, r = this.defaultMode) {
    if (!mr(this.lexerDefinitionErrors)) {
      const a = Xe(this.lexerDefinitionErrors, (i) => i.message).join(`-----------------------
`);
      throw new Error(`Unable to Tokenize because Errors detected in definition of Lexer:
` + a);
    }
    return this.tokenizeInternal(e, r);
  }
  // There is quite a bit of duplication between this and "tokenizeInternalLazy"
  // This is intentional due to performance considerations.
  // this method also used quite a bit of `!` none null assertions because it is too optimized
  // for `tsc` to always understand it is "safe"
  tokenizeInternal(e, r) {
    let n, a, i, s, o, l, u, c, f, h, d, p, g, v, m;
    const b = e, y = b.length;
    let x = 0, E = 0;
    const S = this.hasCustom ? 0 : Math.floor(e.length / 10), w = new Array(S), C = [];
    let k = this.trackStartLines ? 1 : void 0, N = this.trackStartLines ? 1 : void 0;
    const R = Q3e(this.emptyGroups), _ = this.trackStartLines, O = this.config.lineTerminatorsPattern;
    let T = 0, L = [], M = [];
    const A = [], I = [];
    Object.freeze(I);
    let D;
    function F() {
      return L;
    }
    function B(Z) {
      const te = el(Z), ne = M[te];
      return ne === void 0 ? I : ne;
    }
    const G = (Z) => {
      if (A.length === 1 && // if we have both a POP_MODE and a PUSH_MODE this is in-fact a "transition"
      // So no error should occur.
      Z.tokenType.PUSH_MODE === void 0) {
        const te = this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(Z);
        C.push({
          offset: Z.startOffset,
          line: Z.startLine,
          column: Z.startColumn,
          length: Z.image.length,
          message: te
        });
      } else {
        A.pop();
        const te = ms(A);
        L = this.patternIdxToConfig[te], M = this.charCodeToPatternIdxToConfig[te], T = L.length;
        const ne = this.canModeBeOptimized[te] && this.config.safeMode === !1;
        M && ne ? D = B : D = F;
      }
    };
    function H(Z) {
      A.push(Z), M = this.charCodeToPatternIdxToConfig[Z], L = this.patternIdxToConfig[Z], T = L.length, T = L.length;
      const te = this.canModeBeOptimized[Z] && this.config.safeMode === !1;
      M && te ? D = B : D = F;
    }
    H.call(this, r);
    let K;
    const j = this.config.recoveryEnabled;
    for (; x < y; ) {
      l = null;
      const Z = b.charCodeAt(x), te = D(Z), ne = te.length;
      for (n = 0; n < ne; n++) {
        K = te[n];
        const V = K.pattern;
        u = null;
        const q = K.short;
        if (q !== !1 ? Z === q && (l = V) : K.isCustom === !0 ? (m = V.exec(b, x, w, R), m !== null ? (l = m[0], m.payload !== void 0 && (u = m.payload)) : l = null) : (this.updateLastIndex(V, x), l = this.match(V, e, x)), l !== null) {
          if (o = K.longerAlt, o !== void 0) {
            const X = o.length;
            for (i = 0; i < X; i++) {
              const W = L[o[i]], ue = W.pattern;
              if (c = null, W.isCustom === !0 ? (m = ue.exec(b, x, w, R), m !== null ? (s = m[0], m.payload !== void 0 && (c = m.payload)) : s = null) : (this.updateLastIndex(ue, x), s = this.match(ue, e, x)), s && s.length > l.length) {
                l = s, u = c, K = W;
                break;
              }
            }
          }
          break;
        }
      }
      if (l !== null) {
        if (f = l.length, h = K.group, h !== void 0 && (d = K.tokenTypeIdx, p = this.createTokenInstance(l, x, d, K.tokenType, k, N, f), this.handlePayload(p, u), h === !1 ? E = this.addToken(w, E, p) : R[h].push(p)), e = this.chopInput(e, f), x = x + f, N = this.computeNewColumn(N, f), _ === !0 && K.canLineTerminator === !0) {
          let V = 0, q, X;
          O.lastIndex = 0;
          do
            q = O.test(l), q === !0 && (X = O.lastIndex - 1, V++);
          while (q === !0);
          V !== 0 && (k = k + V, N = f - X, this.updateTokenEndLineColumnLocation(p, h, X, V, k, N, f));
        }
        this.handleModes(K, G, H, p);
      } else {
        const V = x, q = k, X = N;
        let W = j === !1;
        for (; W === !1 && x < y; )
          for (e = this.chopInput(e, 1), x++, a = 0; a < T; a++) {
            const ue = L[a], J = ue.pattern, Ce = ue.short;
            if (Ce !== !1 ? b.charCodeAt(x) === Ce && (W = !0) : ue.isCustom === !0 ? W = J.exec(b, x, w, R) !== null : (this.updateLastIndex(J, x), W = J.exec(e) !== null), W === !0)
              break;
          }
        if (g = x - V, N = this.computeNewColumn(N, g), v = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(b, V, g, q, X), C.push({
          offset: V,
          line: q,
          column: X,
          length: g,
          message: v
        }), j === !1)
          break;
      }
    }
    return this.hasCustom || (w.length = E), {
      tokens: w,
      groups: R,
      errors: C
    };
  }
  handleModes(e, r, n, a) {
    if (e.pop === !0) {
      const i = e.push;
      r(a), i !== void 0 && n.call(this, i);
    } else e.push !== void 0 && n.call(this, e.push);
  }
  chopInput(e, r) {
    return e.substring(r);
  }
  updateLastIndex(e, r) {
    e.lastIndex = r;
  }
  // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler
  updateTokenEndLineColumnLocation(e, r, n, a, i, s, o) {
    let l, u;
    r !== void 0 && (l = n === o - 1, u = l ? -1 : 0, a === 1 && l === !0 || (e.endLine = i + u, e.endColumn = s - 1 + -u));
  }
  computeNewColumn(e, r) {
    return e + r;
  }
  createOffsetOnlyToken(e, r, n, a) {
    return {
      image: e,
      startOffset: r,
      tokenTypeIdx: n,
      tokenType: a
    };
  }
  createStartOnlyToken(e, r, n, a, i, s) {
    return {
      image: e,
      startOffset: r,
      startLine: i,
      startColumn: s,
      tokenTypeIdx: n,
      tokenType: a
    };
  }
  createFullToken(e, r, n, a, i, s, o) {
    return {
      image: e,
      startOffset: r,
      endOffset: r + o - 1,
      startLine: i,
      endLine: i,
      startColumn: s,
      endColumn: s + o - 1,
      tokenTypeIdx: n,
      tokenType: a
    };
  }
  addTokenUsingPush(e, r, n) {
    return e.push(n), r;
  }
  addTokenUsingMemberAccess(e, r, n) {
    return e[r] = n, r++, r;
  }
  handlePayloadNoCustom(e, r) {
  }
  handlePayloadWithCustom(e, r) {
    r !== null && (e.payload = r);
  }
  matchWithTest(e, r, n) {
    return e.test(r) === !0 ? r.substring(n, e.lastIndex) : null;
  }
  matchWithExec(e, r) {
    const n = e.exec(r);
    return n !== null ? n[0] : null;
  }
}
ka.SKIPPED = "This marks a skipped Token pattern, this means each token identified by it willbe consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.";
ka.NA = /NOT_APPLICABLE/;
function Ac(t) {
  return jG(t) ? t.LABEL : t.name;
}
function jG(t) {
  return _a(t.LABEL) && t.LABEL !== "";
}
const cAe = "parent", VL = "categories", qL = "label", WL = "group", jL = "push_mode", YL = "pop_mode", XL = "longer_alt", KL = "line_breaks", ZL = "start_chars_hint";
function YG(t) {
  return fAe(t);
}
function fAe(t) {
  const e = t.pattern, r = {};
  if (r.name = t.name, dr(e) || (r.PATTERN = e), Et(t, cAe))
    throw `The parent property is no longer supported.
See: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.`;
  return Et(t, VL) && (r.CATEGORIES = t[VL]), Tp([r]), Et(t, qL) && (r.LABEL = t[qL]), Et(t, WL) && (r.GROUP = t[WL]), Et(t, YL) && (r.POP_MODE = t[YL]), Et(t, jL) && (r.PUSH_MODE = t[jL]), Et(t, XL) && (r.LONGER_ALT = t[XL]), Et(t, KL) && (r.LINE_BREAKS = t[KL]), Et(t, ZL) && (r.START_CHARS_HINT = t[ZL]), r;
}
const tl = YG({ name: "EOF", pattern: ka.NA });
Tp([tl]);
function D3(t, e, r, n, a, i, s, o) {
  return {
    image: e,
    startOffset: r,
    endOffset: n,
    startLine: a,
    endLine: i,
    startColumn: s,
    endColumn: o,
    tokenTypeIdx: t.tokenTypeIdx,
    tokenType: t
  };
}
function XG(t, e) {
  return Ep(t, e);
}
const hc = {
  buildMismatchTokenMessage({ expected: t, actual: e, previous: r, ruleName: n }) {
    return `Expecting ${jG(t) ? `--> ${Ac(t)} <--` : `token of type --> ${t.name} <--`} but found --> '${e.image}' <--`;
  },
  buildNotAllInputParsedMessage({ firstRedundant: t, ruleName: e }) {
    return "Redundant input, expecting EOF but found: " + t.image;
  },
  buildNoViableAltMessage({ expectedPathsPerAlt: t, actual: e, previous: r, customUserDescription: n, ruleName: a }) {
    const i = "Expecting: ", o = `
but found: '` + Yi(e).image + "'";
    if (n)
      return i + n + o;
    {
      const l = fn(t, (h, d) => h.concat(d), []), u = Xe(l, (h) => `[${Xe(h, (d) => Ac(d)).join(", ")}]`), f = `one of these possible Token sequences:
${Xe(u, (h, d) => `  ${d + 1}. ${h}`).join(`
`)}`;
      return i + f + o;
    }
  },
  buildEarlyExitMessage({ expectedIterationPaths: t, actual: e, customUserDescription: r, ruleName: n }) {
    const a = "Expecting: ", s = `
but found: '` + Yi(e).image + "'";
    if (r)
      return a + r + s;
    {
      const l = `expecting at least one iteration which starts with one of these possible Token sequences::
  <${Xe(t, (u) => `[${Xe(u, (c) => Ac(c)).join(",")}]`).join(" ,")}>`;
      return a + l + s;
    }
  }
};
Object.freeze(hc);
const hAe = {
  buildRuleNotFoundError(t, e) {
    return "Invalid grammar, reference to a rule which is not defined: ->" + e.nonTerminalName + `<-
inside top level rule: ->` + t.name + "<-";
  }
}, Hl = {
  buildDuplicateFoundError(t, e) {
    function r(c) {
      return c instanceof Pr ? c.terminalType.name : c instanceof pa ? c.nonTerminalName : "";
    }
    const n = t.name, a = Yi(e), i = a.idx, s = ls(a), o = r(a), l = i > 0;
    let u = `->${s}${l ? i : ""}<- ${o ? `with argument: ->${o}<-` : ""}
                  appears more than once (${e.length} times) in the top level rule: ->${n}<-.                  
                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES 
                  `;
    return u = u.replace(/[ \t]+/g, " "), u = u.replace(/\s\s+/g, `
`), u;
  },
  buildNamespaceConflictError(t) {
    return `Namespace conflict found in grammar.
The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <${t.name}>.
To resolve this make sure each Terminal and Non-Terminal names are unique
This is easy to accomplish by using the convention that Terminal names start with an uppercase letter
and Non-Terminal names start with a lower case letter.`;
  },
  buildAlternationPrefixAmbiguityError(t) {
    const e = Xe(t.prefixPath, (a) => Ac(a)).join(", "), r = t.alternation.idx === 0 ? "" : t.alternation.idx;
    return `Ambiguous alternatives: <${t.ambiguityIndices.join(" ,")}> due to common lookahead prefix
in <OR${r}> inside <${t.topLevelRule.name}> Rule,
<${e}> may appears as a prefix path in all these alternatives.
See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX
For Further details.`;
  },
  buildAlternationAmbiguityError(t) {
    const e = Xe(t.prefixPath, (a) => Ac(a)).join(", "), r = t.alternation.idx === 0 ? "" : t.alternation.idx;
    let n = `Ambiguous Alternatives Detected: <${t.ambiguityIndices.join(" ,")}> in <OR${r}> inside <${t.topLevelRule.name}> Rule,
<${e}> may appears as a prefix path in all these alternatives.
`;
    return n = n + `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES
For Further details.`, n;
  },
  buildEmptyRepetitionError(t) {
    let e = ls(t.repetition);
    return t.repetition.idx !== 0 && (e += t.repetition.idx), `The repetition <${e}> within Rule <${t.topLevelRule.name}> can never consume any tokens.
This could lead to an infinite loop.`;
  },
  // TODO: remove - `errors_public` from nyc.config.js exclude
  //       once this method is fully removed from this file
  buildTokenNameError(t) {
    return "deprecated";
  },
  buildEmptyAlternationError(t) {
    return `Ambiguous empty alternative: <${t.emptyChoiceIdx + 1}> in <OR${t.alternation.idx}> inside <${t.topLevelRule.name}> Rule.
Only the last alternative may be an empty alternative.`;
  },
  buildTooManyAlternativesError(t) {
    return `An Alternation cannot have more than 256 alternatives:
<OR${t.alternation.idx}> inside <${t.topLevelRule.name}> Rule.
 has ${t.alternation.definition.length + 1} alternatives.`;
  },
  buildLeftRecursionError(t) {
    const e = t.topLevelRule.name, r = Xe(t.leftRecursionPath, (i) => i.name), n = `${e} --> ${r.concat([e]).join(" --> ")}`;
    return `Left Recursion found in grammar.
rule: <${e}> can be invoked from itself (directly or indirectly)
without consuming any Tokens. The grammar path that causes this is: 
 ${n}
 To fix this refactor your grammar to remove the left recursion.
see: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.`;
  },
  // TODO: remove - `errors_public` from nyc.config.js exclude
  //       once this method is fully removed from this file
  buildInvalidRuleNameError(t) {
    return "deprecated";
  },
  buildDuplicateRuleNameError(t) {
    let e;
    return t.topLevelRule instanceof Df ? e = t.topLevelRule.name : e = t.topLevelRule, `Duplicate definition, rule: ->${e}<- is already defined in the grammar: ->${t.grammarName}<-`;
  }
};
function dAe(t, e) {
  const r = new pAe(t, e);
  return r.resolveRefs(), r.errors;
}
class pAe extends $f {
  constructor(e, r) {
    super(), this.nameToTopRule = e, this.errMsgProvider = r, this.errors = [];
  }
  resolveRefs() {
    ve(wr(this.nameToTopRule), (e) => {
      this.currTopLevel = e, e.accept(this);
    });
  }
  visitNonTerminal(e) {
    const r = this.nameToTopRule[e.nonTerminalName];
    if (r)
      e.referencedRule = r;
    else {
      const n = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, e);
      this.errors.push({
        message: n,
        type: ga.UNRESOLVED_SUBRULE_REF,
        ruleName: this.currTopLevel.name,
        unresolvedRefName: e.nonTerminalName
      });
    }
  }
}
class gAe extends mb {
  constructor(e, r) {
    super(), this.topProd = e, this.path = r, this.possibleTokTypes = [], this.nextProductionName = "", this.nextProductionOccurrence = 0, this.found = !1, this.isAtEndOfPath = !1;
  }
  startWalking() {
    if (this.found = !1, this.path.ruleStack[0] !== this.topProd.name)
      throw Error("The path does not start with the walker's top Rule!");
    return this.ruleStack = _n(this.path.ruleStack).reverse(), this.occurrenceStack = _n(this.path.occurrenceStack).reverse(), this.ruleStack.pop(), this.occurrenceStack.pop(), this.updateExpectedNext(), this.walk(this.topProd), this.possibleTokTypes;
  }
  walk(e, r = []) {
    this.found || super.walk(e, r);
  }
  walkProdRef(e, r, n) {
    if (e.referencedRule.name === this.nextProductionName && e.idx === this.nextProductionOccurrence) {
      const a = r.concat(n);
      this.updateExpectedNext(), this.walk(e.referencedRule, a);
    }
  }
  updateExpectedNext() {
    mr(this.ruleStack) ? (this.nextProductionName = "", this.nextProductionOccurrence = 0, this.isAtEndOfPath = !0) : (this.nextProductionName = this.ruleStack.pop(), this.nextProductionOccurrence = this.occurrenceStack.pop());
  }
}
class vAe extends gAe {
  constructor(e, r) {
    super(e, r), this.path = r, this.nextTerminalName = "", this.nextTerminalOccurrence = 0, this.nextTerminalName = this.path.lastTok.name, this.nextTerminalOccurrence = this.path.lastTokOccurrence;
  }
  walkTerminal(e, r, n) {
    if (this.isAtEndOfPath && e.terminalType.name === this.nextTerminalName && e.idx === this.nextTerminalOccurrence && !this.found) {
      const a = r.concat(n), i = new La({ definition: a });
      this.possibleTokTypes = wp(i), this.found = !0;
    }
  }
}
class bb extends mb {
  constructor(e, r) {
    super(), this.topRule = e, this.occurrence = r, this.result = {
      token: void 0,
      occurrence: void 0,
      isEndOfRule: void 0
    };
  }
  startWalking() {
    return this.walk(this.topRule), this.result;
  }
}
class mAe extends bb {
  walkMany(e, r, n) {
    if (e.idx === this.occurrence) {
      const a = Yi(r.concat(n));
      this.result.isEndOfRule = a === void 0, a instanceof Pr && (this.result.token = a.terminalType, this.result.occurrence = a.idx);
    } else
      super.walkMany(e, r, n);
  }
}
class QL extends bb {
  walkManySep(e, r, n) {
    if (e.idx === this.occurrence) {
      const a = Yi(r.concat(n));
      this.result.isEndOfRule = a === void 0, a instanceof Pr && (this.result.token = a.terminalType, this.result.occurrence = a.idx);
    } else
      super.walkManySep(e, r, n);
  }
}
class yAe extends bb {
  walkAtLeastOne(e, r, n) {
    if (e.idx === this.occurrence) {
      const a = Yi(r.concat(n));
      this.result.isEndOfRule = a === void 0, a instanceof Pr && (this.result.token = a.terminalType, this.result.occurrence = a.idx);
    } else
      super.walkAtLeastOne(e, r, n);
  }
}
class JL extends bb {
  walkAtLeastOneSep(e, r, n) {
    if (e.idx === this.occurrence) {
      const a = Yi(r.concat(n));
      this.result.isEndOfRule = a === void 0, a instanceof Pr && (this.result.token = a.terminalType, this.result.occurrence = a.idx);
    } else
      super.walkAtLeastOneSep(e, r, n);
  }
}
function W4(t, e, r = []) {
  r = _n(r);
  let n = [], a = 0;
  function i(o) {
    return o.concat(Dn(t, a + 1));
  }
  function s(o) {
    const l = W4(i(o), e, r);
    return n.concat(l);
  }
  for (; r.length < e && a < t.length; ) {
    const o = t[a];
    if (o instanceof La)
      return s(o.definition);
    if (o instanceof pa)
      return s(o.definition);
    if (o instanceof Gn)
      n = s(o.definition);
    else if (o instanceof si) {
      const l = o.definition.concat([
        new Xr({
          definition: o.definition
        })
      ]);
      return s(l);
    } else if (o instanceof oi) {
      const l = [
        new La({ definition: o.definition }),
        new Xr({
          definition: [new Pr({ terminalType: o.separator })].concat(o.definition)
        })
      ];
      return s(l);
    } else if (o instanceof Pa) {
      const l = o.definition.concat([
        new Xr({
          definition: [new Pr({ terminalType: o.separator })].concat(o.definition)
        })
      ]);
      n = s(l);
    } else if (o instanceof Xr) {
      const l = o.definition.concat([
        new Xr({
          definition: o.definition
        })
      ]);
      n = s(l);
    } else {
      if (o instanceof Da)
        return ve(o.definition, (l) => {
          mr(l.definition) === !1 && (n = s(l.definition));
        }), n;
      if (o instanceof Pr)
        r.push(o.terminalType);
      else
        throw Error("non exhaustive match");
    }
    a++;
  }
  return n.push({
    partialPath: r,
    suffixDef: Dn(t, a)
  }), n;
}
function KG(t, e, r, n) {
  const a = "EXIT_NONE_TERMINAL", i = [a], s = "EXIT_ALTERNATIVE";
  let o = !1;
  const l = e.length, u = l - n - 1, c = [], f = [];
  for (f.push({
    idx: -1,
    def: t,
    ruleStack: [],
    occurrenceStack: []
  }); !mr(f); ) {
    const h = f.pop();
    if (h === s) {
      o && ms(f).idx <= u && f.pop();
      continue;
    }
    const d = h.def, p = h.idx, g = h.ruleStack, v = h.occurrenceStack;
    if (mr(d))
      continue;
    const m = d[0];
    if (m === a) {
      const b = {
        idx: p,
        def: Dn(d),
        ruleStack: a0(g),
        occurrenceStack: a0(v)
      };
      f.push(b);
    } else if (m instanceof Pr)
      if (p < l - 1) {
        const b = p + 1, y = e[b];
        if (r(y, m.terminalType)) {
          const x = {
            idx: b,
            def: Dn(d),
            ruleStack: g,
            occurrenceStack: v
          };
          f.push(x);
        }
      } else if (p === l - 1)
        c.push({
          nextTokenType: m.terminalType,
          nextTokenOccurrence: m.idx,
          ruleStack: g,
          occurrenceStack: v
        }), o = !0;
      else
        throw Error("non exhaustive match");
    else if (m instanceof pa) {
      const b = _n(g);
      b.push(m.nonTerminalName);
      const y = _n(v);
      y.push(m.idx);
      const x = {
        idx: p,
        def: m.definition.concat(i, Dn(d)),
        ruleStack: b,
        occurrenceStack: y
      };
      f.push(x);
    } else if (m instanceof Gn) {
      const b = {
        idx: p,
        def: Dn(d),
        ruleStack: g,
        occurrenceStack: v
      };
      f.push(b), f.push(s);
      const y = {
        idx: p,
        def: m.definition.concat(Dn(d)),
        ruleStack: g,
        occurrenceStack: v
      };
      f.push(y);
    } else if (m instanceof si) {
      const b = new Xr({
        definition: m.definition,
        idx: m.idx
      }), y = m.definition.concat([b], Dn(d)), x = {
        idx: p,
        def: y,
        ruleStack: g,
        occurrenceStack: v
      };
      f.push(x);
    } else if (m instanceof oi) {
      const b = new Pr({
        terminalType: m.separator
      }), y = new Xr({
        definition: [b].concat(m.definition),
        idx: m.idx
      }), x = m.definition.concat([y], Dn(d)), E = {
        idx: p,
        def: x,
        ruleStack: g,
        occurrenceStack: v
      };
      f.push(E);
    } else if (m instanceof Pa) {
      const b = {
        idx: p,
        def: Dn(d),
        ruleStack: g,
        occurrenceStack: v
      };
      f.push(b), f.push(s);
      const y = new Pr({
        terminalType: m.separator
      }), x = new Xr({
        definition: [y].concat(m.definition),
        idx: m.idx
      }), E = m.definition.concat([x], Dn(d)), S = {
        idx: p,
        def: E,
        ruleStack: g,
        occurrenceStack: v
      };
      f.push(S);
    } else if (m instanceof Xr) {
      const b = {
        idx: p,
        def: Dn(d),
        ruleStack: g,
        occurrenceStack: v
      };
      f.push(b), f.push(s);
      const y = new Xr({
        definition: m.definition,
        idx: m.idx
      }), x = m.definition.concat([y], Dn(d)), E = {
        idx: p,
        def: x,
        ruleStack: g,
        occurrenceStack: v
      };
      f.push(E);
    } else if (m instanceof Da)
      for (let b = m.definition.length - 1; b >= 0; b--) {
        const y = m.definition[b], x = {
          idx: p,
          def: y.definition.concat(Dn(d)),
          ruleStack: g,
          occurrenceStack: v
        };
        f.push(x), f.push(s);
      }
    else if (m instanceof La)
      f.push({
        idx: p,
        def: m.definition.concat(Dn(d)),
        ruleStack: g,
        occurrenceStack: v
      });
    else if (m instanceof Df)
      f.push(bAe(m, p, g, v));
    else
      throw Error("non exhaustive match");
  }
  return c;
}
function bAe(t, e, r, n) {
  const a = _n(r);
  a.push(t.name);
  const i = _n(n);
  return i.push(1), {
    idx: e,
    def: t.definition,
    ruleStack: a,
    occurrenceStack: i
  };
}
var Hr;
(function(t) {
  t[t.OPTION = 0] = "OPTION", t[t.REPETITION = 1] = "REPETITION", t[t.REPETITION_MANDATORY = 2] = "REPETITION_MANDATORY", t[t.REPETITION_MANDATORY_WITH_SEPARATOR = 3] = "REPETITION_MANDATORY_WITH_SEPARATOR", t[t.REPETITION_WITH_SEPARATOR = 4] = "REPETITION_WITH_SEPARATOR", t[t.ALTERNATION = 5] = "ALTERNATION";
})(Hr || (Hr = {}));
function $3(t) {
  if (t instanceof Gn || t === "Option")
    return Hr.OPTION;
  if (t instanceof Xr || t === "Repetition")
    return Hr.REPETITION;
  if (t instanceof si || t === "RepetitionMandatory")
    return Hr.REPETITION_MANDATORY;
  if (t instanceof oi || t === "RepetitionMandatoryWithSeparator")
    return Hr.REPETITION_MANDATORY_WITH_SEPARATOR;
  if (t instanceof Pa || t === "RepetitionWithSeparator")
    return Hr.REPETITION_WITH_SEPARATOR;
  if (t instanceof Da || t === "Alternation")
    return Hr.ALTERNATION;
  throw Error("non exhaustive match");
}
function eN(t) {
  const { occurrence: e, rule: r, prodType: n, maxLookahead: a } = t, i = $3(n);
  return i === Hr.ALTERNATION ? xb(e, r, a) : wb(e, r, i, a);
}
function xAe(t, e, r, n, a, i) {
  const s = xb(t, e, r), o = JG(s) ? ty : Ep;
  return i(s, n, o, a);
}
function wAe(t, e, r, n, a, i) {
  const s = wb(t, e, a, r), o = JG(s) ? ty : Ep;
  return i(s[0], o, n);
}
function EAe(t, e, r, n) {
  const a = t.length, i = Hi(t, (s) => Hi(s, (o) => o.length === 1));
  if (e)
    return function(s) {
      const o = Xe(s, (l) => l.GATE);
      for (let l = 0; l < a; l++) {
        const u = t[l], c = u.length, f = o[l];
        if (!(f !== void 0 && f.call(this) === !1))
          e: for (let h = 0; h < c; h++) {
            const d = u[h], p = d.length;
            for (let g = 0; g < p; g++) {
              const v = this.LA(g + 1);
              if (r(v, d[g]) === !1)
                continue e;
            }
            return l;
          }
      }
    };
  if (i && !n) {
    const s = Xe(t, (l) => kn(l)), o = fn(s, (l, u, c) => (ve(u, (f) => {
      Et(l, f.tokenTypeIdx) || (l[f.tokenTypeIdx] = c), ve(f.categoryMatches, (h) => {
        Et(l, h) || (l[h] = c);
      });
    }), l), {});
    return function() {
      const l = this.LA(1);
      return o[l.tokenTypeIdx];
    };
  } else
    return function() {
      for (let s = 0; s < a; s++) {
        const o = t[s], l = o.length;
        e: for (let u = 0; u < l; u++) {
          const c = o[u], f = c.length;
          for (let h = 0; h < f; h++) {
            const d = this.LA(h + 1);
            if (r(d, c[h]) === !1)
              continue e;
          }
          return s;
        }
      }
    };
}
function TAe(t, e, r) {
  const n = Hi(t, (i) => i.length === 1), a = t.length;
  if (n && !r) {
    const i = kn(t);
    if (i.length === 1 && mr(i[0].categoryMatches)) {
      const o = i[0].tokenTypeIdx;
      return function() {
        return this.LA(1).tokenTypeIdx === o;
      };
    } else {
      const s = fn(i, (o, l, u) => (o[l.tokenTypeIdx] = !0, ve(l.categoryMatches, (c) => {
        o[c] = !0;
      }), o), []);
      return function() {
        const o = this.LA(1);
        return s[o.tokenTypeIdx] === !0;
      };
    }
  } else
    return function() {
      e: for (let i = 0; i < a; i++) {
        const s = t[i], o = s.length;
        for (let l = 0; l < o; l++) {
          const u = this.LA(l + 1);
          if (e(u, s[l]) === !1)
            continue e;
        }
        return !0;
      }
      return !1;
    };
}
class SAe extends mb {
  constructor(e, r, n) {
    super(), this.topProd = e, this.targetOccurrence = r, this.targetProdType = n;
  }
  startWalking() {
    return this.walk(this.topProd), this.restDef;
  }
  checkIsTarget(e, r, n, a) {
    return e.idx === this.targetOccurrence && this.targetProdType === r ? (this.restDef = n.concat(a), !0) : !1;
  }
  walkOption(e, r, n) {
    this.checkIsTarget(e, Hr.OPTION, r, n) || super.walkOption(e, r, n);
  }
  walkAtLeastOne(e, r, n) {
    this.checkIsTarget(e, Hr.REPETITION_MANDATORY, r, n) || super.walkOption(e, r, n);
  }
  walkAtLeastOneSep(e, r, n) {
    this.checkIsTarget(e, Hr.REPETITION_MANDATORY_WITH_SEPARATOR, r, n) || super.walkOption(e, r, n);
  }
  walkMany(e, r, n) {
    this.checkIsTarget(e, Hr.REPETITION, r, n) || super.walkOption(e, r, n);
  }
  walkManySep(e, r, n) {
    this.checkIsTarget(e, Hr.REPETITION_WITH_SEPARATOR, r, n) || super.walkOption(e, r, n);
  }
}
class ZG extends $f {
  constructor(e, r, n) {
    super(), this.targetOccurrence = e, this.targetProdType = r, this.targetRef = n, this.result = [];
  }
  checkIsTarget(e, r) {
    e.idx === this.targetOccurrence && this.targetProdType === r && (this.targetRef === void 0 || e === this.targetRef) && (this.result = e.definition);
  }
  visitOption(e) {
    this.checkIsTarget(e, Hr.OPTION);
  }
  visitRepetition(e) {
    this.checkIsTarget(e, Hr.REPETITION);
  }
  visitRepetitionMandatory(e) {
    this.checkIsTarget(e, Hr.REPETITION_MANDATORY);
  }
  visitRepetitionMandatoryWithSeparator(e) {
    this.checkIsTarget(e, Hr.REPETITION_MANDATORY_WITH_SEPARATOR);
  }
  visitRepetitionWithSeparator(e) {
    this.checkIsTarget(e, Hr.REPETITION_WITH_SEPARATOR);
  }
  visitAlternation(e) {
    this.checkIsTarget(e, Hr.ALTERNATION);
  }
}
function tN(t) {
  const e = new Array(t);
  for (let r = 0; r < t; r++)
    e[r] = [];
  return e;
}
function Uw(t) {
  let e = [""];
  for (let r = 0; r < t.length; r++) {
    const n = t[r], a = [];
    for (let i = 0; i < e.length; i++) {
      const s = e[i];
      a.push(s + "_" + n.tokenTypeIdx);
      for (let o = 0; o < n.categoryMatches.length; o++) {
        const l = "_" + n.categoryMatches[o];
        a.push(s + l);
      }
    }
    e = a;
  }
  return e;
}
function CAe(t, e, r) {
  for (let n = 0; n < t.length; n++) {
    if (n === r)
      continue;
    const a = t[n];
    for (let i = 0; i < e.length; i++) {
      const s = e[i];
      if (a[s] === !0)
        return !1;
    }
  }
  return !0;
}
function QG(t, e) {
  const r = Xe(t, (s) => W4([s], 1)), n = tN(r.length), a = Xe(r, (s) => {
    const o = {};
    return ve(s, (l) => {
      const u = Uw(l.partialPath);
      ve(u, (c) => {
        o[c] = !0;
      });
    }), o;
  });
  let i = r;
  for (let s = 1; s <= e; s++) {
    const o = i;
    i = tN(o.length);
    for (let l = 0; l < o.length; l++) {
      const u = o[l];
      for (let c = 0; c < u.length; c++) {
        const f = u[c].partialPath, h = u[c].suffixDef, d = Uw(f);
        if (CAe(a, d, l) || mr(h) || f.length === e) {
          const g = n[l];
          if (j4(g, f) === !1) {
            g.push(f);
            for (let v = 0; v < d.length; v++) {
              const m = d[v];
              a[l][m] = !0;
            }
          }
        } else {
          const g = W4(h, s + 1, f);
          i[l] = i[l].concat(g), ve(g, (v) => {
            const m = Uw(v.partialPath);
            ve(m, (b) => {
              a[l][b] = !0;
            });
          });
        }
      }
    }
  }
  return n;
}
function xb(t, e, r, n) {
  const a = new ZG(t, Hr.ALTERNATION, n);
  return e.accept(a), QG(a.result, r);
}
function wb(t, e, r, n) {
  const a = new ZG(t, r);
  e.accept(a);
  const i = a.result, o = new SAe(e, t, r).startWalking(), l = new La({ definition: i }), u = new La({ definition: o });
  return QG([l, u], n);
}
function j4(t, e) {
  e: for (let r = 0; r < t.length; r++) {
    const n = t[r];
    if (n.length === e.length) {
      for (let a = 0; a < n.length; a++) {
        const i = e[a], s = n[a];
        if ((i === s || s.categoryMatchesMap[i.tokenTypeIdx] !== void 0) === !1)
          continue e;
      }
      return !0;
    }
  }
  return !1;
}
function AAe(t, e) {
  return t.length < e.length && Hi(t, (r, n) => {
    const a = e[n];
    return r === a || a.categoryMatchesMap[r.tokenTypeIdx];
  });
}
function JG(t) {
  return Hi(t, (e) => Hi(e, (r) => Hi(r, (n) => mr(n.categoryMatches))));
}
function kAe(t) {
  const e = t.lookaheadStrategy.validate({
    rules: t.rules,
    tokenTypes: t.tokenTypes,
    grammarName: t.grammarName
  });
  return Xe(e, (r) => Object.assign({ type: ga.CUSTOM_LOOKAHEAD_VALIDATION }, r));
}
function RAe(t, e, r, n) {
  const a = ti(t, (l) => MAe(l, r)), i = GAe(t, e, r), s = ti(t, (l) => $Ae(l, r)), o = ti(t, (l) => NAe(l, t, n, r));
  return a.concat(i, s, o);
}
function MAe(t, e) {
  const r = new LAe();
  t.accept(r);
  const n = r.allProductions, a = pbe(n, _Ae), i = Ji(a, (o) => o.length > 1);
  return Xe(wr(i), (o) => {
    const l = Yi(o), u = e.buildDuplicateFoundError(t, o), c = ls(l), f = {
      message: u,
      type: ga.DUPLICATE_PRODUCTIONS,
      ruleName: t.name,
      dslName: c,
      occurrence: l.idx
    }, h = eU(l);
    return h && (f.parameter = h), f;
  });
}
function _Ae(t) {
  return `${ls(t)}_#_${t.idx}_#_${eU(t)}`;
}
function eU(t) {
  return t instanceof Pr ? t.terminalType.name : t instanceof pa ? t.nonTerminalName : "";
}
class LAe extends $f {
  constructor() {
    super(...arguments), this.allProductions = [];
  }
  visitNonTerminal(e) {
    this.allProductions.push(e);
  }
  visitOption(e) {
    this.allProductions.push(e);
  }
  visitRepetitionWithSeparator(e) {
    this.allProductions.push(e);
  }
  visitRepetitionMandatory(e) {
    this.allProductions.push(e);
  }
  visitRepetitionMandatoryWithSeparator(e) {
    this.allProductions.push(e);
  }
  visitRepetition(e) {
    this.allProductions.push(e);
  }
  visitAlternation(e) {
    this.allProductions.push(e);
  }
  visitTerminal(e) {
    this.allProductions.push(e);
  }
}
function NAe(t, e, r, n) {
  const a = [];
  if (fn(e, (s, o) => o.name === t.name ? s + 1 : s, 0) > 1) {
    const s = n.buildDuplicateRuleNameError({
      topLevelRule: t,
      grammarName: r
    });
    a.push({
      message: s,
      type: ga.DUPLICATE_RULE_NAME,
      ruleName: t.name
    });
  }
  return a;
}
function OAe(t, e, r) {
  const n = [];
  let a;
  return ya(e, t) || (a = `Invalid rule override, rule: ->${t}<- cannot be overridden in the grammar: ->${r}<-as it is not defined in any of the super grammars `, n.push({
    message: a,
    type: ga.INVALID_RULE_OVERRIDE,
    ruleName: t
  })), n;
}
function tU(t, e, r, n = []) {
  const a = [], i = _v(e.definition);
  if (mr(i))
    return [];
  {
    const s = t.name;
    ya(i, t) && a.push({
      message: r.buildLeftRecursionError({
        topLevelRule: t,
        leftRecursionPath: n
      }),
      type: ga.LEFT_RECURSION,
      ruleName: s
    });
    const l = q1(i, n.concat([t])), u = ti(l, (c) => {
      const f = _n(n);
      return f.push(c), tU(t, c, r, f);
    });
    return a.concat(u);
  }
}
function _v(t) {
  let e = [];
  if (mr(t))
    return e;
  const r = Yi(t);
  if (r instanceof pa)
    e.push(r.referencedRule);
  else if (r instanceof La || r instanceof Gn || r instanceof si || r instanceof oi || r instanceof Pa || r instanceof Xr)
    e = e.concat(_v(r.definition));
  else if (r instanceof Da)
    e = kn(Xe(r.definition, (i) => _v(i.definition)));
  else if (!(r instanceof Pr)) throw Error("non exhaustive match");
  const n = Jm(r), a = t.length > 1;
  if (n && a) {
    const i = Dn(t);
    return e.concat(_v(i));
  } else
    return e;
}
class F3 extends $f {
  constructor() {
    super(...arguments), this.alternations = [];
  }
  visitAlternation(e) {
    this.alternations.push(e);
  }
}
function IAe(t, e) {
  const r = new F3();
  t.accept(r);
  const n = r.alternations;
  return ti(n, (i) => {
    const s = a0(i.definition);
    return ti(s, (o, l) => {
      const u = KG([o], [], Ep, 1);
      return mr(u) ? [
        {
          message: e.buildEmptyAlternationError({
            topLevelRule: t,
            alternation: i,
            emptyChoiceIdx: l
          }),
          type: ga.NONE_LAST_EMPTY_ALT,
          ruleName: t.name,
          occurrence: i.idx,
          alternative: l + 1
        }
      ] : [];
    });
  });
}
function PAe(t, e, r) {
  const n = new F3();
  t.accept(n);
  let a = n.alternations;
  return a = j1(a, (s) => s.ignoreAmbiguities === !0), ti(a, (s) => {
    const o = s.idx, l = s.maxLookahead || e, u = xb(o, t, l, s), c = BAe(u, s, t, r), f = zAe(u, s, t, r);
    return c.concat(f);
  });
}
class DAe extends $f {
  constructor() {
    super(...arguments), this.allProductions = [];
  }
  visitRepetitionWithSeparator(e) {
    this.allProductions.push(e);
  }
  visitRepetitionMandatory(e) {
    this.allProductions.push(e);
  }
  visitRepetitionMandatoryWithSeparator(e) {
    this.allProductions.push(e);
  }
  visitRepetition(e) {
    this.allProductions.push(e);
  }
}
function $Ae(t, e) {
  const r = new F3();
  t.accept(r);
  const n = r.alternations;
  return ti(n, (i) => i.definition.length > 255 ? [
    {
      message: e.buildTooManyAlternativesError({
        topLevelRule: t,
        alternation: i
      }),
      type: ga.TOO_MANY_ALTS,
      ruleName: t.name,
      occurrence: i.idx
    }
  ] : []);
}
function FAe(t, e, r) {
  const n = [];
  return ve(t, (a) => {
    const i = new DAe();
    a.accept(i);
    const s = i.allProductions;
    ve(s, (o) => {
      const l = $3(o), u = o.maxLookahead || e, c = o.idx, h = wb(c, a, l, u)[0];
      if (mr(kn(h))) {
        const d = r.buildEmptyRepetitionError({
          topLevelRule: a,
          repetition: o
        });
        n.push({
          message: d,
          type: ga.NO_NON_EMPTY_LOOKAHEAD,
          ruleName: a.name
        });
      }
    });
  }), n;
}
function BAe(t, e, r, n) {
  const a = [], i = fn(t, (o, l, u) => (e.definition[u].ignoreAmbiguities === !0 || ve(l, (c) => {
    const f = [u];
    ve(t, (h, d) => {
      u !== d && j4(h, c) && // ignore (skip) ambiguities with this "other" alternative
      e.definition[d].ignoreAmbiguities !== !0 && f.push(d);
    }), f.length > 1 && !j4(a, c) && (a.push(c), o.push({
      alts: f,
      path: c
    }));
  }), o), []);
  return Xe(i, (o) => {
    const l = Xe(o.alts, (c) => c + 1);
    return {
      message: n.buildAlternationAmbiguityError({
        topLevelRule: r,
        alternation: e,
        ambiguityIndices: l,
        prefixPath: o.path
      }),
      type: ga.AMBIGUOUS_ALTS,
      ruleName: r.name,
      occurrence: e.idx,
      alternatives: o.alts
    };
  });
}
function zAe(t, e, r, n) {
  const a = fn(t, (s, o, l) => {
    const u = Xe(o, (c) => ({ idx: l, path: c }));
    return s.concat(u);
  }, []);
  return ip(ti(a, (s) => {
    if (e.definition[s.idx].ignoreAmbiguities === !0)
      return [];
    const l = s.idx, u = s.path, c = Zr(a, (h) => (
      // ignore (skip) ambiguities with this "other" alternative
      e.definition[h.idx].ignoreAmbiguities !== !0 && h.idx < l && // checking for strict prefix because identical lookaheads
      // will be be detected using a different validation.
      AAe(h.path, u)
    ));
    return Xe(c, (h) => {
      const d = [h.idx + 1, l + 1], p = e.idx === 0 ? "" : e.idx;
      return {
        message: n.buildAlternationPrefixAmbiguityError({
          topLevelRule: r,
          alternation: e,
          ambiguityIndices: d,
          prefixPath: h.path
        }),
        type: ga.AMBIGUOUS_PREFIX_ALTS,
        ruleName: r.name,
        occurrence: p,
        alternatives: d
      };
    });
  }));
}
function GAe(t, e, r) {
  const n = [], a = Xe(e, (i) => i.name);
  return ve(t, (i) => {
    const s = i.name;
    if (ya(a, s)) {
      const o = r.buildNamespaceConflictError(i);
      n.push({
        message: o,
        type: ga.CONFLICT_TOKENS_RULES_NAMESPACE,
        ruleName: s
      });
    }
  }), n;
}
function UAe(t) {
  const e = V1(t, {
    errMsgProvider: hAe
  }), r = {};
  return ve(t.rules, (n) => {
    r[n.name] = n;
  }), dAe(r, e.errMsgProvider);
}
function HAe(t) {
  return t = V1(t, {
    errMsgProvider: Hl
  }), RAe(t.rules, t.tokenTypes, t.errMsgProvider, t.grammarName);
}
const rU = "MismatchedTokenException", nU = "NoViableAltException", aU = "EarlyExitException", iU = "NotAllInputParsedException", sU = [
  rU,
  nU,
  aU,
  iU
];
Object.freeze(sU);
function ry(t) {
  return ya(sU, t.name);
}
class Eb extends Error {
  constructor(e, r) {
    super(e), this.token = r, this.resyncedTokens = [], Object.setPrototypeOf(this, new.target.prototype), Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
  }
}
class oU extends Eb {
  constructor(e, r, n) {
    super(e, r), this.previousToken = n, this.name = rU;
  }
}
class VAe extends Eb {
  constructor(e, r, n) {
    super(e, r), this.previousToken = n, this.name = nU;
  }
}
class qAe extends Eb {
  constructor(e, r) {
    super(e, r), this.name = iU;
  }
}
class WAe extends Eb {
  constructor(e, r, n) {
    super(e, r), this.previousToken = n, this.name = aU;
  }
}
const Hw = {}, lU = "InRuleRecoveryException";
class jAe extends Error {
  constructor(e) {
    super(e), this.name = lU;
  }
}
class YAe {
  initRecoverable(e) {
    this.firstAfterRepMap = {}, this.resyncFollows = {}, this.recoveryEnabled = Et(e, "recoveryEnabled") ? e.recoveryEnabled : fo.recoveryEnabled, this.recoveryEnabled && (this.attemptInRepetitionRecovery = XAe);
  }
  getTokenToInsert(e) {
    const r = D3(e, "", NaN, NaN, NaN, NaN, NaN, NaN);
    return r.isInsertedInRecovery = !0, r;
  }
  canTokenTypeBeInsertedInRecovery(e) {
    return !0;
  }
  canTokenTypeBeDeletedInRecovery(e) {
    return !0;
  }
  tryInRepetitionRecovery(e, r, n, a) {
    const i = this.findReSyncTokenType(), s = this.exportLexerState(), o = [];
    let l = !1;
    const u = this.LA(1);
    let c = this.LA(1);
    const f = () => {
      const h = this.LA(0), d = this.errorMessageProvider.buildMismatchTokenMessage({
        expected: a,
        actual: u,
        previous: h,
        ruleName: this.getCurrRuleFullName()
      }), p = new oU(d, u, this.LA(0));
      p.resyncedTokens = a0(o), this.SAVE_ERROR(p);
    };
    for (; !l; )
      if (this.tokenMatcher(c, a)) {
        f();
        return;
      } else if (n.call(this)) {
        f(), e.apply(this, r);
        return;
      } else this.tokenMatcher(c, i) ? l = !0 : (c = this.SKIP_TOKEN(), this.addToResyncTokens(c, o));
    this.importLexerState(s);
  }
  shouldInRepetitionRecoveryBeTried(e, r, n) {
    return !(n === !1 || this.tokenMatcher(this.LA(1), e) || this.isBackTracking() || this.canPerformInRuleRecovery(e, this.getFollowsForInRuleRecovery(e, r)));
  }
  // Error Recovery functionality
  getFollowsForInRuleRecovery(e, r) {
    const n = this.getCurrentGrammarPath(e, r);
    return this.getNextPossibleTokenTypes(n);
  }
  tryInRuleRecovery(e, r) {
    if (this.canRecoverWithSingleTokenInsertion(e, r))
      return this.getTokenToInsert(e);
    if (this.canRecoverWithSingleTokenDeletion(e)) {
      const n = this.SKIP_TOKEN();
      return this.consumeToken(), n;
    }
    throw new jAe("sad sad panda");
  }
  canPerformInRuleRecovery(e, r) {
    return this.canRecoverWithSingleTokenInsertion(e, r) || this.canRecoverWithSingleTokenDeletion(e);
  }
  canRecoverWithSingleTokenInsertion(e, r) {
    if (!this.canTokenTypeBeInsertedInRecovery(e) || mr(r))
      return !1;
    const n = this.LA(1);
    return oo(r, (i) => this.tokenMatcher(n, i)) !== void 0;
  }
  canRecoverWithSingleTokenDeletion(e) {
    return this.canTokenTypeBeDeletedInRecovery(e) ? this.tokenMatcher(this.LA(2), e) : !1;
  }
  isInCurrentRuleReSyncSet(e) {
    const r = this.getCurrFollowKey(), n = this.getFollowSetFromFollowKey(r);
    return ya(n, e);
  }
  findReSyncTokenType() {
    const e = this.flattenFollowSet();
    let r = this.LA(1), n = 2;
    for (; ; ) {
      const a = oo(e, (i) => XG(r, i));
      if (a !== void 0)
        return a;
      r = this.LA(n), n++;
    }
  }
  getCurrFollowKey() {
    if (this.RULE_STACK.length === 1)
      return Hw;
    const e = this.getLastExplicitRuleShortName(), r = this.getLastExplicitRuleOccurrenceIndex(), n = this.getPreviousExplicitRuleShortName();
    return {
      ruleName: this.shortRuleNameToFullName(e),
      idxInCallingRule: r,
      inRule: this.shortRuleNameToFullName(n)
    };
  }
  buildFullFollowKeyStack() {
    const e = this.RULE_STACK, r = this.RULE_OCCURRENCE_STACK;
    return Xe(e, (n, a) => a === 0 ? Hw : {
      ruleName: this.shortRuleNameToFullName(n),
      idxInCallingRule: r[a],
      inRule: this.shortRuleNameToFullName(e[a - 1])
    });
  }
  flattenFollowSet() {
    const e = Xe(this.buildFullFollowKeyStack(), (r) => this.getFollowSetFromFollowKey(r));
    return kn(e);
  }
  getFollowSetFromFollowKey(e) {
    if (e === Hw)
      return [tl];
    const r = e.ruleName + e.idxInCallingRule + FG + e.inRule;
    return this.resyncFollows[r];
  }
  // It does not make any sense to include a virtual EOF token in the list of resynced tokens
  // as EOF does not really exist and thus does not contain any useful information (line/column numbers)
  addToResyncTokens(e, r) {
    return this.tokenMatcher(e, tl) || r.push(e), r;
  }
  reSyncTo(e) {
    const r = [];
    let n = this.LA(1);
    for (; this.tokenMatcher(n, e) === !1; )
      n = this.SKIP_TOKEN(), this.addToResyncTokens(n, r);
    return a0(r);
  }
  attemptInRepetitionRecovery(e, r, n, a, i, s, o) {
  }
  getCurrentGrammarPath(e, r) {
    const n = this.getHumanReadableRuleStack(), a = _n(this.RULE_OCCURRENCE_STACK);
    return {
      ruleStack: n,
      occurrenceStack: a,
      lastTok: e,
      lastTokOccurrence: r
    };
  }
  getHumanReadableRuleStack() {
    return Xe(this.RULE_STACK, (e) => this.shortRuleNameToFullName(e));
  }
}
function XAe(t, e, r, n, a, i, s) {
  const o = this.getKeyForAutomaticLookahead(n, a);
  let l = this.firstAfterRepMap[o];
  if (l === void 0) {
    const h = this.getCurrRuleFullName(), d = this.getGAstProductions()[h];
    l = new i(d, a).startWalking(), this.firstAfterRepMap[o] = l;
  }
  let u = l.token, c = l.occurrence;
  const f = l.isEndOfRule;
  this.RULE_STACK.length === 1 && f && u === void 0 && (u = tl, c = 1), !(u === void 0 || c === void 0) && this.shouldInRepetitionRecoveryBeTried(u, c, s) && this.tryInRepetitionRecovery(t, e, r, u);
}
const KAe = 4, ml = 8, uU = 1 << ml, cU = 2 << ml, Y4 = 3 << ml, X4 = 4 << ml, K4 = 5 << ml, Lv = 6 << ml;
function Vw(t, e, r) {
  return r | e | t;
}
class B3 {
  constructor(e) {
    var r;
    this.maxLookahead = (r = e == null ? void 0 : e.maxLookahead) !== null && r !== void 0 ? r : fo.maxLookahead;
  }
  validate(e) {
    const r = this.validateNoLeftRecursion(e.rules);
    if (mr(r)) {
      const n = this.validateEmptyOrAlternatives(e.rules), a = this.validateAmbiguousAlternationAlternatives(e.rules, this.maxLookahead), i = this.validateSomeNonEmptyLookaheadPath(e.rules, this.maxLookahead);
      return [
        ...r,
        ...n,
        ...a,
        ...i
      ];
    }
    return r;
  }
  validateNoLeftRecursion(e) {
    return ti(e, (r) => tU(r, r, Hl));
  }
  validateEmptyOrAlternatives(e) {
    return ti(e, (r) => IAe(r, Hl));
  }
  validateAmbiguousAlternationAlternatives(e, r) {
    return ti(e, (n) => PAe(n, r, Hl));
  }
  validateSomeNonEmptyLookaheadPath(e, r) {
    return FAe(e, r, Hl);
  }
  buildLookaheadForAlternation(e) {
    return xAe(e.prodOccurrence, e.rule, e.maxLookahead, e.hasPredicates, e.dynamicTokensEnabled, EAe);
  }
  buildLookaheadForOptional(e) {
    return wAe(e.prodOccurrence, e.rule, e.maxLookahead, e.dynamicTokensEnabled, $3(e.prodType), TAe);
  }
}
class ZAe {
  initLooksAhead(e) {
    this.dynamicTokensEnabled = Et(e, "dynamicTokensEnabled") ? e.dynamicTokensEnabled : fo.dynamicTokensEnabled, this.maxLookahead = Et(e, "maxLookahead") ? e.maxLookahead : fo.maxLookahead, this.lookaheadStrategy = Et(e, "lookaheadStrategy") ? e.lookaheadStrategy : new B3({ maxLookahead: this.maxLookahead }), this.lookAheadFuncsCache = /* @__PURE__ */ new Map();
  }
  preComputeLookaheadFunctions(e) {
    ve(e, (r) => {
      this.TRACE_INIT(`${r.name} Rule Lookahead`, () => {
        const { alternation: n, repetition: a, option: i, repetitionMandatory: s, repetitionMandatoryWithSeparator: o, repetitionWithSeparator: l } = JAe(r);
        ve(n, (u) => {
          const c = u.idx === 0 ? "" : u.idx;
          this.TRACE_INIT(`${ls(u)}${c}`, () => {
            const f = this.lookaheadStrategy.buildLookaheadForAlternation({
              prodOccurrence: u.idx,
              rule: r,
              maxLookahead: u.maxLookahead || this.maxLookahead,
              hasPredicates: u.hasPredicates,
              dynamicTokensEnabled: this.dynamicTokensEnabled
            }), h = Vw(this.fullRuleNameToShort[r.name], uU, u.idx);
            this.setLaFuncCache(h, f);
          });
        }), ve(a, (u) => {
          this.computeLookaheadFunc(r, u.idx, Y4, "Repetition", u.maxLookahead, ls(u));
        }), ve(i, (u) => {
          this.computeLookaheadFunc(r, u.idx, cU, "Option", u.maxLookahead, ls(u));
        }), ve(s, (u) => {
          this.computeLookaheadFunc(r, u.idx, X4, "RepetitionMandatory", u.maxLookahead, ls(u));
        }), ve(o, (u) => {
          this.computeLookaheadFunc(r, u.idx, Lv, "RepetitionMandatoryWithSeparator", u.maxLookahead, ls(u));
        }), ve(l, (u) => {
          this.computeLookaheadFunc(r, u.idx, K4, "RepetitionWithSeparator", u.maxLookahead, ls(u));
        });
      });
    });
  }
  computeLookaheadFunc(e, r, n, a, i, s) {
    this.TRACE_INIT(`${s}${r === 0 ? "" : r}`, () => {
      const o = this.lookaheadStrategy.buildLookaheadForOptional({
        prodOccurrence: r,
        rule: e,
        maxLookahead: i || this.maxLookahead,
        dynamicTokensEnabled: this.dynamicTokensEnabled,
        prodType: a
      }), l = Vw(this.fullRuleNameToShort[e.name], n, r);
      this.setLaFuncCache(l, o);
    });
  }
  // this actually returns a number, but it is always used as a string (object prop key)
  getKeyForAutomaticLookahead(e, r) {
    const n = this.getLastExplicitRuleShortName();
    return Vw(n, e, r);
  }
  getLaFuncFromCache(e) {
    return this.lookAheadFuncsCache.get(e);
  }
  /* istanbul ignore next */
  setLaFuncCache(e, r) {
    this.lookAheadFuncsCache.set(e, r);
  }
}
class QAe extends $f {
  constructor() {
    super(...arguments), this.dslMethods = {
      option: [],
      alternation: [],
      repetition: [],
      repetitionWithSeparator: [],
      repetitionMandatory: [],
      repetitionMandatoryWithSeparator: []
    };
  }
  reset() {
    this.dslMethods = {
      option: [],
      alternation: [],
      repetition: [],
      repetitionWithSeparator: [],
      repetitionMandatory: [],
      repetitionMandatoryWithSeparator: []
    };
  }
  visitOption(e) {
    this.dslMethods.option.push(e);
  }
  visitRepetitionWithSeparator(e) {
    this.dslMethods.repetitionWithSeparator.push(e);
  }
  visitRepetitionMandatory(e) {
    this.dslMethods.repetitionMandatory.push(e);
  }
  visitRepetitionMandatoryWithSeparator(e) {
    this.dslMethods.repetitionMandatoryWithSeparator.push(e);
  }
  visitRepetition(e) {
    this.dslMethods.repetition.push(e);
  }
  visitAlternation(e) {
    this.dslMethods.alternation.push(e);
  }
}
const Ig = new QAe();
function JAe(t) {
  Ig.reset(), t.accept(Ig);
  const e = Ig.dslMethods;
  return Ig.reset(), e;
}
function rN(t, e) {
  isNaN(t.startOffset) === !0 ? (t.startOffset = e.startOffset, t.endOffset = e.endOffset) : t.endOffset < e.endOffset && (t.endOffset = e.endOffset);
}
function nN(t, e) {
  isNaN(t.startOffset) === !0 ? (t.startOffset = e.startOffset, t.startColumn = e.startColumn, t.startLine = e.startLine, t.endOffset = e.endOffset, t.endColumn = e.endColumn, t.endLine = e.endLine) : t.endOffset < e.endOffset && (t.endOffset = e.endOffset, t.endColumn = e.endColumn, t.endLine = e.endLine);
}
function eke(t, e, r) {
  t.children[r] === void 0 ? t.children[r] = [e] : t.children[r].push(e);
}
function tke(t, e, r) {
  t.children[e] === void 0 ? t.children[e] = [r] : t.children[e].push(r);
}
const rke = "name";
function fU(t, e) {
  Object.defineProperty(t, rke, {
    enumerable: !1,
    configurable: !0,
    writable: !1,
    value: e
  });
}
function nke(t, e) {
  const r = vn(t), n = r.length;
  for (let a = 0; a < n; a++) {
    const i = r[a], s = t[i], o = s.length;
    for (let l = 0; l < o; l++) {
      const u = s[l];
      u.tokenTypeIdx === void 0 && this[u.name](u.children, e);
    }
  }
}
function ake(t, e) {
  const r = function() {
  };
  fU(r, t + "BaseSemantics");
  const n = {
    visit: function(a, i) {
      if (jt(a) && (a = a[0]), !dr(a))
        return this[a.name](a.children, i);
    },
    validateVisitor: function() {
      const a = ske(this, e);
      if (!mr(a)) {
        const i = Xe(a, (s) => s.msg);
        throw Error(`Errors Detected in CST Visitor <${this.constructor.name}>:
	${i.join(`

`).replace(/\n/g, `
	`)}`);
      }
    }
  };
  return r.prototype = n, r.prototype.constructor = r, r._RULE_NAMES = e, r;
}
function ike(t, e, r) {
  const n = function() {
  };
  fU(n, t + "BaseSemanticsWithDefaults");
  const a = Object.create(r.prototype);
  return ve(e, (i) => {
    a[i] = nke;
  }), n.prototype = a, n.prototype.constructor = n, n;
}
var Z4;
(function(t) {
  t[t.REDUNDANT_METHOD = 0] = "REDUNDANT_METHOD", t[t.MISSING_METHOD = 1] = "MISSING_METHOD";
})(Z4 || (Z4 = {}));
function ske(t, e) {
  return oke(t, e);
}
function oke(t, e) {
  const r = Zr(e, (a) => xi(t[a]) === !1), n = Xe(r, (a) => ({
    msg: `Missing visitor method: <${a}> on ${t.constructor.name} CST Visitor.`,
    type: Z4.MISSING_METHOD,
    methodName: a
  }));
  return ip(n);
}
class lke {
  initTreeBuilder(e) {
    if (this.CST_STACK = [], this.outputCst = e.outputCst, this.nodeLocationTracking = Et(e, "nodeLocationTracking") ? e.nodeLocationTracking : fo.nodeLocationTracking, !this.outputCst)
      this.cstInvocationStateUpdate = dn, this.cstFinallyStateUpdate = dn, this.cstPostTerminal = dn, this.cstPostNonTerminal = dn, this.cstPostRule = dn;
    else if (/full/i.test(this.nodeLocationTracking))
      this.recoveryEnabled ? (this.setNodeLocationFromToken = nN, this.setNodeLocationFromNode = nN, this.cstPostRule = dn, this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery) : (this.setNodeLocationFromToken = dn, this.setNodeLocationFromNode = dn, this.cstPostRule = this.cstPostRuleFull, this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular);
    else if (/onlyOffset/i.test(this.nodeLocationTracking))
      this.recoveryEnabled ? (this.setNodeLocationFromToken = rN, this.setNodeLocationFromNode = rN, this.cstPostRule = dn, this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery) : (this.setNodeLocationFromToken = dn, this.setNodeLocationFromNode = dn, this.cstPostRule = this.cstPostRuleOnlyOffset, this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular);
    else if (/none/i.test(this.nodeLocationTracking))
      this.setNodeLocationFromToken = dn, this.setNodeLocationFromNode = dn, this.cstPostRule = dn, this.setInitialNodeLocation = dn;
    else
      throw Error(`Invalid <nodeLocationTracking> config option: "${e.nodeLocationTracking}"`);
  }
  setInitialNodeLocationOnlyOffsetRecovery(e) {
    e.location = {
      startOffset: NaN,
      endOffset: NaN
    };
  }
  setInitialNodeLocationOnlyOffsetRegular(e) {
    e.location = {
      // without error recovery the starting Location of a new CstNode is guaranteed
      // To be the next Token's startOffset (for valid inputs).
      // For invalid inputs there won't be any CSTOutput so this potential
      // inaccuracy does not matter
      startOffset: this.LA(1).startOffset,
      endOffset: NaN
    };
  }
  setInitialNodeLocationFullRecovery(e) {
    e.location = {
      startOffset: NaN,
      startLine: NaN,
      startColumn: NaN,
      endOffset: NaN,
      endLine: NaN,
      endColumn: NaN
    };
  }
  /**
       *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work
  
       * @param cstNode
       */
  setInitialNodeLocationFullRegular(e) {
    const r = this.LA(1);
    e.location = {
      startOffset: r.startOffset,
      startLine: r.startLine,
      startColumn: r.startColumn,
      endOffset: NaN,
      endLine: NaN,
      endColumn: NaN
    };
  }
  cstInvocationStateUpdate(e) {
    const r = {
      name: e,
      children: /* @__PURE__ */ Object.create(null)
    };
    this.setInitialNodeLocation(r), this.CST_STACK.push(r);
  }
  cstFinallyStateUpdate() {
    this.CST_STACK.pop();
  }
  cstPostRuleFull(e) {
    const r = this.LA(0), n = e.location;
    n.startOffset <= r.startOffset ? (n.endOffset = r.endOffset, n.endLine = r.endLine, n.endColumn = r.endColumn) : (n.startOffset = NaN, n.startLine = NaN, n.startColumn = NaN);
  }
  cstPostRuleOnlyOffset(e) {
    const r = this.LA(0), n = e.location;
    n.startOffset <= r.startOffset ? n.endOffset = r.endOffset : n.startOffset = NaN;
  }
  cstPostTerminal(e, r) {
    const n = this.CST_STACK[this.CST_STACK.length - 1];
    eke(n, r, e), this.setNodeLocationFromToken(n.location, r);
  }
  cstPostNonTerminal(e, r) {
    const n = this.CST_STACK[this.CST_STACK.length - 1];
    tke(n, r, e), this.setNodeLocationFromNode(n.location, e.location);
  }
  getBaseCstVisitorConstructor() {
    if (dr(this.baseCstVisitorConstructor)) {
      const e = ake(this.className, vn(this.gastProductionsCache));
      return this.baseCstVisitorConstructor = e, e;
    }
    return this.baseCstVisitorConstructor;
  }
  getBaseCstVisitorConstructorWithDefaults() {
    if (dr(this.baseCstVisitorWithDefaultsConstructor)) {
      const e = ike(this.className, vn(this.gastProductionsCache), this.getBaseCstVisitorConstructor());
      return this.baseCstVisitorWithDefaultsConstructor = e, e;
    }
    return this.baseCstVisitorWithDefaultsConstructor;
  }
  getLastExplicitRuleShortName() {
    const e = this.RULE_STACK;
    return e[e.length - 1];
  }
  getPreviousExplicitRuleShortName() {
    const e = this.RULE_STACK;
    return e[e.length - 2];
  }
  getLastExplicitRuleOccurrenceIndex() {
    const e = this.RULE_OCCURRENCE_STACK;
    return e[e.length - 1];
  }
}
class uke {
  initLexerAdapter() {
    this.tokVector = [], this.tokVectorLength = 0, this.currIdx = -1;
  }
  set input(e) {
    if (this.selfAnalysisDone !== !0)
      throw Error("Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.");
    this.reset(), this.tokVector = e, this.tokVectorLength = e.length;
  }
  get input() {
    return this.tokVector;
  }
  // skips a token and returns the next token
  SKIP_TOKEN() {
    return this.currIdx <= this.tokVector.length - 2 ? (this.consumeToken(), this.LA(1)) : ay;
  }
  // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers
  // or lexers dependent on parser context.
  LA(e) {
    const r = this.currIdx + e;
    return r < 0 || this.tokVectorLength <= r ? ay : this.tokVector[r];
  }
  consumeToken() {
    this.currIdx++;
  }
  exportLexerState() {
    return this.currIdx;
  }
  importLexerState(e) {
    this.currIdx = e;
  }
  resetLexerState() {
    this.currIdx = -1;
  }
  moveToTerminatedState() {
    this.currIdx = this.tokVector.length - 1;
  }
  getLexerPosition() {
    return this.exportLexerState();
  }
}
class cke {
  ACTION(e) {
    return e.call(this);
  }
  consume(e, r, n) {
    return this.consumeInternal(r, e, n);
  }
  subrule(e, r, n) {
    return this.subruleInternal(r, e, n);
  }
  option(e, r) {
    return this.optionInternal(r, e);
  }
  or(e, r) {
    return this.orInternal(r, e);
  }
  many(e, r) {
    return this.manyInternal(e, r);
  }
  atLeastOne(e, r) {
    return this.atLeastOneInternal(e, r);
  }
  CONSUME(e, r) {
    return this.consumeInternal(e, 0, r);
  }
  CONSUME1(e, r) {
    return this.consumeInternal(e, 1, r);
  }
  CONSUME2(e, r) {
    return this.consumeInternal(e, 2, r);
  }
  CONSUME3(e, r) {
    return this.consumeInternal(e, 3, r);
  }
  CONSUME4(e, r) {
    return this.consumeInternal(e, 4, r);
  }
  CONSUME5(e, r) {
    return this.consumeInternal(e, 5, r);
  }
  CONSUME6(e, r) {
    return this.consumeInternal(e, 6, r);
  }
  CONSUME7(e, r) {
    return this.consumeInternal(e, 7, r);
  }
  CONSUME8(e, r) {
    return this.consumeInternal(e, 8, r);
  }
  CONSUME9(e, r) {
    return this.consumeInternal(e, 9, r);
  }
  SUBRULE(e, r) {
    return this.subruleInternal(e, 0, r);
  }
  SUBRULE1(e, r) {
    return this.subruleInternal(e, 1, r);
  }
  SUBRULE2(e, r) {
    return this.subruleInternal(e, 2, r);
  }
  SUBRULE3(e, r) {
    return this.subruleInternal(e, 3, r);
  }
  SUBRULE4(e, r) {
    return this.subruleInternal(e, 4, r);
  }
  SUBRULE5(e, r) {
    return this.subruleInternal(e, 5, r);
  }
  SUBRULE6(e, r) {
    return this.subruleInternal(e, 6, r);
  }
  SUBRULE7(e, r) {
    return this.subruleInternal(e, 7, r);
  }
  SUBRULE8(e, r) {
    return this.subruleInternal(e, 8, r);
  }
  SUBRULE9(e, r) {
    return this.subruleInternal(e, 9, r);
  }
  OPTION(e) {
    return this.optionInternal(e, 0);
  }
  OPTION1(e) {
    return this.optionInternal(e, 1);
  }
  OPTION2(e) {
    return this.optionInternal(e, 2);
  }
  OPTION3(e) {
    return this.optionInternal(e, 3);
  }
  OPTION4(e) {
    return this.optionInternal(e, 4);
  }
  OPTION5(e) {
    return this.optionInternal(e, 5);
  }
  OPTION6(e) {
    return this.optionInternal(e, 6);
  }
  OPTION7(e) {
    return this.optionInternal(e, 7);
  }
  OPTION8(e) {
    return this.optionInternal(e, 8);
  }
  OPTION9(e) {
    return this.optionInternal(e, 9);
  }
  OR(e) {
    return this.orInternal(e, 0);
  }
  OR1(e) {
    return this.orInternal(e, 1);
  }
  OR2(e) {
    return this.orInternal(e, 2);
  }
  OR3(e) {
    return this.orInternal(e, 3);
  }
  OR4(e) {
    return this.orInternal(e, 4);
  }
  OR5(e) {
    return this.orInternal(e, 5);
  }
  OR6(e) {
    return this.orInternal(e, 6);
  }
  OR7(e) {
    return this.orInternal(e, 7);
  }
  OR8(e) {
    return this.orInternal(e, 8);
  }
  OR9(e) {
    return this.orInternal(e, 9);
  }
  MANY(e) {
    this.manyInternal(0, e);
  }
  MANY1(e) {
    this.manyInternal(1, e);
  }
  MANY2(e) {
    this.manyInternal(2, e);
  }
  MANY3(e) {
    this.manyInternal(3, e);
  }
  MANY4(e) {
    this.manyInternal(4, e);
  }
  MANY5(e) {
    this.manyInternal(5, e);
  }
  MANY6(e) {
    this.manyInternal(6, e);
  }
  MANY7(e) {
    this.manyInternal(7, e);
  }
  MANY8(e) {
    this.manyInternal(8, e);
  }
  MANY9(e) {
    this.manyInternal(9, e);
  }
  MANY_SEP(e) {
    this.manySepFirstInternal(0, e);
  }
  MANY_SEP1(e) {
    this.manySepFirstInternal(1, e);
  }
  MANY_SEP2(e) {
    this.manySepFirstInternal(2, e);
  }
  MANY_SEP3(e) {
    this.manySepFirstInternal(3, e);
  }
  MANY_SEP4(e) {
    this.manySepFirstInternal(4, e);
  }
  MANY_SEP5(e) {
    this.manySepFirstInternal(5, e);
  }
  MANY_SEP6(e) {
    this.manySepFirstInternal(6, e);
  }
  MANY_SEP7(e) {
    this.manySepFirstInternal(7, e);
  }
  MANY_SEP8(e) {
    this.manySepFirstInternal(8, e);
  }
  MANY_SEP9(e) {
    this.manySepFirstInternal(9, e);
  }
  AT_LEAST_ONE(e) {
    this.atLeastOneInternal(0, e);
  }
  AT_LEAST_ONE1(e) {
    return this.atLeastOneInternal(1, e);
  }
  AT_LEAST_ONE2(e) {
    this.atLeastOneInternal(2, e);
  }
  AT_LEAST_ONE3(e) {
    this.atLeastOneInternal(3, e);
  }
  AT_LEAST_ONE4(e) {
    this.atLeastOneInternal(4, e);
  }
  AT_LEAST_ONE5(e) {
    this.atLeastOneInternal(5, e);
  }
  AT_LEAST_ONE6(e) {
    this.atLeastOneInternal(6, e);
  }
  AT_LEAST_ONE7(e) {
    this.atLeastOneInternal(7, e);
  }
  AT_LEAST_ONE8(e) {
    this.atLeastOneInternal(8, e);
  }
  AT_LEAST_ONE9(e) {
    this.atLeastOneInternal(9, e);
  }
  AT_LEAST_ONE_SEP(e) {
    this.atLeastOneSepFirstInternal(0, e);
  }
  AT_LEAST_ONE_SEP1(e) {
    this.atLeastOneSepFirstInternal(1, e);
  }
  AT_LEAST_ONE_SEP2(e) {
    this.atLeastOneSepFirstInternal(2, e);
  }
  AT_LEAST_ONE_SEP3(e) {
    this.atLeastOneSepFirstInternal(3, e);
  }
  AT_LEAST_ONE_SEP4(e) {
    this.atLeastOneSepFirstInternal(4, e);
  }
  AT_LEAST_ONE_SEP5(e) {
    this.atLeastOneSepFirstInternal(5, e);
  }
  AT_LEAST_ONE_SEP6(e) {
    this.atLeastOneSepFirstInternal(6, e);
  }
  AT_LEAST_ONE_SEP7(e) {
    this.atLeastOneSepFirstInternal(7, e);
  }
  AT_LEAST_ONE_SEP8(e) {
    this.atLeastOneSepFirstInternal(8, e);
  }
  AT_LEAST_ONE_SEP9(e) {
    this.atLeastOneSepFirstInternal(9, e);
  }
  RULE(e, r, n = iy) {
    if (ya(this.definedRulesNames, e)) {
      const s = {
        message: Hl.buildDuplicateRuleNameError({
          topLevelRule: e,
          grammarName: this.className
        }),
        type: ga.DUPLICATE_RULE_NAME,
        ruleName: e
      };
      this.definitionErrors.push(s);
    }
    this.definedRulesNames.push(e);
    const a = this.defineRule(e, r, n);
    return this[e] = a, a;
  }
  OVERRIDE_RULE(e, r, n = iy) {
    const a = OAe(e, this.definedRulesNames, this.className);
    this.definitionErrors = this.definitionErrors.concat(a);
    const i = this.defineRule(e, r, n);
    return this[e] = i, i;
  }
  BACKTRACK(e, r) {
    return function() {
      this.isBackTrackingStack.push(1);
      const n = this.saveRecogState();
      try {
        return e.apply(this, r), !0;
      } catch (a) {
        if (ry(a))
          return !1;
        throw a;
      } finally {
        this.reloadRecogState(n), this.isBackTrackingStack.pop();
      }
    };
  }
  // GAST export APIs
  getGAstProductions() {
    return this.gastProductionsCache;
  }
  getSerializedGastProductions() {
    return b3e(wr(this.gastProductionsCache));
  }
}
class fke {
  initRecognizerEngine(e, r) {
    if (this.className = this.constructor.name, this.shortRuleNameToFull = {}, this.fullRuleNameToShort = {}, this.ruleShortNameIdx = 256, this.tokenMatcher = ty, this.subruleIdx = 0, this.definedRulesNames = [], this.tokensMap = {}, this.isBackTrackingStack = [], this.RULE_STACK = [], this.RULE_OCCURRENCE_STACK = [], this.gastProductionsCache = {}, Et(r, "serializedGrammar"))
      throw Error(`The Parser's configuration can no longer contain a <serializedGrammar> property.
	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0
	For Further details.`);
    if (jt(e)) {
      if (mr(e))
        throw Error(`A Token Vocabulary cannot be empty.
	Note that the first argument for the parser constructor
	is no longer a Token vector (since v4.0).`);
      if (typeof e[0].startOffset == "number")
        throw Error(`The Parser constructor no longer accepts a token vector as the first argument.
	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0
	For Further details.`);
    }
    if (jt(e))
      this.tokensMap = fn(e, (i, s) => (i[s.name] = s, i), {});
    else if (Et(e, "modes") && Hi(kn(wr(e.modes)), uAe)) {
      const i = kn(wr(e.modes)), s = KC(i);
      this.tokensMap = fn(s, (o, l) => (o[l.name] = l, o), {});
    } else if (Ma(e))
      this.tokensMap = _n(e);
    else
      throw new Error("<tokensDictionary> argument must be An Array of Token constructors, A dictionary of Token constructors or an IMultiModeLexerDefinition");
    this.tokensMap.EOF = tl;
    const n = Et(e, "modes") ? kn(wr(e.modes)) : wr(e), a = Hi(n, (i) => mr(i.categoryMatches));
    this.tokenMatcher = a ? ty : Ep, Tp(wr(this.tokensMap));
  }
  defineRule(e, r, n) {
    if (this.selfAnalysisDone)
      throw Error(`Grammar rule <${e}> may not be defined after the 'performSelfAnalysis' method has been called'
Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.`);
    const a = Et(n, "resyncEnabled") ? n.resyncEnabled : iy.resyncEnabled, i = Et(n, "recoveryValueFunc") ? n.recoveryValueFunc : iy.recoveryValueFunc, s = this.ruleShortNameIdx << KAe + ml;
    this.ruleShortNameIdx++, this.shortRuleNameToFull[s] = e, this.fullRuleNameToShort[e] = s;
    let o;
    return this.outputCst === !0 ? o = function(...c) {
      try {
        this.ruleInvocationStateUpdate(s, e, this.subruleIdx), r.apply(this, c);
        const f = this.CST_STACK[this.CST_STACK.length - 1];
        return this.cstPostRule(f), f;
      } catch (f) {
        return this.invokeRuleCatch(f, a, i);
      } finally {
        this.ruleFinallyStateUpdate();
      }
    } : o = function(...c) {
      try {
        return this.ruleInvocationStateUpdate(s, e, this.subruleIdx), r.apply(this, c);
      } catch (f) {
        return this.invokeRuleCatch(f, a, i);
      } finally {
        this.ruleFinallyStateUpdate();
      }
    }, Object.assign(o, { ruleName: e, originalGrammarAction: r });
  }
  invokeRuleCatch(e, r, n) {
    const a = this.RULE_STACK.length === 1, i = r && !this.isBackTracking() && this.recoveryEnabled;
    if (ry(e)) {
      const s = e;
      if (i) {
        const o = this.findReSyncTokenType();
        if (this.isInCurrentRuleReSyncSet(o))
          if (s.resyncedTokens = this.reSyncTo(o), this.outputCst) {
            const l = this.CST_STACK[this.CST_STACK.length - 1];
            return l.recoveredNode = !0, l;
          } else
            return n(e);
        else {
          if (this.outputCst) {
            const l = this.CST_STACK[this.CST_STACK.length - 1];
            l.recoveredNode = !0, s.partialCstResult = l;
          }
          throw s;
        }
      } else {
        if (a)
          return this.moveToTerminatedState(), n(e);
        throw s;
      }
    } else
      throw e;
  }
  // Implementation of parsing DSL
  optionInternal(e, r) {
    const n = this.getKeyForAutomaticLookahead(cU, r);
    return this.optionInternalLogic(e, r, n);
  }
  optionInternalLogic(e, r, n) {
    let a = this.getLaFuncFromCache(n), i;
    if (typeof e != "function") {
      i = e.DEF;
      const s = e.GATE;
      if (s !== void 0) {
        const o = a;
        a = () => s.call(this) && o.call(this);
      }
    } else
      i = e;
    if (a.call(this) === !0)
      return i.call(this);
  }
  atLeastOneInternal(e, r) {
    const n = this.getKeyForAutomaticLookahead(X4, e);
    return this.atLeastOneInternalLogic(e, r, n);
  }
  atLeastOneInternalLogic(e, r, n) {
    let a = this.getLaFuncFromCache(n), i;
    if (typeof r != "function") {
      i = r.DEF;
      const s = r.GATE;
      if (s !== void 0) {
        const o = a;
        a = () => s.call(this) && o.call(this);
      }
    } else
      i = r;
    if (a.call(this) === !0) {
      let s = this.doSingleRepetition(i);
      for (; a.call(this) === !0 && s === !0; )
        s = this.doSingleRepetition(i);
    } else
      throw this.raiseEarlyExitException(e, Hr.REPETITION_MANDATORY, r.ERR_MSG);
    this.attemptInRepetitionRecovery(this.atLeastOneInternal, [e, r], a, X4, e, yAe);
  }
  atLeastOneSepFirstInternal(e, r) {
    const n = this.getKeyForAutomaticLookahead(Lv, e);
    this.atLeastOneSepFirstInternalLogic(e, r, n);
  }
  atLeastOneSepFirstInternalLogic(e, r, n) {
    const a = r.DEF, i = r.SEP;
    if (this.getLaFuncFromCache(n).call(this) === !0) {
      a.call(this);
      const o = () => this.tokenMatcher(this.LA(1), i);
      for (; this.tokenMatcher(this.LA(1), i) === !0; )
        this.CONSUME(i), a.call(this);
      this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
        e,
        i,
        o,
        a,
        JL
      ], o, Lv, e, JL);
    } else
      throw this.raiseEarlyExitException(e, Hr.REPETITION_MANDATORY_WITH_SEPARATOR, r.ERR_MSG);
  }
  manyInternal(e, r) {
    const n = this.getKeyForAutomaticLookahead(Y4, e);
    return this.manyInternalLogic(e, r, n);
  }
  manyInternalLogic(e, r, n) {
    let a = this.getLaFuncFromCache(n), i;
    if (typeof r != "function") {
      i = r.DEF;
      const o = r.GATE;
      if (o !== void 0) {
        const l = a;
        a = () => o.call(this) && l.call(this);
      }
    } else
      i = r;
    let s = !0;
    for (; a.call(this) === !0 && s === !0; )
      s = this.doSingleRepetition(i);
    this.attemptInRepetitionRecovery(
      this.manyInternal,
      [e, r],
      a,
      Y4,
      e,
      mAe,
      // The notStuck parameter is only relevant when "attemptInRepetitionRecovery"
      // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]
      // An infinite loop cannot occur as:
      // - Either the lookahead is guaranteed to consume something (Single Token Separator)
      // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).
      s
    );
  }
  manySepFirstInternal(e, r) {
    const n = this.getKeyForAutomaticLookahead(K4, e);
    this.manySepFirstInternalLogic(e, r, n);
  }
  manySepFirstInternalLogic(e, r, n) {
    const a = r.DEF, i = r.SEP;
    if (this.getLaFuncFromCache(n).call(this) === !0) {
      a.call(this);
      const o = () => this.tokenMatcher(this.LA(1), i);
      for (; this.tokenMatcher(this.LA(1), i) === !0; )
        this.CONSUME(i), a.call(this);
      this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
        e,
        i,
        o,
        a,
        QL
      ], o, K4, e, QL);
    }
  }
  repetitionSepSecondInternal(e, r, n, a, i) {
    for (; n(); )
      this.CONSUME(r), a.call(this);
    this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
      e,
      r,
      n,
      a,
      i
    ], n, Lv, e, i);
  }
  doSingleRepetition(e) {
    const r = this.getLexerPosition();
    return e.call(this), this.getLexerPosition() > r;
  }
  orInternal(e, r) {
    const n = this.getKeyForAutomaticLookahead(uU, r), a = jt(e) ? e : e.DEF, s = this.getLaFuncFromCache(n).call(this, a);
    if (s !== void 0)
      return a[s].ALT.call(this);
    this.raiseNoAltException(r, e.ERR_MSG);
  }
  ruleFinallyStateUpdate() {
    if (this.RULE_STACK.pop(), this.RULE_OCCURRENCE_STACK.pop(), this.cstFinallyStateUpdate(), this.RULE_STACK.length === 0 && this.isAtEndOfInput() === !1) {
      const e = this.LA(1), r = this.errorMessageProvider.buildNotAllInputParsedMessage({
        firstRedundant: e,
        ruleName: this.getCurrRuleFullName()
      });
      this.SAVE_ERROR(new qAe(r, e));
    }
  }
  subruleInternal(e, r, n) {
    let a;
    try {
      const i = n !== void 0 ? n.ARGS : void 0;
      return this.subruleIdx = r, a = e.apply(this, i), this.cstPostNonTerminal(a, n !== void 0 && n.LABEL !== void 0 ? n.LABEL : e.ruleName), a;
    } catch (i) {
      throw this.subruleInternalError(i, n, e.ruleName);
    }
  }
  subruleInternalError(e, r, n) {
    throw ry(e) && e.partialCstResult !== void 0 && (this.cstPostNonTerminal(e.partialCstResult, r !== void 0 && r.LABEL !== void 0 ? r.LABEL : n), delete e.partialCstResult), e;
  }
  consumeInternal(e, r, n) {
    let a;
    try {
      const i = this.LA(1);
      this.tokenMatcher(i, e) === !0 ? (this.consumeToken(), a = i) : this.consumeInternalError(e, i, n);
    } catch (i) {
      a = this.consumeInternalRecovery(e, r, i);
    }
    return this.cstPostTerminal(n !== void 0 && n.LABEL !== void 0 ? n.LABEL : e.name, a), a;
  }
  consumeInternalError(e, r, n) {
    let a;
    const i = this.LA(0);
    throw n !== void 0 && n.ERR_MSG ? a = n.ERR_MSG : a = this.errorMessageProvider.buildMismatchTokenMessage({
      expected: e,
      actual: r,
      previous: i,
      ruleName: this.getCurrRuleFullName()
    }), this.SAVE_ERROR(new oU(a, r, i));
  }
  consumeInternalRecovery(e, r, n) {
    if (this.recoveryEnabled && // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?
    n.name === "MismatchedTokenException" && !this.isBackTracking()) {
      const a = this.getFollowsForInRuleRecovery(e, r);
      try {
        return this.tryInRuleRecovery(e, a);
      } catch (i) {
        throw i.name === lU ? n : i;
      }
    } else
      throw n;
  }
  saveRecogState() {
    const e = this.errors, r = _n(this.RULE_STACK);
    return {
      errors: e,
      lexerState: this.exportLexerState(),
      RULE_STACK: r,
      CST_STACK: this.CST_STACK
    };
  }
  reloadRecogState(e) {
    this.errors = e.errors, this.importLexerState(e.lexerState), this.RULE_STACK = e.RULE_STACK;
  }
  ruleInvocationStateUpdate(e, r, n) {
    this.RULE_OCCURRENCE_STACK.push(n), this.RULE_STACK.push(e), this.cstInvocationStateUpdate(r);
  }
  isBackTracking() {
    return this.isBackTrackingStack.length !== 0;
  }
  getCurrRuleFullName() {
    const e = this.getLastExplicitRuleShortName();
    return this.shortRuleNameToFull[e];
  }
  shortRuleNameToFullName(e) {
    return this.shortRuleNameToFull[e];
  }
  isAtEndOfInput() {
    return this.tokenMatcher(this.LA(1), tl);
  }
  reset() {
    this.resetLexerState(), this.subruleIdx = 0, this.isBackTrackingStack = [], this.errors = [], this.RULE_STACK = [], this.CST_STACK = [], this.RULE_OCCURRENCE_STACK = [];
  }
}
class hke {
  initErrorHandler(e) {
    this._errors = [], this.errorMessageProvider = Et(e, "errorMessageProvider") ? e.errorMessageProvider : fo.errorMessageProvider;
  }
  SAVE_ERROR(e) {
    if (ry(e))
      return e.context = {
        ruleStack: this.getHumanReadableRuleStack(),
        ruleOccurrenceStack: _n(this.RULE_OCCURRENCE_STACK)
      }, this._errors.push(e), e;
    throw Error("Trying to save an Error which is not a RecognitionException");
  }
  get errors() {
    return _n(this._errors);
  }
  set errors(e) {
    this._errors = e;
  }
  // TODO: consider caching the error message computed information
  raiseEarlyExitException(e, r, n) {
    const a = this.getCurrRuleFullName(), i = this.getGAstProductions()[a], o = wb(e, i, r, this.maxLookahead)[0], l = [];
    for (let c = 1; c <= this.maxLookahead; c++)
      l.push(this.LA(c));
    const u = this.errorMessageProvider.buildEarlyExitMessage({
      expectedIterationPaths: o,
      actual: l,
      previous: this.LA(0),
      customUserDescription: n,
      ruleName: a
    });
    throw this.SAVE_ERROR(new WAe(u, this.LA(1), this.LA(0)));
  }
  // TODO: consider caching the error message computed information
  raiseNoAltException(e, r) {
    const n = this.getCurrRuleFullName(), a = this.getGAstProductions()[n], i = xb(e, a, this.maxLookahead), s = [];
    for (let u = 1; u <= this.maxLookahead; u++)
      s.push(this.LA(u));
    const o = this.LA(0), l = this.errorMessageProvider.buildNoViableAltMessage({
      expectedPathsPerAlt: i,
      actual: s,
      previous: o,
      customUserDescription: r,
      ruleName: this.getCurrRuleFullName()
    });
    throw this.SAVE_ERROR(new VAe(l, this.LA(1), o));
  }
}
class dke {
  initContentAssist() {
  }
  computeContentAssist(e, r) {
    const n = this.gastProductionsCache[e];
    if (dr(n))
      throw Error(`Rule ->${e}<- does not exist in this grammar.`);
    return KG([n], r, this.tokenMatcher, this.maxLookahead);
  }
  // TODO: should this be a member method or a utility? it does not have any state or usage of 'this'...
  // TODO: should this be more explicitly part of the public API?
  getNextPossibleTokenTypes(e) {
    const r = Yi(e.ruleStack), a = this.getGAstProductions()[r];
    return new vAe(a, e).startWalking();
  }
}
const Tb = {
  description: "This Object indicates the Parser is during Recording Phase"
};
Object.freeze(Tb);
const aN = !0, iN = Math.pow(2, ml) - 1, hU = YG({ name: "RECORDING_PHASE_TOKEN", pattern: ka.NA });
Tp([hU]);
const dU = D3(
  hU,
  `This IToken indicates the Parser is in Recording Phase
	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details`,
  // Using "-1" instead of NaN (as in EOF) because an actual number is less likely to
  // cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.
  -1,
  -1,
  -1,
  -1,
  -1,
  -1
);
Object.freeze(dU);
const pke = {
  name: `This CSTNode indicates the Parser is in Recording Phase
	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details`,
  children: {}
};
class gke {
  initGastRecorder(e) {
    this.recordingProdStack = [], this.RECORDING_PHASE = !1;
  }
  enableRecording() {
    this.RECORDING_PHASE = !0, this.TRACE_INIT("Enable Recording", () => {
      for (let e = 0; e < 10; e++) {
        const r = e > 0 ? e : "";
        this[`CONSUME${r}`] = function(n, a) {
          return this.consumeInternalRecord(n, e, a);
        }, this[`SUBRULE${r}`] = function(n, a) {
          return this.subruleInternalRecord(n, e, a);
        }, this[`OPTION${r}`] = function(n) {
          return this.optionInternalRecord(n, e);
        }, this[`OR${r}`] = function(n) {
          return this.orInternalRecord(n, e);
        }, this[`MANY${r}`] = function(n) {
          this.manyInternalRecord(e, n);
        }, this[`MANY_SEP${r}`] = function(n) {
          this.manySepFirstInternalRecord(e, n);
        }, this[`AT_LEAST_ONE${r}`] = function(n) {
          this.atLeastOneInternalRecord(e, n);
        }, this[`AT_LEAST_ONE_SEP${r}`] = function(n) {
          this.atLeastOneSepFirstInternalRecord(e, n);
        };
      }
      this.consume = function(e, r, n) {
        return this.consumeInternalRecord(r, e, n);
      }, this.subrule = function(e, r, n) {
        return this.subruleInternalRecord(r, e, n);
      }, this.option = function(e, r) {
        return this.optionInternalRecord(r, e);
      }, this.or = function(e, r) {
        return this.orInternalRecord(r, e);
      }, this.many = function(e, r) {
        this.manyInternalRecord(e, r);
      }, this.atLeastOne = function(e, r) {
        this.atLeastOneInternalRecord(e, r);
      }, this.ACTION = this.ACTION_RECORD, this.BACKTRACK = this.BACKTRACK_RECORD, this.LA = this.LA_RECORD;
    });
  }
  disableRecording() {
    this.RECORDING_PHASE = !1, this.TRACE_INIT("Deleting Recording methods", () => {
      const e = this;
      for (let r = 0; r < 10; r++) {
        const n = r > 0 ? r : "";
        delete e[`CONSUME${n}`], delete e[`SUBRULE${n}`], delete e[`OPTION${n}`], delete e[`OR${n}`], delete e[`MANY${n}`], delete e[`MANY_SEP${n}`], delete e[`AT_LEAST_ONE${n}`], delete e[`AT_LEAST_ONE_SEP${n}`];
      }
      delete e.consume, delete e.subrule, delete e.option, delete e.or, delete e.many, delete e.atLeastOne, delete e.ACTION, delete e.BACKTRACK, delete e.LA;
    });
  }
  //   Parser methods are called inside an ACTION?
  //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?
  // @ts-expect-error -- noop place holder
  ACTION_RECORD(e) {
  }
  // Executing backtracking logic will break our recording logic assumptions
  BACKTRACK_RECORD(e, r) {
    return () => !0;
  }
  // LA is part of the official API and may be used for custom lookahead logic
  // by end users who may forget to wrap it in ACTION or inside a GATE
  LA_RECORD(e) {
    return ay;
  }
  topLevelRuleRecord(e, r) {
    try {
      const n = new Df({ definition: [], name: e });
      return n.name = e, this.recordingProdStack.push(n), r.call(this), this.recordingProdStack.pop(), n;
    } catch (n) {
      if (n.KNOWN_RECORDER_ERROR !== !0)
        try {
          n.message = n.message + `
	 This error was thrown during the "grammar recording phase" For more info see:
	https://chevrotain.io/docs/guide/internals.html#grammar-recording`;
        } catch {
          throw n;
        }
      throw n;
    }
  }
  // Implementation of parsing DSL
  optionInternalRecord(e, r) {
    return yh.call(this, Gn, e, r);
  }
  atLeastOneInternalRecord(e, r) {
    yh.call(this, si, r, e);
  }
  atLeastOneSepFirstInternalRecord(e, r) {
    yh.call(this, oi, r, e, aN);
  }
  manyInternalRecord(e, r) {
    yh.call(this, Xr, r, e);
  }
  manySepFirstInternalRecord(e, r) {
    yh.call(this, Pa, r, e, aN);
  }
  orInternalRecord(e, r) {
    return vke.call(this, e, r);
  }
  subruleInternalRecord(e, r, n) {
    if (ny(r), !e || Et(e, "ruleName") === !1) {
      const o = new Error(`<SUBRULE${sN(r)}> argument is invalid expecting a Parser method reference but got: <${JSON.stringify(e)}>
 inside top level rule: <${this.recordingProdStack[0].name}>`);
      throw o.KNOWN_RECORDER_ERROR = !0, o;
    }
    const a = ms(this.recordingProdStack), i = e.ruleName, s = new pa({
      idx: r,
      nonTerminalName: i,
      label: n == null ? void 0 : n.LABEL,
      // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created
      referencedRule: void 0
    });
    return a.definition.push(s), this.outputCst ? pke : Tb;
  }
  consumeInternalRecord(e, r, n) {
    if (ny(r), !WG(e)) {
      const s = new Error(`<CONSUME${sN(r)}> argument is invalid expecting a TokenType reference but got: <${JSON.stringify(e)}>
 inside top level rule: <${this.recordingProdStack[0].name}>`);
      throw s.KNOWN_RECORDER_ERROR = !0, s;
    }
    const a = ms(this.recordingProdStack), i = new Pr({
      idx: r,
      terminalType: e,
      label: n == null ? void 0 : n.LABEL
    });
    return a.definition.push(i), dU;
  }
}
function yh(t, e, r, n = !1) {
  ny(r);
  const a = ms(this.recordingProdStack), i = xi(e) ? e : e.DEF, s = new t({ definition: [], idx: r });
  return n && (s.separator = e.SEP), Et(e, "MAX_LOOKAHEAD") && (s.maxLookahead = e.MAX_LOOKAHEAD), this.recordingProdStack.push(s), i.call(this), a.definition.push(s), this.recordingProdStack.pop(), Tb;
}
function vke(t, e) {
  ny(e);
  const r = ms(this.recordingProdStack), n = jt(t) === !1, a = n === !1 ? t : t.DEF, i = new Da({
    definition: [],
    idx: e,
    ignoreAmbiguities: n && t.IGNORE_AMBIGUITIES === !0
  });
  Et(t, "MAX_LOOKAHEAD") && (i.maxLookahead = t.MAX_LOOKAHEAD);
  const s = lB(a, (o) => xi(o.GATE));
  return i.hasPredicates = s, r.definition.push(i), ve(a, (o) => {
    const l = new La({ definition: [] });
    i.definition.push(l), Et(o, "IGNORE_AMBIGUITIES") ? l.ignoreAmbiguities = o.IGNORE_AMBIGUITIES : Et(o, "GATE") && (l.ignoreAmbiguities = !0), this.recordingProdStack.push(l), o.ALT.call(this), this.recordingProdStack.pop();
  }), Tb;
}
function sN(t) {
  return t === 0 ? "" : `${t}`;
}
function ny(t) {
  if (t < 0 || t > iN) {
    const e = new Error(
      // The stack trace will contain all the needed details
      `Invalid DSL Method idx value: <${t}>
	Idx value must be a none negative value smaller than ${iN + 1}`
    );
    throw e.KNOWN_RECORDER_ERROR = !0, e;
  }
}
class mke {
  initPerformanceTracer(e) {
    if (Et(e, "traceInitPerf")) {
      const r = e.traceInitPerf, n = typeof r == "number";
      this.traceInitMaxIdent = n ? r : 1 / 0, this.traceInitPerf = n ? r > 0 : r;
    } else
      this.traceInitMaxIdent = 0, this.traceInitPerf = fo.traceInitPerf;
    this.traceInitIndent = -1;
  }
  TRACE_INIT(e, r) {
    if (this.traceInitPerf === !0) {
      this.traceInitIndent++;
      const n = new Array(this.traceInitIndent + 1).join("	");
      this.traceInitIndent < this.traceInitMaxIdent && console.log(`${n}--> <${e}>`);
      const { time: a, value: i } = DG(r), s = a > 10 ? console.warn : console.log;
      return this.traceInitIndent < this.traceInitMaxIdent && s(`${n}<-- <${e}> time: ${a}ms`), this.traceInitIndent--, i;
    } else
      return r();
  }
}
function yke(t, e) {
  e.forEach((r) => {
    const n = r.prototype;
    Object.getOwnPropertyNames(n).forEach((a) => {
      if (a === "constructor")
        return;
      const i = Object.getOwnPropertyDescriptor(n, a);
      i && (i.get || i.set) ? Object.defineProperty(t.prototype, a, i) : t.prototype[a] = r.prototype[a];
    });
  });
}
const ay = D3(tl, "", NaN, NaN, NaN, NaN, NaN, NaN);
Object.freeze(ay);
const fo = Object.freeze({
  recoveryEnabled: !1,
  maxLookahead: 3,
  dynamicTokensEnabled: !1,
  outputCst: !0,
  errorMessageProvider: hc,
  nodeLocationTracking: "none",
  traceInitPerf: !1,
  skipValidations: !1
}), iy = Object.freeze({
  recoveryValueFunc: () => {
  },
  resyncEnabled: !0
});
var ga;
(function(t) {
  t[t.INVALID_RULE_NAME = 0] = "INVALID_RULE_NAME", t[t.DUPLICATE_RULE_NAME = 1] = "DUPLICATE_RULE_NAME", t[t.INVALID_RULE_OVERRIDE = 2] = "INVALID_RULE_OVERRIDE", t[t.DUPLICATE_PRODUCTIONS = 3] = "DUPLICATE_PRODUCTIONS", t[t.UNRESOLVED_SUBRULE_REF = 4] = "UNRESOLVED_SUBRULE_REF", t[t.LEFT_RECURSION = 5] = "LEFT_RECURSION", t[t.NONE_LAST_EMPTY_ALT = 6] = "NONE_LAST_EMPTY_ALT", t[t.AMBIGUOUS_ALTS = 7] = "AMBIGUOUS_ALTS", t[t.CONFLICT_TOKENS_RULES_NAMESPACE = 8] = "CONFLICT_TOKENS_RULES_NAMESPACE", t[t.INVALID_TOKEN_NAME = 9] = "INVALID_TOKEN_NAME", t[t.NO_NON_EMPTY_LOOKAHEAD = 10] = "NO_NON_EMPTY_LOOKAHEAD", t[t.AMBIGUOUS_PREFIX_ALTS = 11] = "AMBIGUOUS_PREFIX_ALTS", t[t.TOO_MANY_ALTS = 12] = "TOO_MANY_ALTS", t[t.CUSTOM_LOOKAHEAD_VALIDATION = 13] = "CUSTOM_LOOKAHEAD_VALIDATION";
})(ga || (ga = {}));
function oN(t = void 0) {
  return function() {
    return t;
  };
}
class Sp {
  /**
   *  @deprecated use the **instance** method with the same name instead
   */
  static performSelfAnalysis(e) {
    throw Error("The **static** `performSelfAnalysis` method has been deprecated.	\nUse the **instance** method with the same name instead.");
  }
  performSelfAnalysis() {
    this.TRACE_INIT("performSelfAnalysis", () => {
      let e;
      this.selfAnalysisDone = !0;
      const r = this.className;
      this.TRACE_INIT("toFastProps", () => {
        $G(this);
      }), this.TRACE_INIT("Grammar Recording", () => {
        try {
          this.enableRecording(), ve(this.definedRulesNames, (a) => {
            const s = this[a].originalGrammarAction;
            let o;
            this.TRACE_INIT(`${a} Rule`, () => {
              o = this.topLevelRuleRecord(a, s);
            }), this.gastProductionsCache[a] = o;
          });
        } finally {
          this.disableRecording();
        }
      });
      let n = [];
      if (this.TRACE_INIT("Grammar Resolving", () => {
        n = UAe({
          rules: wr(this.gastProductionsCache)
        }), this.definitionErrors = this.definitionErrors.concat(n);
      }), this.TRACE_INIT("Grammar Validations", () => {
        if (mr(n) && this.skipValidations === !1) {
          const a = HAe({
            rules: wr(this.gastProductionsCache),
            tokenTypes: wr(this.tokensMap),
            errMsgProvider: Hl,
            grammarName: r
          }), i = kAe({
            lookaheadStrategy: this.lookaheadStrategy,
            rules: wr(this.gastProductionsCache),
            tokenTypes: wr(this.tokensMap),
            grammarName: r
          });
          this.definitionErrors = this.definitionErrors.concat(a, i);
        }
      }), mr(this.definitionErrors) && (this.recoveryEnabled && this.TRACE_INIT("computeAllProdsFollows", () => {
        const a = A3e(wr(this.gastProductionsCache));
        this.resyncFollows = a;
      }), this.TRACE_INIT("ComputeLookaheadFunctions", () => {
        var a, i;
        (i = (a = this.lookaheadStrategy).initialize) === null || i === void 0 || i.call(a, {
          rules: wr(this.gastProductionsCache)
        }), this.preComputeLookaheadFunctions(wr(this.gastProductionsCache));
      })), !Sp.DEFER_DEFINITION_ERRORS_HANDLING && !mr(this.definitionErrors))
        throw e = Xe(this.definitionErrors, (a) => a.message), new Error(`Parser Definition Errors detected:
 ${e.join(`
-------------------------------
`)}`);
    });
  }
  constructor(e, r) {
    this.definitionErrors = [], this.selfAnalysisDone = !1;
    const n = this;
    if (n.initErrorHandler(r), n.initLexerAdapter(), n.initLooksAhead(r), n.initRecognizerEngine(e, r), n.initRecoverable(r), n.initTreeBuilder(r), n.initContentAssist(), n.initGastRecorder(r), n.initPerformanceTracer(r), Et(r, "ignoredIssues"))
      throw new Error(`The <ignoredIssues> IParserConfig property has been deprecated.
	Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.
	See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES
	For further details.`);
    this.skipValidations = Et(r, "skipValidations") ? r.skipValidations : fo.skipValidations;
  }
}
Sp.DEFER_DEFINITION_ERRORS_HANDLING = !1;
yke(Sp, [
  YAe,
  ZAe,
  lke,
  uke,
  fke,
  cke,
  hke,
  dke,
  gke,
  mke
]);
class bke extends Sp {
  constructor(e, r = fo) {
    const n = _n(r);
    n.outputCst = !1, super(e, n);
  }
}
function pf(t, e, r) {
  return `${t.name}_${e}_${r}`;
}
const rl = 1, xke = 2, pU = 4, gU = 5, Cp = 7, wke = 8, Eke = 9, Tke = 10, Ske = 11, vU = 12;
class z3 {
  constructor(e) {
    this.target = e;
  }
  isEpsilon() {
    return !1;
  }
}
class G3 extends z3 {
  constructor(e, r) {
    super(e), this.tokenType = r;
  }
}
class mU extends z3 {
  constructor(e) {
    super(e);
  }
  isEpsilon() {
    return !0;
  }
}
class U3 extends z3 {
  constructor(e, r, n) {
    super(e), this.rule = r, this.followState = n;
  }
  isEpsilon() {
    return !0;
  }
}
function Cke(t) {
  const e = {
    decisionMap: {},
    decisionStates: [],
    ruleToStartState: /* @__PURE__ */ new Map(),
    ruleToStopState: /* @__PURE__ */ new Map(),
    states: []
  };
  Ake(e, t);
  const r = t.length;
  for (let n = 0; n < r; n++) {
    const a = t[n], i = Ou(e, a, a);
    i !== void 0 && $ke(e, a, i);
  }
  return e;
}
function Ake(t, e) {
  const r = e.length;
  for (let n = 0; n < r; n++) {
    const a = e[n], i = Mn(t, a, void 0, {
      type: xke
    }), s = Mn(t, a, void 0, {
      type: Cp
    });
    i.stop = s, t.ruleToStartState.set(a, i), t.ruleToStopState.set(a, s);
  }
}
function yU(t, e, r) {
  return r instanceof Pr ? H3(t, e, r.terminalType, r) : r instanceof pa ? Dke(t, e, r) : r instanceof Da ? Lke(t, e, r) : r instanceof Gn ? Nke(t, e, r) : r instanceof Xr ? kke(t, e, r) : r instanceof Pa ? Rke(t, e, r) : r instanceof si ? Mke(t, e, r) : r instanceof oi ? _ke(t, e, r) : Ou(t, e, r);
}
function kke(t, e, r) {
  const n = Mn(t, e, r, {
    type: gU
  });
  yl(t, n);
  const a = Ff(t, e, n, r, Ou(t, e, r));
  return xU(t, e, r, a);
}
function Rke(t, e, r) {
  const n = Mn(t, e, r, {
    type: gU
  });
  yl(t, n);
  const a = Ff(t, e, n, r, Ou(t, e, r)), i = H3(t, e, r.separator, r);
  return xU(t, e, r, a, i);
}
function Mke(t, e, r) {
  const n = Mn(t, e, r, {
    type: pU
  });
  yl(t, n);
  const a = Ff(t, e, n, r, Ou(t, e, r));
  return bU(t, e, r, a);
}
function _ke(t, e, r) {
  const n = Mn(t, e, r, {
    type: pU
  });
  yl(t, n);
  const a = Ff(t, e, n, r, Ou(t, e, r)), i = H3(t, e, r.separator, r);
  return bU(t, e, r, a, i);
}
function Lke(t, e, r) {
  const n = Mn(t, e, r, {
    type: rl
  });
  yl(t, n);
  const a = Xe(r.definition, (s) => yU(t, e, s));
  return Ff(t, e, n, r, ...a);
}
function Nke(t, e, r) {
  const n = Mn(t, e, r, {
    type: rl
  });
  yl(t, n);
  const a = Ff(t, e, n, r, Ou(t, e, r));
  return Oke(t, e, r, a);
}
function Ou(t, e, r) {
  const n = Zr(Xe(r.definition, (a) => yU(t, e, a)), (a) => a !== void 0);
  return n.length === 1 ? n[0] : n.length === 0 ? void 0 : Pke(t, n);
}
function bU(t, e, r, n, a) {
  const i = n.left, s = n.right, o = Mn(t, e, r, {
    type: Ske
  });
  yl(t, o);
  const l = Mn(t, e, r, {
    type: vU
  });
  return i.loopback = o, l.loopback = o, t.decisionMap[pf(e, a ? "RepetitionMandatoryWithSeparator" : "RepetitionMandatory", r.idx)] = o, un(s, o), a === void 0 ? (un(o, i), un(o, l)) : (un(o, l), un(o, a.left), un(a.right, i)), {
    left: i,
    right: l
  };
}
function xU(t, e, r, n, a) {
  const i = n.left, s = n.right, o = Mn(t, e, r, {
    type: Tke
  });
  yl(t, o);
  const l = Mn(t, e, r, {
    type: vU
  }), u = Mn(t, e, r, {
    type: Eke
  });
  return o.loopback = u, l.loopback = u, un(o, i), un(o, l), un(s, u), a !== void 0 ? (un(u, l), un(u, a.left), un(a.right, i)) : un(u, o), t.decisionMap[pf(e, a ? "RepetitionWithSeparator" : "Repetition", r.idx)] = o, {
    left: o,
    right: l
  };
}
function Oke(t, e, r, n) {
  const a = n.left, i = n.right;
  return un(a, i), t.decisionMap[pf(e, "Option", r.idx)] = a, n;
}
function yl(t, e) {
  return t.decisionStates.push(e), e.decision = t.decisionStates.length - 1, e.decision;
}
function Ff(t, e, r, n, ...a) {
  const i = Mn(t, e, n, {
    type: wke,
    start: r
  });
  r.end = i;
  for (const o of a)
    o !== void 0 ? (un(r, o.left), un(o.right, i)) : un(r, i);
  const s = {
    left: r,
    right: i
  };
  return t.decisionMap[pf(e, Ike(n), n.idx)] = r, s;
}
function Ike(t) {
  if (t instanceof Da)
    return "Alternation";
  if (t instanceof Gn)
    return "Option";
  if (t instanceof Xr)
    return "Repetition";
  if (t instanceof Pa)
    return "RepetitionWithSeparator";
  if (t instanceof si)
    return "RepetitionMandatory";
  if (t instanceof oi)
    return "RepetitionMandatoryWithSeparator";
  throw new Error("Invalid production type encountered");
}
function Pke(t, e) {
  const r = e.length;
  for (let i = 0; i < r - 1; i++) {
    const s = e[i];
    let o;
    s.left.transitions.length === 1 && (o = s.left.transitions[0]);
    const l = o instanceof U3, u = o, c = e[i + 1].left;
    s.left.type === rl && s.right.type === rl && o !== void 0 && (l && u.followState === s.right || o.target === s.right) ? (l ? u.followState = c : o.target = c, Fke(t, s.right)) : un(s.right, c);
  }
  const n = e[0], a = e[r - 1];
  return {
    left: n.left,
    right: a.right
  };
}
function H3(t, e, r, n) {
  const a = Mn(t, e, n, {
    type: rl
  }), i = Mn(t, e, n, {
    type: rl
  });
  return V3(a, new G3(i, r)), {
    left: a,
    right: i
  };
}
function Dke(t, e, r) {
  const n = r.referencedRule, a = t.ruleToStartState.get(n), i = Mn(t, e, r, {
    type: rl
  }), s = Mn(t, e, r, {
    type: rl
  }), o = new U3(a, n, s);
  return V3(i, o), {
    left: i,
    right: s
  };
}
function $ke(t, e, r) {
  const n = t.ruleToStartState.get(e);
  un(n, r.left);
  const a = t.ruleToStopState.get(e);
  return un(r.right, a), {
    left: n,
    right: a
  };
}
function un(t, e) {
  const r = new mU(e);
  V3(t, r);
}
function Mn(t, e, r, n) {
  const a = Object.assign({
    atn: t,
    production: r,
    epsilonOnlyTransitions: !1,
    rule: e,
    transitions: [],
    nextTokenWithinRule: [],
    stateNumber: t.states.length
  }, n);
  return t.states.push(a), a;
}
function V3(t, e) {
  t.transitions.length === 0 && (t.epsilonOnlyTransitions = e.isEpsilon()), t.transitions.push(e);
}
function Fke(t, e) {
  t.states.splice(t.states.indexOf(e), 1);
}
const sy = {};
class Q4 {
  constructor() {
    this.map = {}, this.configs = [];
  }
  get size() {
    return this.configs.length;
  }
  finalize() {
    this.map = {};
  }
  add(e) {
    const r = wU(e);
    r in this.map || (this.map[r] = this.configs.length, this.configs.push(e));
  }
  get elements() {
    return this.configs;
  }
  get alts() {
    return Xe(this.configs, (e) => e.alt);
  }
  get key() {
    let e = "";
    for (const r in this.map)
      e += r + ":";
    return e;
  }
}
function wU(t, e = !0) {
  return `${e ? `a${t.alt}` : ""}s${t.state.stateNumber}:${t.stack.map((r) => r.stateNumber.toString()).join("_")}`;
}
function Bke(t, e) {
  const r = {};
  return (n) => {
    const a = n.toString();
    let i = r[a];
    return i !== void 0 || (i = {
      atnStartState: t,
      decision: e,
      states: {}
    }, r[a] = i), i;
  };
}
class EU {
  constructor() {
    this.predicates = [];
  }
  is(e) {
    return e >= this.predicates.length || this.predicates[e];
  }
  set(e, r) {
    this.predicates[e] = r;
  }
  toString() {
    let e = "";
    const r = this.predicates.length;
    for (let n = 0; n < r; n++)
      e += this.predicates[n] === !0 ? "1" : "0";
    return e;
  }
}
const lN = new EU();
class zke extends B3 {
  constructor(e) {
    var r;
    super(), this.logging = (r = e == null ? void 0 : e.logging) !== null && r !== void 0 ? r : (n) => console.log(n);
  }
  initialize(e) {
    this.atn = Cke(e.rules), this.dfas = Gke(this.atn);
  }
  validateAmbiguousAlternationAlternatives() {
    return [];
  }
  validateEmptyOrAlternatives() {
    return [];
  }
  buildLookaheadForAlternation(e) {
    const { prodOccurrence: r, rule: n, hasPredicates: a, dynamicTokensEnabled: i } = e, s = this.dfas, o = this.logging, l = pf(n, "Alternation", r), c = this.atn.decisionMap[l].decision, f = Xe(eN({
      maxLookahead: 1,
      occurrence: r,
      prodType: "Alternation",
      rule: n
    }), (h) => Xe(h, (d) => d[0]));
    if (uN(f, !1) && !i) {
      const h = fn(f, (d, p, g) => (ve(p, (v) => {
        v && (d[v.tokenTypeIdx] = g, ve(v.categoryMatches, (m) => {
          d[m] = g;
        }));
      }), d), {});
      return a ? function(d) {
        var p;
        const g = this.LA(1), v = h[g.tokenTypeIdx];
        if (d !== void 0 && v !== void 0) {
          const m = (p = d[v]) === null || p === void 0 ? void 0 : p.GATE;
          if (m !== void 0 && m.call(this) === !1)
            return;
        }
        return v;
      } : function() {
        const d = this.LA(1);
        return h[d.tokenTypeIdx];
      };
    } else return a ? function(h) {
      const d = new EU(), p = h === void 0 ? 0 : h.length;
      for (let v = 0; v < p; v++) {
        const m = h == null ? void 0 : h[v].GATE;
        d.set(v, m === void 0 || m.call(this));
      }
      const g = qw.call(this, s, c, d, o);
      return typeof g == "number" ? g : void 0;
    } : function() {
      const h = qw.call(this, s, c, lN, o);
      return typeof h == "number" ? h : void 0;
    };
  }
  buildLookaheadForOptional(e) {
    const { prodOccurrence: r, rule: n, prodType: a, dynamicTokensEnabled: i } = e, s = this.dfas, o = this.logging, l = pf(n, a, r), c = this.atn.decisionMap[l].decision, f = Xe(eN({
      maxLookahead: 1,
      occurrence: r,
      prodType: a,
      rule: n
    }), (h) => Xe(h, (d) => d[0]));
    if (uN(f) && f[0][0] && !i) {
      const h = f[0], d = kn(h);
      if (d.length === 1 && mr(d[0].categoryMatches)) {
        const g = d[0].tokenTypeIdx;
        return function() {
          return this.LA(1).tokenTypeIdx === g;
        };
      } else {
        const p = fn(d, (g, v) => (v !== void 0 && (g[v.tokenTypeIdx] = !0, ve(v.categoryMatches, (m) => {
          g[m] = !0;
        })), g), {});
        return function() {
          const g = this.LA(1);
          return p[g.tokenTypeIdx] === !0;
        };
      }
    }
    return function() {
      const h = qw.call(this, s, c, lN, o);
      return typeof h == "object" ? !1 : h === 0;
    };
  }
}
function uN(t, e = !0) {
  const r = /* @__PURE__ */ new Set();
  for (const n of t) {
    const a = /* @__PURE__ */ new Set();
    for (const i of n) {
      if (i === void 0) {
        if (e)
          break;
        return !1;
      }
      const s = [i.tokenTypeIdx].concat(i.categoryMatches);
      for (const o of s)
        if (r.has(o)) {
          if (!a.has(o))
            return !1;
        } else
          r.add(o), a.add(o);
    }
  }
  return !0;
}
function Gke(t) {
  const e = t.decisionStates.length, r = Array(e);
  for (let n = 0; n < e; n++)
    r[n] = Bke(t.decisionStates[n], n);
  return r;
}
function qw(t, e, r, n) {
  const a = t[e](r);
  let i = a.start;
  if (i === void 0) {
    const o = Qke(a.atnStartState);
    i = SU(a, TU(o)), a.start = i;
  }
  return Uke.apply(this, [a, i, r, n]);
}
function Uke(t, e, r, n) {
  let a = e, i = 1;
  const s = [];
  let o = this.LA(i++);
  for (; ; ) {
    let l = Yke(a, o);
    if (l === void 0 && (l = Hke.apply(this, [t, a, o, i, r, n])), l === sy)
      return jke(s, a, o);
    if (l.isAcceptState === !0)
      return l.prediction;
    a = l, s.push(o), o = this.LA(i++);
  }
}
function Hke(t, e, r, n, a, i) {
  const s = Xke(e.configs, r, a);
  if (s.size === 0)
    return cN(t, e, r, sy), sy;
  let o = TU(s);
  const l = Zke(s, a);
  if (l !== void 0)
    o.isAcceptState = !0, o.prediction = l, o.configs.uniqueAlt = l;
  else if (rRe(s)) {
    const u = lf(s.alts);
    o.isAcceptState = !0, o.prediction = u, o.configs.uniqueAlt = u, Vke.apply(this, [t, n, s.alts, i]);
  }
  return o = cN(t, e, r, o), o;
}
function Vke(t, e, r, n) {
  const a = [];
  for (let u = 1; u <= e; u++)
    a.push(this.LA(u).tokenType);
  const i = t.atnStartState, s = i.rule, o = i.production, l = qke({
    topLevelRule: s,
    ambiguityIndices: r,
    production: o,
    prefixPath: a
  });
  n(l);
}
function qke(t) {
  const e = Xe(t.prefixPath, (a) => Ac(a)).join(", "), r = t.production.idx === 0 ? "" : t.production.idx;
  let n = `Ambiguous Alternatives Detected: <${t.ambiguityIndices.join(", ")}> in <${Wke(t.production)}${r}> inside <${t.topLevelRule.name}> Rule,
<${e}> may appears as a prefix path in all these alternatives.
`;
  return n = n + `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES
For Further details.`, n;
}
function Wke(t) {
  if (t instanceof pa)
    return "SUBRULE";
  if (t instanceof Gn)
    return "OPTION";
  if (t instanceof Da)
    return "OR";
  if (t instanceof si)
    return "AT_LEAST_ONE";
  if (t instanceof oi)
    return "AT_LEAST_ONE_SEP";
  if (t instanceof Pa)
    return "MANY_SEP";
  if (t instanceof Xr)
    return "MANY";
  if (t instanceof Pr)
    return "CONSUME";
  throw Error("non exhaustive match");
}
function jke(t, e, r) {
  const n = ti(e.configs.elements, (i) => i.state.transitions), a = Ube(n.filter((i) => i instanceof G3).map((i) => i.tokenType), (i) => i.tokenTypeIdx);
  return {
    actualToken: r,
    possibleTokenTypes: a,
    tokenPath: t
  };
}
function Yke(t, e) {
  return t.edges[e.tokenTypeIdx];
}
function Xke(t, e, r) {
  const n = new Q4(), a = [];
  for (const s of t.elements) {
    if (r.is(s.alt) === !1)
      continue;
    if (s.state.type === Cp) {
      a.push(s);
      continue;
    }
    const o = s.state.transitions.length;
    for (let l = 0; l < o; l++) {
      const u = s.state.transitions[l], c = Kke(u, e);
      c !== void 0 && n.add({
        state: c,
        alt: s.alt,
        stack: s.stack
      });
    }
  }
  let i;
  if (a.length === 0 && n.size === 1 && (i = n), i === void 0) {
    i = new Q4();
    for (const s of n.elements)
      oy(s, i);
  }
  if (a.length > 0 && !eRe(i))
    for (const s of a)
      i.add(s);
  return i;
}
function Kke(t, e) {
  if (t instanceof G3 && XG(e, t.tokenType))
    return t.target;
}
function Zke(t, e) {
  let r;
  for (const n of t.elements)
    if (e.is(n.alt) === !0) {
      if (r === void 0)
        r = n.alt;
      else if (r !== n.alt)
        return;
    }
  return r;
}
function TU(t) {
  return {
    configs: t,
    edges: {},
    isAcceptState: !1,
    prediction: -1
  };
}
function cN(t, e, r, n) {
  return n = SU(t, n), e.edges[r.tokenTypeIdx] = n, n;
}
function SU(t, e) {
  if (e === sy)
    return e;
  const r = e.configs.key, n = t.states[r];
  return n !== void 0 ? n : (e.configs.finalize(), t.states[r] = e, e);
}
function Qke(t) {
  const e = new Q4(), r = t.transitions.length;
  for (let n = 0; n < r; n++) {
    const i = {
      state: t.transitions[n].target,
      alt: n,
      stack: []
    };
    oy(i, e);
  }
  return e;
}
function oy(t, e) {
  const r = t.state;
  if (r.type === Cp) {
    if (t.stack.length > 0) {
      const a = [...t.stack], s = {
        state: a.pop(),
        alt: t.alt,
        stack: a
      };
      oy(s, e);
    } else
      e.add(t);
    return;
  }
  r.epsilonOnlyTransitions || e.add(t);
  const n = r.transitions.length;
  for (let a = 0; a < n; a++) {
    const i = r.transitions[a], s = Jke(t, i);
    s !== void 0 && oy(s, e);
  }
}
function Jke(t, e) {
  if (e instanceof mU)
    return {
      state: e.target,
      alt: t.alt,
      stack: t.stack
    };
  if (e instanceof U3) {
    const r = [...t.stack, e.followState];
    return {
      state: e.target,
      alt: t.alt,
      stack: r
    };
  }
}
function eRe(t) {
  for (const e of t.elements)
    if (e.state.type === Cp)
      return !0;
  return !1;
}
function tRe(t) {
  for (const e of t.elements)
    if (e.state.type !== Cp)
      return !1;
  return !0;
}
function rRe(t) {
  if (tRe(t))
    return !0;
  const e = nRe(t.elements);
  return aRe(e) && !iRe(e);
}
function nRe(t) {
  const e = /* @__PURE__ */ new Map();
  for (const r of t) {
    const n = wU(r, !1);
    let a = e.get(n);
    a === void 0 && (a = {}, e.set(n, a)), a[r.alt] = !0;
  }
  return e;
}
function aRe(t) {
  for (const e of Array.from(t.values()))
    if (Object.keys(e).length > 1)
      return !0;
  return !1;
}
function iRe(t) {
  for (const e of Array.from(t.values()))
    if (Object.keys(e).length === 1)
      return !0;
  return !1;
}
var fN;
(function(t) {
  function e(r) {
    return typeof r == "string";
  }
  t.is = e;
})(fN || (fN = {}));
var J4;
(function(t) {
  function e(r) {
    return typeof r == "string";
  }
  t.is = e;
})(J4 || (J4 = {}));
var hN;
(function(t) {
  t.MIN_VALUE = -2147483648, t.MAX_VALUE = 2147483647;
  function e(r) {
    return typeof r == "number" && t.MIN_VALUE <= r && r <= t.MAX_VALUE;
  }
  t.is = e;
})(hN || (hN = {}));
var ly;
(function(t) {
  t.MIN_VALUE = 0, t.MAX_VALUE = 2147483647;
  function e(r) {
    return typeof r == "number" && t.MIN_VALUE <= r && r <= t.MAX_VALUE;
  }
  t.is = e;
})(ly || (ly = {}));
var cr;
(function(t) {
  function e(n, a) {
    return n === Number.MAX_VALUE && (n = ly.MAX_VALUE), a === Number.MAX_VALUE && (a = ly.MAX_VALUE), { line: n, character: a };
  }
  t.create = e;
  function r(n) {
    let a = n;
    return be.objectLiteral(a) && be.uinteger(a.line) && be.uinteger(a.character);
  }
  t.is = r;
})(cr || (cr = {}));
var Xt;
(function(t) {
  function e(n, a, i, s) {
    if (be.uinteger(n) && be.uinteger(a) && be.uinteger(i) && be.uinteger(s))
      return { start: cr.create(n, a), end: cr.create(i, s) };
    if (cr.is(n) && cr.is(a))
      return { start: n, end: a };
    throw new Error(`Range#create called with invalid arguments[${n}, ${a}, ${i}, ${s}]`);
  }
  t.create = e;
  function r(n) {
    let a = n;
    return be.objectLiteral(a) && cr.is(a.start) && cr.is(a.end);
  }
  t.is = r;
})(Xt || (Xt = {}));
var uy;
(function(t) {
  function e(n, a) {
    return { uri: n, range: a };
  }
  t.create = e;
  function r(n) {
    let a = n;
    return be.objectLiteral(a) && Xt.is(a.range) && (be.string(a.uri) || be.undefined(a.uri));
  }
  t.is = r;
})(uy || (uy = {}));
var dN;
(function(t) {
  function e(n, a, i, s) {
    return { targetUri: n, targetRange: a, targetSelectionRange: i, originSelectionRange: s };
  }
  t.create = e;
  function r(n) {
    let a = n;
    return be.objectLiteral(a) && Xt.is(a.targetRange) && be.string(a.targetUri) && Xt.is(a.targetSelectionRange) && (Xt.is(a.originSelectionRange) || be.undefined(a.originSelectionRange));
  }
  t.is = r;
})(dN || (dN = {}));
var eS;
(function(t) {
  function e(n, a, i, s) {
    return {
      red: n,
      green: a,
      blue: i,
      alpha: s
    };
  }
  t.create = e;
  function r(n) {
    const a = n;
    return be.objectLiteral(a) && be.numberRange(a.red, 0, 1) && be.numberRange(a.green, 0, 1) && be.numberRange(a.blue, 0, 1) && be.numberRange(a.alpha, 0, 1);
  }
  t.is = r;
})(eS || (eS = {}));
var pN;
(function(t) {
  function e(n, a) {
    return {
      range: n,
      color: a
    };
  }
  t.create = e;
  function r(n) {
    const a = n;
    return be.objectLiteral(a) && Xt.is(a.range) && eS.is(a.color);
  }
  t.is = r;
})(pN || (pN = {}));
var gN;
(function(t) {
  function e(n, a, i) {
    return {
      label: n,
      textEdit: a,
      additionalTextEdits: i
    };
  }
  t.create = e;
  function r(n) {
    const a = n;
    return be.objectLiteral(a) && be.string(a.label) && (be.undefined(a.textEdit) || vf.is(a)) && (be.undefined(a.additionalTextEdits) || be.typedArray(a.additionalTextEdits, vf.is));
  }
  t.is = r;
})(gN || (gN = {}));
var vN;
(function(t) {
  t.Comment = "comment", t.Imports = "imports", t.Region = "region";
})(vN || (vN = {}));
var mN;
(function(t) {
  function e(n, a, i, s, o, l) {
    const u = {
      startLine: n,
      endLine: a
    };
    return be.defined(i) && (u.startCharacter = i), be.defined(s) && (u.endCharacter = s), be.defined(o) && (u.kind = o), be.defined(l) && (u.collapsedText = l), u;
  }
  t.create = e;
  function r(n) {
    const a = n;
    return be.objectLiteral(a) && be.uinteger(a.startLine) && be.uinteger(a.startLine) && (be.undefined(a.startCharacter) || be.uinteger(a.startCharacter)) && (be.undefined(a.endCharacter) || be.uinteger(a.endCharacter)) && (be.undefined(a.kind) || be.string(a.kind));
  }
  t.is = r;
})(mN || (mN = {}));
var tS;
(function(t) {
  function e(n, a) {
    return {
      location: n,
      message: a
    };
  }
  t.create = e;
  function r(n) {
    let a = n;
    return be.defined(a) && uy.is(a.location) && be.string(a.message);
  }
  t.is = r;
})(tS || (tS = {}));
var yN;
(function(t) {
  t.Error = 1, t.Warning = 2, t.Information = 3, t.Hint = 4;
})(yN || (yN = {}));
var bN;
(function(t) {
  t.Unnecessary = 1, t.Deprecated = 2;
})(bN || (bN = {}));
var xN;
(function(t) {
  function e(r) {
    const n = r;
    return be.objectLiteral(n) && be.string(n.href);
  }
  t.is = e;
})(xN || (xN = {}));
var cy;
(function(t) {
  function e(n, a, i, s, o, l) {
    let u = { range: n, message: a };
    return be.defined(i) && (u.severity = i), be.defined(s) && (u.code = s), be.defined(o) && (u.source = o), be.defined(l) && (u.relatedInformation = l), u;
  }
  t.create = e;
  function r(n) {
    var a;
    let i = n;
    return be.defined(i) && Xt.is(i.range) && be.string(i.message) && (be.number(i.severity) || be.undefined(i.severity)) && (be.integer(i.code) || be.string(i.code) || be.undefined(i.code)) && (be.undefined(i.codeDescription) || be.string((a = i.codeDescription) === null || a === void 0 ? void 0 : a.href)) && (be.string(i.source) || be.undefined(i.source)) && (be.undefined(i.relatedInformation) || be.typedArray(i.relatedInformation, tS.is));
  }
  t.is = r;
})(cy || (cy = {}));
var gf;
(function(t) {
  function e(n, a, ...i) {
    let s = { title: n, command: a };
    return be.defined(i) && i.length > 0 && (s.arguments = i), s;
  }
  t.create = e;
  function r(n) {
    let a = n;
    return be.defined(a) && be.string(a.title) && be.string(a.command);
  }
  t.is = r;
})(gf || (gf = {}));
var vf;
(function(t) {
  function e(i, s) {
    return { range: i, newText: s };
  }
  t.replace = e;
  function r(i, s) {
    return { range: { start: i, end: i }, newText: s };
  }
  t.insert = r;
  function n(i) {
    return { range: i, newText: "" };
  }
  t.del = n;
  function a(i) {
    const s = i;
    return be.objectLiteral(s) && be.string(s.newText) && Xt.is(s.range);
  }
  t.is = a;
})(vf || (vf = {}));
var rS;
(function(t) {
  function e(n, a, i) {
    const s = { label: n };
    return a !== void 0 && (s.needsConfirmation = a), i !== void 0 && (s.description = i), s;
  }
  t.create = e;
  function r(n) {
    const a = n;
    return be.objectLiteral(a) && be.string(a.label) && (be.boolean(a.needsConfirmation) || a.needsConfirmation === void 0) && (be.string(a.description) || a.description === void 0);
  }
  t.is = r;
})(rS || (rS = {}));
var mf;
(function(t) {
  function e(r) {
    const n = r;
    return be.string(n);
  }
  t.is = e;
})(mf || (mf = {}));
var wN;
(function(t) {
  function e(i, s, o) {
    return { range: i, newText: s, annotationId: o };
  }
  t.replace = e;
  function r(i, s, o) {
    return { range: { start: i, end: i }, newText: s, annotationId: o };
  }
  t.insert = r;
  function n(i, s) {
    return { range: i, newText: "", annotationId: s };
  }
  t.del = n;
  function a(i) {
    const s = i;
    return vf.is(s) && (rS.is(s.annotationId) || mf.is(s.annotationId));
  }
  t.is = a;
})(wN || (wN = {}));
var nS;
(function(t) {
  function e(n, a) {
    return { textDocument: n, edits: a };
  }
  t.create = e;
  function r(n) {
    let a = n;
    return be.defined(a) && lS.is(a.textDocument) && Array.isArray(a.edits);
  }
  t.is = r;
})(nS || (nS = {}));
var aS;
(function(t) {
  function e(n, a, i) {
    let s = {
      kind: "create",
      uri: n
    };
    return a !== void 0 && (a.overwrite !== void 0 || a.ignoreIfExists !== void 0) && (s.options = a), i !== void 0 && (s.annotationId = i), s;
  }
  t.create = e;
  function r(n) {
    let a = n;
    return a && a.kind === "create" && be.string(a.uri) && (a.options === void 0 || (a.options.overwrite === void 0 || be.boolean(a.options.overwrite)) && (a.options.ignoreIfExists === void 0 || be.boolean(a.options.ignoreIfExists))) && (a.annotationId === void 0 || mf.is(a.annotationId));
  }
  t.is = r;
})(aS || (aS = {}));
var iS;
(function(t) {
  function e(n, a, i, s) {
    let o = {
      kind: "rename",
      oldUri: n,
      newUri: a
    };
    return i !== void 0 && (i.overwrite !== void 0 || i.ignoreIfExists !== void 0) && (o.options = i), s !== void 0 && (o.annotationId = s), o;
  }
  t.create = e;
  function r(n) {
    let a = n;
    return a && a.kind === "rename" && be.string(a.oldUri) && be.string(a.newUri) && (a.options === void 0 || (a.options.overwrite === void 0 || be.boolean(a.options.overwrite)) && (a.options.ignoreIfExists === void 0 || be.boolean(a.options.ignoreIfExists))) && (a.annotationId === void 0 || mf.is(a.annotationId));
  }
  t.is = r;
})(iS || (iS = {}));
var sS;
(function(t) {
  function e(n, a, i) {
    let s = {
      kind: "delete",
      uri: n
    };
    return a !== void 0 && (a.recursive !== void 0 || a.ignoreIfNotExists !== void 0) && (s.options = a), i !== void 0 && (s.annotationId = i), s;
  }
  t.create = e;
  function r(n) {
    let a = n;
    return a && a.kind === "delete" && be.string(a.uri) && (a.options === void 0 || (a.options.recursive === void 0 || be.boolean(a.options.recursive)) && (a.options.ignoreIfNotExists === void 0 || be.boolean(a.options.ignoreIfNotExists))) && (a.annotationId === void 0 || mf.is(a.annotationId));
  }
  t.is = r;
})(sS || (sS = {}));
var oS;
(function(t) {
  function e(r) {
    let n = r;
    return n && (n.changes !== void 0 || n.documentChanges !== void 0) && (n.documentChanges === void 0 || n.documentChanges.every((a) => be.string(a.kind) ? aS.is(a) || iS.is(a) || sS.is(a) : nS.is(a)));
  }
  t.is = e;
})(oS || (oS = {}));
var EN;
(function(t) {
  function e(n) {
    return { uri: n };
  }
  t.create = e;
  function r(n) {
    let a = n;
    return be.defined(a) && be.string(a.uri);
  }
  t.is = r;
})(EN || (EN = {}));
var TN;
(function(t) {
  function e(n, a) {
    return { uri: n, version: a };
  }
  t.create = e;
  function r(n) {
    let a = n;
    return be.defined(a) && be.string(a.uri) && be.integer(a.version);
  }
  t.is = r;
})(TN || (TN = {}));
var lS;
(function(t) {
  function e(n, a) {
    return { uri: n, version: a };
  }
  t.create = e;
  function r(n) {
    let a = n;
    return be.defined(a) && be.string(a.uri) && (a.version === null || be.integer(a.version));
  }
  t.is = r;
})(lS || (lS = {}));
var SN;
(function(t) {
  function e(n, a, i, s) {
    return { uri: n, languageId: a, version: i, text: s };
  }
  t.create = e;
  function r(n) {
    let a = n;
    return be.defined(a) && be.string(a.uri) && be.string(a.languageId) && be.integer(a.version) && be.string(a.text);
  }
  t.is = r;
})(SN || (SN = {}));
var uS;
(function(t) {
  t.PlainText = "plaintext", t.Markdown = "markdown";
  function e(r) {
    const n = r;
    return n === t.PlainText || n === t.Markdown;
  }
  t.is = e;
})(uS || (uS = {}));
var m0;
(function(t) {
  function e(r) {
    const n = r;
    return be.objectLiteral(r) && uS.is(n.kind) && be.string(n.value);
  }
  t.is = e;
})(m0 || (m0 = {}));
var CN;
(function(t) {
  t.Text = 1, t.Method = 2, t.Function = 3, t.Constructor = 4, t.Field = 5, t.Variable = 6, t.Class = 7, t.Interface = 8, t.Module = 9, t.Property = 10, t.Unit = 11, t.Value = 12, t.Enum = 13, t.Keyword = 14, t.Snippet = 15, t.Color = 16, t.File = 17, t.Reference = 18, t.Folder = 19, t.EnumMember = 20, t.Constant = 21, t.Struct = 22, t.Event = 23, t.Operator = 24, t.TypeParameter = 25;
})(CN || (CN = {}));
var AN;
(function(t) {
  t.PlainText = 1, t.Snippet = 2;
})(AN || (AN = {}));
var kN;
(function(t) {
  t.Deprecated = 1;
})(kN || (kN = {}));
var RN;
(function(t) {
  function e(n, a, i) {
    return { newText: n, insert: a, replace: i };
  }
  t.create = e;
  function r(n) {
    const a = n;
    return a && be.string(a.newText) && Xt.is(a.insert) && Xt.is(a.replace);
  }
  t.is = r;
})(RN || (RN = {}));
var MN;
(function(t) {
  t.asIs = 1, t.adjustIndentation = 2;
})(MN || (MN = {}));
var _N;
(function(t) {
  function e(r) {
    const n = r;
    return n && (be.string(n.detail) || n.detail === void 0) && (be.string(n.description) || n.description === void 0);
  }
  t.is = e;
})(_N || (_N = {}));
var LN;
(function(t) {
  function e(r) {
    return { label: r };
  }
  t.create = e;
})(LN || (LN = {}));
var NN;
(function(t) {
  function e(r, n) {
    return { items: r || [], isIncomplete: !!n };
  }
  t.create = e;
})(NN || (NN = {}));
var fy;
(function(t) {
  function e(n) {
    return n.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
  }
  t.fromPlainText = e;
  function r(n) {
    const a = n;
    return be.string(a) || be.objectLiteral(a) && be.string(a.language) && be.string(a.value);
  }
  t.is = r;
})(fy || (fy = {}));
var ON;
(function(t) {
  function e(r) {
    let n = r;
    return !!n && be.objectLiteral(n) && (m0.is(n.contents) || fy.is(n.contents) || be.typedArray(n.contents, fy.is)) && (r.range === void 0 || Xt.is(r.range));
  }
  t.is = e;
})(ON || (ON = {}));
var IN;
(function(t) {
  function e(r, n) {
    return n ? { label: r, documentation: n } : { label: r };
  }
  t.create = e;
})(IN || (IN = {}));
var PN;
(function(t) {
  function e(r, n, ...a) {
    let i = { label: r };
    return be.defined(n) && (i.documentation = n), be.defined(a) ? i.parameters = a : i.parameters = [], i;
  }
  t.create = e;
})(PN || (PN = {}));
var DN;
(function(t) {
  t.Text = 1, t.Read = 2, t.Write = 3;
})(DN || (DN = {}));
var $N;
(function(t) {
  function e(r, n) {
    let a = { range: r };
    return be.number(n) && (a.kind = n), a;
  }
  t.create = e;
})($N || ($N = {}));
var FN;
(function(t) {
  t.File = 1, t.Module = 2, t.Namespace = 3, t.Package = 4, t.Class = 5, t.Method = 6, t.Property = 7, t.Field = 8, t.Constructor = 9, t.Enum = 10, t.Interface = 11, t.Function = 12, t.Variable = 13, t.Constant = 14, t.String = 15, t.Number = 16, t.Boolean = 17, t.Array = 18, t.Object = 19, t.Key = 20, t.Null = 21, t.EnumMember = 22, t.Struct = 23, t.Event = 24, t.Operator = 25, t.TypeParameter = 26;
})(FN || (FN = {}));
var BN;
(function(t) {
  t.Deprecated = 1;
})(BN || (BN = {}));
var zN;
(function(t) {
  function e(r, n, a, i, s) {
    let o = {
      name: r,
      kind: n,
      location: { uri: i, range: a }
    };
    return s && (o.containerName = s), o;
  }
  t.create = e;
})(zN || (zN = {}));
var GN;
(function(t) {
  function e(r, n, a, i) {
    return i !== void 0 ? { name: r, kind: n, location: { uri: a, range: i } } : { name: r, kind: n, location: { uri: a } };
  }
  t.create = e;
})(GN || (GN = {}));
var UN;
(function(t) {
  function e(n, a, i, s, o, l) {
    let u = {
      name: n,
      detail: a,
      kind: i,
      range: s,
      selectionRange: o
    };
    return l !== void 0 && (u.children = l), u;
  }
  t.create = e;
  function r(n) {
    let a = n;
    return a && be.string(a.name) && be.number(a.kind) && Xt.is(a.range) && Xt.is(a.selectionRange) && (a.detail === void 0 || be.string(a.detail)) && (a.deprecated === void 0 || be.boolean(a.deprecated)) && (a.children === void 0 || Array.isArray(a.children)) && (a.tags === void 0 || Array.isArray(a.tags));
  }
  t.is = r;
})(UN || (UN = {}));
var HN;
(function(t) {
  t.Empty = "", t.QuickFix = "quickfix", t.Refactor = "refactor", t.RefactorExtract = "refactor.extract", t.RefactorInline = "refactor.inline", t.RefactorRewrite = "refactor.rewrite", t.Source = "source", t.SourceOrganizeImports = "source.organizeImports", t.SourceFixAll = "source.fixAll";
})(HN || (HN = {}));
var hy;
(function(t) {
  t.Invoked = 1, t.Automatic = 2;
})(hy || (hy = {}));
var VN;
(function(t) {
  function e(n, a, i) {
    let s = { diagnostics: n };
    return a != null && (s.only = a), i != null && (s.triggerKind = i), s;
  }
  t.create = e;
  function r(n) {
    let a = n;
    return be.defined(a) && be.typedArray(a.diagnostics, cy.is) && (a.only === void 0 || be.typedArray(a.only, be.string)) && (a.triggerKind === void 0 || a.triggerKind === hy.Invoked || a.triggerKind === hy.Automatic);
  }
  t.is = r;
})(VN || (VN = {}));
var qN;
(function(t) {
  function e(n, a, i) {
    let s = { title: n }, o = !0;
    return typeof a == "string" ? (o = !1, s.kind = a) : gf.is(a) ? s.command = a : s.edit = a, o && i !== void 0 && (s.kind = i), s;
  }
  t.create = e;
  function r(n) {
    let a = n;
    return a && be.string(a.title) && (a.diagnostics === void 0 || be.typedArray(a.diagnostics, cy.is)) && (a.kind === void 0 || be.string(a.kind)) && (a.edit !== void 0 || a.command !== void 0) && (a.command === void 0 || gf.is(a.command)) && (a.isPreferred === void 0 || be.boolean(a.isPreferred)) && (a.edit === void 0 || oS.is(a.edit));
  }
  t.is = r;
})(qN || (qN = {}));
var WN;
(function(t) {
  function e(n, a) {
    let i = { range: n };
    return be.defined(a) && (i.data = a), i;
  }
  t.create = e;
  function r(n) {
    let a = n;
    return be.defined(a) && Xt.is(a.range) && (be.undefined(a.command) || gf.is(a.command));
  }
  t.is = r;
})(WN || (WN = {}));
var jN;
(function(t) {
  function e(n, a) {
    return { tabSize: n, insertSpaces: a };
  }
  t.create = e;
  function r(n) {
    let a = n;
    return be.defined(a) && be.uinteger(a.tabSize) && be.boolean(a.insertSpaces);
  }
  t.is = r;
})(jN || (jN = {}));
var YN;
(function(t) {
  function e(n, a, i) {
    return { range: n, target: a, data: i };
  }
  t.create = e;
  function r(n) {
    let a = n;
    return be.defined(a) && Xt.is(a.range) && (be.undefined(a.target) || be.string(a.target));
  }
  t.is = r;
})(YN || (YN = {}));
var XN;
(function(t) {
  function e(n, a) {
    return { range: n, parent: a };
  }
  t.create = e;
  function r(n) {
    let a = n;
    return be.objectLiteral(a) && Xt.is(a.range) && (a.parent === void 0 || t.is(a.parent));
  }
  t.is = r;
})(XN || (XN = {}));
var KN;
(function(t) {
  t.namespace = "namespace", t.type = "type", t.class = "class", t.enum = "enum", t.interface = "interface", t.struct = "struct", t.typeParameter = "typeParameter", t.parameter = "parameter", t.variable = "variable", t.property = "property", t.enumMember = "enumMember", t.event = "event", t.function = "function", t.method = "method", t.macro = "macro", t.keyword = "keyword", t.modifier = "modifier", t.comment = "comment", t.string = "string", t.number = "number", t.regexp = "regexp", t.operator = "operator", t.decorator = "decorator";
})(KN || (KN = {}));
var ZN;
(function(t) {
  t.declaration = "declaration", t.definition = "definition", t.readonly = "readonly", t.static = "static", t.deprecated = "deprecated", t.abstract = "abstract", t.async = "async", t.modification = "modification", t.documentation = "documentation", t.defaultLibrary = "defaultLibrary";
})(ZN || (ZN = {}));
var QN;
(function(t) {
  function e(r) {
    const n = r;
    return be.objectLiteral(n) && (n.resultId === void 0 || typeof n.resultId == "string") && Array.isArray(n.data) && (n.data.length === 0 || typeof n.data[0] == "number");
  }
  t.is = e;
})(QN || (QN = {}));
var JN;
(function(t) {
  function e(n, a) {
    return { range: n, text: a };
  }
  t.create = e;
  function r(n) {
    const a = n;
    return a != null && Xt.is(a.range) && be.string(a.text);
  }
  t.is = r;
})(JN || (JN = {}));
var e8;
(function(t) {
  function e(n, a, i) {
    return { range: n, variableName: a, caseSensitiveLookup: i };
  }
  t.create = e;
  function r(n) {
    const a = n;
    return a != null && Xt.is(a.range) && be.boolean(a.caseSensitiveLookup) && (be.string(a.variableName) || a.variableName === void 0);
  }
  t.is = r;
})(e8 || (e8 = {}));
var t8;
(function(t) {
  function e(n, a) {
    return { range: n, expression: a };
  }
  t.create = e;
  function r(n) {
    const a = n;
    return a != null && Xt.is(a.range) && (be.string(a.expression) || a.expression === void 0);
  }
  t.is = r;
})(t8 || (t8 = {}));
var r8;
(function(t) {
  function e(n, a) {
    return { frameId: n, stoppedLocation: a };
  }
  t.create = e;
  function r(n) {
    const a = n;
    return be.defined(a) && Xt.is(n.stoppedLocation);
  }
  t.is = r;
})(r8 || (r8 = {}));
var cS;
(function(t) {
  t.Type = 1, t.Parameter = 2;
  function e(r) {
    return r === 1 || r === 2;
  }
  t.is = e;
})(cS || (cS = {}));
var fS;
(function(t) {
  function e(n) {
    return { value: n };
  }
  t.create = e;
  function r(n) {
    const a = n;
    return be.objectLiteral(a) && (a.tooltip === void 0 || be.string(a.tooltip) || m0.is(a.tooltip)) && (a.location === void 0 || uy.is(a.location)) && (a.command === void 0 || gf.is(a.command));
  }
  t.is = r;
})(fS || (fS = {}));
var n8;
(function(t) {
  function e(n, a, i) {
    const s = { position: n, label: a };
    return i !== void 0 && (s.kind = i), s;
  }
  t.create = e;
  function r(n) {
    const a = n;
    return be.objectLiteral(a) && cr.is(a.position) && (be.string(a.label) || be.typedArray(a.label, fS.is)) && (a.kind === void 0 || cS.is(a.kind)) && a.textEdits === void 0 || be.typedArray(a.textEdits, vf.is) && (a.tooltip === void 0 || be.string(a.tooltip) || m0.is(a.tooltip)) && (a.paddingLeft === void 0 || be.boolean(a.paddingLeft)) && (a.paddingRight === void 0 || be.boolean(a.paddingRight));
  }
  t.is = r;
})(n8 || (n8 = {}));
var a8;
(function(t) {
  function e(r) {
    return { kind: "snippet", value: r };
  }
  t.createSnippet = e;
})(a8 || (a8 = {}));
var i8;
(function(t) {
  function e(r, n, a, i) {
    return { insertText: r, filterText: n, range: a, command: i };
  }
  t.create = e;
})(i8 || (i8 = {}));
var s8;
(function(t) {
  function e(r) {
    return { items: r };
  }
  t.create = e;
})(s8 || (s8 = {}));
var o8;
(function(t) {
  t.Invoked = 0, t.Automatic = 1;
})(o8 || (o8 = {}));
var l8;
(function(t) {
  function e(r, n) {
    return { range: r, text: n };
  }
  t.create = e;
})(l8 || (l8 = {}));
var u8;
(function(t) {
  function e(r, n) {
    return { triggerKind: r, selectedCompletionInfo: n };
  }
  t.create = e;
})(u8 || (u8 = {}));
var c8;
(function(t) {
  function e(r) {
    const n = r;
    return be.objectLiteral(n) && J4.is(n.uri) && be.string(n.name);
  }
  t.is = e;
})(c8 || (c8 = {}));
var f8;
(function(t) {
  function e(i, s, o, l) {
    return new sRe(i, s, o, l);
  }
  t.create = e;
  function r(i) {
    let s = i;
    return !!(be.defined(s) && be.string(s.uri) && (be.undefined(s.languageId) || be.string(s.languageId)) && be.uinteger(s.lineCount) && be.func(s.getText) && be.func(s.positionAt) && be.func(s.offsetAt));
  }
  t.is = r;
  function n(i, s) {
    let o = i.getText(), l = a(s, (c, f) => {
      let h = c.range.start.line - f.range.start.line;
      return h === 0 ? c.range.start.character - f.range.start.character : h;
    }), u = o.length;
    for (let c = l.length - 1; c >= 0; c--) {
      let f = l[c], h = i.offsetAt(f.range.start), d = i.offsetAt(f.range.end);
      if (d <= u)
        o = o.substring(0, h) + f.newText + o.substring(d, o.length);
      else
        throw new Error("Overlapping edit");
      u = h;
    }
    return o;
  }
  t.applyEdits = n;
  function a(i, s) {
    if (i.length <= 1)
      return i;
    const o = i.length / 2 | 0, l = i.slice(0, o), u = i.slice(o);
    a(l, s), a(u, s);
    let c = 0, f = 0, h = 0;
    for (; c < l.length && f < u.length; )
      s(l[c], u[f]) <= 0 ? i[h++] = l[c++] : i[h++] = u[f++];
    for (; c < l.length; )
      i[h++] = l[c++];
    for (; f < u.length; )
      i[h++] = u[f++];
    return i;
  }
})(f8 || (f8 = {}));
let sRe = class {
  constructor(e, r, n, a) {
    this._uri = e, this._languageId = r, this._version = n, this._content = a, this._lineOffsets = void 0;
  }
  get uri() {
    return this._uri;
  }
  get languageId() {
    return this._languageId;
  }
  get version() {
    return this._version;
  }
  getText(e) {
    if (e) {
      let r = this.offsetAt(e.start), n = this.offsetAt(e.end);
      return this._content.substring(r, n);
    }
    return this._content;
  }
  update(e, r) {
    this._content = e.text, this._version = r, this._lineOffsets = void 0;
  }
  getLineOffsets() {
    if (this._lineOffsets === void 0) {
      let e = [], r = this._content, n = !0;
      for (let a = 0; a < r.length; a++) {
        n && (e.push(a), n = !1);
        let i = r.charAt(a);
        n = i === "\r" || i === `
`, i === "\r" && a + 1 < r.length && r.charAt(a + 1) === `
` && a++;
      }
      n && r.length > 0 && e.push(r.length), this._lineOffsets = e;
    }
    return this._lineOffsets;
  }
  positionAt(e) {
    e = Math.max(Math.min(e, this._content.length), 0);
    let r = this.getLineOffsets(), n = 0, a = r.length;
    if (a === 0)
      return cr.create(0, e);
    for (; n < a; ) {
      let s = Math.floor((n + a) / 2);
      r[s] > e ? a = s : n = s + 1;
    }
    let i = n - 1;
    return cr.create(i, e - r[i]);
  }
  offsetAt(e) {
    let r = this.getLineOffsets();
    if (e.line >= r.length)
      return this._content.length;
    if (e.line < 0)
      return 0;
    let n = r[e.line], a = e.line + 1 < r.length ? r[e.line + 1] : this._content.length;
    return Math.max(Math.min(n + e.character, a), n);
  }
  get lineCount() {
    return this.getLineOffsets().length;
  }
};
var be;
(function(t) {
  const e = Object.prototype.toString;
  function r(d) {
    return typeof d < "u";
  }
  t.defined = r;
  function n(d) {
    return typeof d > "u";
  }
  t.undefined = n;
  function a(d) {
    return d === !0 || d === !1;
  }
  t.boolean = a;
  function i(d) {
    return e.call(d) === "[object String]";
  }
  t.string = i;
  function s(d) {
    return e.call(d) === "[object Number]";
  }
  t.number = s;
  function o(d, p, g) {
    return e.call(d) === "[object Number]" && p <= d && d <= g;
  }
  t.numberRange = o;
  function l(d) {
    return e.call(d) === "[object Number]" && -2147483648 <= d && d <= 2147483647;
  }
  t.integer = l;
  function u(d) {
    return e.call(d) === "[object Number]" && 0 <= d && d <= 2147483647;
  }
  t.uinteger = u;
  function c(d) {
    return e.call(d) === "[object Function]";
  }
  t.func = c;
  function f(d) {
    return d !== null && typeof d == "object";
  }
  t.objectLiteral = f;
  function h(d, p) {
    return Array.isArray(d) && d.every(p);
  }
  t.typedArray = h;
})(be || (be = {}));
class oRe {
  constructor() {
    this.nodeStack = [];
  }
  get current() {
    var e;
    return (e = this.nodeStack[this.nodeStack.length - 1]) !== null && e !== void 0 ? e : this.rootNode;
  }
  buildRootNode(e) {
    return this.rootNode = new AU(e), this.rootNode.root = this.rootNode, this.nodeStack = [this.rootNode], this.rootNode;
  }
  buildCompositeNode(e) {
    const r = new q3();
    return r.grammarSource = e, r.root = this.rootNode, this.current.content.push(r), this.nodeStack.push(r), r;
  }
  buildLeafNode(e, r) {
    const n = new hS(e.startOffset, e.image.length, B4(e), e.tokenType, !r);
    return n.grammarSource = r, n.root = this.rootNode, this.current.content.push(n), n;
  }
  removeNode(e) {
    const r = e.container;
    if (r) {
      const n = r.content.indexOf(e);
      n >= 0 && r.content.splice(n, 1);
    }
  }
  addHiddenNodes(e) {
    const r = [];
    for (const i of e) {
      const s = new hS(i.startOffset, i.image.length, B4(i), i.tokenType, !0);
      s.root = this.rootNode, r.push(s);
    }
    let n = this.current, a = !1;
    if (n.content.length > 0) {
      n.content.push(...r);
      return;
    }
    for (; n.container; ) {
      const i = n.container.content.indexOf(n);
      if (i > 0) {
        n.container.content.splice(i, 0, ...r), a = !0;
        break;
      }
      n = n.container;
    }
    a || this.rootNode.content.unshift(...r);
  }
  construct(e) {
    const r = this.current;
    typeof e.$type == "string" && (this.current.astNode = e), e.$cstNode = r;
    const n = this.nodeStack.pop();
    (n == null ? void 0 : n.content.length) === 0 && this.removeNode(n);
  }
}
class CU {
  /** @deprecated use `container` instead. */
  get parent() {
    return this.container;
  }
  /** @deprecated use `grammarSource` instead. */
  get feature() {
    return this.grammarSource;
  }
  get hidden() {
    return !1;
  }
  get astNode() {
    var e, r;
    const n = typeof ((e = this._astNode) === null || e === void 0 ? void 0 : e.$type) == "string" ? this._astNode : (r = this.container) === null || r === void 0 ? void 0 : r.astNode;
    if (!n)
      throw new Error("This node has no associated AST element");
    return n;
  }
  set astNode(e) {
    this._astNode = e;
  }
  /** @deprecated use `astNode` instead. */
  get element() {
    return this.astNode;
  }
  get text() {
    return this.root.fullText.substring(this.offset, this.end);
  }
}
class hS extends CU {
  get offset() {
    return this._offset;
  }
  get length() {
    return this._length;
  }
  get end() {
    return this._offset + this._length;
  }
  get hidden() {
    return this._hidden;
  }
  get tokenType() {
    return this._tokenType;
  }
  get range() {
    return this._range;
  }
  constructor(e, r, n, a, i = !1) {
    super(), this._hidden = i, this._offset = e, this._tokenType = a, this._length = r, this._range = n;
  }
}
class q3 extends CU {
  constructor() {
    super(...arguments), this.content = new W3(this);
  }
  /** @deprecated use `content` instead. */
  get children() {
    return this.content;
  }
  get offset() {
    var e, r;
    return (r = (e = this.firstNonHiddenNode) === null || e === void 0 ? void 0 : e.offset) !== null && r !== void 0 ? r : 0;
  }
  get length() {
    return this.end - this.offset;
  }
  get end() {
    var e, r;
    return (r = (e = this.lastNonHiddenNode) === null || e === void 0 ? void 0 : e.end) !== null && r !== void 0 ? r : 0;
  }
  get range() {
    const e = this.firstNonHiddenNode, r = this.lastNonHiddenNode;
    if (e && r) {
      if (this._rangeCache === void 0) {
        const { range: n } = e, { range: a } = r;
        this._rangeCache = { start: n.start, end: a.end.line < n.start.line ? n.start : a.end };
      }
      return this._rangeCache;
    } else
      return { start: cr.create(0, 0), end: cr.create(0, 0) };
  }
  get firstNonHiddenNode() {
    for (const e of this.content)
      if (!e.hidden)
        return e;
    return this.content[0];
  }
  get lastNonHiddenNode() {
    for (let e = this.content.length - 1; e >= 0; e--) {
      const r = this.content[e];
      if (!r.hidden)
        return r;
    }
    return this.content[this.content.length - 1];
  }
}
class W3 extends Array {
  constructor(e) {
    super(), this.parent = e, Object.setPrototypeOf(this, W3.prototype);
  }
  push(...e) {
    return this.addParents(e), super.push(...e);
  }
  unshift(...e) {
    return this.addParents(e), super.unshift(...e);
  }
  splice(e, r, ...n) {
    return this.addParents(n), super.splice(e, r, ...n);
  }
  addParents(e) {
    for (const r of e)
      r.container = this.parent;
  }
}
class AU extends q3 {
  get text() {
    return this._text.substring(this.offset, this.end);
  }
  get fullText() {
    return this._text;
  }
  constructor(e) {
    super(), this._text = "", this._text = e ?? "";
  }
}
const dS = Symbol("Datatype");
function Ww(t) {
  return t.$type === dS;
}
const h8 = "​", kU = (t) => t.endsWith(h8) ? t : t + h8;
class RU {
  constructor(e) {
    this._unorderedGroups = /* @__PURE__ */ new Map(), this.allRules = /* @__PURE__ */ new Map(), this.lexer = e.parser.Lexer;
    const r = this.lexer.definition, n = e.LanguageMetaData.mode === "production";
    this.wrapper = new hRe(r, Object.assign(Object.assign({}, e.parser.ParserConfig), { skipValidations: n, errorMessageProvider: e.parser.ParserErrorMessageProvider }));
  }
  alternatives(e, r) {
    this.wrapper.wrapOr(e, r);
  }
  optional(e, r) {
    this.wrapper.wrapOption(e, r);
  }
  many(e, r) {
    this.wrapper.wrapMany(e, r);
  }
  atLeastOne(e, r) {
    this.wrapper.wrapAtLeastOne(e, r);
  }
  getRule(e) {
    return this.allRules.get(e);
  }
  isRecording() {
    return this.wrapper.IS_RECORDING;
  }
  get unorderedGroups() {
    return this._unorderedGroups;
  }
  getRuleStack() {
    return this.wrapper.RULE_STACK;
  }
  finalize() {
    this.wrapper.wrapSelfAnalysis();
  }
}
class lRe extends RU {
  get current() {
    return this.stack[this.stack.length - 1];
  }
  constructor(e) {
    super(e), this.nodeBuilder = new oRe(), this.stack = [], this.assignmentMap = /* @__PURE__ */ new Map(), this.linker = e.references.Linker, this.converter = e.parser.ValueConverter, this.astReflection = e.shared.AstReflection;
  }
  rule(e, r) {
    const n = this.computeRuleType(e), a = this.wrapper.DEFINE_RULE(kU(e.name), this.startImplementation(n, r).bind(this));
    return this.allRules.set(e.name, a), e.entry && (this.mainRule = a), a;
  }
  computeRuleType(e) {
    if (!e.fragment) {
      if (OG(e))
        return dS;
      {
        const r = L3(e);
        return r ?? e.name;
      }
    }
  }
  parse(e, r = {}) {
    this.nodeBuilder.buildRootNode(e);
    const n = this.lexerResult = this.lexer.tokenize(e);
    this.wrapper.input = n.tokens;
    const a = r.rule ? this.allRules.get(r.rule) : this.mainRule;
    if (!a)
      throw new Error(r.rule ? `No rule found with name '${r.rule}'` : "No main rule available.");
    const i = a.call(this.wrapper, {});
    return this.nodeBuilder.addHiddenNodes(n.hidden), this.unorderedGroups.clear(), this.lexerResult = void 0, {
      value: i,
      lexerErrors: n.errors,
      lexerReport: n.report,
      parserErrors: this.wrapper.errors
    };
  }
  startImplementation(e, r) {
    return (n) => {
      const a = !this.isRecording() && e !== void 0;
      if (a) {
        const s = { $type: e };
        this.stack.push(s), e === dS && (s.value = "");
      }
      let i;
      try {
        i = r(n);
      } catch {
        i = void 0;
      }
      return i === void 0 && a && (i = this.construct()), i;
    };
  }
  extractHiddenTokens(e) {
    const r = this.lexerResult.hidden;
    if (!r.length)
      return [];
    const n = e.startOffset;
    for (let a = 0; a < r.length; a++)
      if (r[a].startOffset > n)
        return r.splice(0, a);
    return r.splice(0, r.length);
  }
  consume(e, r, n) {
    const a = this.wrapper.wrapConsume(e, r);
    if (!this.isRecording() && this.isValidToken(a)) {
      const i = this.extractHiddenTokens(a);
      this.nodeBuilder.addHiddenNodes(i);
      const s = this.nodeBuilder.buildLeafNode(a, n), { assignment: o, isCrossRef: l } = this.getAssignment(n), u = this.current;
      if (o) {
        const c = fu(n) ? a.image : this.converter.convert(a.image, s);
        this.assign(o.operator, o.feature, c, s, l);
      } else if (Ww(u)) {
        let c = a.image;
        fu(n) || (c = this.converter.convert(c, s).toString()), u.value += c;
      }
    }
  }
  /**
   * Most consumed parser tokens are valid. However there are two cases in which they are not valid:
   *
   * 1. They were inserted during error recovery by the parser. These tokens don't really exist and should not be further processed
   * 2. They contain invalid token ranges. This might include the special EOF token, or other tokens produced by invalid token builders.
   */
  isValidToken(e) {
    return !e.isInsertedInRecovery && !isNaN(e.startOffset) && typeof e.endOffset == "number" && !isNaN(e.endOffset);
  }
  subrule(e, r, n, a, i) {
    let s;
    !this.isRecording() && !n && (s = this.nodeBuilder.buildCompositeNode(a));
    const o = this.wrapper.wrapSubrule(e, r, i);
    !this.isRecording() && s && s.length > 0 && this.performSubruleAssignment(o, a, s);
  }
  performSubruleAssignment(e, r, n) {
    const { assignment: a, isCrossRef: i } = this.getAssignment(r);
    if (a)
      this.assign(a.operator, a.feature, e, n, i);
    else if (!a) {
      const s = this.current;
      if (Ww(s))
        s.value += e.toString();
      else if (typeof e == "object" && e) {
        const l = this.assignWithoutOverride(e, s);
        this.stack.pop(), this.stack.push(l);
      }
    }
  }
  action(e, r) {
    if (!this.isRecording()) {
      let n = this.current;
      if (r.feature && r.operator) {
        n = this.construct(), this.nodeBuilder.removeNode(n.$cstNode), this.nodeBuilder.buildCompositeNode(r).content.push(n.$cstNode);
        const i = { $type: e };
        this.stack.push(i), this.assign(r.operator, r.feature, n, n.$cstNode, !1);
      } else
        n.$type = e;
    }
  }
  construct() {
    if (this.isRecording())
      return;
    const e = this.current;
    return UCe(e), this.nodeBuilder.construct(e), this.stack.pop(), Ww(e) ? this.converter.convert(e.value, e.$cstNode) : (HCe(this.astReflection, e), e);
  }
  getAssignment(e) {
    if (!this.assignmentMap.has(e)) {
      const r = pb(e, cu);
      this.assignmentMap.set(e, {
        assignment: r,
        isCrossRef: r ? k3(r.terminal) : !1
      });
    }
    return this.assignmentMap.get(e);
  }
  assign(e, r, n, a, i) {
    const s = this.current;
    let o;
    switch (i && typeof n == "string" ? o = this.linker.buildReference(s, r, a, n) : o = n, e) {
      case "=": {
        s[r] = o;
        break;
      }
      case "?=": {
        s[r] = !0;
        break;
      }
      case "+=":
        Array.isArray(s[r]) || (s[r] = []), s[r].push(o);
    }
  }
  assignWithoutOverride(e, r) {
    for (const [a, i] of Object.entries(r)) {
      const s = e[a];
      s === void 0 ? e[a] = i : Array.isArray(s) && Array.isArray(i) && (i.push(...s), e[a] = i);
    }
    const n = e.$cstNode;
    return n && (n.astNode = void 0, e.$cstNode = void 0), e;
  }
  get definitionErrors() {
    return this.wrapper.definitionErrors;
  }
}
class uRe {
  buildMismatchTokenMessage(e) {
    return hc.buildMismatchTokenMessage(e);
  }
  buildNotAllInputParsedMessage(e) {
    return hc.buildNotAllInputParsedMessage(e);
  }
  buildNoViableAltMessage(e) {
    return hc.buildNoViableAltMessage(e);
  }
  buildEarlyExitMessage(e) {
    return hc.buildEarlyExitMessage(e);
  }
}
class MU extends uRe {
  buildMismatchTokenMessage({ expected: e, actual: r }) {
    return `Expecting ${e.LABEL ? "`" + e.LABEL + "`" : e.name.endsWith(":KW") ? `keyword '${e.name.substring(0, e.name.length - 3)}'` : `token of type '${e.name}'`} but found \`${r.image}\`.`;
  }
  buildNotAllInputParsedMessage({ firstRedundant: e }) {
    return `Expecting end of file but found \`${e.image}\`.`;
  }
}
class cRe extends RU {
  constructor() {
    super(...arguments), this.tokens = [], this.elementStack = [], this.lastElementStack = [], this.nextTokenIndex = 0, this.stackSize = 0;
  }
  action() {
  }
  construct() {
  }
  parse(e) {
    this.resetState();
    const r = this.lexer.tokenize(e, { mode: "partial" });
    return this.tokens = r.tokens, this.wrapper.input = [...this.tokens], this.mainRule.call(this.wrapper, {}), this.unorderedGroups.clear(), {
      tokens: this.tokens,
      elementStack: [...this.lastElementStack],
      tokenIndex: this.nextTokenIndex
    };
  }
  rule(e, r) {
    const n = this.wrapper.DEFINE_RULE(kU(e.name), this.startImplementation(r).bind(this));
    return this.allRules.set(e.name, n), e.entry && (this.mainRule = n), n;
  }
  resetState() {
    this.elementStack = [], this.lastElementStack = [], this.nextTokenIndex = 0, this.stackSize = 0;
  }
  startImplementation(e) {
    return (r) => {
      const n = this.keepStackSize();
      try {
        e(r);
      } finally {
        this.resetStackSize(n);
      }
    };
  }
  removeUnexpectedElements() {
    this.elementStack.splice(this.stackSize);
  }
  keepStackSize() {
    const e = this.elementStack.length;
    return this.stackSize = e, e;
  }
  resetStackSize(e) {
    this.removeUnexpectedElements(), this.stackSize = e;
  }
  consume(e, r, n) {
    this.wrapper.wrapConsume(e, r), this.isRecording() || (this.lastElementStack = [...this.elementStack, n], this.nextTokenIndex = this.currIdx + 1);
  }
  subrule(e, r, n, a, i) {
    this.before(a), this.wrapper.wrapSubrule(e, r, i), this.after(a);
  }
  before(e) {
    this.isRecording() || this.elementStack.push(e);
  }
  after(e) {
    if (!this.isRecording()) {
      const r = this.elementStack.lastIndexOf(e);
      r >= 0 && this.elementStack.splice(r);
    }
  }
  get currIdx() {
    return this.wrapper.currIdx;
  }
}
const fRe = {
  recoveryEnabled: !0,
  nodeLocationTracking: "full",
  skipValidations: !0,
  errorMessageProvider: new MU()
};
class hRe extends bke {
  constructor(e, r) {
    const n = r && "maxLookahead" in r;
    super(e, Object.assign(Object.assign(Object.assign({}, fRe), { lookaheadStrategy: n ? new B3({ maxLookahead: r.maxLookahead }) : new zke({
      // If validations are skipped, don't log the lookahead warnings
      logging: r.skipValidations ? () => {
      } : void 0
    }) }), r));
  }
  get IS_RECORDING() {
    return this.RECORDING_PHASE;
  }
  DEFINE_RULE(e, r) {
    return this.RULE(e, r);
  }
  wrapSelfAnalysis() {
    this.performSelfAnalysis();
  }
  wrapConsume(e, r) {
    return this.consume(e, r);
  }
  wrapSubrule(e, r, n) {
    return this.subrule(e, r, {
      ARGS: [n]
    });
  }
  wrapOr(e, r) {
    this.or(e, r);
  }
  wrapOption(e, r) {
    this.option(e, r);
  }
  wrapMany(e, r) {
    this.many(e, r);
  }
  wrapAtLeastOne(e, r) {
    this.atLeastOne(e, r);
  }
}
function _U(t, e, r) {
  return dRe({
    parser: e,
    tokens: r,
    ruleNames: /* @__PURE__ */ new Map()
  }, t), e;
}
function dRe(t, e) {
  const r = RG(e, !1), n = Fn(e.rules).filter(Si).filter((a) => r.has(a));
  for (const a of n) {
    const i = Object.assign(Object.assign({}, t), { consume: 1, optional: 1, subrule: 1, many: 1, or: 1 });
    t.parser.rule(a, pu(i, a.definition));
  }
}
function pu(t, e, r = !1) {
  let n;
  if (fu(e))
    n = xRe(t, e);
  else if (db(e))
    n = pRe(t, e);
  else if (cu(e))
    n = pu(t, e.terminal);
  else if (k3(e))
    n = LU(t, e);
  else if (hu(e))
    n = gRe(t, e);
  else if (EG(e))
    n = mRe(t, e);
  else if (TG(e))
    n = yRe(t, e);
  else if (R3(e))
    n = bRe(t, e);
  else if (ICe(e)) {
    const a = t.consume++;
    n = () => t.parser.consume(a, tl, e);
  } else
    throw new yG(e.$cstNode, `Unexpected element type: ${e.$type}`);
  return NU(t, r ? void 0 : dy(e), n, e.cardinality);
}
function pRe(t, e) {
  const r = N3(e);
  return () => t.parser.action(r, e);
}
function gRe(t, e) {
  const r = e.rule.ref;
  if (Si(r)) {
    const n = t.subrule++, a = r.fragment, i = e.arguments.length > 0 ? vRe(r, e.arguments) : () => ({});
    return (s) => t.parser.subrule(n, OU(t, r), a, e, i(s));
  } else if (Nu(r)) {
    const n = t.consume++, a = pS(t, r.name);
    return () => t.parser.consume(n, a, e);
  } else if (r)
    bp();
  else
    throw new yG(e.$cstNode, `Undefined rule: ${e.rule.$refText}`);
}
function vRe(t, e) {
  const r = e.map((n) => Gs(n.value));
  return (n) => {
    const a = {};
    for (let i = 0; i < r.length; i++) {
      const s = t.parameters[i], o = r[i];
      a[s.name] = o(n);
    }
    return a;
  };
}
function Gs(t) {
  if (RCe(t)) {
    const e = Gs(t.left), r = Gs(t.right);
    return (n) => e(n) || r(n);
  } else if (kCe(t)) {
    const e = Gs(t.left), r = Gs(t.right);
    return (n) => e(n) && r(n);
  } else if (MCe(t)) {
    const e = Gs(t.value);
    return (r) => !e(r);
  } else if (_Ce(t)) {
    const e = t.parameter.ref.name;
    return (r) => r !== void 0 && r[e] === !0;
  } else if (ACe(t)) {
    const e = !!t.true;
    return () => e;
  }
  bp();
}
function mRe(t, e) {
  if (e.elements.length === 1)
    return pu(t, e.elements[0]);
  {
    const r = [];
    for (const a of e.elements) {
      const i = {
        // Since we handle the guard condition in the alternative already
        // We can ignore the group guard condition inside
        ALT: pu(t, a, !0)
      }, s = dy(a);
      s && (i.GATE = Gs(s)), r.push(i);
    }
    const n = t.or++;
    return (a) => t.parser.alternatives(n, r.map((i) => {
      const s = {
        ALT: () => i.ALT(a)
      }, o = i.GATE;
      return o && (s.GATE = () => o(a)), s;
    }));
  }
}
function yRe(t, e) {
  if (e.elements.length === 1)
    return pu(t, e.elements[0]);
  const r = [];
  for (const o of e.elements) {
    const l = {
      // Since we handle the guard condition in the alternative already
      // We can ignore the group guard condition inside
      ALT: pu(t, o, !0)
    }, u = dy(o);
    u && (l.GATE = Gs(u)), r.push(l);
  }
  const n = t.or++, a = (o, l) => {
    const u = l.getRuleStack().join("-");
    return `uGroup_${o}_${u}`;
  }, i = (o) => t.parser.alternatives(n, r.map((l, u) => {
    const c = { ALT: () => !0 }, f = t.parser;
    c.ALT = () => {
      if (l.ALT(o), !f.isRecording()) {
        const d = a(n, f);
        f.unorderedGroups.get(d) || f.unorderedGroups.set(d, []);
        const p = f.unorderedGroups.get(d);
        typeof (p == null ? void 0 : p[u]) > "u" && (p[u] = !0);
      }
    };
    const h = l.GATE;
    return h ? c.GATE = () => h(o) : c.GATE = () => {
      const d = f.unorderedGroups.get(a(n, f));
      return !(d != null && d[u]);
    }, c;
  })), s = NU(t, dy(e), i, "*");
  return (o) => {
    s(o), t.parser.isRecording() || t.parser.unorderedGroups.delete(a(n, t.parser));
  };
}
function bRe(t, e) {
  const r = e.elements.map((n) => pu(t, n));
  return (n) => r.forEach((a) => a(n));
}
function dy(t) {
  if (R3(t))
    return t.guardCondition;
}
function LU(t, e, r = e.terminal) {
  if (r)
    if (hu(r) && Si(r.rule.ref)) {
      const n = r.rule.ref, a = t.subrule++;
      return (i) => t.parser.subrule(a, OU(t, n), !1, e, i);
    } else if (hu(r) && Nu(r.rule.ref)) {
      const n = t.consume++, a = pS(t, r.rule.ref.name);
      return () => t.parser.consume(n, a, e);
    } else if (fu(r)) {
      const n = t.consume++, a = pS(t, r.value);
      return () => t.parser.consume(n, a, e);
    } else
      throw new Error("Could not build cross reference parser");
  else {
    if (!e.type.ref)
      throw new Error("Could not resolve reference to type: " + e.type.$refText);
    const n = LG(e.type.ref), a = n == null ? void 0 : n.terminal;
    if (!a)
      throw new Error("Could not find name assignment for type: " + N3(e.type.ref));
    return LU(t, e, a);
  }
}
function xRe(t, e) {
  const r = t.consume++, n = t.tokens[e.value];
  if (!n)
    throw new Error("Could not find token for keyword: " + e.value);
  return () => t.parser.consume(r, n, e);
}
function NU(t, e, r, n) {
  const a = e && Gs(e);
  if (!n)
    if (a) {
      const i = t.or++;
      return (s) => t.parser.alternatives(i, [
        {
          ALT: () => r(s),
          GATE: () => a(s)
        },
        {
          ALT: oN(),
          GATE: () => !a(s)
        }
      ]);
    } else
      return r;
  if (n === "*") {
    const i = t.many++;
    return (s) => t.parser.many(i, {
      DEF: () => r(s),
      GATE: a ? () => a(s) : void 0
    });
  } else if (n === "+") {
    const i = t.many++;
    if (a) {
      const s = t.or++;
      return (o) => t.parser.alternatives(s, [
        {
          ALT: () => t.parser.atLeastOne(i, {
            DEF: () => r(o)
          }),
          GATE: () => a(o)
        },
        {
          ALT: oN(),
          GATE: () => !a(o)
        }
      ]);
    } else
      return (s) => t.parser.atLeastOne(i, {
        DEF: () => r(s)
      });
  } else if (n === "?") {
    const i = t.optional++;
    return (s) => t.parser.optional(i, {
      DEF: () => r(s),
      GATE: a ? () => a(s) : void 0
    });
  } else
    bp();
}
function OU(t, e) {
  const r = wRe(t, e), n = t.parser.getRule(r);
  if (!n)
    throw new Error(`Rule "${r}" not found."`);
  return n;
}
function wRe(t, e) {
  if (Si(e))
    return e.name;
  if (t.ruleNames.has(e))
    return t.ruleNames.get(e);
  {
    let r = e, n = r.$container, a = e.$type;
    for (; !Si(n); )
      (R3(n) || EG(n) || TG(n)) && (a = n.elements.indexOf(r).toString() + ":" + a), r = n, n = n.$container;
    return a = n.name + ":" + a, t.ruleNames.set(e, a), a;
  }
}
function pS(t, e) {
  const r = t.tokens[e];
  if (!r)
    throw new Error(`Token "${e}" not found."`);
  return r;
}
function ERe(t) {
  const e = t.Grammar, r = t.parser.Lexer, n = new cRe(t);
  return _U(e, n, r.definition), n.finalize(), n;
}
function TRe(t) {
  const e = SRe(t);
  return e.finalize(), e;
}
function SRe(t) {
  const e = t.Grammar, r = t.parser.Lexer, n = new lRe(t);
  return _U(e, n, r.definition);
}
class IU {
  constructor() {
    this.diagnostics = [];
  }
  buildTokens(e, r) {
    const n = Fn(RG(e, !1)), a = this.buildTerminalTokens(n), i = this.buildKeywordTokens(n, a, r);
    return a.forEach((s) => {
      const o = s.PATTERN;
      typeof o == "object" && o && "test" in o && G4(o) ? i.unshift(s) : i.push(s);
    }), i;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  flushLexingReport(e) {
    return { diagnostics: this.popDiagnostics() };
  }
  popDiagnostics() {
    const e = [...this.diagnostics];
    return this.diagnostics = [], e;
  }
  buildTerminalTokens(e) {
    return e.filter(Nu).filter((r) => !r.fragment).map((r) => this.buildTerminalToken(r)).toArray();
  }
  buildTerminalToken(e) {
    const r = O3(e), n = this.requiresCustomPattern(r) ? this.regexPatternFunction(r) : r, a = {
      name: e.name,
      PATTERN: n
    };
    return typeof n == "function" && (a.LINE_BREAKS = !0), e.hidden && (a.GROUP = G4(r) ? ka.SKIPPED : "hidden"), a;
  }
  requiresCustomPattern(e) {
    return e.flags.includes("u") || e.flags.includes("s") ? !0 : !!(e.source.includes("?<=") || e.source.includes("?<!"));
  }
  regexPatternFunction(e) {
    const r = new RegExp(e, e.flags + "y");
    return (n, a) => (r.lastIndex = a, r.exec(n));
  }
  buildKeywordTokens(e, r, n) {
    return e.filter(Si).flatMap((a) => xp(a).filter(fu)).distinct((a) => a.value).toArray().sort((a, i) => i.value.length - a.value.length).map((a) => this.buildKeywordToken(a, r, !!(n != null && n.caseInsensitive)));
  }
  buildKeywordToken(e, r, n) {
    const a = this.buildKeywordPattern(e, n), i = {
      name: e.value,
      PATTERN: a,
      LONGER_ALT: this.findLongerAlt(e, r)
    };
    return typeof a == "function" && (i.LINE_BREAKS = !0), i;
  }
  buildKeywordPattern(e, r) {
    return r ? new RegExp(QCe(e.value)) : e.value;
  }
  findLongerAlt(e, r) {
    return r.reduce((n, a) => {
      const i = a == null ? void 0 : a.PATTERN;
      return i != null && i.source && JCe("^" + i.source + "$", e.value) && n.push(a), n;
    }, []);
  }
}
class PU {
  convert(e, r) {
    let n = r.grammarSource;
    if (k3(n) && (n = n3e(n)), hu(n)) {
      const a = n.rule.ref;
      if (!a)
        throw new Error("This cst node was not parsed by a rule.");
      return this.runConverter(a, e, r);
    }
    return e;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  runConverter(e, r, n) {
    var a;
    switch (e.name.toUpperCase()) {
      case "INT":
        return Ds.convertInt(r);
      case "STRING":
        return Ds.convertString(r);
      case "ID":
        return Ds.convertID(r);
    }
    switch ((a = c3e(e)) === null || a === void 0 ? void 0 : a.toLowerCase()) {
      case "number":
        return Ds.convertNumber(r);
      case "boolean":
        return Ds.convertBoolean(r);
      case "bigint":
        return Ds.convertBigint(r);
      case "date":
        return Ds.convertDate(r);
      default:
        return r;
    }
  }
}
var Ds;
(function(t) {
  function e(u) {
    let c = "";
    for (let f = 1; f < u.length - 1; f++) {
      const h = u.charAt(f);
      if (h === "\\") {
        const d = u.charAt(++f);
        c += r(d);
      } else
        c += h;
    }
    return c;
  }
  t.convertString = e;
  function r(u) {
    switch (u) {
      case "b":
        return "\b";
      case "f":
        return "\f";
      case "n":
        return `
`;
      case "r":
        return "\r";
      case "t":
        return "	";
      case "v":
        return "\v";
      case "0":
        return "\0";
      default:
        return u;
    }
  }
  function n(u) {
    return u.charAt(0) === "^" ? u.substring(1) : u;
  }
  t.convertID = n;
  function a(u) {
    return parseInt(u);
  }
  t.convertInt = a;
  function i(u) {
    return BigInt(u);
  }
  t.convertBigint = i;
  function s(u) {
    return new Date(u);
  }
  t.convertDate = s;
  function o(u) {
    return Number(u);
  }
  t.convertNumber = o;
  function l(u) {
    return u.toLowerCase() === "true";
  }
  t.convertBoolean = l;
})(Ds || (Ds = {}));
var y0 = {}, Sb = {};
Object.defineProperty(Sb, "__esModule", { value: !0 });
let gS;
function vS() {
  if (gS === void 0)
    throw new Error("No runtime abstraction layer installed");
  return gS;
}
(function(t) {
  function e(r) {
    if (r === void 0)
      throw new Error("No runtime abstraction layer provided");
    gS = r;
  }
  t.install = e;
})(vS || (vS = {}));
Sb.default = vS;
var Zn = {};
Object.defineProperty(Zn, "__esModule", { value: !0 });
Zn.stringArray = Zn.array = Zn.func = Zn.error = Zn.number = Zn.string = Zn.boolean = void 0;
function CRe(t) {
  return t === !0 || t === !1;
}
Zn.boolean = CRe;
function DU(t) {
  return typeof t == "string" || t instanceof String;
}
Zn.string = DU;
function ARe(t) {
  return typeof t == "number" || t instanceof Number;
}
Zn.number = ARe;
function kRe(t) {
  return t instanceof Error;
}
Zn.error = kRe;
function RRe(t) {
  return typeof t == "function";
}
Zn.func = RRe;
function $U(t) {
  return Array.isArray(t);
}
Zn.array = $U;
function MRe(t) {
  return $U(t) && t.every((e) => DU(e));
}
Zn.stringArray = MRe;
var yf = {};
Object.defineProperty(yf, "__esModule", { value: !0 });
var FU = yf.Emitter = yf.Event = void 0;
const _Re = Sb;
var d8;
(function(t) {
  const e = { dispose() {
  } };
  t.None = function() {
    return e;
  };
})(d8 || (yf.Event = d8 = {}));
class LRe {
  add(e, r = null, n) {
    this._callbacks || (this._callbacks = [], this._contexts = []), this._callbacks.push(e), this._contexts.push(r), Array.isArray(n) && n.push({ dispose: () => this.remove(e, r) });
  }
  remove(e, r = null) {
    if (!this._callbacks)
      return;
    let n = !1;
    for (let a = 0, i = this._callbacks.length; a < i; a++)
      if (this._callbacks[a] === e)
        if (this._contexts[a] === r) {
          this._callbacks.splice(a, 1), this._contexts.splice(a, 1);
          return;
        } else
          n = !0;
    if (n)
      throw new Error("When adding a listener with a context, you should remove it with the same context");
  }
  invoke(...e) {
    if (!this._callbacks)
      return [];
    const r = [], n = this._callbacks.slice(0), a = this._contexts.slice(0);
    for (let i = 0, s = n.length; i < s; i++)
      try {
        r.push(n[i].apply(a[i], e));
      } catch (o) {
        (0, _Re.default)().console.error(o);
      }
    return r;
  }
  isEmpty() {
    return !this._callbacks || this._callbacks.length === 0;
  }
  dispose() {
    this._callbacks = void 0, this._contexts = void 0;
  }
}
class Cb {
  constructor(e) {
    this._options = e;
  }
  /**
   * For the public to allow to subscribe
   * to events from this Emitter
   */
  get event() {
    return this._event || (this._event = (e, r, n) => {
      this._callbacks || (this._callbacks = new LRe()), this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty() && this._options.onFirstListenerAdd(this), this._callbacks.add(e, r);
      const a = {
        dispose: () => {
          this._callbacks && (this._callbacks.remove(e, r), a.dispose = Cb._noop, this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty() && this._options.onLastListenerRemove(this));
        }
      };
      return Array.isArray(n) && n.push(a), a;
    }), this._event;
  }
  /**
   * To be kept private to fire an event to
   * subscribers
   */
  fire(e) {
    this._callbacks && this._callbacks.invoke.call(this._callbacks, e);
  }
  dispose() {
    this._callbacks && (this._callbacks.dispose(), this._callbacks = void 0);
  }
}
FU = yf.Emitter = Cb;
Cb._noop = function() {
};
var Vr;
Object.defineProperty(y0, "__esModule", { value: !0 });
var j3 = y0.CancellationTokenSource = Vr = y0.CancellationToken = void 0;
const NRe = Sb, ORe = Zn, mS = yf;
var py;
(function(t) {
  t.None = Object.freeze({
    isCancellationRequested: !1,
    onCancellationRequested: mS.Event.None
  }), t.Cancelled = Object.freeze({
    isCancellationRequested: !0,
    onCancellationRequested: mS.Event.None
  });
  function e(r) {
    const n = r;
    return n && (n === t.None || n === t.Cancelled || ORe.boolean(n.isCancellationRequested) && !!n.onCancellationRequested);
  }
  t.is = e;
})(py || (Vr = y0.CancellationToken = py = {}));
const IRe = Object.freeze(function(t, e) {
  const r = (0, NRe.default)().timer.setTimeout(t.bind(e), 0);
  return { dispose() {
    r.dispose();
  } };
});
class p8 {
  constructor() {
    this._isCancelled = !1;
  }
  cancel() {
    this._isCancelled || (this._isCancelled = !0, this._emitter && (this._emitter.fire(void 0), this.dispose()));
  }
  get isCancellationRequested() {
    return this._isCancelled;
  }
  get onCancellationRequested() {
    return this._isCancelled ? IRe : (this._emitter || (this._emitter = new mS.Emitter()), this._emitter.event);
  }
  dispose() {
    this._emitter && (this._emitter.dispose(), this._emitter = void 0);
  }
}
class PRe {
  get token() {
    return this._token || (this._token = new p8()), this._token;
  }
  cancel() {
    this._token ? this._token.cancel() : this._token = py.Cancelled;
  }
  dispose() {
    this._token ? this._token instanceof p8 && this._token.dispose() : this._token = py.None;
  }
}
j3 = y0.CancellationTokenSource = PRe;
function DRe() {
  return new Promise((t) => {
    typeof setImmediate > "u" ? setTimeout(t, 0) : setImmediate(t);
  });
}
let Nv = 0, $Re = 10;
function FRe() {
  return Nv = performance.now(), new j3();
}
const gy = Symbol("OperationCancelled");
function Ab(t) {
  return t === gy;
}
async function Qa(t) {
  if (t === Vr.None)
    return;
  const e = performance.now();
  if (e - Nv >= $Re && (Nv = e, await DRe(), Nv = performance.now()), t.isCancellationRequested)
    throw gy;
}
class Y3 {
  constructor() {
    this.promise = new Promise((e, r) => {
      this.resolve = (n) => (e(n), this), this.reject = (n) => (r(n), this);
    });
  }
}
class b0 {
  constructor(e, r, n, a) {
    this._uri = e, this._languageId = r, this._version = n, this._content = a, this._lineOffsets = void 0;
  }
  get uri() {
    return this._uri;
  }
  get languageId() {
    return this._languageId;
  }
  get version() {
    return this._version;
  }
  getText(e) {
    if (e) {
      const r = this.offsetAt(e.start), n = this.offsetAt(e.end);
      return this._content.substring(r, n);
    }
    return this._content;
  }
  update(e, r) {
    for (const n of e)
      if (b0.isIncremental(n)) {
        const a = zU(n.range), i = this.offsetAt(a.start), s = this.offsetAt(a.end);
        this._content = this._content.substring(0, i) + n.text + this._content.substring(s, this._content.length);
        const o = Math.max(a.start.line, 0), l = Math.max(a.end.line, 0);
        let u = this._lineOffsets;
        const c = g8(n.text, !1, i);
        if (l - o === c.length)
          for (let h = 0, d = c.length; h < d; h++)
            u[h + o + 1] = c[h];
        else
          c.length < 1e4 ? u.splice(o + 1, l - o, ...c) : this._lineOffsets = u = u.slice(0, o + 1).concat(c, u.slice(l + 1));
        const f = n.text.length - (s - i);
        if (f !== 0)
          for (let h = o + 1 + c.length, d = u.length; h < d; h++)
            u[h] = u[h] + f;
      } else if (b0.isFull(n))
        this._content = n.text, this._lineOffsets = void 0;
      else
        throw new Error("Unknown change event received");
    this._version = r;
  }
  getLineOffsets() {
    return this._lineOffsets === void 0 && (this._lineOffsets = g8(this._content, !0)), this._lineOffsets;
  }
  positionAt(e) {
    e = Math.max(Math.min(e, this._content.length), 0);
    const r = this.getLineOffsets();
    let n = 0, a = r.length;
    if (a === 0)
      return { line: 0, character: e };
    for (; n < a; ) {
      const s = Math.floor((n + a) / 2);
      r[s] > e ? a = s : n = s + 1;
    }
    const i = n - 1;
    return e = this.ensureBeforeEOL(e, r[i]), { line: i, character: e - r[i] };
  }
  offsetAt(e) {
    const r = this.getLineOffsets();
    if (e.line >= r.length)
      return this._content.length;
    if (e.line < 0)
      return 0;
    const n = r[e.line];
    if (e.character <= 0)
      return n;
    const a = e.line + 1 < r.length ? r[e.line + 1] : this._content.length, i = Math.min(n + e.character, a);
    return this.ensureBeforeEOL(i, n);
  }
  ensureBeforeEOL(e, r) {
    for (; e > r && BU(this._content.charCodeAt(e - 1)); )
      e--;
    return e;
  }
  get lineCount() {
    return this.getLineOffsets().length;
  }
  static isIncremental(e) {
    const r = e;
    return r != null && typeof r.text == "string" && r.range !== void 0 && (r.rangeLength === void 0 || typeof r.rangeLength == "number");
  }
  static isFull(e) {
    const r = e;
    return r != null && typeof r.text == "string" && r.range === void 0 && r.rangeLength === void 0;
  }
}
var yS;
(function(t) {
  function e(a, i, s, o) {
    return new b0(a, i, s, o);
  }
  t.create = e;
  function r(a, i, s) {
    if (a instanceof b0)
      return a.update(i, s), a;
    throw new Error("TextDocument.update: document must be created by TextDocument.create");
  }
  t.update = r;
  function n(a, i) {
    const s = a.getText(), o = bS(i.map(BRe), (c, f) => {
      const h = c.range.start.line - f.range.start.line;
      return h === 0 ? c.range.start.character - f.range.start.character : h;
    });
    let l = 0;
    const u = [];
    for (const c of o) {
      const f = a.offsetAt(c.range.start);
      if (f < l)
        throw new Error("Overlapping edit");
      f > l && u.push(s.substring(l, f)), c.newText.length && u.push(c.newText), l = a.offsetAt(c.range.end);
    }
    return u.push(s.substr(l)), u.join("");
  }
  t.applyEdits = n;
})(yS || (yS = {}));
function bS(t, e) {
  if (t.length <= 1)
    return t;
  const r = t.length / 2 | 0, n = t.slice(0, r), a = t.slice(r);
  bS(n, e), bS(a, e);
  let i = 0, s = 0, o = 0;
  for (; i < n.length && s < a.length; )
    e(n[i], a[s]) <= 0 ? t[o++] = n[i++] : t[o++] = a[s++];
  for (; i < n.length; )
    t[o++] = n[i++];
  for (; s < a.length; )
    t[o++] = a[s++];
  return t;
}
function g8(t, e, r = 0) {
  const n = e ? [r] : [];
  for (let a = 0; a < t.length; a++) {
    const i = t.charCodeAt(a);
    BU(i) && (i === 13 && a + 1 < t.length && t.charCodeAt(a + 1) === 10 && a++, n.push(r + a + 1));
  }
  return n;
}
function BU(t) {
  return t === 13 || t === 10;
}
function zU(t) {
  const e = t.start, r = t.end;
  return e.line > r.line || e.line === r.line && e.character > r.character ? { start: r, end: e } : t;
}
function BRe(t) {
  const e = zU(t.range);
  return e !== t.range ? { newText: t.newText, range: e } : t;
}
var GU;
(() => {
  var t = { 470: (a) => {
    function i(l) {
      if (typeof l != "string") throw new TypeError("Path must be a string. Received " + JSON.stringify(l));
    }
    function s(l, u) {
      for (var c, f = "", h = 0, d = -1, p = 0, g = 0; g <= l.length; ++g) {
        if (g < l.length) c = l.charCodeAt(g);
        else {
          if (c === 47) break;
          c = 47;
        }
        if (c === 47) {
          if (!(d === g - 1 || p === 1)) if (d !== g - 1 && p === 2) {
            if (f.length < 2 || h !== 2 || f.charCodeAt(f.length - 1) !== 46 || f.charCodeAt(f.length - 2) !== 46) {
              if (f.length > 2) {
                var v = f.lastIndexOf("/");
                if (v !== f.length - 1) {
                  v === -1 ? (f = "", h = 0) : h = (f = f.slice(0, v)).length - 1 - f.lastIndexOf("/"), d = g, p = 0;
                  continue;
                }
              } else if (f.length === 2 || f.length === 1) {
                f = "", h = 0, d = g, p = 0;
                continue;
              }
            }
            u && (f.length > 0 ? f += "/.." : f = "..", h = 2);
          } else f.length > 0 ? f += "/" + l.slice(d + 1, g) : f = l.slice(d + 1, g), h = g - d - 1;
          d = g, p = 0;
        } else c === 46 && p !== -1 ? ++p : p = -1;
      }
      return f;
    }
    var o = { resolve: function() {
      for (var l, u = "", c = !1, f = arguments.length - 1; f >= -1 && !c; f--) {
        var h;
        f >= 0 ? h = arguments[f] : (l === void 0 && (l = process.cwd()), h = l), i(h), h.length !== 0 && (u = h + "/" + u, c = h.charCodeAt(0) === 47);
      }
      return u = s(u, !c), c ? u.length > 0 ? "/" + u : "/" : u.length > 0 ? u : ".";
    }, normalize: function(l) {
      if (i(l), l.length === 0) return ".";
      var u = l.charCodeAt(0) === 47, c = l.charCodeAt(l.length - 1) === 47;
      return (l = s(l, !u)).length !== 0 || u || (l = "."), l.length > 0 && c && (l += "/"), u ? "/" + l : l;
    }, isAbsolute: function(l) {
      return i(l), l.length > 0 && l.charCodeAt(0) === 47;
    }, join: function() {
      if (arguments.length === 0) return ".";
      for (var l, u = 0; u < arguments.length; ++u) {
        var c = arguments[u];
        i(c), c.length > 0 && (l === void 0 ? l = c : l += "/" + c);
      }
      return l === void 0 ? "." : o.normalize(l);
    }, relative: function(l, u) {
      if (i(l), i(u), l === u || (l = o.resolve(l)) === (u = o.resolve(u))) return "";
      for (var c = 1; c < l.length && l.charCodeAt(c) === 47; ++c) ;
      for (var f = l.length, h = f - c, d = 1; d < u.length && u.charCodeAt(d) === 47; ++d) ;
      for (var p = u.length - d, g = h < p ? h : p, v = -1, m = 0; m <= g; ++m) {
        if (m === g) {
          if (p > g) {
            if (u.charCodeAt(d + m) === 47) return u.slice(d + m + 1);
            if (m === 0) return u.slice(d + m);
          } else h > g && (l.charCodeAt(c + m) === 47 ? v = m : m === 0 && (v = 0));
          break;
        }
        var b = l.charCodeAt(c + m);
        if (b !== u.charCodeAt(d + m)) break;
        b === 47 && (v = m);
      }
      var y = "";
      for (m = c + v + 1; m <= f; ++m) m !== f && l.charCodeAt(m) !== 47 || (y.length === 0 ? y += ".." : y += "/..");
      return y.length > 0 ? y + u.slice(d + v) : (d += v, u.charCodeAt(d) === 47 && ++d, u.slice(d));
    }, _makeLong: function(l) {
      return l;
    }, dirname: function(l) {
      if (i(l), l.length === 0) return ".";
      for (var u = l.charCodeAt(0), c = u === 47, f = -1, h = !0, d = l.length - 1; d >= 1; --d) if ((u = l.charCodeAt(d)) === 47) {
        if (!h) {
          f = d;
          break;
        }
      } else h = !1;
      return f === -1 ? c ? "/" : "." : c && f === 1 ? "//" : l.slice(0, f);
    }, basename: function(l, u) {
      if (u !== void 0 && typeof u != "string") throw new TypeError('"ext" argument must be a string');
      i(l);
      var c, f = 0, h = -1, d = !0;
      if (u !== void 0 && u.length > 0 && u.length <= l.length) {
        if (u.length === l.length && u === l) return "";
        var p = u.length - 1, g = -1;
        for (c = l.length - 1; c >= 0; --c) {
          var v = l.charCodeAt(c);
          if (v === 47) {
            if (!d) {
              f = c + 1;
              break;
            }
          } else g === -1 && (d = !1, g = c + 1), p >= 0 && (v === u.charCodeAt(p) ? --p == -1 && (h = c) : (p = -1, h = g));
        }
        return f === h ? h = g : h === -1 && (h = l.length), l.slice(f, h);
      }
      for (c = l.length - 1; c >= 0; --c) if (l.charCodeAt(c) === 47) {
        if (!d) {
          f = c + 1;
          break;
        }
      } else h === -1 && (d = !1, h = c + 1);
      return h === -1 ? "" : l.slice(f, h);
    }, extname: function(l) {
      i(l);
      for (var u = -1, c = 0, f = -1, h = !0, d = 0, p = l.length - 1; p >= 0; --p) {
        var g = l.charCodeAt(p);
        if (g !== 47) f === -1 && (h = !1, f = p + 1), g === 46 ? u === -1 ? u = p : d !== 1 && (d = 1) : u !== -1 && (d = -1);
        else if (!h) {
          c = p + 1;
          break;
        }
      }
      return u === -1 || f === -1 || d === 0 || d === 1 && u === f - 1 && u === c + 1 ? "" : l.slice(u, f);
    }, format: function(l) {
      if (l === null || typeof l != "object") throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof l);
      return function(u, c) {
        var f = c.dir || c.root, h = c.base || (c.name || "") + (c.ext || "");
        return f ? f === c.root ? f + h : f + "/" + h : h;
      }(0, l);
    }, parse: function(l) {
      i(l);
      var u = { root: "", dir: "", base: "", ext: "", name: "" };
      if (l.length === 0) return u;
      var c, f = l.charCodeAt(0), h = f === 47;
      h ? (u.root = "/", c = 1) : c = 0;
      for (var d = -1, p = 0, g = -1, v = !0, m = l.length - 1, b = 0; m >= c; --m) if ((f = l.charCodeAt(m)) !== 47) g === -1 && (v = !1, g = m + 1), f === 46 ? d === -1 ? d = m : b !== 1 && (b = 1) : d !== -1 && (b = -1);
      else if (!v) {
        p = m + 1;
        break;
      }
      return d === -1 || g === -1 || b === 0 || b === 1 && d === g - 1 && d === p + 1 ? g !== -1 && (u.base = u.name = p === 0 && h ? l.slice(1, g) : l.slice(p, g)) : (p === 0 && h ? (u.name = l.slice(1, d), u.base = l.slice(1, g)) : (u.name = l.slice(p, d), u.base = l.slice(p, g)), u.ext = l.slice(d, g)), p > 0 ? u.dir = l.slice(0, p - 1) : h && (u.dir = "/"), u;
    }, sep: "/", delimiter: ":", win32: null, posix: null };
    o.posix = o, a.exports = o;
  } }, e = {};
  function r(a) {
    var i = e[a];
    if (i !== void 0) return i.exports;
    var s = e[a] = { exports: {} };
    return t[a](s, s.exports, r), s.exports;
  }
  r.d = (a, i) => {
    for (var s in i) r.o(i, s) && !r.o(a, s) && Object.defineProperty(a, s, { enumerable: !0, get: i[s] });
  }, r.o = (a, i) => Object.prototype.hasOwnProperty.call(a, i), r.r = (a) => {
    typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(a, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(a, "__esModule", { value: !0 });
  };
  var n = {};
  (() => {
    let a;
    r.r(n), r.d(n, { URI: () => h, Utils: () => N }), typeof process == "object" ? a = process.platform === "win32" : typeof navigator == "object" && (a = navigator.userAgent.indexOf("Windows") >= 0);
    const i = /^\w[\w\d+.-]*$/, s = /^\//, o = /^\/\//;
    function l(R, _) {
      if (!R.scheme && _) throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${R.authority}", path: "${R.path}", query: "${R.query}", fragment: "${R.fragment}"}`);
      if (R.scheme && !i.test(R.scheme)) throw new Error("[UriError]: Scheme contains illegal characters.");
      if (R.path) {
        if (R.authority) {
          if (!s.test(R.path)) throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
        } else if (o.test(R.path)) throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
      }
    }
    const u = "", c = "/", f = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
    class h {
      constructor(_, O, T, L, M, A = !1) {
        Ye(this, "scheme");
        Ye(this, "authority");
        Ye(this, "path");
        Ye(this, "query");
        Ye(this, "fragment");
        typeof _ == "object" ? (this.scheme = _.scheme || u, this.authority = _.authority || u, this.path = _.path || u, this.query = _.query || u, this.fragment = _.fragment || u) : (this.scheme = /* @__PURE__ */ function(I, D) {
          return I || D ? I : "file";
        }(_, A), this.authority = O || u, this.path = function(I, D) {
          switch (I) {
            case "https":
            case "http":
            case "file":
              D ? D[0] !== c && (D = c + D) : D = c;
          }
          return D;
        }(this.scheme, T || u), this.query = L || u, this.fragment = M || u, l(this, A));
      }
      static isUri(_) {
        return _ instanceof h || !!_ && typeof _.authority == "string" && typeof _.fragment == "string" && typeof _.path == "string" && typeof _.query == "string" && typeof _.scheme == "string" && typeof _.fsPath == "string" && typeof _.with == "function" && typeof _.toString == "function";
      }
      get fsPath() {
        return b(this);
      }
      with(_) {
        if (!_) return this;
        let { scheme: O, authority: T, path: L, query: M, fragment: A } = _;
        return O === void 0 ? O = this.scheme : O === null && (O = u), T === void 0 ? T = this.authority : T === null && (T = u), L === void 0 ? L = this.path : L === null && (L = u), M === void 0 ? M = this.query : M === null && (M = u), A === void 0 ? A = this.fragment : A === null && (A = u), O === this.scheme && T === this.authority && L === this.path && M === this.query && A === this.fragment ? this : new p(O, T, L, M, A);
      }
      static parse(_, O = !1) {
        const T = f.exec(_);
        return T ? new p(T[2] || u, S(T[4] || u), S(T[5] || u), S(T[7] || u), S(T[9] || u), O) : new p(u, u, u, u, u);
      }
      static file(_) {
        let O = u;
        if (a && (_ = _.replace(/\\/g, c)), _[0] === c && _[1] === c) {
          const T = _.indexOf(c, 2);
          T === -1 ? (O = _.substring(2), _ = c) : (O = _.substring(2, T), _ = _.substring(T) || c);
        }
        return new p("file", O, _, u, u);
      }
      static from(_) {
        const O = new p(_.scheme, _.authority, _.path, _.query, _.fragment);
        return l(O, !0), O;
      }
      toString(_ = !1) {
        return y(this, _);
      }
      toJSON() {
        return this;
      }
      static revive(_) {
        if (_) {
          if (_ instanceof h) return _;
          {
            const O = new p(_);
            return O._formatted = _.external, O._fsPath = _._sep === d ? _.fsPath : null, O;
          }
        }
        return _;
      }
    }
    const d = a ? 1 : void 0;
    class p extends h {
      constructor() {
        super(...arguments);
        Ye(this, "_formatted", null);
        Ye(this, "_fsPath", null);
      }
      get fsPath() {
        return this._fsPath || (this._fsPath = b(this)), this._fsPath;
      }
      toString(O = !1) {
        return O ? y(this, !0) : (this._formatted || (this._formatted = y(this, !1)), this._formatted);
      }
      toJSON() {
        const O = { $mid: 1 };
        return this._fsPath && (O.fsPath = this._fsPath, O._sep = d), this._formatted && (O.external = this._formatted), this.path && (O.path = this.path), this.scheme && (O.scheme = this.scheme), this.authority && (O.authority = this.authority), this.query && (O.query = this.query), this.fragment && (O.fragment = this.fragment), O;
      }
    }
    const g = { 58: "%3A", 47: "%2F", 63: "%3F", 35: "%23", 91: "%5B", 93: "%5D", 64: "%40", 33: "%21", 36: "%24", 38: "%26", 39: "%27", 40: "%28", 41: "%29", 42: "%2A", 43: "%2B", 44: "%2C", 59: "%3B", 61: "%3D", 32: "%20" };
    function v(R, _, O) {
      let T, L = -1;
      for (let M = 0; M < R.length; M++) {
        const A = R.charCodeAt(M);
        if (A >= 97 && A <= 122 || A >= 65 && A <= 90 || A >= 48 && A <= 57 || A === 45 || A === 46 || A === 95 || A === 126 || _ && A === 47 || O && A === 91 || O && A === 93 || O && A === 58) L !== -1 && (T += encodeURIComponent(R.substring(L, M)), L = -1), T !== void 0 && (T += R.charAt(M));
        else {
          T === void 0 && (T = R.substr(0, M));
          const I = g[A];
          I !== void 0 ? (L !== -1 && (T += encodeURIComponent(R.substring(L, M)), L = -1), T += I) : L === -1 && (L = M);
        }
      }
      return L !== -1 && (T += encodeURIComponent(R.substring(L))), T !== void 0 ? T : R;
    }
    function m(R) {
      let _;
      for (let O = 0; O < R.length; O++) {
        const T = R.charCodeAt(O);
        T === 35 || T === 63 ? (_ === void 0 && (_ = R.substr(0, O)), _ += g[T]) : _ !== void 0 && (_ += R[O]);
      }
      return _ !== void 0 ? _ : R;
    }
    function b(R, _) {
      let O;
      return O = R.authority && R.path.length > 1 && R.scheme === "file" ? `//${R.authority}${R.path}` : R.path.charCodeAt(0) === 47 && (R.path.charCodeAt(1) >= 65 && R.path.charCodeAt(1) <= 90 || R.path.charCodeAt(1) >= 97 && R.path.charCodeAt(1) <= 122) && R.path.charCodeAt(2) === 58 ? R.path[1].toLowerCase() + R.path.substr(2) : R.path, a && (O = O.replace(/\//g, "\\")), O;
    }
    function y(R, _) {
      const O = _ ? m : v;
      let T = "", { scheme: L, authority: M, path: A, query: I, fragment: D } = R;
      if (L && (T += L, T += ":"), (M || L === "file") && (T += c, T += c), M) {
        let F = M.indexOf("@");
        if (F !== -1) {
          const B = M.substr(0, F);
          M = M.substr(F + 1), F = B.lastIndexOf(":"), F === -1 ? T += O(B, !1, !1) : (T += O(B.substr(0, F), !1, !1), T += ":", T += O(B.substr(F + 1), !1, !0)), T += "@";
        }
        M = M.toLowerCase(), F = M.lastIndexOf(":"), F === -1 ? T += O(M, !1, !0) : (T += O(M.substr(0, F), !1, !0), T += M.substr(F));
      }
      if (A) {
        if (A.length >= 3 && A.charCodeAt(0) === 47 && A.charCodeAt(2) === 58) {
          const F = A.charCodeAt(1);
          F >= 65 && F <= 90 && (A = `/${String.fromCharCode(F + 32)}:${A.substr(3)}`);
        } else if (A.length >= 2 && A.charCodeAt(1) === 58) {
          const F = A.charCodeAt(0);
          F >= 65 && F <= 90 && (A = `${String.fromCharCode(F + 32)}:${A.substr(2)}`);
        }
        T += O(A, !0, !1);
      }
      return I && (T += "?", T += O(I, !1, !1)), D && (T += "#", T += _ ? D : v(D, !1, !1)), T;
    }
    function x(R) {
      try {
        return decodeURIComponent(R);
      } catch {
        return R.length > 3 ? R.substr(0, 3) + x(R.substr(3)) : R;
      }
    }
    const E = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
    function S(R) {
      return R.match(E) ? R.replace(E, (_) => x(_)) : R;
    }
    var w = r(470);
    const C = w.posix || w, k = "/";
    var N;
    (function(R) {
      R.joinPath = function(_, ...O) {
        return _.with({ path: C.join(_.path, ...O) });
      }, R.resolvePath = function(_, ...O) {
        let T = _.path, L = !1;
        T[0] !== k && (T = k + T, L = !0);
        let M = C.resolve(T, ...O);
        return L && M[0] === k && !_.authority && (M = M.substring(1)), _.with({ path: M });
      }, R.dirname = function(_) {
        if (_.path.length === 0 || _.path === k) return _;
        let O = C.dirname(_.path);
        return O.length === 1 && O.charCodeAt(0) === 46 && (O = ""), _.with({ path: O });
      }, R.basename = function(_) {
        return C.basename(_.path);
      }, R.extname = function(_) {
        return C.extname(_.path);
      };
    })(N || (N = {}));
  })(), GU = n;
})();
const { URI: gu, Utils: bh } = GU;
var nl;
(function(t) {
  t.basename = bh.basename, t.dirname = bh.dirname, t.extname = bh.extname, t.joinPath = bh.joinPath, t.resolvePath = bh.resolvePath;
  function e(a, i) {
    return (a == null ? void 0 : a.toString()) === (i == null ? void 0 : i.toString());
  }
  t.equals = e;
  function r(a, i) {
    const s = typeof a == "string" ? a : a.path, o = typeof i == "string" ? i : i.path, l = s.split("/").filter((d) => d.length > 0), u = o.split("/").filter((d) => d.length > 0);
    let c = 0;
    for (; c < l.length && l[c] === u[c]; c++)
      ;
    const f = "../".repeat(l.length - c), h = u.slice(c).join("/");
    return f + h;
  }
  t.relative = r;
  function n(a) {
    return gu.parse(a.toString()).toString();
  }
  t.normalize = n;
})(nl || (nl = {}));
var Dr;
(function(t) {
  t[t.Changed = 0] = "Changed", t[t.Parsed = 1] = "Parsed", t[t.IndexedContent = 2] = "IndexedContent", t[t.ComputedScopes = 3] = "ComputedScopes", t[t.Linked = 4] = "Linked", t[t.IndexedReferences = 5] = "IndexedReferences", t[t.Validated = 6] = "Validated";
})(Dr || (Dr = {}));
class zRe {
  constructor(e) {
    this.serviceRegistry = e.ServiceRegistry, this.textDocuments = e.workspace.TextDocuments, this.fileSystemProvider = e.workspace.FileSystemProvider;
  }
  async fromUri(e, r = Vr.None) {
    const n = await this.fileSystemProvider.readFile(e);
    return this.createAsync(e, n, r);
  }
  fromTextDocument(e, r, n) {
    return r = r ?? gu.parse(e.uri), Vr.is(n) ? this.createAsync(r, e, n) : this.create(r, e, n);
  }
  fromString(e, r, n) {
    return Vr.is(n) ? this.createAsync(r, e, n) : this.create(r, e, n);
  }
  fromModel(e, r) {
    return this.create(r, { $model: e });
  }
  create(e, r, n) {
    if (typeof r == "string") {
      const a = this.parse(e, r, n);
      return this.createLangiumDocument(a, e, void 0, r);
    } else if ("$model" in r) {
      const a = { value: r.$model, parserErrors: [], lexerErrors: [] };
      return this.createLangiumDocument(a, e);
    } else {
      const a = this.parse(e, r.getText(), n);
      return this.createLangiumDocument(a, e, r);
    }
  }
  async createAsync(e, r, n) {
    if (typeof r == "string") {
      const a = await this.parseAsync(e, r, n);
      return this.createLangiumDocument(a, e, void 0, r);
    } else {
      const a = await this.parseAsync(e, r.getText(), n);
      return this.createLangiumDocument(a, e, r);
    }
  }
  /**
   * Create a LangiumDocument from a given parse result.
   *
   * A TextDocument is created on demand if it is not provided as argument here. Usually this
   * should not be necessary because the main purpose of the TextDocument is to convert between
   * text ranges and offsets, which is done solely in LSP request handling.
   *
   * With the introduction of {@link update} below this method is supposed to be mainly called
   * during workspace initialization and on addition/recognition of new files, while changes in
   * existing documents are processed via {@link update}.
   */
  createLangiumDocument(e, r, n, a) {
    let i;
    if (n)
      i = {
        parseResult: e,
        uri: r,
        state: Dr.Parsed,
        references: [],
        textDocument: n
      };
    else {
      const s = this.createTextDocumentGetter(r, a);
      i = {
        parseResult: e,
        uri: r,
        state: Dr.Parsed,
        references: [],
        get textDocument() {
          return s();
        }
      };
    }
    return e.value.$document = i, i;
  }
  async update(e, r) {
    var n, a;
    const i = (n = e.parseResult.value.$cstNode) === null || n === void 0 ? void 0 : n.root.fullText, s = (a = this.textDocuments) === null || a === void 0 ? void 0 : a.get(e.uri.toString()), o = s ? s.getText() : await this.fileSystemProvider.readFile(e.uri);
    if (s)
      Object.defineProperty(e, "textDocument", {
        value: s
      });
    else {
      const l = this.createTextDocumentGetter(e.uri, o);
      Object.defineProperty(e, "textDocument", {
        get: l
      });
    }
    return i !== o && (e.parseResult = await this.parseAsync(e.uri, o, r), e.parseResult.value.$document = e), e.state = Dr.Parsed, e;
  }
  parse(e, r, n) {
    return this.serviceRegistry.getServices(e).parser.LangiumParser.parse(r, n);
  }
  parseAsync(e, r, n) {
    return this.serviceRegistry.getServices(e).parser.AsyncParser.parse(r, n);
  }
  createTextDocumentGetter(e, r) {
    const n = this.serviceRegistry;
    let a;
    return () => a ?? (a = yS.create(e.toString(), n.getServices(e).LanguageMetaData.languageId, 0, r ?? ""));
  }
}
class GRe {
  constructor(e) {
    this.documentMap = /* @__PURE__ */ new Map(), this.langiumDocumentFactory = e.workspace.LangiumDocumentFactory, this.serviceRegistry = e.ServiceRegistry;
  }
  get all() {
    return Fn(this.documentMap.values());
  }
  addDocument(e) {
    const r = e.uri.toString();
    if (this.documentMap.has(r))
      throw new Error(`A document with the URI '${r}' is already present.`);
    this.documentMap.set(r, e);
  }
  getDocument(e) {
    const r = e.toString();
    return this.documentMap.get(r);
  }
  async getOrCreateDocument(e, r) {
    let n = this.getDocument(e);
    return n || (n = await this.langiumDocumentFactory.fromUri(e, r), this.addDocument(n), n);
  }
  createDocument(e, r, n) {
    if (n)
      return this.langiumDocumentFactory.fromString(r, e, n).then((a) => (this.addDocument(a), a));
    {
      const a = this.langiumDocumentFactory.fromString(r, e);
      return this.addDocument(a), a;
    }
  }
  hasDocument(e) {
    return this.documentMap.has(e.toString());
  }
  invalidateDocument(e) {
    const r = e.toString(), n = this.documentMap.get(r);
    return n && (this.serviceRegistry.getServices(e).references.Linker.unlink(n), n.state = Dr.Changed, n.precomputedScopes = void 0, n.diagnostics = void 0), n;
  }
  deleteDocument(e) {
    const r = e.toString(), n = this.documentMap.get(r);
    return n && (n.state = Dr.Changed, this.documentMap.delete(r)), n;
  }
}
const jw = Symbol("ref_resolving");
class URe {
  constructor(e) {
    this.reflection = e.shared.AstReflection, this.langiumDocuments = () => e.shared.workspace.LangiumDocuments, this.scopeProvider = e.references.ScopeProvider, this.astNodeLocator = e.workspace.AstNodeLocator;
  }
  async link(e, r = Vr.None) {
    for (const n of Cc(e.parseResult.value))
      await Qa(r), CG(n).forEach((a) => this.doLink(a, e));
  }
  doLink(e, r) {
    var n;
    const a = e.reference;
    if (a._ref === void 0) {
      a._ref = jw;
      try {
        const i = this.getCandidate(e);
        if (Cv(i))
          a._ref = i;
        else if (a._nodeDescription = i, this.langiumDocuments().hasDocument(i.documentUri)) {
          const s = this.loadAstNode(i);
          a._ref = s ?? this.createLinkingError(e, i);
        } else
          a._ref = void 0;
      } catch (i) {
        console.error(`An error occurred while resolving reference to '${a.$refText}':`, i);
        const s = (n = i.message) !== null && n !== void 0 ? n : String(i);
        a._ref = Object.assign(Object.assign({}, e), { message: `An error occurred while resolving reference to '${a.$refText}': ${s}` });
      }
      r.references.push(a);
    }
  }
  unlink(e) {
    for (const r of e.references)
      delete r._ref, delete r._nodeDescription;
    e.references = [];
  }
  getCandidate(e) {
    const n = this.scopeProvider.getScope(e).getElement(e.reference.$refText);
    return n ?? this.createLinkingError(e);
  }
  buildReference(e, r, n, a) {
    const i = this, s = {
      $refNode: n,
      $refText: a,
      get ref() {
        var o;
        if (Jn(this._ref))
          return this._ref;
        if (vCe(this._nodeDescription)) {
          const l = i.loadAstNode(this._nodeDescription);
          this._ref = l ?? i.createLinkingError({ reference: s, container: e, property: r }, this._nodeDescription);
        } else if (this._ref === void 0) {
          this._ref = jw;
          const l = z4(e).$document, u = i.getLinkedNode({ reference: s, container: e, property: r });
          if (u.error && l && l.state < Dr.ComputedScopes)
            return this._ref = void 0;
          this._ref = (o = u.node) !== null && o !== void 0 ? o : u.error, this._nodeDescription = u.descr, l == null || l.references.push(this);
        } else if (this._ref === jw)
          throw new Error(`Cyclic reference resolution detected: ${i.astNodeLocator.getAstNodePath(e)}/${r} (symbol '${a}')`);
        return Jn(this._ref) ? this._ref : void 0;
      },
      get $nodeDescription() {
        return this._nodeDescription;
      },
      get error() {
        return Cv(this._ref) ? this._ref : void 0;
      }
    };
    return s;
  }
  getLinkedNode(e) {
    var r;
    try {
      const n = this.getCandidate(e);
      if (Cv(n))
        return { error: n };
      const a = this.loadAstNode(n);
      return a ? { node: a, descr: n } : {
        descr: n,
        error: this.createLinkingError(e, n)
      };
    } catch (n) {
      console.error(`An error occurred while resolving reference to '${e.reference.$refText}':`, n);
      const a = (r = n.message) !== null && r !== void 0 ? r : String(n);
      return {
        error: Object.assign(Object.assign({}, e), { message: `An error occurred while resolving reference to '${e.reference.$refText}': ${a}` })
      };
    }
  }
  loadAstNode(e) {
    if (e.node)
      return e.node;
    const r = this.langiumDocuments().getDocument(e.documentUri);
    if (r)
      return this.astNodeLocator.getAstNode(r.parseResult.value, e.path);
  }
  createLinkingError(e, r) {
    const n = z4(e.container).$document;
    n && n.state < Dr.ComputedScopes && console.warn(`Attempted reference resolution before document reached ComputedScopes state (${n.uri}).`);
    const a = this.reflection.getReferenceType(e);
    return Object.assign(Object.assign({}, e), { message: `Could not resolve reference to ${a} named '${e.reference.$refText}'.`, targetDescription: r });
  }
}
function HRe(t) {
  return typeof t.name == "string";
}
class VRe {
  getName(e) {
    if (HRe(e))
      return e.name;
  }
  getNameNode(e) {
    return _G(e.$cstNode, "name");
  }
}
class qRe {
  constructor(e) {
    this.nameProvider = e.references.NameProvider, this.index = e.shared.workspace.IndexManager, this.nodeLocator = e.workspace.AstNodeLocator;
  }
  findDeclaration(e) {
    if (e) {
      const r = l3e(e), n = e.astNode;
      if (r && n) {
        const a = n[r.feature];
        if (ps(a))
          return a.ref;
        if (Array.isArray(a)) {
          for (const i of a)
            if (ps(i) && i.$refNode && i.$refNode.offset <= e.offset && i.$refNode.end >= e.end)
              return i.ref;
        }
      }
      if (n) {
        const a = this.nameProvider.getNameNode(n);
        if (a && (a === e || bCe(e, a)))
          return n;
      }
    }
  }
  findDeclarationNode(e) {
    const r = this.findDeclaration(e);
    if (r != null && r.$cstNode) {
      const n = this.nameProvider.getNameNode(r);
      return n ?? r.$cstNode;
    }
  }
  findReferences(e, r) {
    const n = [];
    if (r.includeDeclaration) {
      const i = this.getReferenceToSelf(e);
      i && n.push(i);
    }
    let a = this.index.findAllReferences(e, this.nodeLocator.getAstNodePath(e));
    return r.documentUri && (a = a.filter((i) => nl.equals(i.sourceUri, r.documentUri))), n.push(...a), Fn(n);
  }
  getReferenceToSelf(e) {
    const r = this.nameProvider.getNameNode(e);
    if (r) {
      const n = Jo(e), a = this.nodeLocator.getAstNodePath(e);
      return {
        sourceUri: n.uri,
        sourcePath: a,
        targetUri: n.uri,
        targetPath: a,
        segment: Km(r),
        local: !0
      };
    }
  }
}
class vy {
  constructor(e) {
    if (this.map = /* @__PURE__ */ new Map(), e)
      for (const [r, n] of e)
        this.add(r, n);
  }
  /**
   * The total number of values in the multimap.
   */
  get size() {
    return $4.sum(Fn(this.map.values()).map((e) => e.length));
  }
  /**
   * Clear all entries in the multimap.
   */
  clear() {
    this.map.clear();
  }
  /**
   * Operates differently depending on whether a `value` is given:
   *  * With a value, this method deletes the specific key / value pair from the multimap.
   *  * Without a value, all values associated with the given key are deleted.
   *
   * @returns `true` if a value existed and has been removed, or `false` if the specified
   *     key / value does not exist.
   */
  delete(e, r) {
    if (r === void 0)
      return this.map.delete(e);
    {
      const n = this.map.get(e);
      if (n) {
        const a = n.indexOf(r);
        if (a >= 0)
          return n.length === 1 ? this.map.delete(e) : n.splice(a, 1), !0;
      }
      return !1;
    }
  }
  /**
   * Returns an array of all values associated with the given key. If no value exists,
   * an empty array is returned.
   *
   * _Note:_ The returned array is assumed not to be modified. Use the `set` method to add a
   * value and `delete` to remove a value from the multimap.
   */
  get(e) {
    var r;
    return (r = this.map.get(e)) !== null && r !== void 0 ? r : [];
  }
  /**
   * Operates differently depending on whether a `value` is given:
   *  * With a value, this method returns `true` if the specific key / value pair is present in the multimap.
   *  * Without a value, this method returns `true` if the given key is present in the multimap.
   */
  has(e, r) {
    if (r === void 0)
      return this.map.has(e);
    {
      const n = this.map.get(e);
      return n ? n.indexOf(r) >= 0 : !1;
    }
  }
  /**
   * Add the given key / value pair to the multimap.
   */
  add(e, r) {
    return this.map.has(e) ? this.map.get(e).push(r) : this.map.set(e, [r]), this;
  }
  /**
   * Add the given set of key / value pairs to the multimap.
   */
  addAll(e, r) {
    return this.map.has(e) ? this.map.get(e).push(...r) : this.map.set(e, Array.from(r)), this;
  }
  /**
   * Invokes the given callback function for every key / value pair in the multimap.
   */
  forEach(e) {
    this.map.forEach((r, n) => r.forEach((a) => e(a, n, this)));
  }
  /**
   * Returns an iterator of key, value pairs for every entry in the map.
   */
  [Symbol.iterator]() {
    return this.entries().iterator();
  }
  /**
   * Returns a stream of key, value pairs for every entry in the map.
   */
  entries() {
    return Fn(this.map.entries()).flatMap(([e, r]) => r.map((n) => [e, n]));
  }
  /**
   * Returns a stream of keys in the map.
   */
  keys() {
    return Fn(this.map.keys());
  }
  /**
   * Returns a stream of values in the map.
   */
  values() {
    return Fn(this.map.values()).flat();
  }
  /**
   * Returns a stream of key, value set pairs for every key in the map.
   */
  entriesGroupedByKey() {
    return Fn(this.map.entries());
  }
}
class v8 {
  get size() {
    return this.map.size;
  }
  constructor(e) {
    if (this.map = /* @__PURE__ */ new Map(), this.inverse = /* @__PURE__ */ new Map(), e)
      for (const [r, n] of e)
        this.set(r, n);
  }
  clear() {
    this.map.clear(), this.inverse.clear();
  }
  set(e, r) {
    return this.map.set(e, r), this.inverse.set(r, e), this;
  }
  get(e) {
    return this.map.get(e);
  }
  getKey(e) {
    return this.inverse.get(e);
  }
  delete(e) {
    const r = this.map.get(e);
    return r !== void 0 ? (this.map.delete(e), this.inverse.delete(r), !0) : !1;
  }
}
class WRe {
  constructor(e) {
    this.nameProvider = e.references.NameProvider, this.descriptions = e.workspace.AstNodeDescriptionProvider;
  }
  async computeExports(e, r = Vr.None) {
    return this.computeExportsForNode(e.parseResult.value, e, void 0, r);
  }
  /**
   * Creates {@link AstNodeDescription AstNodeDescriptions} for the given {@link AstNode parentNode} and its children.
   * The list of children to be considered is determined by the function parameter {@link children}.
   * By default only the direct children of {@link parentNode} are visited, nested nodes are not exported.
   *
   * @param parentNode AST node to be exported, i.e., of which an {@link AstNodeDescription} shall be added to the returned list.
   * @param document The document containing the AST node to be exported.
   * @param children A function called with {@link parentNode} as single argument and returning an {@link Iterable} supplying the children to be visited, which must be directly or transitively contained in {@link parentNode}.
   * @param cancelToken Indicates when to cancel the current operation.
   * @throws `OperationCancelled` if a user action occurs during execution.
   * @returns A list of {@link AstNodeDescription AstNodeDescriptions} to be published to index.
   */
  async computeExportsForNode(e, r, n = M3, a = Vr.None) {
    const i = [];
    this.exportNode(e, i, r);
    for (const s of n(e))
      await Qa(a), this.exportNode(s, i, r);
    return i;
  }
  /**
   * Add a single node to the list of exports if it has a name. Override this method to change how
   * symbols are exported, e.g. by modifying their exported name.
   */
  exportNode(e, r, n) {
    const a = this.nameProvider.getName(e);
    a && r.push(this.descriptions.createDescription(e, a, n));
  }
  async computeLocalScopes(e, r = Vr.None) {
    const n = e.parseResult.value, a = new vy();
    for (const i of xp(n))
      await Qa(r), this.processNode(i, e, a);
    return a;
  }
  /**
   * Process a single node during scopes computation. The default implementation makes the node visible
   * in the subtree of its container (if the node has a name). Override this method to change this,
   * e.g. by increasing the visibility to a higher level in the AST.
   */
  processNode(e, r, n) {
    const a = e.$container;
    if (a) {
      const i = this.nameProvider.getName(e);
      i && n.add(a, this.descriptions.createDescription(e, i, r));
    }
  }
}
class m8 {
  constructor(e, r, n) {
    var a;
    this.elements = e, this.outerScope = r, this.caseInsensitive = (a = n == null ? void 0 : n.caseInsensitive) !== null && a !== void 0 ? a : !1;
  }
  getAllElements() {
    return this.outerScope ? this.elements.concat(this.outerScope.getAllElements()) : this.elements;
  }
  getElement(e) {
    const r = this.caseInsensitive ? this.elements.find((n) => n.name.toLowerCase() === e.toLowerCase()) : this.elements.find((n) => n.name === e);
    if (r)
      return r;
    if (this.outerScope)
      return this.outerScope.getElement(e);
  }
}
class jRe {
  constructor(e, r, n) {
    var a;
    this.elements = /* @__PURE__ */ new Map(), this.caseInsensitive = (a = n == null ? void 0 : n.caseInsensitive) !== null && a !== void 0 ? a : !1;
    for (const i of e) {
      const s = this.caseInsensitive ? i.name.toLowerCase() : i.name;
      this.elements.set(s, i);
    }
    this.outerScope = r;
  }
  getElement(e) {
    const r = this.caseInsensitive ? e.toLowerCase() : e, n = this.elements.get(r);
    if (n)
      return n;
    if (this.outerScope)
      return this.outerScope.getElement(e);
  }
  getAllElements() {
    let e = Fn(this.elements.values());
    return this.outerScope && (e = e.concat(this.outerScope.getAllElements())), e;
  }
}
class UU {
  constructor() {
    this.toDispose = [], this.isDisposed = !1;
  }
  onDispose(e) {
    this.toDispose.push(e);
  }
  dispose() {
    this.throwIfDisposed(), this.clear(), this.isDisposed = !0, this.toDispose.forEach((e) => e.dispose());
  }
  throwIfDisposed() {
    if (this.isDisposed)
      throw new Error("This cache has already been disposed");
  }
}
class YRe extends UU {
  constructor() {
    super(...arguments), this.cache = /* @__PURE__ */ new Map();
  }
  has(e) {
    return this.throwIfDisposed(), this.cache.has(e);
  }
  set(e, r) {
    this.throwIfDisposed(), this.cache.set(e, r);
  }
  get(e, r) {
    if (this.throwIfDisposed(), this.cache.has(e))
      return this.cache.get(e);
    if (r) {
      const n = r();
      return this.cache.set(e, n), n;
    } else
      return;
  }
  delete(e) {
    return this.throwIfDisposed(), this.cache.delete(e);
  }
  clear() {
    this.throwIfDisposed(), this.cache.clear();
  }
}
class XRe extends UU {
  constructor(e) {
    super(), this.cache = /* @__PURE__ */ new Map(), this.converter = e ?? ((r) => r);
  }
  has(e, r) {
    return this.throwIfDisposed(), this.cacheForContext(e).has(r);
  }
  set(e, r, n) {
    this.throwIfDisposed(), this.cacheForContext(e).set(r, n);
  }
  get(e, r, n) {
    this.throwIfDisposed();
    const a = this.cacheForContext(e);
    if (a.has(r))
      return a.get(r);
    if (n) {
      const i = n();
      return a.set(r, i), i;
    } else
      return;
  }
  delete(e, r) {
    return this.throwIfDisposed(), this.cacheForContext(e).delete(r);
  }
  clear(e) {
    if (this.throwIfDisposed(), e) {
      const r = this.converter(e);
      this.cache.delete(r);
    } else
      this.cache.clear();
  }
  cacheForContext(e) {
    const r = this.converter(e);
    let n = this.cache.get(r);
    return n || (n = /* @__PURE__ */ new Map(), this.cache.set(r, n)), n;
  }
}
class KRe extends YRe {
  /**
   * Creates a new workspace cache.
   *
   * @param sharedServices Service container instance to hook into document lifecycle events.
   * @param state Optional document state on which the cache should evict.
   * If not provided, the cache will evict on `DocumentBuilder#onUpdate`.
   * *Deleted* documents are considered in both cases.
   */
  constructor(e, r) {
    super(), r ? (this.toDispose.push(e.workspace.DocumentBuilder.onBuildPhase(r, () => {
      this.clear();
    })), this.toDispose.push(e.workspace.DocumentBuilder.onUpdate((n, a) => {
      a.length > 0 && this.clear();
    }))) : this.toDispose.push(e.workspace.DocumentBuilder.onUpdate(() => {
      this.clear();
    }));
  }
}
class ZRe {
  constructor(e) {
    this.reflection = e.shared.AstReflection, this.nameProvider = e.references.NameProvider, this.descriptions = e.workspace.AstNodeDescriptionProvider, this.indexManager = e.shared.workspace.IndexManager, this.globalScopeCache = new KRe(e.shared);
  }
  getScope(e) {
    const r = [], n = this.reflection.getReferenceType(e), a = Jo(e.container).precomputedScopes;
    if (a) {
      let s = e.container;
      do {
        const o = a.get(s);
        o.length > 0 && r.push(Fn(o).filter((l) => this.reflection.isSubtype(l.type, n))), s = s.$container;
      } while (s);
    }
    let i = this.getGlobalScope(n, e);
    for (let s = r.length - 1; s >= 0; s--)
      i = this.createScope(r[s], i);
    return i;
  }
  /**
   * Create a scope for the given collection of AST node descriptions.
   */
  createScope(e, r, n) {
    return new m8(Fn(e), r, n);
  }
  /**
   * Create a scope for the given collection of AST nodes, which need to be transformed into respective
   * descriptions first. This is done using the `NameProvider` and `AstNodeDescriptionProvider` services.
   */
  createScopeForNodes(e, r, n) {
    const a = Fn(e).map((i) => {
      const s = this.nameProvider.getName(i);
      if (s)
        return this.descriptions.createDescription(i, s);
    }).nonNullable();
    return new m8(a, r, n);
  }
  /**
   * Create a global scope filtered for the given reference type.
   */
  getGlobalScope(e, r) {
    return this.globalScopeCache.get(e, () => new jRe(this.indexManager.allElements(e)));
  }
}
function QRe(t) {
  return typeof t.$comment == "string";
}
function y8(t) {
  return typeof t == "object" && !!t && ("$ref" in t || "$error" in t);
}
class JRe {
  constructor(e) {
    this.ignoreProperties = /* @__PURE__ */ new Set(["$container", "$containerProperty", "$containerIndex", "$document", "$cstNode"]), this.langiumDocuments = e.shared.workspace.LangiumDocuments, this.astNodeLocator = e.workspace.AstNodeLocator, this.nameProvider = e.references.NameProvider, this.commentProvider = e.documentation.CommentProvider;
  }
  serialize(e, r) {
    const n = r ?? {}, a = r == null ? void 0 : r.replacer, i = (o, l) => this.replacer(o, l, n), s = a ? (o, l) => a(o, l, i) : i;
    try {
      return this.currentDocument = Jo(e), JSON.stringify(e, s, r == null ? void 0 : r.space);
    } finally {
      this.currentDocument = void 0;
    }
  }
  deserialize(e, r) {
    const n = r ?? {}, a = JSON.parse(e);
    return this.linkNode(a, a, n), a;
  }
  replacer(e, r, { refText: n, sourceText: a, textRegions: i, comments: s, uriConverter: o }) {
    var l, u, c, f;
    if (!this.ignoreProperties.has(e))
      if (ps(r)) {
        const h = r.ref, d = n ? r.$refText : void 0;
        if (h) {
          const p = Jo(h);
          let g = "";
          this.currentDocument && this.currentDocument !== p && (o ? g = o(p.uri, r) : g = p.uri.toString());
          const v = this.astNodeLocator.getAstNodePath(h);
          return {
            $ref: `${g}#${v}`,
            $refText: d
          };
        } else
          return {
            $error: (u = (l = r.error) === null || l === void 0 ? void 0 : l.message) !== null && u !== void 0 ? u : "Could not resolve reference",
            $refText: d
          };
      } else if (Jn(r)) {
        let h;
        if (i && (h = this.addAstNodeRegionWithAssignmentsTo(Object.assign({}, r)), (!e || r.$document) && (h != null && h.$textRegion) && (h.$textRegion.documentURI = (c = this.currentDocument) === null || c === void 0 ? void 0 : c.uri.toString())), a && !e && (h ?? (h = Object.assign({}, r)), h.$sourceText = (f = r.$cstNode) === null || f === void 0 ? void 0 : f.text), s) {
          h ?? (h = Object.assign({}, r));
          const d = this.commentProvider.getComment(r);
          d && (h.$comment = d.replace(/\r/g, ""));
        }
        return h ?? r;
      } else
        return r;
  }
  addAstNodeRegionWithAssignmentsTo(e) {
    const r = (n) => ({
      offset: n.offset,
      end: n.end,
      length: n.length,
      range: n.range
    });
    if (e.$cstNode) {
      const n = e.$textRegion = r(e.$cstNode), a = n.assignments = {};
      return Object.keys(e).filter((i) => !i.startsWith("$")).forEach((i) => {
        const s = i3e(e.$cstNode, i).map(r);
        s.length !== 0 && (a[i] = s);
      }), e;
    }
  }
  linkNode(e, r, n, a, i, s) {
    for (const [l, u] of Object.entries(e))
      if (Array.isArray(u))
        for (let c = 0; c < u.length; c++) {
          const f = u[c];
          y8(f) ? u[c] = this.reviveReference(e, l, r, f, n) : Jn(f) && this.linkNode(f, r, n, e, l, c);
        }
      else y8(u) ? e[l] = this.reviveReference(e, l, r, u, n) : Jn(u) && this.linkNode(u, r, n, e, l);
    const o = e;
    o.$container = a, o.$containerProperty = i, o.$containerIndex = s;
  }
  reviveReference(e, r, n, a, i) {
    let s = a.$refText, o = a.$error;
    if (a.$ref) {
      const l = this.getRefNode(n, a.$ref, i.uriConverter);
      if (Jn(l))
        return s || (s = this.nameProvider.getName(l)), {
          $refText: s ?? "",
          ref: l
        };
      o = l;
    }
    if (o) {
      const l = {
        $refText: s ?? ""
      };
      return l.error = {
        container: e,
        property: r,
        message: o,
        reference: l
      }, l;
    } else
      return;
  }
  getRefNode(e, r, n) {
    try {
      const a = r.indexOf("#");
      if (a === 0) {
        const l = this.astNodeLocator.getAstNode(e, r.substring(1));
        return l || "Could not resolve path: " + r;
      }
      if (a < 0) {
        const l = n ? n(r) : gu.parse(r), u = this.langiumDocuments.getDocument(l);
        return u ? u.parseResult.value : "Could not find document for URI: " + r;
      }
      const i = n ? n(r.substring(0, a)) : gu.parse(r.substring(0, a)), s = this.langiumDocuments.getDocument(i);
      if (!s)
        return "Could not find document for URI: " + r;
      if (a === r.length - 1)
        return s.parseResult.value;
      const o = this.astNodeLocator.getAstNode(s.parseResult.value, r.substring(a + 1));
      return o || "Could not resolve URI: " + r;
    } catch (a) {
      return String(a);
    }
  }
}
class e6e {
  /**
   * @deprecated Use the new `fileExtensionMap` (or `languageIdMap`) property instead.
   */
  get map() {
    return this.fileExtensionMap;
  }
  constructor(e) {
    this.languageIdMap = /* @__PURE__ */ new Map(), this.fileExtensionMap = /* @__PURE__ */ new Map(), this.textDocuments = e == null ? void 0 : e.workspace.TextDocuments;
  }
  register(e) {
    const r = e.LanguageMetaData;
    for (const n of r.fileExtensions)
      this.fileExtensionMap.has(n) && console.warn(`The file extension ${n} is used by multiple languages. It is now assigned to '${r.languageId}'.`), this.fileExtensionMap.set(n, e);
    this.languageIdMap.set(r.languageId, e), this.languageIdMap.size === 1 ? this.singleton = e : this.singleton = void 0;
  }
  getServices(e) {
    var r, n;
    if (this.singleton !== void 0)
      return this.singleton;
    if (this.languageIdMap.size === 0)
      throw new Error("The service registry is empty. Use `register` to register the services of a language.");
    const a = (n = (r = this.textDocuments) === null || r === void 0 ? void 0 : r.get(e)) === null || n === void 0 ? void 0 : n.languageId;
    if (a !== void 0) {
      const o = this.languageIdMap.get(a);
      if (o)
        return o;
    }
    const i = nl.extname(e), s = this.fileExtensionMap.get(i);
    if (!s)
      throw a ? new Error(`The service registry contains no services for the extension '${i}' for language '${a}'.`) : new Error(`The service registry contains no services for the extension '${i}'.`);
    return s;
  }
  hasServices(e) {
    try {
      return this.getServices(e), !0;
    } catch {
      return !1;
    }
  }
  get all() {
    return Array.from(this.languageIdMap.values());
  }
}
function cd(t) {
  return { code: t };
}
var my;
(function(t) {
  t.all = ["fast", "slow", "built-in"];
})(my || (my = {}));
class t6e {
  constructor(e) {
    this.entries = new vy(), this.entriesBefore = [], this.entriesAfter = [], this.reflection = e.shared.AstReflection;
  }
  /**
   * Register a set of validation checks. Each value in the record can be either a single validation check (i.e. a function)
   * or an array of validation checks.
   *
   * @param checksRecord Set of validation checks to register.
   * @param category Optional category for the validation checks (defaults to `'fast'`).
   * @param thisObj Optional object to be used as `this` when calling the validation check functions.
   */
  register(e, r = this, n = "fast") {
    if (n === "built-in")
      throw new Error("The 'built-in' category is reserved for lexer, parser, and linker errors.");
    for (const [a, i] of Object.entries(e)) {
      const s = i;
      if (Array.isArray(s))
        for (const o of s) {
          const l = {
            check: this.wrapValidationException(o, r),
            category: n
          };
          this.addEntry(a, l);
        }
      else if (typeof s == "function") {
        const o = {
          check: this.wrapValidationException(s, r),
          category: n
        };
        this.addEntry(a, o);
      } else
        bp();
    }
  }
  wrapValidationException(e, r) {
    return async (n, a, i) => {
      await this.handleException(() => e.call(r, n, a, i), "An error occurred during validation", a, n);
    };
  }
  async handleException(e, r, n, a) {
    try {
      await e();
    } catch (i) {
      if (Ab(i))
        throw i;
      console.error(`${r}:`, i), i instanceof Error && i.stack && console.error(i.stack);
      const s = i instanceof Error ? i.message : String(i);
      n("error", `${r}: ${s}`, { node: a });
    }
  }
  addEntry(e, r) {
    if (e === "AstNode") {
      this.entries.add("AstNode", r);
      return;
    }
    for (const n of this.reflection.getAllSubTypes(e))
      this.entries.add(n, r);
  }
  getChecks(e, r) {
    let n = Fn(this.entries.get(e)).concat(this.entries.get("AstNode"));
    return r && (n = n.filter((a) => r.includes(a.category))), n.map((a) => a.check);
  }
  /**
   * Register logic which will be executed once before validating all the nodes of an AST/Langium document.
   * This helps to prepare or initialize some information which are required or reusable for the following checks on the AstNodes.
   *
   * As an example, for validating unique fully-qualified names of nodes in the AST,
   * here the map for mapping names to nodes could be established.
   * During the usual checks on the nodes, they are put into this map with their name.
   *
   * Note that this approach makes validations stateful, which is relevant e.g. when cancelling the validation.
   * Therefore it is recommended to clear stored information
   * _before_ validating an AST to validate each AST unaffected from other ASTs
   * AND _after_ validating the AST to free memory by information which are no longer used.
   *
   * @param checkBefore a set-up function which will be called once before actually validating an AST
   * @param thisObj Optional object to be used as `this` when calling the validation check functions.
   */
  registerBeforeDocument(e, r = this) {
    this.entriesBefore.push(this.wrapPreparationException(e, "An error occurred during set-up of the validation", r));
  }
  /**
   * Register logic which will be executed once after validating all the nodes of an AST/Langium document.
   * This helps to finally evaluate information which are collected during the checks on the AstNodes.
   *
   * As an example, for validating unique fully-qualified names of nodes in the AST,
   * here the map with all the collected nodes and their names is checked
   * and validation hints are created for all nodes with the same name.
   *
   * Note that this approach makes validations stateful, which is relevant e.g. when cancelling the validation.
   * Therefore it is recommended to clear stored information
   * _before_ validating an AST to validate each AST unaffected from other ASTs
   * AND _after_ validating the AST to free memory by information which are no longer used.
   *
   * @param checkBefore a set-up function which will be called once before actually validating an AST
   * @param thisObj Optional object to be used as `this` when calling the validation check functions.
   */
  registerAfterDocument(e, r = this) {
    this.entriesAfter.push(this.wrapPreparationException(e, "An error occurred during tear-down of the validation", r));
  }
  wrapPreparationException(e, r, n) {
    return async (a, i, s, o) => {
      await this.handleException(() => e.call(n, a, i, s, o), r, i, a);
    };
  }
  get checksBefore() {
    return this.entriesBefore;
  }
  get checksAfter() {
    return this.entriesAfter;
  }
}
class r6e {
  constructor(e) {
    this.validationRegistry = e.validation.ValidationRegistry, this.metadata = e.LanguageMetaData;
  }
  async validateDocument(e, r = {}, n = Vr.None) {
    const a = e.parseResult, i = [];
    if (await Qa(n), (!r.categories || r.categories.includes("built-in")) && (this.processLexingErrors(a, i, r), r.stopAfterLexingErrors && i.some((s) => {
      var o;
      return ((o = s.data) === null || o === void 0 ? void 0 : o.code) === $i.LexingError;
    }) || (this.processParsingErrors(a, i, r), r.stopAfterParsingErrors && i.some((s) => {
      var o;
      return ((o = s.data) === null || o === void 0 ? void 0 : o.code) === $i.ParsingError;
    })) || (this.processLinkingErrors(e, i, r), r.stopAfterLinkingErrors && i.some((s) => {
      var o;
      return ((o = s.data) === null || o === void 0 ? void 0 : o.code) === $i.LinkingError;
    }))))
      return i;
    try {
      i.push(...await this.validateAst(a.value, r, n));
    } catch (s) {
      if (Ab(s))
        throw s;
      console.error("An error occurred during validation:", s);
    }
    return await Qa(n), i;
  }
  processLexingErrors(e, r, n) {
    var a, i, s;
    const o = [...e.lexerErrors, ...(i = (a = e.lexerReport) === null || a === void 0 ? void 0 : a.diagnostics) !== null && i !== void 0 ? i : []];
    for (const l of o) {
      const u = (s = l.severity) !== null && s !== void 0 ? s : "error", c = {
        severity: Yw(u),
        range: {
          start: {
            line: l.line - 1,
            character: l.column - 1
          },
          end: {
            line: l.line - 1,
            character: l.column + l.length - 1
          }
        },
        message: l.message,
        data: a6e(u),
        source: this.getSource()
      };
      r.push(c);
    }
  }
  processParsingErrors(e, r, n) {
    for (const a of e.parserErrors) {
      let i;
      if (isNaN(a.token.startOffset)) {
        if ("previousToken" in a) {
          const s = a.previousToken;
          if (isNaN(s.startOffset)) {
            const o = { line: 0, character: 0 };
            i = { start: o, end: o };
          } else {
            const o = { line: s.endLine - 1, character: s.endColumn };
            i = { start: o, end: o };
          }
        }
      } else
        i = B4(a.token);
      if (i) {
        const s = {
          severity: Yw("error"),
          range: i,
          message: a.message,
          data: cd($i.ParsingError),
          source: this.getSource()
        };
        r.push(s);
      }
    }
  }
  processLinkingErrors(e, r, n) {
    for (const a of e.references) {
      const i = a.error;
      if (i) {
        const s = {
          node: i.container,
          property: i.property,
          index: i.index,
          data: {
            code: $i.LinkingError,
            containerType: i.container.$type,
            property: i.property,
            refText: i.reference.$refText
          }
        };
        r.push(this.toDiagnostic("error", i.message, s));
      }
    }
  }
  async validateAst(e, r, n = Vr.None) {
    const a = [], i = (s, o, l) => {
      a.push(this.toDiagnostic(s, o, l));
    };
    return await this.validateAstBefore(e, r, i, n), await this.validateAstNodes(e, r, i, n), await this.validateAstAfter(e, r, i, n), a;
  }
  async validateAstBefore(e, r, n, a = Vr.None) {
    var i;
    const s = this.validationRegistry.checksBefore;
    for (const o of s)
      await Qa(a), await o(e, n, (i = r.categories) !== null && i !== void 0 ? i : [], a);
  }
  async validateAstNodes(e, r, n, a = Vr.None) {
    await Promise.all(Cc(e).map(async (i) => {
      await Qa(a);
      const s = this.validationRegistry.getChecks(i.$type, r.categories);
      for (const o of s)
        await o(i, n, a);
    }));
  }
  async validateAstAfter(e, r, n, a = Vr.None) {
    var i;
    const s = this.validationRegistry.checksAfter;
    for (const o of s)
      await Qa(a), await o(e, n, (i = r.categories) !== null && i !== void 0 ? i : [], a);
  }
  toDiagnostic(e, r, n) {
    return {
      message: r,
      range: n6e(n),
      severity: Yw(e),
      code: n.code,
      codeDescription: n.codeDescription,
      tags: n.tags,
      relatedInformation: n.relatedInformation,
      data: n.data,
      source: this.getSource()
    };
  }
  getSource() {
    return this.metadata.languageId;
  }
}
function n6e(t) {
  if (t.range)
    return t.range;
  let e;
  return typeof t.property == "string" ? e = _G(t.node.$cstNode, t.property, t.index) : typeof t.keyword == "string" && (e = s3e(t.node.$cstNode, t.keyword, t.index)), e ?? (e = t.node.$cstNode), e ? e.range : {
    start: { line: 0, character: 0 },
    end: { line: 0, character: 0 }
  };
}
function Yw(t) {
  switch (t) {
    case "error":
      return 1;
    case "warning":
      return 2;
    case "info":
      return 3;
    case "hint":
      return 4;
    default:
      throw new Error("Invalid diagnostic severity: " + t);
  }
}
function a6e(t) {
  switch (t) {
    case "error":
      return cd($i.LexingError);
    case "warning":
      return cd($i.LexingWarning);
    case "info":
      return cd($i.LexingInfo);
    case "hint":
      return cd($i.LexingHint);
    default:
      throw new Error("Invalid diagnostic severity: " + t);
  }
}
var $i;
(function(t) {
  t.LexingError = "lexing-error", t.LexingWarning = "lexing-warning", t.LexingInfo = "lexing-info", t.LexingHint = "lexing-hint", t.ParsingError = "parsing-error", t.LinkingError = "linking-error";
})($i || ($i = {}));
class i6e {
  constructor(e) {
    this.astNodeLocator = e.workspace.AstNodeLocator, this.nameProvider = e.references.NameProvider;
  }
  createDescription(e, r, n) {
    const a = n ?? Jo(e);
    r ?? (r = this.nameProvider.getName(e));
    const i = this.astNodeLocator.getAstNodePath(e);
    if (!r)
      throw new Error(`Node at path ${i} has no name.`);
    let s;
    const o = () => {
      var l;
      return s ?? (s = Km((l = this.nameProvider.getNameNode(e)) !== null && l !== void 0 ? l : e.$cstNode));
    };
    return {
      node: e,
      name: r,
      get nameSegment() {
        return o();
      },
      selectionSegment: Km(e.$cstNode),
      type: e.$type,
      documentUri: a.uri,
      path: i
    };
  }
}
class s6e {
  constructor(e) {
    this.nodeLocator = e.workspace.AstNodeLocator;
  }
  async createDescriptions(e, r = Vr.None) {
    const n = [], a = e.parseResult.value;
    for (const i of Cc(a))
      await Qa(r), CG(i).filter((s) => !Cv(s)).forEach((s) => {
        const o = this.createDescription(s);
        o && n.push(o);
      });
    return n;
  }
  createDescription(e) {
    const r = e.reference.$nodeDescription, n = e.reference.$refNode;
    if (!r || !n)
      return;
    const a = Jo(e.container).uri;
    return {
      sourceUri: a,
      sourcePath: this.nodeLocator.getAstNodePath(e.container),
      targetUri: r.documentUri,
      targetPath: r.path,
      segment: Km(n),
      local: nl.equals(r.documentUri, a)
    };
  }
}
class o6e {
  constructor() {
    this.segmentSeparator = "/", this.indexSeparator = "@";
  }
  getAstNodePath(e) {
    if (e.$container) {
      const r = this.getAstNodePath(e.$container), n = this.getPathSegment(e);
      return r + this.segmentSeparator + n;
    }
    return "";
  }
  getPathSegment({ $containerProperty: e, $containerIndex: r }) {
    if (!e)
      throw new Error("Missing '$containerProperty' in AST node.");
    return r !== void 0 ? e + this.indexSeparator + r : e;
  }
  getAstNode(e, r) {
    return r.split(this.segmentSeparator).reduce((a, i) => {
      if (!a || i.length === 0)
        return a;
      const s = i.indexOf(this.indexSeparator);
      if (s > 0) {
        const o = i.substring(0, s), l = parseInt(i.substring(s + 1)), u = a[o];
        return u == null ? void 0 : u[l];
      }
      return a[i];
    }, e);
  }
}
class l6e {
  constructor(e) {
    this._ready = new Y3(), this.settings = {}, this.workspaceConfig = !1, this.onConfigurationSectionUpdateEmitter = new FU(), this.serviceRegistry = e.ServiceRegistry;
  }
  get ready() {
    return this._ready.promise;
  }
  initialize(e) {
    var r, n;
    this.workspaceConfig = (n = (r = e.capabilities.workspace) === null || r === void 0 ? void 0 : r.configuration) !== null && n !== void 0 ? n : !1;
  }
  async initialized(e) {
    if (this.workspaceConfig) {
      if (e.register) {
        const r = this.serviceRegistry.all;
        e.register({
          // Listen to configuration changes for all languages
          section: r.map((n) => this.toSectionName(n.LanguageMetaData.languageId))
        });
      }
      if (e.fetchConfiguration) {
        const r = this.serviceRegistry.all.map((a) => ({
          // Fetch the configuration changes for all languages
          section: this.toSectionName(a.LanguageMetaData.languageId)
        })), n = await e.fetchConfiguration(r);
        r.forEach((a, i) => {
          this.updateSectionConfiguration(a.section, n[i]);
        });
      }
    }
    this._ready.resolve();
  }
  /**
   *  Updates the cached configurations using the `change` notification parameters.
   *
   * @param change The parameters of a change configuration notification.
   * `settings` property of the change object could be expressed as `Record<string, Record<string, any>>`
   */
  updateConfiguration(e) {
    e.settings && Object.keys(e.settings).forEach((r) => {
      const n = e.settings[r];
      this.updateSectionConfiguration(r, n), this.onConfigurationSectionUpdateEmitter.fire({ section: r, configuration: n });
    });
  }
  updateSectionConfiguration(e, r) {
    this.settings[e] = r;
  }
  /**
  * Returns a configuration value stored for the given language.
  *
  * @param language The language id
  * @param configuration Configuration name
  */
  async getConfiguration(e, r) {
    await this.ready;
    const n = this.toSectionName(e);
    if (this.settings[n])
      return this.settings[n][r];
  }
  toSectionName(e) {
    return `${e}`;
  }
  get onConfigurationSectionUpdate() {
    return this.onConfigurationSectionUpdateEmitter.event;
  }
}
var Pd;
(function(t) {
  function e(r) {
    return {
      dispose: async () => await r()
    };
  }
  t.create = e;
})(Pd || (Pd = {}));
class u6e {
  constructor(e) {
    this.updateBuildOptions = {
      // Default: run only the built-in validation checks and those in the _fast_ category (includes those without category)
      validation: {
        categories: ["built-in", "fast"]
      }
    }, this.updateListeners = [], this.buildPhaseListeners = new vy(), this.documentPhaseListeners = new vy(), this.buildState = /* @__PURE__ */ new Map(), this.documentBuildWaiters = /* @__PURE__ */ new Map(), this.currentState = Dr.Changed, this.langiumDocuments = e.workspace.LangiumDocuments, this.langiumDocumentFactory = e.workspace.LangiumDocumentFactory, this.textDocuments = e.workspace.TextDocuments, this.indexManager = e.workspace.IndexManager, this.serviceRegistry = e.ServiceRegistry;
  }
  async build(e, r = {}, n = Vr.None) {
    var a, i;
    for (const s of e) {
      const o = s.uri.toString();
      if (s.state === Dr.Validated) {
        if (typeof r.validation == "boolean" && r.validation)
          s.state = Dr.IndexedReferences, s.diagnostics = void 0, this.buildState.delete(o);
        else if (typeof r.validation == "object") {
          const l = this.buildState.get(o), u = (a = l == null ? void 0 : l.result) === null || a === void 0 ? void 0 : a.validationChecks;
          if (u) {
            const f = ((i = r.validation.categories) !== null && i !== void 0 ? i : my.all).filter((h) => !u.includes(h));
            f.length > 0 && (this.buildState.set(o, {
              completed: !1,
              options: {
                validation: Object.assign(Object.assign({}, r.validation), { categories: f })
              },
              result: l.result
            }), s.state = Dr.IndexedReferences);
          }
        }
      } else
        this.buildState.delete(o);
    }
    this.currentState = Dr.Changed, await this.emitUpdate(e.map((s) => s.uri), []), await this.buildDocuments(e, r, n);
  }
  async update(e, r, n = Vr.None) {
    this.currentState = Dr.Changed;
    for (const s of r)
      this.langiumDocuments.deleteDocument(s), this.buildState.delete(s.toString()), this.indexManager.remove(s);
    for (const s of e) {
      if (!this.langiumDocuments.invalidateDocument(s)) {
        const l = this.langiumDocumentFactory.fromModel({ $type: "INVALID" }, s);
        l.state = Dr.Changed, this.langiumDocuments.addDocument(l);
      }
      this.buildState.delete(s.toString());
    }
    const a = Fn(e).concat(r).map((s) => s.toString()).toSet();
    this.langiumDocuments.all.filter((s) => !a.has(s.uri.toString()) && this.shouldRelink(s, a)).forEach((s) => {
      this.serviceRegistry.getServices(s.uri).references.Linker.unlink(s), s.state = Math.min(s.state, Dr.ComputedScopes), s.diagnostics = void 0;
    }), await this.emitUpdate(e, r), await Qa(n);
    const i = this.sortDocuments(this.langiumDocuments.all.filter((s) => {
      var o;
      return s.state < Dr.Linked || !(!((o = this.buildState.get(s.uri.toString())) === null || o === void 0) && o.completed);
    }).toArray());
    await this.buildDocuments(i, this.updateBuildOptions, n);
  }
  async emitUpdate(e, r) {
    await Promise.all(this.updateListeners.map((n) => n(e, r)));
  }
  /**
   * Sort the given documents by priority. By default, documents with an open text document are prioritized.
   * This is useful to ensure that visible documents show their diagnostics before all other documents.
   *
   * This improves the responsiveness in large workspaces as users usually don't care about diagnostics
   * in files that are currently not opened in the editor.
   */
  sortDocuments(e) {
    let r = 0, n = e.length - 1;
    for (; r < n; ) {
      for (; r < e.length && this.hasTextDocument(e[r]); )
        r++;
      for (; n >= 0 && !this.hasTextDocument(e[n]); )
        n--;
      r < n && ([e[r], e[n]] = [e[n], e[r]]);
    }
    return e;
  }
  hasTextDocument(e) {
    var r;
    return !!(!((r = this.textDocuments) === null || r === void 0) && r.get(e.uri));
  }
  /**
   * Check whether the given document should be relinked after changes were found in the given URIs.
   */
  shouldRelink(e, r) {
    return e.references.some((n) => n.error !== void 0) ? !0 : this.indexManager.isAffected(e, r);
  }
  onUpdate(e) {
    return this.updateListeners.push(e), Pd.create(() => {
      const r = this.updateListeners.indexOf(e);
      r >= 0 && this.updateListeners.splice(r, 1);
    });
  }
  /**
   * Build the given documents by stepping through all build phases. If a document's state indicates
   * that a certain build phase is already done, the phase is skipped for that document.
   *
   * @param documents The documents to build.
   * @param options the {@link BuildOptions} to use.
   * @param cancelToken A cancellation token that can be used to cancel the build.
   * @returns A promise that resolves when the build is done.
   */
  async buildDocuments(e, r, n) {
    this.prepareBuild(e, r), await this.runCancelable(e, Dr.Parsed, n, (i) => this.langiumDocumentFactory.update(i, n)), await this.runCancelable(e, Dr.IndexedContent, n, (i) => this.indexManager.updateContent(i, n)), await this.runCancelable(e, Dr.ComputedScopes, n, async (i) => {
      const s = this.serviceRegistry.getServices(i.uri).references.ScopeComputation;
      i.precomputedScopes = await s.computeLocalScopes(i, n);
    }), await this.runCancelable(e, Dr.Linked, n, (i) => this.serviceRegistry.getServices(i.uri).references.Linker.link(i, n)), await this.runCancelable(e, Dr.IndexedReferences, n, (i) => this.indexManager.updateReferences(i, n));
    const a = e.filter((i) => this.shouldValidate(i));
    await this.runCancelable(a, Dr.Validated, n, (i) => this.validate(i, n));
    for (const i of e) {
      const s = this.buildState.get(i.uri.toString());
      s && (s.completed = !0);
    }
  }
  /**
   * Runs prior to beginning the build process to update the {@link DocumentBuildState} for each document
   *
   * @param documents collection of documents to be built
   * @param options the {@link BuildOptions} to use
   */
  prepareBuild(e, r) {
    for (const n of e) {
      const a = n.uri.toString(), i = this.buildState.get(a);
      (!i || i.completed) && this.buildState.set(a, {
        completed: !1,
        options: r,
        result: i == null ? void 0 : i.result
      });
    }
  }
  /**
   * Runs a cancelable operation on a set of documents to bring them to a specified {@link DocumentState}.
   *
   * @param documents The array of documents to process.
   * @param targetState The target {@link DocumentState} to bring the documents to.
   * @param cancelToken A token that can be used to cancel the operation.
   * @param callback A function to be called for each document.
   * @returns A promise that resolves when all documents have been processed or the operation is canceled.
   * @throws Will throw `OperationCancelled` if the operation is canceled via a `CancellationToken`.
   */
  async runCancelable(e, r, n, a) {
    const i = e.filter((o) => o.state < r);
    for (const o of i)
      await Qa(n), await a(o), o.state = r, await this.notifyDocumentPhase(o, r, n);
    const s = e.filter((o) => o.state === r);
    await this.notifyBuildPhase(s, r, n), this.currentState = r;
  }
  onBuildPhase(e, r) {
    return this.buildPhaseListeners.add(e, r), Pd.create(() => {
      this.buildPhaseListeners.delete(e, r);
    });
  }
  onDocumentPhase(e, r) {
    return this.documentPhaseListeners.add(e, r), Pd.create(() => {
      this.documentPhaseListeners.delete(e, r);
    });
  }
  waitUntil(e, r, n) {
    let a;
    if (r && "path" in r ? a = r : n = r, n ?? (n = Vr.None), a) {
      const i = this.langiumDocuments.getDocument(a);
      if (i && i.state > e)
        return Promise.resolve(a);
    }
    return this.currentState >= e ? Promise.resolve(void 0) : n.isCancellationRequested ? Promise.reject(gy) : new Promise((i, s) => {
      const o = this.onBuildPhase(e, () => {
        if (o.dispose(), l.dispose(), a) {
          const u = this.langiumDocuments.getDocument(a);
          i(u == null ? void 0 : u.uri);
        } else
          i(void 0);
      }), l = n.onCancellationRequested(() => {
        o.dispose(), l.dispose(), s(gy);
      });
    });
  }
  async notifyDocumentPhase(e, r, n) {
    const i = this.documentPhaseListeners.get(r).slice();
    for (const s of i)
      try {
        await s(e, n);
      } catch (o) {
        if (!Ab(o))
          throw o;
      }
  }
  async notifyBuildPhase(e, r, n) {
    if (e.length === 0)
      return;
    const i = this.buildPhaseListeners.get(r).slice();
    for (const s of i)
      await Qa(n), await s(e, n);
  }
  /**
   * Determine whether the given document should be validated during a build. The default
   * implementation checks the `validation` property of the build options. If it's set to `true`
   * or a `ValidationOptions` object, the document is included in the validation phase.
   */
  shouldValidate(e) {
    return !!this.getBuildOptions(e).validation;
  }
  /**
   * Run validation checks on the given document and store the resulting diagnostics in the document.
   * If the document already contains diagnostics, the new ones are added to the list.
   */
  async validate(e, r) {
    var n, a;
    const i = this.serviceRegistry.getServices(e.uri).validation.DocumentValidator, s = this.getBuildOptions(e).validation, o = typeof s == "object" ? s : void 0, l = await i.validateDocument(e, o, r);
    e.diagnostics ? e.diagnostics.push(...l) : e.diagnostics = l;
    const u = this.buildState.get(e.uri.toString());
    if (u) {
      (n = u.result) !== null && n !== void 0 || (u.result = {});
      const c = (a = o == null ? void 0 : o.categories) !== null && a !== void 0 ? a : my.all;
      u.result.validationChecks ? u.result.validationChecks.push(...c) : u.result.validationChecks = [...c];
    }
  }
  getBuildOptions(e) {
    var r, n;
    return (n = (r = this.buildState.get(e.uri.toString())) === null || r === void 0 ? void 0 : r.options) !== null && n !== void 0 ? n : {};
  }
}
class c6e {
  constructor(e) {
    this.symbolIndex = /* @__PURE__ */ new Map(), this.symbolByTypeIndex = new XRe(), this.referenceIndex = /* @__PURE__ */ new Map(), this.documents = e.workspace.LangiumDocuments, this.serviceRegistry = e.ServiceRegistry, this.astReflection = e.AstReflection;
  }
  findAllReferences(e, r) {
    const n = Jo(e).uri, a = [];
    return this.referenceIndex.forEach((i) => {
      i.forEach((s) => {
        nl.equals(s.targetUri, n) && s.targetPath === r && a.push(s);
      });
    }), Fn(a);
  }
  allElements(e, r) {
    let n = Fn(this.symbolIndex.keys());
    return r && (n = n.filter((a) => !r || r.has(a))), n.map((a) => this.getFileDescriptions(a, e)).flat();
  }
  getFileDescriptions(e, r) {
    var n;
    return r ? this.symbolByTypeIndex.get(e, r, () => {
      var i;
      return ((i = this.symbolIndex.get(e)) !== null && i !== void 0 ? i : []).filter((o) => this.astReflection.isSubtype(o.type, r));
    }) : (n = this.symbolIndex.get(e)) !== null && n !== void 0 ? n : [];
  }
  remove(e) {
    const r = e.toString();
    this.symbolIndex.delete(r), this.symbolByTypeIndex.clear(r), this.referenceIndex.delete(r);
  }
  async updateContent(e, r = Vr.None) {
    const a = await this.serviceRegistry.getServices(e.uri).references.ScopeComputation.computeExports(e, r), i = e.uri.toString();
    this.symbolIndex.set(i, a), this.symbolByTypeIndex.clear(i);
  }
  async updateReferences(e, r = Vr.None) {
    const a = await this.serviceRegistry.getServices(e.uri).workspace.ReferenceDescriptionProvider.createDescriptions(e, r);
    this.referenceIndex.set(e.uri.toString(), a);
  }
  isAffected(e, r) {
    const n = this.referenceIndex.get(e.uri.toString());
    return n ? n.some((a) => !a.local && r.has(a.targetUri.toString())) : !1;
  }
}
class f6e {
  constructor(e) {
    this.initialBuildOptions = {}, this._ready = new Y3(), this.serviceRegistry = e.ServiceRegistry, this.langiumDocuments = e.workspace.LangiumDocuments, this.documentBuilder = e.workspace.DocumentBuilder, this.fileSystemProvider = e.workspace.FileSystemProvider, this.mutex = e.workspace.WorkspaceLock;
  }
  get ready() {
    return this._ready.promise;
  }
  get workspaceFolders() {
    return this.folders;
  }
  initialize(e) {
    var r;
    this.folders = (r = e.workspaceFolders) !== null && r !== void 0 ? r : void 0;
  }
  initialized(e) {
    return this.mutex.write((r) => {
      var n;
      return this.initializeWorkspace((n = this.folders) !== null && n !== void 0 ? n : [], r);
    });
  }
  async initializeWorkspace(e, r = Vr.None) {
    const n = await this.performStartup(e);
    await Qa(r), await this.documentBuilder.build(n, this.initialBuildOptions, r);
  }
  /**
   * Performs the uninterruptable startup sequence of the workspace manager.
   * This methods loads all documents in the workspace and other documents and returns them.
   */
  async performStartup(e) {
    const r = this.serviceRegistry.all.flatMap((i) => i.LanguageMetaData.fileExtensions), n = [], a = (i) => {
      n.push(i), this.langiumDocuments.hasDocument(i.uri) || this.langiumDocuments.addDocument(i);
    };
    return await this.loadAdditionalDocuments(e, a), await Promise.all(e.map((i) => [i, this.getRootFolder(i)]).map(async (i) => this.traverseFolder(...i, r, a))), this._ready.resolve(), n;
  }
  /**
   * Load all additional documents that shall be visible in the context of the given workspace
   * folders and add them to the collector. This can be used to include built-in libraries of
   * your language, which can be either loaded from provided files or constructed in memory.
   */
  loadAdditionalDocuments(e, r) {
    return Promise.resolve();
  }
  /**
   * Determine the root folder of the source documents in the given workspace folder.
   * The default implementation returns the URI of the workspace folder, but you can override
   * this to return a subfolder like `src` instead.
   */
  getRootFolder(e) {
    return gu.parse(e.uri);
  }
  /**
   * Traverse the file system folder identified by the given URI and its subfolders. All
   * contained files that match the file extensions are added to the collector.
   */
  async traverseFolder(e, r, n, a) {
    const i = await this.fileSystemProvider.readDirectory(r);
    await Promise.all(i.map(async (s) => {
      if (this.includeEntry(e, s, n)) {
        if (s.isDirectory)
          await this.traverseFolder(e, s.uri, n, a);
        else if (s.isFile) {
          const o = await this.langiumDocuments.getOrCreateDocument(s.uri);
          a(o);
        }
      }
    }));
  }
  /**
   * Determine whether the given folder entry shall be included while indexing the workspace.
   */
  includeEntry(e, r, n) {
    const a = nl.basename(r.uri);
    if (a.startsWith("."))
      return !1;
    if (r.isDirectory)
      return a !== "node_modules" && a !== "out";
    if (r.isFile) {
      const i = nl.extname(r.uri);
      return n.includes(i);
    }
    return !1;
  }
}
class h6e {
  buildUnexpectedCharactersMessage(e, r, n, a, i) {
    return q4.buildUnexpectedCharactersMessage(e, r, n, a, i);
  }
  buildUnableToPopLexerModeMessage(e) {
    return q4.buildUnableToPopLexerModeMessage(e);
  }
}
const d6e = { mode: "full" };
class p6e {
  constructor(e) {
    this.errorMessageProvider = e.parser.LexerErrorMessageProvider, this.tokenBuilder = e.parser.TokenBuilder;
    const r = this.tokenBuilder.buildTokens(e.Grammar, {
      caseInsensitive: e.LanguageMetaData.caseInsensitive
    });
    this.tokenTypes = this.toTokenTypeDictionary(r);
    const n = b8(r) ? Object.values(r) : r, a = e.LanguageMetaData.mode === "production";
    this.chevrotainLexer = new ka(n, {
      positionTracking: "full",
      skipValidations: a,
      errorMessageProvider: this.errorMessageProvider
    });
  }
  get definition() {
    return this.tokenTypes;
  }
  tokenize(e, r = d6e) {
    var n, a, i;
    const s = this.chevrotainLexer.tokenize(e);
    return {
      tokens: s.tokens,
      errors: s.errors,
      hidden: (n = s.groups.hidden) !== null && n !== void 0 ? n : [],
      report: (i = (a = this.tokenBuilder).flushLexingReport) === null || i === void 0 ? void 0 : i.call(a, e)
    };
  }
  toTokenTypeDictionary(e) {
    if (b8(e))
      return e;
    const r = HU(e) ? Object.values(e.modes).flat() : e, n = {};
    return r.forEach((a) => n[a.name] = a), n;
  }
}
function g6e(t) {
  return Array.isArray(t) && (t.length === 0 || "name" in t[0]);
}
function HU(t) {
  return t && "modes" in t && "defaultMode" in t;
}
function b8(t) {
  return !g6e(t) && !HU(t);
}
function v6e(t, e, r) {
  let n, a;
  typeof t == "string" ? (a = e, n = r) : (a = t.range.start, n = e), a || (a = cr.create(0, 0));
  const i = VU(t), s = X3(n), o = b6e({
    lines: i,
    position: a,
    options: s
  });
  return S6e({
    index: 0,
    tokens: o,
    position: a
  });
}
function m6e(t, e) {
  const r = X3(e), n = VU(t);
  if (n.length === 0)
    return !1;
  const a = n[0], i = n[n.length - 1], s = r.start, o = r.end;
  return !!(s != null && s.exec(a)) && !!(o != null && o.exec(i));
}
function VU(t) {
  let e = "";
  return typeof t == "string" ? e = t : e = t.text, e.split(jCe);
}
const x8 = /\s*(@([\p{L}][\p{L}\p{N}]*)?)/uy, y6e = /\{(@[\p{L}][\p{L}\p{N}]*)(\s*)([^\r\n}]+)?\}/gu;
function b6e(t) {
  var e, r, n;
  const a = [];
  let i = t.position.line, s = t.position.character;
  for (let o = 0; o < t.lines.length; o++) {
    const l = o === 0, u = o === t.lines.length - 1;
    let c = t.lines[o], f = 0;
    if (l && t.options.start) {
      const d = (e = t.options.start) === null || e === void 0 ? void 0 : e.exec(c);
      d && (f = d.index + d[0].length);
    } else {
      const d = (r = t.options.line) === null || r === void 0 ? void 0 : r.exec(c);
      d && (f = d.index + d[0].length);
    }
    if (u) {
      const d = (n = t.options.end) === null || n === void 0 ? void 0 : n.exec(c);
      d && (c = c.substring(0, d.index));
    }
    if (c = c.substring(0, T6e(c)), xS(c, f) >= c.length) {
      if (a.length > 0) {
        const d = cr.create(i, s);
        a.push({
          type: "break",
          content: "",
          range: Xt.create(d, d)
        });
      }
    } else {
      x8.lastIndex = f;
      const d = x8.exec(c);
      if (d) {
        const p = d[0], g = d[1], v = cr.create(i, s + f), m = cr.create(i, s + f + p.length);
        a.push({
          type: "tag",
          content: g,
          range: Xt.create(v, m)
        }), f += p.length, f = xS(c, f);
      }
      if (f < c.length) {
        const p = c.substring(f), g = Array.from(p.matchAll(y6e));
        a.push(...x6e(g, p, i, s + f));
      }
    }
    i++, s = 0;
  }
  return a.length > 0 && a[a.length - 1].type === "break" ? a.slice(0, -1) : a;
}
function x6e(t, e, r, n) {
  const a = [];
  if (t.length === 0) {
    const i = cr.create(r, n), s = cr.create(r, n + e.length);
    a.push({
      type: "text",
      content: e,
      range: Xt.create(i, s)
    });
  } else {
    let i = 0;
    for (const o of t) {
      const l = o.index, u = e.substring(i, l);
      u.length > 0 && a.push({
        type: "text",
        content: e.substring(i, l),
        range: Xt.create(cr.create(r, i + n), cr.create(r, l + n))
      });
      let c = u.length + 1;
      const f = o[1];
      if (a.push({
        type: "inline-tag",
        content: f,
        range: Xt.create(cr.create(r, i + c + n), cr.create(r, i + c + f.length + n))
      }), c += f.length, o.length === 4) {
        c += o[2].length;
        const h = o[3];
        a.push({
          type: "text",
          content: h,
          range: Xt.create(cr.create(r, i + c + n), cr.create(r, i + c + h.length + n))
        });
      } else
        a.push({
          type: "text",
          content: "",
          range: Xt.create(cr.create(r, i + c + n), cr.create(r, i + c + n))
        });
      i = l + o[0].length;
    }
    const s = e.substring(i);
    s.length > 0 && a.push({
      type: "text",
      content: s,
      range: Xt.create(cr.create(r, i + n), cr.create(r, i + n + s.length))
    });
  }
  return a;
}
const w6e = /\S/, E6e = /\s*$/;
function xS(t, e) {
  const r = t.substring(e).match(w6e);
  return r ? e + r.index : t.length;
}
function T6e(t) {
  const e = t.match(E6e);
  if (e && typeof e.index == "number")
    return e.index;
}
function S6e(t) {
  var e, r, n, a;
  const i = cr.create(t.position.line, t.position.character);
  if (t.tokens.length === 0)
    return new w8([], Xt.create(i, i));
  const s = [];
  for (; t.index < t.tokens.length; ) {
    const u = C6e(t, s[s.length - 1]);
    u && s.push(u);
  }
  const o = (r = (e = s[0]) === null || e === void 0 ? void 0 : e.range.start) !== null && r !== void 0 ? r : i, l = (a = (n = s[s.length - 1]) === null || n === void 0 ? void 0 : n.range.end) !== null && a !== void 0 ? a : i;
  return new w8(s, Xt.create(o, l));
}
function C6e(t, e) {
  const r = t.tokens[t.index];
  if (r.type === "tag")
    return WU(t, !1);
  if (r.type === "text" || r.type === "inline-tag")
    return qU(t);
  A6e(r, e), t.index++;
}
function A6e(t, e) {
  if (e) {
    const r = new YU("", t.range);
    "inlines" in e ? e.inlines.push(r) : e.content.inlines.push(r);
  }
}
function qU(t) {
  let e = t.tokens[t.index];
  const r = e;
  let n = e;
  const a = [];
  for (; e && e.type !== "break" && e.type !== "tag"; )
    a.push(k6e(t)), n = e, e = t.tokens[t.index];
  return new wS(a, Xt.create(r.range.start, n.range.end));
}
function k6e(t) {
  return t.tokens[t.index].type === "inline-tag" ? WU(t, !0) : jU(t);
}
function WU(t, e) {
  const r = t.tokens[t.index++], n = r.content.substring(1), a = t.tokens[t.index];
  if ((a == null ? void 0 : a.type) === "text")
    if (e) {
      const i = jU(t);
      return new Kw(n, new wS([i], i.range), e, Xt.create(r.range.start, i.range.end));
    } else {
      const i = qU(t);
      return new Kw(n, i, e, Xt.create(r.range.start, i.range.end));
    }
  else {
    const i = r.range;
    return new Kw(n, new wS([], i), e, i);
  }
}
function jU(t) {
  const e = t.tokens[t.index++];
  return new YU(e.content, e.range);
}
function X3(t) {
  if (!t)
    return X3({
      start: "/**",
      end: "*/",
      line: "*"
    });
  const { start: e, end: r, line: n } = t;
  return {
    start: Xw(e, !0),
    end: Xw(r, !1),
    line: Xw(n, !0)
  };
}
function Xw(t, e) {
  if (typeof t == "string" || typeof t == "object") {
    const r = typeof t == "string" ? vb(t) : t.source;
    return e ? new RegExp(`^\\s*${r}`) : new RegExp(`\\s*${r}\\s*$`);
  } else
    return t;
}
class w8 {
  constructor(e, r) {
    this.elements = e, this.range = r;
  }
  getTag(e) {
    return this.getAllTags().find((r) => r.name === e);
  }
  getTags(e) {
    return this.getAllTags().filter((r) => r.name === e);
  }
  getAllTags() {
    return this.elements.filter((e) => "name" in e);
  }
  toString() {
    let e = "";
    for (const r of this.elements)
      if (e.length === 0)
        e = r.toString();
      else {
        const n = r.toString();
        e += E8(e) + n;
      }
    return e.trim();
  }
  toMarkdown(e) {
    let r = "";
    for (const n of this.elements)
      if (r.length === 0)
        r = n.toMarkdown(e);
      else {
        const a = n.toMarkdown(e);
        r += E8(r) + a;
      }
    return r.trim();
  }
}
class Kw {
  constructor(e, r, n, a) {
    this.name = e, this.content = r, this.inline = n, this.range = a;
  }
  toString() {
    let e = `@${this.name}`;
    const r = this.content.toString();
    return this.content.inlines.length === 1 ? e = `${e} ${r}` : this.content.inlines.length > 1 && (e = `${e}
${r}`), this.inline ? `{${e}}` : e;
  }
  toMarkdown(e) {
    var r, n;
    return (n = (r = e == null ? void 0 : e.renderTag) === null || r === void 0 ? void 0 : r.call(e, this)) !== null && n !== void 0 ? n : this.toMarkdownDefault(e);
  }
  toMarkdownDefault(e) {
    const r = this.content.toMarkdown(e);
    if (this.inline) {
      const i = R6e(this.name, r, e ?? {});
      if (typeof i == "string")
        return i;
    }
    let n = "";
    (e == null ? void 0 : e.tag) === "italic" || (e == null ? void 0 : e.tag) === void 0 ? n = "*" : (e == null ? void 0 : e.tag) === "bold" ? n = "**" : (e == null ? void 0 : e.tag) === "bold-italic" && (n = "***");
    let a = `${n}@${this.name}${n}`;
    return this.content.inlines.length === 1 ? a = `${a} — ${r}` : this.content.inlines.length > 1 && (a = `${a}
${r}`), this.inline ? `{${a}}` : a;
  }
}
function R6e(t, e, r) {
  var n, a;
  if (t === "linkplain" || t === "linkcode" || t === "link") {
    const i = e.indexOf(" ");
    let s = e;
    if (i > 0) {
      const l = xS(e, i);
      s = e.substring(l), e = e.substring(0, i);
    }
    return (t === "linkcode" || t === "link" && r.link === "code") && (s = `\`${s}\``), (a = (n = r.renderLink) === null || n === void 0 ? void 0 : n.call(r, e, s)) !== null && a !== void 0 ? a : M6e(e, s);
  }
}
function M6e(t, e) {
  try {
    return gu.parse(t, !0), `[${e}](${t})`;
  } catch {
    return t;
  }
}
class wS {
  constructor(e, r) {
    this.inlines = e, this.range = r;
  }
  toString() {
    let e = "";
    for (let r = 0; r < this.inlines.length; r++) {
      const n = this.inlines[r], a = this.inlines[r + 1];
      e += n.toString(), a && a.range.start.line > n.range.start.line && (e += `
`);
    }
    return e;
  }
  toMarkdown(e) {
    let r = "";
    for (let n = 0; n < this.inlines.length; n++) {
      const a = this.inlines[n], i = this.inlines[n + 1];
      r += a.toMarkdown(e), i && i.range.start.line > a.range.start.line && (r += `
`);
    }
    return r;
  }
}
class YU {
  constructor(e, r) {
    this.text = e, this.range = r;
  }
  toString() {
    return this.text;
  }
  toMarkdown() {
    return this.text;
  }
}
function E8(t) {
  return t.endsWith(`
`) ? `
` : `

`;
}
class _6e {
  constructor(e) {
    this.indexManager = e.shared.workspace.IndexManager, this.commentProvider = e.documentation.CommentProvider;
  }
  getDocumentation(e) {
    const r = this.commentProvider.getComment(e);
    if (r && m6e(r))
      return v6e(r).toMarkdown({
        renderLink: (a, i) => this.documentationLinkRenderer(e, a, i),
        renderTag: (a) => this.documentationTagRenderer(e, a)
      });
  }
  documentationLinkRenderer(e, r, n) {
    var a;
    const i = (a = this.findNameInPrecomputedScopes(e, r)) !== null && a !== void 0 ? a : this.findNameInGlobalScope(e, r);
    if (i && i.nameSegment) {
      const s = i.nameSegment.range.start.line + 1, o = i.nameSegment.range.start.character + 1, l = i.documentUri.with({ fragment: `L${s},${o}` });
      return `[${n}](${l.toString()})`;
    } else
      return;
  }
  documentationTagRenderer(e, r) {
  }
  findNameInPrecomputedScopes(e, r) {
    const a = Jo(e).precomputedScopes;
    if (!a)
      return;
    let i = e;
    do {
      const o = a.get(i).find((l) => l.name === r);
      if (o)
        return o;
      i = i.$container;
    } while (i);
  }
  findNameInGlobalScope(e, r) {
    return this.indexManager.allElements().find((a) => a.name === r);
  }
}
class L6e {
  constructor(e) {
    this.grammarConfig = () => e.parser.GrammarConfig;
  }
  getComment(e) {
    var r;
    return QRe(e) ? e.$comment : (r = TCe(e.$cstNode, this.grammarConfig().multilineCommentRules)) === null || r === void 0 ? void 0 : r.text;
  }
}
class N6e {
  constructor(e) {
    this.syncParser = e.parser.LangiumParser;
  }
  parse(e, r) {
    return Promise.resolve(this.syncParser.parse(e));
  }
}
class O6e {
  constructor() {
    this.previousTokenSource = new j3(), this.writeQueue = [], this.readQueue = [], this.done = !0;
  }
  write(e) {
    this.cancelWrite();
    const r = FRe();
    return this.previousTokenSource = r, this.enqueue(this.writeQueue, e, r.token);
  }
  read(e) {
    return this.enqueue(this.readQueue, e);
  }
  enqueue(e, r, n = Vr.None) {
    const a = new Y3(), i = {
      action: r,
      deferred: a,
      cancellationToken: n
    };
    return e.push(i), this.performNextOperation(), a.promise;
  }
  async performNextOperation() {
    if (!this.done)
      return;
    const e = [];
    if (this.writeQueue.length > 0)
      e.push(this.writeQueue.shift());
    else if (this.readQueue.length > 0)
      e.push(...this.readQueue.splice(0, this.readQueue.length));
    else
      return;
    this.done = !1, await Promise.all(e.map(async ({ action: r, deferred: n, cancellationToken: a }) => {
      try {
        const i = await Promise.resolve().then(() => r(a));
        n.resolve(i);
      } catch (i) {
        Ab(i) ? n.resolve(void 0) : n.reject(i);
      }
    })), this.done = !0, this.performNextOperation();
  }
  cancelWrite() {
    this.previousTokenSource.cancel();
  }
}
class I6e {
  constructor(e) {
    this.grammarElementIdMap = new v8(), this.tokenTypeIdMap = new v8(), this.grammar = e.Grammar, this.lexer = e.parser.Lexer, this.linker = e.references.Linker;
  }
  dehydrate(e) {
    return {
      lexerErrors: e.lexerErrors,
      lexerReport: e.lexerReport ? this.dehydrateLexerReport(e.lexerReport) : void 0,
      // We need to create shallow copies of the errors
      // The original errors inherit from the `Error` class, which is not transferable across worker threads
      parserErrors: e.parserErrors.map((r) => Object.assign(Object.assign({}, r), { message: r.message })),
      value: this.dehydrateAstNode(e.value, this.createDehyrationContext(e.value))
    };
  }
  dehydrateLexerReport(e) {
    return e;
  }
  createDehyrationContext(e) {
    const r = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
    for (const a of Cc(e))
      r.set(a, {});
    if (e.$cstNode)
      for (const a of F4(e.$cstNode))
        n.set(a, {});
    return {
      astNodes: r,
      cstNodes: n
    };
  }
  dehydrateAstNode(e, r) {
    const n = r.astNodes.get(e);
    n.$type = e.$type, n.$containerIndex = e.$containerIndex, n.$containerProperty = e.$containerProperty, e.$cstNode !== void 0 && (n.$cstNode = this.dehydrateCstNode(e.$cstNode, r));
    for (const [a, i] of Object.entries(e))
      if (!a.startsWith("$"))
        if (Array.isArray(i)) {
          const s = [];
          n[a] = s;
          for (const o of i)
            Jn(o) ? s.push(this.dehydrateAstNode(o, r)) : ps(o) ? s.push(this.dehydrateReference(o, r)) : s.push(o);
        } else Jn(i) ? n[a] = this.dehydrateAstNode(i, r) : ps(i) ? n[a] = this.dehydrateReference(i, r) : i !== void 0 && (n[a] = i);
    return n;
  }
  dehydrateReference(e, r) {
    const n = {};
    return n.$refText = e.$refText, e.$refNode && (n.$refNode = r.cstNodes.get(e.$refNode)), n;
  }
  dehydrateCstNode(e, r) {
    const n = r.cstNodes.get(e);
    return mG(e) ? n.fullText = e.fullText : n.grammarSource = this.getGrammarElementId(e.grammarSource), n.hidden = e.hidden, n.astNode = r.astNodes.get(e.astNode), v0(e) ? n.content = e.content.map((a) => this.dehydrateCstNode(a, r)) : vG(e) && (n.tokenType = e.tokenType.name, n.offset = e.offset, n.length = e.length, n.startLine = e.range.start.line, n.startColumn = e.range.start.character, n.endLine = e.range.end.line, n.endColumn = e.range.end.character), n;
  }
  hydrate(e) {
    const r = e.value, n = this.createHydrationContext(r);
    return "$cstNode" in r && this.hydrateCstNode(r.$cstNode, n), {
      lexerErrors: e.lexerErrors,
      lexerReport: e.lexerReport,
      parserErrors: e.parserErrors,
      value: this.hydrateAstNode(r, n)
    };
  }
  createHydrationContext(e) {
    const r = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
    for (const i of Cc(e))
      r.set(i, {});
    let a;
    if (e.$cstNode)
      for (const i of F4(e.$cstNode)) {
        let s;
        "fullText" in i ? (s = new AU(i.fullText), a = s) : "content" in i ? s = new q3() : "tokenType" in i && (s = this.hydrateCstLeafNode(i)), s && (n.set(i, s), s.root = a);
      }
    return {
      astNodes: r,
      cstNodes: n
    };
  }
  hydrateAstNode(e, r) {
    const n = r.astNodes.get(e);
    n.$type = e.$type, n.$containerIndex = e.$containerIndex, n.$containerProperty = e.$containerProperty, e.$cstNode && (n.$cstNode = r.cstNodes.get(e.$cstNode));
    for (const [a, i] of Object.entries(e))
      if (!a.startsWith("$"))
        if (Array.isArray(i)) {
          const s = [];
          n[a] = s;
          for (const o of i)
            Jn(o) ? s.push(this.setParent(this.hydrateAstNode(o, r), n)) : ps(o) ? s.push(this.hydrateReference(o, n, a, r)) : s.push(o);
        } else Jn(i) ? n[a] = this.setParent(this.hydrateAstNode(i, r), n) : ps(i) ? n[a] = this.hydrateReference(i, n, a, r) : i !== void 0 && (n[a] = i);
    return n;
  }
  setParent(e, r) {
    return e.$container = r, e;
  }
  hydrateReference(e, r, n, a) {
    return this.linker.buildReference(r, n, a.cstNodes.get(e.$refNode), e.$refText);
  }
  hydrateCstNode(e, r, n = 0) {
    const a = r.cstNodes.get(e);
    if (typeof e.grammarSource == "number" && (a.grammarSource = this.getGrammarElement(e.grammarSource)), a.astNode = r.astNodes.get(e.astNode), v0(a))
      for (const i of e.content) {
        const s = this.hydrateCstNode(i, r, n++);
        a.content.push(s);
      }
    return a;
  }
  hydrateCstLeafNode(e) {
    const r = this.getTokenType(e.tokenType), n = e.offset, a = e.length, i = e.startLine, s = e.startColumn, o = e.endLine, l = e.endColumn, u = e.hidden;
    return new hS(n, a, {
      start: {
        line: i,
        character: s
      },
      end: {
        line: o,
        character: l
      }
    }, r, u);
  }
  getTokenType(e) {
    return this.lexer.definition[e];
  }
  getGrammarElementId(e) {
    if (e)
      return this.grammarElementIdMap.size === 0 && this.createGrammarElementIdMap(), this.grammarElementIdMap.get(e);
  }
  getGrammarElement(e) {
    return this.grammarElementIdMap.size === 0 && this.createGrammarElementIdMap(), this.grammarElementIdMap.getKey(e);
  }
  createGrammarElementIdMap() {
    let e = 0;
    for (const r of Cc(this.grammar))
      CCe(r) && this.grammarElementIdMap.set(r, e++);
  }
}
function bl(t) {
  return {
    documentation: {
      CommentProvider: (e) => new L6e(e),
      DocumentationProvider: (e) => new _6e(e)
    },
    parser: {
      AsyncParser: (e) => new N6e(e),
      GrammarConfig: (e) => v3e(e),
      LangiumParser: (e) => TRe(e),
      CompletionParser: (e) => ERe(e),
      ValueConverter: () => new PU(),
      TokenBuilder: () => new IU(),
      Lexer: (e) => new p6e(e),
      ParserErrorMessageProvider: () => new MU(),
      LexerErrorMessageProvider: () => new h6e()
    },
    workspace: {
      AstNodeLocator: () => new o6e(),
      AstNodeDescriptionProvider: (e) => new i6e(e),
      ReferenceDescriptionProvider: (e) => new s6e(e)
    },
    references: {
      Linker: (e) => new URe(e),
      NameProvider: () => new VRe(),
      ScopeProvider: (e) => new ZRe(e),
      ScopeComputation: (e) => new WRe(e),
      References: (e) => new qRe(e)
    },
    serializer: {
      Hydrator: (e) => new I6e(e),
      JsonSerializer: (e) => new JRe(e)
    },
    validation: {
      DocumentValidator: (e) => new r6e(e),
      ValidationRegistry: (e) => new t6e(e)
    },
    shared: () => t.shared
  };
}
function xl(t) {
  return {
    ServiceRegistry: (e) => new e6e(e),
    workspace: {
      LangiumDocuments: (e) => new GRe(e),
      LangiumDocumentFactory: (e) => new zRe(e),
      DocumentBuilder: (e) => new u6e(e),
      IndexManager: (e) => new c6e(e),
      WorkspaceManager: (e) => new f6e(e),
      FileSystemProvider: (e) => t.fileSystemProvider(e),
      WorkspaceLock: () => new O6e(),
      ConfigurationProvider: (e) => new l6e(e)
    }
  };
}
var T8;
(function(t) {
  t.merge = (e, r) => yy(yy({}, e), r);
})(T8 || (T8 = {}));
function ra(t, e, r, n, a, i, s, o, l) {
  const u = [t, e, r, n, a, i, s, o, l].reduce(yy, {});
  return XU(u);
}
const P6e = Symbol("isProxy");
function XU(t, e) {
  const r = new Proxy({}, {
    deleteProperty: () => !1,
    set: () => {
      throw new Error("Cannot set property on injected service container");
    },
    get: (n, a) => a === P6e ? !0 : C8(n, a, t, e || r),
    getOwnPropertyDescriptor: (n, a) => (C8(n, a, t, e || r), Object.getOwnPropertyDescriptor(n, a)),
    // used by for..in
    has: (n, a) => a in t,
    // used by ..in..
    ownKeys: () => [...Object.getOwnPropertyNames(t)]
    // used by for..in
  });
  return r;
}
const S8 = Symbol();
function C8(t, e, r, n) {
  if (e in t) {
    if (t[e] instanceof Error)
      throw new Error("Construction failure. Please make sure that your dependencies are constructable.", { cause: t[e] });
    if (t[e] === S8)
      throw new Error('Cycle detected. Please make "' + String(e) + '" lazy. Visit https://langium.org/docs/reference/configuration-services/#resolving-cyclic-dependencies');
    return t[e];
  } else if (e in r) {
    const a = r[e];
    t[e] = S8;
    try {
      t[e] = typeof a == "function" ? a(n) : XU(a, n);
    } catch (i) {
      throw t[e] = i instanceof Error ? i : void 0, i;
    }
    return t[e];
  } else
    return;
}
function yy(t, e) {
  if (e) {
    for (const [r, n] of Object.entries(e))
      if (n !== void 0) {
        const a = t[r];
        a !== null && n !== null && typeof a == "object" && typeof n == "object" ? t[r] = yy(a, n) : t[r] = n;
      }
  }
  return t;
}
class D6e {
  readFile() {
    throw new Error("No file system is available.");
  }
  async readDirectory() {
    return [];
  }
}
const wl = {
  fileSystemProvider: () => new D6e()
}, $6e = {
  Grammar: () => {
  },
  LanguageMetaData: () => ({
    caseInsensitive: !1,
    fileExtensions: [".langium"],
    languageId: "langium"
  })
}, F6e = {
  AstReflection: () => new SG()
};
function B6e() {
  const t = ra(xl(wl), F6e), e = ra(bl({ shared: t }), $6e);
  return t.ServiceRegistry.register(e), e;
}
function Iu(t) {
  var e;
  const r = B6e(), n = r.serializer.JsonSerializer.deserialize(t);
  return r.shared.workspace.LangiumDocumentFactory.fromModel(n, gu.parse(`memory://${(e = n.name) !== null && e !== void 0 ? e : "grammar"}.langium`)), n;
}
var z6e = Object.defineProperty, Je = (t, e) => z6e(t, "name", { value: e, configurable: !0 }), A8 = "Statement", Ov = "Architecture";
function G6e(t) {
  return es.isInstance(t, Ov);
}
Je(G6e, "isArchitecture");
var Pg = "Axis", fd = "Branch";
function U6e(t) {
  return es.isInstance(t, fd);
}
Je(U6e, "isBranch");
var Dg = "Checkout", $g = "CherryPicking", Zw = "ClassDefStatement", hd = "Commit";
function H6e(t) {
  return es.isInstance(t, hd);
}
Je(H6e, "isCommit");
var Qw = "Curve", Jw = "Edge", eE = "Entry", dd = "GitGraph";
function V6e(t) {
  return es.isInstance(t, dd);
}
Je(V6e, "isGitGraph");
var tE = "Group", Iv = "Info";
function q6e(t) {
  return es.isInstance(t, Iv);
}
Je(q6e, "isInfo");
var Fg = "Item", rE = "Junction", pd = "Merge";
function W6e(t) {
  return es.isInstance(t, pd);
}
Je(W6e, "isMerge");
var nE = "Option", Pv = "Packet";
function j6e(t) {
  return es.isInstance(t, Pv);
}
Je(j6e, "isPacket");
var Dv = "PacketBlock";
function Y6e(t) {
  return es.isInstance(t, Dv);
}
Je(Y6e, "isPacketBlock");
var $v = "Pie";
function X6e(t) {
  return es.isInstance(t, $v);
}
Je(X6e, "isPie");
var Fv = "PieSection";
function K6e(t) {
  return es.isInstance(t, Fv);
}
Je(K6e, "isPieSection");
var aE = "Radar", iE = "Service", Bv = "Treemap";
function Z6e(t) {
  return es.isInstance(t, Bv);
}
Je(Z6e, "isTreemap");
var sE = "TreemapRow", Bg = "Direction", zg = "Leaf", Gg = "Section", kc, KU = (kc = class extends gG {
  getAllTypes() {
    return [Ov, Pg, fd, Dg, $g, Zw, hd, Qw, Bg, Jw, eE, dd, tE, Iv, Fg, rE, zg, pd, nE, Pv, Dv, $v, Fv, aE, Gg, iE, A8, Bv, sE];
  }
  computeIsSubtype(e, r) {
    switch (e) {
      case fd:
      case Dg:
      case $g:
      case hd:
      case pd:
        return this.isSubtype(A8, r);
      case Bg:
        return this.isSubtype(dd, r);
      case zg:
      case Gg:
        return this.isSubtype(Fg, r);
      default:
        return !1;
    }
  }
  getReferenceType(e) {
    const r = `${e.container.$type}:${e.property}`;
    switch (r) {
      case "Entry:axis":
        return Pg;
      default:
        throw new Error(`${r} is not a valid reference id.`);
    }
  }
  getTypeMetaData(e) {
    switch (e) {
      case Ov:
        return {
          name: Ov,
          properties: [
            { name: "accDescr" },
            { name: "accTitle" },
            { name: "edges", defaultValue: [] },
            { name: "groups", defaultValue: [] },
            { name: "junctions", defaultValue: [] },
            { name: "services", defaultValue: [] },
            { name: "title" }
          ]
        };
      case Pg:
        return {
          name: Pg,
          properties: [
            { name: "label" },
            { name: "name" }
          ]
        };
      case fd:
        return {
          name: fd,
          properties: [
            { name: "name" },
            { name: "order" }
          ]
        };
      case Dg:
        return {
          name: Dg,
          properties: [
            { name: "branch" }
          ]
        };
      case $g:
        return {
          name: $g,
          properties: [
            { name: "id" },
            { name: "parent" },
            { name: "tags", defaultValue: [] }
          ]
        };
      case Zw:
        return {
          name: Zw,
          properties: [
            { name: "className" },
            { name: "styleText" }
          ]
        };
      case hd:
        return {
          name: hd,
          properties: [
            { name: "id" },
            { name: "message" },
            { name: "tags", defaultValue: [] },
            { name: "type" }
          ]
        };
      case Qw:
        return {
          name: Qw,
          properties: [
            { name: "entries", defaultValue: [] },
            { name: "label" },
            { name: "name" }
          ]
        };
      case Jw:
        return {
          name: Jw,
          properties: [
            { name: "lhsDir" },
            { name: "lhsGroup", defaultValue: !1 },
            { name: "lhsId" },
            { name: "lhsInto", defaultValue: !1 },
            { name: "rhsDir" },
            { name: "rhsGroup", defaultValue: !1 },
            { name: "rhsId" },
            { name: "rhsInto", defaultValue: !1 },
            { name: "title" }
          ]
        };
      case eE:
        return {
          name: eE,
          properties: [
            { name: "axis" },
            { name: "value" }
          ]
        };
      case dd:
        return {
          name: dd,
          properties: [
            { name: "accDescr" },
            { name: "accTitle" },
            { name: "statements", defaultValue: [] },
            { name: "title" }
          ]
        };
      case tE:
        return {
          name: tE,
          properties: [
            { name: "icon" },
            { name: "id" },
            { name: "in" },
            { name: "title" }
          ]
        };
      case Iv:
        return {
          name: Iv,
          properties: [
            { name: "accDescr" },
            { name: "accTitle" },
            { name: "title" }
          ]
        };
      case Fg:
        return {
          name: Fg,
          properties: [
            { name: "classSelector" },
            { name: "name" }
          ]
        };
      case rE:
        return {
          name: rE,
          properties: [
            { name: "id" },
            { name: "in" }
          ]
        };
      case pd:
        return {
          name: pd,
          properties: [
            { name: "branch" },
            { name: "id" },
            { name: "tags", defaultValue: [] },
            { name: "type" }
          ]
        };
      case nE:
        return {
          name: nE,
          properties: [
            { name: "name" },
            { name: "value", defaultValue: !1 }
          ]
        };
      case Pv:
        return {
          name: Pv,
          properties: [
            { name: "accDescr" },
            { name: "accTitle" },
            { name: "blocks", defaultValue: [] },
            { name: "title" }
          ]
        };
      case Dv:
        return {
          name: Dv,
          properties: [
            { name: "bits" },
            { name: "end" },
            { name: "label" },
            { name: "start" }
          ]
        };
      case $v:
        return {
          name: $v,
          properties: [
            { name: "accDescr" },
            { name: "accTitle" },
            { name: "sections", defaultValue: [] },
            { name: "showData", defaultValue: !1 },
            { name: "title" }
          ]
        };
      case Fv:
        return {
          name: Fv,
          properties: [
            { name: "label" },
            { name: "value" }
          ]
        };
      case aE:
        return {
          name: aE,
          properties: [
            { name: "accDescr" },
            { name: "accTitle" },
            { name: "axes", defaultValue: [] },
            { name: "curves", defaultValue: [] },
            { name: "options", defaultValue: [] },
            { name: "title" }
          ]
        };
      case iE:
        return {
          name: iE,
          properties: [
            { name: "icon" },
            { name: "iconText" },
            { name: "id" },
            { name: "in" },
            { name: "title" }
          ]
        };
      case Bv:
        return {
          name: Bv,
          properties: [
            { name: "accDescr" },
            { name: "accTitle" },
            { name: "title" },
            { name: "TreemapRows", defaultValue: [] }
          ]
        };
      case sE:
        return {
          name: sE,
          properties: [
            { name: "indent" },
            { name: "item" }
          ]
        };
      case Bg:
        return {
          name: Bg,
          properties: [
            { name: "accDescr" },
            { name: "accTitle" },
            { name: "dir" },
            { name: "statements", defaultValue: [] },
            { name: "title" }
          ]
        };
      case zg:
        return {
          name: zg,
          properties: [
            { name: "classSelector" },
            { name: "name" },
            { name: "value" }
          ]
        };
      case Gg:
        return {
          name: Gg,
          properties: [
            { name: "classSelector" },
            { name: "name" }
          ]
        };
      default:
        return {
          name: e,
          properties: []
        };
    }
  }
}, Je(kc, "MermaidAstReflection"), kc), es = new KU(), k8, Q6e = /* @__PURE__ */ Je(() => k8 ?? (k8 = Iu(`{"$type":"Grammar","isDeclared":true,"name":"Info","imports":[],"rules":[{"$type":"ParserRule","entry":true,"name":"Info","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[],"cardinality":"*"},{"$type":"Keyword","value":"info"},{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[],"cardinality":"*"},{"$type":"Group","elements":[{"$type":"Keyword","value":"showInfo"},{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[],"cardinality":"*"}],"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[],"cardinality":"?"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"EOL","dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"BOOLEAN","type":{"$type":"ReturnType","name":"boolean"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"true"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"false"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"FLOAT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/[0-9]+\\\\.[0-9]+(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"INT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/0|[1-9][0-9]*(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@7"}},{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@8"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STRING","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/\\"([^\\"\\\\\\\\]|\\\\\\\\.)*\\"|'([^'\\\\\\\\]|\\\\\\\\.)*'/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/[\\\\w]([-\\\\w]*\\\\w)?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\t ]*\\\\r?\\\\n(?:[\\\\S\\\\s]*?\\\\r?\\\\n)?---(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%{[\\\\S\\\\s]*?}%%(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%[^\\\\n\\\\r]*/"},"fragment":false}],"definesHiddenTokens":false,"hiddenTokens":[],"interfaces":[],"types":[],"usedGrammars":[]}`)), "InfoGrammar"), R8, J6e = /* @__PURE__ */ Je(() => R8 ?? (R8 = Iu(`{"$type":"Grammar","isDeclared":true,"name":"Packet","imports":[],"rules":[{"$type":"ParserRule","entry":true,"name":"Packet","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[],"cardinality":"*"},{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"packet"},{"$type":"Keyword","value":"packet-beta"}]},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]},{"$type":"Assignment","feature":"blocks","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[]}],"cardinality":"*"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"PacketBlock","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"Assignment","feature":"start","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":"-"},{"$type":"Assignment","feature":"end","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}}],"cardinality":"?"}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"+"},{"$type":"Assignment","feature":"bits","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}}]}]},{"$type":"Keyword","value":":"},{"$type":"Assignment","feature":"label","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@11"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"EOL","dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@7"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"BOOLEAN","type":{"$type":"ReturnType","name":"boolean"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"true"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"false"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"FLOAT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/[0-9]+\\\\.[0-9]+(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"INT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/0|[1-9][0-9]*(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@8"}},{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@9"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STRING","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/\\"([^\\"\\\\\\\\]|\\\\\\\\.)*\\"|'([^'\\\\\\\\]|\\\\\\\\.)*'/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/[\\\\w]([-\\\\w]*\\\\w)?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\t ]*\\\\r?\\\\n(?:[\\\\S\\\\s]*?\\\\r?\\\\n)?---(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%{[\\\\S\\\\s]*?}%%(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%[^\\\\n\\\\r]*/"},"fragment":false}],"definesHiddenTokens":false,"hiddenTokens":[],"interfaces":[],"types":[],"usedGrammars":[]}`)), "PacketGrammar"), M8, e7e = /* @__PURE__ */ Je(() => M8 ?? (M8 = Iu(`{"$type":"Grammar","isDeclared":true,"name":"Pie","imports":[],"rules":[{"$type":"ParserRule","entry":true,"name":"Pie","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@16"},"arguments":[],"cardinality":"*"},{"$type":"Keyword","value":"pie"},{"$type":"Assignment","feature":"showData","operator":"?=","terminal":{"$type":"Keyword","value":"showData"},"cardinality":"?"},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]},{"$type":"Assignment","feature":"sections","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@16"},"arguments":[]}],"cardinality":"*"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"PieSection","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"label","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@14"},"arguments":[]}},{"$type":"Keyword","value":":"},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"FLOAT_PIE","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/-?[0-9]+\\\\.[0-9]+(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"INT_PIE","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/-?(0|[1-9][0-9]*)(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER_PIE","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@2"}},{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@3"}}]},"fragment":false,"hidden":false},{"$type":"ParserRule","fragment":true,"name":"EOL","dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@16"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"BOOLEAN","type":{"$type":"ReturnType","name":"boolean"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"true"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"false"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"FLOAT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/[0-9]+\\\\.[0-9]+(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"INT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/0|[1-9][0-9]*(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@11"}},{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@12"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STRING","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/\\"([^\\"\\\\\\\\]|\\\\\\\\.)*\\"|'([^'\\\\\\\\]|\\\\\\\\.)*'/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/[\\\\w]([-\\\\w]*\\\\w)?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\t ]*\\\\r?\\\\n(?:[\\\\S\\\\s]*?\\\\r?\\\\n)?---(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%{[\\\\S\\\\s]*?}%%(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%[^\\\\n\\\\r]*/"},"fragment":false}],"definesHiddenTokens":false,"hiddenTokens":[],"interfaces":[],"types":[],"usedGrammars":[]}`)), "PieGrammar"), _8, t7e = /* @__PURE__ */ Je(() => _8 ?? (_8 = Iu(`{"$type":"Grammar","isDeclared":true,"name":"Architecture","imports":[],"rules":[{"$type":"ParserRule","entry":true,"name":"Architecture","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@23"},"arguments":[],"cardinality":"*"},{"$type":"Keyword","value":"architecture-beta"},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@23"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]}],"cardinality":"*"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"Statement","definition":{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"groups","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}},{"$type":"Assignment","feature":"services","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]}},{"$type":"Assignment","feature":"junctions","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@7"},"arguments":[]}},{"$type":"Assignment","feature":"edges","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"LeftPort","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":":"},{"$type":"Assignment","feature":"lhsDir","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"RightPort","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"rhsDir","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}},{"$type":"Keyword","value":":"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"Arrow","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]},{"$type":"Assignment","feature":"lhsInto","operator":"?=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@11"},"arguments":[]},"cardinality":"?"},{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"--"},{"$type":"Group","elements":[{"$type":"Keyword","value":"-"},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@29"},"arguments":[]}},{"$type":"Keyword","value":"-"}]}]},{"$type":"Assignment","feature":"rhsInto","operator":"?=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@11"},"arguments":[]},"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Group","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"group"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}},{"$type":"Assignment","feature":"icon","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@28"},"arguments":[]},"cardinality":"?"},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@29"},"arguments":[]},"cardinality":"?"},{"$type":"Group","elements":[{"$type":"Keyword","value":"in"},{"$type":"Assignment","feature":"in","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}}],"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Service","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"service"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}},{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"iconText","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@21"},"arguments":[]}},{"$type":"Assignment","feature":"icon","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@28"},"arguments":[]}}],"cardinality":"?"},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@29"},"arguments":[]},"cardinality":"?"},{"$type":"Group","elements":[{"$type":"Keyword","value":"in"},{"$type":"Assignment","feature":"in","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}}],"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Junction","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"junction"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":"in"},{"$type":"Assignment","feature":"in","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}}],"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Edge","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"lhsId","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}},{"$type":"Assignment","feature":"lhsGroup","operator":"?=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]},"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]},{"$type":"Assignment","feature":"rhsId","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}},{"$type":"Assignment","feature":"rhsGroup","operator":"?=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]},"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"ARROW_DIRECTION","definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"L"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"R"}}]},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"T"}}]},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"B"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ARROW_GROUP","definition":{"$type":"RegexToken","regex":"/\\\\{group\\\\}/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ARROW_INTO","definition":{"$type":"RegexToken","regex":"/<|>/"},"fragment":false,"hidden":false},{"$type":"ParserRule","fragment":true,"name":"EOL","dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@23"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@15"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@16"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"BOOLEAN","type":{"$type":"ReturnType","name":"boolean"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"true"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"false"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"FLOAT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/[0-9]+\\\\.[0-9]+(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"INT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/0|[1-9][0-9]*(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@18"}},{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@19"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STRING","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/\\"([^\\"\\\\\\\\]|\\\\\\\\.)*\\"|'([^'\\\\\\\\]|\\\\\\\\.)*'/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/[\\\\w]([-\\\\w]*\\\\w)?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\t ]*\\\\r?\\\\n(?:[\\\\S\\\\s]*?\\\\r?\\\\n)?---(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%{[\\\\S\\\\s]*?}%%(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%[^\\\\n\\\\r]*/"},"fragment":false},{"$type":"TerminalRule","name":"ARCH_ICON","definition":{"$type":"RegexToken","regex":"/\\\\([\\\\w-:]+\\\\)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ARCH_TITLE","definition":{"$type":"RegexToken","regex":"/\\\\[[\\\\w ]+\\\\]/"},"fragment":false,"hidden":false}],"definesHiddenTokens":false,"hiddenTokens":[],"interfaces":[],"types":[],"usedGrammars":[]}`)), "ArchitectureGrammar"), L8, r7e = /* @__PURE__ */ Je(() => L8 ?? (L8 = Iu(`{"$type":"Grammar","isDeclared":true,"name":"GitGraph","imports":[],"rules":[{"$type":"ParserRule","entry":true,"name":"GitGraph","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[],"cardinality":"*"},{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"gitGraph"},{"$type":"Group","elements":[{"$type":"Keyword","value":"gitGraph"},{"$type":"Keyword","value":":"}]},{"$type":"Keyword","value":"gitGraph:"},{"$type":"Group","elements":[{"$type":"Keyword","value":"gitGraph"},{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]},{"$type":"Keyword","value":":"}]}]},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]},{"$type":"Assignment","feature":"statements","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]}}],"cardinality":"*"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Statement","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@7"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Direction","definition":{"$type":"Assignment","feature":"dir","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"LR"},{"$type":"Keyword","value":"TB"},{"$type":"Keyword","value":"BT"}]}},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Commit","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"commit"},{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"Keyword","value":"id:"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"msg:","cardinality":"?"},{"$type":"Assignment","feature":"message","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"tag:"},{"$type":"Assignment","feature":"tags","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"type:"},{"$type":"Assignment","feature":"type","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"NORMAL"},{"$type":"Keyword","value":"REVERSE"},{"$type":"Keyword","value":"HIGHLIGHT"}]}}]}],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Branch","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"branch"},{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@24"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}]}},{"$type":"Group","elements":[{"$type":"Keyword","value":"order:"},{"$type":"Assignment","feature":"order","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@15"},"arguments":[]}}],"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Merge","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"merge"},{"$type":"Assignment","feature":"branch","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@24"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}]}},{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"Keyword","value":"id:"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"tag:"},{"$type":"Assignment","feature":"tags","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"type:"},{"$type":"Assignment","feature":"type","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"NORMAL"},{"$type":"Keyword","value":"REVERSE"},{"$type":"Keyword","value":"HIGHLIGHT"}]}}]}],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Checkout","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"checkout"},{"$type":"Keyword","value":"switch"}]},{"$type":"Assignment","feature":"branch","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@24"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"CherryPicking","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"cherry-pick"},{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"Keyword","value":"id:"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"tag:"},{"$type":"Assignment","feature":"tags","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"parent:"},{"$type":"Assignment","feature":"parent","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]}],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"EOL","dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@11"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"BOOLEAN","type":{"$type":"ReturnType","name":"boolean"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"true"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"false"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"FLOAT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/[0-9]+\\\\.[0-9]+(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"INT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/0|[1-9][0-9]*(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@14"}},{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@15"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STRING","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/\\"([^\\"\\\\\\\\]|\\\\\\\\.)*\\"|'([^'\\\\\\\\]|\\\\\\\\.)*'/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/[\\\\w]([-\\\\w]*\\\\w)?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\t ]*\\\\r?\\\\n(?:[\\\\S\\\\s]*?\\\\r?\\\\n)?---(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%{[\\\\S\\\\s]*?}%%(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%[^\\\\n\\\\r]*/"},"fragment":false},{"$type":"TerminalRule","name":"REFERENCE","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/\\\\w([-\\\\./\\\\w]*[-\\\\w])?/"},"fragment":false,"hidden":false}],"definesHiddenTokens":false,"hiddenTokens":[],"interfaces":[],"types":[],"usedGrammars":[]}`)), "GitGraphGrammar"), N8, n7e = /* @__PURE__ */ Je(() => N8 ?? (N8 = Iu(`{"$type":"Grammar","isDeclared":true,"name":"Radar","imports":[],"rules":[{"$type":"ParserRule","entry":true,"name":"Radar","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"},{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"radar-beta"},{"$type":"Keyword","value":"radar-beta:"},{"$type":"Group","elements":[{"$type":"Keyword","value":"radar-beta"},{"$type":"Keyword","value":":"}]}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]},{"$type":"Group","elements":[{"$type":"Keyword","value":"axis"},{"$type":"Assignment","feature":"axes","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":","},{"$type":"Assignment","feature":"axes","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]}}],"cardinality":"*"}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"curve"},{"$type":"Assignment","feature":"curves","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":","},{"$type":"Assignment","feature":"curves","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]}}],"cardinality":"*"}]},{"$type":"Group","elements":[{"$type":"Assignment","feature":"options","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@7"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":","},{"$type":"Assignment","feature":"options","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@7"},"arguments":[]}}],"cardinality":"*"}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[]}],"cardinality":"*"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"Label","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"["},{"$type":"Assignment","feature":"label","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@18"},"arguments":[]}},{"$type":"Keyword","value":"]"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Axis","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[],"cardinality":"?"}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Curve","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[],"cardinality":"?"},{"$type":"Keyword","value":"{"},{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]},{"$type":"Keyword","value":"}"}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"Entries","definition":{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"},{"$type":"Assignment","feature":"entries","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":","},{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"},{"$type":"Assignment","feature":"entries","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]}}],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"}]},{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"},{"$type":"Assignment","feature":"entries","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":","},{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"},{"$type":"Assignment","feature":"entries","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}}],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"}]}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"DetailedEntry","returnType":{"$ref":"#/interfaces@0"},"definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"axis","operator":"=","terminal":{"$type":"CrossReference","type":{"$ref":"#/rules@2"},"terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[]},"deprecatedSyntax":false}},{"$type":"Keyword","value":":","cardinality":"?"},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"NumberEntry","returnType":{"$ref":"#/interfaces@0"},"definition":{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Option","definition":{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"Keyword","value":"showLegend"}},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@11"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"Keyword","value":"ticks"}},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"Keyword","value":"max"}},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"Keyword","value":"min"}},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"Keyword","value":"graticule"}},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}}]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"GRATICULE","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"circle"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"polygon"}}]},"fragment":false,"hidden":false},{"$type":"ParserRule","fragment":true,"name":"EOL","dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@14"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"BOOLEAN","type":{"$type":"ReturnType","name":"boolean"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"true"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"false"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"FLOAT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/[0-9]+\\\\.[0-9]+(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"INT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/0|[1-9][0-9]*(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@15"}},{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@16"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STRING","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/\\"([^\\"\\\\\\\\]|\\\\\\\\.)*\\"|'([^'\\\\\\\\]|\\\\\\\\.)*'/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/[\\\\w]([-\\\\w]*\\\\w)?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\t ]*\\\\r?\\\\n(?:[\\\\S\\\\s]*?\\\\r?\\\\n)?---(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%{[\\\\S\\\\s]*?}%%(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%[^\\\\n\\\\r]*/"},"fragment":false}],"interfaces":[{"$type":"Interface","name":"Entry","attributes":[{"$type":"TypeAttribute","name":"axis","isOptional":true,"type":{"$type":"ReferenceType","referenceType":{"$type":"SimpleType","typeRef":{"$ref":"#/rules@2"}}}},{"$type":"TypeAttribute","name":"value","type":{"$type":"SimpleType","primitiveType":"number"},"isOptional":false}],"superTypes":[]}],"definesHiddenTokens":false,"hiddenTokens":[],"types":[],"usedGrammars":[]}`)), "RadarGrammar"), O8, a7e = /* @__PURE__ */ Je(() => O8 ?? (O8 = Iu(`{"$type":"Grammar","isDeclared":true,"name":"Treemap","rules":[{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]}}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"BOOLEAN","type":{"$type":"ReturnType","name":"boolean"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"true"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"false"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"ParserRule","entry":true,"name":"Treemap","returnType":{"$ref":"#/interfaces@4"},"definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@0"},"arguments":[]},{"$type":"Assignment","feature":"TreemapRows","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@14"},"arguments":[]}}],"cardinality":"*"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"TREEMAP_KEYWORD","definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"treemap-beta"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"treemap"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"CLASS_DEF","definition":{"$type":"RegexToken","regex":"/classDef\\\\s+([a-zA-Z_][a-zA-Z0-9_]+)(?:\\\\s+([^;\\\\r\\\\n]*))?(?:;)?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STYLE_SEPARATOR","definition":{"$type":"CharacterRange","left":{"$type":"Keyword","value":":::"}},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"SEPARATOR","definition":{"$type":"CharacterRange","left":{"$type":"Keyword","value":":"}},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"COMMA","definition":{"$type":"CharacterRange","left":{"$type":"Keyword","value":","}},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WS","definition":{"$type":"RegexToken","regex":"/[ \\\\t]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"ML_COMMENT","definition":{"$type":"RegexToken","regex":"/\\\\%\\\\%[^\\\\n]*/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"NL","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false},{"$type":"ParserRule","name":"TreemapRow","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"indent","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[]},"cardinality":"?"},{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"item","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@16"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@15"},"arguments":[]}]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"ClassDef","dataType":"string","definition":{"$type":"RuleCall","rule":{"$ref":"#/rules@7"},"arguments":[]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Item","returnType":{"$ref":"#/interfaces@0"},"definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@18"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Section","returnType":{"$ref":"#/interfaces@1"},"definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@23"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]},{"$type":"Assignment","feature":"classSelector","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[]}}],"cardinality":"?"}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Leaf","returnType":{"$ref":"#/interfaces@2"},"definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@23"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[],"cardinality":"?"},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[],"cardinality":"?"},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]},{"$type":"Assignment","feature":"classSelector","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[]}}],"cardinality":"?"}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"INDENTATION","definition":{"$type":"RegexToken","regex":"/[ \\\\t]{1,}/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID2","definition":{"$type":"RegexToken","regex":"/[a-zA-Z_][a-zA-Z0-9_]*/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER2","definition":{"$type":"RegexToken","regex":"/[0-9_\\\\.\\\\,]+/"},"fragment":false,"hidden":false},{"$type":"ParserRule","name":"MyNumber","dataType":"number","definition":{"$type":"RuleCall","rule":{"$ref":"#/rules@21"},"arguments":[]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"STRING2","definition":{"$type":"RegexToken","regex":"/\\"[^\\"]*\\"|'[^']*'/"},"fragment":false,"hidden":false}],"interfaces":[{"$type":"Interface","name":"Item","attributes":[{"$type":"TypeAttribute","name":"name","type":{"$type":"SimpleType","primitiveType":"string"},"isOptional":false},{"$type":"TypeAttribute","name":"classSelector","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}}],"superTypes":[]},{"$type":"Interface","name":"Section","superTypes":[{"$ref":"#/interfaces@0"}],"attributes":[]},{"$type":"Interface","name":"Leaf","superTypes":[{"$ref":"#/interfaces@0"}],"attributes":[{"$type":"TypeAttribute","name":"value","type":{"$type":"SimpleType","primitiveType":"number"},"isOptional":false}]},{"$type":"Interface","name":"ClassDefStatement","attributes":[{"$type":"TypeAttribute","name":"className","type":{"$type":"SimpleType","primitiveType":"string"},"isOptional":false},{"$type":"TypeAttribute","name":"styleText","type":{"$type":"SimpleType","primitiveType":"string"},"isOptional":false}],"superTypes":[]},{"$type":"Interface","name":"Treemap","attributes":[{"$type":"TypeAttribute","name":"TreemapRows","type":{"$type":"ArrayType","elementType":{"$type":"SimpleType","typeRef":{"$ref":"#/rules@14"}}},"isOptional":false},{"$type":"TypeAttribute","name":"title","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}},{"$type":"TypeAttribute","name":"accTitle","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}},{"$type":"TypeAttribute","name":"accDescr","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}}],"superTypes":[]}],"definesHiddenTokens":false,"hiddenTokens":[],"imports":[],"types":[],"usedGrammars":[],"$comment":"/**\\n * Treemap grammar for Langium\\n * Converted from mindmap grammar\\n *\\n * The ML_COMMENT and NL hidden terminals handle whitespace, comments, and newlines\\n * before the treemap keyword, allowing for empty lines and comments before the\\n * treemap declaration.\\n */"}`)), "TreemapGrammar"), i7e = {
  languageId: "info",
  fileExtensions: [".mmd", ".mermaid"],
  caseInsensitive: !1,
  mode: "production"
}, s7e = {
  languageId: "packet",
  fileExtensions: [".mmd", ".mermaid"],
  caseInsensitive: !1,
  mode: "production"
}, o7e = {
  languageId: "pie",
  fileExtensions: [".mmd", ".mermaid"],
  caseInsensitive: !1,
  mode: "production"
}, l7e = {
  languageId: "architecture",
  fileExtensions: [".mmd", ".mermaid"],
  caseInsensitive: !1,
  mode: "production"
}, u7e = {
  languageId: "gitGraph",
  fileExtensions: [".mmd", ".mermaid"],
  caseInsensitive: !1,
  mode: "production"
}, c7e = {
  languageId: "radar",
  fileExtensions: [".mmd", ".mermaid"],
  caseInsensitive: !1,
  mode: "production"
}, f7e = {
  languageId: "treemap",
  fileExtensions: [".mmd", ".mermaid"],
  caseInsensitive: !1,
  mode: "production"
}, Pu = {
  AstReflection: /* @__PURE__ */ Je(() => new KU(), "AstReflection")
}, h7e = {
  Grammar: /* @__PURE__ */ Je(() => Q6e(), "Grammar"),
  LanguageMetaData: /* @__PURE__ */ Je(() => i7e, "LanguageMetaData"),
  parser: {}
}, d7e = {
  Grammar: /* @__PURE__ */ Je(() => J6e(), "Grammar"),
  LanguageMetaData: /* @__PURE__ */ Je(() => s7e, "LanguageMetaData"),
  parser: {}
}, p7e = {
  Grammar: /* @__PURE__ */ Je(() => e7e(), "Grammar"),
  LanguageMetaData: /* @__PURE__ */ Je(() => o7e, "LanguageMetaData"),
  parser: {}
}, g7e = {
  Grammar: /* @__PURE__ */ Je(() => t7e(), "Grammar"),
  LanguageMetaData: /* @__PURE__ */ Je(() => l7e, "LanguageMetaData"),
  parser: {}
}, v7e = {
  Grammar: /* @__PURE__ */ Je(() => r7e(), "Grammar"),
  LanguageMetaData: /* @__PURE__ */ Je(() => u7e, "LanguageMetaData"),
  parser: {}
}, m7e = {
  Grammar: /* @__PURE__ */ Je(() => n7e(), "Grammar"),
  LanguageMetaData: /* @__PURE__ */ Je(() => c7e, "LanguageMetaData"),
  parser: {}
}, y7e = {
  Grammar: /* @__PURE__ */ Je(() => a7e(), "Grammar"),
  LanguageMetaData: /* @__PURE__ */ Je(() => f7e, "LanguageMetaData"),
  parser: {}
}, b7e = /accDescr(?:[\t ]*:([^\n\r]*)|\s*{([^}]*)})/, x7e = /accTitle[\t ]*:([^\n\r]*)/, w7e = /title([\t ][^\n\r]*|)/, E7e = {
  ACC_DESCR: b7e,
  ACC_TITLE: x7e,
  TITLE: w7e
}, Rc, kb = (Rc = class extends PU {
  runConverter(e, r, n) {
    let a = this.runCommonConverter(e, r, n);
    return a === void 0 && (a = this.runCustomConverter(e, r, n)), a === void 0 ? super.runConverter(e, r, n) : a;
  }
  runCommonConverter(e, r, n) {
    const a = E7e[e.name];
    if (a === void 0)
      return;
    const i = a.exec(r);
    if (i !== null) {
      if (i[1] !== void 0)
        return i[1].trim().replace(/[\t ]{2,}/gm, " ");
      if (i[2] !== void 0)
        return i[2].replace(/^\s*/gm, "").replace(/\s+$/gm, "").replace(/[\t ]{2,}/gm, " ").replace(/[\n\r]{2,}/gm, `
`);
    }
  }
}, Je(Rc, "AbstractMermaidValueConverter"), Rc), Mc, Rb = (Mc = class extends kb {
  runCustomConverter(e, r, n) {
  }
}, Je(Mc, "CommonValueConverter"), Mc), _c, El = (_c = class extends IU {
  constructor(e) {
    super(), this.keywords = new Set(e);
  }
  buildKeywordTokens(e, r, n) {
    const a = super.buildKeywordTokens(e, r, n);
    return a.forEach((i) => {
      this.keywords.has(i.name) && i.PATTERN !== void 0 && (i.PATTERN = new RegExp(i.PATTERN.toString() + "(?:(?=%%)|(?!\\S))"));
    }), a;
  }
}, Je(_c, "AbstractMermaidTokenBuilder"), _c), Lc;
Lc = class extends El {
}, Je(Lc, "CommonTokenBuilder");
var Nc, T7e = (Nc = class extends El {
  constructor() {
    super(["gitGraph"]);
  }
}, Je(Nc, "GitGraphTokenBuilder"), Nc), ZU = {
  parser: {
    TokenBuilder: /* @__PURE__ */ Je(() => new T7e(), "TokenBuilder"),
    ValueConverter: /* @__PURE__ */ Je(() => new Rb(), "ValueConverter")
  }
};
function QU(t = wl) {
  const e = ra(
    xl(t),
    Pu
  ), r = ra(
    bl({ shared: e }),
    v7e,
    ZU
  );
  return e.ServiceRegistry.register(r), { shared: e, GitGraph: r };
}
Je(QU, "createGitGraphServices");
var Oc, S7e = (Oc = class extends El {
  constructor() {
    super(["info", "showInfo"]);
  }
}, Je(Oc, "InfoTokenBuilder"), Oc), JU = {
  parser: {
    TokenBuilder: /* @__PURE__ */ Je(() => new S7e(), "TokenBuilder"),
    ValueConverter: /* @__PURE__ */ Je(() => new Rb(), "ValueConverter")
  }
};
function eH(t = wl) {
  const e = ra(
    xl(t),
    Pu
  ), r = ra(
    bl({ shared: e }),
    h7e,
    JU
  );
  return e.ServiceRegistry.register(r), { shared: e, Info: r };
}
Je(eH, "createInfoServices");
var Ic, C7e = (Ic = class extends El {
  constructor() {
    super(["packet"]);
  }
}, Je(Ic, "PacketTokenBuilder"), Ic), tH = {
  parser: {
    TokenBuilder: /* @__PURE__ */ Je(() => new C7e(), "TokenBuilder"),
    ValueConverter: /* @__PURE__ */ Je(() => new Rb(), "ValueConverter")
  }
};
function rH(t = wl) {
  const e = ra(
    xl(t),
    Pu
  ), r = ra(
    bl({ shared: e }),
    d7e,
    tH
  );
  return e.ServiceRegistry.register(r), { shared: e, Packet: r };
}
Je(rH, "createPacketServices");
var Pc, A7e = (Pc = class extends El {
  constructor() {
    super(["pie", "showData"]);
  }
}, Je(Pc, "PieTokenBuilder"), Pc), Dc, k7e = (Dc = class extends kb {
  runCustomConverter(e, r, n) {
    if (e.name === "PIE_SECTION_LABEL")
      return r.replace(/"/g, "").trim();
  }
}, Je(Dc, "PieValueConverter"), Dc), nH = {
  parser: {
    TokenBuilder: /* @__PURE__ */ Je(() => new A7e(), "TokenBuilder"),
    ValueConverter: /* @__PURE__ */ Je(() => new k7e(), "ValueConverter")
  }
};
function aH(t = wl) {
  const e = ra(
    xl(t),
    Pu
  ), r = ra(
    bl({ shared: e }),
    p7e,
    nH
  );
  return e.ServiceRegistry.register(r), { shared: e, Pie: r };
}
Je(aH, "createPieServices");
var $c, R7e = ($c = class extends El {
  constructor() {
    super(["architecture"]);
  }
}, Je($c, "ArchitectureTokenBuilder"), $c), Fc, M7e = (Fc = class extends kb {
  runCustomConverter(e, r, n) {
    if (e.name === "ARCH_ICON")
      return r.replace(/[()]/g, "").trim();
    if (e.name === "ARCH_TEXT_ICON")
      return r.replace(/["()]/g, "");
    if (e.name === "ARCH_TITLE")
      return r.replace(/[[\]]/g, "").trim();
  }
}, Je(Fc, "ArchitectureValueConverter"), Fc), iH = {
  parser: {
    TokenBuilder: /* @__PURE__ */ Je(() => new R7e(), "TokenBuilder"),
    ValueConverter: /* @__PURE__ */ Je(() => new M7e(), "ValueConverter")
  }
};
function sH(t = wl) {
  const e = ra(
    xl(t),
    Pu
  ), r = ra(
    bl({ shared: e }),
    g7e,
    iH
  );
  return e.ServiceRegistry.register(r), { shared: e, Architecture: r };
}
Je(sH, "createArchitectureServices");
var Bc, _7e = (Bc = class extends El {
  constructor() {
    super(["radar-beta"]);
  }
}, Je(Bc, "RadarTokenBuilder"), Bc), oH = {
  parser: {
    TokenBuilder: /* @__PURE__ */ Je(() => new _7e(), "TokenBuilder"),
    ValueConverter: /* @__PURE__ */ Je(() => new Rb(), "ValueConverter")
  }
};
function lH(t = wl) {
  const e = ra(
    xl(t),
    Pu
  ), r = ra(
    bl({ shared: e }),
    m7e,
    oH
  );
  return e.ServiceRegistry.register(r), { shared: e, Radar: r };
}
Je(lH, "createRadarServices");
var zc, L7e = (zc = class extends El {
  constructor() {
    super(["treemap"]);
  }
}, Je(zc, "TreemapTokenBuilder"), zc), N7e = /classDef\s+([A-Z_a-z]\w+)(?:\s+([^\n\r;]*))?;?/, Gc, O7e = (Gc = class extends kb {
  runCustomConverter(e, r, n) {
    if (e.name === "NUMBER2")
      return parseFloat(r.replace(/,/g, ""));
    if (e.name === "SEPARATOR")
      return r.substring(1, r.length - 1);
    if (e.name === "STRING2")
      return r.substring(1, r.length - 1);
    if (e.name === "INDENTATION")
      return r.length;
    if (e.name === "ClassDef") {
      if (typeof r != "string")
        return r;
      const a = N7e.exec(r);
      if (a)
        return {
          $type: "ClassDefStatement",
          className: a[1],
          styleText: a[2] || void 0
        };
    }
  }
}, Je(Gc, "TreemapValueConverter"), Gc);
function uH(t) {
  const e = t.validation.TreemapValidator, r = t.validation.ValidationRegistry;
  if (r) {
    const n = {
      Treemap: e.checkSingleRoot.bind(e)
      // Remove unused validation for TreemapRow
    };
    r.register(n, e);
  }
}
Je(uH, "registerValidationChecks");
var Uc, I7e = (Uc = class {
  /**
   * Validates that a treemap has only one root node.
   * A root node is defined as a node that has no indentation.
   */
  checkSingleRoot(e, r) {
    let n;
    for (const a of e.TreemapRows)
      a.item && (n === void 0 && // Check if this is a root node (no indentation)
      a.indent === void 0 ? n = 0 : a.indent === void 0 ? r("error", "Multiple root nodes are not allowed in a treemap.", {
        node: a,
        property: "item"
      }) : n !== void 0 && n >= parseInt(a.indent, 10) && r("error", "Multiple root nodes are not allowed in a treemap.", {
        node: a,
        property: "item"
      }));
  }
}, Je(Uc, "TreemapValidator"), Uc), cH = {
  parser: {
    TokenBuilder: /* @__PURE__ */ Je(() => new L7e(), "TokenBuilder"),
    ValueConverter: /* @__PURE__ */ Je(() => new O7e(), "ValueConverter")
  },
  validation: {
    TreemapValidator: /* @__PURE__ */ Je(() => new I7e(), "TreemapValidator")
  }
};
function fH(t = wl) {
  const e = ra(
    xl(t),
    Pu
  ), r = ra(
    bl({ shared: e }),
    y7e,
    cH
  );
  return e.ServiceRegistry.register(r), uH(r), { shared: e, Treemap: r };
}
Je(fH, "createTreemapServices");
var $s = {}, P7e = {
  info: /* @__PURE__ */ Je(async () => {
    const { createInfoServices: t } = await Promise.resolve().then(() => cMe), e = t().Info.parser.LangiumParser;
    $s.info = e;
  }, "info"),
  packet: /* @__PURE__ */ Je(async () => {
    const { createPacketServices: t } = await Promise.resolve().then(() => fMe), e = t().Packet.parser.LangiumParser;
    $s.packet = e;
  }, "packet"),
  pie: /* @__PURE__ */ Je(async () => {
    const { createPieServices: t } = await Promise.resolve().then(() => hMe), e = t().Pie.parser.LangiumParser;
    $s.pie = e;
  }, "pie"),
  architecture: /* @__PURE__ */ Je(async () => {
    const { createArchitectureServices: t } = await Promise.resolve().then(() => dMe), e = t().Architecture.parser.LangiumParser;
    $s.architecture = e;
  }, "architecture"),
  gitGraph: /* @__PURE__ */ Je(async () => {
    const { createGitGraphServices: t } = await Promise.resolve().then(() => pMe), e = t().GitGraph.parser.LangiumParser;
    $s.gitGraph = e;
  }, "gitGraph"),
  radar: /* @__PURE__ */ Je(async () => {
    const { createRadarServices: t } = await Promise.resolve().then(() => gMe), e = t().Radar.parser.LangiumParser;
    $s.radar = e;
  }, "radar"),
  treemap: /* @__PURE__ */ Je(async () => {
    const { createTreemapServices: t } = await Promise.resolve().then(() => vMe), e = t().Treemap.parser.LangiumParser;
    $s.treemap = e;
  }, "treemap")
};
async function D7e(t, e) {
  const r = P7e[t];
  if (!r)
    throw new Error(`Unknown diagram type: ${t}`);
  $s[t] || await r();
  const a = $s[t].parse(e);
  if (a.lexerErrors.length > 0 || a.parserErrors.length > 0)
    throw new $7e(a);
  return a.value;
}
Je(D7e, "parse");
var Hc, $7e = (Hc = class extends Error {
  constructor(e) {
    const r = e.lexerErrors.map((a) => a.message).join(`
`), n = e.parserErrors.map((a) => a.message).join(`
`);
    super(`Parsing failed: ${r} ${n}`), this.result = e;
  }
}, Je(Hc, "MermaidParseError"), Hc), hH = { exports: {} };
(function(t, e) {
  (function(r, n) {
    t.exports = n();
  })(Jt, function() {
    var r = "day";
    return function(n, a, i) {
      var s = function(u) {
        return u.add(4 - u.isoWeekday(), r);
      }, o = a.prototype;
      o.isoWeekYear = function() {
        return s(this).year();
      }, o.isoWeek = function(u) {
        if (!this.$utils().u(u)) return this.add(7 * (u - this.isoWeek()), r);
        var c, f, h, d, p = s(this), g = (c = this.isoWeekYear(), f = this.$u, h = (f ? i.utc : i)().year(c).startOf("year"), d = 4 - h.isoWeekday(), h.isoWeekday() > 4 && (d += 7), h.add(d, r));
        return p.diff(g, "week") + 1;
      }, o.isoWeekday = function(u) {
        return this.$utils().u(u) ? this.day() || 7 : this.day(this.day() % 7 ? u : u - 7);
      };
      var l = o.startOf;
      o.startOf = function(u, c) {
        var f = this.$utils(), h = !!f.u(c) || c;
        return f.p(u) === "isoweek" ? h ? this.date(this.date() - (this.isoWeekday() - 1)).startOf("day") : this.date(this.date() - 1 - (this.isoWeekday() - 1) + 7).endOf("day") : l.bind(this)(u, c);
      };
    };
  });
})(hH);
var F7e = hH.exports;
const rLe = /* @__PURE__ */ ho(F7e);
var dH = { exports: {} };
(function(t, e) {
  (function(r, n) {
    t.exports = n();
  })(Jt, function() {
    var r = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, n = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, a = /\d/, i = /\d\d/, s = /\d\d?/, o = /\d*[^-_:/,()\s\d]+/, l = {}, u = function(v) {
      return (v = +v) + (v > 68 ? 1900 : 2e3);
    }, c = function(v) {
      return function(m) {
        this[v] = +m;
      };
    }, f = [/[+-]\d\d:?(\d\d)?|Z/, function(v) {
      (this.zone || (this.zone = {})).offset = function(m) {
        if (!m || m === "Z") return 0;
        var b = m.match(/([+-]|\d\d)/g), y = 60 * b[1] + (+b[2] || 0);
        return y === 0 ? 0 : b[0] === "+" ? -y : y;
      }(v);
    }], h = function(v) {
      var m = l[v];
      return m && (m.indexOf ? m : m.s.concat(m.f));
    }, d = function(v, m) {
      var b, y = l.meridiem;
      if (y) {
        for (var x = 1; x <= 24; x += 1) if (v.indexOf(y(x, 0, m)) > -1) {
          b = x > 12;
          break;
        }
      } else b = v === (m ? "pm" : "PM");
      return b;
    }, p = { A: [o, function(v) {
      this.afternoon = d(v, !1);
    }], a: [o, function(v) {
      this.afternoon = d(v, !0);
    }], Q: [a, function(v) {
      this.month = 3 * (v - 1) + 1;
    }], S: [a, function(v) {
      this.milliseconds = 100 * +v;
    }], SS: [i, function(v) {
      this.milliseconds = 10 * +v;
    }], SSS: [/\d{3}/, function(v) {
      this.milliseconds = +v;
    }], s: [s, c("seconds")], ss: [s, c("seconds")], m: [s, c("minutes")], mm: [s, c("minutes")], H: [s, c("hours")], h: [s, c("hours")], HH: [s, c("hours")], hh: [s, c("hours")], D: [s, c("day")], DD: [i, c("day")], Do: [o, function(v) {
      var m = l.ordinal, b = v.match(/\d+/);
      if (this.day = b[0], m) for (var y = 1; y <= 31; y += 1) m(y).replace(/\[|\]/g, "") === v && (this.day = y);
    }], w: [s, c("week")], ww: [i, c("week")], M: [s, c("month")], MM: [i, c("month")], MMM: [o, function(v) {
      var m = h("months"), b = (h("monthsShort") || m.map(function(y) {
        return y.slice(0, 3);
      })).indexOf(v) + 1;
      if (b < 1) throw new Error();
      this.month = b % 12 || b;
    }], MMMM: [o, function(v) {
      var m = h("months").indexOf(v) + 1;
      if (m < 1) throw new Error();
      this.month = m % 12 || m;
    }], Y: [/[+-]?\d+/, c("year")], YY: [i, function(v) {
      this.year = u(v);
    }], YYYY: [/\d{4}/, c("year")], Z: f, ZZ: f };
    function g(v) {
      var m, b;
      m = v, b = l && l.formats;
      for (var y = (v = m.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(N, R, _) {
        var O = _ && _.toUpperCase();
        return R || b[_] || r[_] || b[O].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(T, L, M) {
          return L || M.slice(1);
        });
      })).match(n), x = y.length, E = 0; E < x; E += 1) {
        var S = y[E], w = p[S], C = w && w[0], k = w && w[1];
        y[E] = k ? { regex: C, parser: k } : S.replace(/^\[|\]$/g, "");
      }
      return function(N) {
        for (var R = {}, _ = 0, O = 0; _ < x; _ += 1) {
          var T = y[_];
          if (typeof T == "string") O += T.length;
          else {
            var L = T.regex, M = T.parser, A = N.slice(O), I = L.exec(A)[0];
            M.call(R, I), N = N.replace(I, "");
          }
        }
        return function(D) {
          var F = D.afternoon;
          if (F !== void 0) {
            var B = D.hours;
            F ? B < 12 && (D.hours += 12) : B === 12 && (D.hours = 0), delete D.afternoon;
          }
        }(R), R;
      };
    }
    return function(v, m, b) {
      b.p.customParseFormat = !0, v && v.parseTwoDigitYear && (u = v.parseTwoDigitYear);
      var y = m.prototype, x = y.parse;
      y.parse = function(E) {
        var S = E.date, w = E.utc, C = E.args;
        this.$u = w;
        var k = C[1];
        if (typeof k == "string") {
          var N = C[2] === !0, R = C[3] === !0, _ = N || R, O = C[2];
          R && (O = C[2]), l = this.$locale(), !N && O && (l = b.Ls[O]), this.$d = function(A, I, D, F) {
            try {
              if (["x", "X"].indexOf(I) > -1) return new Date((I === "X" ? 1e3 : 1) * A);
              var B = g(I)(A), G = B.year, H = B.month, K = B.day, j = B.hours, Z = B.minutes, te = B.seconds, ne = B.milliseconds, V = B.zone, q = B.week, X = /* @__PURE__ */ new Date(), W = K || (G || H ? 1 : X.getDate()), ue = G || X.getFullYear(), J = 0;
              G && !H || (J = H > 0 ? H - 1 : X.getMonth());
              var Ce, Ee = j || 0, Te = Z || 0, me = te || 0, we = ne || 0;
              return V ? new Date(Date.UTC(ue, J, W, Ee, Te, me, we + 60 * V.offset * 1e3)) : D ? new Date(Date.UTC(ue, J, W, Ee, Te, me, we)) : (Ce = new Date(ue, J, W, Ee, Te, me, we), q && (Ce = F(Ce).week(q).toDate()), Ce);
            } catch {
              return /* @__PURE__ */ new Date("");
            }
          }(S, k, w, b), this.init(), O && O !== !0 && (this.$L = this.locale(O).$L), _ && S != this.format(k) && (this.$d = /* @__PURE__ */ new Date("")), l = {};
        } else if (k instanceof Array) for (var T = k.length, L = 1; L <= T; L += 1) {
          C[1] = k[L - 1];
          var M = b.apply(this, C);
          if (M.isValid()) {
            this.$d = M.$d, this.$L = M.$L, this.init();
            break;
          }
          L === T && (this.$d = /* @__PURE__ */ new Date(""));
        }
        else x.call(this, E);
      };
    };
  });
})(dH);
var B7e = dH.exports;
const nLe = /* @__PURE__ */ ho(B7e);
var pH = { exports: {} };
(function(t, e) {
  (function(r, n) {
    t.exports = n();
  })(Jt, function() {
    return function(r, n) {
      var a = n.prototype, i = a.format;
      a.format = function(s) {
        var o = this, l = this.$locale();
        if (!this.isValid()) return i.bind(this)(s);
        var u = this.$utils(), c = (s || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(f) {
          switch (f) {
            case "Q":
              return Math.ceil((o.$M + 1) / 3);
            case "Do":
              return l.ordinal(o.$D);
            case "gggg":
              return o.weekYear();
            case "GGGG":
              return o.isoWeekYear();
            case "wo":
              return l.ordinal(o.week(), "W");
            case "w":
            case "ww":
              return u.s(o.week(), f === "w" ? 1 : 2, "0");
            case "W":
            case "WW":
              return u.s(o.isoWeek(), f === "W" ? 1 : 2, "0");
            case "k":
            case "kk":
              return u.s(String(o.$H === 0 ? 24 : o.$H), f === "k" ? 1 : 2, "0");
            case "X":
              return Math.floor(o.$d.getTime() / 1e3);
            case "x":
              return o.$d.getTime();
            case "z":
              return "[" + o.offsetName() + "]";
            case "zzz":
              return "[" + o.offsetName("long") + "]";
            default:
              return f;
          }
        });
        return i.bind(this)(c);
      };
    };
  });
})(pH);
var z7e = pH.exports;
const aLe = /* @__PURE__ */ ho(z7e), Pn = [];
for (let t = 0; t < 256; ++t)
  Pn.push((t + 256).toString(16).slice(1));
function G7e(t, e = 0) {
  return (Pn[t[e + 0]] + Pn[t[e + 1]] + Pn[t[e + 2]] + Pn[t[e + 3]] + "-" + Pn[t[e + 4]] + Pn[t[e + 5]] + "-" + Pn[t[e + 6]] + Pn[t[e + 7]] + "-" + Pn[t[e + 8]] + Pn[t[e + 9]] + "-" + Pn[t[e + 10]] + Pn[t[e + 11]] + Pn[t[e + 12]] + Pn[t[e + 13]] + Pn[t[e + 14]] + Pn[t[e + 15]]).toLowerCase();
}
let oE;
const U7e = new Uint8Array(16);
function H7e() {
  if (!oE) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    oE = crypto.getRandomValues.bind(crypto);
  }
  return oE(U7e);
}
const V7e = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), I8 = { randomUUID: V7e };
function iLe(t, e, r) {
  var a;
  if (I8.randomUUID && !t)
    return I8.randomUUID();
  t = t || {};
  const n = t.random ?? ((a = t.rng) == null ? void 0 : a.call(t)) ?? H7e();
  if (n.length < 16)
    throw new Error("Random bytes length must be >= 16");
  return n[6] = n[6] & 15 | 64, n[8] = n[8] & 63 | 128, G7e(n);
}
function P8(t, e) {
  let r;
  if (e === void 0)
    for (const n of t)
      n != null && (r < n || r === void 0 && n >= n) && (r = n);
  else {
    let n = -1;
    for (let a of t)
      (a = e(a, ++n, t)) != null && (r < a || r === void 0 && a >= a) && (r = a);
  }
  return r;
}
function gH(t, e) {
  let r;
  if (e === void 0)
    for (const n of t)
      n != null && (r > n || r === void 0 && n >= n) && (r = n);
  else {
    let n = -1;
    for (let a of t)
      (a = e(a, ++n, t)) != null && (r > a || r === void 0 && a >= a) && (r = a);
  }
  return r;
}
function lE(t, e) {
  let r = 0;
  if (e === void 0)
    for (let n of t)
      (n = +n) && (r += n);
  else {
    let n = -1;
    for (let a of t)
      (a = +e(a, ++n, t)) && (r += a);
  }
  return r;
}
function q7e(t) {
  return t.target.depth;
}
function sLe(t) {
  return t.depth;
}
function oLe(t, e) {
  return e - 1 - t.height;
}
function W7e(t, e) {
  return t.sourceLinks.length ? t.depth : e - 1;
}
function lLe(t) {
  return t.targetLinks.length ? t.depth : t.sourceLinks.length ? gH(t.sourceLinks, q7e) - 1 : 0;
}
function Ug(t) {
  return function() {
    return t;
  };
}
function D8(t, e) {
  return by(t.source, e.source) || t.index - e.index;
}
function $8(t, e) {
  return by(t.target, e.target) || t.index - e.index;
}
function by(t, e) {
  return t.y0 - e.y0;
}
function uE(t) {
  return t.value;
}
function j7e(t) {
  return t.index;
}
function Y7e(t) {
  return t.nodes;
}
function X7e(t) {
  return t.links;
}
function F8(t, e) {
  const r = t.get(e);
  if (!r) throw new Error("missing: " + e);
  return r;
}
function B8({ nodes: t }) {
  for (const e of t) {
    let r = e.y0, n = r;
    for (const a of e.sourceLinks)
      a.y0 = r + a.width / 2, r += a.width;
    for (const a of e.targetLinks)
      a.y1 = n + a.width / 2, n += a.width;
  }
}
function uLe() {
  let t = 0, e = 0, r = 1, n = 1, a = 24, i = 8, s, o = j7e, l = W7e, u, c, f = Y7e, h = X7e, d = 6;
  function p() {
    const L = { nodes: f.apply(null, arguments), links: h.apply(null, arguments) };
    return g(L), v(L), m(L), b(L), E(L), B8(L), L;
  }
  p.update = function(L) {
    return B8(L), L;
  }, p.nodeId = function(L) {
    return arguments.length ? (o = typeof L == "function" ? L : Ug(L), p) : o;
  }, p.nodeAlign = function(L) {
    return arguments.length ? (l = typeof L == "function" ? L : Ug(L), p) : l;
  }, p.nodeSort = function(L) {
    return arguments.length ? (u = L, p) : u;
  }, p.nodeWidth = function(L) {
    return arguments.length ? (a = +L, p) : a;
  }, p.nodePadding = function(L) {
    return arguments.length ? (i = s = +L, p) : i;
  }, p.nodes = function(L) {
    return arguments.length ? (f = typeof L == "function" ? L : Ug(L), p) : f;
  }, p.links = function(L) {
    return arguments.length ? (h = typeof L == "function" ? L : Ug(L), p) : h;
  }, p.linkSort = function(L) {
    return arguments.length ? (c = L, p) : c;
  }, p.size = function(L) {
    return arguments.length ? (t = e = 0, r = +L[0], n = +L[1], p) : [r - t, n - e];
  }, p.extent = function(L) {
    return arguments.length ? (t = +L[0][0], r = +L[1][0], e = +L[0][1], n = +L[1][1], p) : [[t, e], [r, n]];
  }, p.iterations = function(L) {
    return arguments.length ? (d = +L, p) : d;
  };
  function g({ nodes: L, links: M }) {
    for (const [I, D] of L.entries())
      D.index = I, D.sourceLinks = [], D.targetLinks = [];
    const A = new Map(L.map((I, D) => [o(I, D, L), I]));
    for (const [I, D] of M.entries()) {
      D.index = I;
      let { source: F, target: B } = D;
      typeof F != "object" && (F = D.source = F8(A, F)), typeof B != "object" && (B = D.target = F8(A, B)), F.sourceLinks.push(D), B.targetLinks.push(D);
    }
    if (c != null)
      for (const { sourceLinks: I, targetLinks: D } of L)
        I.sort(c), D.sort(c);
  }
  function v({ nodes: L }) {
    for (const M of L)
      M.value = M.fixedValue === void 0 ? Math.max(lE(M.sourceLinks, uE), lE(M.targetLinks, uE)) : M.fixedValue;
  }
  function m({ nodes: L }) {
    const M = L.length;
    let A = new Set(L), I = /* @__PURE__ */ new Set(), D = 0;
    for (; A.size; ) {
      for (const F of A) {
        F.depth = D;
        for (const { target: B } of F.sourceLinks)
          I.add(B);
      }
      if (++D > M) throw new Error("circular link");
      A = I, I = /* @__PURE__ */ new Set();
    }
  }
  function b({ nodes: L }) {
    const M = L.length;
    let A = new Set(L), I = /* @__PURE__ */ new Set(), D = 0;
    for (; A.size; ) {
      for (const F of A) {
        F.height = D;
        for (const { source: B } of F.targetLinks)
          I.add(B);
      }
      if (++D > M) throw new Error("circular link");
      A = I, I = /* @__PURE__ */ new Set();
    }
  }
  function y({ nodes: L }) {
    const M = P8(L, (D) => D.depth) + 1, A = (r - t - a) / (M - 1), I = new Array(M);
    for (const D of L) {
      const F = Math.max(0, Math.min(M - 1, Math.floor(l.call(null, D, M))));
      D.layer = F, D.x0 = t + F * A, D.x1 = D.x0 + a, I[F] ? I[F].push(D) : I[F] = [D];
    }
    if (u) for (const D of I)
      D.sort(u);
    return I;
  }
  function x(L) {
    const M = gH(L, (A) => (n - e - (A.length - 1) * s) / lE(A, uE));
    for (const A of L) {
      let I = e;
      for (const D of A) {
        D.y0 = I, D.y1 = I + D.value * M, I = D.y1 + s;
        for (const F of D.sourceLinks)
          F.width = F.value * M;
      }
      I = (n - I + s) / (A.length + 1);
      for (let D = 0; D < A.length; ++D) {
        const F = A[D];
        F.y0 += I * (D + 1), F.y1 += I * (D + 1);
      }
      _(A);
    }
  }
  function E(L) {
    const M = y(L);
    s = Math.min(i, (n - e) / (P8(M, (A) => A.length) - 1)), x(M);
    for (let A = 0; A < d; ++A) {
      const I = Math.pow(0.99, A), D = Math.max(1 - I, (A + 1) / d);
      w(M, I, D), S(M, I, D);
    }
  }
  function S(L, M, A) {
    for (let I = 1, D = L.length; I < D; ++I) {
      const F = L[I];
      for (const B of F) {
        let G = 0, H = 0;
        for (const { source: j, value: Z } of B.targetLinks) {
          let te = Z * (B.layer - j.layer);
          G += O(j, B) * te, H += te;
        }
        if (!(H > 0)) continue;
        let K = (G / H - B.y0) * M;
        B.y0 += K, B.y1 += K, R(B);
      }
      u === void 0 && F.sort(by), C(F, A);
    }
  }
  function w(L, M, A) {
    for (let I = L.length, D = I - 2; D >= 0; --D) {
      const F = L[D];
      for (const B of F) {
        let G = 0, H = 0;
        for (const { target: j, value: Z } of B.sourceLinks) {
          let te = Z * (j.layer - B.layer);
          G += T(B, j) * te, H += te;
        }
        if (!(H > 0)) continue;
        let K = (G / H - B.y0) * M;
        B.y0 += K, B.y1 += K, R(B);
      }
      u === void 0 && F.sort(by), C(F, A);
    }
  }
  function C(L, M) {
    const A = L.length >> 1, I = L[A];
    N(L, I.y0 - s, A - 1, M), k(L, I.y1 + s, A + 1, M), N(L, n, L.length - 1, M), k(L, e, 0, M);
  }
  function k(L, M, A, I) {
    for (; A < L.length; ++A) {
      const D = L[A], F = (M - D.y0) * I;
      F > 1e-6 && (D.y0 += F, D.y1 += F), M = D.y1 + s;
    }
  }
  function N(L, M, A, I) {
    for (; A >= 0; --A) {
      const D = L[A], F = (D.y1 - M) * I;
      F > 1e-6 && (D.y0 -= F, D.y1 -= F), M = D.y0 - s;
    }
  }
  function R({ sourceLinks: L, targetLinks: M }) {
    if (c === void 0) {
      for (const { source: { sourceLinks: A } } of M)
        A.sort($8);
      for (const { target: { targetLinks: A } } of L)
        A.sort(D8);
    }
  }
  function _(L) {
    if (c === void 0)
      for (const { sourceLinks: M, targetLinks: A } of L)
        M.sort($8), A.sort(D8);
  }
  function O(L, M) {
    let A = L.y0 - (L.sourceLinks.length - 1) * s / 2;
    for (const { target: I, width: D } of L.sourceLinks) {
      if (I === M) break;
      A += D + s;
    }
    for (const { source: I, width: D } of M.targetLinks) {
      if (I === L) break;
      A -= D;
    }
    return A;
  }
  function T(L, M) {
    let A = M.y0 - (M.targetLinks.length - 1) * s / 2;
    for (const { source: I, width: D } of M.targetLinks) {
      if (I === L) break;
      A += D + s;
    }
    for (const { target: I, width: D } of L.sourceLinks) {
      if (I === M) break;
      A -= D;
    }
    return A;
  }
  return p;
}
var ES = Math.PI, TS = 2 * ES, Ol = 1e-6, K7e = TS - Ol;
function SS() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null, this._ = "";
}
function vH() {
  return new SS();
}
SS.prototype = vH.prototype = {
  constructor: SS,
  moveTo: function(t, e) {
    this._ += "M" + (this._x0 = this._x1 = +t) + "," + (this._y0 = this._y1 = +e);
  },
  closePath: function() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._ += "Z");
  },
  lineTo: function(t, e) {
    this._ += "L" + (this._x1 = +t) + "," + (this._y1 = +e);
  },
  quadraticCurveTo: function(t, e, r, n) {
    this._ += "Q" + +t + "," + +e + "," + (this._x1 = +r) + "," + (this._y1 = +n);
  },
  bezierCurveTo: function(t, e, r, n, a, i) {
    this._ += "C" + +t + "," + +e + "," + +r + "," + +n + "," + (this._x1 = +a) + "," + (this._y1 = +i);
  },
  arcTo: function(t, e, r, n, a) {
    t = +t, e = +e, r = +r, n = +n, a = +a;
    var i = this._x1, s = this._y1, o = r - t, l = n - e, u = i - t, c = s - e, f = u * u + c * c;
    if (a < 0) throw new Error("negative radius: " + a);
    if (this._x1 === null)
      this._ += "M" + (this._x1 = t) + "," + (this._y1 = e);
    else if (f > Ol) if (!(Math.abs(c * o - l * u) > Ol) || !a)
      this._ += "L" + (this._x1 = t) + "," + (this._y1 = e);
    else {
      var h = r - i, d = n - s, p = o * o + l * l, g = h * h + d * d, v = Math.sqrt(p), m = Math.sqrt(f), b = a * Math.tan((ES - Math.acos((p + f - g) / (2 * v * m))) / 2), y = b / m, x = b / v;
      Math.abs(y - 1) > Ol && (this._ += "L" + (t + y * u) + "," + (e + y * c)), this._ += "A" + a + "," + a + ",0,0," + +(c * h > u * d) + "," + (this._x1 = t + x * o) + "," + (this._y1 = e + x * l);
    }
  },
  arc: function(t, e, r, n, a, i) {
    t = +t, e = +e, r = +r, i = !!i;
    var s = r * Math.cos(n), o = r * Math.sin(n), l = t + s, u = e + o, c = 1 ^ i, f = i ? n - a : a - n;
    if (r < 0) throw new Error("negative radius: " + r);
    this._x1 === null ? this._ += "M" + l + "," + u : (Math.abs(this._x1 - l) > Ol || Math.abs(this._y1 - u) > Ol) && (this._ += "L" + l + "," + u), r && (f < 0 && (f = f % TS + TS), f > K7e ? this._ += "A" + r + "," + r + ",0,1," + c + "," + (t - s) + "," + (e - o) + "A" + r + "," + r + ",0,1," + c + "," + (this._x1 = l) + "," + (this._y1 = u) : f > Ol && (this._ += "A" + r + "," + r + ",0," + +(f >= ES) + "," + c + "," + (this._x1 = t + r * Math.cos(a)) + "," + (this._y1 = e + r * Math.sin(a))));
  },
  rect: function(t, e, r, n) {
    this._ += "M" + (this._x0 = this._x1 = +t) + "," + (this._y0 = this._y1 = +e) + "h" + +r + "v" + +n + "h" + -r + "Z";
  },
  toString: function() {
    return this._;
  }
};
function z8(t) {
  return function() {
    return t;
  };
}
function Z7e(t) {
  return t[0];
}
function Q7e(t) {
  return t[1];
}
var J7e = Array.prototype.slice;
function eMe(t) {
  return t.source;
}
function tMe(t) {
  return t.target;
}
function rMe(t) {
  var e = eMe, r = tMe, n = Z7e, a = Q7e, i = null;
  function s() {
    var o, l = J7e.call(arguments), u = e.apply(this, l), c = r.apply(this, l);
    if (i || (i = o = vH()), t(i, +n.apply(this, (l[0] = u, l)), +a.apply(this, l), +n.apply(this, (l[0] = c, l)), +a.apply(this, l)), o) return i = null, o + "" || null;
  }
  return s.source = function(o) {
    return arguments.length ? (e = o, s) : e;
  }, s.target = function(o) {
    return arguments.length ? (r = o, s) : r;
  }, s.x = function(o) {
    return arguments.length ? (n = typeof o == "function" ? o : z8(+o), s) : n;
  }, s.y = function(o) {
    return arguments.length ? (a = typeof o == "function" ? o : z8(+o), s) : a;
  }, s.context = function(o) {
    return arguments.length ? (i = o ?? null, s) : i;
  }, s;
}
function nMe(t, e, r, n, a) {
  t.moveTo(e, r), t.bezierCurveTo(e = (e + n) / 2, r, e, a, n, a);
}
function aMe() {
  return rMe(nMe);
}
function iMe(t) {
  return [t.source.x1, t.y0];
}
function sMe(t) {
  return [t.target.x0, t.y1];
}
function cLe() {
  return aMe().source(iMe).target(sMe);
}
var mH = { exports: {} }, cE = { exports: {} }, fE = { exports: {} }, G8;
function oMe() {
  return G8 || (G8 = 1, function(t, e) {
    (function(n, a) {
      t.exports = a();
    })(Jt, function() {
      return (
        /******/
        function(r) {
          var n = {};
          function a(i) {
            if (n[i])
              return n[i].exports;
            var s = n[i] = {
              /******/
              i,
              /******/
              l: !1,
              /******/
              exports: {}
              /******/
            };
            return r[i].call(s.exports, s, s.exports, a), s.l = !0, s.exports;
          }
          return a.m = r, a.c = n, a.i = function(i) {
            return i;
          }, a.d = function(i, s, o) {
            a.o(i, s) || Object.defineProperty(i, s, {
              /******/
              configurable: !1,
              /******/
              enumerable: !0,
              /******/
              get: o
              /******/
            });
          }, a.n = function(i) {
            var s = i && i.__esModule ? (
              /******/
              function() {
                return i.default;
              }
            ) : (
              /******/
              function() {
                return i;
              }
            );
            return a.d(s, "a", s), s;
          }, a.o = function(i, s) {
            return Object.prototype.hasOwnProperty.call(i, s);
          }, a.p = "", a(a.s = 28);
        }([
          /* 0 */
          /***/
          function(r, n, a) {
            function i() {
            }
            i.QUALITY = 1, i.DEFAULT_CREATE_BENDS_AS_NEEDED = !1, i.DEFAULT_INCREMENTAL = !1, i.DEFAULT_ANIMATION_ON_LAYOUT = !0, i.DEFAULT_ANIMATION_DURING_LAYOUT = !1, i.DEFAULT_ANIMATION_PERIOD = 50, i.DEFAULT_UNIFORM_LEAF_NODE_SIZES = !1, i.DEFAULT_GRAPH_MARGIN = 15, i.NODE_DIMENSIONS_INCLUDE_LABELS = !1, i.SIMPLE_NODE_SIZE = 40, i.SIMPLE_NODE_HALF_SIZE = i.SIMPLE_NODE_SIZE / 2, i.EMPTY_COMPOUND_NODE_SIZE = 40, i.MIN_EDGE_LENGTH = 1, i.WORLD_BOUNDARY = 1e6, i.INITIAL_WORLD_BOUNDARY = i.WORLD_BOUNDARY / 1e3, i.WORLD_CENTER_X = 1200, i.WORLD_CENTER_Y = 900, r.exports = i;
          },
          /* 1 */
          /***/
          function(r, n, a) {
            var i = a(2), s = a(8), o = a(9);
            function l(c, f, h) {
              i.call(this, h), this.isOverlapingSourceAndTarget = !1, this.vGraphObject = h, this.bendpoints = [], this.source = c, this.target = f;
            }
            l.prototype = Object.create(i.prototype);
            for (var u in i)
              l[u] = i[u];
            l.prototype.getSource = function() {
              return this.source;
            }, l.prototype.getTarget = function() {
              return this.target;
            }, l.prototype.isInterGraph = function() {
              return this.isInterGraph;
            }, l.prototype.getLength = function() {
              return this.length;
            }, l.prototype.isOverlapingSourceAndTarget = function() {
              return this.isOverlapingSourceAndTarget;
            }, l.prototype.getBendpoints = function() {
              return this.bendpoints;
            }, l.prototype.getLca = function() {
              return this.lca;
            }, l.prototype.getSourceInLca = function() {
              return this.sourceInLca;
            }, l.prototype.getTargetInLca = function() {
              return this.targetInLca;
            }, l.prototype.getOtherEnd = function(c) {
              if (this.source === c)
                return this.target;
              if (this.target === c)
                return this.source;
              throw "Node is not incident with this edge";
            }, l.prototype.getOtherEndInGraph = function(c, f) {
              for (var h = this.getOtherEnd(c), d = f.getGraphManager().getRoot(); ; ) {
                if (h.getOwner() == f)
                  return h;
                if (h.getOwner() == d)
                  break;
                h = h.getOwner().getParent();
              }
              return null;
            }, l.prototype.updateLength = function() {
              var c = new Array(4);
              this.isOverlapingSourceAndTarget = s.getIntersection(this.target.getRect(), this.source.getRect(), c), this.isOverlapingSourceAndTarget || (this.lengthX = c[0] - c[2], this.lengthY = c[1] - c[3], Math.abs(this.lengthX) < 1 && (this.lengthX = o.sign(this.lengthX)), Math.abs(this.lengthY) < 1 && (this.lengthY = o.sign(this.lengthY)), this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY));
            }, l.prototype.updateLengthSimple = function() {
              this.lengthX = this.target.getCenterX() - this.source.getCenterX(), this.lengthY = this.target.getCenterY() - this.source.getCenterY(), Math.abs(this.lengthX) < 1 && (this.lengthX = o.sign(this.lengthX)), Math.abs(this.lengthY) < 1 && (this.lengthY = o.sign(this.lengthY)), this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);
            }, r.exports = l;
          },
          /* 2 */
          /***/
          function(r, n, a) {
            function i(s) {
              this.vGraphObject = s;
            }
            r.exports = i;
          },
          /* 3 */
          /***/
          function(r, n, a) {
            var i = a(2), s = a(10), o = a(13), l = a(0), u = a(16), c = a(5);
            function f(d, p, g, v) {
              g == null && v == null && (v = p), i.call(this, v), d.graphManager != null && (d = d.graphManager), this.estimatedSize = s.MIN_VALUE, this.inclusionTreeDepth = s.MAX_VALUE, this.vGraphObject = v, this.edges = [], this.graphManager = d, g != null && p != null ? this.rect = new o(p.x, p.y, g.width, g.height) : this.rect = new o();
            }
            f.prototype = Object.create(i.prototype);
            for (var h in i)
              f[h] = i[h];
            f.prototype.getEdges = function() {
              return this.edges;
            }, f.prototype.getChild = function() {
              return this.child;
            }, f.prototype.getOwner = function() {
              return this.owner;
            }, f.prototype.getWidth = function() {
              return this.rect.width;
            }, f.prototype.setWidth = function(d) {
              this.rect.width = d;
            }, f.prototype.getHeight = function() {
              return this.rect.height;
            }, f.prototype.setHeight = function(d) {
              this.rect.height = d;
            }, f.prototype.getCenterX = function() {
              return this.rect.x + this.rect.width / 2;
            }, f.prototype.getCenterY = function() {
              return this.rect.y + this.rect.height / 2;
            }, f.prototype.getCenter = function() {
              return new c(this.rect.x + this.rect.width / 2, this.rect.y + this.rect.height / 2);
            }, f.prototype.getLocation = function() {
              return new c(this.rect.x, this.rect.y);
            }, f.prototype.getRect = function() {
              return this.rect;
            }, f.prototype.getDiagonal = function() {
              return Math.sqrt(this.rect.width * this.rect.width + this.rect.height * this.rect.height);
            }, f.prototype.getHalfTheDiagonal = function() {
              return Math.sqrt(this.rect.height * this.rect.height + this.rect.width * this.rect.width) / 2;
            }, f.prototype.setRect = function(d, p) {
              this.rect.x = d.x, this.rect.y = d.y, this.rect.width = p.width, this.rect.height = p.height;
            }, f.prototype.setCenter = function(d, p) {
              this.rect.x = d - this.rect.width / 2, this.rect.y = p - this.rect.height / 2;
            }, f.prototype.setLocation = function(d, p) {
              this.rect.x = d, this.rect.y = p;
            }, f.prototype.moveBy = function(d, p) {
              this.rect.x += d, this.rect.y += p;
            }, f.prototype.getEdgeListToNode = function(d) {
              var p = [], g = this;
              return g.edges.forEach(function(v) {
                if (v.target == d) {
                  if (v.source != g) throw "Incorrect edge source!";
                  p.push(v);
                }
              }), p;
            }, f.prototype.getEdgesBetween = function(d) {
              var p = [], g = this;
              return g.edges.forEach(function(v) {
                if (!(v.source == g || v.target == g)) throw "Incorrect edge source and/or target";
                (v.target == d || v.source == d) && p.push(v);
              }), p;
            }, f.prototype.getNeighborsList = function() {
              var d = /* @__PURE__ */ new Set(), p = this;
              return p.edges.forEach(function(g) {
                if (g.source == p)
                  d.add(g.target);
                else {
                  if (g.target != p)
                    throw "Incorrect incidency!";
                  d.add(g.source);
                }
              }), d;
            }, f.prototype.withChildren = function() {
              var d = /* @__PURE__ */ new Set(), p, g;
              if (d.add(this), this.child != null)
                for (var v = this.child.getNodes(), m = 0; m < v.length; m++)
                  p = v[m], g = p.withChildren(), g.forEach(function(b) {
                    d.add(b);
                  });
              return d;
            }, f.prototype.getNoOfChildren = function() {
              var d = 0, p;
              if (this.child == null)
                d = 1;
              else
                for (var g = this.child.getNodes(), v = 0; v < g.length; v++)
                  p = g[v], d += p.getNoOfChildren();
              return d == 0 && (d = 1), d;
            }, f.prototype.getEstimatedSize = function() {
              if (this.estimatedSize == s.MIN_VALUE)
                throw "assert failed";
              return this.estimatedSize;
            }, f.prototype.calcEstimatedSize = function() {
              return this.child == null ? this.estimatedSize = (this.rect.width + this.rect.height) / 2 : (this.estimatedSize = this.child.calcEstimatedSize(), this.rect.width = this.estimatedSize, this.rect.height = this.estimatedSize, this.estimatedSize);
            }, f.prototype.scatter = function() {
              var d, p, g = -l.INITIAL_WORLD_BOUNDARY, v = l.INITIAL_WORLD_BOUNDARY;
              d = l.WORLD_CENTER_X + u.nextDouble() * (v - g) + g;
              var m = -l.INITIAL_WORLD_BOUNDARY, b = l.INITIAL_WORLD_BOUNDARY;
              p = l.WORLD_CENTER_Y + u.nextDouble() * (b - m) + m, this.rect.x = d, this.rect.y = p;
            }, f.prototype.updateBounds = function() {
              if (this.getChild() == null)
                throw "assert failed";
              if (this.getChild().getNodes().length != 0) {
                var d = this.getChild();
                if (d.updateBounds(!0), this.rect.x = d.getLeft(), this.rect.y = d.getTop(), this.setWidth(d.getRight() - d.getLeft()), this.setHeight(d.getBottom() - d.getTop()), l.NODE_DIMENSIONS_INCLUDE_LABELS) {
                  var p = d.getRight() - d.getLeft(), g = d.getBottom() - d.getTop();
                  this.labelWidth && (this.labelPosHorizontal == "left" ? (this.rect.x -= this.labelWidth, this.setWidth(p + this.labelWidth)) : this.labelPosHorizontal == "center" && this.labelWidth > p ? (this.rect.x -= (this.labelWidth - p) / 2, this.setWidth(this.labelWidth)) : this.labelPosHorizontal == "right" && this.setWidth(p + this.labelWidth)), this.labelHeight && (this.labelPosVertical == "top" ? (this.rect.y -= this.labelHeight, this.setHeight(g + this.labelHeight)) : this.labelPosVertical == "center" && this.labelHeight > g ? (this.rect.y -= (this.labelHeight - g) / 2, this.setHeight(this.labelHeight)) : this.labelPosVertical == "bottom" && this.setHeight(g + this.labelHeight));
                }
              }
            }, f.prototype.getInclusionTreeDepth = function() {
              if (this.inclusionTreeDepth == s.MAX_VALUE)
                throw "assert failed";
              return this.inclusionTreeDepth;
            }, f.prototype.transform = function(d) {
              var p = this.rect.x;
              p > l.WORLD_BOUNDARY ? p = l.WORLD_BOUNDARY : p < -l.WORLD_BOUNDARY && (p = -l.WORLD_BOUNDARY);
              var g = this.rect.y;
              g > l.WORLD_BOUNDARY ? g = l.WORLD_BOUNDARY : g < -l.WORLD_BOUNDARY && (g = -l.WORLD_BOUNDARY);
              var v = new c(p, g), m = d.inverseTransformPoint(v);
              this.setLocation(m.x, m.y);
            }, f.prototype.getLeft = function() {
              return this.rect.x;
            }, f.prototype.getRight = function() {
              return this.rect.x + this.rect.width;
            }, f.prototype.getTop = function() {
              return this.rect.y;
            }, f.prototype.getBottom = function() {
              return this.rect.y + this.rect.height;
            }, f.prototype.getParent = function() {
              return this.owner == null ? null : this.owner.getParent();
            }, r.exports = f;
          },
          /* 4 */
          /***/
          function(r, n, a) {
            var i = a(0);
            function s() {
            }
            for (var o in i)
              s[o] = i[o];
            s.MAX_ITERATIONS = 2500, s.DEFAULT_EDGE_LENGTH = 50, s.DEFAULT_SPRING_STRENGTH = 0.45, s.DEFAULT_REPULSION_STRENGTH = 4500, s.DEFAULT_GRAVITY_STRENGTH = 0.4, s.DEFAULT_COMPOUND_GRAVITY_STRENGTH = 1, s.DEFAULT_GRAVITY_RANGE_FACTOR = 3.8, s.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = 1.5, s.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION = !0, s.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION = !0, s.DEFAULT_COOLING_FACTOR_INCREMENTAL = 0.3, s.COOLING_ADAPTATION_FACTOR = 0.33, s.ADAPTATION_LOWER_NODE_LIMIT = 1e3, s.ADAPTATION_UPPER_NODE_LIMIT = 5e3, s.MAX_NODE_DISPLACEMENT_INCREMENTAL = 100, s.MAX_NODE_DISPLACEMENT = s.MAX_NODE_DISPLACEMENT_INCREMENTAL * 3, s.MIN_REPULSION_DIST = s.DEFAULT_EDGE_LENGTH / 10, s.CONVERGENCE_CHECK_PERIOD = 100, s.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = 0.1, s.MIN_EDGE_LENGTH = 1, s.GRID_CALCULATION_CHECK_PERIOD = 10, r.exports = s;
          },
          /* 5 */
          /***/
          function(r, n, a) {
            function i(s, o) {
              s == null && o == null ? (this.x = 0, this.y = 0) : (this.x = s, this.y = o);
            }
            i.prototype.getX = function() {
              return this.x;
            }, i.prototype.getY = function() {
              return this.y;
            }, i.prototype.setX = function(s) {
              this.x = s;
            }, i.prototype.setY = function(s) {
              this.y = s;
            }, i.prototype.getDifference = function(s) {
              return new DimensionD(this.x - s.x, this.y - s.y);
            }, i.prototype.getCopy = function() {
              return new i(this.x, this.y);
            }, i.prototype.translate = function(s) {
              return this.x += s.width, this.y += s.height, this;
            }, r.exports = i;
          },
          /* 6 */
          /***/
          function(r, n, a) {
            var i = a(2), s = a(10), o = a(0), l = a(7), u = a(3), c = a(1), f = a(13), h = a(12), d = a(11);
            function p(v, m, b) {
              i.call(this, b), this.estimatedSize = s.MIN_VALUE, this.margin = o.DEFAULT_GRAPH_MARGIN, this.edges = [], this.nodes = [], this.isConnected = !1, this.parent = v, m != null && m instanceof l ? this.graphManager = m : m != null && m instanceof Layout && (this.graphManager = m.graphManager);
            }
            p.prototype = Object.create(i.prototype);
            for (var g in i)
              p[g] = i[g];
            p.prototype.getNodes = function() {
              return this.nodes;
            }, p.prototype.getEdges = function() {
              return this.edges;
            }, p.prototype.getGraphManager = function() {
              return this.graphManager;
            }, p.prototype.getParent = function() {
              return this.parent;
            }, p.prototype.getLeft = function() {
              return this.left;
            }, p.prototype.getRight = function() {
              return this.right;
            }, p.prototype.getTop = function() {
              return this.top;
            }, p.prototype.getBottom = function() {
              return this.bottom;
            }, p.prototype.isConnected = function() {
              return this.isConnected;
            }, p.prototype.add = function(v, m, b) {
              if (m == null && b == null) {
                var y = v;
                if (this.graphManager == null)
                  throw "Graph has no graph mgr!";
                if (this.getNodes().indexOf(y) > -1)
                  throw "Node already in graph!";
                return y.owner = this, this.getNodes().push(y), y;
              } else {
                var x = v;
                if (!(this.getNodes().indexOf(m) > -1 && this.getNodes().indexOf(b) > -1))
                  throw "Source or target not in graph!";
                if (!(m.owner == b.owner && m.owner == this))
                  throw "Both owners must be this graph!";
                return m.owner != b.owner ? null : (x.source = m, x.target = b, x.isInterGraph = !1, this.getEdges().push(x), m.edges.push(x), b != m && b.edges.push(x), x);
              }
            }, p.prototype.remove = function(v) {
              var m = v;
              if (v instanceof u) {
                if (m == null)
                  throw "Node is null!";
                if (!(m.owner != null && m.owner == this))
                  throw "Owner graph is invalid!";
                if (this.graphManager == null)
                  throw "Owner graph manager is invalid!";
                for (var b = m.edges.slice(), y, x = b.length, E = 0; E < x; E++)
                  y = b[E], y.isInterGraph ? this.graphManager.remove(y) : y.source.owner.remove(y);
                var S = this.nodes.indexOf(m);
                if (S == -1)
                  throw "Node not in owner node list!";
                this.nodes.splice(S, 1);
              } else if (v instanceof c) {
                var y = v;
                if (y == null)
                  throw "Edge is null!";
                if (!(y.source != null && y.target != null))
                  throw "Source and/or target is null!";
                if (!(y.source.owner != null && y.target.owner != null && y.source.owner == this && y.target.owner == this))
                  throw "Source and/or target owner is invalid!";
                var w = y.source.edges.indexOf(y), C = y.target.edges.indexOf(y);
                if (!(w > -1 && C > -1))
                  throw "Source and/or target doesn't know this edge!";
                y.source.edges.splice(w, 1), y.target != y.source && y.target.edges.splice(C, 1);
                var S = y.source.owner.getEdges().indexOf(y);
                if (S == -1)
                  throw "Not in owner's edge list!";
                y.source.owner.getEdges().splice(S, 1);
              }
            }, p.prototype.updateLeftTop = function() {
              for (var v = s.MAX_VALUE, m = s.MAX_VALUE, b, y, x, E = this.getNodes(), S = E.length, w = 0; w < S; w++) {
                var C = E[w];
                b = C.getTop(), y = C.getLeft(), v > b && (v = b), m > y && (m = y);
              }
              return v == s.MAX_VALUE ? null : (E[0].getParent().paddingLeft != null ? x = E[0].getParent().paddingLeft : x = this.margin, this.left = m - x, this.top = v - x, new h(this.left, this.top));
            }, p.prototype.updateBounds = function(v) {
              for (var m = s.MAX_VALUE, b = -s.MAX_VALUE, y = s.MAX_VALUE, x = -s.MAX_VALUE, E, S, w, C, k, N = this.nodes, R = N.length, _ = 0; _ < R; _++) {
                var O = N[_];
                v && O.child != null && O.updateBounds(), E = O.getLeft(), S = O.getRight(), w = O.getTop(), C = O.getBottom(), m > E && (m = E), b < S && (b = S), y > w && (y = w), x < C && (x = C);
              }
              var T = new f(m, y, b - m, x - y);
              m == s.MAX_VALUE && (this.left = this.parent.getLeft(), this.right = this.parent.getRight(), this.top = this.parent.getTop(), this.bottom = this.parent.getBottom()), N[0].getParent().paddingLeft != null ? k = N[0].getParent().paddingLeft : k = this.margin, this.left = T.x - k, this.right = T.x + T.width + k, this.top = T.y - k, this.bottom = T.y + T.height + k;
            }, p.calculateBounds = function(v) {
              for (var m = s.MAX_VALUE, b = -s.MAX_VALUE, y = s.MAX_VALUE, x = -s.MAX_VALUE, E, S, w, C, k = v.length, N = 0; N < k; N++) {
                var R = v[N];
                E = R.getLeft(), S = R.getRight(), w = R.getTop(), C = R.getBottom(), m > E && (m = E), b < S && (b = S), y > w && (y = w), x < C && (x = C);
              }
              var _ = new f(m, y, b - m, x - y);
              return _;
            }, p.prototype.getInclusionTreeDepth = function() {
              return this == this.graphManager.getRoot() ? 1 : this.parent.getInclusionTreeDepth();
            }, p.prototype.getEstimatedSize = function() {
              if (this.estimatedSize == s.MIN_VALUE)
                throw "assert failed";
              return this.estimatedSize;
            }, p.prototype.calcEstimatedSize = function() {
              for (var v = 0, m = this.nodes, b = m.length, y = 0; y < b; y++) {
                var x = m[y];
                v += x.calcEstimatedSize();
              }
              return v == 0 ? this.estimatedSize = o.EMPTY_COMPOUND_NODE_SIZE : this.estimatedSize = v / Math.sqrt(this.nodes.length), this.estimatedSize;
            }, p.prototype.updateConnected = function() {
              var v = this;
              if (this.nodes.length == 0) {
                this.isConnected = !0;
                return;
              }
              var m = new d(), b = /* @__PURE__ */ new Set(), y = this.nodes[0], x, E, S = y.withChildren();
              for (S.forEach(function(_) {
                m.push(_), b.add(_);
              }); m.length !== 0; ) {
                y = m.shift(), x = y.getEdges();
                for (var w = x.length, C = 0; C < w; C++) {
                  var k = x[C];
                  if (E = k.getOtherEndInGraph(y, this), E != null && !b.has(E)) {
                    var N = E.withChildren();
                    N.forEach(function(_) {
                      m.push(_), b.add(_);
                    });
                  }
                }
              }
              if (this.isConnected = !1, b.size >= this.nodes.length) {
                var R = 0;
                b.forEach(function(_) {
                  _.owner == v && R++;
                }), R == this.nodes.length && (this.isConnected = !0);
              }
            }, r.exports = p;
          },
          /* 7 */
          /***/
          function(r, n, a) {
            var i, s = a(1);
            function o(l) {
              i = a(6), this.layout = l, this.graphs = [], this.edges = [];
            }
            o.prototype.addRoot = function() {
              var l = this.layout.newGraph(), u = this.layout.newNode(null), c = this.add(l, u);
              return this.setRootGraph(c), this.rootGraph;
            }, o.prototype.add = function(l, u, c, f, h) {
              if (c == null && f == null && h == null) {
                if (l == null)
                  throw "Graph is null!";
                if (u == null)
                  throw "Parent node is null!";
                if (this.graphs.indexOf(l) > -1)
                  throw "Graph already in this graph mgr!";
                if (this.graphs.push(l), l.parent != null)
                  throw "Already has a parent!";
                if (u.child != null)
                  throw "Already has a child!";
                return l.parent = u, u.child = l, l;
              } else {
                h = c, f = u, c = l;
                var d = f.getOwner(), p = h.getOwner();
                if (!(d != null && d.getGraphManager() == this))
                  throw "Source not in this graph mgr!";
                if (!(p != null && p.getGraphManager() == this))
                  throw "Target not in this graph mgr!";
                if (d == p)
                  return c.isInterGraph = !1, d.add(c, f, h);
                if (c.isInterGraph = !0, c.source = f, c.target = h, this.edges.indexOf(c) > -1)
                  throw "Edge already in inter-graph edge list!";
                if (this.edges.push(c), !(c.source != null && c.target != null))
                  throw "Edge source and/or target is null!";
                if (!(c.source.edges.indexOf(c) == -1 && c.target.edges.indexOf(c) == -1))
                  throw "Edge already in source and/or target incidency list!";
                return c.source.edges.push(c), c.target.edges.push(c), c;
              }
            }, o.prototype.remove = function(l) {
              if (l instanceof i) {
                var u = l;
                if (u.getGraphManager() != this)
                  throw "Graph not in this graph mgr";
                if (!(u == this.rootGraph || u.parent != null && u.parent.graphManager == this))
                  throw "Invalid parent node!";
                var c = [];
                c = c.concat(u.getEdges());
                for (var f, h = c.length, d = 0; d < h; d++)
                  f = c[d], u.remove(f);
                var p = [];
                p = p.concat(u.getNodes());
                var g;
                h = p.length;
                for (var d = 0; d < h; d++)
                  g = p[d], u.remove(g);
                u == this.rootGraph && this.setRootGraph(null);
                var v = this.graphs.indexOf(u);
                this.graphs.splice(v, 1), u.parent = null;
              } else if (l instanceof s) {
                if (f = l, f == null)
                  throw "Edge is null!";
                if (!f.isInterGraph)
                  throw "Not an inter-graph edge!";
                if (!(f.source != null && f.target != null))
                  throw "Source and/or target is null!";
                if (!(f.source.edges.indexOf(f) != -1 && f.target.edges.indexOf(f) != -1))
                  throw "Source and/or target doesn't know this edge!";
                var v = f.source.edges.indexOf(f);
                if (f.source.edges.splice(v, 1), v = f.target.edges.indexOf(f), f.target.edges.splice(v, 1), !(f.source.owner != null && f.source.owner.getGraphManager() != null))
                  throw "Edge owner graph or owner graph manager is null!";
                if (f.source.owner.getGraphManager().edges.indexOf(f) == -1)
                  throw "Not in owner graph manager's edge list!";
                var v = f.source.owner.getGraphManager().edges.indexOf(f);
                f.source.owner.getGraphManager().edges.splice(v, 1);
              }
            }, o.prototype.updateBounds = function() {
              this.rootGraph.updateBounds(!0);
            }, o.prototype.getGraphs = function() {
              return this.graphs;
            }, o.prototype.getAllNodes = function() {
              if (this.allNodes == null) {
                for (var l = [], u = this.getGraphs(), c = u.length, f = 0; f < c; f++)
                  l = l.concat(u[f].getNodes());
                this.allNodes = l;
              }
              return this.allNodes;
            }, o.prototype.resetAllNodes = function() {
              this.allNodes = null;
            }, o.prototype.resetAllEdges = function() {
              this.allEdges = null;
            }, o.prototype.resetAllNodesToApplyGravitation = function() {
              this.allNodesToApplyGravitation = null;
            }, o.prototype.getAllEdges = function() {
              if (this.allEdges == null) {
                var l = [], u = this.getGraphs();
                u.length;
                for (var c = 0; c < u.length; c++)
                  l = l.concat(u[c].getEdges());
                l = l.concat(this.edges), this.allEdges = l;
              }
              return this.allEdges;
            }, o.prototype.getAllNodesToApplyGravitation = function() {
              return this.allNodesToApplyGravitation;
            }, o.prototype.setAllNodesToApplyGravitation = function(l) {
              if (this.allNodesToApplyGravitation != null)
                throw "assert failed";
              this.allNodesToApplyGravitation = l;
            }, o.prototype.getRoot = function() {
              return this.rootGraph;
            }, o.prototype.setRootGraph = function(l) {
              if (l.getGraphManager() != this)
                throw "Root not in this graph mgr!";
              this.rootGraph = l, l.parent == null && (l.parent = this.layout.newNode("Root node"));
            }, o.prototype.getLayout = function() {
              return this.layout;
            }, o.prototype.isOneAncestorOfOther = function(l, u) {
              if (!(l != null && u != null))
                throw "assert failed";
              if (l == u)
                return !0;
              var c = l.getOwner(), f;
              do {
                if (f = c.getParent(), f == null)
                  break;
                if (f == u)
                  return !0;
                if (c = f.getOwner(), c == null)
                  break;
              } while (!0);
              c = u.getOwner();
              do {
                if (f = c.getParent(), f == null)
                  break;
                if (f == l)
                  return !0;
                if (c = f.getOwner(), c == null)
                  break;
              } while (!0);
              return !1;
            }, o.prototype.calcLowestCommonAncestors = function() {
              for (var l, u, c, f, h, d = this.getAllEdges(), p = d.length, g = 0; g < p; g++) {
                if (l = d[g], u = l.source, c = l.target, l.lca = null, l.sourceInLca = u, l.targetInLca = c, u == c) {
                  l.lca = u.getOwner();
                  continue;
                }
                for (f = u.getOwner(); l.lca == null; ) {
                  for (l.targetInLca = c, h = c.getOwner(); l.lca == null; ) {
                    if (h == f) {
                      l.lca = h;
                      break;
                    }
                    if (h == this.rootGraph)
                      break;
                    if (l.lca != null)
                      throw "assert failed";
                    l.targetInLca = h.getParent(), h = l.targetInLca.getOwner();
                  }
                  if (f == this.rootGraph)
                    break;
                  l.lca == null && (l.sourceInLca = f.getParent(), f = l.sourceInLca.getOwner());
                }
                if (l.lca == null)
                  throw "assert failed";
              }
            }, o.prototype.calcLowestCommonAncestor = function(l, u) {
              if (l == u)
                return l.getOwner();
              var c = l.getOwner();
              do {
                if (c == null)
                  break;
                var f = u.getOwner();
                do {
                  if (f == null)
                    break;
                  if (f == c)
                    return f;
                  f = f.getParent().getOwner();
                } while (!0);
                c = c.getParent().getOwner();
              } while (!0);
              return c;
            }, o.prototype.calcInclusionTreeDepths = function(l, u) {
              l == null && u == null && (l = this.rootGraph, u = 1);
              for (var c, f = l.getNodes(), h = f.length, d = 0; d < h; d++)
                c = f[d], c.inclusionTreeDepth = u, c.child != null && this.calcInclusionTreeDepths(c.child, u + 1);
            }, o.prototype.includesInvalidEdge = function() {
              for (var l, u = [], c = this.edges.length, f = 0; f < c; f++)
                l = this.edges[f], this.isOneAncestorOfOther(l.source, l.target) && u.push(l);
              for (var f = 0; f < u.length; f++)
                this.remove(u[f]);
              return !1;
            }, r.exports = o;
          },
          /* 8 */
          /***/
          function(r, n, a) {
            var i = a(12);
            function s() {
            }
            s.calcSeparationAmount = function(o, l, u, c) {
              if (!o.intersects(l))
                throw "assert failed";
              var f = new Array(2);
              this.decideDirectionsForOverlappingNodes(o, l, f), u[0] = Math.min(o.getRight(), l.getRight()) - Math.max(o.x, l.x), u[1] = Math.min(o.getBottom(), l.getBottom()) - Math.max(o.y, l.y), o.getX() <= l.getX() && o.getRight() >= l.getRight() ? u[0] += Math.min(l.getX() - o.getX(), o.getRight() - l.getRight()) : l.getX() <= o.getX() && l.getRight() >= o.getRight() && (u[0] += Math.min(o.getX() - l.getX(), l.getRight() - o.getRight())), o.getY() <= l.getY() && o.getBottom() >= l.getBottom() ? u[1] += Math.min(l.getY() - o.getY(), o.getBottom() - l.getBottom()) : l.getY() <= o.getY() && l.getBottom() >= o.getBottom() && (u[1] += Math.min(o.getY() - l.getY(), l.getBottom() - o.getBottom()));
              var h = Math.abs((l.getCenterY() - o.getCenterY()) / (l.getCenterX() - o.getCenterX()));
              l.getCenterY() === o.getCenterY() && l.getCenterX() === o.getCenterX() && (h = 1);
              var d = h * u[0], p = u[1] / h;
              u[0] < p ? p = u[0] : d = u[1], u[0] = -1 * f[0] * (p / 2 + c), u[1] = -1 * f[1] * (d / 2 + c);
            }, s.decideDirectionsForOverlappingNodes = function(o, l, u) {
              o.getCenterX() < l.getCenterX() ? u[0] = -1 : u[0] = 1, o.getCenterY() < l.getCenterY() ? u[1] = -1 : u[1] = 1;
            }, s.getIntersection2 = function(o, l, u) {
              var c = o.getCenterX(), f = o.getCenterY(), h = l.getCenterX(), d = l.getCenterY();
              if (o.intersects(l))
                return u[0] = c, u[1] = f, u[2] = h, u[3] = d, !0;
              var p = o.getX(), g = o.getY(), v = o.getRight(), m = o.getX(), b = o.getBottom(), y = o.getRight(), x = o.getWidthHalf(), E = o.getHeightHalf(), S = l.getX(), w = l.getY(), C = l.getRight(), k = l.getX(), N = l.getBottom(), R = l.getRight(), _ = l.getWidthHalf(), O = l.getHeightHalf(), T = !1, L = !1;
              if (c === h) {
                if (f > d)
                  return u[0] = c, u[1] = g, u[2] = h, u[3] = N, !1;
                if (f < d)
                  return u[0] = c, u[1] = b, u[2] = h, u[3] = w, !1;
              } else if (f === d) {
                if (c > h)
                  return u[0] = p, u[1] = f, u[2] = C, u[3] = d, !1;
                if (c < h)
                  return u[0] = v, u[1] = f, u[2] = S, u[3] = d, !1;
              } else {
                var M = o.height / o.width, A = l.height / l.width, I = (d - f) / (h - c), D = void 0, F = void 0, B = void 0, G = void 0, H = void 0, K = void 0;
                if (-M === I ? c > h ? (u[0] = m, u[1] = b, T = !0) : (u[0] = v, u[1] = g, T = !0) : M === I && (c > h ? (u[0] = p, u[1] = g, T = !0) : (u[0] = y, u[1] = b, T = !0)), -A === I ? h > c ? (u[2] = k, u[3] = N, L = !0) : (u[2] = C, u[3] = w, L = !0) : A === I && (h > c ? (u[2] = S, u[3] = w, L = !0) : (u[2] = R, u[3] = N, L = !0)), T && L)
                  return !1;
                if (c > h ? f > d ? (D = this.getCardinalDirection(M, I, 4), F = this.getCardinalDirection(A, I, 2)) : (D = this.getCardinalDirection(-M, I, 3), F = this.getCardinalDirection(-A, I, 1)) : f > d ? (D = this.getCardinalDirection(-M, I, 1), F = this.getCardinalDirection(-A, I, 3)) : (D = this.getCardinalDirection(M, I, 2), F = this.getCardinalDirection(A, I, 4)), !T)
                  switch (D) {
                    case 1:
                      G = g, B = c + -E / I, u[0] = B, u[1] = G;
                      break;
                    case 2:
                      B = y, G = f + x * I, u[0] = B, u[1] = G;
                      break;
                    case 3:
                      G = b, B = c + E / I, u[0] = B, u[1] = G;
                      break;
                    case 4:
                      B = m, G = f + -x * I, u[0] = B, u[1] = G;
                      break;
                  }
                if (!L)
                  switch (F) {
                    case 1:
                      K = w, H = h + -O / I, u[2] = H, u[3] = K;
                      break;
                    case 2:
                      H = R, K = d + _ * I, u[2] = H, u[3] = K;
                      break;
                    case 3:
                      K = N, H = h + O / I, u[2] = H, u[3] = K;
                      break;
                    case 4:
                      H = k, K = d + -_ * I, u[2] = H, u[3] = K;
                      break;
                  }
              }
              return !1;
            }, s.getCardinalDirection = function(o, l, u) {
              return o > l ? u : 1 + u % 4;
            }, s.getIntersection = function(o, l, u, c) {
              if (c == null)
                return this.getIntersection2(o, l, u);
              var f = o.x, h = o.y, d = l.x, p = l.y, g = u.x, v = u.y, m = c.x, b = c.y, y = void 0, x = void 0, E = void 0, S = void 0, w = void 0, C = void 0, k = void 0, N = void 0, R = void 0;
              return E = p - h, w = f - d, k = d * h - f * p, S = b - v, C = g - m, N = m * v - g * b, R = E * C - S * w, R === 0 ? null : (y = (w * N - C * k) / R, x = (S * k - E * N) / R, new i(y, x));
            }, s.angleOfVector = function(o, l, u, c) {
              var f = void 0;
              return o !== u ? (f = Math.atan((c - l) / (u - o)), u < o ? f += Math.PI : c < l && (f += this.TWO_PI)) : c < l ? f = this.ONE_AND_HALF_PI : f = this.HALF_PI, f;
            }, s.doIntersect = function(o, l, u, c) {
              var f = o.x, h = o.y, d = l.x, p = l.y, g = u.x, v = u.y, m = c.x, b = c.y, y = (d - f) * (b - v) - (m - g) * (p - h);
              if (y === 0)
                return !1;
              var x = ((b - v) * (m - f) + (g - m) * (b - h)) / y, E = ((h - p) * (m - f) + (d - f) * (b - h)) / y;
              return 0 < x && x < 1 && 0 < E && E < 1;
            }, s.findCircleLineIntersections = function(o, l, u, c, f, h, d) {
              var p = (u - o) * (u - o) + (c - l) * (c - l), g = 2 * ((o - f) * (u - o) + (l - h) * (c - l)), v = (o - f) * (o - f) + (l - h) * (l - h) - d * d, m = g * g - 4 * p * v;
              if (m >= 0) {
                var b = (-g + Math.sqrt(g * g - 4 * p * v)) / (2 * p), y = (-g - Math.sqrt(g * g - 4 * p * v)) / (2 * p), x = null;
                return b >= 0 && b <= 1 ? [b] : y >= 0 && y <= 1 ? [y] : x;
              } else return null;
            }, s.HALF_PI = 0.5 * Math.PI, s.ONE_AND_HALF_PI = 1.5 * Math.PI, s.TWO_PI = 2 * Math.PI, s.THREE_PI = 3 * Math.PI, r.exports = s;
          },
          /* 9 */
          /***/
          function(r, n, a) {
            function i() {
            }
            i.sign = function(s) {
              return s > 0 ? 1 : s < 0 ? -1 : 0;
            }, i.floor = function(s) {
              return s < 0 ? Math.ceil(s) : Math.floor(s);
            }, i.ceil = function(s) {
              return s < 0 ? Math.floor(s) : Math.ceil(s);
            }, r.exports = i;
          },
          /* 10 */
          /***/
          function(r, n, a) {
            function i() {
            }
            i.MAX_VALUE = 2147483647, i.MIN_VALUE = -2147483648, r.exports = i;
          },
          /* 11 */
          /***/
          function(r, n, a) {
            var i = /* @__PURE__ */ function() {
              function f(h, d) {
                for (var p = 0; p < d.length; p++) {
                  var g = d[p];
                  g.enumerable = g.enumerable || !1, g.configurable = !0, "value" in g && (g.writable = !0), Object.defineProperty(h, g.key, g);
                }
              }
              return function(h, d, p) {
                return d && f(h.prototype, d), p && f(h, p), h;
              };
            }();
            function s(f, h) {
              if (!(f instanceof h))
                throw new TypeError("Cannot call a class as a function");
            }
            var o = function(h) {
              return { value: h, next: null, prev: null };
            }, l = function(h, d, p, g) {
              return h !== null ? h.next = d : g.head = d, p !== null ? p.prev = d : g.tail = d, d.prev = h, d.next = p, g.length++, d;
            }, u = function(h, d) {
              var p = h.prev, g = h.next;
              return p !== null ? p.next = g : d.head = g, g !== null ? g.prev = p : d.tail = p, h.prev = h.next = null, d.length--, h;
            }, c = function() {
              function f(h) {
                var d = this;
                s(this, f), this.length = 0, this.head = null, this.tail = null, h != null && h.forEach(function(p) {
                  return d.push(p);
                });
              }
              return i(f, [{
                key: "size",
                value: function() {
                  return this.length;
                }
              }, {
                key: "insertBefore",
                value: function(d, p) {
                  return l(p.prev, o(d), p, this);
                }
              }, {
                key: "insertAfter",
                value: function(d, p) {
                  return l(p, o(d), p.next, this);
                }
              }, {
                key: "insertNodeBefore",
                value: function(d, p) {
                  return l(p.prev, d, p, this);
                }
              }, {
                key: "insertNodeAfter",
                value: function(d, p) {
                  return l(p, d, p.next, this);
                }
              }, {
                key: "push",
                value: function(d) {
                  return l(this.tail, o(d), null, this);
                }
              }, {
                key: "unshift",
                value: function(d) {
                  return l(null, o(d), this.head, this);
                }
              }, {
                key: "remove",
                value: function(d) {
                  return u(d, this);
                }
              }, {
                key: "pop",
                value: function() {
                  return u(this.tail, this).value;
                }
              }, {
                key: "popNode",
                value: function() {
                  return u(this.tail, this);
                }
              }, {
                key: "shift",
                value: function() {
                  return u(this.head, this).value;
                }
              }, {
                key: "shiftNode",
                value: function() {
                  return u(this.head, this);
                }
              }, {
                key: "get_object_at",
                value: function(d) {
                  if (d <= this.length()) {
                    for (var p = 1, g = this.head; p < d; )
                      g = g.next, p++;
                    return g.value;
                  }
                }
              }, {
                key: "set_object_at",
                value: function(d, p) {
                  if (d <= this.length()) {
                    for (var g = 1, v = this.head; g < d; )
                      v = v.next, g++;
                    v.value = p;
                  }
                }
              }]), f;
            }();
            r.exports = c;
          },
          /* 12 */
          /***/
          function(r, n, a) {
            function i(s, o, l) {
              this.x = null, this.y = null, s == null && o == null && l == null ? (this.x = 0, this.y = 0) : typeof s == "number" && typeof o == "number" && l == null ? (this.x = s, this.y = o) : s.constructor.name == "Point" && o == null && l == null && (l = s, this.x = l.x, this.y = l.y);
            }
            i.prototype.getX = function() {
              return this.x;
            }, i.prototype.getY = function() {
              return this.y;
            }, i.prototype.getLocation = function() {
              return new i(this.x, this.y);
            }, i.prototype.setLocation = function(s, o, l) {
              s.constructor.name == "Point" && o == null && l == null ? (l = s, this.setLocation(l.x, l.y)) : typeof s == "number" && typeof o == "number" && l == null && (parseInt(s) == s && parseInt(o) == o ? this.move(s, o) : (this.x = Math.floor(s + 0.5), this.y = Math.floor(o + 0.5)));
            }, i.prototype.move = function(s, o) {
              this.x = s, this.y = o;
            }, i.prototype.translate = function(s, o) {
              this.x += s, this.y += o;
            }, i.prototype.equals = function(s) {
              if (s.constructor.name == "Point") {
                var o = s;
                return this.x == o.x && this.y == o.y;
              }
              return this == s;
            }, i.prototype.toString = function() {
              return new i().constructor.name + "[x=" + this.x + ",y=" + this.y + "]";
            }, r.exports = i;
          },
          /* 13 */
          /***/
          function(r, n, a) {
            function i(s, o, l, u) {
              this.x = 0, this.y = 0, this.width = 0, this.height = 0, s != null && o != null && l != null && u != null && (this.x = s, this.y = o, this.width = l, this.height = u);
            }
            i.prototype.getX = function() {
              return this.x;
            }, i.prototype.setX = function(s) {
              this.x = s;
            }, i.prototype.getY = function() {
              return this.y;
            }, i.prototype.setY = function(s) {
              this.y = s;
            }, i.prototype.getWidth = function() {
              return this.width;
            }, i.prototype.setWidth = function(s) {
              this.width = s;
            }, i.prototype.getHeight = function() {
              return this.height;
            }, i.prototype.setHeight = function(s) {
              this.height = s;
            }, i.prototype.getRight = function() {
              return this.x + this.width;
            }, i.prototype.getBottom = function() {
              return this.y + this.height;
            }, i.prototype.intersects = function(s) {
              return !(this.getRight() < s.x || this.getBottom() < s.y || s.getRight() < this.x || s.getBottom() < this.y);
            }, i.prototype.getCenterX = function() {
              return this.x + this.width / 2;
            }, i.prototype.getMinX = function() {
              return this.getX();
            }, i.prototype.getMaxX = function() {
              return this.getX() + this.width;
            }, i.prototype.getCenterY = function() {
              return this.y + this.height / 2;
            }, i.prototype.getMinY = function() {
              return this.getY();
            }, i.prototype.getMaxY = function() {
              return this.getY() + this.height;
            }, i.prototype.getWidthHalf = function() {
              return this.width / 2;
            }, i.prototype.getHeightHalf = function() {
              return this.height / 2;
            }, r.exports = i;
          },
          /* 14 */
          /***/
          function(r, n, a) {
            var i = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o) {
              return typeof o;
            } : function(o) {
              return o && typeof Symbol == "function" && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
            };
            function s() {
            }
            s.lastID = 0, s.createID = function(o) {
              return s.isPrimitive(o) ? o : (o.uniqueID != null || (o.uniqueID = s.getString(), s.lastID++), o.uniqueID);
            }, s.getString = function(o) {
              return o == null && (o = s.lastID), "Object#" + o;
            }, s.isPrimitive = function(o) {
              var l = typeof o > "u" ? "undefined" : i(o);
              return o == null || l != "object" && l != "function";
            }, r.exports = s;
          },
          /* 15 */
          /***/
          function(r, n, a) {
            function i(g) {
              if (Array.isArray(g)) {
                for (var v = 0, m = Array(g.length); v < g.length; v++)
                  m[v] = g[v];
                return m;
              } else
                return Array.from(g);
            }
            var s = a(0), o = a(7), l = a(3), u = a(1), c = a(6), f = a(5), h = a(17), d = a(29);
            function p(g) {
              d.call(this), this.layoutQuality = s.QUALITY, this.createBendsAsNeeded = s.DEFAULT_CREATE_BENDS_AS_NEEDED, this.incremental = s.DEFAULT_INCREMENTAL, this.animationOnLayout = s.DEFAULT_ANIMATION_ON_LAYOUT, this.animationDuringLayout = s.DEFAULT_ANIMATION_DURING_LAYOUT, this.animationPeriod = s.DEFAULT_ANIMATION_PERIOD, this.uniformLeafNodeSizes = s.DEFAULT_UNIFORM_LEAF_NODE_SIZES, this.edgeToDummyNodes = /* @__PURE__ */ new Map(), this.graphManager = new o(this), this.isLayoutFinished = !1, this.isSubLayout = !1, this.isRemoteUse = !1, g != null && (this.isRemoteUse = g);
            }
            p.RANDOM_SEED = 1, p.prototype = Object.create(d.prototype), p.prototype.getGraphManager = function() {
              return this.graphManager;
            }, p.prototype.getAllNodes = function() {
              return this.graphManager.getAllNodes();
            }, p.prototype.getAllEdges = function() {
              return this.graphManager.getAllEdges();
            }, p.prototype.getAllNodesToApplyGravitation = function() {
              return this.graphManager.getAllNodesToApplyGravitation();
            }, p.prototype.newGraphManager = function() {
              var g = new o(this);
              return this.graphManager = g, g;
            }, p.prototype.newGraph = function(g) {
              return new c(null, this.graphManager, g);
            }, p.prototype.newNode = function(g) {
              return new l(this.graphManager, g);
            }, p.prototype.newEdge = function(g) {
              return new u(null, null, g);
            }, p.prototype.checkLayoutSuccess = function() {
              return this.graphManager.getRoot() == null || this.graphManager.getRoot().getNodes().length == 0 || this.graphManager.includesInvalidEdge();
            }, p.prototype.runLayout = function() {
              this.isLayoutFinished = !1, this.tilingPreLayout && this.tilingPreLayout(), this.initParameters();
              var g;
              return this.checkLayoutSuccess() ? g = !1 : g = this.layout(), s.ANIMATE === "during" ? !1 : (g && (this.isSubLayout || this.doPostLayout()), this.tilingPostLayout && this.tilingPostLayout(), this.isLayoutFinished = !0, g);
            }, p.prototype.doPostLayout = function() {
              this.incremental || this.transform(), this.update();
            }, p.prototype.update2 = function() {
              if (this.createBendsAsNeeded && (this.createBendpointsFromDummyNodes(), this.graphManager.resetAllEdges()), !this.isRemoteUse) {
                for (var g = this.graphManager.getAllEdges(), v = 0; v < g.length; v++)
                  g[v];
                for (var m = this.graphManager.getRoot().getNodes(), v = 0; v < m.length; v++)
                  m[v];
                this.update(this.graphManager.getRoot());
              }
            }, p.prototype.update = function(g) {
              if (g == null)
                this.update2();
              else if (g instanceof l) {
                var v = g;
                if (v.getChild() != null)
                  for (var m = v.getChild().getNodes(), b = 0; b < m.length; b++)
                    update(m[b]);
                if (v.vGraphObject != null) {
                  var y = v.vGraphObject;
                  y.update(v);
                }
              } else if (g instanceof u) {
                var x = g;
                if (x.vGraphObject != null) {
                  var E = x.vGraphObject;
                  E.update(x);
                }
              } else if (g instanceof c) {
                var S = g;
                if (S.vGraphObject != null) {
                  var w = S.vGraphObject;
                  w.update(S);
                }
              }
            }, p.prototype.initParameters = function() {
              this.isSubLayout || (this.layoutQuality = s.QUALITY, this.animationDuringLayout = s.DEFAULT_ANIMATION_DURING_LAYOUT, this.animationPeriod = s.DEFAULT_ANIMATION_PERIOD, this.animationOnLayout = s.DEFAULT_ANIMATION_ON_LAYOUT, this.incremental = s.DEFAULT_INCREMENTAL, this.createBendsAsNeeded = s.DEFAULT_CREATE_BENDS_AS_NEEDED, this.uniformLeafNodeSizes = s.DEFAULT_UNIFORM_LEAF_NODE_SIZES), this.animationDuringLayout && (this.animationOnLayout = !1);
            }, p.prototype.transform = function(g) {
              if (g == null)
                this.transform(new f(0, 0));
              else {
                var v = new h(), m = this.graphManager.getRoot().updateLeftTop();
                if (m != null) {
                  v.setWorldOrgX(g.x), v.setWorldOrgY(g.y), v.setDeviceOrgX(m.x), v.setDeviceOrgY(m.y);
                  for (var b = this.getAllNodes(), y, x = 0; x < b.length; x++)
                    y = b[x], y.transform(v);
                }
              }
            }, p.prototype.positionNodesRandomly = function(g) {
              if (g == null)
                this.positionNodesRandomly(this.getGraphManager().getRoot()), this.getGraphManager().getRoot().updateBounds(!0);
              else
                for (var v, m, b = g.getNodes(), y = 0; y < b.length; y++)
                  v = b[y], m = v.getChild(), m == null || m.getNodes().length == 0 ? v.scatter() : (this.positionNodesRandomly(m), v.updateBounds());
            }, p.prototype.getFlatForest = function() {
              for (var g = [], v = !0, m = this.graphManager.getRoot().getNodes(), b = !0, y = 0; y < m.length; y++)
                m[y].getChild() != null && (b = !1);
              if (!b)
                return g;
              var x = /* @__PURE__ */ new Set(), E = [], S = /* @__PURE__ */ new Map(), w = [];
              for (w = w.concat(m); w.length > 0 && v; ) {
                for (E.push(w[0]); E.length > 0 && v; ) {
                  var C = E[0];
                  E.splice(0, 1), x.add(C);
                  for (var k = C.getEdges(), y = 0; y < k.length; y++) {
                    var N = k[y].getOtherEnd(C);
                    if (S.get(C) != N)
                      if (!x.has(N))
                        E.push(N), S.set(N, C);
                      else {
                        v = !1;
                        break;
                      }
                  }
                }
                if (!v)
                  g = [];
                else {
                  var R = [].concat(i(x));
                  g.push(R);
                  for (var y = 0; y < R.length; y++) {
                    var _ = R[y], O = w.indexOf(_);
                    O > -1 && w.splice(O, 1);
                  }
                  x = /* @__PURE__ */ new Set(), S = /* @__PURE__ */ new Map();
                }
              }
              return g;
            }, p.prototype.createDummyNodesForBendpoints = function(g) {
              for (var v = [], m = g.source, b = this.graphManager.calcLowestCommonAncestor(g.source, g.target), y = 0; y < g.bendpoints.length; y++) {
                var x = this.newNode(null);
                x.setRect(new Point(0, 0), new Dimension(1, 1)), b.add(x);
                var E = this.newEdge(null);
                this.graphManager.add(E, m, x), v.add(x), m = x;
              }
              var E = this.newEdge(null);
              return this.graphManager.add(E, m, g.target), this.edgeToDummyNodes.set(g, v), g.isInterGraph() ? this.graphManager.remove(g) : b.remove(g), v;
            }, p.prototype.createBendpointsFromDummyNodes = function() {
              var g = [];
              g = g.concat(this.graphManager.getAllEdges()), g = [].concat(i(this.edgeToDummyNodes.keys())).concat(g);
              for (var v = 0; v < g.length; v++) {
                var m = g[v];
                if (m.bendpoints.length > 0) {
                  for (var b = this.edgeToDummyNodes.get(m), y = 0; y < b.length; y++) {
                    var x = b[y], E = new f(x.getCenterX(), x.getCenterY()), S = m.bendpoints.get(y);
                    S.x = E.x, S.y = E.y, x.getOwner().remove(x);
                  }
                  this.graphManager.add(m, m.source, m.target);
                }
              }
            }, p.transform = function(g, v, m, b) {
              if (m != null && b != null) {
                var y = v;
                if (g <= 50) {
                  var x = v / m;
                  y -= (v - x) / 50 * (50 - g);
                } else {
                  var E = v * b;
                  y += (E - v) / 50 * (g - 50);
                }
                return y;
              } else {
                var S, w;
                return g <= 50 ? (S = 9 * v / 500, w = v / 10) : (S = 9 * v / 50, w = -8 * v), S * g + w;
              }
            }, p.findCenterOfTree = function(g) {
              var v = [];
              v = v.concat(g);
              var m = [], b = /* @__PURE__ */ new Map(), y = !1, x = null;
              (v.length == 1 || v.length == 2) && (y = !0, x = v[0]);
              for (var E = 0; E < v.length; E++) {
                var S = v[E], w = S.getNeighborsList().size;
                b.set(S, S.getNeighborsList().size), w == 1 && m.push(S);
              }
              var C = [];
              for (C = C.concat(m); !y; ) {
                var k = [];
                k = k.concat(C), C = [];
                for (var E = 0; E < v.length; E++) {
                  var S = v[E], N = v.indexOf(S);
                  N >= 0 && v.splice(N, 1);
                  var R = S.getNeighborsList();
                  R.forEach(function(T) {
                    if (m.indexOf(T) < 0) {
                      var L = b.get(T), M = L - 1;
                      M == 1 && C.push(T), b.set(T, M);
                    }
                  });
                }
                m = m.concat(C), (v.length == 1 || v.length == 2) && (y = !0, x = v[0]);
              }
              return x;
            }, p.prototype.setGraphManager = function(g) {
              this.graphManager = g;
            }, r.exports = p;
          },
          /* 16 */
          /***/
          function(r, n, a) {
            function i() {
            }
            i.seed = 1, i.x = 0, i.nextDouble = function() {
              return i.x = Math.sin(i.seed++) * 1e4, i.x - Math.floor(i.x);
            }, r.exports = i;
          },
          /* 17 */
          /***/
          function(r, n, a) {
            var i = a(5);
            function s(o, l) {
              this.lworldOrgX = 0, this.lworldOrgY = 0, this.ldeviceOrgX = 0, this.ldeviceOrgY = 0, this.lworldExtX = 1, this.lworldExtY = 1, this.ldeviceExtX = 1, this.ldeviceExtY = 1;
            }
            s.prototype.getWorldOrgX = function() {
              return this.lworldOrgX;
            }, s.prototype.setWorldOrgX = function(o) {
              this.lworldOrgX = o;
            }, s.prototype.getWorldOrgY = function() {
              return this.lworldOrgY;
            }, s.prototype.setWorldOrgY = function(o) {
              this.lworldOrgY = o;
            }, s.prototype.getWorldExtX = function() {
              return this.lworldExtX;
            }, s.prototype.setWorldExtX = function(o) {
              this.lworldExtX = o;
            }, s.prototype.getWorldExtY = function() {
              return this.lworldExtY;
            }, s.prototype.setWorldExtY = function(o) {
              this.lworldExtY = o;
            }, s.prototype.getDeviceOrgX = function() {
              return this.ldeviceOrgX;
            }, s.prototype.setDeviceOrgX = function(o) {
              this.ldeviceOrgX = o;
            }, s.prototype.getDeviceOrgY = function() {
              return this.ldeviceOrgY;
            }, s.prototype.setDeviceOrgY = function(o) {
              this.ldeviceOrgY = o;
            }, s.prototype.getDeviceExtX = function() {
              return this.ldeviceExtX;
            }, s.prototype.setDeviceExtX = function(o) {
              this.ldeviceExtX = o;
            }, s.prototype.getDeviceExtY = function() {
              return this.ldeviceExtY;
            }, s.prototype.setDeviceExtY = function(o) {
              this.ldeviceExtY = o;
            }, s.prototype.transformX = function(o) {
              var l = 0, u = this.lworldExtX;
              return u != 0 && (l = this.ldeviceOrgX + (o - this.lworldOrgX) * this.ldeviceExtX / u), l;
            }, s.prototype.transformY = function(o) {
              var l = 0, u = this.lworldExtY;
              return u != 0 && (l = this.ldeviceOrgY + (o - this.lworldOrgY) * this.ldeviceExtY / u), l;
            }, s.prototype.inverseTransformX = function(o) {
              var l = 0, u = this.ldeviceExtX;
              return u != 0 && (l = this.lworldOrgX + (o - this.ldeviceOrgX) * this.lworldExtX / u), l;
            }, s.prototype.inverseTransformY = function(o) {
              var l = 0, u = this.ldeviceExtY;
              return u != 0 && (l = this.lworldOrgY + (o - this.ldeviceOrgY) * this.lworldExtY / u), l;
            }, s.prototype.inverseTransformPoint = function(o) {
              var l = new i(this.inverseTransformX(o.x), this.inverseTransformY(o.y));
              return l;
            }, r.exports = s;
          },
          /* 18 */
          /***/
          function(r, n, a) {
            function i(d) {
              if (Array.isArray(d)) {
                for (var p = 0, g = Array(d.length); p < d.length; p++)
                  g[p] = d[p];
                return g;
              } else
                return Array.from(d);
            }
            var s = a(15), o = a(4), l = a(0), u = a(8), c = a(9);
            function f() {
              s.call(this), this.useSmartIdealEdgeLengthCalculation = o.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION, this.gravityConstant = o.DEFAULT_GRAVITY_STRENGTH, this.compoundGravityConstant = o.DEFAULT_COMPOUND_GRAVITY_STRENGTH, this.gravityRangeFactor = o.DEFAULT_GRAVITY_RANGE_FACTOR, this.compoundGravityRangeFactor = o.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR, this.displacementThresholdPerNode = 3 * o.DEFAULT_EDGE_LENGTH / 100, this.coolingFactor = o.DEFAULT_COOLING_FACTOR_INCREMENTAL, this.initialCoolingFactor = o.DEFAULT_COOLING_FACTOR_INCREMENTAL, this.totalDisplacement = 0, this.oldTotalDisplacement = 0, this.maxIterations = o.MAX_ITERATIONS;
            }
            f.prototype = Object.create(s.prototype);
            for (var h in s)
              f[h] = s[h];
            f.prototype.initParameters = function() {
              s.prototype.initParameters.call(this, arguments), this.totalIterations = 0, this.notAnimatedIterations = 0, this.useFRGridVariant = o.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION, this.grid = [];
            }, f.prototype.calcIdealEdgeLengths = function() {
              for (var d, p, g, v, m, b, y, x = this.getGraphManager().getAllEdges(), E = 0; E < x.length; E++)
                d = x[E], p = d.idealLength, d.isInterGraph && (v = d.getSource(), m = d.getTarget(), b = d.getSourceInLca().getEstimatedSize(), y = d.getTargetInLca().getEstimatedSize(), this.useSmartIdealEdgeLengthCalculation && (d.idealLength += b + y - 2 * l.SIMPLE_NODE_SIZE), g = d.getLca().getInclusionTreeDepth(), d.idealLength += p * o.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR * (v.getInclusionTreeDepth() + m.getInclusionTreeDepth() - 2 * g));
            }, f.prototype.initSpringEmbedder = function() {
              var d = this.getAllNodes().length;
              this.incremental ? (d > o.ADAPTATION_LOWER_NODE_LIMIT && (this.coolingFactor = Math.max(this.coolingFactor * o.COOLING_ADAPTATION_FACTOR, this.coolingFactor - (d - o.ADAPTATION_LOWER_NODE_LIMIT) / (o.ADAPTATION_UPPER_NODE_LIMIT - o.ADAPTATION_LOWER_NODE_LIMIT) * this.coolingFactor * (1 - o.COOLING_ADAPTATION_FACTOR))), this.maxNodeDisplacement = o.MAX_NODE_DISPLACEMENT_INCREMENTAL) : (d > o.ADAPTATION_LOWER_NODE_LIMIT ? this.coolingFactor = Math.max(o.COOLING_ADAPTATION_FACTOR, 1 - (d - o.ADAPTATION_LOWER_NODE_LIMIT) / (o.ADAPTATION_UPPER_NODE_LIMIT - o.ADAPTATION_LOWER_NODE_LIMIT) * (1 - o.COOLING_ADAPTATION_FACTOR)) : this.coolingFactor = 1, this.initialCoolingFactor = this.coolingFactor, this.maxNodeDisplacement = o.MAX_NODE_DISPLACEMENT), this.maxIterations = Math.max(this.getAllNodes().length * 5, this.maxIterations), this.displacementThresholdPerNode = 3 * o.DEFAULT_EDGE_LENGTH / 100, this.totalDisplacementThreshold = this.displacementThresholdPerNode * this.getAllNodes().length, this.repulsionRange = this.calcRepulsionRange();
            }, f.prototype.calcSpringForces = function() {
              for (var d = this.getAllEdges(), p, g = 0; g < d.length; g++)
                p = d[g], this.calcSpringForce(p, p.idealLength);
            }, f.prototype.calcRepulsionForces = function() {
              var d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0, p = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, g, v, m, b, y = this.getAllNodes(), x;
              if (this.useFRGridVariant)
                for (this.totalIterations % o.GRID_CALCULATION_CHECK_PERIOD == 1 && d && this.updateGrid(), x = /* @__PURE__ */ new Set(), g = 0; g < y.length; g++)
                  m = y[g], this.calculateRepulsionForceOfANode(m, x, d, p), x.add(m);
              else
                for (g = 0; g < y.length; g++)
                  for (m = y[g], v = g + 1; v < y.length; v++)
                    b = y[v], m.getOwner() == b.getOwner() && this.calcRepulsionForce(m, b);
            }, f.prototype.calcGravitationalForces = function() {
              for (var d, p = this.getAllNodesToApplyGravitation(), g = 0; g < p.length; g++)
                d = p[g], this.calcGravitationalForce(d);
            }, f.prototype.moveNodes = function() {
              for (var d = this.getAllNodes(), p, g = 0; g < d.length; g++)
                p = d[g], p.move();
            }, f.prototype.calcSpringForce = function(d, p) {
              var g = d.getSource(), v = d.getTarget(), m, b, y, x;
              if (this.uniformLeafNodeSizes && g.getChild() == null && v.getChild() == null)
                d.updateLengthSimple();
              else if (d.updateLength(), d.isOverlapingSourceAndTarget)
                return;
              m = d.getLength(), m != 0 && (b = d.edgeElasticity * (m - p), y = b * (d.lengthX / m), x = b * (d.lengthY / m), g.springForceX += y, g.springForceY += x, v.springForceX -= y, v.springForceY -= x);
            }, f.prototype.calcRepulsionForce = function(d, p) {
              var g = d.getRect(), v = p.getRect(), m = new Array(2), b = new Array(4), y, x, E, S, w, C, k;
              if (g.intersects(v)) {
                u.calcSeparationAmount(g, v, m, o.DEFAULT_EDGE_LENGTH / 2), C = 2 * m[0], k = 2 * m[1];
                var N = d.noOfChildren * p.noOfChildren / (d.noOfChildren + p.noOfChildren);
                d.repulsionForceX -= N * C, d.repulsionForceY -= N * k, p.repulsionForceX += N * C, p.repulsionForceY += N * k;
              } else
                this.uniformLeafNodeSizes && d.getChild() == null && p.getChild() == null ? (y = v.getCenterX() - g.getCenterX(), x = v.getCenterY() - g.getCenterY()) : (u.getIntersection(g, v, b), y = b[2] - b[0], x = b[3] - b[1]), Math.abs(y) < o.MIN_REPULSION_DIST && (y = c.sign(y) * o.MIN_REPULSION_DIST), Math.abs(x) < o.MIN_REPULSION_DIST && (x = c.sign(x) * o.MIN_REPULSION_DIST), E = y * y + x * x, S = Math.sqrt(E), w = (d.nodeRepulsion / 2 + p.nodeRepulsion / 2) * d.noOfChildren * p.noOfChildren / E, C = w * y / S, k = w * x / S, d.repulsionForceX -= C, d.repulsionForceY -= k, p.repulsionForceX += C, p.repulsionForceY += k;
            }, f.prototype.calcGravitationalForce = function(d) {
              var p, g, v, m, b, y, x, E;
              p = d.getOwner(), g = (p.getRight() + p.getLeft()) / 2, v = (p.getTop() + p.getBottom()) / 2, m = d.getCenterX() - g, b = d.getCenterY() - v, y = Math.abs(m) + d.getWidth() / 2, x = Math.abs(b) + d.getHeight() / 2, d.getOwner() == this.graphManager.getRoot() ? (E = p.getEstimatedSize() * this.gravityRangeFactor, (y > E || x > E) && (d.gravitationForceX = -this.gravityConstant * m, d.gravitationForceY = -this.gravityConstant * b)) : (E = p.getEstimatedSize() * this.compoundGravityRangeFactor, (y > E || x > E) && (d.gravitationForceX = -this.gravityConstant * m * this.compoundGravityConstant, d.gravitationForceY = -this.gravityConstant * b * this.compoundGravityConstant));
            }, f.prototype.isConverged = function() {
              var d, p = !1;
              return this.totalIterations > this.maxIterations / 3 && (p = Math.abs(this.totalDisplacement - this.oldTotalDisplacement) < 2), d = this.totalDisplacement < this.totalDisplacementThreshold, this.oldTotalDisplacement = this.totalDisplacement, d || p;
            }, f.prototype.animate = function() {
              this.animationDuringLayout && !this.isSubLayout && (this.notAnimatedIterations == this.animationPeriod ? (this.update(), this.notAnimatedIterations = 0) : this.notAnimatedIterations++);
            }, f.prototype.calcNoOfChildrenForAllNodes = function() {
              for (var d, p = this.graphManager.getAllNodes(), g = 0; g < p.length; g++)
                d = p[g], d.noOfChildren = d.getNoOfChildren();
            }, f.prototype.calcGrid = function(d) {
              var p = 0, g = 0;
              p = parseInt(Math.ceil((d.getRight() - d.getLeft()) / this.repulsionRange)), g = parseInt(Math.ceil((d.getBottom() - d.getTop()) / this.repulsionRange));
              for (var v = new Array(p), m = 0; m < p; m++)
                v[m] = new Array(g);
              for (var m = 0; m < p; m++)
                for (var b = 0; b < g; b++)
                  v[m][b] = new Array();
              return v;
            }, f.prototype.addNodeToGrid = function(d, p, g) {
              var v = 0, m = 0, b = 0, y = 0;
              v = parseInt(Math.floor((d.getRect().x - p) / this.repulsionRange)), m = parseInt(Math.floor((d.getRect().width + d.getRect().x - p) / this.repulsionRange)), b = parseInt(Math.floor((d.getRect().y - g) / this.repulsionRange)), y = parseInt(Math.floor((d.getRect().height + d.getRect().y - g) / this.repulsionRange));
              for (var x = v; x <= m; x++)
                for (var E = b; E <= y; E++)
                  this.grid[x][E].push(d), d.setGridCoordinates(v, m, b, y);
            }, f.prototype.updateGrid = function() {
              var d, p, g = this.getAllNodes();
              for (this.grid = this.calcGrid(this.graphManager.getRoot()), d = 0; d < g.length; d++)
                p = g[d], this.addNodeToGrid(p, this.graphManager.getRoot().getLeft(), this.graphManager.getRoot().getTop());
            }, f.prototype.calculateRepulsionForceOfANode = function(d, p, g, v) {
              if (this.totalIterations % o.GRID_CALCULATION_CHECK_PERIOD == 1 && g || v) {
                var m = /* @__PURE__ */ new Set();
                d.surrounding = new Array();
                for (var b, y = this.grid, x = d.startX - 1; x < d.finishX + 2; x++)
                  for (var E = d.startY - 1; E < d.finishY + 2; E++)
                    if (!(x < 0 || E < 0 || x >= y.length || E >= y[0].length)) {
                      for (var S = 0; S < y[x][E].length; S++)
                        if (b = y[x][E][S], !(d.getOwner() != b.getOwner() || d == b) && !p.has(b) && !m.has(b)) {
                          var w = Math.abs(d.getCenterX() - b.getCenterX()) - (d.getWidth() / 2 + b.getWidth() / 2), C = Math.abs(d.getCenterY() - b.getCenterY()) - (d.getHeight() / 2 + b.getHeight() / 2);
                          w <= this.repulsionRange && C <= this.repulsionRange && m.add(b);
                        }
                    }
                d.surrounding = [].concat(i(m));
              }
              for (x = 0; x < d.surrounding.length; x++)
                this.calcRepulsionForce(d, d.surrounding[x]);
            }, f.prototype.calcRepulsionRange = function() {
              return 0;
            }, r.exports = f;
          },
          /* 19 */
          /***/
          function(r, n, a) {
            var i = a(1), s = a(4);
            function o(u, c, f) {
              i.call(this, u, c, f), this.idealLength = s.DEFAULT_EDGE_LENGTH, this.edgeElasticity = s.DEFAULT_SPRING_STRENGTH;
            }
            o.prototype = Object.create(i.prototype);
            for (var l in i)
              o[l] = i[l];
            r.exports = o;
          },
          /* 20 */
          /***/
          function(r, n, a) {
            var i = a(3), s = a(4);
            function o(u, c, f, h) {
              i.call(this, u, c, f, h), this.nodeRepulsion = s.DEFAULT_REPULSION_STRENGTH, this.springForceX = 0, this.springForceY = 0, this.repulsionForceX = 0, this.repulsionForceY = 0, this.gravitationForceX = 0, this.gravitationForceY = 0, this.displacementX = 0, this.displacementY = 0, this.startX = 0, this.finishX = 0, this.startY = 0, this.finishY = 0, this.surrounding = [];
            }
            o.prototype = Object.create(i.prototype);
            for (var l in i)
              o[l] = i[l];
            o.prototype.setGridCoordinates = function(u, c, f, h) {
              this.startX = u, this.finishX = c, this.startY = f, this.finishY = h;
            }, r.exports = o;
          },
          /* 21 */
          /***/
          function(r, n, a) {
            function i(s, o) {
              this.width = 0, this.height = 0, s !== null && o !== null && (this.height = o, this.width = s);
            }
            i.prototype.getWidth = function() {
              return this.width;
            }, i.prototype.setWidth = function(s) {
              this.width = s;
            }, i.prototype.getHeight = function() {
              return this.height;
            }, i.prototype.setHeight = function(s) {
              this.height = s;
            }, r.exports = i;
          },
          /* 22 */
          /***/
          function(r, n, a) {
            var i = a(14);
            function s() {
              this.map = {}, this.keys = [];
            }
            s.prototype.put = function(o, l) {
              var u = i.createID(o);
              this.contains(u) || (this.map[u] = l, this.keys.push(o));
            }, s.prototype.contains = function(o) {
              return i.createID(o), this.map[o] != null;
            }, s.prototype.get = function(o) {
              var l = i.createID(o);
              return this.map[l];
            }, s.prototype.keySet = function() {
              return this.keys;
            }, r.exports = s;
          },
          /* 23 */
          /***/
          function(r, n, a) {
            var i = a(14);
            function s() {
              this.set = {};
            }
            s.prototype.add = function(o) {
              var l = i.createID(o);
              this.contains(l) || (this.set[l] = o);
            }, s.prototype.remove = function(o) {
              delete this.set[i.createID(o)];
            }, s.prototype.clear = function() {
              this.set = {};
            }, s.prototype.contains = function(o) {
              return this.set[i.createID(o)] == o;
            }, s.prototype.isEmpty = function() {
              return this.size() === 0;
            }, s.prototype.size = function() {
              return Object.keys(this.set).length;
            }, s.prototype.addAllTo = function(o) {
              for (var l = Object.keys(this.set), u = l.length, c = 0; c < u; c++)
                o.push(this.set[l[c]]);
            }, s.prototype.size = function() {
              return Object.keys(this.set).length;
            }, s.prototype.addAll = function(o) {
              for (var l = o.length, u = 0; u < l; u++) {
                var c = o[u];
                this.add(c);
              }
            }, r.exports = s;
          },
          /* 24 */
          /***/
          function(r, n, a) {
            function i() {
            }
            i.multMat = function(s, o) {
              for (var l = [], u = 0; u < s.length; u++) {
                l[u] = [];
                for (var c = 0; c < o[0].length; c++) {
                  l[u][c] = 0;
                  for (var f = 0; f < s[0].length; f++)
                    l[u][c] += s[u][f] * o[f][c];
                }
              }
              return l;
            }, i.transpose = function(s) {
              for (var o = [], l = 0; l < s[0].length; l++) {
                o[l] = [];
                for (var u = 0; u < s.length; u++)
                  o[l][u] = s[u][l];
              }
              return o;
            }, i.multCons = function(s, o) {
              for (var l = [], u = 0; u < s.length; u++)
                l[u] = s[u] * o;
              return l;
            }, i.minusOp = function(s, o) {
              for (var l = [], u = 0; u < s.length; u++)
                l[u] = s[u] - o[u];
              return l;
            }, i.dotProduct = function(s, o) {
              for (var l = 0, u = 0; u < s.length; u++)
                l += s[u] * o[u];
              return l;
            }, i.mag = function(s) {
              return Math.sqrt(this.dotProduct(s, s));
            }, i.normalize = function(s) {
              for (var o = [], l = this.mag(s), u = 0; u < s.length; u++)
                o[u] = s[u] / l;
              return o;
            }, i.multGamma = function(s) {
              for (var o = [], l = 0, u = 0; u < s.length; u++)
                l += s[u];
              l *= -1 / s.length;
              for (var c = 0; c < s.length; c++)
                o[c] = l + s[c];
              return o;
            }, i.multL = function(s, o, l) {
              for (var u = [], c = [], f = [], h = 0; h < o[0].length; h++) {
                for (var d = 0, p = 0; p < o.length; p++)
                  d += -0.5 * o[p][h] * s[p];
                c[h] = d;
              }
              for (var g = 0; g < l.length; g++) {
                for (var v = 0, m = 0; m < l.length; m++)
                  v += l[g][m] * c[m];
                f[g] = v;
              }
              for (var b = 0; b < o.length; b++) {
                for (var y = 0, x = 0; x < o[0].length; x++)
                  y += o[b][x] * f[x];
                u[b] = y;
              }
              return u;
            }, r.exports = i;
          },
          /* 25 */
          /***/
          function(r, n, a) {
            var i = /* @__PURE__ */ function() {
              function u(c, f) {
                for (var h = 0; h < f.length; h++) {
                  var d = f[h];
                  d.enumerable = d.enumerable || !1, d.configurable = !0, "value" in d && (d.writable = !0), Object.defineProperty(c, d.key, d);
                }
              }
              return function(c, f, h) {
                return f && u(c.prototype, f), h && u(c, h), c;
              };
            }();
            function s(u, c) {
              if (!(u instanceof c))
                throw new TypeError("Cannot call a class as a function");
            }
            var o = a(11), l = function() {
              function u(c, f) {
                s(this, u), (f !== null || f !== void 0) && (this.compareFunction = this._defaultCompareFunction);
                var h = void 0;
                c instanceof o ? h = c.size() : h = c.length, this._quicksort(c, 0, h - 1);
              }
              return i(u, [{
                key: "_quicksort",
                value: function(f, h, d) {
                  if (h < d) {
                    var p = this._partition(f, h, d);
                    this._quicksort(f, h, p), this._quicksort(f, p + 1, d);
                  }
                }
              }, {
                key: "_partition",
                value: function(f, h, d) {
                  for (var p = this._get(f, h), g = h, v = d; ; ) {
                    for (; this.compareFunction(p, this._get(f, v)); )
                      v--;
                    for (; this.compareFunction(this._get(f, g), p); )
                      g++;
                    if (g < v)
                      this._swap(f, g, v), g++, v--;
                    else return v;
                  }
                }
              }, {
                key: "_get",
                value: function(f, h) {
                  return f instanceof o ? f.get_object_at(h) : f[h];
                }
              }, {
                key: "_set",
                value: function(f, h, d) {
                  f instanceof o ? f.set_object_at(h, d) : f[h] = d;
                }
              }, {
                key: "_swap",
                value: function(f, h, d) {
                  var p = this._get(f, h);
                  this._set(f, h, this._get(f, d)), this._set(f, d, p);
                }
              }, {
                key: "_defaultCompareFunction",
                value: function(f, h) {
                  return h > f;
                }
              }]), u;
            }();
            r.exports = l;
          },
          /* 26 */
          /***/
          function(r, n, a) {
            function i() {
            }
            i.svd = function(s) {
              this.U = null, this.V = null, this.s = null, this.m = 0, this.n = 0, this.m = s.length, this.n = s[0].length;
              var o = Math.min(this.m, this.n);
              this.s = function(vt) {
                for (var nt = []; vt-- > 0; )
                  nt.push(0);
                return nt;
              }(Math.min(this.m + 1, this.n)), this.U = function(vt) {
                var nt = function Dt(Gt) {
                  if (Gt.length == 0)
                    return 0;
                  for (var yt = [], ee = 0; ee < Gt[0]; ee++)
                    yt.push(Dt(Gt.slice(1)));
                  return yt;
                };
                return nt(vt);
              }([this.m, o]), this.V = function(vt) {
                var nt = function Dt(Gt) {
                  if (Gt.length == 0)
                    return 0;
                  for (var yt = [], ee = 0; ee < Gt[0]; ee++)
                    yt.push(Dt(Gt.slice(1)));
                  return yt;
                };
                return nt(vt);
              }([this.n, this.n]);
              for (var l = function(vt) {
                for (var nt = []; vt-- > 0; )
                  nt.push(0);
                return nt;
              }(this.n), u = function(vt) {
                for (var nt = []; vt-- > 0; )
                  nt.push(0);
                return nt;
              }(this.m), c = !0, f = Math.min(this.m - 1, this.n), h = Math.max(0, Math.min(this.n - 2, this.m)), d = 0; d < Math.max(f, h); d++) {
                if (d < f) {
                  this.s[d] = 0;
                  for (var p = d; p < this.m; p++)
                    this.s[d] = i.hypot(this.s[d], s[p][d]);
                  if (this.s[d] !== 0) {
                    s[d][d] < 0 && (this.s[d] = -this.s[d]);
                    for (var g = d; g < this.m; g++)
                      s[g][d] /= this.s[d];
                    s[d][d] += 1;
                  }
                  this.s[d] = -this.s[d];
                }
                for (var v = d + 1; v < this.n; v++) {
                  if (/* @__PURE__ */ function(vt, nt) {
                    return vt && nt;
                  }(d < f, this.s[d] !== 0)) {
                    for (var m = 0, b = d; b < this.m; b++)
                      m += s[b][d] * s[b][v];
                    m = -m / s[d][d];
                    for (var y = d; y < this.m; y++)
                      s[y][v] += m * s[y][d];
                  }
                  l[v] = s[d][v];
                }
                if (/* @__PURE__ */ function(vt, nt) {
                  return nt;
                }(c, d < f))
                  for (var x = d; x < this.m; x++)
                    this.U[x][d] = s[x][d];
                if (d < h) {
                  l[d] = 0;
                  for (var E = d + 1; E < this.n; E++)
                    l[d] = i.hypot(l[d], l[E]);
                  if (l[d] !== 0) {
                    l[d + 1] < 0 && (l[d] = -l[d]);
                    for (var S = d + 1; S < this.n; S++)
                      l[S] /= l[d];
                    l[d + 1] += 1;
                  }
                  if (l[d] = -l[d], /* @__PURE__ */ function(vt, nt) {
                    return vt && nt;
                  }(d + 1 < this.m, l[d] !== 0)) {
                    for (var w = d + 1; w < this.m; w++)
                      u[w] = 0;
                    for (var C = d + 1; C < this.n; C++)
                      for (var k = d + 1; k < this.m; k++)
                        u[k] += l[C] * s[k][C];
                    for (var N = d + 1; N < this.n; N++)
                      for (var R = -l[N] / l[d + 1], _ = d + 1; _ < this.m; _++)
                        s[_][N] += R * u[_];
                  }
                  for (var O = d + 1; O < this.n; O++)
                    this.V[O][d] = l[O];
                }
              }
              var T = Math.min(this.n, this.m + 1);
              f < this.n && (this.s[f] = s[f][f]), this.m < T && (this.s[T - 1] = 0), h + 1 < T && (l[h] = s[h][T - 1]), l[T - 1] = 0;
              {
                for (var L = f; L < o; L++) {
                  for (var M = 0; M < this.m; M++)
                    this.U[M][L] = 0;
                  this.U[L][L] = 1;
                }
                for (var A = f - 1; A >= 0; A--)
                  if (this.s[A] !== 0) {
                    for (var I = A + 1; I < o; I++) {
                      for (var D = 0, F = A; F < this.m; F++)
                        D += this.U[F][A] * this.U[F][I];
                      D = -D / this.U[A][A];
                      for (var B = A; B < this.m; B++)
                        this.U[B][I] += D * this.U[B][A];
                    }
                    for (var G = A; G < this.m; G++)
                      this.U[G][A] = -this.U[G][A];
                    this.U[A][A] = 1 + this.U[A][A];
                    for (var H = 0; H < A - 1; H++)
                      this.U[H][A] = 0;
                  } else {
                    for (var K = 0; K < this.m; K++)
                      this.U[K][A] = 0;
                    this.U[A][A] = 1;
                  }
              }
              for (var j = this.n - 1; j >= 0; j--) {
                if (/* @__PURE__ */ function(vt, nt) {
                  return vt && nt;
                }(j < h, l[j] !== 0))
                  for (var Z = j + 1; Z < o; Z++) {
                    for (var te = 0, ne = j + 1; ne < this.n; ne++)
                      te += this.V[ne][j] * this.V[ne][Z];
                    te = -te / this.V[j + 1][j];
                    for (var V = j + 1; V < this.n; V++)
                      this.V[V][Z] += te * this.V[V][j];
                  }
                for (var q = 0; q < this.n; q++)
                  this.V[q][j] = 0;
                this.V[j][j] = 1;
              }
              for (var X = T - 1, W = Math.pow(2, -52), ue = Math.pow(2, -966); T > 0; ) {
                var J = void 0, Ce = void 0;
                for (J = T - 2; J >= -1 && J !== -1; J--)
                  if (Math.abs(l[J]) <= ue + W * (Math.abs(this.s[J]) + Math.abs(this.s[J + 1]))) {
                    l[J] = 0;
                    break;
                  }
                if (J === T - 2)
                  Ce = 4;
                else {
                  var Ee = void 0;
                  for (Ee = T - 1; Ee >= J && Ee !== J; Ee--) {
                    var Te = (Ee !== T ? Math.abs(l[Ee]) : 0) + (Ee !== J + 1 ? Math.abs(l[Ee - 1]) : 0);
                    if (Math.abs(this.s[Ee]) <= ue + W * Te) {
                      this.s[Ee] = 0;
                      break;
                    }
                  }
                  Ee === J ? Ce = 3 : Ee === T - 1 ? Ce = 1 : (Ce = 2, J = Ee);
                }
                switch (J++, Ce) {
                  case 1:
                    {
                      var me = l[T - 2];
                      l[T - 2] = 0;
                      for (var we = T - 2; we >= J; we--) {
                        var Ae = i.hypot(this.s[we], me), Ne = this.s[we] / Ae, Ie = me / Ae;
                        this.s[we] = Ae, we !== J && (me = -Ie * l[we - 1], l[we - 1] = Ne * l[we - 1]);
                        for (var Me = 0; Me < this.n; Me++)
                          Ae = Ne * this.V[Me][we] + Ie * this.V[Me][T - 1], this.V[Me][T - 1] = -Ie * this.V[Me][we] + Ne * this.V[Me][T - 1], this.V[Me][we] = Ae;
                      }
                    }
                    break;
                  case 2:
                    {
                      var _e = l[J - 1];
                      l[J - 1] = 0;
                      for (var Be = J; Be < T; Be++) {
                        var st = i.hypot(this.s[Be], _e), ct = this.s[Be] / st, dt = _e / st;
                        this.s[Be] = st, _e = -dt * l[Be], l[Be] = ct * l[Be];
                        for (var ft = 0; ft < this.m; ft++)
                          st = ct * this.U[ft][Be] + dt * this.U[ft][J - 1], this.U[ft][J - 1] = -dt * this.U[ft][Be] + ct * this.U[ft][J - 1], this.U[ft][Be] = st;
                      }
                    }
                    break;
                  case 3:
                    {
                      var rt = Math.max(Math.max(Math.max(Math.max(Math.abs(this.s[T - 1]), Math.abs(this.s[T - 2])), Math.abs(l[T - 2])), Math.abs(this.s[J])), Math.abs(l[J])), je = this.s[T - 1] / rt, ae = this.s[T - 2] / rt, z = l[T - 2] / rt, Q = this.s[J] / rt, se = l[J] / rt, oe = ((ae + je) * (ae - je) + z * z) / 2, he = je * z * (je * z), Le = 0;
                      /* @__PURE__ */ (function(vt, nt) {
                        return vt || nt;
                      })(oe !== 0, he !== 0) && (Le = Math.sqrt(oe * oe + he), oe < 0 && (Le = -Le), Le = he / (oe + Le));
                      for (var ge = (Q + je) * (Q - je) + Le, Se = Q * se, xe = J; xe < T - 1; xe++) {
                        var $e = i.hypot(ge, Se), Ze = ge / $e, We = Se / $e;
                        xe !== J && (l[xe - 1] = $e), ge = Ze * this.s[xe] + We * l[xe], l[xe] = Ze * l[xe] - We * this.s[xe], Se = We * this.s[xe + 1], this.s[xe + 1] = Ze * this.s[xe + 1];
                        for (var He = 0; He < this.n; He++)
                          $e = Ze * this.V[He][xe] + We * this.V[He][xe + 1], this.V[He][xe + 1] = -We * this.V[He][xe] + Ze * this.V[He][xe + 1], this.V[He][xe] = $e;
                        if ($e = i.hypot(ge, Se), Ze = ge / $e, We = Se / $e, this.s[xe] = $e, ge = Ze * l[xe] + We * this.s[xe + 1], this.s[xe + 1] = -We * l[xe] + Ze * this.s[xe + 1], Se = We * l[xe + 1], l[xe + 1] = Ze * l[xe + 1], xe < this.m - 1)
                          for (var Pe = 0; Pe < this.m; Pe++)
                            $e = Ze * this.U[Pe][xe] + We * this.U[Pe][xe + 1], this.U[Pe][xe + 1] = -We * this.U[Pe][xe] + Ze * this.U[Pe][xe + 1], this.U[Pe][xe] = $e;
                      }
                      l[T - 2] = ge;
                    }
                    break;
                  case 4:
                    {
                      if (this.s[J] <= 0) {
                        this.s[J] = this.s[J] < 0 ? -this.s[J] : 0;
                        for (var De = 0; De <= X; De++)
                          this.V[De][J] = -this.V[De][J];
                      }
                      for (; J < X && !(this.s[J] >= this.s[J + 1]); ) {
                        var mt = this.s[J];
                        if (this.s[J] = this.s[J + 1], this.s[J + 1] = mt, J < this.n - 1)
                          for (var Ke = 0; Ke < this.n; Ke++)
                            mt = this.V[Ke][J + 1], this.V[Ke][J + 1] = this.V[Ke][J], this.V[Ke][J] = mt;
                        if (J < this.m - 1)
                          for (var et = 0; et < this.m; et++)
                            mt = this.U[et][J + 1], this.U[et][J + 1] = this.U[et][J], this.U[et][J] = mt;
                        J++;
                      }
                      T--;
                    }
                    break;
                }
              }
              var Pt = { U: this.U, V: this.V, S: this.s };
              return Pt;
            }, i.hypot = function(s, o) {
              var l = void 0;
              return Math.abs(s) > Math.abs(o) ? (l = o / s, l = Math.abs(s) * Math.sqrt(1 + l * l)) : o != 0 ? (l = s / o, l = Math.abs(o) * Math.sqrt(1 + l * l)) : l = 0, l;
            }, r.exports = i;
          },
          /* 27 */
          /***/
          function(r, n, a) {
            var i = /* @__PURE__ */ function() {
              function l(u, c) {
                for (var f = 0; f < c.length; f++) {
                  var h = c[f];
                  h.enumerable = h.enumerable || !1, h.configurable = !0, "value" in h && (h.writable = !0), Object.defineProperty(u, h.key, h);
                }
              }
              return function(u, c, f) {
                return c && l(u.prototype, c), f && l(u, f), u;
              };
            }();
            function s(l, u) {
              if (!(l instanceof u))
                throw new TypeError("Cannot call a class as a function");
            }
            var o = function() {
              function l(u, c) {
                var f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, h = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : -1, d = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : -1;
                s(this, l), this.sequence1 = u, this.sequence2 = c, this.match_score = f, this.mismatch_penalty = h, this.gap_penalty = d, this.iMax = u.length + 1, this.jMax = c.length + 1, this.grid = new Array(this.iMax);
                for (var p = 0; p < this.iMax; p++) {
                  this.grid[p] = new Array(this.jMax);
                  for (var g = 0; g < this.jMax; g++)
                    this.grid[p][g] = 0;
                }
                this.tracebackGrid = new Array(this.iMax);
                for (var v = 0; v < this.iMax; v++) {
                  this.tracebackGrid[v] = new Array(this.jMax);
                  for (var m = 0; m < this.jMax; m++)
                    this.tracebackGrid[v][m] = [null, null, null];
                }
                this.alignments = [], this.score = -1, this.computeGrids();
              }
              return i(l, [{
                key: "getScore",
                value: function() {
                  return this.score;
                }
              }, {
                key: "getAlignments",
                value: function() {
                  return this.alignments;
                }
                // Main dynamic programming procedure
              }, {
                key: "computeGrids",
                value: function() {
                  for (var c = 1; c < this.jMax; c++)
                    this.grid[0][c] = this.grid[0][c - 1] + this.gap_penalty, this.tracebackGrid[0][c] = [!1, !1, !0];
                  for (var f = 1; f < this.iMax; f++)
                    this.grid[f][0] = this.grid[f - 1][0] + this.gap_penalty, this.tracebackGrid[f][0] = [!1, !0, !1];
                  for (var h = 1; h < this.iMax; h++)
                    for (var d = 1; d < this.jMax; d++) {
                      var p = void 0;
                      this.sequence1[h - 1] === this.sequence2[d - 1] ? p = this.grid[h - 1][d - 1] + this.match_score : p = this.grid[h - 1][d - 1] + this.mismatch_penalty;
                      var g = this.grid[h - 1][d] + this.gap_penalty, v = this.grid[h][d - 1] + this.gap_penalty, m = [p, g, v], b = this.arrayAllMaxIndexes(m);
                      this.grid[h][d] = m[b[0]], this.tracebackGrid[h][d] = [b.includes(0), b.includes(1), b.includes(2)];
                    }
                  this.score = this.grid[this.iMax - 1][this.jMax - 1];
                }
                // Gets all possible valid sequence combinations
              }, {
                key: "alignmentTraceback",
                value: function() {
                  var c = [];
                  for (c.push({
                    pos: [this.sequence1.length, this.sequence2.length],
                    seq1: "",
                    seq2: ""
                  }); c[0]; ) {
                    var f = c[0], h = this.tracebackGrid[f.pos[0]][f.pos[1]];
                    h[0] && c.push({
                      pos: [f.pos[0] - 1, f.pos[1] - 1],
                      seq1: this.sequence1[f.pos[0] - 1] + f.seq1,
                      seq2: this.sequence2[f.pos[1] - 1] + f.seq2
                    }), h[1] && c.push({
                      pos: [f.pos[0] - 1, f.pos[1]],
                      seq1: this.sequence1[f.pos[0] - 1] + f.seq1,
                      seq2: "-" + f.seq2
                    }), h[2] && c.push({
                      pos: [f.pos[0], f.pos[1] - 1],
                      seq1: "-" + f.seq1,
                      seq2: this.sequence2[f.pos[1] - 1] + f.seq2
                    }), f.pos[0] === 0 && f.pos[1] === 0 && this.alignments.push({
                      sequence1: f.seq1,
                      sequence2: f.seq2
                    }), c.shift();
                  }
                  return this.alignments;
                }
                // Helper Functions
              }, {
                key: "getAllIndexes",
                value: function(c, f) {
                  for (var h = [], d = -1; (d = c.indexOf(f, d + 1)) !== -1; )
                    h.push(d);
                  return h;
                }
              }, {
                key: "arrayAllMaxIndexes",
                value: function(c) {
                  return this.getAllIndexes(c, Math.max.apply(null, c));
                }
              }]), l;
            }();
            r.exports = o;
          },
          /* 28 */
          /***/
          function(r, n, a) {
            var i = function() {
            };
            i.FDLayout = a(18), i.FDLayoutConstants = a(4), i.FDLayoutEdge = a(19), i.FDLayoutNode = a(20), i.DimensionD = a(21), i.HashMap = a(22), i.HashSet = a(23), i.IGeometry = a(8), i.IMath = a(9), i.Integer = a(10), i.Point = a(12), i.PointD = a(5), i.RandomSeed = a(16), i.RectangleD = a(13), i.Transform = a(17), i.UniqueIDGeneretor = a(14), i.Quicksort = a(25), i.LinkedList = a(11), i.LGraphObject = a(2), i.LGraph = a(6), i.LEdge = a(1), i.LGraphManager = a(7), i.LNode = a(3), i.Layout = a(15), i.LayoutConstants = a(0), i.NeedlemanWunsch = a(27), i.Matrix = a(24), i.SVD = a(26), r.exports = i;
          },
          /* 29 */
          /***/
          function(r, n, a) {
            function i() {
              this.listeners = [];
            }
            var s = i.prototype;
            s.addListener = function(o, l) {
              this.listeners.push({
                event: o,
                callback: l
              });
            }, s.removeListener = function(o, l) {
              for (var u = this.listeners.length; u >= 0; u--) {
                var c = this.listeners[u];
                c.event === o && c.callback === l && this.listeners.splice(u, 1);
              }
            }, s.emit = function(o, l) {
              for (var u = 0; u < this.listeners.length; u++) {
                var c = this.listeners[u];
                o === c.event && c.callback(l);
              }
            }, r.exports = i;
          }
          /******/
        ])
      );
    });
  }(fE)), fE.exports;
}
var U8;
function lMe() {
  return U8 || (U8 = 1, function(t, e) {
    (function(n, a) {
      t.exports = a(oMe());
    })(Jt, function(r) {
      return (
        /******/
        (() => {
          var n = {
            /***/
            45: (
              /***/
              (o, l, u) => {
                var c = {};
                c.layoutBase = u(551), c.CoSEConstants = u(806), c.CoSEEdge = u(767), c.CoSEGraph = u(880), c.CoSEGraphManager = u(578), c.CoSELayout = u(765), c.CoSENode = u(991), c.ConstraintHandler = u(902), o.exports = c;
              }
            ),
            /***/
            806: (
              /***/
              (o, l, u) => {
                var c = u(551).FDLayoutConstants;
                function f() {
                }
                for (var h in c)
                  f[h] = c[h];
                f.DEFAULT_USE_MULTI_LEVEL_SCALING = !1, f.DEFAULT_RADIAL_SEPARATION = c.DEFAULT_EDGE_LENGTH, f.DEFAULT_COMPONENT_SEPERATION = 60, f.TILE = !0, f.TILING_PADDING_VERTICAL = 10, f.TILING_PADDING_HORIZONTAL = 10, f.TRANSFORM_ON_CONSTRAINT_HANDLING = !0, f.ENFORCE_CONSTRAINTS = !0, f.APPLY_LAYOUT = !0, f.RELAX_MOVEMENT_ON_CONSTRAINTS = !0, f.TREE_REDUCTION_ON_INCREMENTAL = !0, f.PURE_INCREMENTAL = f.DEFAULT_INCREMENTAL, o.exports = f;
              }
            ),
            /***/
            767: (
              /***/
              (o, l, u) => {
                var c = u(551).FDLayoutEdge;
                function f(d, p, g) {
                  c.call(this, d, p, g);
                }
                f.prototype = Object.create(c.prototype);
                for (var h in c)
                  f[h] = c[h];
                o.exports = f;
              }
            ),
            /***/
            880: (
              /***/
              (o, l, u) => {
                var c = u(551).LGraph;
                function f(d, p, g) {
                  c.call(this, d, p, g);
                }
                f.prototype = Object.create(c.prototype);
                for (var h in c)
                  f[h] = c[h];
                o.exports = f;
              }
            ),
            /***/
            578: (
              /***/
              (o, l, u) => {
                var c = u(551).LGraphManager;
                function f(d) {
                  c.call(this, d);
                }
                f.prototype = Object.create(c.prototype);
                for (var h in c)
                  f[h] = c[h];
                o.exports = f;
              }
            ),
            /***/
            765: (
              /***/
              (o, l, u) => {
                var c = u(551).FDLayout, f = u(578), h = u(880), d = u(991), p = u(767), g = u(806), v = u(902), m = u(551).FDLayoutConstants, b = u(551).LayoutConstants, y = u(551).Point, x = u(551).PointD, E = u(551).DimensionD, S = u(551).Layout, w = u(551).Integer, C = u(551).IGeometry, k = u(551).LGraph, N = u(551).Transform, R = u(551).LinkedList;
                function _() {
                  c.call(this), this.toBeTiled = {}, this.constraints = {};
                }
                _.prototype = Object.create(c.prototype);
                for (var O in c)
                  _[O] = c[O];
                _.prototype.newGraphManager = function() {
                  var T = new f(this);
                  return this.graphManager = T, T;
                }, _.prototype.newGraph = function(T) {
                  return new h(null, this.graphManager, T);
                }, _.prototype.newNode = function(T) {
                  return new d(this.graphManager, T);
                }, _.prototype.newEdge = function(T) {
                  return new p(null, null, T);
                }, _.prototype.initParameters = function() {
                  c.prototype.initParameters.call(this, arguments), this.isSubLayout || (g.DEFAULT_EDGE_LENGTH < 10 ? this.idealEdgeLength = 10 : this.idealEdgeLength = g.DEFAULT_EDGE_LENGTH, this.useSmartIdealEdgeLengthCalculation = g.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION, this.gravityConstant = m.DEFAULT_GRAVITY_STRENGTH, this.compoundGravityConstant = m.DEFAULT_COMPOUND_GRAVITY_STRENGTH, this.gravityRangeFactor = m.DEFAULT_GRAVITY_RANGE_FACTOR, this.compoundGravityRangeFactor = m.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR, this.prunedNodesAll = [], this.growTreeIterations = 0, this.afterGrowthIterations = 0, this.isTreeGrowing = !1, this.isGrowthFinished = !1);
                }, _.prototype.initSpringEmbedder = function() {
                  c.prototype.initSpringEmbedder.call(this), this.coolingCycle = 0, this.maxCoolingCycle = this.maxIterations / m.CONVERGENCE_CHECK_PERIOD, this.finalTemperature = 0.04, this.coolingAdjuster = 1;
                }, _.prototype.layout = function() {
                  var T = b.DEFAULT_CREATE_BENDS_AS_NEEDED;
                  return T && (this.createBendpoints(), this.graphManager.resetAllEdges()), this.level = 0, this.classicLayout();
                }, _.prototype.classicLayout = function() {
                  if (this.nodesWithGravity = this.calculateNodesToApplyGravitationTo(), this.graphManager.setAllNodesToApplyGravitation(this.nodesWithGravity), this.calcNoOfChildrenForAllNodes(), this.graphManager.calcLowestCommonAncestors(), this.graphManager.calcInclusionTreeDepths(), this.graphManager.getRoot().calcEstimatedSize(), this.calcIdealEdgeLengths(), this.incremental) {
                    if (g.TREE_REDUCTION_ON_INCREMENTAL) {
                      this.reduceTrees(), this.graphManager.resetAllNodesToApplyGravitation();
                      var L = new Set(this.getAllNodes()), M = this.nodesWithGravity.filter(function(D) {
                        return L.has(D);
                      });
                      this.graphManager.setAllNodesToApplyGravitation(M);
                    }
                  } else {
                    var T = this.getFlatForest();
                    if (T.length > 0)
                      this.positionNodesRadially(T);
                    else {
                      this.reduceTrees(), this.graphManager.resetAllNodesToApplyGravitation();
                      var L = new Set(this.getAllNodes()), M = this.nodesWithGravity.filter(function(A) {
                        return L.has(A);
                      });
                      this.graphManager.setAllNodesToApplyGravitation(M), this.positionNodesRandomly();
                    }
                  }
                  return Object.keys(this.constraints).length > 0 && (v.handleConstraints(this), this.initConstraintVariables()), this.initSpringEmbedder(), g.APPLY_LAYOUT && this.runSpringEmbedder(), !0;
                }, _.prototype.tick = function() {
                  if (this.totalIterations++, this.totalIterations === this.maxIterations && !this.isTreeGrowing && !this.isGrowthFinished)
                    if (this.prunedNodesAll.length > 0)
                      this.isTreeGrowing = !0;
                    else
                      return !0;
                  if (this.totalIterations % m.CONVERGENCE_CHECK_PERIOD == 0 && !this.isTreeGrowing && !this.isGrowthFinished) {
                    if (this.isConverged())
                      if (this.prunedNodesAll.length > 0)
                        this.isTreeGrowing = !0;
                      else
                        return !0;
                    this.coolingCycle++, this.layoutQuality == 0 ? this.coolingAdjuster = this.coolingCycle : this.layoutQuality == 1 && (this.coolingAdjuster = this.coolingCycle / 3), this.coolingFactor = Math.max(this.initialCoolingFactor - Math.pow(this.coolingCycle, Math.log(100 * (this.initialCoolingFactor - this.finalTemperature)) / Math.log(this.maxCoolingCycle)) / 100 * this.coolingAdjuster, this.finalTemperature), this.animationPeriod = Math.ceil(this.initialAnimationPeriod * Math.sqrt(this.coolingFactor));
                  }
                  if (this.isTreeGrowing) {
                    if (this.growTreeIterations % 10 == 0)
                      if (this.prunedNodesAll.length > 0) {
                        this.graphManager.updateBounds(), this.updateGrid(), this.growTree(this.prunedNodesAll), this.graphManager.resetAllNodesToApplyGravitation();
                        var T = new Set(this.getAllNodes()), L = this.nodesWithGravity.filter(function(I) {
                          return T.has(I);
                        });
                        this.graphManager.setAllNodesToApplyGravitation(L), this.graphManager.updateBounds(), this.updateGrid(), g.PURE_INCREMENTAL ? this.coolingFactor = m.DEFAULT_COOLING_FACTOR_INCREMENTAL / 2 : this.coolingFactor = m.DEFAULT_COOLING_FACTOR_INCREMENTAL;
                      } else
                        this.isTreeGrowing = !1, this.isGrowthFinished = !0;
                    this.growTreeIterations++;
                  }
                  if (this.isGrowthFinished) {
                    if (this.isConverged())
                      return !0;
                    this.afterGrowthIterations % 10 == 0 && (this.graphManager.updateBounds(), this.updateGrid()), g.PURE_INCREMENTAL ? this.coolingFactor = m.DEFAULT_COOLING_FACTOR_INCREMENTAL / 2 * ((100 - this.afterGrowthIterations) / 100) : this.coolingFactor = m.DEFAULT_COOLING_FACTOR_INCREMENTAL * ((100 - this.afterGrowthIterations) / 100), this.afterGrowthIterations++;
                  }
                  var M = !this.isTreeGrowing && !this.isGrowthFinished, A = this.growTreeIterations % 10 == 1 && this.isTreeGrowing || this.afterGrowthIterations % 10 == 1 && this.isGrowthFinished;
                  return this.totalDisplacement = 0, this.graphManager.updateBounds(), this.calcSpringForces(), this.calcRepulsionForces(M, A), this.calcGravitationalForces(), this.moveNodes(), this.animate(), !1;
                }, _.prototype.getPositionsData = function() {
                  for (var T = this.graphManager.getAllNodes(), L = {}, M = 0; M < T.length; M++) {
                    var A = T[M].rect, I = T[M].id;
                    L[I] = {
                      id: I,
                      x: A.getCenterX(),
                      y: A.getCenterY(),
                      w: A.width,
                      h: A.height
                    };
                  }
                  return L;
                }, _.prototype.runSpringEmbedder = function() {
                  this.initialAnimationPeriod = 25, this.animationPeriod = this.initialAnimationPeriod;
                  var T = !1;
                  if (m.ANIMATE === "during")
                    this.emit("layoutstarted");
                  else {
                    for (; !T; )
                      T = this.tick();
                    this.graphManager.updateBounds();
                  }
                }, _.prototype.moveNodes = function() {
                  for (var T = this.getAllNodes(), L, M = 0; M < T.length; M++)
                    L = T[M], L.calculateDisplacement();
                  Object.keys(this.constraints).length > 0 && this.updateDisplacements();
                  for (var M = 0; M < T.length; M++)
                    L = T[M], L.move();
                }, _.prototype.initConstraintVariables = function() {
                  var T = this;
                  this.idToNodeMap = /* @__PURE__ */ new Map(), this.fixedNodeSet = /* @__PURE__ */ new Set();
                  for (var L = this.graphManager.getAllNodes(), M = 0; M < L.length; M++) {
                    var A = L[M];
                    this.idToNodeMap.set(A.id, A);
                  }
                  var I = function V(q) {
                    for (var X = q.getChild().getNodes(), W, ue = 0, J = 0; J < X.length; J++)
                      W = X[J], W.getChild() == null ? T.fixedNodeSet.has(W.id) && (ue += 100) : ue += V(W);
                    return ue;
                  };
                  if (this.constraints.fixedNodeConstraint) {
                    this.constraints.fixedNodeConstraint.forEach(function(X) {
                      T.fixedNodeSet.add(X.nodeId);
                    });
                    for (var L = this.graphManager.getAllNodes(), A, M = 0; M < L.length; M++)
                      if (A = L[M], A.getChild() != null) {
                        var D = I(A);
                        D > 0 && (A.fixedNodeWeight = D);
                      }
                  }
                  if (this.constraints.relativePlacementConstraint) {
                    var F = /* @__PURE__ */ new Map(), B = /* @__PURE__ */ new Map();
                    if (this.dummyToNodeForVerticalAlignment = /* @__PURE__ */ new Map(), this.dummyToNodeForHorizontalAlignment = /* @__PURE__ */ new Map(), this.fixedNodesOnHorizontal = /* @__PURE__ */ new Set(), this.fixedNodesOnVertical = /* @__PURE__ */ new Set(), this.fixedNodeSet.forEach(function(V) {
                      T.fixedNodesOnHorizontal.add(V), T.fixedNodesOnVertical.add(V);
                    }), this.constraints.alignmentConstraint) {
                      if (this.constraints.alignmentConstraint.vertical)
                        for (var G = this.constraints.alignmentConstraint.vertical, M = 0; M < G.length; M++)
                          this.dummyToNodeForVerticalAlignment.set("dummy" + M, []), G[M].forEach(function(q) {
                            F.set(q, "dummy" + M), T.dummyToNodeForVerticalAlignment.get("dummy" + M).push(q), T.fixedNodeSet.has(q) && T.fixedNodesOnHorizontal.add("dummy" + M);
                          });
                      if (this.constraints.alignmentConstraint.horizontal)
                        for (var H = this.constraints.alignmentConstraint.horizontal, M = 0; M < H.length; M++)
                          this.dummyToNodeForHorizontalAlignment.set("dummy" + M, []), H[M].forEach(function(q) {
                            B.set(q, "dummy" + M), T.dummyToNodeForHorizontalAlignment.get("dummy" + M).push(q), T.fixedNodeSet.has(q) && T.fixedNodesOnVertical.add("dummy" + M);
                          });
                    }
                    if (g.RELAX_MOVEMENT_ON_CONSTRAINTS)
                      this.shuffle = function(V) {
                        var q, X, W;
                        for (W = V.length - 1; W >= 2 * V.length / 3; W--)
                          q = Math.floor(Math.random() * (W + 1)), X = V[W], V[W] = V[q], V[q] = X;
                        return V;
                      }, this.nodesInRelativeHorizontal = [], this.nodesInRelativeVertical = [], this.nodeToRelativeConstraintMapHorizontal = /* @__PURE__ */ new Map(), this.nodeToRelativeConstraintMapVertical = /* @__PURE__ */ new Map(), this.nodeToTempPositionMapHorizontal = /* @__PURE__ */ new Map(), this.nodeToTempPositionMapVertical = /* @__PURE__ */ new Map(), this.constraints.relativePlacementConstraint.forEach(function(V) {
                        if (V.left) {
                          var q = F.has(V.left) ? F.get(V.left) : V.left, X = F.has(V.right) ? F.get(V.right) : V.right;
                          T.nodesInRelativeHorizontal.includes(q) || (T.nodesInRelativeHorizontal.push(q), T.nodeToRelativeConstraintMapHorizontal.set(q, []), T.dummyToNodeForVerticalAlignment.has(q) ? T.nodeToTempPositionMapHorizontal.set(q, T.idToNodeMap.get(T.dummyToNodeForVerticalAlignment.get(q)[0]).getCenterX()) : T.nodeToTempPositionMapHorizontal.set(q, T.idToNodeMap.get(q).getCenterX())), T.nodesInRelativeHorizontal.includes(X) || (T.nodesInRelativeHorizontal.push(X), T.nodeToRelativeConstraintMapHorizontal.set(X, []), T.dummyToNodeForVerticalAlignment.has(X) ? T.nodeToTempPositionMapHorizontal.set(X, T.idToNodeMap.get(T.dummyToNodeForVerticalAlignment.get(X)[0]).getCenterX()) : T.nodeToTempPositionMapHorizontal.set(X, T.idToNodeMap.get(X).getCenterX())), T.nodeToRelativeConstraintMapHorizontal.get(q).push({ right: X, gap: V.gap }), T.nodeToRelativeConstraintMapHorizontal.get(X).push({ left: q, gap: V.gap });
                        } else {
                          var W = B.has(V.top) ? B.get(V.top) : V.top, ue = B.has(V.bottom) ? B.get(V.bottom) : V.bottom;
                          T.nodesInRelativeVertical.includes(W) || (T.nodesInRelativeVertical.push(W), T.nodeToRelativeConstraintMapVertical.set(W, []), T.dummyToNodeForHorizontalAlignment.has(W) ? T.nodeToTempPositionMapVertical.set(W, T.idToNodeMap.get(T.dummyToNodeForHorizontalAlignment.get(W)[0]).getCenterY()) : T.nodeToTempPositionMapVertical.set(W, T.idToNodeMap.get(W).getCenterY())), T.nodesInRelativeVertical.includes(ue) || (T.nodesInRelativeVertical.push(ue), T.nodeToRelativeConstraintMapVertical.set(ue, []), T.dummyToNodeForHorizontalAlignment.has(ue) ? T.nodeToTempPositionMapVertical.set(ue, T.idToNodeMap.get(T.dummyToNodeForHorizontalAlignment.get(ue)[0]).getCenterY()) : T.nodeToTempPositionMapVertical.set(ue, T.idToNodeMap.get(ue).getCenterY())), T.nodeToRelativeConstraintMapVertical.get(W).push({ bottom: ue, gap: V.gap }), T.nodeToRelativeConstraintMapVertical.get(ue).push({ top: W, gap: V.gap });
                        }
                      });
                    else {
                      var K = /* @__PURE__ */ new Map(), j = /* @__PURE__ */ new Map();
                      this.constraints.relativePlacementConstraint.forEach(function(V) {
                        if (V.left) {
                          var q = F.has(V.left) ? F.get(V.left) : V.left, X = F.has(V.right) ? F.get(V.right) : V.right;
                          K.has(q) ? K.get(q).push(X) : K.set(q, [X]), K.has(X) ? K.get(X).push(q) : K.set(X, [q]);
                        } else {
                          var W = B.has(V.top) ? B.get(V.top) : V.top, ue = B.has(V.bottom) ? B.get(V.bottom) : V.bottom;
                          j.has(W) ? j.get(W).push(ue) : j.set(W, [ue]), j.has(ue) ? j.get(ue).push(W) : j.set(ue, [W]);
                        }
                      });
                      var Z = function(q, X) {
                        var W = [], ue = [], J = new R(), Ce = /* @__PURE__ */ new Set(), Ee = 0;
                        return q.forEach(function(Te, me) {
                          if (!Ce.has(me)) {
                            W[Ee] = [], ue[Ee] = !1;
                            var we = me;
                            for (J.push(we), Ce.add(we), W[Ee].push(we); J.length != 0; ) {
                              we = J.shift(), X.has(we) && (ue[Ee] = !0);
                              var Ae = q.get(we);
                              Ae.forEach(function(Ne) {
                                Ce.has(Ne) || (J.push(Ne), Ce.add(Ne), W[Ee].push(Ne));
                              });
                            }
                            Ee++;
                          }
                        }), { components: W, isFixed: ue };
                      }, te = Z(K, T.fixedNodesOnHorizontal);
                      this.componentsOnHorizontal = te.components, this.fixedComponentsOnHorizontal = te.isFixed;
                      var ne = Z(j, T.fixedNodesOnVertical);
                      this.componentsOnVertical = ne.components, this.fixedComponentsOnVertical = ne.isFixed;
                    }
                  }
                }, _.prototype.updateDisplacements = function() {
                  var T = this;
                  if (this.constraints.fixedNodeConstraint && this.constraints.fixedNodeConstraint.forEach(function(ne) {
                    var V = T.idToNodeMap.get(ne.nodeId);
                    V.displacementX = 0, V.displacementY = 0;
                  }), this.constraints.alignmentConstraint) {
                    if (this.constraints.alignmentConstraint.vertical)
                      for (var L = this.constraints.alignmentConstraint.vertical, M = 0; M < L.length; M++) {
                        for (var A = 0, I = 0; I < L[M].length; I++) {
                          if (this.fixedNodeSet.has(L[M][I])) {
                            A = 0;
                            break;
                          }
                          A += this.idToNodeMap.get(L[M][I]).displacementX;
                        }
                        for (var D = A / L[M].length, I = 0; I < L[M].length; I++)
                          this.idToNodeMap.get(L[M][I]).displacementX = D;
                      }
                    if (this.constraints.alignmentConstraint.horizontal)
                      for (var F = this.constraints.alignmentConstraint.horizontal, M = 0; M < F.length; M++) {
                        for (var B = 0, I = 0; I < F[M].length; I++) {
                          if (this.fixedNodeSet.has(F[M][I])) {
                            B = 0;
                            break;
                          }
                          B += this.idToNodeMap.get(F[M][I]).displacementY;
                        }
                        for (var G = B / F[M].length, I = 0; I < F[M].length; I++)
                          this.idToNodeMap.get(F[M][I]).displacementY = G;
                      }
                  }
                  if (this.constraints.relativePlacementConstraint)
                    if (g.RELAX_MOVEMENT_ON_CONSTRAINTS)
                      this.totalIterations % 10 == 0 && (this.shuffle(this.nodesInRelativeHorizontal), this.shuffle(this.nodesInRelativeVertical)), this.nodesInRelativeHorizontal.forEach(function(ne) {
                        if (!T.fixedNodesOnHorizontal.has(ne)) {
                          var V = 0;
                          T.dummyToNodeForVerticalAlignment.has(ne) ? V = T.idToNodeMap.get(T.dummyToNodeForVerticalAlignment.get(ne)[0]).displacementX : V = T.idToNodeMap.get(ne).displacementX, T.nodeToRelativeConstraintMapHorizontal.get(ne).forEach(function(q) {
                            if (q.right) {
                              var X = T.nodeToTempPositionMapHorizontal.get(q.right) - T.nodeToTempPositionMapHorizontal.get(ne) - V;
                              X < q.gap && (V -= q.gap - X);
                            } else {
                              var X = T.nodeToTempPositionMapHorizontal.get(ne) - T.nodeToTempPositionMapHorizontal.get(q.left) + V;
                              X < q.gap && (V += q.gap - X);
                            }
                          }), T.nodeToTempPositionMapHorizontal.set(ne, T.nodeToTempPositionMapHorizontal.get(ne) + V), T.dummyToNodeForVerticalAlignment.has(ne) ? T.dummyToNodeForVerticalAlignment.get(ne).forEach(function(q) {
                            T.idToNodeMap.get(q).displacementX = V;
                          }) : T.idToNodeMap.get(ne).displacementX = V;
                        }
                      }), this.nodesInRelativeVertical.forEach(function(ne) {
                        if (!T.fixedNodesOnHorizontal.has(ne)) {
                          var V = 0;
                          T.dummyToNodeForHorizontalAlignment.has(ne) ? V = T.idToNodeMap.get(T.dummyToNodeForHorizontalAlignment.get(ne)[0]).displacementY : V = T.idToNodeMap.get(ne).displacementY, T.nodeToRelativeConstraintMapVertical.get(ne).forEach(function(q) {
                            if (q.bottom) {
                              var X = T.nodeToTempPositionMapVertical.get(q.bottom) - T.nodeToTempPositionMapVertical.get(ne) - V;
                              X < q.gap && (V -= q.gap - X);
                            } else {
                              var X = T.nodeToTempPositionMapVertical.get(ne) - T.nodeToTempPositionMapVertical.get(q.top) + V;
                              X < q.gap && (V += q.gap - X);
                            }
                          }), T.nodeToTempPositionMapVertical.set(ne, T.nodeToTempPositionMapVertical.get(ne) + V), T.dummyToNodeForHorizontalAlignment.has(ne) ? T.dummyToNodeForHorizontalAlignment.get(ne).forEach(function(q) {
                            T.idToNodeMap.get(q).displacementY = V;
                          }) : T.idToNodeMap.get(ne).displacementY = V;
                        }
                      });
                    else {
                      for (var M = 0; M < this.componentsOnHorizontal.length; M++) {
                        var H = this.componentsOnHorizontal[M];
                        if (this.fixedComponentsOnHorizontal[M])
                          for (var I = 0; I < H.length; I++)
                            this.dummyToNodeForVerticalAlignment.has(H[I]) ? this.dummyToNodeForVerticalAlignment.get(H[I]).forEach(function(q) {
                              T.idToNodeMap.get(q).displacementX = 0;
                            }) : this.idToNodeMap.get(H[I]).displacementX = 0;
                        else {
                          for (var K = 0, j = 0, I = 0; I < H.length; I++)
                            if (this.dummyToNodeForVerticalAlignment.has(H[I])) {
                              var Z = this.dummyToNodeForVerticalAlignment.get(H[I]);
                              K += Z.length * this.idToNodeMap.get(Z[0]).displacementX, j += Z.length;
                            } else
                              K += this.idToNodeMap.get(H[I]).displacementX, j++;
                          for (var te = K / j, I = 0; I < H.length; I++)
                            this.dummyToNodeForVerticalAlignment.has(H[I]) ? this.dummyToNodeForVerticalAlignment.get(H[I]).forEach(function(q) {
                              T.idToNodeMap.get(q).displacementX = te;
                            }) : this.idToNodeMap.get(H[I]).displacementX = te;
                        }
                      }
                      for (var M = 0; M < this.componentsOnVertical.length; M++) {
                        var H = this.componentsOnVertical[M];
                        if (this.fixedComponentsOnVertical[M])
                          for (var I = 0; I < H.length; I++)
                            this.dummyToNodeForHorizontalAlignment.has(H[I]) ? this.dummyToNodeForHorizontalAlignment.get(H[I]).forEach(function(X) {
                              T.idToNodeMap.get(X).displacementY = 0;
                            }) : this.idToNodeMap.get(H[I]).displacementY = 0;
                        else {
                          for (var K = 0, j = 0, I = 0; I < H.length; I++)
                            if (this.dummyToNodeForHorizontalAlignment.has(H[I])) {
                              var Z = this.dummyToNodeForHorizontalAlignment.get(H[I]);
                              K += Z.length * this.idToNodeMap.get(Z[0]).displacementY, j += Z.length;
                            } else
                              K += this.idToNodeMap.get(H[I]).displacementY, j++;
                          for (var te = K / j, I = 0; I < H.length; I++)
                            this.dummyToNodeForHorizontalAlignment.has(H[I]) ? this.dummyToNodeForHorizontalAlignment.get(H[I]).forEach(function(J) {
                              T.idToNodeMap.get(J).displacementY = te;
                            }) : this.idToNodeMap.get(H[I]).displacementY = te;
                        }
                      }
                    }
                }, _.prototype.calculateNodesToApplyGravitationTo = function() {
                  var T = [], L, M = this.graphManager.getGraphs(), A = M.length, I;
                  for (I = 0; I < A; I++)
                    L = M[I], L.updateConnected(), L.isConnected || (T = T.concat(L.getNodes()));
                  return T;
                }, _.prototype.createBendpoints = function() {
                  var T = [];
                  T = T.concat(this.graphManager.getAllEdges());
                  var L = /* @__PURE__ */ new Set(), M;
                  for (M = 0; M < T.length; M++) {
                    var A = T[M];
                    if (!L.has(A)) {
                      var I = A.getSource(), D = A.getTarget();
                      if (I == D)
                        A.getBendpoints().push(new x()), A.getBendpoints().push(new x()), this.createDummyNodesForBendpoints(A), L.add(A);
                      else {
                        var F = [];
                        if (F = F.concat(I.getEdgeListToNode(D)), F = F.concat(D.getEdgeListToNode(I)), !L.has(F[0])) {
                          if (F.length > 1) {
                            var B;
                            for (B = 0; B < F.length; B++) {
                              var G = F[B];
                              G.getBendpoints().push(new x()), this.createDummyNodesForBendpoints(G);
                            }
                          }
                          F.forEach(function(H) {
                            L.add(H);
                          });
                        }
                      }
                    }
                    if (L.size == T.length)
                      break;
                  }
                }, _.prototype.positionNodesRadially = function(T) {
                  for (var L = new y(0, 0), M = Math.ceil(Math.sqrt(T.length)), A = 0, I = 0, D = 0, F = new x(0, 0), B = 0; B < T.length; B++) {
                    B % M == 0 && (D = 0, I = A, B != 0 && (I += g.DEFAULT_COMPONENT_SEPERATION), A = 0);
                    var G = T[B], H = S.findCenterOfTree(G);
                    L.x = D, L.y = I, F = _.radialLayout(G, H, L), F.y > A && (A = Math.floor(F.y)), D = Math.floor(F.x + g.DEFAULT_COMPONENT_SEPERATION);
                  }
                  this.transform(new x(b.WORLD_CENTER_X - F.x / 2, b.WORLD_CENTER_Y - F.y / 2));
                }, _.radialLayout = function(T, L, M) {
                  var A = Math.max(this.maxDiagonalInTree(T), g.DEFAULT_RADIAL_SEPARATION);
                  _.branchRadialLayout(L, null, 0, 359, 0, A);
                  var I = k.calculateBounds(T), D = new N();
                  D.setDeviceOrgX(I.getMinX()), D.setDeviceOrgY(I.getMinY()), D.setWorldOrgX(M.x), D.setWorldOrgY(M.y);
                  for (var F = 0; F < T.length; F++) {
                    var B = T[F];
                    B.transform(D);
                  }
                  var G = new x(I.getMaxX(), I.getMaxY());
                  return D.inverseTransformPoint(G);
                }, _.branchRadialLayout = function(T, L, M, A, I, D) {
                  var F = (A - M + 1) / 2;
                  F < 0 && (F += 180);
                  var B = (F + M) % 360, G = B * C.TWO_PI / 360, H = I * Math.cos(G), K = I * Math.sin(G);
                  T.setCenter(H, K);
                  var j = [];
                  j = j.concat(T.getEdges());
                  var Z = j.length;
                  L != null && Z--;
                  for (var te = 0, ne = j.length, V, q = T.getEdgesBetween(L); q.length > 1; ) {
                    var X = q[0];
                    q.splice(0, 1);
                    var W = j.indexOf(X);
                    W >= 0 && j.splice(W, 1), ne--, Z--;
                  }
                  L != null ? V = (j.indexOf(q[0]) + 1) % ne : V = 0;
                  for (var ue = Math.abs(A - M) / Z, J = V; te != Z; J = ++J % ne) {
                    var Ce = j[J].getOtherEnd(T);
                    if (Ce != L) {
                      var Ee = (M + te * ue) % 360, Te = (Ee + ue) % 360;
                      _.branchRadialLayout(Ce, T, Ee, Te, I + D, D), te++;
                    }
                  }
                }, _.maxDiagonalInTree = function(T) {
                  for (var L = w.MIN_VALUE, M = 0; M < T.length; M++) {
                    var A = T[M], I = A.getDiagonal();
                    I > L && (L = I);
                  }
                  return L;
                }, _.prototype.calcRepulsionRange = function() {
                  return 2 * (this.level + 1) * this.idealEdgeLength;
                }, _.prototype.groupZeroDegreeMembers = function() {
                  var T = this, L = {};
                  this.memberGroups = {}, this.idToDummyNode = {};
                  for (var M = [], A = this.graphManager.getAllNodes(), I = 0; I < A.length; I++) {
                    var D = A[I], F = D.getParent();
                    this.getNodeDegreeWithChildren(D) === 0 && (F.id == null || !this.getToBeTiled(F)) && M.push(D);
                  }
                  for (var I = 0; I < M.length; I++) {
                    var D = M[I], B = D.getParent().id;
                    typeof L[B] > "u" && (L[B] = []), L[B] = L[B].concat(D);
                  }
                  Object.keys(L).forEach(function(G) {
                    if (L[G].length > 1) {
                      var H = "DummyCompound_" + G;
                      T.memberGroups[H] = L[G];
                      var K = L[G][0].getParent(), j = new d(T.graphManager);
                      j.id = H, j.paddingLeft = K.paddingLeft || 0, j.paddingRight = K.paddingRight || 0, j.paddingBottom = K.paddingBottom || 0, j.paddingTop = K.paddingTop || 0, T.idToDummyNode[H] = j;
                      var Z = T.getGraphManager().add(T.newGraph(), j), te = K.getChild();
                      te.add(j);
                      for (var ne = 0; ne < L[G].length; ne++) {
                        var V = L[G][ne];
                        te.remove(V), Z.add(V);
                      }
                    }
                  });
                }, _.prototype.clearCompounds = function() {
                  var T = {}, L = {};
                  this.performDFSOnCompounds();
                  for (var M = 0; M < this.compoundOrder.length; M++)
                    L[this.compoundOrder[M].id] = this.compoundOrder[M], T[this.compoundOrder[M].id] = [].concat(this.compoundOrder[M].getChild().getNodes()), this.graphManager.remove(this.compoundOrder[M].getChild()), this.compoundOrder[M].child = null;
                  this.graphManager.resetAllNodes(), this.tileCompoundMembers(T, L);
                }, _.prototype.clearZeroDegreeMembers = function() {
                  var T = this, L = this.tiledZeroDegreePack = [];
                  Object.keys(this.memberGroups).forEach(function(M) {
                    var A = T.idToDummyNode[M];
                    if (L[M] = T.tileNodes(T.memberGroups[M], A.paddingLeft + A.paddingRight), A.rect.width = L[M].width, A.rect.height = L[M].height, A.setCenter(L[M].centerX, L[M].centerY), A.labelMarginLeft = 0, A.labelMarginTop = 0, g.NODE_DIMENSIONS_INCLUDE_LABELS) {
                      var I = A.rect.width, D = A.rect.height;
                      A.labelWidth && (A.labelPosHorizontal == "left" ? (A.rect.x -= A.labelWidth, A.setWidth(I + A.labelWidth), A.labelMarginLeft = A.labelWidth) : A.labelPosHorizontal == "center" && A.labelWidth > I ? (A.rect.x -= (A.labelWidth - I) / 2, A.setWidth(A.labelWidth), A.labelMarginLeft = (A.labelWidth - I) / 2) : A.labelPosHorizontal == "right" && A.setWidth(I + A.labelWidth)), A.labelHeight && (A.labelPosVertical == "top" ? (A.rect.y -= A.labelHeight, A.setHeight(D + A.labelHeight), A.labelMarginTop = A.labelHeight) : A.labelPosVertical == "center" && A.labelHeight > D ? (A.rect.y -= (A.labelHeight - D) / 2, A.setHeight(A.labelHeight), A.labelMarginTop = (A.labelHeight - D) / 2) : A.labelPosVertical == "bottom" && A.setHeight(D + A.labelHeight));
                    }
                  });
                }, _.prototype.repopulateCompounds = function() {
                  for (var T = this.compoundOrder.length - 1; T >= 0; T--) {
                    var L = this.compoundOrder[T], M = L.id, A = L.paddingLeft, I = L.paddingTop, D = L.labelMarginLeft, F = L.labelMarginTop;
                    this.adjustLocations(this.tiledMemberPack[M], L.rect.x, L.rect.y, A, I, D, F);
                  }
                }, _.prototype.repopulateZeroDegreeMembers = function() {
                  var T = this, L = this.tiledZeroDegreePack;
                  Object.keys(L).forEach(function(M) {
                    var A = T.idToDummyNode[M], I = A.paddingLeft, D = A.paddingTop, F = A.labelMarginLeft, B = A.labelMarginTop;
                    T.adjustLocations(L[M], A.rect.x, A.rect.y, I, D, F, B);
                  });
                }, _.prototype.getToBeTiled = function(T) {
                  var L = T.id;
                  if (this.toBeTiled[L] != null)
                    return this.toBeTiled[L];
                  var M = T.getChild();
                  if (M == null)
                    return this.toBeTiled[L] = !1, !1;
                  for (var A = M.getNodes(), I = 0; I < A.length; I++) {
                    var D = A[I];
                    if (this.getNodeDegree(D) > 0)
                      return this.toBeTiled[L] = !1, !1;
                    if (D.getChild() == null) {
                      this.toBeTiled[D.id] = !1;
                      continue;
                    }
                    if (!this.getToBeTiled(D))
                      return this.toBeTiled[L] = !1, !1;
                  }
                  return this.toBeTiled[L] = !0, !0;
                }, _.prototype.getNodeDegree = function(T) {
                  T.id;
                  for (var L = T.getEdges(), M = 0, A = 0; A < L.length; A++) {
                    var I = L[A];
                    I.getSource().id !== I.getTarget().id && (M = M + 1);
                  }
                  return M;
                }, _.prototype.getNodeDegreeWithChildren = function(T) {
                  var L = this.getNodeDegree(T);
                  if (T.getChild() == null)
                    return L;
                  for (var M = T.getChild().getNodes(), A = 0; A < M.length; A++) {
                    var I = M[A];
                    L += this.getNodeDegreeWithChildren(I);
                  }
                  return L;
                }, _.prototype.performDFSOnCompounds = function() {
                  this.compoundOrder = [], this.fillCompexOrderByDFS(this.graphManager.getRoot().getNodes());
                }, _.prototype.fillCompexOrderByDFS = function(T) {
                  for (var L = 0; L < T.length; L++) {
                    var M = T[L];
                    M.getChild() != null && this.fillCompexOrderByDFS(M.getChild().getNodes()), this.getToBeTiled(M) && this.compoundOrder.push(M);
                  }
                }, _.prototype.adjustLocations = function(T, L, M, A, I, D, F) {
                  L += A + D, M += I + F;
                  for (var B = L, G = 0; G < T.rows.length; G++) {
                    var H = T.rows[G];
                    L = B;
                    for (var K = 0, j = 0; j < H.length; j++) {
                      var Z = H[j];
                      Z.rect.x = L, Z.rect.y = M, L += Z.rect.width + T.horizontalPadding, Z.rect.height > K && (K = Z.rect.height);
                    }
                    M += K + T.verticalPadding;
                  }
                }, _.prototype.tileCompoundMembers = function(T, L) {
                  var M = this;
                  this.tiledMemberPack = [], Object.keys(T).forEach(function(A) {
                    var I = L[A];
                    if (M.tiledMemberPack[A] = M.tileNodes(T[A], I.paddingLeft + I.paddingRight), I.rect.width = M.tiledMemberPack[A].width, I.rect.height = M.tiledMemberPack[A].height, I.setCenter(M.tiledMemberPack[A].centerX, M.tiledMemberPack[A].centerY), I.labelMarginLeft = 0, I.labelMarginTop = 0, g.NODE_DIMENSIONS_INCLUDE_LABELS) {
                      var D = I.rect.width, F = I.rect.height;
                      I.labelWidth && (I.labelPosHorizontal == "left" ? (I.rect.x -= I.labelWidth, I.setWidth(D + I.labelWidth), I.labelMarginLeft = I.labelWidth) : I.labelPosHorizontal == "center" && I.labelWidth > D ? (I.rect.x -= (I.labelWidth - D) / 2, I.setWidth(I.labelWidth), I.labelMarginLeft = (I.labelWidth - D) / 2) : I.labelPosHorizontal == "right" && I.setWidth(D + I.labelWidth)), I.labelHeight && (I.labelPosVertical == "top" ? (I.rect.y -= I.labelHeight, I.setHeight(F + I.labelHeight), I.labelMarginTop = I.labelHeight) : I.labelPosVertical == "center" && I.labelHeight > F ? (I.rect.y -= (I.labelHeight - F) / 2, I.setHeight(I.labelHeight), I.labelMarginTop = (I.labelHeight - F) / 2) : I.labelPosVertical == "bottom" && I.setHeight(F + I.labelHeight));
                    }
                  });
                }, _.prototype.tileNodes = function(T, L) {
                  var M = this.tileNodesByFavoringDim(T, L, !0), A = this.tileNodesByFavoringDim(T, L, !1), I = this.getOrgRatio(M), D = this.getOrgRatio(A), F;
                  return D < I ? F = A : F = M, F;
                }, _.prototype.getOrgRatio = function(T) {
                  var L = T.width, M = T.height, A = L / M;
                  return A < 1 && (A = 1 / A), A;
                }, _.prototype.calcIdealRowWidth = function(T, L) {
                  var M = g.TILING_PADDING_VERTICAL, A = g.TILING_PADDING_HORIZONTAL, I = T.length, D = 0, F = 0, B = 0;
                  T.forEach(function(ne) {
                    D += ne.getWidth(), F += ne.getHeight(), ne.getWidth() > B && (B = ne.getWidth());
                  });
                  var G = D / I, H = F / I, K = Math.pow(M - A, 2) + 4 * (G + A) * (H + M) * I, j = (A - M + Math.sqrt(K)) / (2 * (G + A)), Z;
                  L ? (Z = Math.ceil(j), Z == j && Z++) : Z = Math.floor(j);
                  var te = Z * (G + A) - A;
                  return B > te && (te = B), te += A * 2, te;
                }, _.prototype.tileNodesByFavoringDim = function(T, L, M) {
                  var A = g.TILING_PADDING_VERTICAL, I = g.TILING_PADDING_HORIZONTAL, D = g.TILING_COMPARE_BY, F = {
                    rows: [],
                    rowWidth: [],
                    rowHeight: [],
                    width: 0,
                    height: L,
                    // assume minHeight equals to minWidth
                    verticalPadding: A,
                    horizontalPadding: I,
                    centerX: 0,
                    centerY: 0
                  };
                  D && (F.idealRowWidth = this.calcIdealRowWidth(T, M));
                  var B = function(V) {
                    return V.rect.width * V.rect.height;
                  }, G = function(V, q) {
                    return B(q) - B(V);
                  };
                  T.sort(function(ne, V) {
                    var q = G;
                    return F.idealRowWidth ? (q = D, q(ne.id, V.id)) : q(ne, V);
                  });
                  for (var H = 0, K = 0, j = 0; j < T.length; j++) {
                    var Z = T[j];
                    H += Z.getCenterX(), K += Z.getCenterY();
                  }
                  F.centerX = H / T.length, F.centerY = K / T.length;
                  for (var j = 0; j < T.length; j++) {
                    var Z = T[j];
                    if (F.rows.length == 0)
                      this.insertNodeToRow(F, Z, 0, L);
                    else if (this.canAddHorizontal(F, Z.rect.width, Z.rect.height)) {
                      var te = F.rows.length - 1;
                      F.idealRowWidth || (te = this.getShortestRowIndex(F)), this.insertNodeToRow(F, Z, te, L);
                    } else
                      this.insertNodeToRow(F, Z, F.rows.length, L);
                    this.shiftToLastRow(F);
                  }
                  return F;
                }, _.prototype.insertNodeToRow = function(T, L, M, A) {
                  var I = A;
                  if (M == T.rows.length) {
                    var D = [];
                    T.rows.push(D), T.rowWidth.push(I), T.rowHeight.push(0);
                  }
                  var F = T.rowWidth[M] + L.rect.width;
                  T.rows[M].length > 0 && (F += T.horizontalPadding), T.rowWidth[M] = F, T.width < F && (T.width = F);
                  var B = L.rect.height;
                  M > 0 && (B += T.verticalPadding);
                  var G = 0;
                  B > T.rowHeight[M] && (G = T.rowHeight[M], T.rowHeight[M] = B, G = T.rowHeight[M] - G), T.height += G, T.rows[M].push(L);
                }, _.prototype.getShortestRowIndex = function(T) {
                  for (var L = -1, M = Number.MAX_VALUE, A = 0; A < T.rows.length; A++)
                    T.rowWidth[A] < M && (L = A, M = T.rowWidth[A]);
                  return L;
                }, _.prototype.getLongestRowIndex = function(T) {
                  for (var L = -1, M = Number.MIN_VALUE, A = 0; A < T.rows.length; A++)
                    T.rowWidth[A] > M && (L = A, M = T.rowWidth[A]);
                  return L;
                }, _.prototype.canAddHorizontal = function(T, L, M) {
                  if (T.idealRowWidth) {
                    var A = T.rows.length - 1, I = T.rowWidth[A];
                    return I + L + T.horizontalPadding <= T.idealRowWidth;
                  }
                  var D = this.getShortestRowIndex(T);
                  if (D < 0)
                    return !0;
                  var F = T.rowWidth[D];
                  if (F + T.horizontalPadding + L <= T.width) return !0;
                  var B = 0;
                  T.rowHeight[D] < M && D > 0 && (B = M + T.verticalPadding - T.rowHeight[D]);
                  var G;
                  T.width - F >= L + T.horizontalPadding ? G = (T.height + B) / (F + L + T.horizontalPadding) : G = (T.height + B) / T.width, B = M + T.verticalPadding;
                  var H;
                  return T.width < L ? H = (T.height + B) / L : H = (T.height + B) / T.width, H < 1 && (H = 1 / H), G < 1 && (G = 1 / G), G < H;
                }, _.prototype.shiftToLastRow = function(T) {
                  var L = this.getLongestRowIndex(T), M = T.rowWidth.length - 1, A = T.rows[L], I = A[A.length - 1], D = I.width + T.horizontalPadding;
                  if (T.width - T.rowWidth[M] > D && L != M) {
                    A.splice(-1, 1), T.rows[M].push(I), T.rowWidth[L] = T.rowWidth[L] - D, T.rowWidth[M] = T.rowWidth[M] + D, T.width = T.rowWidth[instance.getLongestRowIndex(T)];
                    for (var F = Number.MIN_VALUE, B = 0; B < A.length; B++)
                      A[B].height > F && (F = A[B].height);
                    L > 0 && (F += T.verticalPadding);
                    var G = T.rowHeight[L] + T.rowHeight[M];
                    T.rowHeight[L] = F, T.rowHeight[M] < I.height + T.verticalPadding && (T.rowHeight[M] = I.height + T.verticalPadding);
                    var H = T.rowHeight[L] + T.rowHeight[M];
                    T.height += H - G, this.shiftToLastRow(T);
                  }
                }, _.prototype.tilingPreLayout = function() {
                  g.TILE && (this.groupZeroDegreeMembers(), this.clearCompounds(), this.clearZeroDegreeMembers());
                }, _.prototype.tilingPostLayout = function() {
                  g.TILE && (this.repopulateZeroDegreeMembers(), this.repopulateCompounds());
                }, _.prototype.reduceTrees = function() {
                  for (var T = [], L = !0, M; L; ) {
                    var A = this.graphManager.getAllNodes(), I = [];
                    L = !1;
                    for (var D = 0; D < A.length; D++)
                      if (M = A[D], M.getEdges().length == 1 && !M.getEdges()[0].isInterGraph && M.getChild() == null) {
                        if (g.PURE_INCREMENTAL) {
                          var F = M.getEdges()[0].getOtherEnd(M), B = new E(M.getCenterX() - F.getCenterX(), M.getCenterY() - F.getCenterY());
                          I.push([M, M.getEdges()[0], M.getOwner(), B]);
                        } else
                          I.push([M, M.getEdges()[0], M.getOwner()]);
                        L = !0;
                      }
                    if (L == !0) {
                      for (var G = [], H = 0; H < I.length; H++)
                        I[H][0].getEdges().length == 1 && (G.push(I[H]), I[H][0].getOwner().remove(I[H][0]));
                      T.push(G), this.graphManager.resetAllNodes(), this.graphManager.resetAllEdges();
                    }
                  }
                  this.prunedNodesAll = T;
                }, _.prototype.growTree = function(T) {
                  for (var L = T.length, M = T[L - 1], A, I = 0; I < M.length; I++)
                    A = M[I], this.findPlaceforPrunedNode(A), A[2].add(A[0]), A[2].add(A[1], A[1].source, A[1].target);
                  T.splice(T.length - 1, 1), this.graphManager.resetAllNodes(), this.graphManager.resetAllEdges();
                }, _.prototype.findPlaceforPrunedNode = function(T) {
                  var L, M, A = T[0];
                  if (A == T[1].source ? M = T[1].target : M = T[1].source, g.PURE_INCREMENTAL)
                    A.setCenter(M.getCenterX() + T[3].getWidth(), M.getCenterY() + T[3].getHeight());
                  else {
                    var I = M.startX, D = M.finishX, F = M.startY, B = M.finishY, G = 0, H = 0, K = 0, j = 0, Z = [G, K, H, j];
                    if (F > 0)
                      for (var te = I; te <= D; te++)
                        Z[0] += this.grid[te][F - 1].length + this.grid[te][F].length - 1;
                    if (D < this.grid.length - 1)
                      for (var te = F; te <= B; te++)
                        Z[1] += this.grid[D + 1][te].length + this.grid[D][te].length - 1;
                    if (B < this.grid[0].length - 1)
                      for (var te = I; te <= D; te++)
                        Z[2] += this.grid[te][B + 1].length + this.grid[te][B].length - 1;
                    if (I > 0)
                      for (var te = F; te <= B; te++)
                        Z[3] += this.grid[I - 1][te].length + this.grid[I][te].length - 1;
                    for (var ne = w.MAX_VALUE, V, q, X = 0; X < Z.length; X++)
                      Z[X] < ne ? (ne = Z[X], V = 1, q = X) : Z[X] == ne && V++;
                    if (V == 3 && ne == 0)
                      Z[0] == 0 && Z[1] == 0 && Z[2] == 0 ? L = 1 : Z[0] == 0 && Z[1] == 0 && Z[3] == 0 ? L = 0 : Z[0] == 0 && Z[2] == 0 && Z[3] == 0 ? L = 3 : Z[1] == 0 && Z[2] == 0 && Z[3] == 0 && (L = 2);
                    else if (V == 2 && ne == 0) {
                      var W = Math.floor(Math.random() * 2);
                      Z[0] == 0 && Z[1] == 0 ? W == 0 ? L = 0 : L = 1 : Z[0] == 0 && Z[2] == 0 ? W == 0 ? L = 0 : L = 2 : Z[0] == 0 && Z[3] == 0 ? W == 0 ? L = 0 : L = 3 : Z[1] == 0 && Z[2] == 0 ? W == 0 ? L = 1 : L = 2 : Z[1] == 0 && Z[3] == 0 ? W == 0 ? L = 1 : L = 3 : W == 0 ? L = 2 : L = 3;
                    } else if (V == 4 && ne == 0) {
                      var W = Math.floor(Math.random() * 4);
                      L = W;
                    } else
                      L = q;
                    L == 0 ? A.setCenter(M.getCenterX(), M.getCenterY() - M.getHeight() / 2 - m.DEFAULT_EDGE_LENGTH - A.getHeight() / 2) : L == 1 ? A.setCenter(M.getCenterX() + M.getWidth() / 2 + m.DEFAULT_EDGE_LENGTH + A.getWidth() / 2, M.getCenterY()) : L == 2 ? A.setCenter(M.getCenterX(), M.getCenterY() + M.getHeight() / 2 + m.DEFAULT_EDGE_LENGTH + A.getHeight() / 2) : A.setCenter(M.getCenterX() - M.getWidth() / 2 - m.DEFAULT_EDGE_LENGTH - A.getWidth() / 2, M.getCenterY());
                  }
                }, o.exports = _;
              }
            ),
            /***/
            991: (
              /***/
              (o, l, u) => {
                var c = u(551).FDLayoutNode, f = u(551).IMath;
                function h(p, g, v, m) {
                  c.call(this, p, g, v, m);
                }
                h.prototype = Object.create(c.prototype);
                for (var d in c)
                  h[d] = c[d];
                h.prototype.calculateDisplacement = function() {
                  var p = this.graphManager.getLayout();
                  this.getChild() != null && this.fixedNodeWeight ? (this.displacementX += p.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.fixedNodeWeight, this.displacementY += p.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.fixedNodeWeight) : (this.displacementX += p.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.noOfChildren, this.displacementY += p.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.noOfChildren), Math.abs(this.displacementX) > p.coolingFactor * p.maxNodeDisplacement && (this.displacementX = p.coolingFactor * p.maxNodeDisplacement * f.sign(this.displacementX)), Math.abs(this.displacementY) > p.coolingFactor * p.maxNodeDisplacement && (this.displacementY = p.coolingFactor * p.maxNodeDisplacement * f.sign(this.displacementY)), this.child && this.child.getNodes().length > 0 && this.propogateDisplacementToChildren(this.displacementX, this.displacementY);
                }, h.prototype.propogateDisplacementToChildren = function(p, g) {
                  for (var v = this.getChild().getNodes(), m, b = 0; b < v.length; b++)
                    m = v[b], m.getChild() == null ? (m.displacementX += p, m.displacementY += g) : m.propogateDisplacementToChildren(p, g);
                }, h.prototype.move = function() {
                  var p = this.graphManager.getLayout();
                  (this.child == null || this.child.getNodes().length == 0) && (this.moveBy(this.displacementX, this.displacementY), p.totalDisplacement += Math.abs(this.displacementX) + Math.abs(this.displacementY)), this.springForceX = 0, this.springForceY = 0, this.repulsionForceX = 0, this.repulsionForceY = 0, this.gravitationForceX = 0, this.gravitationForceY = 0, this.displacementX = 0, this.displacementY = 0;
                }, h.prototype.setPred1 = function(p) {
                  this.pred1 = p;
                }, h.prototype.getPred1 = function() {
                  return pred1;
                }, h.prototype.getPred2 = function() {
                  return pred2;
                }, h.prototype.setNext = function(p) {
                  this.next = p;
                }, h.prototype.getNext = function() {
                  return next;
                }, h.prototype.setProcessed = function(p) {
                  this.processed = p;
                }, h.prototype.isProcessed = function() {
                  return processed;
                }, o.exports = h;
              }
            ),
            /***/
            902: (
              /***/
              (o, l, u) => {
                function c(v) {
                  if (Array.isArray(v)) {
                    for (var m = 0, b = Array(v.length); m < v.length; m++)
                      b[m] = v[m];
                    return b;
                  } else
                    return Array.from(v);
                }
                var f = u(806), h = u(551).LinkedList, d = u(551).Matrix, p = u(551).SVD;
                function g() {
                }
                g.handleConstraints = function(v) {
                  var m = {};
                  m.fixedNodeConstraint = v.constraints.fixedNodeConstraint, m.alignmentConstraint = v.constraints.alignmentConstraint, m.relativePlacementConstraint = v.constraints.relativePlacementConstraint;
                  for (var b = /* @__PURE__ */ new Map(), y = /* @__PURE__ */ new Map(), x = [], E = [], S = v.getAllNodes(), w = 0, C = 0; C < S.length; C++) {
                    var k = S[C];
                    k.getChild() == null && (y.set(k.id, w++), x.push(k.getCenterX()), E.push(k.getCenterY()), b.set(k.id, k));
                  }
                  m.relativePlacementConstraint && m.relativePlacementConstraint.forEach(function(ae) {
                    !ae.gap && ae.gap != 0 && (ae.left ? ae.gap = f.DEFAULT_EDGE_LENGTH + b.get(ae.left).getWidth() / 2 + b.get(ae.right).getWidth() / 2 : ae.gap = f.DEFAULT_EDGE_LENGTH + b.get(ae.top).getHeight() / 2 + b.get(ae.bottom).getHeight() / 2);
                  });
                  var N = function(z, Q) {
                    return { x: z.x - Q.x, y: z.y - Q.y };
                  }, R = function(z) {
                    var Q = 0, se = 0;
                    return z.forEach(function(oe) {
                      Q += x[y.get(oe)], se += E[y.get(oe)];
                    }), { x: Q / z.size, y: se / z.size };
                  }, _ = function(z, Q, se, oe, he) {
                    function Le(Pe, De) {
                      var mt = new Set(Pe), Ke = !0, et = !1, Pt = void 0;
                      try {
                        for (var vt = De[Symbol.iterator](), nt; !(Ke = (nt = vt.next()).done); Ke = !0) {
                          var Dt = nt.value;
                          mt.add(Dt);
                        }
                      } catch (Gt) {
                        et = !0, Pt = Gt;
                      } finally {
                        try {
                          !Ke && vt.return && vt.return();
                        } finally {
                          if (et)
                            throw Pt;
                        }
                      }
                      return mt;
                    }
                    var ge = /* @__PURE__ */ new Map();
                    z.forEach(function(Pe, De) {
                      ge.set(De, 0);
                    }), z.forEach(function(Pe, De) {
                      Pe.forEach(function(mt) {
                        ge.set(mt.id, ge.get(mt.id) + 1);
                      });
                    });
                    var Se = /* @__PURE__ */ new Map(), xe = /* @__PURE__ */ new Map(), $e = new h();
                    ge.forEach(function(Pe, De) {
                      Pe == 0 ? ($e.push(De), se || (Q == "horizontal" ? Se.set(De, y.has(De) ? x[y.get(De)] : oe.get(De)) : Se.set(De, y.has(De) ? E[y.get(De)] : oe.get(De)))) : Se.set(De, Number.NEGATIVE_INFINITY), se && xe.set(De, /* @__PURE__ */ new Set([De]));
                    }), se && he.forEach(function(Pe) {
                      var De = [];
                      if (Pe.forEach(function(et) {
                        se.has(et) && De.push(et);
                      }), De.length > 0) {
                        var mt = 0;
                        De.forEach(function(et) {
                          Q == "horizontal" ? (Se.set(et, y.has(et) ? x[y.get(et)] : oe.get(et)), mt += Se.get(et)) : (Se.set(et, y.has(et) ? E[y.get(et)] : oe.get(et)), mt += Se.get(et));
                        }), mt = mt / De.length, Pe.forEach(function(et) {
                          se.has(et) || Se.set(et, mt);
                        });
                      } else {
                        var Ke = 0;
                        Pe.forEach(function(et) {
                          Q == "horizontal" ? Ke += y.has(et) ? x[y.get(et)] : oe.get(et) : Ke += y.has(et) ? E[y.get(et)] : oe.get(et);
                        }), Ke = Ke / Pe.length, Pe.forEach(function(et) {
                          Se.set(et, Ke);
                        });
                      }
                    });
                    for (var Ze = function() {
                      var De = $e.shift(), mt = z.get(De);
                      mt.forEach(function(Ke) {
                        if (Se.get(Ke.id) < Se.get(De) + Ke.gap)
                          if (se && se.has(Ke.id)) {
                            var et = void 0;
                            if (Q == "horizontal" ? et = y.has(Ke.id) ? x[y.get(Ke.id)] : oe.get(Ke.id) : et = y.has(Ke.id) ? E[y.get(Ke.id)] : oe.get(Ke.id), Se.set(Ke.id, et), et < Se.get(De) + Ke.gap) {
                              var Pt = Se.get(De) + Ke.gap - et;
                              xe.get(De).forEach(function(vt) {
                                Se.set(vt, Se.get(vt) - Pt);
                              });
                            }
                          } else
                            Se.set(Ke.id, Se.get(De) + Ke.gap);
                        ge.set(Ke.id, ge.get(Ke.id) - 1), ge.get(Ke.id) == 0 && $e.push(Ke.id), se && xe.set(Ke.id, Le(xe.get(De), xe.get(Ke.id)));
                      });
                    }; $e.length != 0; )
                      Ze();
                    if (se) {
                      var We = /* @__PURE__ */ new Set();
                      z.forEach(function(Pe, De) {
                        Pe.length == 0 && We.add(De);
                      });
                      var He = [];
                      xe.forEach(function(Pe, De) {
                        if (We.has(De)) {
                          var mt = !1, Ke = !0, et = !1, Pt = void 0;
                          try {
                            for (var vt = Pe[Symbol.iterator](), nt; !(Ke = (nt = vt.next()).done); Ke = !0) {
                              var Dt = nt.value;
                              se.has(Dt) && (mt = !0);
                            }
                          } catch (ee) {
                            et = !0, Pt = ee;
                          } finally {
                            try {
                              !Ke && vt.return && vt.return();
                            } finally {
                              if (et)
                                throw Pt;
                            }
                          }
                          if (!mt) {
                            var Gt = !1, yt = void 0;
                            He.forEach(function(ee, Re) {
                              ee.has([].concat(c(Pe))[0]) && (Gt = !0, yt = Re);
                            }), Gt ? Pe.forEach(function(ee) {
                              He[yt].add(ee);
                            }) : He.push(new Set(Pe));
                          }
                        }
                      }), He.forEach(function(Pe, De) {
                        var mt = Number.POSITIVE_INFINITY, Ke = Number.POSITIVE_INFINITY, et = Number.NEGATIVE_INFINITY, Pt = Number.NEGATIVE_INFINITY, vt = !0, nt = !1, Dt = void 0;
                        try {
                          for (var Gt = Pe[Symbol.iterator](), yt; !(vt = (yt = Gt.next()).done); vt = !0) {
                            var ee = yt.value, Re = void 0;
                            Q == "horizontal" ? Re = y.has(ee) ? x[y.get(ee)] : oe.get(ee) : Re = y.has(ee) ? E[y.get(ee)] : oe.get(ee);
                            var Ge = Se.get(ee);
                            Re < mt && (mt = Re), Re > et && (et = Re), Ge < Ke && (Ke = Ge), Ge > Pt && (Pt = Ge);
                          }
                        } catch (le) {
                          nt = !0, Dt = le;
                        } finally {
                          try {
                            !vt && Gt.return && Gt.return();
                          } finally {
                            if (nt)
                              throw Dt;
                          }
                        }
                        var ot = (mt + et) / 2 - (Ke + Pt) / 2, kt = !0, wt = !1, pt = void 0;
                        try {
                          for (var gt = Pe[Symbol.iterator](), or; !(kt = (or = gt.next()).done); kt = !0) {
                            var ze = or.value;
                            Se.set(ze, Se.get(ze) + ot);
                          }
                        } catch (le) {
                          wt = !0, pt = le;
                        } finally {
                          try {
                            !kt && gt.return && gt.return();
                          } finally {
                            if (wt)
                              throw pt;
                          }
                        }
                      });
                    }
                    return Se;
                  }, O = function(z) {
                    var Q = 0, se = 0, oe = 0, he = 0;
                    if (z.forEach(function(xe) {
                      xe.left ? x[y.get(xe.left)] - x[y.get(xe.right)] >= 0 ? Q++ : se++ : E[y.get(xe.top)] - E[y.get(xe.bottom)] >= 0 ? oe++ : he++;
                    }), Q > se && oe > he)
                      for (var Le = 0; Le < y.size; Le++)
                        x[Le] = -1 * x[Le], E[Le] = -1 * E[Le];
                    else if (Q > se)
                      for (var ge = 0; ge < y.size; ge++)
                        x[ge] = -1 * x[ge];
                    else if (oe > he)
                      for (var Se = 0; Se < y.size; Se++)
                        E[Se] = -1 * E[Se];
                  }, T = function(z) {
                    var Q = [], se = new h(), oe = /* @__PURE__ */ new Set(), he = 0;
                    return z.forEach(function(Le, ge) {
                      if (!oe.has(ge)) {
                        Q[he] = [];
                        var Se = ge;
                        for (se.push(Se), oe.add(Se), Q[he].push(Se); se.length != 0; ) {
                          Se = se.shift();
                          var xe = z.get(Se);
                          xe.forEach(function($e) {
                            oe.has($e.id) || (se.push($e.id), oe.add($e.id), Q[he].push($e.id));
                          });
                        }
                        he++;
                      }
                    }), Q;
                  }, L = function(z) {
                    var Q = /* @__PURE__ */ new Map();
                    return z.forEach(function(se, oe) {
                      Q.set(oe, []);
                    }), z.forEach(function(se, oe) {
                      se.forEach(function(he) {
                        Q.get(oe).push(he), Q.get(he.id).push({ id: oe, gap: he.gap, direction: he.direction });
                      });
                    }), Q;
                  }, M = function(z) {
                    var Q = /* @__PURE__ */ new Map();
                    return z.forEach(function(se, oe) {
                      Q.set(oe, []);
                    }), z.forEach(function(se, oe) {
                      se.forEach(function(he) {
                        Q.get(he.id).push({ id: oe, gap: he.gap, direction: he.direction });
                      });
                    }), Q;
                  }, A = [], I = [], D = !1, F = !1, B = /* @__PURE__ */ new Set(), G = /* @__PURE__ */ new Map(), H = /* @__PURE__ */ new Map(), K = [];
                  if (m.fixedNodeConstraint && m.fixedNodeConstraint.forEach(function(ae) {
                    B.add(ae.nodeId);
                  }), m.relativePlacementConstraint && (m.relativePlacementConstraint.forEach(function(ae) {
                    ae.left ? (G.has(ae.left) ? G.get(ae.left).push({ id: ae.right, gap: ae.gap, direction: "horizontal" }) : G.set(ae.left, [{ id: ae.right, gap: ae.gap, direction: "horizontal" }]), G.has(ae.right) || G.set(ae.right, [])) : (G.has(ae.top) ? G.get(ae.top).push({ id: ae.bottom, gap: ae.gap, direction: "vertical" }) : G.set(ae.top, [{ id: ae.bottom, gap: ae.gap, direction: "vertical" }]), G.has(ae.bottom) || G.set(ae.bottom, []));
                  }), H = L(G), K = T(H)), f.TRANSFORM_ON_CONSTRAINT_HANDLING) {
                    if (m.fixedNodeConstraint && m.fixedNodeConstraint.length > 1)
                      m.fixedNodeConstraint.forEach(function(ae, z) {
                        A[z] = [ae.position.x, ae.position.y], I[z] = [x[y.get(ae.nodeId)], E[y.get(ae.nodeId)]];
                      }), D = !0;
                    else if (m.alignmentConstraint)
                      (function() {
                        var ae = 0;
                        if (m.alignmentConstraint.vertical) {
                          for (var z = m.alignmentConstraint.vertical, Q = function(Se) {
                            var xe = /* @__PURE__ */ new Set();
                            z[Se].forEach(function(We) {
                              xe.add(We);
                            });
                            var $e = new Set([].concat(c(xe)).filter(function(We) {
                              return B.has(We);
                            })), Ze = void 0;
                            $e.size > 0 ? Ze = x[y.get($e.values().next().value)] : Ze = R(xe).x, z[Se].forEach(function(We) {
                              A[ae] = [Ze, E[y.get(We)]], I[ae] = [x[y.get(We)], E[y.get(We)]], ae++;
                            });
                          }, se = 0; se < z.length; se++)
                            Q(se);
                          D = !0;
                        }
                        if (m.alignmentConstraint.horizontal) {
                          for (var oe = m.alignmentConstraint.horizontal, he = function(Se) {
                            var xe = /* @__PURE__ */ new Set();
                            oe[Se].forEach(function(We) {
                              xe.add(We);
                            });
                            var $e = new Set([].concat(c(xe)).filter(function(We) {
                              return B.has(We);
                            })), Ze = void 0;
                            $e.size > 0 ? Ze = x[y.get($e.values().next().value)] : Ze = R(xe).y, oe[Se].forEach(function(We) {
                              A[ae] = [x[y.get(We)], Ze], I[ae] = [x[y.get(We)], E[y.get(We)]], ae++;
                            });
                          }, Le = 0; Le < oe.length; Le++)
                            he(Le);
                          D = !0;
                        }
                        m.relativePlacementConstraint && (F = !0);
                      })();
                    else if (m.relativePlacementConstraint) {
                      for (var j = 0, Z = 0, te = 0; te < K.length; te++)
                        K[te].length > j && (j = K[te].length, Z = te);
                      if (j < H.size / 2)
                        O(m.relativePlacementConstraint), D = !1, F = !1;
                      else {
                        var ne = /* @__PURE__ */ new Map(), V = /* @__PURE__ */ new Map(), q = [];
                        K[Z].forEach(function(ae) {
                          G.get(ae).forEach(function(z) {
                            z.direction == "horizontal" ? (ne.has(ae) ? ne.get(ae).push(z) : ne.set(ae, [z]), ne.has(z.id) || ne.set(z.id, []), q.push({ left: ae, right: z.id })) : (V.has(ae) ? V.get(ae).push(z) : V.set(ae, [z]), V.has(z.id) || V.set(z.id, []), q.push({ top: ae, bottom: z.id }));
                          });
                        }), O(q), F = !1;
                        var X = _(ne, "horizontal"), W = _(V, "vertical");
                        K[Z].forEach(function(ae, z) {
                          I[z] = [x[y.get(ae)], E[y.get(ae)]], A[z] = [], X.has(ae) ? A[z][0] = X.get(ae) : A[z][0] = x[y.get(ae)], W.has(ae) ? A[z][1] = W.get(ae) : A[z][1] = E[y.get(ae)];
                        }), D = !0;
                      }
                    }
                    if (D) {
                      for (var ue = void 0, J = d.transpose(A), Ce = d.transpose(I), Ee = 0; Ee < J.length; Ee++)
                        J[Ee] = d.multGamma(J[Ee]), Ce[Ee] = d.multGamma(Ce[Ee]);
                      var Te = d.multMat(J, d.transpose(Ce)), me = p.svd(Te);
                      ue = d.multMat(me.V, d.transpose(me.U));
                      for (var we = 0; we < y.size; we++) {
                        var Ae = [x[we], E[we]], Ne = [ue[0][0], ue[1][0]], Ie = [ue[0][1], ue[1][1]];
                        x[we] = d.dotProduct(Ae, Ne), E[we] = d.dotProduct(Ae, Ie);
                      }
                      F && O(m.relativePlacementConstraint);
                    }
                  }
                  if (f.ENFORCE_CONSTRAINTS) {
                    if (m.fixedNodeConstraint && m.fixedNodeConstraint.length > 0) {
                      var Me = { x: 0, y: 0 };
                      m.fixedNodeConstraint.forEach(function(ae, z) {
                        var Q = { x: x[y.get(ae.nodeId)], y: E[y.get(ae.nodeId)] }, se = ae.position, oe = N(se, Q);
                        Me.x += oe.x, Me.y += oe.y;
                      }), Me.x /= m.fixedNodeConstraint.length, Me.y /= m.fixedNodeConstraint.length, x.forEach(function(ae, z) {
                        x[z] += Me.x;
                      }), E.forEach(function(ae, z) {
                        E[z] += Me.y;
                      }), m.fixedNodeConstraint.forEach(function(ae) {
                        x[y.get(ae.nodeId)] = ae.position.x, E[y.get(ae.nodeId)] = ae.position.y;
                      });
                    }
                    if (m.alignmentConstraint) {
                      if (m.alignmentConstraint.vertical)
                        for (var _e = m.alignmentConstraint.vertical, Be = function(z) {
                          var Q = /* @__PURE__ */ new Set();
                          _e[z].forEach(function(he) {
                            Q.add(he);
                          });
                          var se = new Set([].concat(c(Q)).filter(function(he) {
                            return B.has(he);
                          })), oe = void 0;
                          se.size > 0 ? oe = x[y.get(se.values().next().value)] : oe = R(Q).x, Q.forEach(function(he) {
                            B.has(he) || (x[y.get(he)] = oe);
                          });
                        }, st = 0; st < _e.length; st++)
                          Be(st);
                      if (m.alignmentConstraint.horizontal)
                        for (var ct = m.alignmentConstraint.horizontal, dt = function(z) {
                          var Q = /* @__PURE__ */ new Set();
                          ct[z].forEach(function(he) {
                            Q.add(he);
                          });
                          var se = new Set([].concat(c(Q)).filter(function(he) {
                            return B.has(he);
                          })), oe = void 0;
                          se.size > 0 ? oe = E[y.get(se.values().next().value)] : oe = R(Q).y, Q.forEach(function(he) {
                            B.has(he) || (E[y.get(he)] = oe);
                          });
                        }, ft = 0; ft < ct.length; ft++)
                          dt(ft);
                    }
                    m.relativePlacementConstraint && function() {
                      var ae = /* @__PURE__ */ new Map(), z = /* @__PURE__ */ new Map(), Q = /* @__PURE__ */ new Map(), se = /* @__PURE__ */ new Map(), oe = /* @__PURE__ */ new Map(), he = /* @__PURE__ */ new Map(), Le = /* @__PURE__ */ new Set(), ge = /* @__PURE__ */ new Set();
                      if (B.forEach(function(zr) {
                        Le.add(zr), ge.add(zr);
                      }), m.alignmentConstraint) {
                        if (m.alignmentConstraint.vertical)
                          for (var Se = m.alignmentConstraint.vertical, xe = function(It) {
                            Q.set("dummy" + It, []), Se[It].forEach(function(ir) {
                              ae.set(ir, "dummy" + It), Q.get("dummy" + It).push(ir), B.has(ir) && Le.add("dummy" + It);
                            }), oe.set("dummy" + It, x[y.get(Se[It][0])]);
                          }, $e = 0; $e < Se.length; $e++)
                            xe($e);
                        if (m.alignmentConstraint.horizontal)
                          for (var Ze = m.alignmentConstraint.horizontal, We = function(It) {
                            se.set("dummy" + It, []), Ze[It].forEach(function(ir) {
                              z.set(ir, "dummy" + It), se.get("dummy" + It).push(ir), B.has(ir) && ge.add("dummy" + It);
                            }), he.set("dummy" + It, E[y.get(Ze[It][0])]);
                          }, He = 0; He < Ze.length; He++)
                            We(He);
                      }
                      var Pe = /* @__PURE__ */ new Map(), De = /* @__PURE__ */ new Map(), mt = function(It) {
                        G.get(It).forEach(function(ir) {
                          var an = void 0, Wn = void 0;
                          ir.direction == "horizontal" ? (an = ae.get(It) ? ae.get(It) : It, ae.get(ir.id) ? Wn = { id: ae.get(ir.id), gap: ir.gap, direction: ir.direction } : Wn = ir, Pe.has(an) ? Pe.get(an).push(Wn) : Pe.set(an, [Wn]), Pe.has(Wn.id) || Pe.set(Wn.id, [])) : (an = z.get(It) ? z.get(It) : It, z.get(ir.id) ? Wn = { id: z.get(ir.id), gap: ir.gap, direction: ir.direction } : Wn = ir, De.has(an) ? De.get(an).push(Wn) : De.set(an, [Wn]), De.has(Wn.id) || De.set(Wn.id, []));
                        });
                      }, Ke = !0, et = !1, Pt = void 0;
                      try {
                        for (var vt = G.keys()[Symbol.iterator](), nt; !(Ke = (nt = vt.next()).done); Ke = !0) {
                          var Dt = nt.value;
                          mt(Dt);
                        }
                      } catch (zr) {
                        et = !0, Pt = zr;
                      } finally {
                        try {
                          !Ke && vt.return && vt.return();
                        } finally {
                          if (et)
                            throw Pt;
                        }
                      }
                      var Gt = L(Pe), yt = L(De), ee = T(Gt), Re = T(yt), Ge = M(Pe), ot = M(De), kt = [], wt = [];
                      ee.forEach(function(zr, It) {
                        kt[It] = [], zr.forEach(function(ir) {
                          Ge.get(ir).length == 0 && kt[It].push(ir);
                        });
                      }), Re.forEach(function(zr, It) {
                        wt[It] = [], zr.forEach(function(ir) {
                          ot.get(ir).length == 0 && wt[It].push(ir);
                        });
                      });
                      var pt = _(Pe, "horizontal", Le, oe, kt), gt = _(De, "vertical", ge, he, wt), or = function(It) {
                        Q.get(It) ? Q.get(It).forEach(function(ir) {
                          x[y.get(ir)] = pt.get(It);
                        }) : x[y.get(It)] = pt.get(It);
                      }, ze = !0, le = !1, Oe = void 0;
                      try {
                        for (var at = pt.keys()[Symbol.iterator](), Ht; !(ze = (Ht = at.next()).done); ze = !0) {
                          var Vt = Ht.value;
                          or(Vt);
                        }
                      } catch (zr) {
                        le = !0, Oe = zr;
                      } finally {
                        try {
                          !ze && at.return && at.return();
                        } finally {
                          if (le)
                            throw Oe;
                        }
                      }
                      var yr = function(It) {
                        se.get(It) ? se.get(It).forEach(function(ir) {
                          E[y.get(ir)] = gt.get(It);
                        }) : E[y.get(It)] = gt.get(It);
                      }, jr = !0, qn = !1, aa = void 0;
                      try {
                        for (var Ci = gt.keys()[Symbol.iterator](), Lr; !(jr = (Lr = Ci.next()).done); jr = !0) {
                          var Vt = Lr.value;
                          yr(Vt);
                        }
                      } catch (zr) {
                        qn = !0, aa = zr;
                      } finally {
                        try {
                          !jr && Ci.return && Ci.return();
                        } finally {
                          if (qn)
                            throw aa;
                        }
                      }
                    }();
                  }
                  for (var rt = 0; rt < S.length; rt++) {
                    var je = S[rt];
                    je.getChild() == null && je.setCenter(x[y.get(je.id)], E[y.get(je.id)]);
                  }
                }, o.exports = g;
              }
            ),
            /***/
            551: (
              /***/
              (o) => {
                o.exports = r;
              }
            )
            /******/
          }, a = {};
          function i(o) {
            var l = a[o];
            if (l !== void 0)
              return l.exports;
            var u = a[o] = {
              /******/
              // no module.id needed
              /******/
              // no module.loaded needed
              /******/
              exports: {}
              /******/
            };
            return n[o](u, u.exports, i), u.exports;
          }
          var s = i(45);
          return s;
        })()
      );
    });
  }(cE)), cE.exports;
}
(function(t, e) {
  (function(n, a) {
    t.exports = a(lMe());
  })(Jt, function(r) {
    return (
      /******/
      (() => {
        var n = {
          /***/
          658: (
            /***/
            (o) => {
              o.exports = Object.assign != null ? Object.assign.bind(Object) : function(l) {
                for (var u = arguments.length, c = Array(u > 1 ? u - 1 : 0), f = 1; f < u; f++)
                  c[f - 1] = arguments[f];
                return c.forEach(function(h) {
                  Object.keys(h).forEach(function(d) {
                    return l[d] = h[d];
                  });
                }), l;
              };
            }
          ),
          /***/
          548: (
            /***/
            (o, l, u) => {
              var c = /* @__PURE__ */ function() {
                function d(p, g) {
                  var v = [], m = !0, b = !1, y = void 0;
                  try {
                    for (var x = p[Symbol.iterator](), E; !(m = (E = x.next()).done) && (v.push(E.value), !(g && v.length === g)); m = !0)
                      ;
                  } catch (S) {
                    b = !0, y = S;
                  } finally {
                    try {
                      !m && x.return && x.return();
                    } finally {
                      if (b) throw y;
                    }
                  }
                  return v;
                }
                return function(p, g) {
                  if (Array.isArray(p))
                    return p;
                  if (Symbol.iterator in Object(p))
                    return d(p, g);
                  throw new TypeError("Invalid attempt to destructure non-iterable instance");
                };
              }(), f = u(140).layoutBase.LinkedList, h = {};
              h.getTopMostNodes = function(d) {
                for (var p = {}, g = 0; g < d.length; g++)
                  p[d[g].id()] = !0;
                var v = d.filter(function(m, b) {
                  typeof m == "number" && (m = b);
                  for (var y = m.parent()[0]; y != null; ) {
                    if (p[y.id()])
                      return !1;
                    y = y.parent()[0];
                  }
                  return !0;
                });
                return v;
              }, h.connectComponents = function(d, p, g, v) {
                var m = new f(), b = /* @__PURE__ */ new Set(), y = [], x = void 0, E = void 0, S = void 0, w = !1, C = 1, k = [], N = [], R = function() {
                  var O = d.collection();
                  N.push(O);
                  var T = g[0], L = d.collection();
                  L.merge(T).merge(T.descendants().intersection(p)), y.push(T), L.forEach(function(I) {
                    m.push(I), b.add(I), O.merge(I);
                  });
                  for (var M = function() {
                    T = m.shift();
                    var D = d.collection();
                    T.neighborhood().nodes().forEach(function(H) {
                      p.intersection(T.edgesWith(H)).length > 0 && D.merge(H);
                    });
                    for (var F = 0; F < D.length; F++) {
                      var B = D[F];
                      if (x = g.intersection(B.union(B.ancestors())), x != null && !b.has(x[0])) {
                        var G = x.union(x.descendants());
                        G.forEach(function(H) {
                          m.push(H), b.add(H), O.merge(H), g.has(H) && y.push(H);
                        });
                      }
                    }
                  }; m.length != 0; )
                    M();
                  if (O.forEach(function(I) {
                    p.intersection(I.connectedEdges()).forEach(function(D) {
                      O.has(D.source()) && O.has(D.target()) && O.merge(D);
                    });
                  }), y.length == g.length && (w = !0), !w || w && C > 1) {
                    E = y[0], S = E.connectedEdges().length, y.forEach(function(I) {
                      I.connectedEdges().length < S && (S = I.connectedEdges().length, E = I);
                    }), k.push(E.id());
                    var A = d.collection();
                    A.merge(y[0]), y.forEach(function(I) {
                      A.merge(I);
                    }), y = [], g = g.difference(A), C++;
                  }
                };
                do
                  R();
                while (!w);
                return v && k.length > 0 && v.set("dummy" + (v.size + 1), k), N;
              }, h.relocateComponent = function(d, p, g) {
                if (!g.fixedNodeConstraint) {
                  var v = Number.POSITIVE_INFINITY, m = Number.NEGATIVE_INFINITY, b = Number.POSITIVE_INFINITY, y = Number.NEGATIVE_INFINITY;
                  if (g.quality == "draft") {
                    var x = !0, E = !1, S = void 0;
                    try {
                      for (var w = p.nodeIndexes[Symbol.iterator](), C; !(x = (C = w.next()).done); x = !0) {
                        var k = C.value, N = c(k, 2), R = N[0], _ = N[1], O = g.cy.getElementById(R);
                        if (O) {
                          var T = O.boundingBox(), L = p.xCoords[_] - T.w / 2, M = p.xCoords[_] + T.w / 2, A = p.yCoords[_] - T.h / 2, I = p.yCoords[_] + T.h / 2;
                          L < v && (v = L), M > m && (m = M), A < b && (b = A), I > y && (y = I);
                        }
                      }
                    } catch (H) {
                      E = !0, S = H;
                    } finally {
                      try {
                        !x && w.return && w.return();
                      } finally {
                        if (E)
                          throw S;
                      }
                    }
                    var D = d.x - (m + v) / 2, F = d.y - (y + b) / 2;
                    p.xCoords = p.xCoords.map(function(H) {
                      return H + D;
                    }), p.yCoords = p.yCoords.map(function(H) {
                      return H + F;
                    });
                  } else {
                    Object.keys(p).forEach(function(H) {
                      var K = p[H], j = K.getRect().x, Z = K.getRect().x + K.getRect().width, te = K.getRect().y, ne = K.getRect().y + K.getRect().height;
                      j < v && (v = j), Z > m && (m = Z), te < b && (b = te), ne > y && (y = ne);
                    });
                    var B = d.x - (m + v) / 2, G = d.y - (y + b) / 2;
                    Object.keys(p).forEach(function(H) {
                      var K = p[H];
                      K.setCenter(K.getCenterX() + B, K.getCenterY() + G);
                    });
                  }
                }
              }, h.calcBoundingBox = function(d, p, g, v) {
                for (var m = Number.MAX_SAFE_INTEGER, b = Number.MIN_SAFE_INTEGER, y = Number.MAX_SAFE_INTEGER, x = Number.MIN_SAFE_INTEGER, E = void 0, S = void 0, w = void 0, C = void 0, k = d.descendants().not(":parent"), N = k.length, R = 0; R < N; R++) {
                  var _ = k[R];
                  E = p[v.get(_.id())] - _.width() / 2, S = p[v.get(_.id())] + _.width() / 2, w = g[v.get(_.id())] - _.height() / 2, C = g[v.get(_.id())] + _.height() / 2, m > E && (m = E), b < S && (b = S), y > w && (y = w), x < C && (x = C);
                }
                var O = {};
                return O.topLeftX = m, O.topLeftY = y, O.width = b - m, O.height = x - y, O;
              }, h.calcParentsWithoutChildren = function(d, p) {
                var g = d.collection();
                return p.nodes(":parent").forEach(function(v) {
                  var m = !1;
                  v.children().forEach(function(b) {
                    b.css("display") != "none" && (m = !0);
                  }), m || g.merge(v);
                }), g;
              }, o.exports = h;
            }
          ),
          /***/
          816: (
            /***/
            (o, l, u) => {
              var c = u(548), f = u(140).CoSELayout, h = u(140).CoSENode, d = u(140).layoutBase.PointD, p = u(140).layoutBase.DimensionD, g = u(140).layoutBase.LayoutConstants, v = u(140).layoutBase.FDLayoutConstants, m = u(140).CoSEConstants, b = function(x, E) {
                var S = x.cy, w = x.eles, C = w.nodes(), k = w.edges(), N = void 0, R = void 0, _ = void 0, O = {};
                x.randomize && (N = E.nodeIndexes, R = E.xCoords, _ = E.yCoords);
                var T = function(H) {
                  return typeof H == "function";
                }, L = function(H, K) {
                  return T(H) ? H(K) : H;
                }, M = c.calcParentsWithoutChildren(S, w), A = function G(H, K, j, Z) {
                  for (var te = K.length, ne = 0; ne < te; ne++) {
                    var V = K[ne], q = null;
                    V.intersection(M).length == 0 && (q = V.children());
                    var X = void 0, W = V.layoutDimensions({
                      nodeDimensionsIncludeLabels: Z.nodeDimensionsIncludeLabels
                    });
                    if (V.outerWidth() != null && V.outerHeight() != null)
                      if (Z.randomize)
                        if (!V.isParent())
                          X = H.add(new h(j.graphManager, new d(R[N.get(V.id())] - W.w / 2, _[N.get(V.id())] - W.h / 2), new p(parseFloat(W.w), parseFloat(W.h))));
                        else {
                          var ue = c.calcBoundingBox(V, R, _, N);
                          V.intersection(M).length == 0 ? X = H.add(new h(j.graphManager, new d(ue.topLeftX, ue.topLeftY), new p(ue.width, ue.height))) : X = H.add(new h(j.graphManager, new d(ue.topLeftX, ue.topLeftY), new p(parseFloat(W.w), parseFloat(W.h))));
                        }
                      else
                        X = H.add(new h(j.graphManager, new d(V.position("x") - W.w / 2, V.position("y") - W.h / 2), new p(parseFloat(W.w), parseFloat(W.h))));
                    else
                      X = H.add(new h(this.graphManager));
                    if (X.id = V.data("id"), X.nodeRepulsion = L(Z.nodeRepulsion, V), X.paddingLeft = parseInt(V.css("padding")), X.paddingTop = parseInt(V.css("padding")), X.paddingRight = parseInt(V.css("padding")), X.paddingBottom = parseInt(V.css("padding")), Z.nodeDimensionsIncludeLabels && (X.labelWidth = V.boundingBox({ includeLabels: !0, includeNodes: !1, includeOverlays: !1 }).w, X.labelHeight = V.boundingBox({ includeLabels: !0, includeNodes: !1, includeOverlays: !1 }).h, X.labelPosVertical = V.css("text-valign"), X.labelPosHorizontal = V.css("text-halign")), O[V.data("id")] = X, isNaN(X.rect.x) && (X.rect.x = 0), isNaN(X.rect.y) && (X.rect.y = 0), q != null && q.length > 0) {
                      var J = void 0;
                      J = j.getGraphManager().add(j.newGraph(), X), G(J, q, j, Z);
                    }
                  }
                }, I = function(H, K, j) {
                  for (var Z = 0, te = 0, ne = 0; ne < j.length; ne++) {
                    var V = j[ne], q = O[V.data("source")], X = O[V.data("target")];
                    if (q && X && q !== X && q.getEdgesBetween(X).length == 0) {
                      var W = K.add(H.newEdge(), q, X);
                      W.id = V.id(), W.idealLength = L(x.idealEdgeLength, V), W.edgeElasticity = L(x.edgeElasticity, V), Z += W.idealLength, te++;
                    }
                  }
                  x.idealEdgeLength != null && (te > 0 ? m.DEFAULT_EDGE_LENGTH = v.DEFAULT_EDGE_LENGTH = Z / te : T(x.idealEdgeLength) ? m.DEFAULT_EDGE_LENGTH = v.DEFAULT_EDGE_LENGTH = 50 : m.DEFAULT_EDGE_LENGTH = v.DEFAULT_EDGE_LENGTH = x.idealEdgeLength, m.MIN_REPULSION_DIST = v.MIN_REPULSION_DIST = v.DEFAULT_EDGE_LENGTH / 10, m.DEFAULT_RADIAL_SEPARATION = v.DEFAULT_EDGE_LENGTH);
                }, D = function(H, K) {
                  K.fixedNodeConstraint && (H.constraints.fixedNodeConstraint = K.fixedNodeConstraint), K.alignmentConstraint && (H.constraints.alignmentConstraint = K.alignmentConstraint), K.relativePlacementConstraint && (H.constraints.relativePlacementConstraint = K.relativePlacementConstraint);
                };
                x.nestingFactor != null && (m.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = v.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = x.nestingFactor), x.gravity != null && (m.DEFAULT_GRAVITY_STRENGTH = v.DEFAULT_GRAVITY_STRENGTH = x.gravity), x.numIter != null && (m.MAX_ITERATIONS = v.MAX_ITERATIONS = x.numIter), x.gravityRange != null && (m.DEFAULT_GRAVITY_RANGE_FACTOR = v.DEFAULT_GRAVITY_RANGE_FACTOR = x.gravityRange), x.gravityCompound != null && (m.DEFAULT_COMPOUND_GRAVITY_STRENGTH = v.DEFAULT_COMPOUND_GRAVITY_STRENGTH = x.gravityCompound), x.gravityRangeCompound != null && (m.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = v.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = x.gravityRangeCompound), x.initialEnergyOnIncremental != null && (m.DEFAULT_COOLING_FACTOR_INCREMENTAL = v.DEFAULT_COOLING_FACTOR_INCREMENTAL = x.initialEnergyOnIncremental), x.tilingCompareBy != null && (m.TILING_COMPARE_BY = x.tilingCompareBy), x.quality == "proof" ? g.QUALITY = 2 : g.QUALITY = 0, m.NODE_DIMENSIONS_INCLUDE_LABELS = v.NODE_DIMENSIONS_INCLUDE_LABELS = g.NODE_DIMENSIONS_INCLUDE_LABELS = x.nodeDimensionsIncludeLabels, m.DEFAULT_INCREMENTAL = v.DEFAULT_INCREMENTAL = g.DEFAULT_INCREMENTAL = !x.randomize, m.ANIMATE = v.ANIMATE = g.ANIMATE = x.animate, m.TILE = x.tile, m.TILING_PADDING_VERTICAL = typeof x.tilingPaddingVertical == "function" ? x.tilingPaddingVertical.call() : x.tilingPaddingVertical, m.TILING_PADDING_HORIZONTAL = typeof x.tilingPaddingHorizontal == "function" ? x.tilingPaddingHorizontal.call() : x.tilingPaddingHorizontal, m.DEFAULT_INCREMENTAL = v.DEFAULT_INCREMENTAL = g.DEFAULT_INCREMENTAL = !0, m.PURE_INCREMENTAL = !x.randomize, g.DEFAULT_UNIFORM_LEAF_NODE_SIZES = x.uniformNodeDimensions, x.step == "transformed" && (m.TRANSFORM_ON_CONSTRAINT_HANDLING = !0, m.ENFORCE_CONSTRAINTS = !1, m.APPLY_LAYOUT = !1), x.step == "enforced" && (m.TRANSFORM_ON_CONSTRAINT_HANDLING = !1, m.ENFORCE_CONSTRAINTS = !0, m.APPLY_LAYOUT = !1), x.step == "cose" && (m.TRANSFORM_ON_CONSTRAINT_HANDLING = !1, m.ENFORCE_CONSTRAINTS = !1, m.APPLY_LAYOUT = !0), x.step == "all" && (x.randomize ? m.TRANSFORM_ON_CONSTRAINT_HANDLING = !0 : m.TRANSFORM_ON_CONSTRAINT_HANDLING = !1, m.ENFORCE_CONSTRAINTS = !0, m.APPLY_LAYOUT = !0), x.fixedNodeConstraint || x.alignmentConstraint || x.relativePlacementConstraint ? m.TREE_REDUCTION_ON_INCREMENTAL = !1 : m.TREE_REDUCTION_ON_INCREMENTAL = !0;
                var F = new f(), B = F.newGraphManager();
                return A(B.addRoot(), c.getTopMostNodes(C), F, x), I(F, B, k), D(F, x), F.runLayout(), O;
              };
              o.exports = { coseLayout: b };
            }
          ),
          /***/
          212: (
            /***/
            (o, l, u) => {
              var c = /* @__PURE__ */ function() {
                function x(E, S) {
                  for (var w = 0; w < S.length; w++) {
                    var C = S[w];
                    C.enumerable = C.enumerable || !1, C.configurable = !0, "value" in C && (C.writable = !0), Object.defineProperty(E, C.key, C);
                  }
                }
                return function(E, S, w) {
                  return S && x(E.prototype, S), w && x(E, w), E;
                };
              }();
              function f(x, E) {
                if (!(x instanceof E))
                  throw new TypeError("Cannot call a class as a function");
              }
              var h = u(658), d = u(548), p = u(657), g = p.spectralLayout, v = u(816), m = v.coseLayout, b = Object.freeze({
                // 'draft', 'default' or 'proof' 
                // - 'draft' only applies spectral layout 
                // - 'default' improves the quality with subsequent CoSE layout (fast cooling rate)
                // - 'proof' improves the quality with subsequent CoSE layout (slow cooling rate) 
                quality: "default",
                // Use random node positions at beginning of layout
                // if this is set to false, then quality option must be "proof"
                randomize: !0,
                // Whether or not to animate the layout
                animate: !0,
                // Duration of animation in ms, if enabled
                animationDuration: 1e3,
                // Easing of animation, if enabled
                animationEasing: void 0,
                // Fit the viewport to the repositioned nodes
                fit: !0,
                // Padding around layout
                padding: 30,
                // Whether to include labels in node dimensions. Valid in "proof" quality
                nodeDimensionsIncludeLabels: !1,
                // Whether or not simple nodes (non-compound nodes) are of uniform dimensions
                uniformNodeDimensions: !1,
                // Whether to pack disconnected components - valid only if randomize: true
                packComponents: !0,
                // Layout step - all, transformed, enforced, cose - for debug purpose only
                step: "all",
                /* spectral layout options */
                // False for random, true for greedy
                samplingType: !0,
                // Sample size to construct distance matrix
                sampleSize: 25,
                // Separation amount between nodes
                nodeSeparation: 75,
                // Power iteration tolerance
                piTol: 1e-7,
                /* CoSE layout options */
                // Node repulsion (non overlapping) multiplier
                nodeRepulsion: function(E) {
                  return 4500;
                },
                // Ideal edge (non nested) length
                idealEdgeLength: function(E) {
                  return 50;
                },
                // Divisor to compute edge forces
                edgeElasticity: function(E) {
                  return 0.45;
                },
                // Nesting factor (multiplier) to compute ideal edge length for nested edges
                nestingFactor: 0.1,
                // Gravity force (constant)
                gravity: 0.25,
                // Maximum number of iterations to perform
                numIter: 2500,
                // For enabling tiling
                tile: !0,
                // The function that specifies the criteria for comparing nodes while sorting them during tiling operation.
                // Takes the node id as a parameter and the default tiling operation is perfomed when this option is not set.
                tilingCompareBy: void 0,
                // Represents the amount of the vertical space to put between the zero degree members during the tiling operation(can also be a function)
                tilingPaddingVertical: 10,
                // Represents the amount of the horizontal space to put between the zero degree members during the tiling operation(can also be a function)
                tilingPaddingHorizontal: 10,
                // Gravity range (constant) for compounds
                gravityRangeCompound: 1.5,
                // Gravity force (constant) for compounds
                gravityCompound: 1,
                // Gravity range (constant)
                gravityRange: 3.8,
                // Initial cooling factor for incremental layout  
                initialEnergyOnIncremental: 0.3,
                /* constraint options */
                // Fix required nodes to predefined positions
                // [{nodeId: 'n1', position: {x: 100, y: 200}, {...}]
                fixedNodeConstraint: void 0,
                // Align required nodes in vertical/horizontal direction
                // {vertical: [['n1', 'n2')], ['n3', 'n4']], horizontal: ['n2', 'n4']}
                alignmentConstraint: void 0,
                // Place two nodes relatively in vertical/horizontal direction 
                // [{top: 'n1', bottom: 'n2', gap: 100}, {left: 'n3', right: 'n4', gap: 75}]
                relativePlacementConstraint: void 0,
                /* layout event callbacks */
                ready: function() {
                },
                // on layoutready
                stop: function() {
                }
                // on layoutstop
              }), y = function() {
                function x(E) {
                  f(this, x), this.options = h({}, b, E);
                }
                return c(x, [{
                  key: "run",
                  value: function() {
                    var S = this, w = this.options, C = w.cy, k = w.eles, N = [], R = [], _ = void 0, O = [];
                    w.fixedNodeConstraint && (!Array.isArray(w.fixedNodeConstraint) || w.fixedNodeConstraint.length == 0) && (w.fixedNodeConstraint = void 0), w.alignmentConstraint && (w.alignmentConstraint.vertical && (!Array.isArray(w.alignmentConstraint.vertical) || w.alignmentConstraint.vertical.length == 0) && (w.alignmentConstraint.vertical = void 0), w.alignmentConstraint.horizontal && (!Array.isArray(w.alignmentConstraint.horizontal) || w.alignmentConstraint.horizontal.length == 0) && (w.alignmentConstraint.horizontal = void 0)), w.relativePlacementConstraint && (!Array.isArray(w.relativePlacementConstraint) || w.relativePlacementConstraint.length == 0) && (w.relativePlacementConstraint = void 0);
                    var T = w.fixedNodeConstraint || w.alignmentConstraint || w.relativePlacementConstraint;
                    T && (w.tile = !1, w.packComponents = !1);
                    var L = void 0, M = !1;
                    if (C.layoutUtilities && w.packComponents && (L = C.layoutUtilities("get"), L || (L = C.layoutUtilities()), M = !0), k.nodes().length > 0)
                      if (M) {
                        var D = d.getTopMostNodes(w.eles.nodes());
                        if (_ = d.connectComponents(C, w.eles, D), _.forEach(function(Te) {
                          var me = Te.boundingBox();
                          O.push({ x: me.x1 + me.w / 2, y: me.y1 + me.h / 2 });
                        }), w.randomize && _.forEach(function(Te) {
                          w.eles = Te, N.push(g(w));
                        }), w.quality == "default" || w.quality == "proof") {
                          var F = C.collection();
                          if (w.tile) {
                            var B = /* @__PURE__ */ new Map(), G = [], H = [], K = 0, j = { nodeIndexes: B, xCoords: G, yCoords: H }, Z = [];
                            if (_.forEach(function(Te, me) {
                              Te.edges().length == 0 && (Te.nodes().forEach(function(we, Ae) {
                                F.merge(Te.nodes()[Ae]), we.isParent() || (j.nodeIndexes.set(Te.nodes()[Ae].id(), K++), j.xCoords.push(Te.nodes()[0].position().x), j.yCoords.push(Te.nodes()[0].position().y));
                              }), Z.push(me));
                            }), F.length > 1) {
                              var te = F.boundingBox();
                              O.push({ x: te.x1 + te.w / 2, y: te.y1 + te.h / 2 }), _.push(F), N.push(j);
                              for (var ne = Z.length - 1; ne >= 0; ne--)
                                _.splice(Z[ne], 1), N.splice(Z[ne], 1), O.splice(Z[ne], 1);
                            }
                          }
                          _.forEach(function(Te, me) {
                            w.eles = Te, R.push(m(w, N[me])), d.relocateComponent(O[me], R[me], w);
                          });
                        } else
                          _.forEach(function(Te, me) {
                            d.relocateComponent(O[me], N[me], w);
                          });
                        var V = /* @__PURE__ */ new Set();
                        if (_.length > 1) {
                          var q = [], X = k.filter(function(Te) {
                            return Te.css("display") == "none";
                          });
                          _.forEach(function(Te, me) {
                            var we = void 0;
                            if (w.quality == "draft" && (we = N[me].nodeIndexes), Te.nodes().not(X).length > 0) {
                              var Ae = {};
                              Ae.edges = [], Ae.nodes = [];
                              var Ne = void 0;
                              Te.nodes().not(X).forEach(function(Ie) {
                                if (w.quality == "draft")
                                  if (!Ie.isParent())
                                    Ne = we.get(Ie.id()), Ae.nodes.push({ x: N[me].xCoords[Ne] - Ie.boundingbox().w / 2, y: N[me].yCoords[Ne] - Ie.boundingbox().h / 2, width: Ie.boundingbox().w, height: Ie.boundingbox().h });
                                  else {
                                    var Me = d.calcBoundingBox(Ie, N[me].xCoords, N[me].yCoords, we);
                                    Ae.nodes.push({ x: Me.topLeftX, y: Me.topLeftY, width: Me.width, height: Me.height });
                                  }
                                else
                                  R[me][Ie.id()] && Ae.nodes.push({ x: R[me][Ie.id()].getLeft(), y: R[me][Ie.id()].getTop(), width: R[me][Ie.id()].getWidth(), height: R[me][Ie.id()].getHeight() });
                              }), Te.edges().forEach(function(Ie) {
                                var Me = Ie.source(), _e = Ie.target();
                                if (Me.css("display") != "none" && _e.css("display") != "none")
                                  if (w.quality == "draft") {
                                    var Be = we.get(Me.id()), st = we.get(_e.id()), ct = [], dt = [];
                                    if (Me.isParent()) {
                                      var ft = d.calcBoundingBox(Me, N[me].xCoords, N[me].yCoords, we);
                                      ct.push(ft.topLeftX + ft.width / 2), ct.push(ft.topLeftY + ft.height / 2);
                                    } else
                                      ct.push(N[me].xCoords[Be]), ct.push(N[me].yCoords[Be]);
                                    if (_e.isParent()) {
                                      var rt = d.calcBoundingBox(_e, N[me].xCoords, N[me].yCoords, we);
                                      dt.push(rt.topLeftX + rt.width / 2), dt.push(rt.topLeftY + rt.height / 2);
                                    } else
                                      dt.push(N[me].xCoords[st]), dt.push(N[me].yCoords[st]);
                                    Ae.edges.push({ startX: ct[0], startY: ct[1], endX: dt[0], endY: dt[1] });
                                  } else
                                    R[me][Me.id()] && R[me][_e.id()] && Ae.edges.push({ startX: R[me][Me.id()].getCenterX(), startY: R[me][Me.id()].getCenterY(), endX: R[me][_e.id()].getCenterX(), endY: R[me][_e.id()].getCenterY() });
                              }), Ae.nodes.length > 0 && (q.push(Ae), V.add(me));
                            }
                          });
                          var W = L.packComponents(q, w.randomize).shifts;
                          if (w.quality == "draft")
                            N.forEach(function(Te, me) {
                              var we = Te.xCoords.map(function(Ne) {
                                return Ne + W[me].dx;
                              }), Ae = Te.yCoords.map(function(Ne) {
                                return Ne + W[me].dy;
                              });
                              Te.xCoords = we, Te.yCoords = Ae;
                            });
                          else {
                            var ue = 0;
                            V.forEach(function(Te) {
                              Object.keys(R[Te]).forEach(function(me) {
                                var we = R[Te][me];
                                we.setCenter(we.getCenterX() + W[ue].dx, we.getCenterY() + W[ue].dy);
                              }), ue++;
                            });
                          }
                        }
                      } else {
                        var A = w.eles.boundingBox();
                        if (O.push({ x: A.x1 + A.w / 2, y: A.y1 + A.h / 2 }), w.randomize) {
                          var I = g(w);
                          N.push(I);
                        }
                        w.quality == "default" || w.quality == "proof" ? (R.push(m(w, N[0])), d.relocateComponent(O[0], R[0], w)) : d.relocateComponent(O[0], N[0], w);
                      }
                    var J = function(me, we) {
                      if (w.quality == "default" || w.quality == "proof") {
                        typeof me == "number" && (me = we);
                        var Ae = void 0, Ne = void 0, Ie = me.data("id");
                        return R.forEach(function(_e) {
                          Ie in _e && (Ae = { x: _e[Ie].getRect().getCenterX(), y: _e[Ie].getRect().getCenterY() }, Ne = _e[Ie]);
                        }), w.nodeDimensionsIncludeLabels && (Ne.labelWidth && (Ne.labelPosHorizontal == "left" ? Ae.x += Ne.labelWidth / 2 : Ne.labelPosHorizontal == "right" && (Ae.x -= Ne.labelWidth / 2)), Ne.labelHeight && (Ne.labelPosVertical == "top" ? Ae.y += Ne.labelHeight / 2 : Ne.labelPosVertical == "bottom" && (Ae.y -= Ne.labelHeight / 2))), Ae == null && (Ae = { x: me.position("x"), y: me.position("y") }), {
                          x: Ae.x,
                          y: Ae.y
                        };
                      } else {
                        var Me = void 0;
                        return N.forEach(function(_e) {
                          var Be = _e.nodeIndexes.get(me.id());
                          Be != null && (Me = { x: _e.xCoords[Be], y: _e.yCoords[Be] });
                        }), Me == null && (Me = { x: me.position("x"), y: me.position("y") }), {
                          x: Me.x,
                          y: Me.y
                        };
                      }
                    };
                    if (w.quality == "default" || w.quality == "proof" || w.randomize) {
                      var Ce = d.calcParentsWithoutChildren(C, k), Ee = k.filter(function(Te) {
                        return Te.css("display") == "none";
                      });
                      w.eles = k.not(Ee), k.nodes().not(":parent").not(Ee).layoutPositions(S, w, J), Ce.length > 0 && Ce.forEach(function(Te) {
                        Te.position(J(Te));
                      });
                    } else
                      console.log("If randomize option is set to false, then quality option must be 'default' or 'proof'.");
                  }
                }]), x;
              }();
              o.exports = y;
            }
          ),
          /***/
          657: (
            /***/
            (o, l, u) => {
              var c = u(548), f = u(140).layoutBase.Matrix, h = u(140).layoutBase.SVD, d = function(g) {
                var v = g.cy, m = g.eles, b = m.nodes(), y = m.nodes(":parent"), x = /* @__PURE__ */ new Map(), E = /* @__PURE__ */ new Map(), S = /* @__PURE__ */ new Map(), w = [], C = [], k = [], N = [], R = [], _ = [], O = [], T = [], L = void 0, M = 1e8, A = 1e-9, I = g.piTol, D = g.samplingType, F = g.nodeSeparation, B = void 0, G = function() {
                  for (var z = 0, Q = 0, se = !1; Q < B; ) {
                    z = Math.floor(Math.random() * L), se = !1;
                    for (var oe = 0; oe < Q; oe++)
                      if (N[oe] == z) {
                        se = !0;
                        break;
                      }
                    if (!se)
                      N[Q] = z, Q++;
                    else
                      continue;
                  }
                }, H = function(z, Q, se) {
                  for (var oe = [], he = 0, Le = 0, ge = 0, Se = void 0, xe = [], $e = 0, Ze = 1, We = 0; We < L; We++)
                    xe[We] = M;
                  for (oe[Le] = z, xe[z] = 0; Le >= he; ) {
                    ge = oe[he++];
                    for (var He = w[ge], Pe = 0; Pe < He.length; Pe++)
                      Se = E.get(He[Pe]), xe[Se] == M && (xe[Se] = xe[ge] + 1, oe[++Le] = Se);
                    _[ge][Q] = xe[ge] * F;
                  }
                  if (se) {
                    for (var De = 0; De < L; De++)
                      _[De][Q] < R[De] && (R[De] = _[De][Q]);
                    for (var mt = 0; mt < L; mt++)
                      R[mt] > $e && ($e = R[mt], Ze = mt);
                  }
                  return Ze;
                }, K = function(z) {
                  var Q = void 0;
                  if (z) {
                    Q = Math.floor(Math.random() * L);
                    for (var oe = 0; oe < L; oe++)
                      R[oe] = M;
                    for (var he = 0; he < B; he++)
                      N[he] = Q, Q = H(Q, he, z);
                  } else {
                    G();
                    for (var se = 0; se < B; se++)
                      H(N[se], se, z);
                  }
                  for (var Le = 0; Le < L; Le++)
                    for (var ge = 0; ge < B; ge++)
                      _[Le][ge] *= _[Le][ge];
                  for (var Se = 0; Se < B; Se++)
                    O[Se] = [];
                  for (var xe = 0; xe < B; xe++)
                    for (var $e = 0; $e < B; $e++)
                      O[xe][$e] = _[N[$e]][xe];
                }, j = function() {
                  for (var z = h.svd(O), Q = z.S, se = z.U, oe = z.V, he = Q[0] * Q[0] * Q[0], Le = [], ge = 0; ge < B; ge++) {
                    Le[ge] = [];
                    for (var Se = 0; Se < B; Se++)
                      Le[ge][Se] = 0, ge == Se && (Le[ge][Se] = Q[ge] / (Q[ge] * Q[ge] + he / (Q[ge] * Q[ge])));
                  }
                  T = f.multMat(f.multMat(oe, Le), f.transpose(se));
                }, Z = function() {
                  for (var z = void 0, Q = void 0, se = [], oe = [], he = [], Le = [], ge = 0; ge < L; ge++)
                    se[ge] = Math.random(), oe[ge] = Math.random();
                  se = f.normalize(se), oe = f.normalize(oe);
                  for (var Se = A, xe = A, $e = void 0; ; ) {
                    for (var Ze = 0; Ze < L; Ze++)
                      he[Ze] = se[Ze];
                    if (se = f.multGamma(f.multL(f.multGamma(he), _, T)), z = f.dotProduct(he, se), se = f.normalize(se), Se = f.dotProduct(he, se), $e = Math.abs(Se / xe), $e <= 1 + I && $e >= 1)
                      break;
                    xe = Se;
                  }
                  for (var We = 0; We < L; We++)
                    he[We] = se[We];
                  for (xe = A; ; ) {
                    for (var He = 0; He < L; He++)
                      Le[He] = oe[He];
                    if (Le = f.minusOp(Le, f.multCons(he, f.dotProduct(he, Le))), oe = f.multGamma(f.multL(f.multGamma(Le), _, T)), Q = f.dotProduct(Le, oe), oe = f.normalize(oe), Se = f.dotProduct(Le, oe), $e = Math.abs(Se / xe), $e <= 1 + I && $e >= 1)
                      break;
                    xe = Se;
                  }
                  for (var Pe = 0; Pe < L; Pe++)
                    Le[Pe] = oe[Pe];
                  C = f.multCons(he, Math.sqrt(Math.abs(z))), k = f.multCons(Le, Math.sqrt(Math.abs(Q)));
                };
                c.connectComponents(v, m, c.getTopMostNodes(b), x), y.forEach(function(ae) {
                  c.connectComponents(v, m, c.getTopMostNodes(ae.descendants().intersection(m)), x);
                });
                for (var te = 0, ne = 0; ne < b.length; ne++)
                  b[ne].isParent() || E.set(b[ne].id(), te++);
                var V = !0, q = !1, X = void 0;
                try {
                  for (var W = x.keys()[Symbol.iterator](), ue; !(V = (ue = W.next()).done); V = !0) {
                    var J = ue.value;
                    E.set(J, te++);
                  }
                } catch (ae) {
                  q = !0, X = ae;
                } finally {
                  try {
                    !V && W.return && W.return();
                  } finally {
                    if (q)
                      throw X;
                  }
                }
                for (var Ce = 0; Ce < E.size; Ce++)
                  w[Ce] = [];
                y.forEach(function(ae) {
                  for (var z = ae.children().intersection(m); z.nodes(":childless").length == 0; )
                    z = z.nodes()[0].children().intersection(m);
                  var Q = 0, se = z.nodes(":childless")[0].connectedEdges().length;
                  z.nodes(":childless").forEach(function(oe, he) {
                    oe.connectedEdges().length < se && (se = oe.connectedEdges().length, Q = he);
                  }), S.set(ae.id(), z.nodes(":childless")[Q].id());
                }), b.forEach(function(ae) {
                  var z = void 0;
                  ae.isParent() ? z = E.get(S.get(ae.id())) : z = E.get(ae.id()), ae.neighborhood().nodes().forEach(function(Q) {
                    m.intersection(ae.edgesWith(Q)).length > 0 && (Q.isParent() ? w[z].push(S.get(Q.id())) : w[z].push(Q.id()));
                  });
                });
                var Ee = function(z) {
                  var Q = E.get(z), se = void 0;
                  x.get(z).forEach(function(oe) {
                    v.getElementById(oe).isParent() ? se = S.get(oe) : se = oe, w[Q].push(se), w[E.get(se)].push(z);
                  });
                }, Te = !0, me = !1, we = void 0;
                try {
                  for (var Ae = x.keys()[Symbol.iterator](), Ne; !(Te = (Ne = Ae.next()).done); Te = !0) {
                    var Ie = Ne.value;
                    Ee(Ie);
                  }
                } catch (ae) {
                  me = !0, we = ae;
                } finally {
                  try {
                    !Te && Ae.return && Ae.return();
                  } finally {
                    if (me)
                      throw we;
                  }
                }
                L = E.size;
                var Me = void 0;
                if (L > 2) {
                  B = L < g.sampleSize ? L : g.sampleSize;
                  for (var _e = 0; _e < L; _e++)
                    _[_e] = [];
                  for (var Be = 0; Be < B; Be++)
                    T[Be] = [];
                  return g.quality == "draft" || g.step == "all" ? (K(D), j(), Z(), Me = { nodeIndexes: E, xCoords: C, yCoords: k }) : (E.forEach(function(ae, z) {
                    C.push(v.getElementById(z).position("x")), k.push(v.getElementById(z).position("y"));
                  }), Me = { nodeIndexes: E, xCoords: C, yCoords: k }), Me;
                } else {
                  var st = E.keys(), ct = v.getElementById(st.next().value), dt = ct.position(), ft = ct.outerWidth();
                  if (C.push(dt.x), k.push(dt.y), L == 2) {
                    var rt = v.getElementById(st.next().value), je = rt.outerWidth();
                    C.push(dt.x + ft / 2 + je / 2 + g.idealEdgeLength), k.push(dt.y);
                  }
                  return Me = { nodeIndexes: E, xCoords: C, yCoords: k }, Me;
                }
              };
              o.exports = { spectralLayout: d };
            }
          ),
          /***/
          579: (
            /***/
            (o, l, u) => {
              var c = u(212), f = function(d) {
                d && d("layout", "fcose", c);
              };
              typeof cytoscape < "u" && f(cytoscape), o.exports = f;
            }
          ),
          /***/
          140: (
            /***/
            (o) => {
              o.exports = r;
            }
          )
          /******/
        }, a = {};
        function i(o) {
          var l = a[o];
          if (l !== void 0)
            return l.exports;
          var u = a[o] = {
            /******/
            // no module.id needed
            /******/
            // no module.loaded needed
            /******/
            exports: {}
            /******/
          };
          return n[o](u, u.exports, i), u.exports;
        }
        var s = i(579);
        return s;
      })()
    );
  });
})(mH);
var uMe = mH.exports;
const fLe = /* @__PURE__ */ ho(uMe), cMe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  InfoModule: JU,
  createInfoServices: eH
}, Symbol.toStringTag, { value: "Module" })), fMe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  PacketModule: tH,
  createPacketServices: rH
}, Symbol.toStringTag, { value: "Module" })), hMe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  PieModule: nH,
  createPieServices: aH
}, Symbol.toStringTag, { value: "Module" })), dMe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ArchitectureModule: iH,
  createArchitectureServices: sH
}, Symbol.toStringTag, { value: "Module" })), pMe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  GitGraphModule: ZU,
  createGitGraphServices: QU
}, Symbol.toStringTag, { value: "Module" })), gMe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  RadarModule: oH,
  createRadarServices: lH
}, Symbol.toStringTag, { value: "Module" })), vMe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  TreemapModule: cH,
  createTreemapServices: fH
}, Symbol.toStringTag, { value: "Module" }));
export {
  R_e as $,
  bD as A,
  QMe as B,
  XX as C,
  W_e as D,
  sX as E,
  DMe as F,
  VY as G,
  RY as H,
  AMe as I,
  hY as J,
  IMe as K,
  Kj as L,
  phe as M,
  Ij as N,
  yj as O,
  KMe as P,
  ZMe as Q,
  ete as R,
  XMe as S,
  YMe as T,
  jMe as U,
  n_e as V,
  C5 as W,
  qoe as X,
  M_e as Y,
  __e as Z,
  Ra as _,
  MMe as a,
  t9 as a$,
  k_e as a0,
  A_e as a1,
  C_e as a2,
  S_e as a3,
  zoe as a4,
  w_e as a5,
  T_e as a6,
  E_e as a7,
  y_e as a8,
  x_e as a9,
  WMe as aA,
  D7e as aB,
  o_e as aC,
  e_e as aD,
  JMe as aE,
  fse as aF,
  a_e as aG,
  r_e as aH,
  u9 as aI,
  b5 as aJ,
  f1 as aK,
  bse as aL,
  yse as aM,
  Qc as aN,
  mse as aO,
  vse as aP,
  nm as aQ,
  U0 as aR,
  m5 as aS,
  v5 as aT,
  sc as aU,
  rm as aV,
  t_e as aW,
  rLe as aX,
  nLe as aY,
  aLe as aZ,
  u_e as a_,
  b_e as aa,
  m_e as ab,
  d_e as ac,
  h_e as ad,
  v_e as ae,
  g_e as af,
  p_e as ag,
  kT as ah,
  O_e as ai,
  P_e as aj,
  I_e as ak,
  Er as al,
  L_e as am,
  N_e as an,
  G_e as ao,
  V_e as ap,
  c_e as aq,
  Wc as ar,
  NE as as,
  LE as at,
  mr as au,
  As as av,
  Q_e as aw,
  Z_e as ax,
  df as ay,
  J_e as az,
  OI as b,
  f_e as b0,
  rse as b1,
  iLe as b2,
  uLe as b3,
  W7e as b4,
  lLe as b5,
  oLe as b6,
  sLe as b7,
  l_e as b8,
  cLe as b9,
  _n as ba,
  fLe as bb,
  QP as bc,
  e9 as bd,
  s_e as be,
  zMe as bf,
  GMe as bg,
  Y_e as bh,
  K_e as bi,
  NMe as c,
  AK as d,
  MA as e,
  NI as f,
  PMe as g,
  kMe as h,
  XQ as i,
  CMe as j,
  IO as k,
  Fd as l,
  cI as m,
  zv as n,
  ZQ as o,
  $Me as p,
  pee as q,
  RMe as r,
  UMe as s,
  HMe as t,
  OMe as u,
  Lee as v,
  VMe as w,
  HJ as x,
  DS as y,
  q_e as z
};
