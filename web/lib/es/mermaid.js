import { P as st, Q as Bt, R as Zi, S as zt, T as Ft, U as Ni, B as ua, V as yt, W as Cc, X as ns, Y as hd, Z as ud, $ as dd, a0 as pd, a1 as gd, a2 as fd, a3 as ym, a4 as ul, a5 as yd, a6 as mm, a7 as xm, a8 as md, a9 as bm, aa as km, ab as vm, ac as xd, ad as bd, ae as Sm, af as Cm, ag as _s, ah as wm, ai as Tm, aj as _m, ak as Em, al as kd, am as Am, an as Lm, ao as vd, ap as Rt, aq as Ha, ar as Bm, as as Dm, at as Im, au as Gh, av as vo, aw as Gr, ax as Sd, ay as So, az as Fm, aA as wc, aB as os, aC as Nm, aD as Rm, aE as Mm, aF as Ua, aG as Om, aH as Pm, aI as Xh, aJ as Kh, aK as $m, aL as Vm, aM as zm, aN as Wm, aO as qm, aP as Ym, aQ as Hm, aR as Qh, aS as Zh, aT as Jh, aU as tu, aV as eu, aW as Um, aX as jm, aY as Gm, aZ as Xm, a_ as da, a$ as Va, b0 as Km, b1 as ru, b2 as Qm, b3 as Zm, b4 as Jm, b5 as tx, b6 as ex, b7 as rx, b8 as ix, b9 as sx, ba as ax, bb as nx, bc as Ea, bd as ox, be as lx } from "./vendor.js";
import ir from "dayjs";
var dl = {
  name: "mermaid",
  version: "11.12.1",
  description: "Markdown-ish syntax for generating flowcharts, mindmaps, sequence diagrams, class diagrams, gantt charts, git graphs and more.",
  type: "module",
  module: "./dist/mermaid.core.mjs",
  types: "./dist/mermaid.d.ts",
  exports: {
    ".": {
      types: "./dist/mermaid.d.ts",
      import: "./dist/mermaid.core.mjs",
      default: "./dist/mermaid.core.mjs"
    },
    "./*": "./*"
  },
  keywords: [
    "diagram",
    "markdown",
    "flowchart",
    "sequence diagram",
    "gantt",
    "class diagram",
    "git graph",
    "mindmap",
    "packet diagram",
    "c4 diagram",
    "er diagram",
    "pie chart",
    "pie diagram",
    "quadrant chart",
    "requirement diagram",
    "graph"
  ],
  scripts: {
    clean: "rimraf dist",
    dev: "pnpm -w dev",
    "docs:code": "typedoc src/defaultConfig.ts src/config.ts src/mermaid.ts && prettier --write ./src/docs/config/setup",
    "docs:build": "rimraf ../../docs && pnpm docs:code && pnpm docs:spellcheck && tsx scripts/docs.cli.mts",
    "docs:verify": "pnpm docs:code && pnpm docs:spellcheck && tsx scripts/docs.cli.mts --verify",
    "docs:pre:vitepress": "pnpm --filter ./src/docs prefetch && rimraf src/vitepress && pnpm docs:code && tsx scripts/docs.cli.mts --vitepress && pnpm --filter ./src/vitepress install --no-frozen-lockfile --ignore-scripts",
    "docs:build:vitepress": "pnpm docs:pre:vitepress && (cd src/vitepress && pnpm run build) && cpy --flat src/docs/landing/ ./src/vitepress/.vitepress/dist/landing",
    "docs:dev": 'pnpm docs:pre:vitepress && concurrently "pnpm --filter ./src/vitepress dev" "tsx scripts/docs.cli.mts --watch --vitepress"',
    "docs:dev:docker": 'pnpm docs:pre:vitepress && concurrently "pnpm --filter ./src/vitepress dev:docker" "tsx scripts/docs.cli.mts --watch --vitepress"',
    "docs:serve": "pnpm docs:build:vitepress && vitepress serve src/vitepress",
    "docs:spellcheck": 'cspell "src/docs/**/*.md"',
    "docs:release-version": "tsx scripts/update-release-version.mts",
    "docs:verify-version": "tsx scripts/update-release-version.mts --verify",
    "types:build-config": "tsx scripts/create-types-from-json-schema.mts",
    "types:verify-config": "tsx scripts/create-types-from-json-schema.mts --verify",
    checkCircle: "npx madge --circular ./src",
    prepublishOnly: "pnpm docs:verify-version"
  },
  repository: {
    type: "git",
    url: "https://github.com/mermaid-js/mermaid"
  },
  author: "Knut Sveidqvist",
  license: "MIT",
  standard: {
    ignore: [
      "**/parser/*.js",
      "dist/**/*.js",
      "cypress/**/*.js"
    ],
    globals: [
      "page"
    ]
  },
  dependencies: {
    "@braintree/sanitize-url": "^7.1.1",
    "@iconify/utils": "^3.0.1",
    "@mermaid-js/parser": "workspace:^",
    "@types/d3": "^7.4.3",
    cytoscape: "^3.29.3",
    "cytoscape-cose-bilkent": "^4.1.0",
    "cytoscape-fcose": "^2.2.0",
    d3: "^7.9.0",
    "d3-sankey": "^0.12.3",
    "dagre-d3-es": "7.0.13",
    dayjs: "^1.11.18",
    dompurify: "^3.2.5",
    katex: "^0.16.22",
    khroma: "^2.1.0",
    "lodash-es": "^4.17.21",
    marked: "^16.2.1",
    roughjs: "^4.6.6",
    stylis: "^4.3.6",
    "ts-dedent": "^2.2.0",
    uuid: "^11.1.0"
  },
  devDependencies: {
    "@adobe/jsonschema2md": "^8.0.5",
    "@iconify/types": "^2.0.0",
    "@types/cytoscape": "^3.21.9",
    "@types/cytoscape-fcose": "^2.2.4",
    "@types/d3-sankey": "^0.12.4",
    "@types/d3-scale": "^4.0.9",
    "@types/d3-scale-chromatic": "^3.1.0",
    "@types/d3-selection": "^3.0.11",
    "@types/d3-shape": "^3.1.7",
    "@types/jsdom": "^21.1.7",
    "@types/katex": "^0.16.7",
    "@types/lodash-es": "^4.17.12",
    "@types/micromatch": "^4.0.9",
    "@types/stylis": "^4.2.7",
    "@types/uuid": "^10.0.0",
    ajv: "^8.17.1",
    canvas: "^3.1.2",
    chokidar: "3.6.0",
    concurrently: "^9.1.2",
    "csstree-validator": "^4.0.1",
    globby: "^14.1.0",
    jison: "^0.4.18",
    "js-base64": "^3.7.8",
    jsdom: "^26.1.0",
    "json-schema-to-typescript": "^15.0.4",
    micromatch: "^4.0.8",
    "path-browserify": "^1.0.1",
    prettier: "^3.5.3",
    remark: "^15.0.1",
    "remark-frontmatter": "^5.0.0",
    "remark-gfm": "^4.0.1",
    rimraf: "^6.0.1",
    "start-server-and-test": "^2.0.13",
    "type-fest": "^4.35.0",
    typedoc: "^0.28.12",
    "typedoc-plugin-markdown": "^4.8.1",
    typescript: "~5.7.3",
    "unist-util-flatmap": "^1.0.0",
    "unist-util-visit": "^5.0.0",
    vitepress: "^1.6.4",
    "vitepress-plugin-search": "1.0.4-alpha.22"
  },
  files: [
    "dist/",
    "README.md"
  ],
  publishConfig: {
    access: "public"
  }
}, Cd = Object.defineProperty, u = (e, t) => Cd(e, "name", { value: t, configurable: !0 }), Co = (e, t) => {
  for (var r in t)
    Cd(e, r, { get: t[r], enumerable: !0 });
}, oi = {
  trace: 0,
  debug: 1,
  info: 2,
  warn: 3,
  error: 4,
  fatal: 5
}, I = {
  trace: /* @__PURE__ */ u((...e) => {
  }, "trace"),
  debug: /* @__PURE__ */ u((...e) => {
  }, "debug"),
  info: /* @__PURE__ */ u((...e) => {
  }, "info"),
  warn: /* @__PURE__ */ u((...e) => {
  }, "warn"),
  error: /* @__PURE__ */ u((...e) => {
  }, "error"),
  fatal: /* @__PURE__ */ u((...e) => {
  }, "fatal")
}, Tc = /* @__PURE__ */ u(function(e = "fatal") {
  let t = oi.fatal;
  typeof e == "string" ? e.toLowerCase() in oi && (t = oi[e]) : typeof e == "number" && (t = e), I.trace = () => {
  }, I.debug = () => {
  }, I.info = () => {
  }, I.warn = () => {
  }, I.error = () => {
  }, I.fatal = () => {
  }, t <= oi.fatal && (I.fatal = console.error ? console.error.bind(console, Br("FATAL"), "color: orange") : console.log.bind(console, "\x1B[35m", Br("FATAL"))), t <= oi.error && (I.error = console.error ? console.error.bind(console, Br("ERROR"), "color: orange") : console.log.bind(console, "\x1B[31m", Br("ERROR"))), t <= oi.warn && (I.warn = console.warn ? console.warn.bind(console, Br("WARN"), "color: orange") : console.log.bind(console, "\x1B[33m", Br("WARN"))), t <= oi.info && (I.info = console.info ? console.info.bind(console, Br("INFO"), "color: lightblue") : console.log.bind(console, "\x1B[34m", Br("INFO"))), t <= oi.debug && (I.debug = console.debug ? console.debug.bind(console, Br("DEBUG"), "color: lightgreen") : console.log.bind(console, "\x1B[32m", Br("DEBUG"))), t <= oi.trace && (I.trace = console.debug ? console.debug.bind(console, Br("TRACE"), "color: lightgreen") : console.log.bind(console, "\x1B[32m", Br("TRACE")));
}, "setLogLevel"), Br = /* @__PURE__ */ u((e) => `%c${ir().format("ss.SSS")} : ${e} : `, "format"), wd = /^-{3}\s*[\n\r](.*?)[\n\r]-{3}\s*[\n\r]+/s, za = /%{2}{\s*(?:(\w+)\s*:|(\w+))\s*(?:(\w+)|((?:(?!}%{2}).|\r?\n)*))?\s*(?:}%{2})?/gi, cx = /\s*%%.*\n/gm, Bs, Td = (Bs = class extends Error {
  constructor(t) {
    super(t), this.name = "UnknownDiagramError";
  }
}, u(Bs, "UnknownDiagramError"), Bs), es = {}, _c = /* @__PURE__ */ u(function(e, t) {
  e = e.replace(wd, "").replace(za, "").replace(cx, `
`);
  for (const [r, { detector: i }] of Object.entries(es))
    if (i(e, t))
      return r;
  throw new Td(
    `No diagram type detected matching given configuration for text: ${e}`
  );
}, "detectType"), pl = /* @__PURE__ */ u((...e) => {
  for (const { id: t, detector: r, loader: i } of e)
    _d(t, r, i);
}, "registerLazyLoadedDiagrams"), _d = /* @__PURE__ */ u((e, t, r) => {
  es[e] && I.warn(`Detector with key ${e} already exists. Overwriting.`), es[e] = { detector: t, loader: r }, I.debug(`Detector with key ${e} added${r ? " with loader" : ""}`);
}, "addDetector"), hx = /* @__PURE__ */ u((e) => es[e].loader, "getDiagramLoader"), gl = /* @__PURE__ */ u((e, t, { depth: r = 2, clobber: i = !1 } = {}) => {
  const s = { depth: r, clobber: i };
  return Array.isArray(t) && !Array.isArray(e) ? (t.forEach((a) => gl(e, a, s)), e) : Array.isArray(t) && Array.isArray(e) ? (t.forEach((a) => {
    e.includes(a) || e.push(a);
  }), e) : e === void 0 || r <= 0 ? e != null && typeof e == "object" && typeof t == "object" ? Object.assign(e, t) : t : (t !== void 0 && typeof e == "object" && typeof t == "object" && Object.keys(t).forEach((a) => {
    typeof t[a] == "object" && (e[a] === void 0 || typeof e[a] == "object") ? (e[a] === void 0 && (e[a] = Array.isArray(t[a]) ? [] : {}), e[a] = gl(e[a], t[a], { depth: r - 1, clobber: i })) : (i || typeof e[a] != "object" && typeof t[a] != "object") && (e[a] = t[a]);
  }), e);
}, "assignWithDepth"), De = gl, wo = "#ffffff", To = "#f2f2f2", hr = /* @__PURE__ */ u((e, t) => t ? st(e, { s: -40, l: 10 }) : st(e, { s: -40, l: -10 }), "mkBorder"), Ds, ux = (Ds = class {
  constructor() {
    this.background = "#f4f4f4", this.primaryColor = "#fff4dd", this.noteBkgColor = "#fff5ad", this.noteTextColor = "#333", this.THEME_COLOR_LIMIT = 12, this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif', this.fontSize = "16px";
  }
  updateColors() {
    var r, i, s, a, n, o, h, l, d, p, g, f, y, m, x, b, v, _, A, S, k;
    if (this.primaryTextColor = this.primaryTextColor || (this.darkMode ? "#eee" : "#333"), this.secondaryColor = this.secondaryColor || st(this.primaryColor, { h: -120 }), this.tertiaryColor = this.tertiaryColor || st(this.primaryColor, { h: 180, l: 5 }), this.primaryBorderColor = this.primaryBorderColor || hr(this.primaryColor, this.darkMode), this.secondaryBorderColor = this.secondaryBorderColor || hr(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = this.tertiaryBorderColor || hr(this.tertiaryColor, this.darkMode), this.noteBorderColor = this.noteBorderColor || hr(this.noteBkgColor, this.darkMode), this.noteBkgColor = this.noteBkgColor || "#fff5ad", this.noteTextColor = this.noteTextColor || "#333", this.secondaryTextColor = this.secondaryTextColor || Bt(this.secondaryColor), this.tertiaryTextColor = this.tertiaryTextColor || Bt(this.tertiaryColor), this.lineColor = this.lineColor || Bt(this.background), this.arrowheadColor = this.arrowheadColor || Bt(this.background), this.textColor = this.textColor || this.primaryTextColor, this.border2 = this.border2 || this.tertiaryBorderColor, this.nodeBkg = this.nodeBkg || this.primaryColor, this.mainBkg = this.mainBkg || this.primaryColor, this.nodeBorder = this.nodeBorder || this.primaryBorderColor, this.clusterBkg = this.clusterBkg || this.tertiaryColor, this.clusterBorder = this.clusterBorder || this.tertiaryBorderColor, this.defaultLinkColor = this.defaultLinkColor || this.lineColor, this.titleColor = this.titleColor || this.tertiaryTextColor, this.edgeLabelBackground = this.edgeLabelBackground || (this.darkMode ? zt(this.secondaryColor, 30) : this.secondaryColor), this.nodeTextColor = this.nodeTextColor || this.primaryTextColor, this.actorBorder = this.actorBorder || this.primaryBorderColor, this.actorBkg = this.actorBkg || this.mainBkg, this.actorTextColor = this.actorTextColor || this.primaryTextColor, this.actorLineColor = this.actorLineColor || this.actorBorder, this.labelBoxBkgColor = this.labelBoxBkgColor || this.actorBkg, this.signalColor = this.signalColor || this.textColor, this.signalTextColor = this.signalTextColor || this.textColor, this.labelBoxBorderColor = this.labelBoxBorderColor || this.actorBorder, this.labelTextColor = this.labelTextColor || this.actorTextColor, this.loopTextColor = this.loopTextColor || this.actorTextColor, this.activationBorderColor = this.activationBorderColor || zt(this.secondaryColor, 10), this.activationBkgColor = this.activationBkgColor || this.secondaryColor, this.sequenceNumberColor = this.sequenceNumberColor || Bt(this.lineColor), this.sectionBkgColor = this.sectionBkgColor || this.tertiaryColor, this.altSectionBkgColor = this.altSectionBkgColor || "white", this.sectionBkgColor = this.sectionBkgColor || this.secondaryColor, this.sectionBkgColor2 = this.sectionBkgColor2 || this.primaryColor, this.excludeBkgColor = this.excludeBkgColor || "#eeeeee", this.taskBorderColor = this.taskBorderColor || this.primaryBorderColor, this.taskBkgColor = this.taskBkgColor || this.primaryColor, this.activeTaskBorderColor = this.activeTaskBorderColor || this.primaryColor, this.activeTaskBkgColor = this.activeTaskBkgColor || Ft(this.primaryColor, 23), this.gridColor = this.gridColor || "lightgrey", this.doneTaskBkgColor = this.doneTaskBkgColor || "lightgrey", this.doneTaskBorderColor = this.doneTaskBorderColor || "grey", this.critBorderColor = this.critBorderColor || "#ff8888", this.critBkgColor = this.critBkgColor || "red", this.todayLineColor = this.todayLineColor || "red", this.vertLineColor = this.vertLineColor || "navy", this.taskTextColor = this.taskTextColor || this.textColor, this.taskTextOutsideColor = this.taskTextOutsideColor || this.textColor, this.taskTextLightColor = this.taskTextLightColor || this.textColor, this.taskTextColor = this.taskTextColor || this.primaryTextColor, this.taskTextDarkColor = this.taskTextDarkColor || this.textColor, this.taskTextClickableColor = this.taskTextClickableColor || "#003163", this.personBorder = this.personBorder || this.primaryBorderColor, this.personBkg = this.personBkg || this.mainBkg, this.darkMode ? (this.rowOdd = this.rowOdd || zt(this.mainBkg, 5) || "#ffffff", this.rowEven = this.rowEven || zt(this.mainBkg, 10)) : (this.rowOdd = this.rowOdd || Ft(this.mainBkg, 75) || "#ffffff", this.rowEven = this.rowEven || Ft(this.mainBkg, 5)), this.transitionColor = this.transitionColor || this.lineColor, this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || this.tertiaryColor, this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.compositeBorder = this.compositeBorder || this.nodeBorder, this.innerEndBackground = this.nodeBorder, this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.transitionColor = this.transitionColor || this.lineColor, this.specialStateColor = this.lineColor, this.cScale0 = this.cScale0 || this.primaryColor, this.cScale1 = this.cScale1 || this.secondaryColor, this.cScale2 = this.cScale2 || this.tertiaryColor, this.cScale3 = this.cScale3 || st(this.primaryColor, { h: 30 }), this.cScale4 = this.cScale4 || st(this.primaryColor, { h: 60 }), this.cScale5 = this.cScale5 || st(this.primaryColor, { h: 90 }), this.cScale6 = this.cScale6 || st(this.primaryColor, { h: 120 }), this.cScale7 = this.cScale7 || st(this.primaryColor, { h: 150 }), this.cScale8 = this.cScale8 || st(this.primaryColor, { h: 210, l: 150 }), this.cScale9 = this.cScale9 || st(this.primaryColor, { h: 270 }), this.cScale10 = this.cScale10 || st(this.primaryColor, { h: 300 }), this.cScale11 = this.cScale11 || st(this.primaryColor, { h: 330 }), this.darkMode)
      for (let L = 0; L < this.THEME_COLOR_LIMIT; L++)
        this["cScale" + L] = zt(this["cScale" + L], 75);
    else
      for (let L = 0; L < this.THEME_COLOR_LIMIT; L++)
        this["cScale" + L] = zt(this["cScale" + L], 25);
    for (let L = 0; L < this.THEME_COLOR_LIMIT; L++)
      this["cScaleInv" + L] = this["cScaleInv" + L] || Bt(this["cScale" + L]);
    for (let L = 0; L < this.THEME_COLOR_LIMIT; L++)
      this.darkMode ? this["cScalePeer" + L] = this["cScalePeer" + L] || Ft(this["cScale" + L], 10) : this["cScalePeer" + L] = this["cScalePeer" + L] || zt(this["cScale" + L], 10);
    this.scaleLabelColor = this.scaleLabelColor || this.labelTextColor;
    for (let L = 0; L < this.THEME_COLOR_LIMIT; L++)
      this["cScaleLabel" + L] = this["cScaleLabel" + L] || this.scaleLabelColor;
    const t = this.darkMode ? -4 : -1;
    for (let L = 0; L < 5; L++)
      this["surface" + L] = this["surface" + L] || st(this.mainBkg, { h: 180, s: -15, l: t * (5 + L * 3) }), this["surfacePeer" + L] = this["surfacePeer" + L] || st(this.mainBkg, { h: 180, s: -15, l: t * (8 + L * 3) });
    this.classText = this.classText || this.textColor, this.fillType0 = this.fillType0 || this.primaryColor, this.fillType1 = this.fillType1 || this.secondaryColor, this.fillType2 = this.fillType2 || st(this.primaryColor, { h: 64 }), this.fillType3 = this.fillType3 || st(this.secondaryColor, { h: 64 }), this.fillType4 = this.fillType4 || st(this.primaryColor, { h: -64 }), this.fillType5 = this.fillType5 || st(this.secondaryColor, { h: -64 }), this.fillType6 = this.fillType6 || st(this.primaryColor, { h: 128 }), this.fillType7 = this.fillType7 || st(this.secondaryColor, { h: 128 }), this.pie1 = this.pie1 || this.primaryColor, this.pie2 = this.pie2 || this.secondaryColor, this.pie3 = this.pie3 || this.tertiaryColor, this.pie4 = this.pie4 || st(this.primaryColor, { l: -10 }), this.pie5 = this.pie5 || st(this.secondaryColor, { l: -10 }), this.pie6 = this.pie6 || st(this.tertiaryColor, { l: -10 }), this.pie7 = this.pie7 || st(this.primaryColor, { h: 60, l: -10 }), this.pie8 = this.pie8 || st(this.primaryColor, { h: -60, l: -10 }), this.pie9 = this.pie9 || st(this.primaryColor, { h: 120, l: 0 }), this.pie10 = this.pie10 || st(this.primaryColor, { h: 60, l: -20 }), this.pie11 = this.pie11 || st(this.primaryColor, { h: -60, l: -20 }), this.pie12 = this.pie12 || st(this.primaryColor, { h: 120, l: -10 }), this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px", this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black", this.pieOpacity = this.pieOpacity || "0.7", this.radar = {
      axisColor: ((r = this.radar) == null ? void 0 : r.axisColor) || this.lineColor,
      axisStrokeWidth: ((i = this.radar) == null ? void 0 : i.axisStrokeWidth) || 2,
      axisLabelFontSize: ((s = this.radar) == null ? void 0 : s.axisLabelFontSize) || 12,
      curveOpacity: ((a = this.radar) == null ? void 0 : a.curveOpacity) || 0.5,
      curveStrokeWidth: ((n = this.radar) == null ? void 0 : n.curveStrokeWidth) || 2,
      graticuleColor: ((o = this.radar) == null ? void 0 : o.graticuleColor) || "#DEDEDE",
      graticuleStrokeWidth: ((h = this.radar) == null ? void 0 : h.graticuleStrokeWidth) || 1,
      graticuleOpacity: ((l = this.radar) == null ? void 0 : l.graticuleOpacity) || 0.3,
      legendBoxSize: ((d = this.radar) == null ? void 0 : d.legendBoxSize) || 12,
      legendFontSize: ((p = this.radar) == null ? void 0 : p.legendFontSize) || 12
    }, this.archEdgeColor = this.archEdgeColor || "#777", this.archEdgeArrowColor = this.archEdgeArrowColor || "#777", this.archEdgeWidth = this.archEdgeWidth || "3", this.archGroupBorderColor = this.archGroupBorderColor || "#000", this.archGroupBorderWidth = this.archGroupBorderWidth || "2px", this.quadrant1Fill = this.quadrant1Fill || this.primaryColor, this.quadrant2Fill = this.quadrant2Fill || st(this.primaryColor, { r: 5, g: 5, b: 5 }), this.quadrant3Fill = this.quadrant3Fill || st(this.primaryColor, { r: 10, g: 10, b: 10 }), this.quadrant4Fill = this.quadrant4Fill || st(this.primaryColor, { r: 15, g: 15, b: 15 }), this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor, this.quadrant2TextFill = this.quadrant2TextFill || st(this.primaryTextColor, { r: -5, g: -5, b: -5 }), this.quadrant3TextFill = this.quadrant3TextFill || st(this.primaryTextColor, { r: -10, g: -10, b: -10 }), this.quadrant4TextFill = this.quadrant4TextFill || st(this.primaryTextColor, { r: -15, g: -15, b: -15 }), this.quadrantPointFill = this.quadrantPointFill || Ni(this.quadrant1Fill) ? Ft(this.quadrant1Fill) : zt(this.quadrant1Fill), this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor, this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor, this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor, this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor, this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor, this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor, this.xyChart = {
      backgroundColor: ((g = this.xyChart) == null ? void 0 : g.backgroundColor) || this.background,
      titleColor: ((f = this.xyChart) == null ? void 0 : f.titleColor) || this.primaryTextColor,
      xAxisTitleColor: ((y = this.xyChart) == null ? void 0 : y.xAxisTitleColor) || this.primaryTextColor,
      xAxisLabelColor: ((m = this.xyChart) == null ? void 0 : m.xAxisLabelColor) || this.primaryTextColor,
      xAxisTickColor: ((x = this.xyChart) == null ? void 0 : x.xAxisTickColor) || this.primaryTextColor,
      xAxisLineColor: ((b = this.xyChart) == null ? void 0 : b.xAxisLineColor) || this.primaryTextColor,
      yAxisTitleColor: ((v = this.xyChart) == null ? void 0 : v.yAxisTitleColor) || this.primaryTextColor,
      yAxisLabelColor: ((_ = this.xyChart) == null ? void 0 : _.yAxisLabelColor) || this.primaryTextColor,
      yAxisTickColor: ((A = this.xyChart) == null ? void 0 : A.yAxisTickColor) || this.primaryTextColor,
      yAxisLineColor: ((S = this.xyChart) == null ? void 0 : S.yAxisLineColor) || this.primaryTextColor,
      plotColorPalette: ((k = this.xyChart) == null ? void 0 : k.plotColorPalette) || "#FFF4DD,#FFD8B1,#FFA07A,#ECEFF1,#D6DBDF,#C3E0A8,#FFB6A4,#FFD74D,#738FA7,#FFFFF0"
    }, this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || "1", this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || (this.darkMode ? zt(this.secondaryColor, 30) : this.secondaryColor), this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = this.git0 || this.primaryColor, this.git1 = this.git1 || this.secondaryColor, this.git2 = this.git2 || this.tertiaryColor, this.git3 = this.git3 || st(this.primaryColor, { h: -30 }), this.git4 = this.git4 || st(this.primaryColor, { h: -60 }), this.git5 = this.git5 || st(this.primaryColor, { h: -90 }), this.git6 = this.git6 || st(this.primaryColor, { h: 60 }), this.git7 = this.git7 || st(this.primaryColor, { h: 120 }), this.darkMode ? (this.git0 = Ft(this.git0, 25), this.git1 = Ft(this.git1, 25), this.git2 = Ft(this.git2, 25), this.git3 = Ft(this.git3, 25), this.git4 = Ft(this.git4, 25), this.git5 = Ft(this.git5, 25), this.git6 = Ft(this.git6, 25), this.git7 = Ft(this.git7, 25)) : (this.git0 = zt(this.git0, 25), this.git1 = zt(this.git1, 25), this.git2 = zt(this.git2, 25), this.git3 = zt(this.git3, 25), this.git4 = zt(this.git4, 25), this.git5 = zt(this.git5, 25), this.git6 = zt(this.git6, 25), this.git7 = zt(this.git7, 25)), this.gitInv0 = this.gitInv0 || Bt(this.git0), this.gitInv1 = this.gitInv1 || Bt(this.git1), this.gitInv2 = this.gitInv2 || Bt(this.git2), this.gitInv3 = this.gitInv3 || Bt(this.git3), this.gitInv4 = this.gitInv4 || Bt(this.git4), this.gitInv5 = this.gitInv5 || Bt(this.git5), this.gitInv6 = this.gitInv6 || Bt(this.git6), this.gitInv7 = this.gitInv7 || Bt(this.git7), this.branchLabelColor = this.branchLabelColor || (this.darkMode ? "black" : this.labelTextColor), this.gitBranchLabel0 = this.gitBranchLabel0 || this.branchLabelColor, this.gitBranchLabel1 = this.gitBranchLabel1 || this.branchLabelColor, this.gitBranchLabel2 = this.gitBranchLabel2 || this.branchLabelColor, this.gitBranchLabel3 = this.gitBranchLabel3 || this.branchLabelColor, this.gitBranchLabel4 = this.gitBranchLabel4 || this.branchLabelColor, this.gitBranchLabel5 = this.gitBranchLabel5 || this.branchLabelColor, this.gitBranchLabel6 = this.gitBranchLabel6 || this.branchLabelColor, this.gitBranchLabel7 = this.gitBranchLabel7 || this.branchLabelColor, this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || wo, this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || To;
  }
  calculate(t) {
    if (typeof t != "object") {
      this.updateColors();
      return;
    }
    const r = Object.keys(t);
    r.forEach((i) => {
      this[i] = t[i];
    }), this.updateColors(), r.forEach((i) => {
      this[i] = t[i];
    });
  }
}, u(Ds, "Theme"), Ds), dx = /* @__PURE__ */ u((e) => {
  const t = new ux();
  return t.calculate(e), t;
}, "getThemeVariables"), Is, px = (Is = class {
  constructor() {
    this.background = "#333", this.primaryColor = "#1f2020", this.secondaryColor = Ft(this.primaryColor, 16), this.tertiaryColor = st(this.primaryColor, { h: -160 }), this.primaryBorderColor = Bt(this.background), this.secondaryBorderColor = hr(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = hr(this.tertiaryColor, this.darkMode), this.primaryTextColor = Bt(this.primaryColor), this.secondaryTextColor = Bt(this.secondaryColor), this.tertiaryTextColor = Bt(this.tertiaryColor), this.lineColor = Bt(this.background), this.textColor = Bt(this.background), this.mainBkg = "#1f2020", this.secondBkg = "calculated", this.mainContrastColor = "lightgrey", this.darkTextColor = Ft(Bt("#323D47"), 10), this.lineColor = "calculated", this.border1 = "#ccc", this.border2 = Zi(255, 255, 255, 0.25), this.arrowheadColor = "calculated", this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif', this.fontSize = "16px", this.labelBackground = "#181818", this.textColor = "#ccc", this.THEME_COLOR_LIMIT = 12, this.nodeBkg = "calculated", this.nodeBorder = "calculated", this.clusterBkg = "calculated", this.clusterBorder = "calculated", this.defaultLinkColor = "calculated", this.titleColor = "#F9FFFE", this.edgeLabelBackground = "calculated", this.actorBorder = "calculated", this.actorBkg = "calculated", this.actorTextColor = "calculated", this.actorLineColor = "calculated", this.signalColor = "calculated", this.signalTextColor = "calculated", this.labelBoxBkgColor = "calculated", this.labelBoxBorderColor = "calculated", this.labelTextColor = "calculated", this.loopTextColor = "calculated", this.noteBorderColor = "calculated", this.noteBkgColor = "#fff5ad", this.noteTextColor = "calculated", this.activationBorderColor = "calculated", this.activationBkgColor = "calculated", this.sequenceNumberColor = "black", this.sectionBkgColor = zt("#EAE8D9", 30), this.altSectionBkgColor = "calculated", this.sectionBkgColor2 = "#EAE8D9", this.excludeBkgColor = zt(this.sectionBkgColor, 10), this.taskBorderColor = Zi(255, 255, 255, 70), this.taskBkgColor = "calculated", this.taskTextColor = "calculated", this.taskTextLightColor = "calculated", this.taskTextOutsideColor = "calculated", this.taskTextClickableColor = "#003163", this.activeTaskBorderColor = Zi(255, 255, 255, 50), this.activeTaskBkgColor = "#81B1DB", this.gridColor = "calculated", this.doneTaskBkgColor = "calculated", this.doneTaskBorderColor = "grey", this.critBorderColor = "#E83737", this.critBkgColor = "#E83737", this.taskTextDarkColor = "calculated", this.todayLineColor = "#DB5757", this.vertLineColor = "#00BFFF", this.personBorder = this.primaryBorderColor, this.personBkg = this.mainBkg, this.archEdgeColor = "calculated", this.archEdgeArrowColor = "calculated", this.archEdgeWidth = "3", this.archGroupBorderColor = this.primaryBorderColor, this.archGroupBorderWidth = "2px", this.rowOdd = this.rowOdd || Ft(this.mainBkg, 5) || "#ffffff", this.rowEven = this.rowEven || zt(this.mainBkg, 10), this.labelColor = "calculated", this.errorBkgColor = "#a44141", this.errorTextColor = "#ddd";
  }
  updateColors() {
    var t, r, i, s, a, n, o, h, l, d, p, g, f, y, m, x, b, v, _, A, S;
    this.secondBkg = Ft(this.mainBkg, 16), this.lineColor = this.mainContrastColor, this.arrowheadColor = this.mainContrastColor, this.nodeBkg = this.mainBkg, this.nodeBorder = this.border1, this.clusterBkg = this.secondBkg, this.clusterBorder = this.border2, this.defaultLinkColor = this.lineColor, this.edgeLabelBackground = Ft(this.labelBackground, 25), this.actorBorder = this.border1, this.actorBkg = this.mainBkg, this.actorTextColor = this.mainContrastColor, this.actorLineColor = this.actorBorder, this.signalColor = this.mainContrastColor, this.signalTextColor = this.mainContrastColor, this.labelBoxBkgColor = this.actorBkg, this.labelBoxBorderColor = this.actorBorder, this.labelTextColor = this.mainContrastColor, this.loopTextColor = this.mainContrastColor, this.noteBorderColor = this.secondaryBorderColor, this.noteBkgColor = this.secondBkg, this.noteTextColor = this.secondaryTextColor, this.activationBorderColor = this.border1, this.activationBkgColor = this.secondBkg, this.altSectionBkgColor = this.background, this.taskBkgColor = Ft(this.mainBkg, 23), this.taskTextColor = this.darkTextColor, this.taskTextLightColor = this.mainContrastColor, this.taskTextOutsideColor = this.taskTextLightColor, this.gridColor = this.mainContrastColor, this.doneTaskBkgColor = this.mainContrastColor, this.taskTextDarkColor = this.darkTextColor, this.archEdgeColor = this.lineColor, this.archEdgeArrowColor = this.lineColor, this.transitionColor = this.transitionColor || this.lineColor, this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || "#555", this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.compositeBorder = this.compositeBorder || this.nodeBorder, this.innerEndBackground = this.primaryBorderColor, this.specialStateColor = "#f4f4f4", this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.fillType0 = this.primaryColor, this.fillType1 = this.secondaryColor, this.fillType2 = st(this.primaryColor, { h: 64 }), this.fillType3 = st(this.secondaryColor, { h: 64 }), this.fillType4 = st(this.primaryColor, { h: -64 }), this.fillType5 = st(this.secondaryColor, { h: -64 }), this.fillType6 = st(this.primaryColor, { h: 128 }), this.fillType7 = st(this.secondaryColor, { h: 128 }), this.cScale1 = this.cScale1 || "#0b0000", this.cScale2 = this.cScale2 || "#4d1037", this.cScale3 = this.cScale3 || "#3f5258", this.cScale4 = this.cScale4 || "#4f2f1b", this.cScale5 = this.cScale5 || "#6e0a0a", this.cScale6 = this.cScale6 || "#3b0048", this.cScale7 = this.cScale7 || "#995a01", this.cScale8 = this.cScale8 || "#154706", this.cScale9 = this.cScale9 || "#161722", this.cScale10 = this.cScale10 || "#00296f", this.cScale11 = this.cScale11 || "#01629c", this.cScale12 = this.cScale12 || "#010029", this.cScale0 = this.cScale0 || this.primaryColor, this.cScale1 = this.cScale1 || this.secondaryColor, this.cScale2 = this.cScale2 || this.tertiaryColor, this.cScale3 = this.cScale3 || st(this.primaryColor, { h: 30 }), this.cScale4 = this.cScale4 || st(this.primaryColor, { h: 60 }), this.cScale5 = this.cScale5 || st(this.primaryColor, { h: 90 }), this.cScale6 = this.cScale6 || st(this.primaryColor, { h: 120 }), this.cScale7 = this.cScale7 || st(this.primaryColor, { h: 150 }), this.cScale8 = this.cScale8 || st(this.primaryColor, { h: 210 }), this.cScale9 = this.cScale9 || st(this.primaryColor, { h: 270 }), this.cScale10 = this.cScale10 || st(this.primaryColor, { h: 300 }), this.cScale11 = this.cScale11 || st(this.primaryColor, { h: 330 });
    for (let k = 0; k < this.THEME_COLOR_LIMIT; k++)
      this["cScaleInv" + k] = this["cScaleInv" + k] || Bt(this["cScale" + k]);
    for (let k = 0; k < this.THEME_COLOR_LIMIT; k++)
      this["cScalePeer" + k] = this["cScalePeer" + k] || Ft(this["cScale" + k], 10);
    for (let k = 0; k < 5; k++)
      this["surface" + k] = this["surface" + k] || st(this.mainBkg, { h: 30, s: -30, l: -(-10 + k * 4) }), this["surfacePeer" + k] = this["surfacePeer" + k] || st(this.mainBkg, { h: 30, s: -30, l: -(-7 + k * 4) });
    this.scaleLabelColor = this.scaleLabelColor || (this.darkMode ? "black" : this.labelTextColor);
    for (let k = 0; k < this.THEME_COLOR_LIMIT; k++)
      this["cScaleLabel" + k] = this["cScaleLabel" + k] || this.scaleLabelColor;
    for (let k = 0; k < this.THEME_COLOR_LIMIT; k++)
      this["pie" + k] = this["cScale" + k];
    this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px", this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black", this.pieOpacity = this.pieOpacity || "0.7", this.quadrant1Fill = this.quadrant1Fill || this.primaryColor, this.quadrant2Fill = this.quadrant2Fill || st(this.primaryColor, { r: 5, g: 5, b: 5 }), this.quadrant3Fill = this.quadrant3Fill || st(this.primaryColor, { r: 10, g: 10, b: 10 }), this.quadrant4Fill = this.quadrant4Fill || st(this.primaryColor, { r: 15, g: 15, b: 15 }), this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor, this.quadrant2TextFill = this.quadrant2TextFill || st(this.primaryTextColor, { r: -5, g: -5, b: -5 }), this.quadrant3TextFill = this.quadrant3TextFill || st(this.primaryTextColor, { r: -10, g: -10, b: -10 }), this.quadrant4TextFill = this.quadrant4TextFill || st(this.primaryTextColor, { r: -15, g: -15, b: -15 }), this.quadrantPointFill = this.quadrantPointFill || Ni(this.quadrant1Fill) ? Ft(this.quadrant1Fill) : zt(this.quadrant1Fill), this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor, this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor, this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor, this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor, this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor, this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor, this.xyChart = {
      backgroundColor: ((t = this.xyChart) == null ? void 0 : t.backgroundColor) || this.background,
      titleColor: ((r = this.xyChart) == null ? void 0 : r.titleColor) || this.primaryTextColor,
      xAxisTitleColor: ((i = this.xyChart) == null ? void 0 : i.xAxisTitleColor) || this.primaryTextColor,
      xAxisLabelColor: ((s = this.xyChart) == null ? void 0 : s.xAxisLabelColor) || this.primaryTextColor,
      xAxisTickColor: ((a = this.xyChart) == null ? void 0 : a.xAxisTickColor) || this.primaryTextColor,
      xAxisLineColor: ((n = this.xyChart) == null ? void 0 : n.xAxisLineColor) || this.primaryTextColor,
      yAxisTitleColor: ((o = this.xyChart) == null ? void 0 : o.yAxisTitleColor) || this.primaryTextColor,
      yAxisLabelColor: ((h = this.xyChart) == null ? void 0 : h.yAxisLabelColor) || this.primaryTextColor,
      yAxisTickColor: ((l = this.xyChart) == null ? void 0 : l.yAxisTickColor) || this.primaryTextColor,
      yAxisLineColor: ((d = this.xyChart) == null ? void 0 : d.yAxisLineColor) || this.primaryTextColor,
      plotColorPalette: ((p = this.xyChart) == null ? void 0 : p.plotColorPalette) || "#3498db,#2ecc71,#e74c3c,#f1c40f,#bdc3c7,#ffffff,#34495e,#9b59b6,#1abc9c,#e67e22"
    }, this.packet = {
      startByteColor: this.primaryTextColor,
      endByteColor: this.primaryTextColor,
      labelColor: this.primaryTextColor,
      titleColor: this.primaryTextColor,
      blockStrokeColor: this.primaryTextColor,
      blockFillColor: this.background
    }, this.radar = {
      axisColor: ((g = this.radar) == null ? void 0 : g.axisColor) || this.lineColor,
      axisStrokeWidth: ((f = this.radar) == null ? void 0 : f.axisStrokeWidth) || 2,
      axisLabelFontSize: ((y = this.radar) == null ? void 0 : y.axisLabelFontSize) || 12,
      curveOpacity: ((m = this.radar) == null ? void 0 : m.curveOpacity) || 0.5,
      curveStrokeWidth: ((x = this.radar) == null ? void 0 : x.curveStrokeWidth) || 2,
      graticuleColor: ((b = this.radar) == null ? void 0 : b.graticuleColor) || "#DEDEDE",
      graticuleStrokeWidth: ((v = this.radar) == null ? void 0 : v.graticuleStrokeWidth) || 1,
      graticuleOpacity: ((_ = this.radar) == null ? void 0 : _.graticuleOpacity) || 0.3,
      legendBoxSize: ((A = this.radar) == null ? void 0 : A.legendBoxSize) || 12,
      legendFontSize: ((S = this.radar) == null ? void 0 : S.legendFontSize) || 12
    }, this.classText = this.primaryTextColor, this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || "1", this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || (this.darkMode ? zt(this.secondaryColor, 30) : this.secondaryColor), this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = Ft(this.secondaryColor, 20), this.git1 = Ft(this.pie2 || this.secondaryColor, 20), this.git2 = Ft(this.pie3 || this.tertiaryColor, 20), this.git3 = Ft(this.pie4 || st(this.primaryColor, { h: -30 }), 20), this.git4 = Ft(this.pie5 || st(this.primaryColor, { h: -60 }), 20), this.git5 = Ft(this.pie6 || st(this.primaryColor, { h: -90 }), 10), this.git6 = Ft(this.pie7 || st(this.primaryColor, { h: 60 }), 10), this.git7 = Ft(this.pie8 || st(this.primaryColor, { h: 120 }), 20), this.gitInv0 = this.gitInv0 || Bt(this.git0), this.gitInv1 = this.gitInv1 || Bt(this.git1), this.gitInv2 = this.gitInv2 || Bt(this.git2), this.gitInv3 = this.gitInv3 || Bt(this.git3), this.gitInv4 = this.gitInv4 || Bt(this.git4), this.gitInv5 = this.gitInv5 || Bt(this.git5), this.gitInv6 = this.gitInv6 || Bt(this.git6), this.gitInv7 = this.gitInv7 || Bt(this.git7), this.gitBranchLabel0 = this.gitBranchLabel0 || Bt(this.labelTextColor), this.gitBranchLabel1 = this.gitBranchLabel1 || this.labelTextColor, this.gitBranchLabel2 = this.gitBranchLabel2 || this.labelTextColor, this.gitBranchLabel3 = this.gitBranchLabel3 || Bt(this.labelTextColor), this.gitBranchLabel4 = this.gitBranchLabel4 || this.labelTextColor, this.gitBranchLabel5 = this.gitBranchLabel5 || this.labelTextColor, this.gitBranchLabel6 = this.gitBranchLabel6 || this.labelTextColor, this.gitBranchLabel7 = this.gitBranchLabel7 || this.labelTextColor, this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || Ft(this.background, 12), this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || Ft(this.background, 2), this.nodeBorder = this.nodeBorder || "#999";
  }
  calculate(t) {
    if (typeof t != "object") {
      this.updateColors();
      return;
    }
    const r = Object.keys(t);
    r.forEach((i) => {
      this[i] = t[i];
    }), this.updateColors(), r.forEach((i) => {
      this[i] = t[i];
    });
  }
}, u(Is, "Theme"), Is), gx = /* @__PURE__ */ u((e) => {
  const t = new px();
  return t.calculate(e), t;
}, "getThemeVariables"), Fs, fx = (Fs = class {
  constructor() {
    this.background = "#f4f4f4", this.primaryColor = "#ECECFF", this.secondaryColor = st(this.primaryColor, { h: 120 }), this.secondaryColor = "#ffffde", this.tertiaryColor = st(this.primaryColor, { h: -160 }), this.primaryBorderColor = hr(this.primaryColor, this.darkMode), this.secondaryBorderColor = hr(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = hr(this.tertiaryColor, this.darkMode), this.primaryTextColor = Bt(this.primaryColor), this.secondaryTextColor = Bt(this.secondaryColor), this.tertiaryTextColor = Bt(this.tertiaryColor), this.lineColor = Bt(this.background), this.textColor = Bt(this.background), this.background = "white", this.mainBkg = "#ECECFF", this.secondBkg = "#ffffde", this.lineColor = "#333333", this.border1 = "#9370DB", this.border2 = "#aaaa33", this.arrowheadColor = "#333333", this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif', this.fontSize = "16px", this.labelBackground = "rgba(232,232,232, 0.8)", this.textColor = "#333", this.THEME_COLOR_LIMIT = 12, this.nodeBkg = "calculated", this.nodeBorder = "calculated", this.clusterBkg = "calculated", this.clusterBorder = "calculated", this.defaultLinkColor = "calculated", this.titleColor = "calculated", this.edgeLabelBackground = "calculated", this.actorBorder = "calculated", this.actorBkg = "calculated", this.actorTextColor = "black", this.actorLineColor = "calculated", this.signalColor = "calculated", this.signalTextColor = "calculated", this.labelBoxBkgColor = "calculated", this.labelBoxBorderColor = "calculated", this.labelTextColor = "calculated", this.loopTextColor = "calculated", this.noteBorderColor = "calculated", this.noteBkgColor = "#fff5ad", this.noteTextColor = "calculated", this.activationBorderColor = "#666", this.activationBkgColor = "#f4f4f4", this.sequenceNumberColor = "white", this.sectionBkgColor = "calculated", this.altSectionBkgColor = "calculated", this.sectionBkgColor2 = "calculated", this.excludeBkgColor = "#eeeeee", this.taskBorderColor = "calculated", this.taskBkgColor = "calculated", this.taskTextLightColor = "calculated", this.taskTextColor = this.taskTextLightColor, this.taskTextDarkColor = "calculated", this.taskTextOutsideColor = this.taskTextDarkColor, this.taskTextClickableColor = "calculated", this.activeTaskBorderColor = "calculated", this.activeTaskBkgColor = "calculated", this.gridColor = "calculated", this.doneTaskBkgColor = "calculated", this.doneTaskBorderColor = "calculated", this.critBorderColor = "calculated", this.critBkgColor = "calculated", this.todayLineColor = "calculated", this.vertLineColor = "calculated", this.sectionBkgColor = Zi(102, 102, 255, 0.49), this.altSectionBkgColor = "white", this.sectionBkgColor2 = "#fff400", this.taskBorderColor = "#534fbc", this.taskBkgColor = "#8a90dd", this.taskTextLightColor = "white", this.taskTextColor = "calculated", this.taskTextDarkColor = "black", this.taskTextOutsideColor = "calculated", this.taskTextClickableColor = "#003163", this.activeTaskBorderColor = "#534fbc", this.activeTaskBkgColor = "#bfc7ff", this.gridColor = "lightgrey", this.doneTaskBkgColor = "lightgrey", this.doneTaskBorderColor = "grey", this.critBorderColor = "#ff8888", this.critBkgColor = "red", this.todayLineColor = "red", this.vertLineColor = "navy", this.personBorder = this.primaryBorderColor, this.personBkg = this.mainBkg, this.archEdgeColor = "calculated", this.archEdgeArrowColor = "calculated", this.archEdgeWidth = "3", this.archGroupBorderColor = this.primaryBorderColor, this.archGroupBorderWidth = "2px", this.rowOdd = "calculated", this.rowEven = "calculated", this.labelColor = "black", this.errorBkgColor = "#552222", this.errorTextColor = "#552222", this.updateColors();
  }
  updateColors() {
    var t, r, i, s, a, n, o, h, l, d, p, g, f, y, m, x, b, v, _, A, S;
    this.cScale0 = this.cScale0 || this.primaryColor, this.cScale1 = this.cScale1 || this.secondaryColor, this.cScale2 = this.cScale2 || this.tertiaryColor, this.cScale3 = this.cScale3 || st(this.primaryColor, { h: 30 }), this.cScale4 = this.cScale4 || st(this.primaryColor, { h: 60 }), this.cScale5 = this.cScale5 || st(this.primaryColor, { h: 90 }), this.cScale6 = this.cScale6 || st(this.primaryColor, { h: 120 }), this.cScale7 = this.cScale7 || st(this.primaryColor, { h: 150 }), this.cScale8 = this.cScale8 || st(this.primaryColor, { h: 210 }), this.cScale9 = this.cScale9 || st(this.primaryColor, { h: 270 }), this.cScale10 = this.cScale10 || st(this.primaryColor, { h: 300 }), this.cScale11 = this.cScale11 || st(this.primaryColor, { h: 330 }), this.cScalePeer1 = this.cScalePeer1 || zt(this.secondaryColor, 45), this.cScalePeer2 = this.cScalePeer2 || zt(this.tertiaryColor, 40);
    for (let k = 0; k < this.THEME_COLOR_LIMIT; k++)
      this["cScale" + k] = zt(this["cScale" + k], 10), this["cScalePeer" + k] = this["cScalePeer" + k] || zt(this["cScale" + k], 25);
    for (let k = 0; k < this.THEME_COLOR_LIMIT; k++)
      this["cScaleInv" + k] = this["cScaleInv" + k] || st(this["cScale" + k], { h: 180 });
    for (let k = 0; k < 5; k++)
      this["surface" + k] = this["surface" + k] || st(this.mainBkg, { h: 30, l: -(5 + k * 5) }), this["surfacePeer" + k] = this["surfacePeer" + k] || st(this.mainBkg, { h: 30, l: -(7 + k * 5) });
    if (this.scaleLabelColor = this.scaleLabelColor !== "calculated" && this.scaleLabelColor ? this.scaleLabelColor : this.labelTextColor, this.labelTextColor !== "calculated") {
      this.cScaleLabel0 = this.cScaleLabel0 || Bt(this.labelTextColor), this.cScaleLabel3 = this.cScaleLabel3 || Bt(this.labelTextColor);
      for (let k = 0; k < this.THEME_COLOR_LIMIT; k++)
        this["cScaleLabel" + k] = this["cScaleLabel" + k] || this.labelTextColor;
    }
    this.nodeBkg = this.mainBkg, this.nodeBorder = this.border1, this.clusterBkg = this.secondBkg, this.clusterBorder = this.border2, this.defaultLinkColor = this.lineColor, this.titleColor = this.textColor, this.edgeLabelBackground = this.labelBackground, this.actorBorder = Ft(this.border1, 23), this.actorBkg = this.mainBkg, this.labelBoxBkgColor = this.actorBkg, this.signalColor = this.textColor, this.signalTextColor = this.textColor, this.labelBoxBorderColor = this.actorBorder, this.labelTextColor = this.actorTextColor, this.loopTextColor = this.actorTextColor, this.noteBorderColor = this.border2, this.noteTextColor = this.actorTextColor, this.actorLineColor = this.actorBorder, this.taskTextColor = this.taskTextLightColor, this.taskTextOutsideColor = this.taskTextDarkColor, this.archEdgeColor = this.lineColor, this.archEdgeArrowColor = this.lineColor, this.rowOdd = this.rowOdd || Ft(this.primaryColor, 75) || "#ffffff", this.rowEven = this.rowEven || Ft(this.primaryColor, 1), this.transitionColor = this.transitionColor || this.lineColor, this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || "#f0f0f0", this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.compositeBorder = this.compositeBorder || this.nodeBorder, this.innerEndBackground = this.nodeBorder, this.specialStateColor = this.lineColor, this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.transitionColor = this.transitionColor || this.lineColor, this.classText = this.primaryTextColor, this.fillType0 = this.primaryColor, this.fillType1 = this.secondaryColor, this.fillType2 = st(this.primaryColor, { h: 64 }), this.fillType3 = st(this.secondaryColor, { h: 64 }), this.fillType4 = st(this.primaryColor, { h: -64 }), this.fillType5 = st(this.secondaryColor, { h: -64 }), this.fillType6 = st(this.primaryColor, { h: 128 }), this.fillType7 = st(this.secondaryColor, { h: 128 }), this.pie1 = this.pie1 || this.primaryColor, this.pie2 = this.pie2 || this.secondaryColor, this.pie3 = this.pie3 || st(this.tertiaryColor, { l: -40 }), this.pie4 = this.pie4 || st(this.primaryColor, { l: -10 }), this.pie5 = this.pie5 || st(this.secondaryColor, { l: -30 }), this.pie6 = this.pie6 || st(this.tertiaryColor, { l: -20 }), this.pie7 = this.pie7 || st(this.primaryColor, { h: 60, l: -20 }), this.pie8 = this.pie8 || st(this.primaryColor, { h: -60, l: -40 }), this.pie9 = this.pie9 || st(this.primaryColor, { h: 120, l: -40 }), this.pie10 = this.pie10 || st(this.primaryColor, { h: 60, l: -40 }), this.pie11 = this.pie11 || st(this.primaryColor, { h: -90, l: -40 }), this.pie12 = this.pie12 || st(this.primaryColor, { h: 120, l: -30 }), this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px", this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black", this.pieOpacity = this.pieOpacity || "0.7", this.quadrant1Fill = this.quadrant1Fill || this.primaryColor, this.quadrant2Fill = this.quadrant2Fill || st(this.primaryColor, { r: 5, g: 5, b: 5 }), this.quadrant3Fill = this.quadrant3Fill || st(this.primaryColor, { r: 10, g: 10, b: 10 }), this.quadrant4Fill = this.quadrant4Fill || st(this.primaryColor, { r: 15, g: 15, b: 15 }), this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor, this.quadrant2TextFill = this.quadrant2TextFill || st(this.primaryTextColor, { r: -5, g: -5, b: -5 }), this.quadrant3TextFill = this.quadrant3TextFill || st(this.primaryTextColor, { r: -10, g: -10, b: -10 }), this.quadrant4TextFill = this.quadrant4TextFill || st(this.primaryTextColor, { r: -15, g: -15, b: -15 }), this.quadrantPointFill = this.quadrantPointFill || Ni(this.quadrant1Fill) ? Ft(this.quadrant1Fill) : zt(this.quadrant1Fill), this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor, this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor, this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor, this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor, this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor, this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor, this.radar = {
      axisColor: ((t = this.radar) == null ? void 0 : t.axisColor) || this.lineColor,
      axisStrokeWidth: ((r = this.radar) == null ? void 0 : r.axisStrokeWidth) || 2,
      axisLabelFontSize: ((i = this.radar) == null ? void 0 : i.axisLabelFontSize) || 12,
      curveOpacity: ((s = this.radar) == null ? void 0 : s.curveOpacity) || 0.5,
      curveStrokeWidth: ((a = this.radar) == null ? void 0 : a.curveStrokeWidth) || 2,
      graticuleColor: ((n = this.radar) == null ? void 0 : n.graticuleColor) || "#DEDEDE",
      graticuleStrokeWidth: ((o = this.radar) == null ? void 0 : o.graticuleStrokeWidth) || 1,
      graticuleOpacity: ((h = this.radar) == null ? void 0 : h.graticuleOpacity) || 0.3,
      legendBoxSize: ((l = this.radar) == null ? void 0 : l.legendBoxSize) || 12,
      legendFontSize: ((d = this.radar) == null ? void 0 : d.legendFontSize) || 12
    }, this.xyChart = {
      backgroundColor: ((p = this.xyChart) == null ? void 0 : p.backgroundColor) || this.background,
      titleColor: ((g = this.xyChart) == null ? void 0 : g.titleColor) || this.primaryTextColor,
      xAxisTitleColor: ((f = this.xyChart) == null ? void 0 : f.xAxisTitleColor) || this.primaryTextColor,
      xAxisLabelColor: ((y = this.xyChart) == null ? void 0 : y.xAxisLabelColor) || this.primaryTextColor,
      xAxisTickColor: ((m = this.xyChart) == null ? void 0 : m.xAxisTickColor) || this.primaryTextColor,
      xAxisLineColor: ((x = this.xyChart) == null ? void 0 : x.xAxisLineColor) || this.primaryTextColor,
      yAxisTitleColor: ((b = this.xyChart) == null ? void 0 : b.yAxisTitleColor) || this.primaryTextColor,
      yAxisLabelColor: ((v = this.xyChart) == null ? void 0 : v.yAxisLabelColor) || this.primaryTextColor,
      yAxisTickColor: ((_ = this.xyChart) == null ? void 0 : _.yAxisTickColor) || this.primaryTextColor,
      yAxisLineColor: ((A = this.xyChart) == null ? void 0 : A.yAxisLineColor) || this.primaryTextColor,
      plotColorPalette: ((S = this.xyChart) == null ? void 0 : S.plotColorPalette) || "#ECECFF,#8493A6,#FFC3A0,#DCDDE1,#B8E994,#D1A36F,#C3CDE6,#FFB6C1,#496078,#F8F3E3"
    }, this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || "1", this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || this.labelBackground, this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = this.git0 || this.primaryColor, this.git1 = this.git1 || this.secondaryColor, this.git2 = this.git2 || this.tertiaryColor, this.git3 = this.git3 || st(this.primaryColor, { h: -30 }), this.git4 = this.git4 || st(this.primaryColor, { h: -60 }), this.git5 = this.git5 || st(this.primaryColor, { h: -90 }), this.git6 = this.git6 || st(this.primaryColor, { h: 60 }), this.git7 = this.git7 || st(this.primaryColor, { h: 120 }), this.darkMode ? (this.git0 = Ft(this.git0, 25), this.git1 = Ft(this.git1, 25), this.git2 = Ft(this.git2, 25), this.git3 = Ft(this.git3, 25), this.git4 = Ft(this.git4, 25), this.git5 = Ft(this.git5, 25), this.git6 = Ft(this.git6, 25), this.git7 = Ft(this.git7, 25)) : (this.git0 = zt(this.git0, 25), this.git1 = zt(this.git1, 25), this.git2 = zt(this.git2, 25), this.git3 = zt(this.git3, 25), this.git4 = zt(this.git4, 25), this.git5 = zt(this.git5, 25), this.git6 = zt(this.git6, 25), this.git7 = zt(this.git7, 25)), this.gitInv0 = this.gitInv0 || zt(Bt(this.git0), 25), this.gitInv1 = this.gitInv1 || Bt(this.git1), this.gitInv2 = this.gitInv2 || Bt(this.git2), this.gitInv3 = this.gitInv3 || Bt(this.git3), this.gitInv4 = this.gitInv4 || Bt(this.git4), this.gitInv5 = this.gitInv5 || Bt(this.git5), this.gitInv6 = this.gitInv6 || Bt(this.git6), this.gitInv7 = this.gitInv7 || Bt(this.git7), this.gitBranchLabel0 = this.gitBranchLabel0 || Bt(this.labelTextColor), this.gitBranchLabel1 = this.gitBranchLabel1 || this.labelTextColor, this.gitBranchLabel2 = this.gitBranchLabel2 || this.labelTextColor, this.gitBranchLabel3 = this.gitBranchLabel3 || Bt(this.labelTextColor), this.gitBranchLabel4 = this.gitBranchLabel4 || this.labelTextColor, this.gitBranchLabel5 = this.gitBranchLabel5 || this.labelTextColor, this.gitBranchLabel6 = this.gitBranchLabel6 || this.labelTextColor, this.gitBranchLabel7 = this.gitBranchLabel7 || this.labelTextColor, this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || wo, this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || To;
  }
  calculate(t) {
    if (Object.keys(this).forEach((i) => {
      this[i] === "calculated" && (this[i] = void 0);
    }), typeof t != "object") {
      this.updateColors();
      return;
    }
    const r = Object.keys(t);
    r.forEach((i) => {
      this[i] = t[i];
    }), this.updateColors(), r.forEach((i) => {
      this[i] = t[i];
    });
  }
}, u(Fs, "Theme"), Fs), _o = /* @__PURE__ */ u((e) => {
  const t = new fx();
  return t.calculate(e), t;
}, "getThemeVariables"), Ns, yx = (Ns = class {
  constructor() {
    this.background = "#f4f4f4", this.primaryColor = "#cde498", this.secondaryColor = "#cdffb2", this.background = "white", this.mainBkg = "#cde498", this.secondBkg = "#cdffb2", this.lineColor = "green", this.border1 = "#13540c", this.border2 = "#6eaa49", this.arrowheadColor = "green", this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif', this.fontSize = "16px", this.tertiaryColor = Ft("#cde498", 10), this.primaryBorderColor = hr(this.primaryColor, this.darkMode), this.secondaryBorderColor = hr(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = hr(this.tertiaryColor, this.darkMode), this.primaryTextColor = Bt(this.primaryColor), this.secondaryTextColor = Bt(this.secondaryColor), this.tertiaryTextColor = Bt(this.primaryColor), this.lineColor = Bt(this.background), this.textColor = Bt(this.background), this.THEME_COLOR_LIMIT = 12, this.nodeBkg = "calculated", this.nodeBorder = "calculated", this.clusterBkg = "calculated", this.clusterBorder = "calculated", this.defaultLinkColor = "calculated", this.titleColor = "#333", this.edgeLabelBackground = "#e8e8e8", this.actorBorder = "calculated", this.actorBkg = "calculated", this.actorTextColor = "black", this.actorLineColor = "calculated", this.signalColor = "#333", this.signalTextColor = "#333", this.labelBoxBkgColor = "calculated", this.labelBoxBorderColor = "#326932", this.labelTextColor = "calculated", this.loopTextColor = "calculated", this.noteBorderColor = "calculated", this.noteBkgColor = "#fff5ad", this.noteTextColor = "calculated", this.activationBorderColor = "#666", this.activationBkgColor = "#f4f4f4", this.sequenceNumberColor = "white", this.sectionBkgColor = "#6eaa49", this.altSectionBkgColor = "white", this.sectionBkgColor2 = "#6eaa49", this.excludeBkgColor = "#eeeeee", this.taskBorderColor = "calculated", this.taskBkgColor = "#487e3a", this.taskTextLightColor = "white", this.taskTextColor = "calculated", this.taskTextDarkColor = "black", this.taskTextOutsideColor = "calculated", this.taskTextClickableColor = "#003163", this.activeTaskBorderColor = "calculated", this.activeTaskBkgColor = "calculated", this.gridColor = "lightgrey", this.doneTaskBkgColor = "lightgrey", this.doneTaskBorderColor = "grey", this.critBorderColor = "#ff8888", this.critBkgColor = "red", this.todayLineColor = "red", this.vertLineColor = "#00BFFF", this.personBorder = this.primaryBorderColor, this.personBkg = this.mainBkg, this.archEdgeColor = "calculated", this.archEdgeArrowColor = "calculated", this.archEdgeWidth = "3", this.archGroupBorderColor = this.primaryBorderColor, this.archGroupBorderWidth = "2px", this.labelColor = "black", this.errorBkgColor = "#552222", this.errorTextColor = "#552222";
  }
  updateColors() {
    var t, r, i, s, a, n, o, h, l, d, p, g, f, y, m, x, b, v, _, A, S;
    this.actorBorder = zt(this.mainBkg, 20), this.actorBkg = this.mainBkg, this.labelBoxBkgColor = this.actorBkg, this.labelTextColor = this.actorTextColor, this.loopTextColor = this.actorTextColor, this.noteBorderColor = this.border2, this.noteTextColor = this.actorTextColor, this.actorLineColor = this.actorBorder, this.cScale0 = this.cScale0 || this.primaryColor, this.cScale1 = this.cScale1 || this.secondaryColor, this.cScale2 = this.cScale2 || this.tertiaryColor, this.cScale3 = this.cScale3 || st(this.primaryColor, { h: 30 }), this.cScale4 = this.cScale4 || st(this.primaryColor, { h: 60 }), this.cScale5 = this.cScale5 || st(this.primaryColor, { h: 90 }), this.cScale6 = this.cScale6 || st(this.primaryColor, { h: 120 }), this.cScale7 = this.cScale7 || st(this.primaryColor, { h: 150 }), this.cScale8 = this.cScale8 || st(this.primaryColor, { h: 210 }), this.cScale9 = this.cScale9 || st(this.primaryColor, { h: 270 }), this.cScale10 = this.cScale10 || st(this.primaryColor, { h: 300 }), this.cScale11 = this.cScale11 || st(this.primaryColor, { h: 330 }), this.cScalePeer1 = this.cScalePeer1 || zt(this.secondaryColor, 45), this.cScalePeer2 = this.cScalePeer2 || zt(this.tertiaryColor, 40);
    for (let k = 0; k < this.THEME_COLOR_LIMIT; k++)
      this["cScale" + k] = zt(this["cScale" + k], 10), this["cScalePeer" + k] = this["cScalePeer" + k] || zt(this["cScale" + k], 25);
    for (let k = 0; k < this.THEME_COLOR_LIMIT; k++)
      this["cScaleInv" + k] = this["cScaleInv" + k] || st(this["cScale" + k], { h: 180 });
    this.scaleLabelColor = this.scaleLabelColor !== "calculated" && this.scaleLabelColor ? this.scaleLabelColor : this.labelTextColor;
    for (let k = 0; k < this.THEME_COLOR_LIMIT; k++)
      this["cScaleLabel" + k] = this["cScaleLabel" + k] || this.scaleLabelColor;
    for (let k = 0; k < 5; k++)
      this["surface" + k] = this["surface" + k] || st(this.mainBkg, { h: 30, s: -30, l: -(5 + k * 5) }), this["surfacePeer" + k] = this["surfacePeer" + k] || st(this.mainBkg, { h: 30, s: -30, l: -(8 + k * 5) });
    this.nodeBkg = this.mainBkg, this.nodeBorder = this.border1, this.clusterBkg = this.secondBkg, this.clusterBorder = this.border2, this.defaultLinkColor = this.lineColor, this.taskBorderColor = this.border1, this.taskTextColor = this.taskTextLightColor, this.taskTextOutsideColor = this.taskTextDarkColor, this.activeTaskBorderColor = this.taskBorderColor, this.activeTaskBkgColor = this.mainBkg, this.archEdgeColor = this.lineColor, this.archEdgeArrowColor = this.lineColor, this.rowOdd = this.rowOdd || Ft(this.mainBkg, 75) || "#ffffff", this.rowEven = this.rowEven || Ft(this.mainBkg, 20), this.transitionColor = this.transitionColor || this.lineColor, this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || "#f0f0f0", this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.compositeBorder = this.compositeBorder || this.nodeBorder, this.innerEndBackground = this.primaryBorderColor, this.specialStateColor = this.lineColor, this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.transitionColor = this.transitionColor || this.lineColor, this.classText = this.primaryTextColor, this.fillType0 = this.primaryColor, this.fillType1 = this.secondaryColor, this.fillType2 = st(this.primaryColor, { h: 64 }), this.fillType3 = st(this.secondaryColor, { h: 64 }), this.fillType4 = st(this.primaryColor, { h: -64 }), this.fillType5 = st(this.secondaryColor, { h: -64 }), this.fillType6 = st(this.primaryColor, { h: 128 }), this.fillType7 = st(this.secondaryColor, { h: 128 }), this.pie1 = this.pie1 || this.primaryColor, this.pie2 = this.pie2 || this.secondaryColor, this.pie3 = this.pie3 || this.tertiaryColor, this.pie4 = this.pie4 || st(this.primaryColor, { l: -30 }), this.pie5 = this.pie5 || st(this.secondaryColor, { l: -30 }), this.pie6 = this.pie6 || st(this.tertiaryColor, { h: 40, l: -40 }), this.pie7 = this.pie7 || st(this.primaryColor, { h: 60, l: -10 }), this.pie8 = this.pie8 || st(this.primaryColor, { h: -60, l: -10 }), this.pie9 = this.pie9 || st(this.primaryColor, { h: 120, l: 0 }), this.pie10 = this.pie10 || st(this.primaryColor, { h: 60, l: -50 }), this.pie11 = this.pie11 || st(this.primaryColor, { h: -60, l: -50 }), this.pie12 = this.pie12 || st(this.primaryColor, { h: 120, l: -50 }), this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px", this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black", this.pieOpacity = this.pieOpacity || "0.7", this.quadrant1Fill = this.quadrant1Fill || this.primaryColor, this.quadrant2Fill = this.quadrant2Fill || st(this.primaryColor, { r: 5, g: 5, b: 5 }), this.quadrant3Fill = this.quadrant3Fill || st(this.primaryColor, { r: 10, g: 10, b: 10 }), this.quadrant4Fill = this.quadrant4Fill || st(this.primaryColor, { r: 15, g: 15, b: 15 }), this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor, this.quadrant2TextFill = this.quadrant2TextFill || st(this.primaryTextColor, { r: -5, g: -5, b: -5 }), this.quadrant3TextFill = this.quadrant3TextFill || st(this.primaryTextColor, { r: -10, g: -10, b: -10 }), this.quadrant4TextFill = this.quadrant4TextFill || st(this.primaryTextColor, { r: -15, g: -15, b: -15 }), this.quadrantPointFill = this.quadrantPointFill || Ni(this.quadrant1Fill) ? Ft(this.quadrant1Fill) : zt(this.quadrant1Fill), this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor, this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor, this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor, this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor, this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor, this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor, this.packet = {
      startByteColor: this.primaryTextColor,
      endByteColor: this.primaryTextColor,
      labelColor: this.primaryTextColor,
      titleColor: this.primaryTextColor,
      blockStrokeColor: this.primaryTextColor,
      blockFillColor: this.mainBkg
    }, this.radar = {
      axisColor: ((t = this.radar) == null ? void 0 : t.axisColor) || this.lineColor,
      axisStrokeWidth: ((r = this.radar) == null ? void 0 : r.axisStrokeWidth) || 2,
      axisLabelFontSize: ((i = this.radar) == null ? void 0 : i.axisLabelFontSize) || 12,
      curveOpacity: ((s = this.radar) == null ? void 0 : s.curveOpacity) || 0.5,
      curveStrokeWidth: ((a = this.radar) == null ? void 0 : a.curveStrokeWidth) || 2,
      graticuleColor: ((n = this.radar) == null ? void 0 : n.graticuleColor) || "#DEDEDE",
      graticuleStrokeWidth: ((o = this.radar) == null ? void 0 : o.graticuleStrokeWidth) || 1,
      graticuleOpacity: ((h = this.radar) == null ? void 0 : h.graticuleOpacity) || 0.3,
      legendBoxSize: ((l = this.radar) == null ? void 0 : l.legendBoxSize) || 12,
      legendFontSize: ((d = this.radar) == null ? void 0 : d.legendFontSize) || 12
    }, this.xyChart = {
      backgroundColor: ((p = this.xyChart) == null ? void 0 : p.backgroundColor) || this.background,
      titleColor: ((g = this.xyChart) == null ? void 0 : g.titleColor) || this.primaryTextColor,
      xAxisTitleColor: ((f = this.xyChart) == null ? void 0 : f.xAxisTitleColor) || this.primaryTextColor,
      xAxisLabelColor: ((y = this.xyChart) == null ? void 0 : y.xAxisLabelColor) || this.primaryTextColor,
      xAxisTickColor: ((m = this.xyChart) == null ? void 0 : m.xAxisTickColor) || this.primaryTextColor,
      xAxisLineColor: ((x = this.xyChart) == null ? void 0 : x.xAxisLineColor) || this.primaryTextColor,
      yAxisTitleColor: ((b = this.xyChart) == null ? void 0 : b.yAxisTitleColor) || this.primaryTextColor,
      yAxisLabelColor: ((v = this.xyChart) == null ? void 0 : v.yAxisLabelColor) || this.primaryTextColor,
      yAxisTickColor: ((_ = this.xyChart) == null ? void 0 : _.yAxisTickColor) || this.primaryTextColor,
      yAxisLineColor: ((A = this.xyChart) == null ? void 0 : A.yAxisLineColor) || this.primaryTextColor,
      plotColorPalette: ((S = this.xyChart) == null ? void 0 : S.plotColorPalette) || "#CDE498,#FF6B6B,#A0D2DB,#D7BDE2,#F0F0F0,#FFC3A0,#7FD8BE,#FF9A8B,#FAF3E0,#FFF176"
    }, this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || "1", this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || this.edgeLabelBackground, this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = this.git0 || this.primaryColor, this.git1 = this.git1 || this.secondaryColor, this.git2 = this.git2 || this.tertiaryColor, this.git3 = this.git3 || st(this.primaryColor, { h: -30 }), this.git4 = this.git4 || st(this.primaryColor, { h: -60 }), this.git5 = this.git5 || st(this.primaryColor, { h: -90 }), this.git6 = this.git6 || st(this.primaryColor, { h: 60 }), this.git7 = this.git7 || st(this.primaryColor, { h: 120 }), this.darkMode ? (this.git0 = Ft(this.git0, 25), this.git1 = Ft(this.git1, 25), this.git2 = Ft(this.git2, 25), this.git3 = Ft(this.git3, 25), this.git4 = Ft(this.git4, 25), this.git5 = Ft(this.git5, 25), this.git6 = Ft(this.git6, 25), this.git7 = Ft(this.git7, 25)) : (this.git0 = zt(this.git0, 25), this.git1 = zt(this.git1, 25), this.git2 = zt(this.git2, 25), this.git3 = zt(this.git3, 25), this.git4 = zt(this.git4, 25), this.git5 = zt(this.git5, 25), this.git6 = zt(this.git6, 25), this.git7 = zt(this.git7, 25)), this.gitInv0 = this.gitInv0 || Bt(this.git0), this.gitInv1 = this.gitInv1 || Bt(this.git1), this.gitInv2 = this.gitInv2 || Bt(this.git2), this.gitInv3 = this.gitInv3 || Bt(this.git3), this.gitInv4 = this.gitInv4 || Bt(this.git4), this.gitInv5 = this.gitInv5 || Bt(this.git5), this.gitInv6 = this.gitInv6 || Bt(this.git6), this.gitInv7 = this.gitInv7 || Bt(this.git7), this.gitBranchLabel0 = this.gitBranchLabel0 || Bt(this.labelTextColor), this.gitBranchLabel1 = this.gitBranchLabel1 || this.labelTextColor, this.gitBranchLabel2 = this.gitBranchLabel2 || this.labelTextColor, this.gitBranchLabel3 = this.gitBranchLabel3 || Bt(this.labelTextColor), this.gitBranchLabel4 = this.gitBranchLabel4 || this.labelTextColor, this.gitBranchLabel5 = this.gitBranchLabel5 || this.labelTextColor, this.gitBranchLabel6 = this.gitBranchLabel6 || this.labelTextColor, this.gitBranchLabel7 = this.gitBranchLabel7 || this.labelTextColor, this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || wo, this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || To;
  }
  calculate(t) {
    if (typeof t != "object") {
      this.updateColors();
      return;
    }
    const r = Object.keys(t);
    r.forEach((i) => {
      this[i] = t[i];
    }), this.updateColors(), r.forEach((i) => {
      this[i] = t[i];
    });
  }
}, u(Ns, "Theme"), Ns), mx = /* @__PURE__ */ u((e) => {
  const t = new yx();
  return t.calculate(e), t;
}, "getThemeVariables"), Rs, xx = (Rs = class {
  constructor() {
    this.primaryColor = "#eee", this.contrast = "#707070", this.secondaryColor = Ft(this.contrast, 55), this.background = "#ffffff", this.tertiaryColor = st(this.primaryColor, { h: -160 }), this.primaryBorderColor = hr(this.primaryColor, this.darkMode), this.secondaryBorderColor = hr(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = hr(this.tertiaryColor, this.darkMode), this.primaryTextColor = Bt(this.primaryColor), this.secondaryTextColor = Bt(this.secondaryColor), this.tertiaryTextColor = Bt(this.tertiaryColor), this.lineColor = Bt(this.background), this.textColor = Bt(this.background), this.mainBkg = "#eee", this.secondBkg = "calculated", this.lineColor = "#666", this.border1 = "#999", this.border2 = "calculated", this.note = "#ffa", this.text = "#333", this.critical = "#d42", this.done = "#bbb", this.arrowheadColor = "#333333", this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif', this.fontSize = "16px", this.THEME_COLOR_LIMIT = 12, this.nodeBkg = "calculated", this.nodeBorder = "calculated", this.clusterBkg = "calculated", this.clusterBorder = "calculated", this.defaultLinkColor = "calculated", this.titleColor = "calculated", this.edgeLabelBackground = "white", this.actorBorder = "calculated", this.actorBkg = "calculated", this.actorTextColor = "calculated", this.actorLineColor = this.actorBorder, this.signalColor = "calculated", this.signalTextColor = "calculated", this.labelBoxBkgColor = "calculated", this.labelBoxBorderColor = "calculated", this.labelTextColor = "calculated", this.loopTextColor = "calculated", this.noteBorderColor = "calculated", this.noteBkgColor = "calculated", this.noteTextColor = "calculated", this.activationBorderColor = "#666", this.activationBkgColor = "#f4f4f4", this.sequenceNumberColor = "white", this.sectionBkgColor = "calculated", this.altSectionBkgColor = "white", this.sectionBkgColor2 = "calculated", this.excludeBkgColor = "#eeeeee", this.taskBorderColor = "calculated", this.taskBkgColor = "calculated", this.taskTextLightColor = "white", this.taskTextColor = "calculated", this.taskTextDarkColor = "calculated", this.taskTextOutsideColor = "calculated", this.taskTextClickableColor = "#003163", this.activeTaskBorderColor = "calculated", this.activeTaskBkgColor = "calculated", this.gridColor = "calculated", this.doneTaskBkgColor = "calculated", this.doneTaskBorderColor = "calculated", this.critBkgColor = "calculated", this.critBorderColor = "calculated", this.todayLineColor = "calculated", this.vertLineColor = "calculated", this.personBorder = this.primaryBorderColor, this.personBkg = this.mainBkg, this.archEdgeColor = "calculated", this.archEdgeArrowColor = "calculated", this.archEdgeWidth = "3", this.archGroupBorderColor = this.primaryBorderColor, this.archGroupBorderWidth = "2px", this.rowOdd = this.rowOdd || Ft(this.mainBkg, 75) || "#ffffff", this.rowEven = this.rowEven || "#f4f4f4", this.labelColor = "black", this.errorBkgColor = "#552222", this.errorTextColor = "#552222";
  }
  updateColors() {
    var t, r, i, s, a, n, o, h, l, d, p, g, f, y, m, x, b, v, _, A, S;
    this.secondBkg = Ft(this.contrast, 55), this.border2 = this.contrast, this.actorBorder = Ft(this.border1, 23), this.actorBkg = this.mainBkg, this.actorTextColor = this.text, this.actorLineColor = this.actorBorder, this.signalColor = this.text, this.signalTextColor = this.text, this.labelBoxBkgColor = this.actorBkg, this.labelBoxBorderColor = this.actorBorder, this.labelTextColor = this.text, this.loopTextColor = this.text, this.noteBorderColor = "#999", this.noteBkgColor = "#666", this.noteTextColor = "#fff", this.cScale0 = this.cScale0 || "#555", this.cScale1 = this.cScale1 || "#F4F4F4", this.cScale2 = this.cScale2 || "#555", this.cScale3 = this.cScale3 || "#BBB", this.cScale4 = this.cScale4 || "#777", this.cScale5 = this.cScale5 || "#999", this.cScale6 = this.cScale6 || "#DDD", this.cScale7 = this.cScale7 || "#FFF", this.cScale8 = this.cScale8 || "#DDD", this.cScale9 = this.cScale9 || "#BBB", this.cScale10 = this.cScale10 || "#999", this.cScale11 = this.cScale11 || "#777";
    for (let k = 0; k < this.THEME_COLOR_LIMIT; k++)
      this["cScaleInv" + k] = this["cScaleInv" + k] || Bt(this["cScale" + k]);
    for (let k = 0; k < this.THEME_COLOR_LIMIT; k++)
      this.darkMode ? this["cScalePeer" + k] = this["cScalePeer" + k] || Ft(this["cScale" + k], 10) : this["cScalePeer" + k] = this["cScalePeer" + k] || zt(this["cScale" + k], 10);
    this.scaleLabelColor = this.scaleLabelColor || (this.darkMode ? "black" : this.labelTextColor), this.cScaleLabel0 = this.cScaleLabel0 || this.cScale1, this.cScaleLabel2 = this.cScaleLabel2 || this.cScale1;
    for (let k = 0; k < this.THEME_COLOR_LIMIT; k++)
      this["cScaleLabel" + k] = this["cScaleLabel" + k] || this.scaleLabelColor;
    for (let k = 0; k < 5; k++)
      this["surface" + k] = this["surface" + k] || st(this.mainBkg, { l: -(5 + k * 5) }), this["surfacePeer" + k] = this["surfacePeer" + k] || st(this.mainBkg, { l: -(8 + k * 5) });
    this.nodeBkg = this.mainBkg, this.nodeBorder = this.border1, this.clusterBkg = this.secondBkg, this.clusterBorder = this.border2, this.defaultLinkColor = this.lineColor, this.titleColor = this.text, this.sectionBkgColor = Ft(this.contrast, 30), this.sectionBkgColor2 = Ft(this.contrast, 30), this.taskBorderColor = zt(this.contrast, 10), this.taskBkgColor = this.contrast, this.taskTextColor = this.taskTextLightColor, this.taskTextDarkColor = this.text, this.taskTextOutsideColor = this.taskTextDarkColor, this.activeTaskBorderColor = this.taskBorderColor, this.activeTaskBkgColor = this.mainBkg, this.gridColor = Ft(this.border1, 30), this.doneTaskBkgColor = this.done, this.doneTaskBorderColor = this.lineColor, this.critBkgColor = this.critical, this.critBorderColor = zt(this.critBkgColor, 10), this.todayLineColor = this.critBkgColor, this.vertLineColor = this.critBkgColor, this.archEdgeColor = this.lineColor, this.archEdgeArrowColor = this.lineColor, this.transitionColor = this.transitionColor || "#000", this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || "#f4f4f4", this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.stateBorder = this.stateBorder || "#000", this.innerEndBackground = this.primaryBorderColor, this.specialStateColor = "#222", this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.classText = this.primaryTextColor, this.fillType0 = this.primaryColor, this.fillType1 = this.secondaryColor, this.fillType2 = st(this.primaryColor, { h: 64 }), this.fillType3 = st(this.secondaryColor, { h: 64 }), this.fillType4 = st(this.primaryColor, { h: -64 }), this.fillType5 = st(this.secondaryColor, { h: -64 }), this.fillType6 = st(this.primaryColor, { h: 128 }), this.fillType7 = st(this.secondaryColor, { h: 128 });
    for (let k = 0; k < this.THEME_COLOR_LIMIT; k++)
      this["pie" + k] = this["cScale" + k];
    this.pie12 = this.pie0, this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px", this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black", this.pieOpacity = this.pieOpacity || "0.7", this.quadrant1Fill = this.quadrant1Fill || this.primaryColor, this.quadrant2Fill = this.quadrant2Fill || st(this.primaryColor, { r: 5, g: 5, b: 5 }), this.quadrant3Fill = this.quadrant3Fill || st(this.primaryColor, { r: 10, g: 10, b: 10 }), this.quadrant4Fill = this.quadrant4Fill || st(this.primaryColor, { r: 15, g: 15, b: 15 }), this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor, this.quadrant2TextFill = this.quadrant2TextFill || st(this.primaryTextColor, { r: -5, g: -5, b: -5 }), this.quadrant3TextFill = this.quadrant3TextFill || st(this.primaryTextColor, { r: -10, g: -10, b: -10 }), this.quadrant4TextFill = this.quadrant4TextFill || st(this.primaryTextColor, { r: -15, g: -15, b: -15 }), this.quadrantPointFill = this.quadrantPointFill || Ni(this.quadrant1Fill) ? Ft(this.quadrant1Fill) : zt(this.quadrant1Fill), this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor, this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor, this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor, this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor, this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor, this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor, this.xyChart = {
      backgroundColor: ((t = this.xyChart) == null ? void 0 : t.backgroundColor) || this.background,
      titleColor: ((r = this.xyChart) == null ? void 0 : r.titleColor) || this.primaryTextColor,
      xAxisTitleColor: ((i = this.xyChart) == null ? void 0 : i.xAxisTitleColor) || this.primaryTextColor,
      xAxisLabelColor: ((s = this.xyChart) == null ? void 0 : s.xAxisLabelColor) || this.primaryTextColor,
      xAxisTickColor: ((a = this.xyChart) == null ? void 0 : a.xAxisTickColor) || this.primaryTextColor,
      xAxisLineColor: ((n = this.xyChart) == null ? void 0 : n.xAxisLineColor) || this.primaryTextColor,
      yAxisTitleColor: ((o = this.xyChart) == null ? void 0 : o.yAxisTitleColor) || this.primaryTextColor,
      yAxisLabelColor: ((h = this.xyChart) == null ? void 0 : h.yAxisLabelColor) || this.primaryTextColor,
      yAxisTickColor: ((l = this.xyChart) == null ? void 0 : l.yAxisTickColor) || this.primaryTextColor,
      yAxisLineColor: ((d = this.xyChart) == null ? void 0 : d.yAxisLineColor) || this.primaryTextColor,
      plotColorPalette: ((p = this.xyChart) == null ? void 0 : p.plotColorPalette) || "#EEE,#6BB8E4,#8ACB88,#C7ACD6,#E8DCC2,#FFB2A8,#FFF380,#7E8D91,#FFD8B1,#FAF3E0"
    }, this.radar = {
      axisColor: ((g = this.radar) == null ? void 0 : g.axisColor) || this.lineColor,
      axisStrokeWidth: ((f = this.radar) == null ? void 0 : f.axisStrokeWidth) || 2,
      axisLabelFontSize: ((y = this.radar) == null ? void 0 : y.axisLabelFontSize) || 12,
      curveOpacity: ((m = this.radar) == null ? void 0 : m.curveOpacity) || 0.5,
      curveStrokeWidth: ((x = this.radar) == null ? void 0 : x.curveStrokeWidth) || 2,
      graticuleColor: ((b = this.radar) == null ? void 0 : b.graticuleColor) || "#DEDEDE",
      graticuleStrokeWidth: ((v = this.radar) == null ? void 0 : v.graticuleStrokeWidth) || 1,
      graticuleOpacity: ((_ = this.radar) == null ? void 0 : _.graticuleOpacity) || 0.3,
      legendBoxSize: ((A = this.radar) == null ? void 0 : A.legendBoxSize) || 12,
      legendFontSize: ((S = this.radar) == null ? void 0 : S.legendFontSize) || 12
    }, this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || "1", this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || this.edgeLabelBackground, this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = zt(this.pie1, 25) || this.primaryColor, this.git1 = this.pie2 || this.secondaryColor, this.git2 = this.pie3 || this.tertiaryColor, this.git3 = this.pie4 || st(this.primaryColor, { h: -30 }), this.git4 = this.pie5 || st(this.primaryColor, { h: -60 }), this.git5 = this.pie6 || st(this.primaryColor, { h: -90 }), this.git6 = this.pie7 || st(this.primaryColor, { h: 60 }), this.git7 = this.pie8 || st(this.primaryColor, { h: 120 }), this.gitInv0 = this.gitInv0 || Bt(this.git0), this.gitInv1 = this.gitInv1 || Bt(this.git1), this.gitInv2 = this.gitInv2 || Bt(this.git2), this.gitInv3 = this.gitInv3 || Bt(this.git3), this.gitInv4 = this.gitInv4 || Bt(this.git4), this.gitInv5 = this.gitInv5 || Bt(this.git5), this.gitInv6 = this.gitInv6 || Bt(this.git6), this.gitInv7 = this.gitInv7 || Bt(this.git7), this.branchLabelColor = this.branchLabelColor || this.labelTextColor, this.gitBranchLabel0 = this.branchLabelColor, this.gitBranchLabel1 = "white", this.gitBranchLabel2 = this.branchLabelColor, this.gitBranchLabel3 = "white", this.gitBranchLabel4 = this.branchLabelColor, this.gitBranchLabel5 = this.branchLabelColor, this.gitBranchLabel6 = this.branchLabelColor, this.gitBranchLabel7 = this.branchLabelColor, this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || wo, this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || To;
  }
  calculate(t) {
    if (typeof t != "object") {
      this.updateColors();
      return;
    }
    const r = Object.keys(t);
    r.forEach((i) => {
      this[i] = t[i];
    }), this.updateColors(), r.forEach((i) => {
      this[i] = t[i];
    });
  }
}, u(Rs, "Theme"), Rs), bx = /* @__PURE__ */ u((e) => {
  const t = new xx();
  return t.calculate(e), t;
}, "getThemeVariables"), yi = {
  base: {
    getThemeVariables: dx
  },
  dark: {
    getThemeVariables: gx
  },
  default: {
    getThemeVariables: _o
  },
  forest: {
    getThemeVariables: mx
  },
  neutral: {
    getThemeVariables: bx
  }
}, Yr = {
  flowchart: {
    useMaxWidth: !0,
    titleTopMargin: 25,
    subGraphTitleMargin: {
      top: 0,
      bottom: 0
    },
    diagramPadding: 8,
    htmlLabels: !0,
    nodeSpacing: 50,
    rankSpacing: 50,
    curve: "basis",
    padding: 15,
    defaultRenderer: "dagre-wrapper",
    wrappingWidth: 200,
    inheritDir: !1
  },
  sequence: {
    useMaxWidth: !0,
    hideUnusedParticipants: !1,
    activationWidth: 10,
    diagramMarginX: 50,
    diagramMarginY: 10,
    actorMargin: 50,
    width: 150,
    height: 65,
    boxMargin: 10,
    boxTextMargin: 5,
    noteMargin: 10,
    messageMargin: 35,
    messageAlign: "center",
    mirrorActors: !0,
    forceMenus: !1,
    bottomMarginAdj: 1,
    rightAngles: !1,
    showSequenceNumbers: !1,
    actorFontSize: 14,
    actorFontFamily: '"Open Sans", sans-serif',
    actorFontWeight: 400,
    noteFontSize: 14,
    noteFontFamily: '"trebuchet ms", verdana, arial, sans-serif',
    noteFontWeight: 400,
    noteAlign: "center",
    messageFontSize: 16,
    messageFontFamily: '"trebuchet ms", verdana, arial, sans-serif',
    messageFontWeight: 400,
    wrap: !1,
    wrapPadding: 10,
    labelBoxWidth: 50,
    labelBoxHeight: 20
  },
  gantt: {
    useMaxWidth: !0,
    titleTopMargin: 25,
    barHeight: 20,
    barGap: 4,
    topPadding: 50,
    rightPadding: 75,
    leftPadding: 75,
    gridLineStartPadding: 35,
    fontSize: 11,
    sectionFontSize: 11,
    numberSectionStyles: 4,
    axisFormat: "%Y-%m-%d",
    topAxis: !1,
    displayMode: "",
    weekday: "sunday"
  },
  journey: {
    useMaxWidth: !0,
    diagramMarginX: 50,
    diagramMarginY: 10,
    leftMargin: 150,
    maxLabelWidth: 360,
    width: 150,
    height: 50,
    boxMargin: 10,
    boxTextMargin: 5,
    noteMargin: 10,
    messageMargin: 35,
    messageAlign: "center",
    bottomMarginAdj: 1,
    rightAngles: !1,
    taskFontSize: 14,
    taskFontFamily: '"Open Sans", sans-serif',
    taskMargin: 50,
    activationWidth: 10,
    textPlacement: "fo",
    actorColours: [
      "#8FBC8F",
      "#7CFC00",
      "#00FFFF",
      "#20B2AA",
      "#B0E0E6",
      "#FFFFE0"
    ],
    sectionFills: [
      "#191970",
      "#8B008B",
      "#4B0082",
      "#2F4F4F",
      "#800000",
      "#8B4513",
      "#00008B"
    ],
    sectionColours: [
      "#fff"
    ],
    titleColor: "",
    titleFontFamily: '"trebuchet ms", verdana, arial, sans-serif',
    titleFontSize: "4ex"
  },
  class: {
    useMaxWidth: !0,
    titleTopMargin: 25,
    arrowMarkerAbsolute: !1,
    dividerMargin: 10,
    padding: 5,
    textHeight: 10,
    defaultRenderer: "dagre-wrapper",
    htmlLabels: !1,
    hideEmptyMembersBox: !1
  },
  state: {
    useMaxWidth: !0,
    titleTopMargin: 25,
    dividerMargin: 10,
    sizeUnit: 5,
    padding: 8,
    textHeight: 10,
    titleShift: -15,
    noteMargin: 10,
    forkWidth: 70,
    forkHeight: 7,
    miniPadding: 2,
    fontSizeFactor: 5.02,
    fontSize: 24,
    labelHeight: 16,
    edgeLengthFactor: "20",
    compositTitleSize: 35,
    radius: 5,
    defaultRenderer: "dagre-wrapper"
  },
  er: {
    useMaxWidth: !0,
    titleTopMargin: 25,
    diagramPadding: 20,
    layoutDirection: "TB",
    minEntityWidth: 100,
    minEntityHeight: 75,
    entityPadding: 15,
    nodeSpacing: 140,
    rankSpacing: 80,
    stroke: "gray",
    fill: "honeydew",
    fontSize: 12
  },
  pie: {
    useMaxWidth: !0,
    textPosition: 0.75
  },
  quadrantChart: {
    useMaxWidth: !0,
    chartWidth: 500,
    chartHeight: 500,
    titleFontSize: 20,
    titlePadding: 10,
    quadrantPadding: 5,
    xAxisLabelPadding: 5,
    yAxisLabelPadding: 5,
    xAxisLabelFontSize: 16,
    yAxisLabelFontSize: 16,
    quadrantLabelFontSize: 16,
    quadrantTextTopPadding: 5,
    pointTextPadding: 5,
    pointLabelFontSize: 12,
    pointRadius: 5,
    xAxisPosition: "top",
    yAxisPosition: "left",
    quadrantInternalBorderStrokeWidth: 1,
    quadrantExternalBorderStrokeWidth: 2
  },
  xyChart: {
    useMaxWidth: !0,
    width: 700,
    height: 500,
    titleFontSize: 20,
    titlePadding: 10,
    showDataLabel: !1,
    showTitle: !0,
    xAxis: {
      $ref: "#/$defs/XYChartAxisConfig",
      showLabel: !0,
      labelFontSize: 14,
      labelPadding: 5,
      showTitle: !0,
      titleFontSize: 16,
      titlePadding: 5,
      showTick: !0,
      tickLength: 5,
      tickWidth: 2,
      showAxisLine: !0,
      axisLineWidth: 2
    },
    yAxis: {
      $ref: "#/$defs/XYChartAxisConfig",
      showLabel: !0,
      labelFontSize: 14,
      labelPadding: 5,
      showTitle: !0,
      titleFontSize: 16,
      titlePadding: 5,
      showTick: !0,
      tickLength: 5,
      tickWidth: 2,
      showAxisLine: !0,
      axisLineWidth: 2
    },
    chartOrientation: "vertical",
    plotReservedSpacePercent: 50
  },
  requirement: {
    useMaxWidth: !0,
    rect_fill: "#f9f9f9",
    text_color: "#333",
    rect_border_size: "0.5px",
    rect_border_color: "#bbb",
    rect_min_width: 200,
    rect_min_height: 200,
    fontSize: 14,
    rect_padding: 10,
    line_height: 20
  },
  mindmap: {
    useMaxWidth: !0,
    padding: 10,
    maxNodeWidth: 200,
    layoutAlgorithm: "cose-bilkent"
  },
  kanban: {
    useMaxWidth: !0,
    padding: 8,
    sectionWidth: 200,
    ticketBaseUrl: ""
  },
  timeline: {
    useMaxWidth: !0,
    diagramMarginX: 50,
    diagramMarginY: 10,
    leftMargin: 150,
    width: 150,
    height: 50,
    boxMargin: 10,
    boxTextMargin: 5,
    noteMargin: 10,
    messageMargin: 35,
    messageAlign: "center",
    bottomMarginAdj: 1,
    rightAngles: !1,
    taskFontSize: 14,
    taskFontFamily: '"Open Sans", sans-serif',
    taskMargin: 50,
    activationWidth: 10,
    textPlacement: "fo",
    actorColours: [
      "#8FBC8F",
      "#7CFC00",
      "#00FFFF",
      "#20B2AA",
      "#B0E0E6",
      "#FFFFE0"
    ],
    sectionFills: [
      "#191970",
      "#8B008B",
      "#4B0082",
      "#2F4F4F",
      "#800000",
      "#8B4513",
      "#00008B"
    ],
    sectionColours: [
      "#fff"
    ],
    disableMulticolor: !1
  },
  gitGraph: {
    useMaxWidth: !0,
    titleTopMargin: 25,
    diagramPadding: 8,
    nodeLabel: {
      width: 75,
      height: 100,
      x: -25,
      y: 0
    },
    mainBranchName: "main",
    mainBranchOrder: 0,
    showCommitLabel: !0,
    showBranches: !0,
    rotateCommitLabel: !0,
    parallelCommits: !1,
    arrowMarkerAbsolute: !1
  },
  c4: {
    useMaxWidth: !0,
    diagramMarginX: 50,
    diagramMarginY: 10,
    c4ShapeMargin: 50,
    c4ShapePadding: 20,
    width: 216,
    height: 60,
    boxMargin: 10,
    c4ShapeInRow: 4,
    nextLinePaddingX: 0,
    c4BoundaryInRow: 2,
    personFontSize: 14,
    personFontFamily: '"Open Sans", sans-serif',
    personFontWeight: "normal",
    external_personFontSize: 14,
    external_personFontFamily: '"Open Sans", sans-serif',
    external_personFontWeight: "normal",
    systemFontSize: 14,
    systemFontFamily: '"Open Sans", sans-serif',
    systemFontWeight: "normal",
    external_systemFontSize: 14,
    external_systemFontFamily: '"Open Sans", sans-serif',
    external_systemFontWeight: "normal",
    system_dbFontSize: 14,
    system_dbFontFamily: '"Open Sans", sans-serif',
    system_dbFontWeight: "normal",
    external_system_dbFontSize: 14,
    external_system_dbFontFamily: '"Open Sans", sans-serif',
    external_system_dbFontWeight: "normal",
    system_queueFontSize: 14,
    system_queueFontFamily: '"Open Sans", sans-serif',
    system_queueFontWeight: "normal",
    external_system_queueFontSize: 14,
    external_system_queueFontFamily: '"Open Sans", sans-serif',
    external_system_queueFontWeight: "normal",
    boundaryFontSize: 14,
    boundaryFontFamily: '"Open Sans", sans-serif',
    boundaryFontWeight: "normal",
    messageFontSize: 12,
    messageFontFamily: '"Open Sans", sans-serif',
    messageFontWeight: "normal",
    containerFontSize: 14,
    containerFontFamily: '"Open Sans", sans-serif',
    containerFontWeight: "normal",
    external_containerFontSize: 14,
    external_containerFontFamily: '"Open Sans", sans-serif',
    external_containerFontWeight: "normal",
    container_dbFontSize: 14,
    container_dbFontFamily: '"Open Sans", sans-serif',
    container_dbFontWeight: "normal",
    external_container_dbFontSize: 14,
    external_container_dbFontFamily: '"Open Sans", sans-serif',
    external_container_dbFontWeight: "normal",
    container_queueFontSize: 14,
    container_queueFontFamily: '"Open Sans", sans-serif',
    container_queueFontWeight: "normal",
    external_container_queueFontSize: 14,
    external_container_queueFontFamily: '"Open Sans", sans-serif',
    external_container_queueFontWeight: "normal",
    componentFontSize: 14,
    componentFontFamily: '"Open Sans", sans-serif',
    componentFontWeight: "normal",
    external_componentFontSize: 14,
    external_componentFontFamily: '"Open Sans", sans-serif',
    external_componentFontWeight: "normal",
    component_dbFontSize: 14,
    component_dbFontFamily: '"Open Sans", sans-serif',
    component_dbFontWeight: "normal",
    external_component_dbFontSize: 14,
    external_component_dbFontFamily: '"Open Sans", sans-serif',
    external_component_dbFontWeight: "normal",
    component_queueFontSize: 14,
    component_queueFontFamily: '"Open Sans", sans-serif',
    component_queueFontWeight: "normal",
    external_component_queueFontSize: 14,
    external_component_queueFontFamily: '"Open Sans", sans-serif',
    external_component_queueFontWeight: "normal",
    wrap: !0,
    wrapPadding: 10,
    person_bg_color: "#08427B",
    person_border_color: "#073B6F",
    external_person_bg_color: "#686868",
    external_person_border_color: "#8A8A8A",
    system_bg_color: "#1168BD",
    system_border_color: "#3C7FC0",
    system_db_bg_color: "#1168BD",
    system_db_border_color: "#3C7FC0",
    system_queue_bg_color: "#1168BD",
    system_queue_border_color: "#3C7FC0",
    external_system_bg_color: "#999999",
    external_system_border_color: "#8A8A8A",
    external_system_db_bg_color: "#999999",
    external_system_db_border_color: "#8A8A8A",
    external_system_queue_bg_color: "#999999",
    external_system_queue_border_color: "#8A8A8A",
    container_bg_color: "#438DD5",
    container_border_color: "#3C7FC0",
    container_db_bg_color: "#438DD5",
    container_db_border_color: "#3C7FC0",
    container_queue_bg_color: "#438DD5",
    container_queue_border_color: "#3C7FC0",
    external_container_bg_color: "#B3B3B3",
    external_container_border_color: "#A6A6A6",
    external_container_db_bg_color: "#B3B3B3",
    external_container_db_border_color: "#A6A6A6",
    external_container_queue_bg_color: "#B3B3B3",
    external_container_queue_border_color: "#A6A6A6",
    component_bg_color: "#85BBF0",
    component_border_color: "#78A8D8",
    component_db_bg_color: "#85BBF0",
    component_db_border_color: "#78A8D8",
    component_queue_bg_color: "#85BBF0",
    component_queue_border_color: "#78A8D8",
    external_component_bg_color: "#CCCCCC",
    external_component_border_color: "#BFBFBF",
    external_component_db_bg_color: "#CCCCCC",
    external_component_db_border_color: "#BFBFBF",
    external_component_queue_bg_color: "#CCCCCC",
    external_component_queue_border_color: "#BFBFBF"
  },
  sankey: {
    useMaxWidth: !0,
    width: 600,
    height: 400,
    linkColor: "gradient",
    nodeAlignment: "justify",
    showValues: !0,
    prefix: "",
    suffix: ""
  },
  block: {
    useMaxWidth: !0,
    padding: 8
  },
  packet: {
    useMaxWidth: !0,
    rowHeight: 32,
    bitWidth: 32,
    bitsPerRow: 32,
    showBits: !0,
    paddingX: 5,
    paddingY: 5
  },
  architecture: {
    useMaxWidth: !0,
    padding: 40,
    iconSize: 80,
    fontSize: 16
  },
  radar: {
    useMaxWidth: !0,
    width: 600,
    height: 600,
    marginTop: 50,
    marginRight: 50,
    marginBottom: 50,
    marginLeft: 50,
    axisScaleFactor: 1,
    axisLabelFactor: 1.05,
    curveTension: 0.17
  },
  theme: "default",
  look: "classic",
  handDrawnSeed: 0,
  layout: "dagre",
  maxTextSize: 5e4,
  maxEdges: 500,
  darkMode: !1,
  fontFamily: '"trebuchet ms", verdana, arial, sans-serif;',
  logLevel: 5,
  securityLevel: "strict",
  startOnLoad: !0,
  arrowMarkerAbsolute: !1,
  secure: [
    "secure",
    "securityLevel",
    "startOnLoad",
    "maxTextSize",
    "suppressErrorRendering",
    "maxEdges"
  ],
  legacyMathML: !1,
  forceLegacyMathML: !1,
  deterministicIds: !1,
  fontSize: 16,
  markdownAutoWrap: !0,
  suppressErrorRendering: !1
}, Ed = {
  ...Yr,
  // Set, even though they're `undefined` so that `configKeys` finds these keys
  // TODO: Should we replace these with `null` so that they can go in the JSON Schema?
  deterministicIDSeed: void 0,
  elk: {
    // mergeEdges is needed here to be considered
    mergeEdges: !1,
    nodePlacementStrategy: "BRANDES_KOEPF",
    forceNodeModelOrder: !1,
    considerModelOrder: "NODES_AND_EDGES"
  },
  themeCSS: void 0,
  // add non-JSON default config values
  themeVariables: yi.default.getThemeVariables(),
  sequence: {
    ...Yr.sequence,
    messageFont: /* @__PURE__ */ u(function() {
      return {
        fontFamily: this.messageFontFamily,
        fontSize: this.messageFontSize,
        fontWeight: this.messageFontWeight
      };
    }, "messageFont"),
    noteFont: /* @__PURE__ */ u(function() {
      return {
        fontFamily: this.noteFontFamily,
        fontSize: this.noteFontSize,
        fontWeight: this.noteFontWeight
      };
    }, "noteFont"),
    actorFont: /* @__PURE__ */ u(function() {
      return {
        fontFamily: this.actorFontFamily,
        fontSize: this.actorFontSize,
        fontWeight: this.actorFontWeight
      };
    }, "actorFont")
  },
  class: {
    hideEmptyMembersBox: !1
  },
  gantt: {
    ...Yr.gantt,
    tickInterval: void 0,
    useWidth: void 0
    // can probably be removed since `configKeys` already includes this
  },
  c4: {
    ...Yr.c4,
    useWidth: void 0,
    personFont: /* @__PURE__ */ u(function() {
      return {
        fontFamily: this.personFontFamily,
        fontSize: this.personFontSize,
        fontWeight: this.personFontWeight
      };
    }, "personFont"),
    flowchart: {
      ...Yr.flowchart,
      inheritDir: !1
      // default to legacy behavior
    },
    external_personFont: /* @__PURE__ */ u(function() {
      return {
        fontFamily: this.external_personFontFamily,
        fontSize: this.external_personFontSize,
        fontWeight: this.external_personFontWeight
      };
    }, "external_personFont"),
    systemFont: /* @__PURE__ */ u(function() {
      return {
        fontFamily: this.systemFontFamily,
        fontSize: this.systemFontSize,
        fontWeight: this.systemFontWeight
      };
    }, "systemFont"),
    external_systemFont: /* @__PURE__ */ u(function() {
      return {
        fontFamily: this.external_systemFontFamily,
        fontSize: this.external_systemFontSize,
        fontWeight: this.external_systemFontWeight
      };
    }, "external_systemFont"),
    system_dbFont: /* @__PURE__ */ u(function() {
      return {
        fontFamily: this.system_dbFontFamily,
        fontSize: this.system_dbFontSize,
        fontWeight: this.system_dbFontWeight
      };
    }, "system_dbFont"),
    external_system_dbFont: /* @__PURE__ */ u(function() {
      return {
        fontFamily: this.external_system_dbFontFamily,
        fontSize: this.external_system_dbFontSize,
        fontWeight: this.external_system_dbFontWeight
      };
    }, "external_system_dbFont"),
    system_queueFont: /* @__PURE__ */ u(function() {
      return {
        fontFamily: this.system_queueFontFamily,
        fontSize: this.system_queueFontSize,
        fontWeight: this.system_queueFontWeight
      };
    }, "system_queueFont"),
    external_system_queueFont: /* @__PURE__ */ u(function() {
      return {
        fontFamily: this.external_system_queueFontFamily,
        fontSize: this.external_system_queueFontSize,
        fontWeight: this.external_system_queueFontWeight
      };
    }, "external_system_queueFont"),
    containerFont: /* @__PURE__ */ u(function() {
      return {
        fontFamily: this.containerFontFamily,
        fontSize: this.containerFontSize,
        fontWeight: this.containerFontWeight
      };
    }, "containerFont"),
    external_containerFont: /* @__PURE__ */ u(function() {
      return {
        fontFamily: this.external_containerFontFamily,
        fontSize: this.external_containerFontSize,
        fontWeight: this.external_containerFontWeight
      };
    }, "external_containerFont"),
    container_dbFont: /* @__PURE__ */ u(function() {
      return {
        fontFamily: this.container_dbFontFamily,
        fontSize: this.container_dbFontSize,
        fontWeight: this.container_dbFontWeight
      };
    }, "container_dbFont"),
    external_container_dbFont: /* @__PURE__ */ u(function() {
      return {
        fontFamily: this.external_container_dbFontFamily,
        fontSize: this.external_container_dbFontSize,
        fontWeight: this.external_container_dbFontWeight
      };
    }, "external_container_dbFont"),
    container_queueFont: /* @__PURE__ */ u(function() {
      return {
        fontFamily: this.container_queueFontFamily,
        fontSize: this.container_queueFontSize,
        fontWeight: this.container_queueFontWeight
      };
    }, "container_queueFont"),
    external_container_queueFont: /* @__PURE__ */ u(function() {
      return {
        fontFamily: this.external_container_queueFontFamily,
        fontSize: this.external_container_queueFontSize,
        fontWeight: this.external_container_queueFontWeight
      };
    }, "external_container_queueFont"),
    componentFont: /* @__PURE__ */ u(function() {
      return {
        fontFamily: this.componentFontFamily,
        fontSize: this.componentFontSize,
        fontWeight: this.componentFontWeight
      };
    }, "componentFont"),
    external_componentFont: /* @__PURE__ */ u(function() {
      return {
        fontFamily: this.external_componentFontFamily,
        fontSize: this.external_componentFontSize,
        fontWeight: this.external_componentFontWeight
      };
    }, "external_componentFont"),
    component_dbFont: /* @__PURE__ */ u(function() {
      return {
        fontFamily: this.component_dbFontFamily,
        fontSize: this.component_dbFontSize,
        fontWeight: this.component_dbFontWeight
      };
    }, "component_dbFont"),
    external_component_dbFont: /* @__PURE__ */ u(function() {
      return {
        fontFamily: this.external_component_dbFontFamily,
        fontSize: this.external_component_dbFontSize,
        fontWeight: this.external_component_dbFontWeight
      };
    }, "external_component_dbFont"),
    component_queueFont: /* @__PURE__ */ u(function() {
      return {
        fontFamily: this.component_queueFontFamily,
        fontSize: this.component_queueFontSize,
        fontWeight: this.component_queueFontWeight
      };
    }, "component_queueFont"),
    external_component_queueFont: /* @__PURE__ */ u(function() {
      return {
        fontFamily: this.external_component_queueFontFamily,
        fontSize: this.external_component_queueFontSize,
        fontWeight: this.external_component_queueFontWeight
      };
    }, "external_component_queueFont"),
    boundaryFont: /* @__PURE__ */ u(function() {
      return {
        fontFamily: this.boundaryFontFamily,
        fontSize: this.boundaryFontSize,
        fontWeight: this.boundaryFontWeight
      };
    }, "boundaryFont"),
    messageFont: /* @__PURE__ */ u(function() {
      return {
        fontFamily: this.messageFontFamily,
        fontSize: this.messageFontSize,
        fontWeight: this.messageFontWeight
      };
    }, "messageFont")
  },
  pie: {
    ...Yr.pie,
    useWidth: 984
  },
  xyChart: {
    ...Yr.xyChart,
    useWidth: void 0
  },
  requirement: {
    ...Yr.requirement,
    useWidth: void 0
  },
  packet: {
    ...Yr.packet
  },
  radar: {
    ...Yr.radar
  },
  treemap: {
    useMaxWidth: !0,
    padding: 10,
    diagramPadding: 8,
    showValues: !0,
    nodeWidth: 100,
    nodeHeight: 40,
    borderWidth: 1,
    valueFontSize: 12,
    labelFontSize: 14,
    valueFormat: ","
  }
}, Ad = /* @__PURE__ */ u((e, t = "") => Object.keys(e).reduce((r, i) => Array.isArray(e[i]) ? r : typeof e[i] == "object" && e[i] !== null ? [...r, t + i, ...Ad(e[i], "")] : [...r, t + i], []), "keyify"), kx = new Set(Ad(Ed, "")), de = Ed, Wn = /* @__PURE__ */ u((e) => {
  if (I.debug("sanitizeDirective called with", e), !(typeof e != "object" || e == null)) {
    if (Array.isArray(e)) {
      e.forEach((t) => Wn(t));
      return;
    }
    for (const t of Object.keys(e)) {
      if (I.debug("Checking key", t), t.startsWith("__") || t.includes("proto") || t.includes("constr") || !kx.has(t) || e[t] == null) {
        I.debug("sanitize deleting key: ", t), delete e[t];
        continue;
      }
      if (typeof e[t] == "object") {
        I.debug("sanitizing object", t), Wn(e[t]);
        continue;
      }
      const r = ["themeCSS", "fontFamily", "altFontFamily"];
      for (const i of r)
        t.includes(i) && (I.debug("sanitizing css option", t), e[t] = vx(e[t]));
    }
    if (e.themeVariables)
      for (const t of Object.keys(e.themeVariables)) {
        const r = e.themeVariables[t];
        r != null && r.match && !r.match(/^[\d "#%(),.;A-Za-z]+$/) && (e.themeVariables[t] = "");
      }
    I.debug("After sanitization", e);
  }
}, "sanitizeDirective"), vx = /* @__PURE__ */ u((e) => {
  let t = 0, r = 0;
  for (const i of e) {
    if (t < r)
      return "{ /* ERROR: Unbalanced CSS */ }";
    i === "{" ? t++ : i === "}" && r++;
  }
  return t !== r ? "{ /* ERROR: Unbalanced CSS */ }" : e;
}, "sanitizeCss"), pa = Object.freeze(de), mr = De({}, pa), qn, rs = [], Wa = De({}, pa), Eo = /* @__PURE__ */ u((e, t) => {
  let r = De({}, e), i = {};
  for (const s of t)
    Dd(s), i = De(i, s);
  if (r = De(r, i), i.theme && i.theme in yi) {
    const s = De({}, qn), a = De(
      s.themeVariables || {},
      i.themeVariables
    );
    r.theme && r.theme in yi && (r.themeVariables = yi[r.theme].getThemeVariables(a));
  }
  return Wa = r, Id(Wa), Wa;
}, "updateCurrentConfig"), Sx = /* @__PURE__ */ u((e) => (mr = De({}, pa), mr = De(mr, e), e.theme && yi[e.theme] && (mr.themeVariables = yi[e.theme].getThemeVariables(e.themeVariables)), Eo(mr, rs), mr), "setSiteConfig"), Cx = /* @__PURE__ */ u((e) => {
  qn = De({}, e);
}, "saveConfigFromInitialize"), wx = /* @__PURE__ */ u((e) => (mr = De(mr, e), Eo(mr, rs), mr), "updateSiteConfig"), Ld = /* @__PURE__ */ u(() => De({}, mr), "getSiteConfig"), Bd = /* @__PURE__ */ u((e) => (Id(e), De(Wa, e), fe()), "setConfig"), fe = /* @__PURE__ */ u(() => De({}, Wa), "getConfig"), Dd = /* @__PURE__ */ u((e) => {
  e && (["secure", ...mr.secure ?? []].forEach((t) => {
    Object.hasOwn(e, t) && (I.debug(`Denied attempt to modify a secure key ${t}`, e[t]), delete e[t]);
  }), Object.keys(e).forEach((t) => {
    t.startsWith("__") && delete e[t];
  }), Object.keys(e).forEach((t) => {
    typeof e[t] == "string" && (e[t].includes("<") || e[t].includes(">") || e[t].includes("url(data:")) && delete e[t], typeof e[t] == "object" && Dd(e[t]);
  }));
}, "sanitize"), Tx = /* @__PURE__ */ u((e) => {
  var t;
  Wn(e), e.fontFamily && !((t = e.themeVariables) != null && t.fontFamily) && (e.themeVariables = {
    ...e.themeVariables,
    fontFamily: e.fontFamily
  }), rs.push(e), Eo(mr, rs);
}, "addDirective"), Yn = /* @__PURE__ */ u((e = mr) => {
  rs = [], Eo(e, rs);
}, "reset"), _x = {
  LAZY_LOAD_DEPRECATED: "The configuration options lazyLoadedDiagrams and loadExternalDiagramsAtStartup are deprecated. Please use registerExternalDiagrams instead."
}, iu = {}, Ex = /* @__PURE__ */ u((e) => {
  iu[e] || (I.warn(_x[e]), iu[e] = !0);
}, "issueWarning"), Id = /* @__PURE__ */ u((e) => {
  e && (e.lazyLoadedDiagrams || e.loadExternalDiagramsAtStartup) && Ex("LAZY_LOAD_DEPRECATED");
}, "checkConfig"), Ax = /* @__PURE__ */ u(() => {
  let e = {};
  qn && (e = De(e, qn));
  for (const t of rs)
    e = De(e, t);
  return e;
}, "getUserDefinedConfig"), va = /<br\s*\/?>/gi, Lx = /* @__PURE__ */ u((e) => e ? Rd(e).replace(/\\n/g, "#br#").split("#br#") : [""], "getRows"), Bx = /* @__PURE__ */ (() => {
  let e = !1;
  return () => {
    e || (Fd(), e = !0);
  };
})();
function Fd() {
  const e = "data-temp-href-target";
  ua.addHook("beforeSanitizeAttributes", (t) => {
    t.tagName === "A" && t.hasAttribute("target") && t.setAttribute(e, t.getAttribute("target") ?? "");
  }), ua.addHook("afterSanitizeAttributes", (t) => {
    t.tagName === "A" && t.hasAttribute(e) && (t.setAttribute("target", t.getAttribute(e) ?? ""), t.removeAttribute(e), t.getAttribute("target") === "_blank" && t.setAttribute("rel", "noopener"));
  });
}
u(Fd, "setupDompurifyHooks");
var Nd = /* @__PURE__ */ u((e) => (Bx(), ua.sanitize(e)), "removeScript"), su = /* @__PURE__ */ u((e, t) => {
  var r;
  if (((r = t.flowchart) == null ? void 0 : r.htmlLabels) !== !1) {
    const i = t.securityLevel;
    i === "antiscript" || i === "strict" ? e = Nd(e) : i !== "loose" && (e = Rd(e), e = e.replace(/</g, "&lt;").replace(/>/g, "&gt;"), e = e.replace(/=/g, "&equals;"), e = Nx(e));
  }
  return e;
}, "sanitizeMore"), ge = /* @__PURE__ */ u((e, t) => e && (t.dompurifyConfig ? e = ua.sanitize(su(e, t), t.dompurifyConfig).toString() : e = ua.sanitize(su(e, t), {
  FORBID_TAGS: ["style"]
}).toString(), e), "sanitizeText"), Dx = /* @__PURE__ */ u((e, t) => typeof e == "string" ? ge(e, t) : e.flat().map((r) => ge(r, t)), "sanitizeTextOrArray"), Ix = /* @__PURE__ */ u((e) => va.test(e), "hasBreaks"), Fx = /* @__PURE__ */ u((e) => e.split(va), "splitBreaks"), Nx = /* @__PURE__ */ u((e) => e.replace(/#br#/g, "<br/>"), "placeholderToBreak"), Rd = /* @__PURE__ */ u((e) => e.replace(va, "#br#"), "breakToPlaceholder"), Ao = /* @__PURE__ */ u((e) => {
  let t = "";
  return e && (t = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search, t = CSS.escape(t)), t;
}, "getUrl"), ke = /* @__PURE__ */ u((e) => !(e === !1 || ["false", "null", "0"].includes(String(e).trim().toLowerCase())), "evaluate"), Rx = /* @__PURE__ */ u(function(...e) {
  const t = e.filter((r) => !isNaN(r));
  return Math.max(...t);
}, "getMax"), Mx = /* @__PURE__ */ u(function(...e) {
  const t = e.filter((r) => !isNaN(r));
  return Math.min(...t);
}, "getMin"), vi = /* @__PURE__ */ u(function(e) {
  const t = e.split(/(,)/), r = [];
  for (let i = 0; i < t.length; i++) {
    let s = t[i];
    if (s === "," && i > 0 && i + 1 < t.length) {
      const a = t[i - 1], n = t[i + 1];
      Ox(a, n) && (s = a + "," + n, i++, r.pop());
    }
    r.push(Px(s));
  }
  return r.join("");
}, "parseGenericTypes"), fl = /* @__PURE__ */ u((e, t) => Math.max(0, e.split(t).length - 1), "countOccurrence"), Ox = /* @__PURE__ */ u((e, t) => {
  const r = fl(e, "~"), i = fl(t, "~");
  return r === 1 && i === 1;
}, "shouldCombineSets"), Px = /* @__PURE__ */ u((e) => {
  const t = fl(e, "~");
  let r = !1;
  if (t <= 1)
    return e;
  t % 2 !== 0 && e.startsWith("~") && (e = e.substring(1), r = !0);
  const i = [...e];
  let s = i.indexOf("~"), a = i.lastIndexOf("~");
  for (; s !== -1 && a !== -1 && s !== a; )
    i[s] = "<", i[a] = ">", s = i.indexOf("~"), a = i.lastIndexOf("~");
  return r && i.unshift("~"), i.join("");
}, "processSet"), au = /* @__PURE__ */ u(() => window.MathMLElement !== void 0, "isMathMLSupported"), yl = /\$\$(.*)\$\$/g, Ee = /* @__PURE__ */ u((e) => {
  var t;
  return (((t = e.match(yl)) == null ? void 0 : t.length) ?? 0) > 0;
}, "hasKatex"), hn = /* @__PURE__ */ u(async (e, t) => {
  const r = document.createElement("div");
  r.innerHTML = await un(e, t), r.id = "katex-temp", r.style.visibility = "hidden", r.style.position = "absolute", r.style.top = "0";
  const i = document.querySelector("body");
  i == null || i.insertAdjacentElement("beforeend", r);
  const s = { width: r.clientWidth, height: r.clientHeight };
  return r.remove(), s;
}, "calculateMathMLDimensions"), $x = /* @__PURE__ */ u(async (e, t) => {
  if (!Ee(e))
    return e;
  if (!(au() || t.legacyMathML || t.forceLegacyMathML))
    return e.replace(yl, "MathML is unsupported in this environment.");
  {
    const { default: r } = await import("./vendor.js").then((s) => s.bi), i = t.forceLegacyMathML || !au() && t.legacyMathML ? "htmlAndMathml" : "mathml";
    return e.split(va).map(
      (s) => Ee(s) ? `<div style="display: flex; align-items: center; justify-content: center; white-space: nowrap;">${s}</div>` : `<div>${s}</div>`
    ).join("").replace(
      yl,
      (s, a) => r.renderToString(a, {
        throwOnError: !0,
        displayMode: !0,
        output: i
      }).replace(/\n/g, " ").replace(/<annotation.*<\/annotation>/g, "")
    );
  }
}, "renderKatexUnsanitized"), un = /* @__PURE__ */ u(async (e, t) => ge(await $x(e, t), t), "renderKatexSanitized"), St = {
  getRows: Lx,
  sanitizeText: ge,
  sanitizeTextOrArray: Dx,
  hasBreaks: Ix,
  splitBreaks: Fx,
  lineBreakRegex: va,
  removeScript: Nd,
  getUrl: Ao,
  evaluate: ke,
  getMax: Rx,
  getMin: Mx
}, Vx = /* @__PURE__ */ u(function(e, t) {
  for (let r of t)
    e.attr(r[0], r[1]);
}, "d3Attrs"), zx = /* @__PURE__ */ u(function(e, t, r) {
  let i = /* @__PURE__ */ new Map();
  return r ? (i.set("width", "100%"), i.set("style", `max-width: ${t}px;`)) : (i.set("height", e), i.set("width", t)), i;
}, "calculateSvgSizeAttrs"), fr = /* @__PURE__ */ u(function(e, t, r, i) {
  const s = zx(t, r, i);
  Vx(e, s);
}, "configureSvgSize"), dn = /* @__PURE__ */ u(function(e, t, r, i) {
  const s = t.node().getBBox(), a = s.width, n = s.height;
  I.info(`SVG bounds: ${a}x${n}`, s);
  let o = 0, h = 0;
  I.info(`Graph bounds: ${o}x${h}`, e), o = a + r * 2, h = n + r * 2, I.info(`Calculated bounds: ${o}x${h}`), fr(t, h, o, i);
  const l = `${s.x - r} ${s.y - r} ${s.width + 2 * r} ${s.height + 2 * r}`;
  t.attr("viewBox", l);
}, "setupGraphViewbox"), In = {}, Wx = /* @__PURE__ */ u((e, t, r) => {
  let i = "";
  return e in In && In[e] ? i = In[e](r) : I.warn(`No theme found for ${e}`), ` & {
    font-family: ${r.fontFamily};
    font-size: ${r.fontSize};
    fill: ${r.textColor}
  }
  @keyframes edge-animation-frame {
    from {
      stroke-dashoffset: 0;
    }
  }
  @keyframes dash {
    to {
      stroke-dashoffset: 0;
    }
  }
  & .edge-animation-slow {
    stroke-dasharray: 9,5 !important;
    stroke-dashoffset: 900;
    animation: dash 50s linear infinite;
    stroke-linecap: round;
  }
  & .edge-animation-fast {
    stroke-dasharray: 9,5 !important;
    stroke-dashoffset: 900;
    animation: dash 20s linear infinite;
    stroke-linecap: round;
  }
  /* Classes common for multiple diagrams */

  & .error-icon {
    fill: ${r.errorBkgColor};
  }
  & .error-text {
    fill: ${r.errorTextColor};
    stroke: ${r.errorTextColor};
  }

  & .edge-thickness-normal {
    stroke-width: 1px;
  }
  & .edge-thickness-thick {
    stroke-width: 3.5px
  }
  & .edge-pattern-solid {
    stroke-dasharray: 0;
  }
  & .edge-thickness-invisible {
    stroke-width: 0;
    fill: none;
  }
  & .edge-pattern-dashed{
    stroke-dasharray: 3;
  }
  .edge-pattern-dotted {
    stroke-dasharray: 2;
  }

  & .marker {
    fill: ${r.lineColor};
    stroke: ${r.lineColor};
  }
  & .marker.cross {
    stroke: ${r.lineColor};
  }

  & svg {
    font-family: ${r.fontFamily};
    font-size: ${r.fontSize};
  }
   & p {
    margin: 0
   }

  ${i}

  ${t}
`;
}, "getStyles"), qx = /* @__PURE__ */ u((e, t) => {
  t !== void 0 && (In[e] = t);
}, "addStylesForDiagram"), Yx = Wx, Ec = {};
Co(Ec, {
  clear: () => Me,
  getAccDescription: () => He,
  getAccTitle: () => qe,
  getDiagramTitle: () => Oe,
  setAccDescription: () => Ye,
  setAccTitle: () => Re,
  setDiagramTitle: () => Ge
});
var Ac = "", Lc = "", Bc = "", Dc = /* @__PURE__ */ u((e) => ge(e, fe()), "sanitizeText"), Me = /* @__PURE__ */ u(() => {
  Ac = "", Bc = "", Lc = "";
}, "clear"), Re = /* @__PURE__ */ u((e) => {
  Ac = Dc(e).replace(/^\s+/g, "");
}, "setAccTitle"), qe = /* @__PURE__ */ u(() => Ac, "getAccTitle"), Ye = /* @__PURE__ */ u((e) => {
  Bc = Dc(e).replace(/\n\s+/g, `
`);
}, "setAccDescription"), He = /* @__PURE__ */ u(() => Bc, "getAccDescription"), Ge = /* @__PURE__ */ u((e) => {
  Lc = Dc(e);
}, "setDiagramTitle"), Oe = /* @__PURE__ */ u(() => Lc, "getDiagramTitle"), nu = I, Hx = Tc, K = fe, ml = Bd, Md = pa, Ic = /* @__PURE__ */ u((e) => ge(e, K()), "sanitizeText"), Od = dn, Ux = /* @__PURE__ */ u(() => Ec, "getCommonDb"), Hn = {}, Un = /* @__PURE__ */ u((e, t, r) => {
  var i;
  Hn[e] && nu.warn(`Diagram with id ${e} already registered. Overwriting.`), Hn[e] = t, r && _d(e, r), qx(e, t.styles), (i = t.injectUtils) == null || i.call(
    t,
    nu,
    Hx,
    K,
    Ic,
    Od,
    Ux(),
    () => {
    }
  );
}, "registerDiagram"), xl = /* @__PURE__ */ u((e) => {
  if (e in Hn)
    return Hn[e];
  throw new jx(e);
}, "getDiagram"), Ms, jx = (Ms = class extends Error {
  constructor(t) {
    super(`Diagram ${t} not found.`);
  }
}, u(Ms, "DiagramNotFoundError"), Ms), xi = /* @__PURE__ */ u((e) => {
  var s;
  const { securityLevel: t } = K();
  let r = yt("body");
  if (t === "sandbox") {
    const n = ((s = yt(`#i${e}`).node()) == null ? void 0 : s.contentDocument) ?? document;
    r = yt(n.body);
  }
  return r.select(`#${e}`);
}, "selectSvgElement");
function Fc(e) {
  return typeof e > "u" || e === null;
}
u(Fc, "isNothing");
function Pd(e) {
  return typeof e == "object" && e !== null;
}
u(Pd, "isObject");
function $d(e) {
  return Array.isArray(e) ? e : Fc(e) ? [] : [e];
}
u($d, "toArray");
function Vd(e, t) {
  var r, i, s, a;
  if (t)
    for (a = Object.keys(t), r = 0, i = a.length; r < i; r += 1)
      s = a[r], e[s] = t[s];
  return e;
}
u(Vd, "extend");
function zd(e, t) {
  var r = "", i;
  for (i = 0; i < t; i += 1)
    r += e;
  return r;
}
u(zd, "repeat");
function Wd(e) {
  return e === 0 && Number.NEGATIVE_INFINITY === 1 / e;
}
u(Wd, "isNegativeZero");
var Gx = Fc, Xx = Pd, Kx = $d, Qx = zd, Zx = Wd, Jx = Vd, We = {
  isNothing: Gx,
  isObject: Xx,
  toArray: Kx,
  repeat: Qx,
  isNegativeZero: Zx,
  extend: Jx
};
function Nc(e, t) {
  var r = "", i = e.reason || "(unknown reason)";
  return e.mark ? (e.mark.name && (r += 'in "' + e.mark.name + '" '), r += "(" + (e.mark.line + 1) + ":" + (e.mark.column + 1) + ")", !t && e.mark.snippet && (r += `

` + e.mark.snippet), i + " " + r) : i;
}
u(Nc, "formatError");
function ga(e, t) {
  Error.call(this), this.name = "YAMLException", this.reason = e, this.mark = t, this.message = Nc(this, !1), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
}
u(ga, "YAMLException$1");
ga.prototype = Object.create(Error.prototype);
ga.prototype.constructor = ga;
ga.prototype.toString = /* @__PURE__ */ u(function(t) {
  return this.name + ": " + Nc(this, t);
}, "toString");
var xr = ga;
function Fn(e, t, r, i, s) {
  var a = "", n = "", o = Math.floor(s / 2) - 1;
  return i - t > o && (a = " ... ", t = i - o + a.length), r - i > o && (n = " ...", r = i + o - n.length), {
    str: a + e.slice(t, r).replace(/\t/g, "") + n,
    pos: i - t + a.length
    // relative position
  };
}
u(Fn, "getLine");
function Nn(e, t) {
  return We.repeat(" ", t - e.length) + e;
}
u(Nn, "padStart");
function qd(e, t) {
  if (t = Object.create(t || null), !e.buffer) return null;
  t.maxLength || (t.maxLength = 79), typeof t.indent != "number" && (t.indent = 1), typeof t.linesBefore != "number" && (t.linesBefore = 3), typeof t.linesAfter != "number" && (t.linesAfter = 2);
  for (var r = /\r?\n|\r|\0/g, i = [0], s = [], a, n = -1; a = r.exec(e.buffer); )
    s.push(a.index), i.push(a.index + a[0].length), e.position <= a.index && n < 0 && (n = i.length - 2);
  n < 0 && (n = i.length - 1);
  var o = "", h, l, d = Math.min(e.line + t.linesAfter, s.length).toString().length, p = t.maxLength - (t.indent + d + 3);
  for (h = 1; h <= t.linesBefore && !(n - h < 0); h++)
    l = Fn(
      e.buffer,
      i[n - h],
      s[n - h],
      e.position - (i[n] - i[n - h]),
      p
    ), o = We.repeat(" ", t.indent) + Nn((e.line - h + 1).toString(), d) + " | " + l.str + `
` + o;
  for (l = Fn(e.buffer, i[n], s[n], e.position, p), o += We.repeat(" ", t.indent) + Nn((e.line + 1).toString(), d) + " | " + l.str + `
`, o += We.repeat("-", t.indent + d + 3 + l.pos) + `^
`, h = 1; h <= t.linesAfter && !(n + h >= s.length); h++)
    l = Fn(
      e.buffer,
      i[n + h],
      s[n + h],
      e.position - (i[n] - i[n + h]),
      p
    ), o += We.repeat(" ", t.indent) + Nn((e.line + h + 1).toString(), d) + " | " + l.str + `
`;
  return o.replace(/\n$/, "");
}
u(qd, "makeSnippet");
var tb = qd, eb = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
], rb = [
  "scalar",
  "sequence",
  "mapping"
];
function Yd(e) {
  var t = {};
  return e !== null && Object.keys(e).forEach(function(r) {
    e[r].forEach(function(i) {
      t[String(i)] = r;
    });
  }), t;
}
u(Yd, "compileStyleAliases");
function Hd(e, t) {
  if (t = t || {}, Object.keys(t).forEach(function(r) {
    if (eb.indexOf(r) === -1)
      throw new xr('Unknown option "' + r + '" is met in definition of "' + e + '" YAML type.');
  }), this.options = t, this.tag = e, this.kind = t.kind || null, this.resolve = t.resolve || function() {
    return !0;
  }, this.construct = t.construct || function(r) {
    return r;
  }, this.instanceOf = t.instanceOf || null, this.predicate = t.predicate || null, this.represent = t.represent || null, this.representName = t.representName || null, this.defaultStyle = t.defaultStyle || null, this.multi = t.multi || !1, this.styleAliases = Yd(t.styleAliases || null), rb.indexOf(this.kind) === -1)
    throw new xr('Unknown kind "' + this.kind + '" is specified for "' + e + '" YAML type.');
}
u(Hd, "Type$1");
var sr = Hd;
function bl(e, t) {
  var r = [];
  return e[t].forEach(function(i) {
    var s = r.length;
    r.forEach(function(a, n) {
      a.tag === i.tag && a.kind === i.kind && a.multi === i.multi && (s = n);
    }), r[s] = i;
  }), r;
}
u(bl, "compileList");
function Ud() {
  var e = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, t, r;
  function i(s) {
    s.multi ? (e.multi[s.kind].push(s), e.multi.fallback.push(s)) : e[s.kind][s.tag] = e.fallback[s.tag] = s;
  }
  for (u(i, "collectType"), t = 0, r = arguments.length; t < r; t += 1)
    arguments[t].forEach(i);
  return e;
}
u(Ud, "compileMap");
function jn(e) {
  return this.extend(e);
}
u(jn, "Schema$1");
jn.prototype.extend = /* @__PURE__ */ u(function(t) {
  var r = [], i = [];
  if (t instanceof sr)
    i.push(t);
  else if (Array.isArray(t))
    i = i.concat(t);
  else if (t && (Array.isArray(t.implicit) || Array.isArray(t.explicit)))
    t.implicit && (r = r.concat(t.implicit)), t.explicit && (i = i.concat(t.explicit));
  else
    throw new xr("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  r.forEach(function(a) {
    if (!(a instanceof sr))
      throw new xr("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    if (a.loadKind && a.loadKind !== "scalar")
      throw new xr("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    if (a.multi)
      throw new xr("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
  }), i.forEach(function(a) {
    if (!(a instanceof sr))
      throw new xr("Specified list of YAML types (or a single Type object) contains a non-Type object.");
  });
  var s = Object.create(jn.prototype);
  return s.implicit = (this.implicit || []).concat(r), s.explicit = (this.explicit || []).concat(i), s.compiledImplicit = bl(s, "implicit"), s.compiledExplicit = bl(s, "explicit"), s.compiledTypeMap = Ud(s.compiledImplicit, s.compiledExplicit), s;
}, "extend");
var ib = jn, sb = new sr("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: /* @__PURE__ */ u(function(e) {
    return e !== null ? e : "";
  }, "construct")
}), ab = new sr("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: /* @__PURE__ */ u(function(e) {
    return e !== null ? e : [];
  }, "construct")
}), nb = new sr("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: /* @__PURE__ */ u(function(e) {
    return e !== null ? e : {};
  }, "construct")
}), ob = new ib({
  explicit: [
    sb,
    ab,
    nb
  ]
});
function jd(e) {
  if (e === null) return !0;
  var t = e.length;
  return t === 1 && e === "~" || t === 4 && (e === "null" || e === "Null" || e === "NULL");
}
u(jd, "resolveYamlNull");
function Gd() {
  return null;
}
u(Gd, "constructYamlNull");
function Xd(e) {
  return e === null;
}
u(Xd, "isNull");
var lb = new sr("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: jd,
  construct: Gd,
  predicate: Xd,
  represent: {
    canonical: /* @__PURE__ */ u(function() {
      return "~";
    }, "canonical"),
    lowercase: /* @__PURE__ */ u(function() {
      return "null";
    }, "lowercase"),
    uppercase: /* @__PURE__ */ u(function() {
      return "NULL";
    }, "uppercase"),
    camelcase: /* @__PURE__ */ u(function() {
      return "Null";
    }, "camelcase"),
    empty: /* @__PURE__ */ u(function() {
      return "";
    }, "empty")
  },
  defaultStyle: "lowercase"
});
function Kd(e) {
  if (e === null) return !1;
  var t = e.length;
  return t === 4 && (e === "true" || e === "True" || e === "TRUE") || t === 5 && (e === "false" || e === "False" || e === "FALSE");
}
u(Kd, "resolveYamlBoolean");
function Qd(e) {
  return e === "true" || e === "True" || e === "TRUE";
}
u(Qd, "constructYamlBoolean");
function Zd(e) {
  return Object.prototype.toString.call(e) === "[object Boolean]";
}
u(Zd, "isBoolean");
var cb = new sr("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: Kd,
  construct: Qd,
  predicate: Zd,
  represent: {
    lowercase: /* @__PURE__ */ u(function(e) {
      return e ? "true" : "false";
    }, "lowercase"),
    uppercase: /* @__PURE__ */ u(function(e) {
      return e ? "TRUE" : "FALSE";
    }, "uppercase"),
    camelcase: /* @__PURE__ */ u(function(e) {
      return e ? "True" : "False";
    }, "camelcase")
  },
  defaultStyle: "lowercase"
});
function Jd(e) {
  return 48 <= e && e <= 57 || 65 <= e && e <= 70 || 97 <= e && e <= 102;
}
u(Jd, "isHexCode");
function t1(e) {
  return 48 <= e && e <= 55;
}
u(t1, "isOctCode");
function e1(e) {
  return 48 <= e && e <= 57;
}
u(e1, "isDecCode");
function r1(e) {
  if (e === null) return !1;
  var t = e.length, r = 0, i = !1, s;
  if (!t) return !1;
  if (s = e[r], (s === "-" || s === "+") && (s = e[++r]), s === "0") {
    if (r + 1 === t) return !0;
    if (s = e[++r], s === "b") {
      for (r++; r < t; r++)
        if (s = e[r], s !== "_") {
          if (s !== "0" && s !== "1") return !1;
          i = !0;
        }
      return i && s !== "_";
    }
    if (s === "x") {
      for (r++; r < t; r++)
        if (s = e[r], s !== "_") {
          if (!Jd(e.charCodeAt(r))) return !1;
          i = !0;
        }
      return i && s !== "_";
    }
    if (s === "o") {
      for (r++; r < t; r++)
        if (s = e[r], s !== "_") {
          if (!t1(e.charCodeAt(r))) return !1;
          i = !0;
        }
      return i && s !== "_";
    }
  }
  if (s === "_") return !1;
  for (; r < t; r++)
    if (s = e[r], s !== "_") {
      if (!e1(e.charCodeAt(r)))
        return !1;
      i = !0;
    }
  return !(!i || s === "_");
}
u(r1, "resolveYamlInteger");
function i1(e) {
  var t = e, r = 1, i;
  if (t.indexOf("_") !== -1 && (t = t.replace(/_/g, "")), i = t[0], (i === "-" || i === "+") && (i === "-" && (r = -1), t = t.slice(1), i = t[0]), t === "0") return 0;
  if (i === "0") {
    if (t[1] === "b") return r * parseInt(t.slice(2), 2);
    if (t[1] === "x") return r * parseInt(t.slice(2), 16);
    if (t[1] === "o") return r * parseInt(t.slice(2), 8);
  }
  return r * parseInt(t, 10);
}
u(i1, "constructYamlInteger");
function s1(e) {
  return Object.prototype.toString.call(e) === "[object Number]" && e % 1 === 0 && !We.isNegativeZero(e);
}
u(s1, "isInteger");
var hb = new sr("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: r1,
  construct: i1,
  predicate: s1,
  represent: {
    binary: /* @__PURE__ */ u(function(e) {
      return e >= 0 ? "0b" + e.toString(2) : "-0b" + e.toString(2).slice(1);
    }, "binary"),
    octal: /* @__PURE__ */ u(function(e) {
      return e >= 0 ? "0o" + e.toString(8) : "-0o" + e.toString(8).slice(1);
    }, "octal"),
    decimal: /* @__PURE__ */ u(function(e) {
      return e.toString(10);
    }, "decimal"),
    /* eslint-disable max-len */
    hexadecimal: /* @__PURE__ */ u(function(e) {
      return e >= 0 ? "0x" + e.toString(16).toUpperCase() : "-0x" + e.toString(16).toUpperCase().slice(1);
    }, "hexadecimal")
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
}), ub = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function a1(e) {
  return !(e === null || !ub.test(e) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  e[e.length - 1] === "_");
}
u(a1, "resolveYamlFloat");
function n1(e) {
  var t, r;
  return t = e.replace(/_/g, "").toLowerCase(), r = t[0] === "-" ? -1 : 1, "+-".indexOf(t[0]) >= 0 && (t = t.slice(1)), t === ".inf" ? r === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : t === ".nan" ? NaN : r * parseFloat(t, 10);
}
u(n1, "constructYamlFloat");
var db = /^[-+]?[0-9]+e/;
function o1(e, t) {
  var r;
  if (isNaN(e))
    switch (t) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  else if (Number.POSITIVE_INFINITY === e)
    switch (t) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  else if (Number.NEGATIVE_INFINITY === e)
    switch (t) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  else if (We.isNegativeZero(e))
    return "-0.0";
  return r = e.toString(10), db.test(r) ? r.replace("e", ".e") : r;
}
u(o1, "representYamlFloat");
function l1(e) {
  return Object.prototype.toString.call(e) === "[object Number]" && (e % 1 !== 0 || We.isNegativeZero(e));
}
u(l1, "isFloat");
var pb = new sr("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: a1,
  construct: n1,
  predicate: l1,
  represent: o1,
  defaultStyle: "lowercase"
}), c1 = ob.extend({
  implicit: [
    lb,
    cb,
    hb,
    pb
  ]
}), gb = c1, h1 = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
), u1 = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function d1(e) {
  return e === null ? !1 : h1.exec(e) !== null || u1.exec(e) !== null;
}
u(d1, "resolveYamlTimestamp");
function p1(e) {
  var t, r, i, s, a, n, o, h = 0, l = null, d, p, g;
  if (t = h1.exec(e), t === null && (t = u1.exec(e)), t === null) throw new Error("Date resolve error");
  if (r = +t[1], i = +t[2] - 1, s = +t[3], !t[4])
    return new Date(Date.UTC(r, i, s));
  if (a = +t[4], n = +t[5], o = +t[6], t[7]) {
    for (h = t[7].slice(0, 3); h.length < 3; )
      h += "0";
    h = +h;
  }
  return t[9] && (d = +t[10], p = +(t[11] || 0), l = (d * 60 + p) * 6e4, t[9] === "-" && (l = -l)), g = new Date(Date.UTC(r, i, s, a, n, o, h)), l && g.setTime(g.getTime() - l), g;
}
u(p1, "constructYamlTimestamp");
function g1(e) {
  return e.toISOString();
}
u(g1, "representYamlTimestamp");
var fb = new sr("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: d1,
  construct: p1,
  instanceOf: Date,
  represent: g1
});
function f1(e) {
  return e === "<<" || e === null;
}
u(f1, "resolveYamlMerge");
var yb = new sr("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: f1
}), Rc = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
function y1(e) {
  if (e === null) return !1;
  var t, r, i = 0, s = e.length, a = Rc;
  for (r = 0; r < s; r++)
    if (t = a.indexOf(e.charAt(r)), !(t > 64)) {
      if (t < 0) return !1;
      i += 6;
    }
  return i % 8 === 0;
}
u(y1, "resolveYamlBinary");
function m1(e) {
  var t, r, i = e.replace(/[\r\n=]/g, ""), s = i.length, a = Rc, n = 0, o = [];
  for (t = 0; t < s; t++)
    t % 4 === 0 && t && (o.push(n >> 16 & 255), o.push(n >> 8 & 255), o.push(n & 255)), n = n << 6 | a.indexOf(i.charAt(t));
  return r = s % 4 * 6, r === 0 ? (o.push(n >> 16 & 255), o.push(n >> 8 & 255), o.push(n & 255)) : r === 18 ? (o.push(n >> 10 & 255), o.push(n >> 2 & 255)) : r === 12 && o.push(n >> 4 & 255), new Uint8Array(o);
}
u(m1, "constructYamlBinary");
function x1(e) {
  var t = "", r = 0, i, s, a = e.length, n = Rc;
  for (i = 0; i < a; i++)
    i % 3 === 0 && i && (t += n[r >> 18 & 63], t += n[r >> 12 & 63], t += n[r >> 6 & 63], t += n[r & 63]), r = (r << 8) + e[i];
  return s = a % 3, s === 0 ? (t += n[r >> 18 & 63], t += n[r >> 12 & 63], t += n[r >> 6 & 63], t += n[r & 63]) : s === 2 ? (t += n[r >> 10 & 63], t += n[r >> 4 & 63], t += n[r << 2 & 63], t += n[64]) : s === 1 && (t += n[r >> 2 & 63], t += n[r << 4 & 63], t += n[64], t += n[64]), t;
}
u(x1, "representYamlBinary");
function b1(e) {
  return Object.prototype.toString.call(e) === "[object Uint8Array]";
}
u(b1, "isBinary");
var mb = new sr("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: y1,
  construct: m1,
  predicate: b1,
  represent: x1
}), xb = Object.prototype.hasOwnProperty, bb = Object.prototype.toString;
function k1(e) {
  if (e === null) return !0;
  var t = [], r, i, s, a, n, o = e;
  for (r = 0, i = o.length; r < i; r += 1) {
    if (s = o[r], n = !1, bb.call(s) !== "[object Object]") return !1;
    for (a in s)
      if (xb.call(s, a))
        if (!n) n = !0;
        else return !1;
    if (!n) return !1;
    if (t.indexOf(a) === -1) t.push(a);
    else return !1;
  }
  return !0;
}
u(k1, "resolveYamlOmap");
function v1(e) {
  return e !== null ? e : [];
}
u(v1, "constructYamlOmap");
var kb = new sr("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: k1,
  construct: v1
}), vb = Object.prototype.toString;
function S1(e) {
  if (e === null) return !0;
  var t, r, i, s, a, n = e;
  for (a = new Array(n.length), t = 0, r = n.length; t < r; t += 1) {
    if (i = n[t], vb.call(i) !== "[object Object]" || (s = Object.keys(i), s.length !== 1)) return !1;
    a[t] = [s[0], i[s[0]]];
  }
  return !0;
}
u(S1, "resolveYamlPairs");
function C1(e) {
  if (e === null) return [];
  var t, r, i, s, a, n = e;
  for (a = new Array(n.length), t = 0, r = n.length; t < r; t += 1)
    i = n[t], s = Object.keys(i), a[t] = [s[0], i[s[0]]];
  return a;
}
u(C1, "constructYamlPairs");
var Sb = new sr("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: S1,
  construct: C1
}), Cb = Object.prototype.hasOwnProperty;
function w1(e) {
  if (e === null) return !0;
  var t, r = e;
  for (t in r)
    if (Cb.call(r, t) && r[t] !== null)
      return !1;
  return !0;
}
u(w1, "resolveYamlSet");
function T1(e) {
  return e !== null ? e : {};
}
u(T1, "constructYamlSet");
var wb = new sr("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: w1,
  construct: T1
}), _1 = gb.extend({
  implicit: [
    fb,
    yb
  ],
  explicit: [
    mb,
    kb,
    Sb,
    wb
  ]
}), Li = Object.prototype.hasOwnProperty, Gn = 1, E1 = 2, A1 = 3, Xn = 4, il = 1, Tb = 2, ou = 3, _b = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, Eb = /[\x85\u2028\u2029]/, Ab = /[,\[\]\{\}]/, L1 = /^(?:!|!!|![a-z\-]+!)$/i, B1 = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function kl(e) {
  return Object.prototype.toString.call(e);
}
u(kl, "_class");
function Pr(e) {
  return e === 10 || e === 13;
}
u(Pr, "is_EOL");
function Ei(e) {
  return e === 9 || e === 32;
}
u(Ei, "is_WHITE_SPACE");
function ur(e) {
  return e === 9 || e === 32 || e === 10 || e === 13;
}
u(ur, "is_WS_OR_EOL");
function ji(e) {
  return e === 44 || e === 91 || e === 93 || e === 123 || e === 125;
}
u(ji, "is_FLOW_INDICATOR");
function D1(e) {
  var t;
  return 48 <= e && e <= 57 ? e - 48 : (t = e | 32, 97 <= t && t <= 102 ? t - 97 + 10 : -1);
}
u(D1, "fromHexCode");
function I1(e) {
  return e === 120 ? 2 : e === 117 ? 4 : e === 85 ? 8 : 0;
}
u(I1, "escapedHexLen");
function F1(e) {
  return 48 <= e && e <= 57 ? e - 48 : -1;
}
u(F1, "fromDecimalCode");
function vl(e) {
  return e === 48 ? "\0" : e === 97 ? "\x07" : e === 98 ? "\b" : e === 116 || e === 9 ? "	" : e === 110 ? `
` : e === 118 ? "\v" : e === 102 ? "\f" : e === 114 ? "\r" : e === 101 ? "\x1B" : e === 32 ? " " : e === 34 ? '"' : e === 47 ? "/" : e === 92 ? "\\" : e === 78 ? "" : e === 95 ? "" : e === 76 ? "\u2028" : e === 80 ? "\u2029" : "";
}
u(vl, "simpleEscapeSequence");
function N1(e) {
  return e <= 65535 ? String.fromCharCode(e) : String.fromCharCode(
    (e - 65536 >> 10) + 55296,
    (e - 65536 & 1023) + 56320
  );
}
u(N1, "charFromCodepoint");
var R1 = new Array(256), M1 = new Array(256);
for (Wi = 0; Wi < 256; Wi++)
  R1[Wi] = vl(Wi) ? 1 : 0, M1[Wi] = vl(Wi);
var Wi;
function O1(e, t) {
  this.input = e, this.filename = t.filename || null, this.schema = t.schema || _1, this.onWarning = t.onWarning || null, this.legacy = t.legacy || !1, this.json = t.json || !1, this.listener = t.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = e.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.firstTabInLine = -1, this.documents = [];
}
u(O1, "State$1");
function Mc(e, t) {
  var r = {
    name: e.filename,
    buffer: e.input.slice(0, -1),
    // omit trailing \0
    position: e.position,
    line: e.line,
    column: e.position - e.lineStart
  };
  return r.snippet = tb(r), new xr(t, r);
}
u(Mc, "generateError");
function Ht(e, t) {
  throw Mc(e, t);
}
u(Ht, "throwError");
function ja(e, t) {
  e.onWarning && e.onWarning.call(null, Mc(e, t));
}
u(ja, "throwWarning");
var lu = {
  YAML: /* @__PURE__ */ u(function(t, r, i) {
    var s, a, n;
    t.version !== null && Ht(t, "duplication of %YAML directive"), i.length !== 1 && Ht(t, "YAML directive accepts exactly one argument"), s = /^([0-9]+)\.([0-9]+)$/.exec(i[0]), s === null && Ht(t, "ill-formed argument of the YAML directive"), a = parseInt(s[1], 10), n = parseInt(s[2], 10), a !== 1 && Ht(t, "unacceptable YAML version of the document"), t.version = i[0], t.checkLineBreaks = n < 2, n !== 1 && n !== 2 && ja(t, "unsupported YAML version of the document");
  }, "handleYamlDirective"),
  TAG: /* @__PURE__ */ u(function(t, r, i) {
    var s, a;
    i.length !== 2 && Ht(t, "TAG directive accepts exactly two arguments"), s = i[0], a = i[1], L1.test(s) || Ht(t, "ill-formed tag handle (first argument) of the TAG directive"), Li.call(t.tagMap, s) && Ht(t, 'there is a previously declared suffix for "' + s + '" tag handle'), B1.test(a) || Ht(t, "ill-formed tag prefix (second argument) of the TAG directive");
    try {
      a = decodeURIComponent(a);
    } catch {
      Ht(t, "tag prefix is malformed: " + a);
    }
    t.tagMap[s] = a;
  }, "handleTagDirective")
};
function mi(e, t, r, i) {
  var s, a, n, o;
  if (t < r) {
    if (o = e.input.slice(t, r), i)
      for (s = 0, a = o.length; s < a; s += 1)
        n = o.charCodeAt(s), n === 9 || 32 <= n && n <= 1114111 || Ht(e, "expected valid JSON character");
    else _b.test(o) && Ht(e, "the stream contains non-printable characters");
    e.result += o;
  }
}
u(mi, "captureSegment");
function Sl(e, t, r, i) {
  var s, a, n, o;
  for (We.isObject(r) || Ht(e, "cannot merge mappings; the provided source object is unacceptable"), s = Object.keys(r), n = 0, o = s.length; n < o; n += 1)
    a = s[n], Li.call(t, a) || (t[a] = r[a], i[a] = !0);
}
u(Sl, "mergeMappings");
function Gi(e, t, r, i, s, a, n, o, h) {
  var l, d;
  if (Array.isArray(s))
    for (s = Array.prototype.slice.call(s), l = 0, d = s.length; l < d; l += 1)
      Array.isArray(s[l]) && Ht(e, "nested arrays are not supported inside keys"), typeof s == "object" && kl(s[l]) === "[object Object]" && (s[l] = "[object Object]");
  if (typeof s == "object" && kl(s) === "[object Object]" && (s = "[object Object]"), s = String(s), t === null && (t = {}), i === "tag:yaml.org,2002:merge")
    if (Array.isArray(a))
      for (l = 0, d = a.length; l < d; l += 1)
        Sl(e, t, a[l], r);
    else
      Sl(e, t, a, r);
  else
    !e.json && !Li.call(r, s) && Li.call(t, s) && (e.line = n || e.line, e.lineStart = o || e.lineStart, e.position = h || e.position, Ht(e, "duplicated mapping key")), s === "__proto__" ? Object.defineProperty(t, s, {
      configurable: !0,
      enumerable: !0,
      writable: !0,
      value: a
    }) : t[s] = a, delete r[s];
  return t;
}
u(Gi, "storeMappingPair");
function Lo(e) {
  var t;
  t = e.input.charCodeAt(e.position), t === 10 ? e.position++ : t === 13 ? (e.position++, e.input.charCodeAt(e.position) === 10 && e.position++) : Ht(e, "a line break is expected"), e.line += 1, e.lineStart = e.position, e.firstTabInLine = -1;
}
u(Lo, "readLineBreak");
function Ie(e, t, r) {
  for (var i = 0, s = e.input.charCodeAt(e.position); s !== 0; ) {
    for (; Ei(s); )
      s === 9 && e.firstTabInLine === -1 && (e.firstTabInLine = e.position), s = e.input.charCodeAt(++e.position);
    if (t && s === 35)
      do
        s = e.input.charCodeAt(++e.position);
      while (s !== 10 && s !== 13 && s !== 0);
    if (Pr(s))
      for (Lo(e), s = e.input.charCodeAt(e.position), i++, e.lineIndent = 0; s === 32; )
        e.lineIndent++, s = e.input.charCodeAt(++e.position);
    else
      break;
  }
  return r !== -1 && i !== 0 && e.lineIndent < r && ja(e, "deficient indentation"), i;
}
u(Ie, "skipSeparationSpace");
function pn(e) {
  var t = e.position, r;
  return r = e.input.charCodeAt(t), !!((r === 45 || r === 46) && r === e.input.charCodeAt(t + 1) && r === e.input.charCodeAt(t + 2) && (t += 3, r = e.input.charCodeAt(t), r === 0 || ur(r)));
}
u(pn, "testDocumentSeparator");
function Bo(e, t) {
  t === 1 ? e.result += " " : t > 1 && (e.result += We.repeat(`
`, t - 1));
}
u(Bo, "writeFoldedLines");
function P1(e, t, r) {
  var i, s, a, n, o, h, l, d, p = e.kind, g = e.result, f;
  if (f = e.input.charCodeAt(e.position), ur(f) || ji(f) || f === 35 || f === 38 || f === 42 || f === 33 || f === 124 || f === 62 || f === 39 || f === 34 || f === 37 || f === 64 || f === 96 || (f === 63 || f === 45) && (s = e.input.charCodeAt(e.position + 1), ur(s) || r && ji(s)))
    return !1;
  for (e.kind = "scalar", e.result = "", a = n = e.position, o = !1; f !== 0; ) {
    if (f === 58) {
      if (s = e.input.charCodeAt(e.position + 1), ur(s) || r && ji(s))
        break;
    } else if (f === 35) {
      if (i = e.input.charCodeAt(e.position - 1), ur(i))
        break;
    } else {
      if (e.position === e.lineStart && pn(e) || r && ji(f))
        break;
      if (Pr(f))
        if (h = e.line, l = e.lineStart, d = e.lineIndent, Ie(e, !1, -1), e.lineIndent >= t) {
          o = !0, f = e.input.charCodeAt(e.position);
          continue;
        } else {
          e.position = n, e.line = h, e.lineStart = l, e.lineIndent = d;
          break;
        }
    }
    o && (mi(e, a, n, !1), Bo(e, e.line - h), a = n = e.position, o = !1), Ei(f) || (n = e.position + 1), f = e.input.charCodeAt(++e.position);
  }
  return mi(e, a, n, !1), e.result ? !0 : (e.kind = p, e.result = g, !1);
}
u(P1, "readPlainScalar");
function $1(e, t) {
  var r, i, s;
  if (r = e.input.charCodeAt(e.position), r !== 39)
    return !1;
  for (e.kind = "scalar", e.result = "", e.position++, i = s = e.position; (r = e.input.charCodeAt(e.position)) !== 0; )
    if (r === 39)
      if (mi(e, i, e.position, !0), r = e.input.charCodeAt(++e.position), r === 39)
        i = e.position, e.position++, s = e.position;
      else
        return !0;
    else Pr(r) ? (mi(e, i, s, !0), Bo(e, Ie(e, !1, t)), i = s = e.position) : e.position === e.lineStart && pn(e) ? Ht(e, "unexpected end of the document within a single quoted scalar") : (e.position++, s = e.position);
  Ht(e, "unexpected end of the stream within a single quoted scalar");
}
u($1, "readSingleQuotedScalar");
function V1(e, t) {
  var r, i, s, a, n, o;
  if (o = e.input.charCodeAt(e.position), o !== 34)
    return !1;
  for (e.kind = "scalar", e.result = "", e.position++, r = i = e.position; (o = e.input.charCodeAt(e.position)) !== 0; ) {
    if (o === 34)
      return mi(e, r, e.position, !0), e.position++, !0;
    if (o === 92) {
      if (mi(e, r, e.position, !0), o = e.input.charCodeAt(++e.position), Pr(o))
        Ie(e, !1, t);
      else if (o < 256 && R1[o])
        e.result += M1[o], e.position++;
      else if ((n = I1(o)) > 0) {
        for (s = n, a = 0; s > 0; s--)
          o = e.input.charCodeAt(++e.position), (n = D1(o)) >= 0 ? a = (a << 4) + n : Ht(e, "expected hexadecimal character");
        e.result += N1(a), e.position++;
      } else
        Ht(e, "unknown escape sequence");
      r = i = e.position;
    } else Pr(o) ? (mi(e, r, i, !0), Bo(e, Ie(e, !1, t)), r = i = e.position) : e.position === e.lineStart && pn(e) ? Ht(e, "unexpected end of the document within a double quoted scalar") : (e.position++, i = e.position);
  }
  Ht(e, "unexpected end of the stream within a double quoted scalar");
}
u(V1, "readDoubleQuotedScalar");
function z1(e, t) {
  var r = !0, i, s, a, n = e.tag, o, h = e.anchor, l, d, p, g, f, y = /* @__PURE__ */ Object.create(null), m, x, b, v;
  if (v = e.input.charCodeAt(e.position), v === 91)
    d = 93, f = !1, o = [];
  else if (v === 123)
    d = 125, f = !0, o = {};
  else
    return !1;
  for (e.anchor !== null && (e.anchorMap[e.anchor] = o), v = e.input.charCodeAt(++e.position); v !== 0; ) {
    if (Ie(e, !0, t), v = e.input.charCodeAt(e.position), v === d)
      return e.position++, e.tag = n, e.anchor = h, e.kind = f ? "mapping" : "sequence", e.result = o, !0;
    r ? v === 44 && Ht(e, "expected the node content, but found ','") : Ht(e, "missed comma between flow collection entries"), x = m = b = null, p = g = !1, v === 63 && (l = e.input.charCodeAt(e.position + 1), ur(l) && (p = g = !0, e.position++, Ie(e, !0, t))), i = e.line, s = e.lineStart, a = e.position, is(e, t, Gn, !1, !0), x = e.tag, m = e.result, Ie(e, !0, t), v = e.input.charCodeAt(e.position), (g || e.line === i) && v === 58 && (p = !0, v = e.input.charCodeAt(++e.position), Ie(e, !0, t), is(e, t, Gn, !1, !0), b = e.result), f ? Gi(e, o, y, x, m, b, i, s, a) : p ? o.push(Gi(e, null, y, x, m, b, i, s, a)) : o.push(m), Ie(e, !0, t), v = e.input.charCodeAt(e.position), v === 44 ? (r = !0, v = e.input.charCodeAt(++e.position)) : r = !1;
  }
  Ht(e, "unexpected end of the stream within a flow collection");
}
u(z1, "readFlowCollection");
function W1(e, t) {
  var r, i, s = il, a = !1, n = !1, o = t, h = 0, l = !1, d, p;
  if (p = e.input.charCodeAt(e.position), p === 124)
    i = !1;
  else if (p === 62)
    i = !0;
  else
    return !1;
  for (e.kind = "scalar", e.result = ""; p !== 0; )
    if (p = e.input.charCodeAt(++e.position), p === 43 || p === 45)
      il === s ? s = p === 43 ? ou : Tb : Ht(e, "repeat of a chomping mode identifier");
    else if ((d = F1(p)) >= 0)
      d === 0 ? Ht(e, "bad explicit indentation width of a block scalar; it cannot be less than one") : n ? Ht(e, "repeat of an indentation width identifier") : (o = t + d - 1, n = !0);
    else
      break;
  if (Ei(p)) {
    do
      p = e.input.charCodeAt(++e.position);
    while (Ei(p));
    if (p === 35)
      do
        p = e.input.charCodeAt(++e.position);
      while (!Pr(p) && p !== 0);
  }
  for (; p !== 0; ) {
    for (Lo(e), e.lineIndent = 0, p = e.input.charCodeAt(e.position); (!n || e.lineIndent < o) && p === 32; )
      e.lineIndent++, p = e.input.charCodeAt(++e.position);
    if (!n && e.lineIndent > o && (o = e.lineIndent), Pr(p)) {
      h++;
      continue;
    }
    if (e.lineIndent < o) {
      s === ou ? e.result += We.repeat(`
`, a ? 1 + h : h) : s === il && a && (e.result += `
`);
      break;
    }
    for (i ? Ei(p) ? (l = !0, e.result += We.repeat(`
`, a ? 1 + h : h)) : l ? (l = !1, e.result += We.repeat(`
`, h + 1)) : h === 0 ? a && (e.result += " ") : e.result += We.repeat(`
`, h) : e.result += We.repeat(`
`, a ? 1 + h : h), a = !0, n = !0, h = 0, r = e.position; !Pr(p) && p !== 0; )
      p = e.input.charCodeAt(++e.position);
    mi(e, r, e.position, !1);
  }
  return !0;
}
u(W1, "readBlockScalar");
function Cl(e, t) {
  var r, i = e.tag, s = e.anchor, a = [], n, o = !1, h;
  if (e.firstTabInLine !== -1) return !1;
  for (e.anchor !== null && (e.anchorMap[e.anchor] = a), h = e.input.charCodeAt(e.position); h !== 0 && (e.firstTabInLine !== -1 && (e.position = e.firstTabInLine, Ht(e, "tab characters must not be used in indentation")), !(h !== 45 || (n = e.input.charCodeAt(e.position + 1), !ur(n)))); ) {
    if (o = !0, e.position++, Ie(e, !0, -1) && e.lineIndent <= t) {
      a.push(null), h = e.input.charCodeAt(e.position);
      continue;
    }
    if (r = e.line, is(e, t, A1, !1, !0), a.push(e.result), Ie(e, !0, -1), h = e.input.charCodeAt(e.position), (e.line === r || e.lineIndent > t) && h !== 0)
      Ht(e, "bad indentation of a sequence entry");
    else if (e.lineIndent < t)
      break;
  }
  return o ? (e.tag = i, e.anchor = s, e.kind = "sequence", e.result = a, !0) : !1;
}
u(Cl, "readBlockSequence");
function q1(e, t, r) {
  var i, s, a, n, o, h, l = e.tag, d = e.anchor, p = {}, g = /* @__PURE__ */ Object.create(null), f = null, y = null, m = null, x = !1, b = !1, v;
  if (e.firstTabInLine !== -1) return !1;
  for (e.anchor !== null && (e.anchorMap[e.anchor] = p), v = e.input.charCodeAt(e.position); v !== 0; ) {
    if (!x && e.firstTabInLine !== -1 && (e.position = e.firstTabInLine, Ht(e, "tab characters must not be used in indentation")), i = e.input.charCodeAt(e.position + 1), a = e.line, (v === 63 || v === 58) && ur(i))
      v === 63 ? (x && (Gi(e, p, g, f, y, null, n, o, h), f = y = m = null), b = !0, x = !0, s = !0) : x ? (x = !1, s = !0) : Ht(e, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), e.position += 1, v = i;
    else {
      if (n = e.line, o = e.lineStart, h = e.position, !is(e, r, E1, !1, !0))
        break;
      if (e.line === a) {
        for (v = e.input.charCodeAt(e.position); Ei(v); )
          v = e.input.charCodeAt(++e.position);
        if (v === 58)
          v = e.input.charCodeAt(++e.position), ur(v) || Ht(e, "a whitespace character is expected after the key-value separator within a block mapping"), x && (Gi(e, p, g, f, y, null, n, o, h), f = y = m = null), b = !0, x = !1, s = !1, f = e.tag, y = e.result;
        else if (b)
          Ht(e, "can not read an implicit mapping pair; a colon is missed");
        else
          return e.tag = l, e.anchor = d, !0;
      } else if (b)
        Ht(e, "can not read a block mapping entry; a multiline key may not be an implicit key");
      else
        return e.tag = l, e.anchor = d, !0;
    }
    if ((e.line === a || e.lineIndent > t) && (x && (n = e.line, o = e.lineStart, h = e.position), is(e, t, Xn, !0, s) && (x ? y = e.result : m = e.result), x || (Gi(e, p, g, f, y, m, n, o, h), f = y = m = null), Ie(e, !0, -1), v = e.input.charCodeAt(e.position)), (e.line === a || e.lineIndent > t) && v !== 0)
      Ht(e, "bad indentation of a mapping entry");
    else if (e.lineIndent < t)
      break;
  }
  return x && Gi(e, p, g, f, y, null, n, o, h), b && (e.tag = l, e.anchor = d, e.kind = "mapping", e.result = p), b;
}
u(q1, "readBlockMapping");
function Y1(e) {
  var t, r = !1, i = !1, s, a, n;
  if (n = e.input.charCodeAt(e.position), n !== 33) return !1;
  if (e.tag !== null && Ht(e, "duplication of a tag property"), n = e.input.charCodeAt(++e.position), n === 60 ? (r = !0, n = e.input.charCodeAt(++e.position)) : n === 33 ? (i = !0, s = "!!", n = e.input.charCodeAt(++e.position)) : s = "!", t = e.position, r) {
    do
      n = e.input.charCodeAt(++e.position);
    while (n !== 0 && n !== 62);
    e.position < e.length ? (a = e.input.slice(t, e.position), n = e.input.charCodeAt(++e.position)) : Ht(e, "unexpected end of the stream within a verbatim tag");
  } else {
    for (; n !== 0 && !ur(n); )
      n === 33 && (i ? Ht(e, "tag suffix cannot contain exclamation marks") : (s = e.input.slice(t - 1, e.position + 1), L1.test(s) || Ht(e, "named tag handle cannot contain such characters"), i = !0, t = e.position + 1)), n = e.input.charCodeAt(++e.position);
    a = e.input.slice(t, e.position), Ab.test(a) && Ht(e, "tag suffix cannot contain flow indicator characters");
  }
  a && !B1.test(a) && Ht(e, "tag name cannot contain such characters: " + a);
  try {
    a = decodeURIComponent(a);
  } catch {
    Ht(e, "tag name is malformed: " + a);
  }
  return r ? e.tag = a : Li.call(e.tagMap, s) ? e.tag = e.tagMap[s] + a : s === "!" ? e.tag = "!" + a : s === "!!" ? e.tag = "tag:yaml.org,2002:" + a : Ht(e, 'undeclared tag handle "' + s + '"'), !0;
}
u(Y1, "readTagProperty");
function H1(e) {
  var t, r;
  if (r = e.input.charCodeAt(e.position), r !== 38) return !1;
  for (e.anchor !== null && Ht(e, "duplication of an anchor property"), r = e.input.charCodeAt(++e.position), t = e.position; r !== 0 && !ur(r) && !ji(r); )
    r = e.input.charCodeAt(++e.position);
  return e.position === t && Ht(e, "name of an anchor node must contain at least one character"), e.anchor = e.input.slice(t, e.position), !0;
}
u(H1, "readAnchorProperty");
function U1(e) {
  var t, r, i;
  if (i = e.input.charCodeAt(e.position), i !== 42) return !1;
  for (i = e.input.charCodeAt(++e.position), t = e.position; i !== 0 && !ur(i) && !ji(i); )
    i = e.input.charCodeAt(++e.position);
  return e.position === t && Ht(e, "name of an alias node must contain at least one character"), r = e.input.slice(t, e.position), Li.call(e.anchorMap, r) || Ht(e, 'unidentified alias "' + r + '"'), e.result = e.anchorMap[r], Ie(e, !0, -1), !0;
}
u(U1, "readAlias");
function is(e, t, r, i, s) {
  var a, n, o, h = 1, l = !1, d = !1, p, g, f, y, m, x;
  if (e.listener !== null && e.listener("open", e), e.tag = null, e.anchor = null, e.kind = null, e.result = null, a = n = o = Xn === r || A1 === r, i && Ie(e, !0, -1) && (l = !0, e.lineIndent > t ? h = 1 : e.lineIndent === t ? h = 0 : e.lineIndent < t && (h = -1)), h === 1)
    for (; Y1(e) || H1(e); )
      Ie(e, !0, -1) ? (l = !0, o = a, e.lineIndent > t ? h = 1 : e.lineIndent === t ? h = 0 : e.lineIndent < t && (h = -1)) : o = !1;
  if (o && (o = l || s), (h === 1 || Xn === r) && (Gn === r || E1 === r ? m = t : m = t + 1, x = e.position - e.lineStart, h === 1 ? o && (Cl(e, x) || q1(e, x, m)) || z1(e, m) ? d = !0 : (n && W1(e, m) || $1(e, m) || V1(e, m) ? d = !0 : U1(e) ? (d = !0, (e.tag !== null || e.anchor !== null) && Ht(e, "alias node should not have any properties")) : P1(e, m, Gn === r) && (d = !0, e.tag === null && (e.tag = "?")), e.anchor !== null && (e.anchorMap[e.anchor] = e.result)) : h === 0 && (d = o && Cl(e, x))), e.tag === null)
    e.anchor !== null && (e.anchorMap[e.anchor] = e.result);
  else if (e.tag === "?") {
    for (e.result !== null && e.kind !== "scalar" && Ht(e, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + e.kind + '"'), p = 0, g = e.implicitTypes.length; p < g; p += 1)
      if (y = e.implicitTypes[p], y.resolve(e.result)) {
        e.result = y.construct(e.result), e.tag = y.tag, e.anchor !== null && (e.anchorMap[e.anchor] = e.result);
        break;
      }
  } else if (e.tag !== "!") {
    if (Li.call(e.typeMap[e.kind || "fallback"], e.tag))
      y = e.typeMap[e.kind || "fallback"][e.tag];
    else
      for (y = null, f = e.typeMap.multi[e.kind || "fallback"], p = 0, g = f.length; p < g; p += 1)
        if (e.tag.slice(0, f[p].tag.length) === f[p].tag) {
          y = f[p];
          break;
        }
    y || Ht(e, "unknown tag !<" + e.tag + ">"), e.result !== null && y.kind !== e.kind && Ht(e, "unacceptable node kind for !<" + e.tag + '> tag; it should be "' + y.kind + '", not "' + e.kind + '"'), y.resolve(e.result, e.tag) ? (e.result = y.construct(e.result, e.tag), e.anchor !== null && (e.anchorMap[e.anchor] = e.result)) : Ht(e, "cannot resolve a node with !<" + e.tag + "> explicit tag");
  }
  return e.listener !== null && e.listener("close", e), e.tag !== null || e.anchor !== null || d;
}
u(is, "composeNode");
function j1(e) {
  var t = e.position, r, i, s, a = !1, n;
  for (e.version = null, e.checkLineBreaks = e.legacy, e.tagMap = /* @__PURE__ */ Object.create(null), e.anchorMap = /* @__PURE__ */ Object.create(null); (n = e.input.charCodeAt(e.position)) !== 0 && (Ie(e, !0, -1), n = e.input.charCodeAt(e.position), !(e.lineIndent > 0 || n !== 37)); ) {
    for (a = !0, n = e.input.charCodeAt(++e.position), r = e.position; n !== 0 && !ur(n); )
      n = e.input.charCodeAt(++e.position);
    for (i = e.input.slice(r, e.position), s = [], i.length < 1 && Ht(e, "directive name must not be less than one character in length"); n !== 0; ) {
      for (; Ei(n); )
        n = e.input.charCodeAt(++e.position);
      if (n === 35) {
        do
          n = e.input.charCodeAt(++e.position);
        while (n !== 0 && !Pr(n));
        break;
      }
      if (Pr(n)) break;
      for (r = e.position; n !== 0 && !ur(n); )
        n = e.input.charCodeAt(++e.position);
      s.push(e.input.slice(r, e.position));
    }
    n !== 0 && Lo(e), Li.call(lu, i) ? lu[i](e, i, s) : ja(e, 'unknown document directive "' + i + '"');
  }
  if (Ie(e, !0, -1), e.lineIndent === 0 && e.input.charCodeAt(e.position) === 45 && e.input.charCodeAt(e.position + 1) === 45 && e.input.charCodeAt(e.position + 2) === 45 ? (e.position += 3, Ie(e, !0, -1)) : a && Ht(e, "directives end mark is expected"), is(e, e.lineIndent - 1, Xn, !1, !0), Ie(e, !0, -1), e.checkLineBreaks && Eb.test(e.input.slice(t, e.position)) && ja(e, "non-ASCII line breaks are interpreted as content"), e.documents.push(e.result), e.position === e.lineStart && pn(e)) {
    e.input.charCodeAt(e.position) === 46 && (e.position += 3, Ie(e, !0, -1));
    return;
  }
  if (e.position < e.length - 1)
    Ht(e, "end of the stream or a document separator is expected");
  else
    return;
}
u(j1, "readDocument");
function Oc(e, t) {
  e = String(e), t = t || {}, e.length !== 0 && (e.charCodeAt(e.length - 1) !== 10 && e.charCodeAt(e.length - 1) !== 13 && (e += `
`), e.charCodeAt(0) === 65279 && (e = e.slice(1)));
  var r = new O1(e, t), i = e.indexOf("\0");
  for (i !== -1 && (r.position = i, Ht(r, "null byte is not allowed in input")), r.input += "\0"; r.input.charCodeAt(r.position) === 32; )
    r.lineIndent += 1, r.position += 1;
  for (; r.position < r.length - 1; )
    j1(r);
  return r.documents;
}
u(Oc, "loadDocuments");
function Lb(e, t, r) {
  t !== null && typeof t == "object" && typeof r > "u" && (r = t, t = null);
  var i = Oc(e, r);
  if (typeof t != "function")
    return i;
  for (var s = 0, a = i.length; s < a; s += 1)
    t(i[s]);
}
u(Lb, "loadAll$1");
function G1(e, t) {
  var r = Oc(e, t);
  if (r.length !== 0) {
    if (r.length === 1)
      return r[0];
    throw new xr("expected a single document in the stream, but found more");
  }
}
u(G1, "load$1");
var Bb = G1, Db = {
  load: Bb
}, X1 = Object.prototype.toString, K1 = Object.prototype.hasOwnProperty, Pc = 65279, Ib = 9, Ga = 10, Fb = 13, Nb = 32, Rb = 33, Mb = 34, wl = 35, Ob = 37, Pb = 38, $b = 39, Vb = 42, Q1 = 44, zb = 45, Kn = 58, Wb = 61, qb = 62, Yb = 63, Hb = 64, Z1 = 91, J1 = 93, Ub = 96, t0 = 123, jb = 124, e0 = 125, nr = {};
nr[0] = "\\0";
nr[7] = "\\a";
nr[8] = "\\b";
nr[9] = "\\t";
nr[10] = "\\n";
nr[11] = "\\v";
nr[12] = "\\f";
nr[13] = "\\r";
nr[27] = "\\e";
nr[34] = '\\"';
nr[92] = "\\\\";
nr[133] = "\\N";
nr[160] = "\\_";
nr[8232] = "\\L";
nr[8233] = "\\P";
var Gb = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
], Xb = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function r0(e, t) {
  var r, i, s, a, n, o, h;
  if (t === null) return {};
  for (r = {}, i = Object.keys(t), s = 0, a = i.length; s < a; s += 1)
    n = i[s], o = String(t[n]), n.slice(0, 2) === "!!" && (n = "tag:yaml.org,2002:" + n.slice(2)), h = e.compiledTypeMap.fallback[n], h && K1.call(h.styleAliases, o) && (o = h.styleAliases[o]), r[n] = o;
  return r;
}
u(r0, "compileStyleMap");
function i0(e) {
  var t, r, i;
  if (t = e.toString(16).toUpperCase(), e <= 255)
    r = "x", i = 2;
  else if (e <= 65535)
    r = "u", i = 4;
  else if (e <= 4294967295)
    r = "U", i = 8;
  else
    throw new xr("code point within a string may not be greater than 0xFFFFFFFF");
  return "\\" + r + We.repeat("0", i - t.length) + t;
}
u(i0, "encodeHex");
var Kb = 1, Xa = 2;
function s0(e) {
  this.schema = e.schema || _1, this.indent = Math.max(1, e.indent || 2), this.noArrayIndent = e.noArrayIndent || !1, this.skipInvalid = e.skipInvalid || !1, this.flowLevel = We.isNothing(e.flowLevel) ? -1 : e.flowLevel, this.styleMap = r0(this.schema, e.styles || null), this.sortKeys = e.sortKeys || !1, this.lineWidth = e.lineWidth || 80, this.noRefs = e.noRefs || !1, this.noCompatMode = e.noCompatMode || !1, this.condenseFlow = e.condenseFlow || !1, this.quotingType = e.quotingType === '"' ? Xa : Kb, this.forceQuotes = e.forceQuotes || !1, this.replacer = typeof e.replacer == "function" ? e.replacer : null, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
}
u(s0, "State");
function Tl(e, t) {
  for (var r = We.repeat(" ", t), i = 0, s = -1, a = "", n, o = e.length; i < o; )
    s = e.indexOf(`
`, i), s === -1 ? (n = e.slice(i), i = o) : (n = e.slice(i, s + 1), i = s + 1), n.length && n !== `
` && (a += r), a += n;
  return a;
}
u(Tl, "indentString");
function Qn(e, t) {
  return `
` + We.repeat(" ", e.indent * t);
}
u(Qn, "generateNextLine");
function a0(e, t) {
  var r, i, s;
  for (r = 0, i = e.implicitTypes.length; r < i; r += 1)
    if (s = e.implicitTypes[r], s.resolve(t))
      return !0;
  return !1;
}
u(a0, "testImplicitResolving");
function Ka(e) {
  return e === Nb || e === Ib;
}
u(Ka, "isWhitespace");
function fa(e) {
  return 32 <= e && e <= 126 || 161 <= e && e <= 55295 && e !== 8232 && e !== 8233 || 57344 <= e && e <= 65533 && e !== Pc || 65536 <= e && e <= 1114111;
}
u(fa, "isPrintable");
function _l(e) {
  return fa(e) && e !== Pc && e !== Fb && e !== Ga;
}
u(_l, "isNsCharOrWhitespace");
function El(e, t, r) {
  var i = _l(e), s = i && !Ka(e);
  return (
    // ns-plain-safe
    (r ? (
      // c = flow-in
      i
    ) : i && e !== Q1 && e !== Z1 && e !== J1 && e !== t0 && e !== e0) && e !== wl && !(t === Kn && !s) || _l(t) && !Ka(t) && e === wl || t === Kn && s
  );
}
u(El, "isPlainSafe");
function n0(e) {
  return fa(e) && e !== Pc && !Ka(e) && e !== zb && e !== Yb && e !== Kn && e !== Q1 && e !== Z1 && e !== J1 && e !== t0 && e !== e0 && e !== wl && e !== Pb && e !== Vb && e !== Rb && e !== jb && e !== Wb && e !== qb && e !== $b && e !== Mb && e !== Ob && e !== Hb && e !== Ub;
}
u(n0, "isPlainSafeFirst");
function o0(e) {
  return !Ka(e) && e !== Kn;
}
u(o0, "isPlainSafeLast");
function ws(e, t) {
  var r = e.charCodeAt(t), i;
  return r >= 55296 && r <= 56319 && t + 1 < e.length && (i = e.charCodeAt(t + 1), i >= 56320 && i <= 57343) ? (r - 55296) * 1024 + i - 56320 + 65536 : r;
}
u(ws, "codePointAt");
function $c(e) {
  var t = /^\n* /;
  return t.test(e);
}
u($c, "needIndentIndicator");
var l0 = 1, Al = 2, c0 = 3, h0 = 4, bs = 5;
function u0(e, t, r, i, s, a, n, o) {
  var h, l = 0, d = null, p = !1, g = !1, f = i !== -1, y = -1, m = n0(ws(e, 0)) && o0(ws(e, e.length - 1));
  if (t || n)
    for (h = 0; h < e.length; l >= 65536 ? h += 2 : h++) {
      if (l = ws(e, h), !fa(l))
        return bs;
      m = m && El(l, d, o), d = l;
    }
  else {
    for (h = 0; h < e.length; l >= 65536 ? h += 2 : h++) {
      if (l = ws(e, h), l === Ga)
        p = !0, f && (g = g || // Foldable line = too long, and not more-indented.
        h - y - 1 > i && e[y + 1] !== " ", y = h);
      else if (!fa(l))
        return bs;
      m = m && El(l, d, o), d = l;
    }
    g = g || f && h - y - 1 > i && e[y + 1] !== " ";
  }
  return !p && !g ? m && !n && !s(e) ? l0 : a === Xa ? bs : Al : r > 9 && $c(e) ? bs : n ? a === Xa ? bs : Al : g ? h0 : c0;
}
u(u0, "chooseScalarStyle");
function d0(e, t, r, i, s) {
  e.dump = function() {
    if (t.length === 0)
      return e.quotingType === Xa ? '""' : "''";
    if (!e.noCompatMode && (Gb.indexOf(t) !== -1 || Xb.test(t)))
      return e.quotingType === Xa ? '"' + t + '"' : "'" + t + "'";
    var a = e.indent * Math.max(1, r), n = e.lineWidth === -1 ? -1 : Math.max(Math.min(e.lineWidth, 40), e.lineWidth - a), o = i || e.flowLevel > -1 && r >= e.flowLevel;
    function h(l) {
      return a0(e, l);
    }
    switch (u(h, "testAmbiguity"), u0(
      t,
      o,
      e.indent,
      n,
      h,
      e.quotingType,
      e.forceQuotes && !i,
      s
    )) {
      case l0:
        return t;
      case Al:
        return "'" + t.replace(/'/g, "''") + "'";
      case c0:
        return "|" + Ll(t, e.indent) + Bl(Tl(t, a));
      case h0:
        return ">" + Ll(t, e.indent) + Bl(Tl(p0(t, n), a));
      case bs:
        return '"' + g0(t) + '"';
      default:
        throw new xr("impossible error: invalid scalar style");
    }
  }();
}
u(d0, "writeScalar");
function Ll(e, t) {
  var r = $c(e) ? String(t) : "", i = e[e.length - 1] === `
`, s = i && (e[e.length - 2] === `
` || e === `
`), a = s ? "+" : i ? "" : "-";
  return r + a + `
`;
}
u(Ll, "blockHeader");
function Bl(e) {
  return e[e.length - 1] === `
` ? e.slice(0, -1) : e;
}
u(Bl, "dropEndingNewline");
function p0(e, t) {
  for (var r = /(\n+)([^\n]*)/g, i = function() {
    var l = e.indexOf(`
`);
    return l = l !== -1 ? l : e.length, r.lastIndex = l, Dl(e.slice(0, l), t);
  }(), s = e[0] === `
` || e[0] === " ", a, n; n = r.exec(e); ) {
    var o = n[1], h = n[2];
    a = h[0] === " ", i += o + (!s && !a && h !== "" ? `
` : "") + Dl(h, t), s = a;
  }
  return i;
}
u(p0, "foldString");
function Dl(e, t) {
  if (e === "" || e[0] === " ") return e;
  for (var r = / [^ ]/g, i, s = 0, a, n = 0, o = 0, h = ""; i = r.exec(e); )
    o = i.index, o - s > t && (a = n > s ? n : o, h += `
` + e.slice(s, a), s = a + 1), n = o;
  return h += `
`, e.length - s > t && n > s ? h += e.slice(s, n) + `
` + e.slice(n + 1) : h += e.slice(s), h.slice(1);
}
u(Dl, "foldLine");
function g0(e) {
  for (var t = "", r = 0, i, s = 0; s < e.length; r >= 65536 ? s += 2 : s++)
    r = ws(e, s), i = nr[r], !i && fa(r) ? (t += e[s], r >= 65536 && (t += e[s + 1])) : t += i || i0(r);
  return t;
}
u(g0, "escapeString");
function f0(e, t, r) {
  var i = "", s = e.tag, a, n, o;
  for (a = 0, n = r.length; a < n; a += 1)
    o = r[a], e.replacer && (o = e.replacer.call(r, String(a), o)), (Kr(e, t, o, !1, !1) || typeof o > "u" && Kr(e, t, null, !1, !1)) && (i !== "" && (i += "," + (e.condenseFlow ? "" : " ")), i += e.dump);
  e.tag = s, e.dump = "[" + i + "]";
}
u(f0, "writeFlowSequence");
function Il(e, t, r, i) {
  var s = "", a = e.tag, n, o, h;
  for (n = 0, o = r.length; n < o; n += 1)
    h = r[n], e.replacer && (h = e.replacer.call(r, String(n), h)), (Kr(e, t + 1, h, !0, !0, !1, !0) || typeof h > "u" && Kr(e, t + 1, null, !0, !0, !1, !0)) && ((!i || s !== "") && (s += Qn(e, t)), e.dump && Ga === e.dump.charCodeAt(0) ? s += "-" : s += "- ", s += e.dump);
  e.tag = a, e.dump = s || "[]";
}
u(Il, "writeBlockSequence");
function y0(e, t, r) {
  var i = "", s = e.tag, a = Object.keys(r), n, o, h, l, d;
  for (n = 0, o = a.length; n < o; n += 1)
    d = "", i !== "" && (d += ", "), e.condenseFlow && (d += '"'), h = a[n], l = r[h], e.replacer && (l = e.replacer.call(r, h, l)), Kr(e, t, h, !1, !1) && (e.dump.length > 1024 && (d += "? "), d += e.dump + (e.condenseFlow ? '"' : "") + ":" + (e.condenseFlow ? "" : " "), Kr(e, t, l, !1, !1) && (d += e.dump, i += d));
  e.tag = s, e.dump = "{" + i + "}";
}
u(y0, "writeFlowMapping");
function m0(e, t, r, i) {
  var s = "", a = e.tag, n = Object.keys(r), o, h, l, d, p, g;
  if (e.sortKeys === !0)
    n.sort();
  else if (typeof e.sortKeys == "function")
    n.sort(e.sortKeys);
  else if (e.sortKeys)
    throw new xr("sortKeys must be a boolean or a function");
  for (o = 0, h = n.length; o < h; o += 1)
    g = "", (!i || s !== "") && (g += Qn(e, t)), l = n[o], d = r[l], e.replacer && (d = e.replacer.call(r, l, d)), Kr(e, t + 1, l, !0, !0, !0) && (p = e.tag !== null && e.tag !== "?" || e.dump && e.dump.length > 1024, p && (e.dump && Ga === e.dump.charCodeAt(0) ? g += "?" : g += "? "), g += e.dump, p && (g += Qn(e, t)), Kr(e, t + 1, d, !0, p) && (e.dump && Ga === e.dump.charCodeAt(0) ? g += ":" : g += ": ", g += e.dump, s += g));
  e.tag = a, e.dump = s || "{}";
}
u(m0, "writeBlockMapping");
function Fl(e, t, r) {
  var i, s, a, n, o, h;
  for (s = r ? e.explicitTypes : e.implicitTypes, a = 0, n = s.length; a < n; a += 1)
    if (o = s[a], (o.instanceOf || o.predicate) && (!o.instanceOf || typeof t == "object" && t instanceof o.instanceOf) && (!o.predicate || o.predicate(t))) {
      if (r ? o.multi && o.representName ? e.tag = o.representName(t) : e.tag = o.tag : e.tag = "?", o.represent) {
        if (h = e.styleMap[o.tag] || o.defaultStyle, X1.call(o.represent) === "[object Function]")
          i = o.represent(t, h);
        else if (K1.call(o.represent, h))
          i = o.represent[h](t, h);
        else
          throw new xr("!<" + o.tag + '> tag resolver accepts not "' + h + '" style');
        e.dump = i;
      }
      return !0;
    }
  return !1;
}
u(Fl, "detectType");
function Kr(e, t, r, i, s, a, n) {
  e.tag = null, e.dump = r, Fl(e, r, !1) || Fl(e, r, !0);
  var o = X1.call(e.dump), h = i, l;
  i && (i = e.flowLevel < 0 || e.flowLevel > t);
  var d = o === "[object Object]" || o === "[object Array]", p, g;
  if (d && (p = e.duplicates.indexOf(r), g = p !== -1), (e.tag !== null && e.tag !== "?" || g || e.indent !== 2 && t > 0) && (s = !1), g && e.usedDuplicates[p])
    e.dump = "*ref_" + p;
  else {
    if (d && g && !e.usedDuplicates[p] && (e.usedDuplicates[p] = !0), o === "[object Object]")
      i && Object.keys(e.dump).length !== 0 ? (m0(e, t, e.dump, s), g && (e.dump = "&ref_" + p + e.dump)) : (y0(e, t, e.dump), g && (e.dump = "&ref_" + p + " " + e.dump));
    else if (o === "[object Array]")
      i && e.dump.length !== 0 ? (e.noArrayIndent && !n && t > 0 ? Il(e, t - 1, e.dump, s) : Il(e, t, e.dump, s), g && (e.dump = "&ref_" + p + e.dump)) : (f0(e, t, e.dump), g && (e.dump = "&ref_" + p + " " + e.dump));
    else if (o === "[object String]")
      e.tag !== "?" && d0(e, e.dump, t, a, h);
    else {
      if (o === "[object Undefined]")
        return !1;
      if (e.skipInvalid) return !1;
      throw new xr("unacceptable kind of an object to dump " + o);
    }
    e.tag !== null && e.tag !== "?" && (l = encodeURI(
      e.tag[0] === "!" ? e.tag.slice(1) : e.tag
    ).replace(/!/g, "%21"), e.tag[0] === "!" ? l = "!" + l : l.slice(0, 18) === "tag:yaml.org,2002:" ? l = "!!" + l.slice(18) : l = "!<" + l + ">", e.dump = l + " " + e.dump);
  }
  return !0;
}
u(Kr, "writeNode");
function x0(e, t) {
  var r = [], i = [], s, a;
  for (Zn(e, r, i), s = 0, a = i.length; s < a; s += 1)
    t.duplicates.push(r[i[s]]);
  t.usedDuplicates = new Array(a);
}
u(x0, "getDuplicateReferences");
function Zn(e, t, r) {
  var i, s, a;
  if (e !== null && typeof e == "object")
    if (s = t.indexOf(e), s !== -1)
      r.indexOf(s) === -1 && r.push(s);
    else if (t.push(e), Array.isArray(e))
      for (s = 0, a = e.length; s < a; s += 1)
        Zn(e[s], t, r);
    else
      for (i = Object.keys(e), s = 0, a = i.length; s < a; s += 1)
        Zn(e[i[s]], t, r);
}
u(Zn, "inspectNode");
function Qb(e, t) {
  t = t || {};
  var r = new s0(t);
  r.noRefs || x0(e, r);
  var i = e;
  return r.replacer && (i = r.replacer.call({ "": i }, "", i)), Kr(r, 0, i, !0, !0) ? r.dump + `
` : "";
}
u(Qb, "dump$1");
function Zb(e, t) {
  return function() {
    throw new Error("Function yaml." + e + " is removed in js-yaml 4. Use yaml." + t + " instead, which is now safe by default.");
  };
}
u(Zb, "renamed");
var Do = c1, Io = Db.load;
/*! Bundled license information:

js-yaml/dist/js-yaml.mjs:
  (*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT *)
*/
var er = {
  aggregation: 17.25,
  extension: 17.25,
  composition: 17.25,
  dependency: 6,
  lollipop: 13.5,
  arrow_point: 4
  //arrow_cross: 24,
}, cu = {
  arrow_point: 9,
  arrow_cross: 12.5,
  arrow_circle: 12.5
};
function Ba(e, t) {
  if (e === void 0 || t === void 0)
    return { angle: 0, deltaX: 0, deltaY: 0 };
  e = we(e), t = we(t);
  const [r, i] = [e.x, e.y], [s, a] = [t.x, t.y], n = s - r, o = a - i;
  return { angle: Math.atan(o / n), deltaX: n, deltaY: o };
}
u(Ba, "calculateDeltaAndAngle");
var we = /* @__PURE__ */ u((e) => Array.isArray(e) ? { x: e[0], y: e[1] } : e, "pointTransformer"), b0 = /* @__PURE__ */ u((e) => ({
  x: /* @__PURE__ */ u(function(t, r, i) {
    let s = 0;
    const a = we(i[0]).x < we(i[i.length - 1]).x ? "left" : "right";
    if (r === 0 && Object.hasOwn(er, e.arrowTypeStart)) {
      const { angle: f, deltaX: y } = Ba(i[0], i[1]);
      s = er[e.arrowTypeStart] * Math.cos(f) * (y >= 0 ? 1 : -1);
    } else if (r === i.length - 1 && Object.hasOwn(er, e.arrowTypeEnd)) {
      const { angle: f, deltaX: y } = Ba(
        i[i.length - 1],
        i[i.length - 2]
      );
      s = er[e.arrowTypeEnd] * Math.cos(f) * (y >= 0 ? 1 : -1);
    }
    const n = Math.abs(
      we(t).x - we(i[i.length - 1]).x
    ), o = Math.abs(
      we(t).y - we(i[i.length - 1]).y
    ), h = Math.abs(we(t).x - we(i[0]).x), l = Math.abs(we(t).y - we(i[0]).y), d = er[e.arrowTypeStart], p = er[e.arrowTypeEnd], g = 1;
    if (n < p && n > 0 && o < p) {
      let f = p + g - n;
      f *= a === "right" ? -1 : 1, s -= f;
    }
    if (h < d && h > 0 && l < d) {
      let f = d + g - h;
      f *= a === "right" ? -1 : 1, s += f;
    }
    return we(t).x + s;
  }, "x"),
  y: /* @__PURE__ */ u(function(t, r, i) {
    let s = 0;
    const a = we(i[0]).y < we(i[i.length - 1]).y ? "down" : "up";
    if (r === 0 && Object.hasOwn(er, e.arrowTypeStart)) {
      const { angle: f, deltaY: y } = Ba(i[0], i[1]);
      s = er[e.arrowTypeStart] * Math.abs(Math.sin(f)) * (y >= 0 ? 1 : -1);
    } else if (r === i.length - 1 && Object.hasOwn(er, e.arrowTypeEnd)) {
      const { angle: f, deltaY: y } = Ba(
        i[i.length - 1],
        i[i.length - 2]
      );
      s = er[e.arrowTypeEnd] * Math.abs(Math.sin(f)) * (y >= 0 ? 1 : -1);
    }
    const n = Math.abs(
      we(t).y - we(i[i.length - 1]).y
    ), o = Math.abs(
      we(t).x - we(i[i.length - 1]).x
    ), h = Math.abs(we(t).y - we(i[0]).y), l = Math.abs(we(t).x - we(i[0]).x), d = er[e.arrowTypeStart], p = er[e.arrowTypeEnd], g = 1;
    if (n < p && n > 0 && o < p) {
      let f = p + g - n;
      f *= a === "up" ? -1 : 1, s -= f;
    }
    if (h < d && h > 0 && l < d) {
      let f = d + g - h;
      f *= a === "up" ? -1 : 1, s += f;
    }
    return we(t).y + s;
  }, "y")
}), "getLineFunctionsWithOffset"), gn = /* @__PURE__ */ u(({
  flowchart: e
}) => {
  var s, a;
  const t = ((s = e == null ? void 0 : e.subGraphTitleMargin) == null ? void 0 : s.top) ?? 0, r = ((a = e == null ? void 0 : e.subGraphTitleMargin) == null ? void 0 : a.bottom) ?? 0, i = t + r;
  return {
    subGraphTitleTopMargin: t,
    subGraphTitleBottomMargin: r,
    subGraphTitleTotalMargin: i
  };
}, "getSubGraphTitleMargins"), Jb = /* @__PURE__ */ u((e) => {
  const { handDrawnSeed: t } = K();
  return {
    fill: e,
    hachureAngle: 120,
    // angle of hachure,
    hachureGap: 4,
    fillWeight: 2,
    roughness: 0.7,
    stroke: e,
    seed: t
  };
}, "solidStateFill"), Sa = /* @__PURE__ */ u((e) => {
  const t = t3([
    ...e.cssCompiledStyles || [],
    ...e.cssStyles || [],
    ...e.labelStyle || []
  ]);
  return { stylesMap: t, stylesArray: [...t] };
}, "compileStyles"), t3 = /* @__PURE__ */ u((e) => {
  const t = /* @__PURE__ */ new Map();
  return e.forEach((r) => {
    const [i, s] = r.split(":");
    t.set(i.trim(), s == null ? void 0 : s.trim());
  }), t;
}, "styles2Map"), Vc = /* @__PURE__ */ u((e) => e === "color" || e === "font-size" || e === "font-family" || e === "font-weight" || e === "font-style" || e === "text-decoration" || e === "text-align" || e === "text-transform" || e === "line-height" || e === "letter-spacing" || e === "word-spacing" || e === "text-shadow" || e === "text-overflow" || e === "white-space" || e === "word-wrap" || e === "word-break" || e === "overflow-wrap" || e === "hyphens", "isLabelStyle"), It = /* @__PURE__ */ u((e) => {
  const { stylesArray: t } = Sa(e), r = [], i = [], s = [], a = [];
  return t.forEach((n) => {
    const o = n[0];
    Vc(o) ? r.push(n.join(":") + " !important") : (i.push(n.join(":") + " !important"), o.includes("stroke") && s.push(n.join(":") + " !important"), o === "fill" && a.push(n.join(":") + " !important"));
  }), {
    labelStyles: r.join(";"),
    nodeStyles: i.join(";"),
    stylesArray: t,
    borderStyles: s,
    backgroundStyles: a
  };
}, "styles2String"), Ot = /* @__PURE__ */ u((e, t) => {
  var h;
  const { themeVariables: r, handDrawnSeed: i } = K(), { nodeBorder: s, mainBkg: a } = r, { stylesMap: n } = Sa(e);
  return Object.assign(
    {
      roughness: 0.7,
      fill: n.get("fill") || a,
      fillStyle: "hachure",
      // solid fill
      fillWeight: 4,
      hachureGap: 5.2,
      stroke: n.get("stroke") || s,
      seed: i,
      strokeWidth: ((h = n.get("stroke-width")) == null ? void 0 : h.replace("px", "")) || 1.3,
      fillLineDash: [0, 0],
      strokeLineDash: e3(n.get("stroke-dasharray"))
    },
    t
  );
}, "userNodeOverrides"), e3 = /* @__PURE__ */ u((e) => {
  if (!e)
    return [0, 0];
  const t = e.trim().split(/\s+/).map(Number);
  if (t.length === 1) {
    const s = isNaN(t[0]) ? 0 : t[0];
    return [s, s];
  }
  const r = isNaN(t[0]) ? 0 : t[0], i = isNaN(t[1]) ? 0 : t[1];
  return [r, i];
}, "getStrokeDashArray"), k0 = "", r3 = {
  curveBasis: _s,
  curveBasisClosed: Cm,
  curveBasisOpen: Sm,
  curveBumpX: bd,
  curveBumpY: xd,
  curveBundle: vm,
  curveCardinalClosed: km,
  curveCardinalOpen: bm,
  curveCardinal: md,
  curveCatmullRomClosed: xm,
  curveCatmullRomOpen: mm,
  curveCatmullRom: yd,
  curveLinear: ul,
  curveLinearClosed: ym,
  curveMonotoneX: fd,
  curveMonotoneY: gd,
  curveNatural: pd,
  curveStep: dd,
  curveStepAfter: ud,
  curveStepBefore: hd
}, i3 = /\s*(?:(\w+)(?=:):|(\w+))\s*(?:(\w+)|((?:(?!}%{2}).|\r?\n)*))?\s*(?:}%{2})?/gi, s3 = /* @__PURE__ */ u(function(e, t) {
  const r = v0(e, /(?:init\b)|(?:initialize\b)/);
  let i = {};
  if (Array.isArray(r)) {
    const n = r.map((o) => o.args);
    Wn(n), i = De(i, [...n]);
  } else
    i = r.args;
  if (!i)
    return;
  let s = _c(e, t);
  const a = "config";
  return i[a] !== void 0 && (s === "flowchart-v2" && (s = "flowchart"), i[s] = i[a], delete i[a]), i;
}, "detectInit"), v0 = /* @__PURE__ */ u(function(e, t = null) {
  var r, i;
  try {
    const s = new RegExp(
      `[%]{2}(?![{]${i3.source})(?=[}][%]{2}).*
`,
      "ig"
    );
    e = e.trim().replace(s, "").replace(/'/gm, '"'), I.debug(
      `Detecting diagram directive${t !== null ? " type:" + t : ""} based on the text:${e}`
    );
    let a;
    const n = [];
    for (; (a = za.exec(e)) !== null; )
      if (a.index === za.lastIndex && za.lastIndex++, a && !t || t && ((r = a[1]) != null && r.match(t)) || t && ((i = a[2]) != null && i.match(t))) {
        const o = a[1] ? a[1] : a[2], h = a[3] ? a[3].trim() : a[4] ? JSON.parse(a[4].trim()) : null;
        n.push({ type: o, args: h });
      }
    return n.length === 0 ? { type: e, args: null } : n.length === 1 ? n[0] : n;
  } catch (s) {
    return I.error(
      `ERROR: ${s.message} - Unable to parse directive type: '${t}' based on the text: '${e}'`
    ), { type: void 0, args: null };
  }
}, "detectDirective"), a3 = /* @__PURE__ */ u(function(e) {
  return e.replace(za, "");
}, "removeDirectives"), n3 = /* @__PURE__ */ u(function(e, t) {
  for (const [r, i] of t.entries())
    if (i.match(e))
      return r;
  return -1;
}, "isSubstringInArray");
function zc(e, t) {
  if (!e)
    return t;
  const r = `curve${e.charAt(0).toUpperCase() + e.slice(1)}`;
  return r3[r] ?? t;
}
u(zc, "interpolateToCurve");
function S0(e, t) {
  const r = e.trim();
  if (r)
    return t.securityLevel !== "loose" ? ns(r) : r;
}
u(S0, "formatUrl");
var o3 = /* @__PURE__ */ u((e, ...t) => {
  const r = e.split("."), i = r.length - 1, s = r[i];
  let a = window;
  for (let n = 0; n < i; n++)
    if (a = a[r[n]], !a) {
      I.error(`Function name: ${e} not found in window`);
      return;
    }
  a[s](...t);
}, "runFunc");
function Wc(e, t) {
  return !e || !t ? 0 : Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2));
}
u(Wc, "distance");
function C0(e) {
  let t, r = 0;
  e.forEach((s) => {
    r += Wc(s, t), t = s;
  });
  const i = r / 2;
  return qc(e, i);
}
u(C0, "traverseEdge");
function w0(e) {
  return e.length === 1 ? e[0] : C0(e);
}
u(w0, "calcLabelPosition");
var hu = /* @__PURE__ */ u((e, t = 2) => {
  const r = Math.pow(10, t);
  return Math.round(e * r) / r;
}, "roundNumber"), qc = /* @__PURE__ */ u((e, t) => {
  let r, i = t;
  for (const s of e) {
    if (r) {
      const a = Wc(s, r);
      if (a === 0)
        return r;
      if (a < i)
        i -= a;
      else {
        const n = i / a;
        if (n <= 0)
          return r;
        if (n >= 1)
          return { x: s.x, y: s.y };
        if (n > 0 && n < 1)
          return {
            x: hu((1 - n) * r.x + n * s.x, 5),
            y: hu((1 - n) * r.y + n * s.y, 5)
          };
      }
    }
    r = s;
  }
  throw new Error("Could not find a suitable point for the given distance");
}, "calculatePoint"), l3 = /* @__PURE__ */ u((e, t, r) => {
  I.info(`our points ${JSON.stringify(t)}`), t[0] !== r && (t = t.reverse());
  const s = qc(t, 25), a = e ? 10 : 5, n = Math.atan2(t[0].y - s.y, t[0].x - s.x), o = { x: 0, y: 0 };
  return o.x = Math.sin(n) * a + (t[0].x + s.x) / 2, o.y = -Math.cos(n) * a + (t[0].y + s.y) / 2, o;
}, "calcCardinalityPosition");
function T0(e, t, r) {
  const i = structuredClone(r);
  I.info("our points", i), t !== "start_left" && t !== "start_right" && i.reverse();
  const s = 25 + e, a = qc(i, s), n = 10 + e * 0.5, o = Math.atan2(i[0].y - a.y, i[0].x - a.x), h = { x: 0, y: 0 };
  return t === "start_left" ? (h.x = Math.sin(o + Math.PI) * n + (i[0].x + a.x) / 2, h.y = -Math.cos(o + Math.PI) * n + (i[0].y + a.y) / 2) : t === "end_right" ? (h.x = Math.sin(o - Math.PI) * n + (i[0].x + a.x) / 2 - 5, h.y = -Math.cos(o - Math.PI) * n + (i[0].y + a.y) / 2 - 5) : t === "end_left" ? (h.x = Math.sin(o) * n + (i[0].x + a.x) / 2 - 5, h.y = -Math.cos(o) * n + (i[0].y + a.y) / 2 - 5) : (h.x = Math.sin(o) * n + (i[0].x + a.x) / 2, h.y = -Math.cos(o) * n + (i[0].y + a.y) / 2), h;
}
u(T0, "calcTerminalLabelPosition");
function Yc(e) {
  let t = "", r = "";
  for (const i of e)
    i !== void 0 && (i.startsWith("color:") || i.startsWith("text-align:") ? r = r + i + ";" : t = t + i + ";");
  return { style: t, labelStyle: r };
}
u(Yc, "getStylesFromArray");
var uu = 0, _0 = /* @__PURE__ */ u(() => (uu++, "id-" + Math.random().toString(36).substr(2, 12) + "-" + uu), "generateId");
function E0(e) {
  let t = "";
  const r = "0123456789abcdef", i = r.length;
  for (let s = 0; s < e; s++)
    t += r.charAt(Math.floor(Math.random() * i));
  return t;
}
u(E0, "makeRandomHex");
var A0 = /* @__PURE__ */ u((e) => E0(e.length), "random"), c3 = /* @__PURE__ */ u(function() {
  return {
    x: 0,
    y: 0,
    fill: void 0,
    anchor: "start",
    style: "#666",
    width: 100,
    height: 100,
    textMargin: 0,
    rx: 0,
    ry: 0,
    valign: void 0,
    text: ""
  };
}, "getTextObj"), h3 = /* @__PURE__ */ u(function(e, t) {
  const r = t.text.replace(St.lineBreakRegex, " "), [, i] = ls(t.fontSize), s = e.append("text");
  s.attr("x", t.x), s.attr("y", t.y), s.style("text-anchor", t.anchor), s.style("font-family", t.fontFamily), s.style("font-size", i), s.style("font-weight", t.fontWeight), s.attr("fill", t.fill), t.class !== void 0 && s.attr("class", t.class);
  const a = s.append("tspan");
  return a.attr("x", t.x + t.textMargin * 2), a.attr("fill", t.fill), a.text(r), s;
}, "drawSimpleText"), L0 = Cc(
  (e, t, r) => {
    if (!e || (r = Object.assign(
      { fontSize: 12, fontWeight: 400, fontFamily: "Arial", joinWith: "<br/>" },
      r
    ), St.lineBreakRegex.test(e)))
      return e;
    const i = e.split(" ").filter(Boolean), s = [];
    let a = "";
    return i.forEach((n, o) => {
      const h = dr(`${n} `, r), l = dr(a, r);
      if (h > t) {
        const { hyphenatedStrings: g, remainingWord: f } = u3(n, t, "-", r);
        s.push(a, ...g), a = f;
      } else l + h >= t ? (s.push(a), a = n) : a = [a, n].filter(Boolean).join(" ");
      o + 1 === i.length && s.push(a);
    }), s.filter((n) => n !== "").join(r.joinWith);
  },
  (e, t, r) => `${e}${t}${r.fontSize}${r.fontWeight}${r.fontFamily}${r.joinWith}`
), u3 = Cc(
  (e, t, r = "-", i) => {
    i = Object.assign(
      { fontSize: 12, fontWeight: 400, fontFamily: "Arial", margin: 0 },
      i
    );
    const s = [...e], a = [];
    let n = "";
    return s.forEach((o, h) => {
      const l = `${n}${o}`;
      if (dr(l, i) >= t) {
        const p = h + 1, g = s.length === p, f = `${l}${r}`;
        a.push(g ? l : f), n = "";
      } else
        n = l;
    }), { hyphenatedStrings: a, remainingWord: n };
  },
  (e, t, r = "-", i) => `${e}${t}${r}${i.fontSize}${i.fontWeight}${i.fontFamily}`
);
function Jn(e, t) {
  return Hc(e, t).height;
}
u(Jn, "calculateTextHeight");
function dr(e, t) {
  return Hc(e, t).width;
}
u(dr, "calculateTextWidth");
var Hc = Cc(
  (e, t) => {
    const { fontSize: r = 12, fontFamily: i = "Arial", fontWeight: s = 400 } = t;
    if (!e)
      return { width: 0, height: 0 };
    const [, a] = ls(r), n = ["sans-serif", i], o = e.split(St.lineBreakRegex), h = [], l = yt("body");
    if (!l.remove)
      return { width: 0, height: 0, lineHeight: 0 };
    const d = l.append("svg");
    for (const g of n) {
      let f = 0;
      const y = { width: 0, height: 0, lineHeight: 0 };
      for (const m of o) {
        const x = c3();
        x.text = m || k0;
        const b = h3(d, x).style("font-size", a).style("font-weight", s).style("font-family", g), v = (b._groups || b)[0][0].getBBox();
        if (v.width === 0 && v.height === 0)
          throw new Error("svg element not in render tree");
        y.width = Math.round(Math.max(y.width, v.width)), f = Math.round(v.height), y.height += f, y.lineHeight = Math.round(Math.max(y.lineHeight, f));
      }
      h.push(y);
    }
    d.remove();
    const p = isNaN(h[1].height) || isNaN(h[1].width) || isNaN(h[1].lineHeight) || h[0].height > h[1].height && h[0].width > h[1].width && h[0].lineHeight > h[1].lineHeight ? 0 : 1;
    return h[p];
  },
  (e, t) => `${e}${t.fontSize}${t.fontWeight}${t.fontFamily}`
), Os, d3 = (Os = class {
  constructor(t = !1, r) {
    this.count = 0, this.count = r ? r.length : 0, this.next = t ? () => this.count++ : () => Date.now();
  }
}, u(Os, "InitIDGenerator"), Os), wn, p3 = /* @__PURE__ */ u(function(e) {
  return wn = wn || document.createElement("div"), e = escape(e).replace(/%26/g, "&").replace(/%23/g, "#").replace(/%3B/g, ";"), wn.innerHTML = e, unescape(wn.textContent);
}, "entityDecode");
function Uc(e) {
  return "str" in e;
}
u(Uc, "isDetailedError");
var g3 = /* @__PURE__ */ u((e, t, r, i) => {
  var a;
  if (!i)
    return;
  const s = (a = e.node()) == null ? void 0 : a.getBBox();
  s && e.append("text").text(i).attr("text-anchor", "middle").attr("x", s.x + s.width / 2).attr("y", -r).attr("class", t);
}, "insertTitle"), ls = /* @__PURE__ */ u((e) => {
  if (typeof e == "number")
    return [e, e + "px"];
  const t = parseInt(e ?? "", 10);
  return Number.isNaN(t) ? [void 0, void 0] : e === String(t) ? [t, e + "px"] : [t, e];
}, "parseFontSize");
function gr(e, t) {
  return wm({}, e, t);
}
u(gr, "cleanAndMerge");
var ee = {
  assignWithDepth: De,
  wrapLabel: L0,
  calculateTextHeight: Jn,
  calculateTextWidth: dr,
  calculateTextDimensions: Hc,
  cleanAndMerge: gr,
  detectInit: s3,
  detectDirective: v0,
  isSubstringInArray: n3,
  interpolateToCurve: zc,
  calcLabelPosition: w0,
  calcCardinalityPosition: l3,
  calcTerminalLabelPosition: T0,
  formatUrl: S0,
  getStylesFromArray: Yc,
  generateId: _0,
  random: A0,
  runFunc: o3,
  entityDecode: p3,
  insertTitle: g3,
  isLabelCoordinateInPath: B0,
  parseFontSize: ls,
  InitIDGenerator: d3
}, f3 = /* @__PURE__ */ u(function(e) {
  let t = e;
  return t = t.replace(/style.*:\S*#.*;/g, function(r) {
    return r.substring(0, r.length - 1);
  }), t = t.replace(/classDef.*:\S*#.*;/g, function(r) {
    return r.substring(0, r.length - 1);
  }), t = t.replace(/#\w+;/g, function(r) {
    const i = r.substring(1, r.length - 1);
    return /^\+?\d+$/.test(i) ? "" + i + "" : "" + i + "";
  }), t;
}, "encodeEntities"), Qr = /* @__PURE__ */ u(function(e) {
  return e.replace(//g, "&#").replace(//g, "&").replace(//g, ";");
}, "decodeEntities"), Es = /* @__PURE__ */ u((e, t, {
  counter: r = 0,
  prefix: i,
  suffix: s
}, a) => a || `${i ? `${i}_` : ""}${e}_${t}_${r}${s ? `_${s}` : ""}`, "getEdgeId");
function ar(e) {
  return e ?? null;
}
u(ar, "handleUndefinedAttr");
function B0(e, t) {
  const r = Math.round(e.x), i = Math.round(e.y), s = t.replace(
    /(\d+\.\d+)/g,
    (a) => Math.round(parseFloat(a)).toString()
  );
  return s.includes(r.toString()) || s.includes(i.toString());
}
u(B0, "isLabelCoordinateInPath");
var D0 = {
  body: '<g><rect width="80" height="80" style="fill: #087ebf; stroke-width: 0px;"/><text transform="translate(21.16 64.67)" style="fill: #fff; font-family: ArialMT, Arial; font-size: 67.75px;"><tspan x="0" y="0">?</tspan></text></g>',
  height: 80,
  width: 80
}, Nl = /* @__PURE__ */ new Map(), I0 = /* @__PURE__ */ new Map(), F0 = /* @__PURE__ */ u((e) => {
  for (const t of e) {
    if (!t.name)
      throw new Error(
        'Invalid icon loader. Must have a "name" property with non-empty string value.'
      );
    if (I.debug("Registering icon pack:", t.name), "loader" in t)
      I0.set(t.name, t.loader);
    else if ("icons" in t)
      Nl.set(t.name, t.icons);
    else
      throw I.error("Invalid icon loader:", t), new Error('Invalid icon loader. Must have either "icons" or "loader" property.');
  }
}, "registerIconPacks"), N0 = /* @__PURE__ */ u(async (e, t) => {
  const r = Am(e, !0, t !== void 0);
  if (!r)
    throw new Error(`Invalid icon name: ${e}`);
  const i = r.prefix || t;
  if (!i)
    throw new Error(`Icon name must contain a prefix: ${e}`);
  let s = Nl.get(i);
  if (!s) {
    const n = I0.get(i);
    if (!n)
      throw new Error(`Icon set not found: ${r.prefix}`);
    try {
      s = { ...await n(), prefix: i }, Nl.set(i, s);
    } catch (o) {
      throw I.error(o), new Error(`Failed to load icon set: ${r.prefix}`);
    }
  }
  const a = Lm(s, r.name);
  if (!a)
    throw new Error(`Icon not found: ${e}`);
  return a;
}, "getRegisteredIconData"), y3 = /* @__PURE__ */ u(async (e) => {
  try {
    return await N0(e), !0;
  } catch {
    return !1;
  }
}, "isIconAvailable"), Bi = /* @__PURE__ */ u(async (e, t, r) => {
  let i;
  try {
    i = await N0(e, t == null ? void 0 : t.fallbackPrefix);
  } catch (n) {
    I.error(n), i = D0;
  }
  const s = Tm(i, t), a = _m(Em(s.body), {
    ...s.attributes,
    ...r
  });
  return ge(a, fe());
}, "getIconSVG");
function R0(e, { markdownAutoWrap: t }) {
  const i = e.replace(/<br\/>/g, `
`).replace(/\n{2,}/g, `
`), s = vd(i);
  return t === !1 ? s.replace(/ /g, "&nbsp;") : s;
}
u(R0, "preprocessMarkdown");
function M0(e, t = {}) {
  const r = R0(e, t), i = kd.lexer(r), s = [[]];
  let a = 0;
  function n(o, h = "normal") {
    o.type === "text" ? o.text.split(`
`).forEach((d, p) => {
      p !== 0 && (a++, s.push([])), d.split(" ").forEach((g) => {
        g = g.replace(/&#39;/g, "'"), g && s[a].push({ content: g, type: h });
      });
    }) : o.type === "strong" || o.type === "em" ? o.tokens.forEach((l) => {
      n(l, o.type);
    }) : o.type === "html" && s[a].push({ content: o.text, type: "normal" });
  }
  return u(n, "processNode"), i.forEach((o) => {
    var h;
    o.type === "paragraph" ? (h = o.tokens) == null || h.forEach((l) => {
      n(l);
    }) : o.type === "html" ? s[a].push({ content: o.text, type: "normal" }) : s[a].push({ content: o.raw, type: "normal" });
  }), s;
}
u(M0, "markdownToLines");
function O0(e, { markdownAutoWrap: t } = {}) {
  const r = kd.lexer(e);
  function i(s) {
    var a, n, o;
    return s.type === "text" ? t === !1 ? s.text.replace(/\n */g, "<br/>").replace(/ /g, "&nbsp;") : s.text.replace(/\n */g, "<br/>") : s.type === "strong" ? `<strong>${(a = s.tokens) == null ? void 0 : a.map(i).join("")}</strong>` : s.type === "em" ? `<em>${(n = s.tokens) == null ? void 0 : n.map(i).join("")}</em>` : s.type === "paragraph" ? `<p>${(o = s.tokens) == null ? void 0 : o.map(i).join("")}</p>` : s.type === "space" ? "" : s.type === "html" ? `${s.text}` : s.type === "escape" ? s.text : (I.warn(`Unsupported markdown: ${s.type}`), s.raw);
  }
  return u(i, "output"), r.map(i).join("");
}
u(O0, "markdownToHTML");
function P0(e) {
  return Intl.Segmenter ? [...new Intl.Segmenter().segment(e)].map((t) => t.segment) : [...e];
}
u(P0, "splitTextToChars");
function $0(e, t) {
  const r = P0(t.content);
  return jc(e, [], r, t.type);
}
u($0, "splitWordToFitWidth");
function jc(e, t, r, i) {
  if (r.length === 0)
    return [
      { content: t.join(""), type: i },
      { content: "", type: i }
    ];
  const [s, ...a] = r, n = [...t, s];
  return e([{ content: n.join(""), type: i }]) ? jc(e, n, a, i) : (t.length === 0 && s && (t.push(s), r.shift()), [
    { content: t.join(""), type: i },
    { content: r.join(""), type: i }
  ]);
}
u(jc, "splitWordToFitWidthRecursion");
function V0(e, t) {
  if (e.some(({ content: r }) => r.includes(`
`)))
    throw new Error("splitLineToFitWidth does not support newlines in the line");
  return to(e, t);
}
u(V0, "splitLineToFitWidth");
function to(e, t, r = [], i = []) {
  if (e.length === 0)
    return i.length > 0 && r.push(i), r.length > 0 ? r : [];
  let s = "";
  e[0].content === " " && (s = " ", e.shift());
  const a = e.shift() ?? { content: " ", type: "normal" }, n = [...i];
  if (s !== "" && n.push({ content: s, type: "normal" }), n.push(a), t(n))
    return to(e, t, r, n);
  if (i.length > 0)
    r.push(i), e.unshift(a);
  else if (a.content) {
    const [o, h] = $0(t, a);
    r.push([o]), h.content && e.unshift(h);
  }
  return to(e, t, r);
}
u(to, "splitLineToFitWidthRecursion");
function Rl(e, t) {
  t && e.attr("style", t);
}
u(Rl, "applyStyle");
async function z0(e, t, r, i, s = !1, a = fe()) {
  const n = e.append("foreignObject");
  n.attr("width", `${10 * r}px`), n.attr("height", `${10 * r}px`);
  const o = n.append("xhtml:div"), h = Ee(t.label) ? await un(t.label.replace(St.lineBreakRegex, `
`), a) : ge(t.label, a), l = t.isNode ? "nodeLabel" : "edgeLabel", d = o.append("span");
  d.html(h), Rl(d, t.labelStyle), d.attr("class", `${l} ${i}`), Rl(o, t.labelStyle), o.style("display", "table-cell"), o.style("white-space", "nowrap"), o.style("line-height", "1.5"), o.style("max-width", r + "px"), o.style("text-align", "center"), o.attr("xmlns", "http://www.w3.org/1999/xhtml"), s && o.attr("class", "labelBkg");
  let p = o.node().getBoundingClientRect();
  return p.width === r && (o.style("display", "table"), o.style("white-space", "break-spaces"), o.style("width", r + "px"), p = o.node().getBoundingClientRect()), n.node();
}
u(z0, "addHtmlSpan");
function Fo(e, t, r) {
  return e.append("tspan").attr("class", "text-outer-tspan").attr("x", 0).attr("y", t * r - 0.1 + "em").attr("dy", r + "em");
}
u(Fo, "createTspan");
function W0(e, t, r) {
  const i = e.append("text"), s = Fo(i, 1, t);
  No(s, r);
  const a = s.node().getComputedTextLength();
  return i.remove(), a;
}
u(W0, "computeWidthOfText");
function q0(e, t, r) {
  var n;
  const i = e.append("text"), s = Fo(i, 1, t);
  No(s, [{ content: r, type: "normal" }]);
  const a = (n = s.node()) == null ? void 0 : n.getBoundingClientRect();
  return a && i.remove(), a;
}
u(q0, "computeDimensionOfText");
function Y0(e, t, r, i = !1) {
  const a = t.append("g"), n = a.insert("rect").attr("class", "background").attr("style", "stroke: none"), o = a.append("text").attr("y", "-10.1");
  let h = 0;
  for (const l of r) {
    const d = /* @__PURE__ */ u((g) => W0(a, 1.1, g) <= e, "checkWidth"), p = d(l) ? [l] : V0(l, d);
    for (const g of p) {
      const f = Fo(o, h, 1.1);
      No(f, g), h++;
    }
  }
  if (i) {
    const l = o.node().getBBox(), d = 2;
    return n.attr("x", l.x - d).attr("y", l.y - d).attr("width", l.width + 2 * d).attr("height", l.height + 2 * d), a.node();
  } else
    return o.node();
}
u(Y0, "createFormattedText");
function No(e, t) {
  e.text(""), t.forEach((r, i) => {
    const s = e.append("tspan").attr("font-style", r.type === "em" ? "italic" : "normal").attr("class", "text-inner-tspan").attr("font-weight", r.type === "strong" ? "bold" : "normal");
    i === 0 ? s.text(r.content) : s.text(" " + r.content);
  });
}
u(No, "updateTextContentAndStyles");
async function Gc(e, t = {}) {
  const r = [];
  e.replace(/(fa[bklrs]?):fa-([\w-]+)/g, (s, a, n) => (r.push(
    (async () => {
      const o = `${a}:${n}`;
      return await y3(o) ? await Bi(o, void 0, { class: "label-icon" }) : `<i class='${ge(s, t).replace(":", " ")}'></i>`;
    })()
  ), s));
  const i = await Promise.all(r);
  return e.replace(/(fa[bklrs]?):fa-([\w-]+)/g, () => i.shift() ?? "");
}
u(Gc, "replaceIconSubstring");
var _r = /* @__PURE__ */ u(async (e, t = "", {
  style: r = "",
  isTitle: i = !1,
  classes: s = "",
  useHtmlLabels: a = !0,
  isNode: n = !0,
  width: o = 200,
  addSvgBackground: h = !1
} = {}, l) => {
  if (I.debug(
    "XYZ createText",
    t,
    r,
    i,
    s,
    a,
    n,
    "addSvgBackground: ",
    h
  ), a) {
    const d = O0(t, l), p = await Gc(Qr(d), l), g = t.replace(/\\\\/g, "\\"), f = {
      isNode: n,
      label: Ee(t) ? g : p,
      labelStyle: r.replace("fill:", "color:")
    };
    return await z0(e, f, o, s, h, l);
  } else {
    const d = t.replace(/<br\s*\/?>/g, "<br/>"), p = M0(d.replace("<br>", "<br/>"), l), g = Y0(
      o,
      e,
      p,
      t ? h : !1
    );
    if (n) {
      /stroke:/.exec(r) && (r = r.replace("stroke:", "lineColor:"));
      const f = r.replace(/stroke:[^;]+;?/g, "").replace(/stroke-width:[^;]+;?/g, "").replace(/fill:[^;]+;?/g, "").replace(/color:/g, "fill:");
      yt(g).attr("style", f);
    } else {
      const f = r.replace(/stroke:[^;]+;?/g, "").replace(/stroke-width:[^;]+;?/g, "").replace(/fill:[^;]+;?/g, "").replace(/background:/g, "fill:");
      yt(g).select("rect").attr("style", f.replace(/background:/g, "fill:"));
      const y = r.replace(/stroke:[^;]+;?/g, "").replace(/stroke-width:[^;]+;?/g, "").replace(/fill:[^;]+;?/g, "").replace(/color:/g, "fill:");
      yt(g).select("text").attr("style", y);
    }
    return g;
  }
}, "createText"), Qt = /* @__PURE__ */ u(async (e, t, r) => {
  var p, g;
  let i;
  const s = t.useHtmlLabels || ke((p = K()) == null ? void 0 : p.htmlLabels);
  r ? i = r : i = "node default";
  const a = e.insert("g").attr("class", i).attr("id", t.domId || t.id), n = a.insert("g").attr("class", "label").attr("style", ar(t.labelStyle));
  let o;
  t.label === void 0 ? o = "" : o = typeof t.label == "string" ? t.label : t.label[0];
  const h = await _r(n, ge(Qr(o), K()), {
    useHtmlLabels: s,
    width: t.width || ((g = K().flowchart) == null ? void 0 : g.wrappingWidth),
    // @ts-expect-error -- This is currently not used. Should this be `classes` instead?
    cssClasses: "markdown-node-label",
    style: t.labelStyle,
    addSvgBackground: !!t.icon || !!t.img
  });
  let l = h.getBBox();
  const d = ((t == null ? void 0 : t.padding) ?? 0) / 2;
  if (s) {
    const f = h.children[0], y = yt(h), m = f.getElementsByTagName("img");
    if (m) {
      const x = o.replace(/<img[^>]*>/g, "").trim() === "";
      await Promise.all(
        [...m].map(
          (b) => new Promise((v) => {
            function _() {
              if (b.style.display = "flex", b.style.flexDirection = "column", x) {
                const A = K().fontSize ? K().fontSize : window.getComputedStyle(document.body).fontSize, S = 5, [k = de.fontSize] = ls(A), L = k * S + "px";
                b.style.minWidth = L, b.style.maxWidth = L;
              } else
                b.style.width = "100%";
              v(b);
            }
            u(_, "setupImage"), setTimeout(() => {
              b.complete && _();
            }), b.addEventListener("error", _), b.addEventListener("load", _);
          })
        )
      );
    }
    l = f.getBoundingClientRect(), y.attr("width", l.width), y.attr("height", l.height);
  }
  return s ? n.attr("transform", "translate(" + -l.width / 2 + ", " + -l.height / 2 + ")") : n.attr("transform", "translate(0, " + -l.height / 2 + ")"), t.centerLabel && n.attr("transform", "translate(" + -l.width / 2 + ", " + -l.height / 2 + ")"), n.insert("rect", ":first-child"), { shapeSvg: a, bbox: l, halfPadding: d, label: n };
}, "labelHelper"), sl = /* @__PURE__ */ u(async (e, t, r) => {
  var h, l, d, p, g, f;
  const i = r.useHtmlLabels || ke((l = (h = K()) == null ? void 0 : h.flowchart) == null ? void 0 : l.htmlLabels), s = e.insert("g").attr("class", "label").attr("style", r.labelStyle || ""), a = await _r(s, ge(Qr(t), K()), {
    useHtmlLabels: i,
    width: r.width || ((p = (d = K()) == null ? void 0 : d.flowchart) == null ? void 0 : p.wrappingWidth),
    style: r.labelStyle,
    addSvgBackground: !!r.icon || !!r.img
  });
  let n = a.getBBox();
  const o = r.padding / 2;
  if (ke((f = (g = K()) == null ? void 0 : g.flowchart) == null ? void 0 : f.htmlLabels)) {
    const y = a.children[0], m = yt(a);
    n = y.getBoundingClientRect(), m.attr("width", n.width), m.attr("height", n.height);
  }
  return i ? s.attr("transform", "translate(" + -n.width / 2 + ", " + -n.height / 2 + ")") : s.attr("transform", "translate(0, " + -n.height / 2 + ")"), r.centerLabel && s.attr("transform", "translate(" + -n.width / 2 + ", " + -n.height / 2 + ")"), s.insert("rect", ":first-child"), { shapeSvg: e, bbox: n, halfPadding: o, label: s };
}, "insertLabel"), Pt = /* @__PURE__ */ u((e, t) => {
  const r = t.node().getBBox();
  e.width = r.width, e.height = r.height;
}, "updateNodeBounds"), Xt = /* @__PURE__ */ u((e, t) => (e.look === "handDrawn" ? "rough-node" : "node") + " " + e.cssClasses + " " + (t || ""), "getNodeClasses");
function ce(e) {
  const t = e.map((r, i) => `${i === 0 ? "M" : "L"}${r.x},${r.y}`);
  return t.push("Z"), t.join(" ");
}
u(ce, "createPathFromPoints");
function Di(e, t, r, i, s, a) {
  const n = [], h = r - e, l = i - t, d = h / a, p = 2 * Math.PI / d, g = t + l / 2;
  for (let f = 0; f <= 50; f++) {
    const y = f / 50, m = e + y * h, x = g + s * Math.sin(p * (m - e));
    n.push({ x: m, y: x });
  }
  return n;
}
u(Di, "generateFullSineWavePoints");
function Qa(e, t, r, i, s, a) {
  const n = [], o = s * Math.PI / 180, d = (a * Math.PI / 180 - o) / (i - 1);
  for (let p = 0; p < i; p++) {
    const g = o + p * d, f = e + r * Math.cos(g), y = t + r * Math.sin(g);
    n.push({ x: -f, y: -y });
  }
  return n;
}
u(Qa, "generateCirclePoints");
var m3 = /* @__PURE__ */ u((e, t) => {
  var r = e.x, i = e.y, s = t.x - r, a = t.y - i, n = e.width / 2, o = e.height / 2, h, l;
  return Math.abs(a) * n > Math.abs(s) * o ? (a < 0 && (o = -o), h = a === 0 ? 0 : o * s / a, l = o) : (s < 0 && (n = -n), h = n, l = s === 0 ? 0 : n * a / s), { x: r + h, y: i + l };
}, "intersectRect"), Ca = m3;
function H0(e, t) {
  t && e.attr("style", t);
}
u(H0, "applyStyle");
async function U0(e) {
  const t = yt(document.createElementNS("http://www.w3.org/2000/svg", "foreignObject")), r = t.append("xhtml:div"), i = K();
  let s = e.label;
  e.label && Ee(e.label) && (s = await un(e.label.replace(St.lineBreakRegex, `
`), i));
  const n = '<span class="' + (e.isNode ? "nodeLabel" : "edgeLabel") + '" ' + (e.labelStyle ? 'style="' + e.labelStyle + '"' : "") + // codeql [js/html-constructed-from-input] : false positive
  ">" + s + "</span>";
  return r.html(ge(n, i)), H0(r, e.labelStyle), r.style("display", "inline-block"), r.style("padding-right", "1px"), r.style("white-space", "nowrap"), r.attr("xmlns", "http://www.w3.org/1999/xhtml"), t.node();
}
u(U0, "addHtmlLabel");
var x3 = /* @__PURE__ */ u(async (e, t, r, i) => {
  let s = e || "";
  if (typeof s == "object" && (s = s[0]), ke(K().flowchart.htmlLabels)) {
    s = s.replace(/\\n|\n/g, "<br />"), I.info("vertexText" + s);
    const a = {
      isNode: i,
      label: Qr(s).replace(
        /fa[blrs]?:fa-[\w-]+/g,
        (o) => `<i class='${o.replace(":", " ")}'></i>`
      ),
      labelStyle: t && t.replace("fill:", "color:")
    };
    return await U0(a);
  } else {
    const a = document.createElementNS("http://www.w3.org/2000/svg", "text");
    a.setAttribute("style", t.replace("color:", "fill:"));
    let n = [];
    typeof s == "string" ? n = s.split(/\\n|\n|<br\s*\/?>/gi) : Array.isArray(s) ? n = s : n = [];
    for (const o of n) {
      const h = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
      h.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"), h.setAttribute("dy", "1em"), h.setAttribute("x", "0"), r ? h.setAttribute("class", "title-row") : h.setAttribute("class", "row"), h.textContent = o.trim(), a.appendChild(h);
    }
    return a;
  }
}, "createLabel"), Xi = x3, Ri = /* @__PURE__ */ u((e, t, r, i, s) => [
  "M",
  e + s,
  t,
  // Move to the first point
  "H",
  e + r - s,
  // Draw horizontal line to the beginning of the right corner
  "A",
  s,
  s,
  0,
  0,
  1,
  e + r,
  t + s,
  // Draw arc to the right top corner
  "V",
  t + i - s,
  // Draw vertical line down to the beginning of the right bottom corner
  "A",
  s,
  s,
  0,
  0,
  1,
  e + r - s,
  t + i,
  // Draw arc to the right bottom corner
  "H",
  e + s,
  // Draw horizontal line to the beginning of the left bottom corner
  "A",
  s,
  s,
  0,
  0,
  1,
  e,
  t + i - s,
  // Draw arc to the left bottom corner
  "V",
  t + s,
  // Draw vertical line up to the beginning of the left top corner
  "A",
  s,
  s,
  0,
  0,
  1,
  e + s,
  t,
  // Draw arc to the left top corner
  "Z"
  // Close the path
].join(" "), "createRoundedRectPathD"), j0 = /* @__PURE__ */ u(async (e, t) => {
  I.info("Creating subgraph rect for ", t.id, t);
  const r = K(), { themeVariables: i, handDrawnSeed: s } = r, { clusterBkg: a, clusterBorder: n } = i, { labelStyles: o, nodeStyles: h, borderStyles: l, backgroundStyles: d } = It(t), p = e.insert("g").attr("class", "cluster " + t.cssClasses).attr("id", t.id).attr("data-look", t.look), g = ke(r.flowchart.htmlLabels), f = p.insert("g").attr("class", "cluster-label "), y = await _r(f, t.label, {
    style: t.labelStyle,
    useHtmlLabels: g,
    isNode: !0
  });
  let m = y.getBBox();
  if (ke(r.flowchart.htmlLabels)) {
    const L = y.children[0], T = yt(y);
    m = L.getBoundingClientRect(), T.attr("width", m.width), T.attr("height", m.height);
  }
  const x = t.width <= m.width + t.padding ? m.width + t.padding : t.width;
  t.width <= m.width + t.padding ? t.diff = (x - t.width) / 2 - t.padding : t.diff = -t.padding;
  const b = t.height, v = t.x - x / 2, _ = t.y - b / 2;
  I.trace("Data ", t, JSON.stringify(t));
  let A;
  if (t.look === "handDrawn") {
    const L = Rt.svg(p), T = Ot(t, {
      roughness: 0.7,
      fill: a,
      // fill: 'red',
      stroke: n,
      fillWeight: 3,
      seed: s
    }), C = L.path(Ri(v, _, x, b, 0), T);
    A = p.insert(() => (I.debug("Rough node insert CXC", C), C), ":first-child"), A.select("path:nth-child(2)").attr("style", l.join(";")), A.select("path").attr("style", d.join(";").replace("fill", "stroke"));
  } else
    A = p.insert("rect", ":first-child"), A.attr("style", h).attr("rx", t.rx).attr("ry", t.ry).attr("x", v).attr("y", _).attr("width", x).attr("height", b);
  const { subGraphTitleTopMargin: S } = gn(r);
  if (f.attr(
    "transform",
    // This puts the label on top of the box instead of inside it
    `translate(${t.x - m.width / 2}, ${t.y - t.height / 2 + S})`
  ), o) {
    const L = f.select("span");
    L && L.attr("style", o);
  }
  const k = A.node().getBBox();
  return t.offsetX = 0, t.width = k.width, t.height = k.height, t.offsetY = m.height - t.padding / 2, t.intersect = function(L) {
    return Ca(t, L);
  }, { cluster: p, labelBBox: m };
}, "rect"), b3 = /* @__PURE__ */ u((e, t) => {
  const r = e.insert("g").attr("class", "note-cluster").attr("id", t.id), i = r.insert("rect", ":first-child"), s = 0 * t.padding, a = s / 2;
  i.attr("rx", t.rx).attr("ry", t.ry).attr("x", t.x - t.width / 2 - a).attr("y", t.y - t.height / 2 - a).attr("width", t.width + s).attr("height", t.height + s).attr("fill", "none");
  const n = i.node().getBBox();
  return t.width = n.width, t.height = n.height, t.intersect = function(o) {
    return Ca(t, o);
  }, { cluster: r, labelBBox: { width: 0, height: 0 } };
}, "noteGroup"), k3 = /* @__PURE__ */ u(async (e, t) => {
  const r = K(), { themeVariables: i, handDrawnSeed: s } = r, { altBackground: a, compositeBackground: n, compositeTitleBackground: o, nodeBorder: h } = i, l = e.insert("g").attr("class", t.cssClasses).attr("id", t.id).attr("data-id", t.id).attr("data-look", t.look), d = l.insert("g", ":first-child"), p = l.insert("g").attr("class", "cluster-label");
  let g = l.append("rect");
  const f = p.node().appendChild(await Xi(t.label, t.labelStyle, void 0, !0));
  let y = f.getBBox();
  if (ke(r.flowchart.htmlLabels)) {
    const C = f.children[0], E = yt(f);
    y = C.getBoundingClientRect(), E.attr("width", y.width), E.attr("height", y.height);
  }
  const m = 0 * t.padding, x = m / 2, b = (t.width <= y.width + t.padding ? y.width + t.padding : t.width) + m;
  t.width <= y.width + t.padding ? t.diff = (b - t.width) / 2 - t.padding : t.diff = -t.padding;
  const v = t.height + m, _ = t.height + m - y.height - 6, A = t.x - b / 2, S = t.y - v / 2;
  t.width = b;
  const k = t.y - t.height / 2 - x + y.height + 2;
  let L;
  if (t.look === "handDrawn") {
    const C = t.cssClasses.includes("statediagram-cluster-alt"), E = Rt.svg(l), w = t.rx || t.ry ? E.path(Ri(A, S, b, v, 10), {
      roughness: 0.7,
      fill: o,
      fillStyle: "solid",
      stroke: h,
      seed: s
    }) : E.rectangle(A, S, b, v, { seed: s });
    L = l.insert(() => w, ":first-child");
    const W = E.rectangle(A, k, b, _, {
      fill: C ? a : n,
      fillStyle: C ? "hachure" : "solid",
      stroke: h,
      seed: s
    });
    L = l.insert(() => w, ":first-child"), g = l.insert(() => W);
  } else
    L = d.insert("rect", ":first-child"), L.attr("class", "outer").attr("x", A).attr("y", S).attr("width", b).attr("height", v).attr("data-look", t.look), g.attr("class", "inner").attr("x", A).attr("y", k).attr("width", b).attr("height", _);
  p.attr(
    "transform",
    `translate(${t.x - y.width / 2}, ${S + 1 - (ke(r.flowchart.htmlLabels) ? 0 : 3)})`
  );
  const T = L.node().getBBox();
  return t.height = T.height, t.offsetX = 0, t.offsetY = y.height - t.padding / 2, t.labelBBox = y, t.intersect = function(C) {
    return Ca(t, C);
  }, { cluster: l, labelBBox: y };
}, "roundedWithTitle"), v3 = /* @__PURE__ */ u(async (e, t) => {
  I.info("Creating subgraph rect for ", t.id, t);
  const r = K(), { themeVariables: i, handDrawnSeed: s } = r, { clusterBkg: a, clusterBorder: n } = i, { labelStyles: o, nodeStyles: h, borderStyles: l, backgroundStyles: d } = It(t), p = e.insert("g").attr("class", "cluster " + t.cssClasses).attr("id", t.id).attr("data-look", t.look), g = ke(r.flowchart.htmlLabels), f = p.insert("g").attr("class", "cluster-label "), y = await _r(f, t.label, {
    style: t.labelStyle,
    useHtmlLabels: g,
    isNode: !0,
    width: t.width
  });
  let m = y.getBBox();
  if (ke(r.flowchart.htmlLabels)) {
    const L = y.children[0], T = yt(y);
    m = L.getBoundingClientRect(), T.attr("width", m.width), T.attr("height", m.height);
  }
  const x = t.width <= m.width + t.padding ? m.width + t.padding : t.width;
  t.width <= m.width + t.padding ? t.diff = (x - t.width) / 2 - t.padding : t.diff = -t.padding;
  const b = t.height, v = t.x - x / 2, _ = t.y - b / 2;
  I.trace("Data ", t, JSON.stringify(t));
  let A;
  if (t.look === "handDrawn") {
    const L = Rt.svg(p), T = Ot(t, {
      roughness: 0.7,
      fill: a,
      // fill: 'red',
      stroke: n,
      fillWeight: 4,
      seed: s
    }), C = L.path(Ri(v, _, x, b, t.rx), T);
    A = p.insert(() => (I.debug("Rough node insert CXC", C), C), ":first-child"), A.select("path:nth-child(2)").attr("style", l.join(";")), A.select("path").attr("style", d.join(";").replace("fill", "stroke"));
  } else
    A = p.insert("rect", ":first-child"), A.attr("style", h).attr("rx", t.rx).attr("ry", t.ry).attr("x", v).attr("y", _).attr("width", x).attr("height", b);
  const { subGraphTitleTopMargin: S } = gn(r);
  if (f.attr(
    "transform",
    // This puts the label on top of the box instead of inside it
    `translate(${t.x - m.width / 2}, ${t.y - t.height / 2 + S})`
  ), o) {
    const L = f.select("span");
    L && L.attr("style", o);
  }
  const k = A.node().getBBox();
  return t.offsetX = 0, t.width = k.width, t.height = k.height, t.offsetY = m.height - t.padding / 2, t.intersect = function(L) {
    return Ca(t, L);
  }, { cluster: p, labelBBox: m };
}, "kanbanSection"), S3 = /* @__PURE__ */ u((e, t) => {
  const r = K(), { themeVariables: i, handDrawnSeed: s } = r, { nodeBorder: a } = i, n = e.insert("g").attr("class", t.cssClasses).attr("id", t.id).attr("data-look", t.look), o = n.insert("g", ":first-child"), h = 0 * t.padding, l = t.width + h;
  t.diff = -t.padding;
  const d = t.height + h, p = t.x - l / 2, g = t.y - d / 2;
  t.width = l;
  let f;
  if (t.look === "handDrawn") {
    const x = Rt.svg(n).rectangle(p, g, l, d, {
      fill: "lightgrey",
      roughness: 0.5,
      strokeLineDash: [5],
      stroke: a,
      seed: s
    });
    f = n.insert(() => x, ":first-child");
  } else
    f = o.insert("rect", ":first-child"), f.attr("class", "divider").attr("x", p).attr("y", g).attr("width", l).attr("height", d).attr("data-look", t.look);
  const y = f.node().getBBox();
  return t.height = y.height, t.offsetX = 0, t.offsetY = 0, t.intersect = function(m) {
    return Ca(t, m);
  }, { cluster: n, labelBBox: {} };
}, "divider"), C3 = j0, w3 = {
  rect: j0,
  squareRect: C3,
  roundedWithTitle: k3,
  noteGroup: b3,
  divider: S3,
  kanbanSection: v3
}, G0 = /* @__PURE__ */ new Map(), Xc = /* @__PURE__ */ u(async (e, t) => {
  const r = t.shape || "rect", i = await w3[r](e, t);
  return G0.set(t.id, i), i;
}, "insertCluster"), T3 = /* @__PURE__ */ u(() => {
  G0 = /* @__PURE__ */ new Map();
}, "clear");
function X0(e, t) {
  return e.intersect(t);
}
u(X0, "intersectNode");
var _3 = X0;
function K0(e, t, r, i) {
  var s = e.x, a = e.y, n = s - i.x, o = a - i.y, h = Math.sqrt(t * t * o * o + r * r * n * n), l = Math.abs(t * r * n / h);
  i.x < s && (l = -l);
  var d = Math.abs(t * r * o / h);
  return i.y < a && (d = -d), { x: s + l, y: a + d };
}
u(K0, "intersectEllipse");
var Q0 = K0;
function Z0(e, t, r) {
  return Q0(e, t, t, r);
}
u(Z0, "intersectCircle");
var E3 = Z0;
function J0(e, t, r, i) {
  {
    const s = t.y - e.y, a = e.x - t.x, n = t.x * e.y - e.x * t.y, o = s * r.x + a * r.y + n, h = s * i.x + a * i.y + n, l = 1e-6;
    if (o !== 0 && h !== 0 && Ml(o, h))
      return;
    const d = i.y - r.y, p = r.x - i.x, g = i.x * r.y - r.x * i.y, f = d * e.x + p * e.y + g, y = d * t.x + p * t.y + g;
    if (Math.abs(f) < l && Math.abs(y) < l && Ml(f, y))
      return;
    const m = s * p - d * a;
    if (m === 0)
      return;
    const x = Math.abs(m / 2);
    let b = a * g - p * n;
    const v = b < 0 ? (b - x) / m : (b + x) / m;
    b = d * n - s * g;
    const _ = b < 0 ? (b - x) / m : (b + x) / m;
    return { x: v, y: _ };
  }
}
u(J0, "intersectLine");
function Ml(e, t) {
  return e * t > 0;
}
u(Ml, "sameSign");
var A3 = J0;
function tp(e, t, r) {
  let i = e.x, s = e.y, a = [], n = Number.POSITIVE_INFINITY, o = Number.POSITIVE_INFINITY;
  typeof t.forEach == "function" ? t.forEach(function(d) {
    n = Math.min(n, d.x), o = Math.min(o, d.y);
  }) : (n = Math.min(n, t.x), o = Math.min(o, t.y));
  let h = i - e.width / 2 - n, l = s - e.height / 2 - o;
  for (let d = 0; d < t.length; d++) {
    let p = t[d], g = t[d < t.length - 1 ? d + 1 : 0], f = A3(
      e,
      r,
      { x: h + p.x, y: l + p.y },
      { x: h + g.x, y: l + g.y }
    );
    f && a.push(f);
  }
  return a.length ? (a.length > 1 && a.sort(function(d, p) {
    let g = d.x - r.x, f = d.y - r.y, y = Math.sqrt(g * g + f * f), m = p.x - r.x, x = p.y - r.y, b = Math.sqrt(m * m + x * x);
    return y < b ? -1 : y === b ? 0 : 1;
  }), a[0]) : e;
}
u(tp, "intersectPolygon");
var L3 = tp, Dt = {
  node: _3,
  circle: E3,
  ellipse: Q0,
  polygon: L3,
  rect: Ca
};
function ep(e, t) {
  const { labelStyles: r } = It(t);
  t.labelStyle = r;
  const i = Xt(t);
  let s = i;
  i || (s = "anchor");
  const a = e.insert("g").attr("class", s).attr("id", t.domId || t.id), n = 1, { cssStyles: o } = t, h = Rt.svg(a), l = Ot(t, { fill: "black", stroke: "none", fillStyle: "solid" });
  t.look !== "handDrawn" && (l.roughness = 0);
  const d = h.circle(0, 0, n * 2, l), p = a.insert(() => d, ":first-child");
  return p.attr("class", "anchor").attr("style", ar(o)), Pt(t, p), t.intersect = function(g) {
    return I.info("Circle intersect", t, n, g), Dt.circle(t, n, g);
  }, a;
}
u(ep, "anchor");
function Ol(e, t, r, i, s, a, n) {
  const h = (e + r) / 2, l = (t + i) / 2, d = Math.atan2(i - t, r - e), p = (r - e) / 2, g = (i - t) / 2, f = p / s, y = g / a, m = Math.sqrt(f ** 2 + y ** 2);
  if (m > 1)
    throw new Error("The given radii are too small to create an arc between the points.");
  const x = Math.sqrt(1 - m ** 2), b = h + x * a * Math.sin(d) * (n ? -1 : 1), v = l - x * s * Math.cos(d) * (n ? -1 : 1), _ = Math.atan2((t - v) / a, (e - b) / s);
  let S = Math.atan2((i - v) / a, (r - b) / s) - _;
  n && S < 0 && (S += 2 * Math.PI), !n && S > 0 && (S -= 2 * Math.PI);
  const k = [];
  for (let L = 0; L < 20; L++) {
    const T = L / 19, C = _ + T * S, E = b + s * Math.cos(C), w = v + a * Math.sin(C);
    k.push({ x: E, y: w });
  }
  return k;
}
u(Ol, "generateArcPoints");
async function rp(e, t) {
  const { labelStyles: r, nodeStyles: i } = It(t);
  t.labelStyle = r;
  const { shapeSvg: s, bbox: a } = await Qt(e, t, Xt(t)), n = a.width + t.padding + 20, o = a.height + t.padding, h = o / 2, l = h / (2.5 + o / 50), { cssStyles: d } = t, p = [
    { x: n / 2, y: -o / 2 },
    { x: -n / 2, y: -o / 2 },
    ...Ol(-n / 2, -o / 2, -n / 2, o / 2, l, h, !1),
    { x: n / 2, y: o / 2 },
    ...Ol(n / 2, o / 2, n / 2, -o / 2, l, h, !0)
  ], g = Rt.svg(s), f = Ot(t, {});
  t.look !== "handDrawn" && (f.roughness = 0, f.fillStyle = "solid");
  const y = ce(p), m = g.path(y, f), x = s.insert(() => m, ":first-child");
  return x.attr("class", "basic label-container"), d && t.look !== "handDrawn" && x.selectAll("path").attr("style", d), i && t.look !== "handDrawn" && x.selectAll("path").attr("style", i), x.attr("transform", `translate(${l / 2}, 0)`), Pt(t, x), t.intersect = function(b) {
    return Dt.polygon(t, p, b);
  }, s;
}
u(rp, "bowTieRect");
function Mi(e, t, r, i) {
  return e.insert("polygon", ":first-child").attr(
    "points",
    i.map(function(s) {
      return s.x + "," + s.y;
    }).join(" ")
  ).attr("class", "label-container").attr("transform", "translate(" + -t / 2 + "," + r / 2 + ")");
}
u(Mi, "insertPolygonShape");
async function ip(e, t) {
  const { labelStyles: r, nodeStyles: i } = It(t);
  t.labelStyle = r;
  const { shapeSvg: s, bbox: a } = await Qt(e, t, Xt(t)), n = a.height + t.padding, o = 12, h = a.width + t.padding + o, l = 0, d = h, p = -n, g = 0, f = [
    { x: l + o, y: p },
    { x: d, y: p },
    { x: d, y: g },
    { x: l, y: g },
    { x: l, y: p + o },
    { x: l + o, y: p }
  ];
  let y;
  const { cssStyles: m } = t;
  if (t.look === "handDrawn") {
    const x = Rt.svg(s), b = Ot(t, {}), v = ce(f), _ = x.path(v, b);
    y = s.insert(() => _, ":first-child").attr("transform", `translate(${-h / 2}, ${n / 2})`), m && y.attr("style", m);
  } else
    y = Mi(s, h, n, f);
  return i && y.attr("style", i), Pt(t, y), t.intersect = function(x) {
    return Dt.polygon(t, f, x);
  }, s;
}
u(ip, "card");
function sp(e, t) {
  const { nodeStyles: r } = It(t);
  t.label = "";
  const i = e.insert("g").attr("class", Xt(t)).attr("id", t.domId ?? t.id), { cssStyles: s } = t, a = Math.max(28, t.width ?? 0), n = [
    { x: 0, y: a / 2 },
    { x: a / 2, y: 0 },
    { x: 0, y: -a / 2 },
    { x: -a / 2, y: 0 }
  ], o = Rt.svg(i), h = Ot(t, {});
  t.look !== "handDrawn" && (h.roughness = 0, h.fillStyle = "solid");
  const l = ce(n), d = o.path(l, h), p = i.insert(() => d, ":first-child");
  return s && t.look !== "handDrawn" && p.selectAll("path").attr("style", s), r && t.look !== "handDrawn" && p.selectAll("path").attr("style", r), t.width = 28, t.height = 28, t.intersect = function(g) {
    return Dt.polygon(t, n, g);
  }, i;
}
u(sp, "choice");
async function Kc(e, t, r) {
  const { labelStyles: i, nodeStyles: s } = It(t);
  t.labelStyle = i;
  const { shapeSvg: a, bbox: n, halfPadding: o } = await Qt(e, t, Xt(t)), h = (r == null ? void 0 : r.padding) ?? o, l = n.width / 2 + h;
  let d;
  const { cssStyles: p } = t;
  if (t.look === "handDrawn") {
    const g = Rt.svg(a), f = Ot(t, {}), y = g.circle(0, 0, l * 2, f);
    d = a.insert(() => y, ":first-child"), d.attr("class", "basic label-container").attr("style", ar(p));
  } else
    d = a.insert("circle", ":first-child").attr("class", "basic label-container").attr("style", s).attr("r", l).attr("cx", 0).attr("cy", 0);
  return Pt(t, d), t.calcIntersect = function(g, f) {
    const y = g.width / 2;
    return Dt.circle(g, y, f);
  }, t.intersect = function(g) {
    return I.info("Circle intersect", t, l, g), Dt.circle(t, l, g);
  }, a;
}
u(Kc, "circle");
function ap(e) {
  const t = Math.cos(Math.PI / 4), r = Math.sin(Math.PI / 4), i = e * 2, s = { x: i / 2 * t, y: i / 2 * r }, a = { x: -(i / 2) * t, y: i / 2 * r }, n = { x: -(i / 2) * t, y: -(i / 2) * r }, o = { x: i / 2 * t, y: -(i / 2) * r };
  return `M ${a.x},${a.y} L ${o.x},${o.y}
                   M ${s.x},${s.y} L ${n.x},${n.y}`;
}
u(ap, "createLine");
function np(e, t) {
  const { labelStyles: r, nodeStyles: i } = It(t);
  t.labelStyle = r, t.label = "";
  const s = e.insert("g").attr("class", Xt(t)).attr("id", t.domId ?? t.id), a = Math.max(30, (t == null ? void 0 : t.width) ?? 0), { cssStyles: n } = t, o = Rt.svg(s), h = Ot(t, {});
  t.look !== "handDrawn" && (h.roughness = 0, h.fillStyle = "solid");
  const l = o.circle(0, 0, a * 2, h), d = ap(a), p = o.path(d, h), g = s.insert(() => l, ":first-child");
  return g.insert(() => p), n && t.look !== "handDrawn" && g.selectAll("path").attr("style", n), i && t.look !== "handDrawn" && g.selectAll("path").attr("style", i), Pt(t, g), t.intersect = function(f) {
    return I.info("crossedCircle intersect", t, { radius: a, point: f }), Dt.circle(t, a, f);
  }, s;
}
u(np, "crossedCircle");
function hi(e, t, r, i = 100, s = 0, a = 180) {
  const n = [], o = s * Math.PI / 180, d = (a * Math.PI / 180 - o) / (i - 1);
  for (let p = 0; p < i; p++) {
    const g = o + p * d, f = e + r * Math.cos(g), y = t + r * Math.sin(g);
    n.push({ x: -f, y: -y });
  }
  return n;
}
u(hi, "generateCirclePoints");
async function op(e, t) {
  const { labelStyles: r, nodeStyles: i } = It(t);
  t.labelStyle = r;
  const { shapeSvg: s, bbox: a, label: n } = await Qt(e, t, Xt(t)), o = a.width + (t.padding ?? 0), h = a.height + (t.padding ?? 0), l = Math.max(5, h * 0.1), { cssStyles: d } = t, p = [
    ...hi(o / 2, -h / 2, l, 30, -90, 0),
    { x: -o / 2 - l, y: l },
    ...hi(o / 2 + l * 2, -l, l, 20, -180, -270),
    ...hi(o / 2 + l * 2, l, l, 20, -90, -180),
    { x: -o / 2 - l, y: -h / 2 },
    ...hi(o / 2, h / 2, l, 20, 0, 90)
  ], g = [
    { x: o / 2, y: -h / 2 - l },
    { x: -o / 2, y: -h / 2 - l },
    ...hi(o / 2, -h / 2, l, 20, -90, 0),
    { x: -o / 2 - l, y: -l },
    ...hi(o / 2 + o * 0.1, -l, l, 20, -180, -270),
    ...hi(o / 2 + o * 0.1, l, l, 20, -90, -180),
    { x: -o / 2 - l, y: h / 2 },
    ...hi(o / 2, h / 2, l, 20, 0, 90),
    { x: -o / 2, y: h / 2 + l },
    { x: o / 2, y: h / 2 + l }
  ], f = Rt.svg(s), y = Ot(t, { fill: "none" });
  t.look !== "handDrawn" && (y.roughness = 0, y.fillStyle = "solid");
  const x = ce(p).replace("Z", ""), b = f.path(x, y), v = ce(g), _ = f.path(v, { ...y }), A = s.insert("g", ":first-child");
  return A.insert(() => _, ":first-child").attr("stroke-opacity", 0), A.insert(() => b, ":first-child"), A.attr("class", "text"), d && t.look !== "handDrawn" && A.selectAll("path").attr("style", d), i && t.look !== "handDrawn" && A.selectAll("path").attr("style", i), A.attr("transform", `translate(${l}, 0)`), n.attr(
    "transform",
    `translate(${-o / 2 + l - (a.x - (a.left ?? 0))},${-h / 2 + (t.padding ?? 0) / 2 - (a.y - (a.top ?? 0))})`
  ), Pt(t, A), t.intersect = function(S) {
    return Dt.polygon(t, g, S);
  }, s;
}
u(op, "curlyBraceLeft");
function ui(e, t, r, i = 100, s = 0, a = 180) {
  const n = [], o = s * Math.PI / 180, d = (a * Math.PI / 180 - o) / (i - 1);
  for (let p = 0; p < i; p++) {
    const g = o + p * d, f = e + r * Math.cos(g), y = t + r * Math.sin(g);
    n.push({ x: f, y });
  }
  return n;
}
u(ui, "generateCirclePoints");
async function lp(e, t) {
  const { labelStyles: r, nodeStyles: i } = It(t);
  t.labelStyle = r;
  const { shapeSvg: s, bbox: a, label: n } = await Qt(e, t, Xt(t)), o = a.width + (t.padding ?? 0), h = a.height + (t.padding ?? 0), l = Math.max(5, h * 0.1), { cssStyles: d } = t, p = [
    ...ui(o / 2, -h / 2, l, 20, -90, 0),
    { x: o / 2 + l, y: -l },
    ...ui(o / 2 + l * 2, -l, l, 20, -180, -270),
    ...ui(o / 2 + l * 2, l, l, 20, -90, -180),
    { x: o / 2 + l, y: h / 2 },
    ...ui(o / 2, h / 2, l, 20, 0, 90)
  ], g = [
    { x: -o / 2, y: -h / 2 - l },
    { x: o / 2, y: -h / 2 - l },
    ...ui(o / 2, -h / 2, l, 20, -90, 0),
    { x: o / 2 + l, y: -l },
    ...ui(o / 2 + l * 2, -l, l, 20, -180, -270),
    ...ui(o / 2 + l * 2, l, l, 20, -90, -180),
    { x: o / 2 + l, y: h / 2 },
    ...ui(o / 2, h / 2, l, 20, 0, 90),
    { x: o / 2, y: h / 2 + l },
    { x: -o / 2, y: h / 2 + l }
  ], f = Rt.svg(s), y = Ot(t, { fill: "none" });
  t.look !== "handDrawn" && (y.roughness = 0, y.fillStyle = "solid");
  const x = ce(p).replace("Z", ""), b = f.path(x, y), v = ce(g), _ = f.path(v, { ...y }), A = s.insert("g", ":first-child");
  return A.insert(() => _, ":first-child").attr("stroke-opacity", 0), A.insert(() => b, ":first-child"), A.attr("class", "text"), d && t.look !== "handDrawn" && A.selectAll("path").attr("style", d), i && t.look !== "handDrawn" && A.selectAll("path").attr("style", i), A.attr("transform", `translate(${-l}, 0)`), n.attr(
    "transform",
    `translate(${-o / 2 + (t.padding ?? 0) / 2 - (a.x - (a.left ?? 0))},${-h / 2 + (t.padding ?? 0) / 2 - (a.y - (a.top ?? 0))})`
  ), Pt(t, A), t.intersect = function(S) {
    return Dt.polygon(t, g, S);
  }, s;
}
u(lp, "curlyBraceRight");
function Qe(e, t, r, i = 100, s = 0, a = 180) {
  const n = [], o = s * Math.PI / 180, d = (a * Math.PI / 180 - o) / (i - 1);
  for (let p = 0; p < i; p++) {
    const g = o + p * d, f = e + r * Math.cos(g), y = t + r * Math.sin(g);
    n.push({ x: -f, y: -y });
  }
  return n;
}
u(Qe, "generateCirclePoints");
async function cp(e, t) {
  const { labelStyles: r, nodeStyles: i } = It(t);
  t.labelStyle = r;
  const { shapeSvg: s, bbox: a, label: n } = await Qt(e, t, Xt(t)), o = a.width + (t.padding ?? 0), h = a.height + (t.padding ?? 0), l = Math.max(5, h * 0.1), { cssStyles: d } = t, p = [
    ...Qe(o / 2, -h / 2, l, 30, -90, 0),
    { x: -o / 2 - l, y: l },
    ...Qe(o / 2 + l * 2, -l, l, 20, -180, -270),
    ...Qe(o / 2 + l * 2, l, l, 20, -90, -180),
    { x: -o / 2 - l, y: -h / 2 },
    ...Qe(o / 2, h / 2, l, 20, 0, 90)
  ], g = [
    ...Qe(-o / 2 + l + l / 2, -h / 2, l, 20, -90, -180),
    { x: o / 2 - l / 2, y: l },
    ...Qe(-o / 2 - l / 2, -l, l, 20, 0, 90),
    ...Qe(-o / 2 - l / 2, l, l, 20, -90, 0),
    { x: o / 2 - l / 2, y: -l },
    ...Qe(-o / 2 + l + l / 2, h / 2, l, 30, -180, -270)
  ], f = [
    { x: o / 2, y: -h / 2 - l },
    { x: -o / 2, y: -h / 2 - l },
    ...Qe(o / 2, -h / 2, l, 20, -90, 0),
    { x: -o / 2 - l, y: -l },
    ...Qe(o / 2 + l * 2, -l, l, 20, -180, -270),
    ...Qe(o / 2 + l * 2, l, l, 20, -90, -180),
    { x: -o / 2 - l, y: h / 2 },
    ...Qe(o / 2, h / 2, l, 20, 0, 90),
    { x: -o / 2, y: h / 2 + l },
    { x: o / 2 - l - l / 2, y: h / 2 + l },
    ...Qe(-o / 2 + l + l / 2, -h / 2, l, 20, -90, -180),
    { x: o / 2 - l / 2, y: l },
    ...Qe(-o / 2 - l / 2, -l, l, 20, 0, 90),
    ...Qe(-o / 2 - l / 2, l, l, 20, -90, 0),
    { x: o / 2 - l / 2, y: -l },
    ...Qe(-o / 2 + l + l / 2, h / 2, l, 30, -180, -270)
  ], y = Rt.svg(s), m = Ot(t, { fill: "none" });
  t.look !== "handDrawn" && (m.roughness = 0, m.fillStyle = "solid");
  const b = ce(p).replace("Z", ""), v = y.path(b, m), A = ce(g).replace("Z", ""), S = y.path(A, m), k = ce(f), L = y.path(k, { ...m }), T = s.insert("g", ":first-child");
  return T.insert(() => L, ":first-child").attr("stroke-opacity", 0), T.insert(() => v, ":first-child"), T.insert(() => S, ":first-child"), T.attr("class", "text"), d && t.look !== "handDrawn" && T.selectAll("path").attr("style", d), i && t.look !== "handDrawn" && T.selectAll("path").attr("style", i), T.attr("transform", `translate(${l - l / 4}, 0)`), n.attr(
    "transform",
    `translate(${-o / 2 + (t.padding ?? 0) / 2 - (a.x - (a.left ?? 0))},${-h / 2 + (t.padding ?? 0) / 2 - (a.y - (a.top ?? 0))})`
  ), Pt(t, T), t.intersect = function(C) {
    return Dt.polygon(t, f, C);
  }, s;
}
u(cp, "curlyBraces");
async function hp(e, t) {
  const { labelStyles: r, nodeStyles: i } = It(t);
  t.labelStyle = r;
  const { shapeSvg: s, bbox: a } = await Qt(e, t, Xt(t)), n = 80, o = 20, h = Math.max(n, (a.width + (t.padding ?? 0) * 2) * 1.25, (t == null ? void 0 : t.width) ?? 0), l = Math.max(o, a.height + (t.padding ?? 0) * 2, (t == null ? void 0 : t.height) ?? 0), d = l / 2, { cssStyles: p } = t, g = Rt.svg(s), f = Ot(t, {});
  t.look !== "handDrawn" && (f.roughness = 0, f.fillStyle = "solid");
  const y = h, m = l, x = y - d, b = m / 4, v = [
    { x, y: 0 },
    { x: b, y: 0 },
    { x: 0, y: m / 2 },
    { x: b, y: m },
    { x, y: m },
    ...Qa(-x, -m / 2, d, 50, 270, 90)
  ], _ = ce(v), A = g.path(_, f), S = s.insert(() => A, ":first-child");
  return S.attr("class", "basic label-container"), p && t.look !== "handDrawn" && S.selectChildren("path").attr("style", p), i && t.look !== "handDrawn" && S.selectChildren("path").attr("style", i), S.attr("transform", `translate(${-h / 2}, ${-l / 2})`), Pt(t, S), t.intersect = function(k) {
    return Dt.polygon(t, v, k);
  }, s;
}
u(hp, "curvedTrapezoid");
var B3 = /* @__PURE__ */ u((e, t, r, i, s, a) => [
  `M${e},${t + a}`,
  `a${s},${a} 0,0,0 ${r},0`,
  `a${s},${a} 0,0,0 ${-r},0`,
  `l0,${i}`,
  `a${s},${a} 0,0,0 ${r},0`,
  `l0,${-i}`
].join(" "), "createCylinderPathD"), D3 = /* @__PURE__ */ u((e, t, r, i, s, a) => [
  `M${e},${t + a}`,
  `M${e + r},${t + a}`,
  `a${s},${a} 0,0,0 ${-r},0`,
  `l0,${i}`,
  `a${s},${a} 0,0,0 ${r},0`,
  `l0,${-i}`
].join(" "), "createOuterCylinderPathD"), I3 = /* @__PURE__ */ u((e, t, r, i, s, a) => [`M${e - r / 2},${-i / 2}`, `a${s},${a} 0,0,0 ${r},0`].join(" "), "createInnerCylinderPathD");
async function up(e, t) {
  const { labelStyles: r, nodeStyles: i } = It(t);
  t.labelStyle = r;
  const { shapeSvg: s, bbox: a, label: n } = await Qt(e, t, Xt(t)), o = Math.max(a.width + t.padding, t.width ?? 0), h = o / 2, l = h / (2.5 + o / 50), d = Math.max(a.height + l + t.padding, t.height ?? 0);
  let p;
  const { cssStyles: g } = t;
  if (t.look === "handDrawn") {
    const f = Rt.svg(s), y = D3(0, 0, o, d, h, l), m = I3(0, l, o, d, h, l), x = f.path(y, Ot(t, {})), b = f.path(m, Ot(t, { fill: "none" }));
    p = s.insert(() => b, ":first-child"), p = s.insert(() => x, ":first-child"), p.attr("class", "basic label-container"), g && p.attr("style", g);
  } else {
    const f = B3(0, 0, o, d, h, l);
    p = s.insert("path", ":first-child").attr("d", f).attr("class", "basic label-container").attr("style", ar(g)).attr("style", i);
  }
  return p.attr("label-offset-y", l), p.attr("transform", `translate(${-o / 2}, ${-(d / 2 + l)})`), Pt(t, p), n.attr(
    "transform",
    `translate(${-(a.width / 2) - (a.x - (a.left ?? 0))}, ${-(a.height / 2) + (t.padding ?? 0) / 1.5 - (a.y - (a.top ?? 0))})`
  ), t.intersect = function(f) {
    const y = Dt.rect(t, f), m = y.x - (t.x ?? 0);
    if (h != 0 && (Math.abs(m) < (t.width ?? 0) / 2 || Math.abs(m) == (t.width ?? 0) / 2 && Math.abs(y.y - (t.y ?? 0)) > (t.height ?? 0) / 2 - l)) {
      let x = l * l * (1 - m * m / (h * h));
      x > 0 && (x = Math.sqrt(x)), x = l - x, f.y - (t.y ?? 0) > 0 && (x = -x), y.y += x;
    }
    return y;
  }, s;
}
u(up, "cylinder");
async function dp(e, t) {
  const { labelStyles: r, nodeStyles: i } = It(t);
  t.labelStyle = r;
  const { shapeSvg: s, bbox: a, label: n } = await Qt(e, t, Xt(t)), o = a.width + t.padding, h = a.height + t.padding, l = h * 0.2, d = -o / 2, p = -h / 2 - l / 2, { cssStyles: g } = t, f = Rt.svg(s), y = Ot(t, {});
  t.look !== "handDrawn" && (y.roughness = 0, y.fillStyle = "solid");
  const m = [
    { x: d, y: p + l },
    { x: -d, y: p + l },
    { x: -d, y: -p },
    { x: d, y: -p },
    { x: d, y: p },
    { x: -d, y: p },
    { x: -d, y: p + l }
  ], x = f.polygon(
    m.map((v) => [v.x, v.y]),
    y
  ), b = s.insert(() => x, ":first-child");
  return b.attr("class", "basic label-container"), g && t.look !== "handDrawn" && b.selectAll("path").attr("style", g), i && t.look !== "handDrawn" && b.selectAll("path").attr("style", i), n.attr(
    "transform",
    `translate(${d + (t.padding ?? 0) / 2 - (a.x - (a.left ?? 0))}, ${p + l + (t.padding ?? 0) / 2 - (a.y - (a.top ?? 0))})`
  ), Pt(t, b), t.intersect = function(v) {
    return Dt.rect(t, v);
  }, s;
}
u(dp, "dividedRectangle");
async function pp(e, t) {
  var g, f;
  const { labelStyles: r, nodeStyles: i } = It(t);
  t.labelStyle = r;
  const { shapeSvg: s, bbox: a, halfPadding: n } = await Qt(e, t, Xt(t)), h = a.width / 2 + n + 5, l = a.width / 2 + n;
  let d;
  const { cssStyles: p } = t;
  if (t.look === "handDrawn") {
    const y = Rt.svg(s), m = Ot(t, { roughness: 0.2, strokeWidth: 2.5 }), x = Ot(t, { roughness: 0.2, strokeWidth: 1.5 }), b = y.circle(0, 0, h * 2, m), v = y.circle(0, 0, l * 2, x);
    d = s.insert("g", ":first-child"), d.attr("class", ar(t.cssClasses)).attr("style", ar(p)), (g = d.node()) == null || g.appendChild(b), (f = d.node()) == null || f.appendChild(v);
  } else {
    d = s.insert("g", ":first-child");
    const y = d.insert("circle", ":first-child"), m = d.insert("circle");
    d.attr("class", "basic label-container").attr("style", i), y.attr("class", "outer-circle").attr("style", i).attr("r", h).attr("cx", 0).attr("cy", 0), m.attr("class", "inner-circle").attr("style", i).attr("r", l).attr("cx", 0).attr("cy", 0);
  }
  return Pt(t, d), t.intersect = function(y) {
    return I.info("DoubleCircle intersect", t, h, y), Dt.circle(t, h, y);
  }, s;
}
u(pp, "doublecircle");
function gp(e, t, { config: { themeVariables: r } }) {
  const { labelStyles: i, nodeStyles: s } = It(t);
  t.label = "", t.labelStyle = i;
  const a = e.insert("g").attr("class", Xt(t)).attr("id", t.domId ?? t.id), n = 7, { cssStyles: o } = t, h = Rt.svg(a), { nodeBorder: l } = r, d = Ot(t, { fillStyle: "solid" });
  t.look !== "handDrawn" && (d.roughness = 0);
  const p = h.circle(0, 0, n * 2, d), g = a.insert(() => p, ":first-child");
  return g.selectAll("path").attr("style", `fill: ${l} !important;`), o && o.length > 0 && t.look !== "handDrawn" && g.selectAll("path").attr("style", o), s && t.look !== "handDrawn" && g.selectAll("path").attr("style", s), Pt(t, g), t.intersect = function(f) {
    return I.info("filledCircle intersect", t, { radius: n, point: f }), Dt.circle(t, n, f);
  }, a;
}
u(gp, "filledCircle");
async function fp(e, t) {
  const { labelStyles: r, nodeStyles: i } = It(t);
  t.labelStyle = r;
  const { shapeSvg: s, bbox: a, label: n } = await Qt(e, t, Xt(t)), o = a.width + (t.padding ?? 0), h = o + a.height, l = o + a.height, d = [
    { x: 0, y: -h },
    { x: l, y: -h },
    { x: l / 2, y: 0 }
  ], { cssStyles: p } = t, g = Rt.svg(s), f = Ot(t, {});
  t.look !== "handDrawn" && (f.roughness = 0, f.fillStyle = "solid");
  const y = ce(d), m = g.path(y, f), x = s.insert(() => m, ":first-child").attr("transform", `translate(${-h / 2}, ${h / 2})`);
  return p && t.look !== "handDrawn" && x.selectChildren("path").attr("style", p), i && t.look !== "handDrawn" && x.selectChildren("path").attr("style", i), t.width = o, t.height = h, Pt(t, x), n.attr(
    "transform",
    `translate(${-a.width / 2 - (a.x - (a.left ?? 0))}, ${-h / 2 + (t.padding ?? 0) / 2 + (a.y - (a.top ?? 0))})`
  ), t.intersect = function(b) {
    return I.info("Triangle intersect", t, d, b), Dt.polygon(t, d, b);
  }, s;
}
u(fp, "flippedTriangle");
function yp(e, t, { dir: r, config: { state: i, themeVariables: s } }) {
  const { nodeStyles: a } = It(t);
  t.label = "";
  const n = e.insert("g").attr("class", Xt(t)).attr("id", t.domId ?? t.id), { cssStyles: o } = t;
  let h = Math.max(70, (t == null ? void 0 : t.width) ?? 0), l = Math.max(10, (t == null ? void 0 : t.height) ?? 0);
  r === "LR" && (h = Math.max(10, (t == null ? void 0 : t.width) ?? 0), l = Math.max(70, (t == null ? void 0 : t.height) ?? 0));
  const d = -1 * h / 2, p = -1 * l / 2, g = Rt.svg(n), f = Ot(t, {
    stroke: s.lineColor,
    fill: s.lineColor
  });
  t.look !== "handDrawn" && (f.roughness = 0, f.fillStyle = "solid");
  const y = g.rectangle(d, p, h, l, f), m = n.insert(() => y, ":first-child");
  o && t.look !== "handDrawn" && m.selectAll("path").attr("style", o), a && t.look !== "handDrawn" && m.selectAll("path").attr("style", a), Pt(t, m);
  const x = (i == null ? void 0 : i.padding) ?? 0;
  return t.width && t.height && (t.width += x / 2 || 0, t.height += x / 2 || 0), t.intersect = function(b) {
    return Dt.rect(t, b);
  }, n;
}
u(yp, "forkJoin");
async function mp(e, t) {
  const { labelStyles: r, nodeStyles: i } = It(t);
  t.labelStyle = r;
  const s = 80, a = 50, { shapeSvg: n, bbox: o } = await Qt(e, t, Xt(t)), h = Math.max(s, o.width + (t.padding ?? 0) * 2, (t == null ? void 0 : t.width) ?? 0), l = Math.max(a, o.height + (t.padding ?? 0) * 2, (t == null ? void 0 : t.height) ?? 0), d = l / 2, { cssStyles: p } = t, g = Rt.svg(n), f = Ot(t, {});
  t.look !== "handDrawn" && (f.roughness = 0, f.fillStyle = "solid");
  const y = [
    { x: -h / 2, y: -l / 2 },
    { x: h / 2 - d, y: -l / 2 },
    ...Qa(-h / 2 + d, 0, d, 50, 90, 270),
    { x: h / 2 - d, y: l / 2 },
    { x: -h / 2, y: l / 2 }
  ], m = ce(y), x = g.path(m, f), b = n.insert(() => x, ":first-child");
  return b.attr("class", "basic label-container"), p && t.look !== "handDrawn" && b.selectChildren("path").attr("style", p), i && t.look !== "handDrawn" && b.selectChildren("path").attr("style", i), Pt(t, b), t.intersect = function(v) {
    return I.info("Pill intersect", t, { radius: d, point: v }), Dt.polygon(t, y, v);
  }, n;
}
u(mp, "halfRoundedRectangle");
async function xp(e, t) {
  const { labelStyles: r, nodeStyles: i } = It(t);
  t.labelStyle = r;
  const { shapeSvg: s, bbox: a } = await Qt(e, t, Xt(t)), n = a.height + (t.padding ?? 0), o = a.width + (t.padding ?? 0) * 2.5, { cssStyles: h } = t, l = Rt.svg(s), d = Ot(t, {});
  t.look !== "handDrawn" && (d.roughness = 0, d.fillStyle = "solid");
  let p = o / 2;
  const g = p / 6;
  p = p + g;
  const f = n / 2, y = f / 2, m = p - y, x = [
    { x: -m, y: -f },
    { x: 0, y: -f },
    { x: m, y: -f },
    { x: p, y: 0 },
    { x: m, y: f },
    { x: 0, y: f },
    { x: -m, y: f },
    { x: -p, y: 0 }
  ], b = ce(x), v = l.path(b, d), _ = s.insert(() => v, ":first-child");
  return _.attr("class", "basic label-container"), h && t.look !== "handDrawn" && _.selectChildren("path").attr("style", h), i && t.look !== "handDrawn" && _.selectChildren("path").attr("style", i), t.width = o, t.height = n, Pt(t, _), t.intersect = function(A) {
    return Dt.polygon(t, x, A);
  }, s;
}
u(xp, "hexagon");
async function bp(e, t) {
  const { labelStyles: r, nodeStyles: i } = It(t);
  t.label = "", t.labelStyle = r;
  const { shapeSvg: s } = await Qt(e, t, Xt(t)), a = Math.max(30, (t == null ? void 0 : t.width) ?? 0), n = Math.max(30, (t == null ? void 0 : t.height) ?? 0), { cssStyles: o } = t, h = Rt.svg(s), l = Ot(t, {});
  t.look !== "handDrawn" && (l.roughness = 0, l.fillStyle = "solid");
  const d = [
    { x: 0, y: 0 },
    { x: a, y: 0 },
    { x: 0, y: n },
    { x: a, y: n }
  ], p = ce(d), g = h.path(p, l), f = s.insert(() => g, ":first-child");
  return f.attr("class", "basic label-container"), o && t.look !== "handDrawn" && f.selectChildren("path").attr("style", o), i && t.look !== "handDrawn" && f.selectChildren("path").attr("style", i), f.attr("transform", `translate(${-a / 2}, ${-n / 2})`), Pt(t, f), t.intersect = function(y) {
    return I.info("Pill intersect", t, { points: d }), Dt.polygon(t, d, y);
  }, s;
}
u(bp, "hourglass");
async function kp(e, t, { config: { themeVariables: r, flowchart: i } }) {
  const { labelStyles: s } = It(t);
  t.labelStyle = s;
  const a = t.assetHeight ?? 48, n = t.assetWidth ?? 48, o = Math.max(a, n), h = i == null ? void 0 : i.wrappingWidth;
  t.width = Math.max(o, h ?? 0);
  const { shapeSvg: l, bbox: d, label: p } = await Qt(e, t, "icon-shape default"), g = t.pos === "t", f = o, y = o, { nodeBorder: m } = r, { stylesMap: x } = Sa(t), b = -y / 2, v = -f / 2, _ = t.label ? 8 : 0, A = Rt.svg(l), S = Ot(t, { stroke: "none", fill: "none" });
  t.look !== "handDrawn" && (S.roughness = 0, S.fillStyle = "solid");
  const k = A.rectangle(b, v, y, f, S), L = Math.max(y, d.width), T = f + d.height + _, C = A.rectangle(-L / 2, -T / 2, L, T, {
    ...S,
    fill: "transparent",
    stroke: "none"
  }), E = l.insert(() => k, ":first-child"), w = l.insert(() => C);
  if (t.icon) {
    const W = l.append("g");
    W.html(
      `<g>${await Bi(t.icon, {
        height: o,
        width: o,
        fallbackPrefix: ""
      })}</g>`
    );
    const N = W.node().getBBox(), B = N.width, R = N.height, V = N.x, $ = N.y;
    W.attr(
      "transform",
      `translate(${-B / 2 - V},${g ? d.height / 2 + _ / 2 - R / 2 - $ : -d.height / 2 - _ / 2 - R / 2 - $})`
    ), W.attr("style", `color: ${x.get("stroke") ?? m};`);
  }
  return p.attr(
    "transform",
    `translate(${-d.width / 2 - (d.x - (d.left ?? 0))},${g ? -T / 2 : T / 2 - d.height})`
  ), E.attr(
    "transform",
    `translate(0,${g ? d.height / 2 + _ / 2 : -d.height / 2 - _ / 2})`
  ), Pt(t, w), t.intersect = function(W) {
    if (I.info("iconSquare intersect", t, W), !t.label)
      return Dt.rect(t, W);
    const N = t.x ?? 0, B = t.y ?? 0, R = t.height ?? 0;
    let V = [];
    return g ? V = [
      { x: N - d.width / 2, y: B - R / 2 },
      { x: N + d.width / 2, y: B - R / 2 },
      { x: N + d.width / 2, y: B - R / 2 + d.height + _ },
      { x: N + y / 2, y: B - R / 2 + d.height + _ },
      { x: N + y / 2, y: B + R / 2 },
      { x: N - y / 2, y: B + R / 2 },
      { x: N - y / 2, y: B - R / 2 + d.height + _ },
      { x: N - d.width / 2, y: B - R / 2 + d.height + _ }
    ] : V = [
      { x: N - y / 2, y: B - R / 2 },
      { x: N + y / 2, y: B - R / 2 },
      { x: N + y / 2, y: B - R / 2 + f },
      { x: N + d.width / 2, y: B - R / 2 + f },
      { x: N + d.width / 2 / 2, y: B + R / 2 },
      { x: N - d.width / 2, y: B + R / 2 },
      { x: N - d.width / 2, y: B - R / 2 + f },
      { x: N - y / 2, y: B - R / 2 + f }
    ], Dt.polygon(t, V, W);
  }, l;
}
u(kp, "icon");
async function vp(e, t, { config: { themeVariables: r, flowchart: i } }) {
  const { labelStyles: s } = It(t);
  t.labelStyle = s;
  const a = t.assetHeight ?? 48, n = t.assetWidth ?? 48, o = Math.max(a, n), h = i == null ? void 0 : i.wrappingWidth;
  t.width = Math.max(o, h ?? 0);
  const { shapeSvg: l, bbox: d, label: p } = await Qt(e, t, "icon-shape default"), g = 20, f = t.label ? 8 : 0, y = t.pos === "t", { nodeBorder: m, mainBkg: x } = r, { stylesMap: b } = Sa(t), v = Rt.svg(l), _ = Ot(t, {});
  t.look !== "handDrawn" && (_.roughness = 0, _.fillStyle = "solid");
  const A = b.get("fill");
  _.stroke = A ?? x;
  const S = l.append("g");
  t.icon && S.html(
    `<g>${await Bi(t.icon, {
      height: o,
      width: o,
      fallbackPrefix: ""
    })}</g>`
  );
  const k = S.node().getBBox(), L = k.width, T = k.height, C = k.x, E = k.y, w = Math.max(L, T) * Math.SQRT2 + g * 2, W = v.circle(0, 0, w, _), N = Math.max(w, d.width), B = w + d.height + f, R = v.rectangle(-N / 2, -B / 2, N, B, {
    ..._,
    fill: "transparent",
    stroke: "none"
  }), V = l.insert(() => W, ":first-child"), $ = l.insert(() => R);
  return S.attr(
    "transform",
    `translate(${-L / 2 - C},${y ? d.height / 2 + f / 2 - T / 2 - E : -d.height / 2 - f / 2 - T / 2 - E})`
  ), S.attr("style", `color: ${b.get("stroke") ?? m};`), p.attr(
    "transform",
    `translate(${-d.width / 2 - (d.x - (d.left ?? 0))},${y ? -B / 2 : B / 2 - d.height})`
  ), V.attr(
    "transform",
    `translate(0,${y ? d.height / 2 + f / 2 : -d.height / 2 - f / 2})`
  ), Pt(t, $), t.intersect = function(D) {
    return I.info("iconSquare intersect", t, D), Dt.rect(t, D);
  }, l;
}
u(vp, "iconCircle");
async function Sp(e, t, { config: { themeVariables: r, flowchart: i } }) {
  const { labelStyles: s } = It(t);
  t.labelStyle = s;
  const a = t.assetHeight ?? 48, n = t.assetWidth ?? 48, o = Math.max(a, n), h = i == null ? void 0 : i.wrappingWidth;
  t.width = Math.max(o, h ?? 0);
  const { shapeSvg: l, bbox: d, halfPadding: p, label: g } = await Qt(
    e,
    t,
    "icon-shape default"
  ), f = t.pos === "t", y = o + p * 2, m = o + p * 2, { nodeBorder: x, mainBkg: b } = r, { stylesMap: v } = Sa(t), _ = -m / 2, A = -y / 2, S = t.label ? 8 : 0, k = Rt.svg(l), L = Ot(t, {});
  t.look !== "handDrawn" && (L.roughness = 0, L.fillStyle = "solid");
  const T = v.get("fill");
  L.stroke = T ?? b;
  const C = k.path(Ri(_, A, m, y, 5), L), E = Math.max(m, d.width), w = y + d.height + S, W = k.rectangle(-E / 2, -w / 2, E, w, {
    ...L,
    fill: "transparent",
    stroke: "none"
  }), N = l.insert(() => C, ":first-child").attr("class", "icon-shape2"), B = l.insert(() => W);
  if (t.icon) {
    const R = l.append("g");
    R.html(
      `<g>${await Bi(t.icon, {
        height: o,
        width: o,
        fallbackPrefix: ""
      })}</g>`
    );
    const V = R.node().getBBox(), $ = V.width, D = V.height, O = V.x, Y = V.y;
    R.attr(
      "transform",
      `translate(${-$ / 2 - O},${f ? d.height / 2 + S / 2 - D / 2 - Y : -d.height / 2 - S / 2 - D / 2 - Y})`
    ), R.attr("style", `color: ${v.get("stroke") ?? x};`);
  }
  return g.attr(
    "transform",
    `translate(${-d.width / 2 - (d.x - (d.left ?? 0))},${f ? -w / 2 : w / 2 - d.height})`
  ), N.attr(
    "transform",
    `translate(0,${f ? d.height / 2 + S / 2 : -d.height / 2 - S / 2})`
  ), Pt(t, B), t.intersect = function(R) {
    if (I.info("iconSquare intersect", t, R), !t.label)
      return Dt.rect(t, R);
    const V = t.x ?? 0, $ = t.y ?? 0, D = t.height ?? 0;
    let O = [];
    return f ? O = [
      { x: V - d.width / 2, y: $ - D / 2 },
      { x: V + d.width / 2, y: $ - D / 2 },
      { x: V + d.width / 2, y: $ - D / 2 + d.height + S },
      { x: V + m / 2, y: $ - D / 2 + d.height + S },
      { x: V + m / 2, y: $ + D / 2 },
      { x: V - m / 2, y: $ + D / 2 },
      { x: V - m / 2, y: $ - D / 2 + d.height + S },
      { x: V - d.width / 2, y: $ - D / 2 + d.height + S }
    ] : O = [
      { x: V - m / 2, y: $ - D / 2 },
      { x: V + m / 2, y: $ - D / 2 },
      { x: V + m / 2, y: $ - D / 2 + y },
      { x: V + d.width / 2, y: $ - D / 2 + y },
      { x: V + d.width / 2 / 2, y: $ + D / 2 },
      { x: V - d.width / 2, y: $ + D / 2 },
      { x: V - d.width / 2, y: $ - D / 2 + y },
      { x: V - m / 2, y: $ - D / 2 + y }
    ], Dt.polygon(t, O, R);
  }, l;
}
u(Sp, "iconRounded");
async function Cp(e, t, { config: { themeVariables: r, flowchart: i } }) {
  const { labelStyles: s } = It(t);
  t.labelStyle = s;
  const a = t.assetHeight ?? 48, n = t.assetWidth ?? 48, o = Math.max(a, n), h = i == null ? void 0 : i.wrappingWidth;
  t.width = Math.max(o, h ?? 0);
  const { shapeSvg: l, bbox: d, halfPadding: p, label: g } = await Qt(
    e,
    t,
    "icon-shape default"
  ), f = t.pos === "t", y = o + p * 2, m = o + p * 2, { nodeBorder: x, mainBkg: b } = r, { stylesMap: v } = Sa(t), _ = -m / 2, A = -y / 2, S = t.label ? 8 : 0, k = Rt.svg(l), L = Ot(t, {});
  t.look !== "handDrawn" && (L.roughness = 0, L.fillStyle = "solid");
  const T = v.get("fill");
  L.stroke = T ?? b;
  const C = k.path(Ri(_, A, m, y, 0.1), L), E = Math.max(m, d.width), w = y + d.height + S, W = k.rectangle(-E / 2, -w / 2, E, w, {
    ...L,
    fill: "transparent",
    stroke: "none"
  }), N = l.insert(() => C, ":first-child"), B = l.insert(() => W);
  if (t.icon) {
    const R = l.append("g");
    R.html(
      `<g>${await Bi(t.icon, {
        height: o,
        width: o,
        fallbackPrefix: ""
      })}</g>`
    );
    const V = R.node().getBBox(), $ = V.width, D = V.height, O = V.x, Y = V.y;
    R.attr(
      "transform",
      `translate(${-$ / 2 - O},${f ? d.height / 2 + S / 2 - D / 2 - Y : -d.height / 2 - S / 2 - D / 2 - Y})`
    ), R.attr("style", `color: ${v.get("stroke") ?? x};`);
  }
  return g.attr(
    "transform",
    `translate(${-d.width / 2 - (d.x - (d.left ?? 0))},${f ? -w / 2 : w / 2 - d.height})`
  ), N.attr(
    "transform",
    `translate(0,${f ? d.height / 2 + S / 2 : -d.height / 2 - S / 2})`
  ), Pt(t, B), t.intersect = function(R) {
    if (I.info("iconSquare intersect", t, R), !t.label)
      return Dt.rect(t, R);
    const V = t.x ?? 0, $ = t.y ?? 0, D = t.height ?? 0;
    let O = [];
    return f ? O = [
      { x: V - d.width / 2, y: $ - D / 2 },
      { x: V + d.width / 2, y: $ - D / 2 },
      { x: V + d.width / 2, y: $ - D / 2 + d.height + S },
      { x: V + m / 2, y: $ - D / 2 + d.height + S },
      { x: V + m / 2, y: $ + D / 2 },
      { x: V - m / 2, y: $ + D / 2 },
      { x: V - m / 2, y: $ - D / 2 + d.height + S },
      { x: V - d.width / 2, y: $ - D / 2 + d.height + S }
    ] : O = [
      { x: V - m / 2, y: $ - D / 2 },
      { x: V + m / 2, y: $ - D / 2 },
      { x: V + m / 2, y: $ - D / 2 + y },
      { x: V + d.width / 2, y: $ - D / 2 + y },
      { x: V + d.width / 2 / 2, y: $ + D / 2 },
      { x: V - d.width / 2, y: $ + D / 2 },
      { x: V - d.width / 2, y: $ - D / 2 + y },
      { x: V - m / 2, y: $ - D / 2 + y }
    ], Dt.polygon(t, O, R);
  }, l;
}
u(Cp, "iconSquare");
async function wp(e, t, { config: { flowchart: r } }) {
  const i = new Image();
  i.src = (t == null ? void 0 : t.img) ?? "", await i.decode();
  const s = Number(i.naturalWidth.toString().replace("px", "")), a = Number(i.naturalHeight.toString().replace("px", ""));
  t.imageAspectRatio = s / a;
  const { labelStyles: n } = It(t);
  t.labelStyle = n;
  const o = r == null ? void 0 : r.wrappingWidth;
  t.defaultWidth = r == null ? void 0 : r.wrappingWidth;
  const h = Math.max(
    t.label ? o ?? 0 : 0,
    (t == null ? void 0 : t.assetWidth) ?? s
  ), l = t.constraint === "on" && t != null && t.assetHeight ? t.assetHeight * t.imageAspectRatio : h, d = t.constraint === "on" ? l / t.imageAspectRatio : (t == null ? void 0 : t.assetHeight) ?? a;
  t.width = Math.max(l, o ?? 0);
  const { shapeSvg: p, bbox: g, label: f } = await Qt(e, t, "image-shape default"), y = t.pos === "t", m = -l / 2, x = -d / 2, b = t.label ? 8 : 0, v = Rt.svg(p), _ = Ot(t, {});
  t.look !== "handDrawn" && (_.roughness = 0, _.fillStyle = "solid");
  const A = v.rectangle(m, x, l, d, _), S = Math.max(l, g.width), k = d + g.height + b, L = v.rectangle(-S / 2, -k / 2, S, k, {
    ..._,
    fill: "none",
    stroke: "none"
  }), T = p.insert(() => A, ":first-child"), C = p.insert(() => L);
  if (t.img) {
    const E = p.append("image");
    E.attr("href", t.img), E.attr("width", l), E.attr("height", d), E.attr("preserveAspectRatio", "none"), E.attr(
      "transform",
      `translate(${-l / 2},${y ? k / 2 - d : -k / 2})`
    );
  }
  return f.attr(
    "transform",
    `translate(${-g.width / 2 - (g.x - (g.left ?? 0))},${y ? -d / 2 - g.height / 2 - b / 2 : d / 2 - g.height / 2 + b / 2})`
  ), T.attr(
    "transform",
    `translate(0,${y ? g.height / 2 + b / 2 : -g.height / 2 - b / 2})`
  ), Pt(t, C), t.intersect = function(E) {
    if (I.info("iconSquare intersect", t, E), !t.label)
      return Dt.rect(t, E);
    const w = t.x ?? 0, W = t.y ?? 0, N = t.height ?? 0;
    let B = [];
    return y ? B = [
      { x: w - g.width / 2, y: W - N / 2 },
      { x: w + g.width / 2, y: W - N / 2 },
      { x: w + g.width / 2, y: W - N / 2 + g.height + b },
      { x: w + l / 2, y: W - N / 2 + g.height + b },
      { x: w + l / 2, y: W + N / 2 },
      { x: w - l / 2, y: W + N / 2 },
      { x: w - l / 2, y: W - N / 2 + g.height + b },
      { x: w - g.width / 2, y: W - N / 2 + g.height + b }
    ] : B = [
      { x: w - l / 2, y: W - N / 2 },
      { x: w + l / 2, y: W - N / 2 },
      { x: w + l / 2, y: W - N / 2 + d },
      { x: w + g.width / 2, y: W - N / 2 + d },
      { x: w + g.width / 2 / 2, y: W + N / 2 },
      { x: w - g.width / 2, y: W + N / 2 },
      { x: w - g.width / 2, y: W - N / 2 + d },
      { x: w - l / 2, y: W - N / 2 + d }
    ], Dt.polygon(t, B, E);
  }, p;
}
u(wp, "imageSquare");
async function Tp(e, t) {
  const { labelStyles: r, nodeStyles: i } = It(t);
  t.labelStyle = r;
  const { shapeSvg: s, bbox: a } = await Qt(e, t, Xt(t)), n = Math.max(a.width + (t.padding ?? 0) * 2, (t == null ? void 0 : t.width) ?? 0), o = Math.max(a.height + (t.padding ?? 0) * 2, (t == null ? void 0 : t.height) ?? 0), h = [
    { x: 0, y: 0 },
    { x: n, y: 0 },
    { x: n + 3 * o / 6, y: -o },
    { x: -3 * o / 6, y: -o }
  ];
  let l;
  const { cssStyles: d } = t;
  if (t.look === "handDrawn") {
    const p = Rt.svg(s), g = Ot(t, {}), f = ce(h), y = p.path(f, g);
    l = s.insert(() => y, ":first-child").attr("transform", `translate(${-n / 2}, ${o / 2})`), d && l.attr("style", d);
  } else
    l = Mi(s, n, o, h);
  return i && l.attr("style", i), t.width = n, t.height = o, Pt(t, l), t.intersect = function(p) {
    return Dt.polygon(t, h, p);
  }, s;
}
u(Tp, "inv_trapezoid");
async function Ro(e, t, r) {
  const { labelStyles: i, nodeStyles: s } = It(t);
  t.labelStyle = i;
  const { shapeSvg: a, bbox: n } = await Qt(e, t, Xt(t)), o = Math.max(n.width + r.labelPaddingX * 2, (t == null ? void 0 : t.width) || 0), h = Math.max(n.height + r.labelPaddingY * 2, (t == null ? void 0 : t.height) || 0), l = -o / 2, d = -h / 2;
  let p, { rx: g, ry: f } = t;
  const { cssStyles: y } = t;
  if (r != null && r.rx && r.ry && (g = r.rx, f = r.ry), t.look === "handDrawn") {
    const m = Rt.svg(a), x = Ot(t, {}), b = g || f ? m.path(Ri(l, d, o, h, g || 0), x) : m.rectangle(l, d, o, h, x);
    p = a.insert(() => b, ":first-child"), p.attr("class", "basic label-container").attr("style", ar(y));
  } else
    p = a.insert("rect", ":first-child"), p.attr("class", "basic label-container").attr("style", s).attr("rx", ar(g)).attr("ry", ar(f)).attr("x", l).attr("y", d).attr("width", o).attr("height", h);
  return Pt(t, p), t.calcIntersect = function(m, x) {
    return Dt.rect(m, x);
  }, t.intersect = function(m) {
    return Dt.rect(t, m);
  }, a;
}
u(Ro, "drawRect");
async function _p(e, t) {
  const { shapeSvg: r, bbox: i, label: s } = await Qt(e, t, "label"), a = r.insert("rect", ":first-child");
  return a.attr("width", 0.1).attr("height", 0.1), r.attr("class", "label edgeLabel"), s.attr(
    "transform",
    `translate(${-(i.width / 2) - (i.x - (i.left ?? 0))}, ${-(i.height / 2) - (i.y - (i.top ?? 0))})`
  ), Pt(t, a), t.intersect = function(h) {
    return Dt.rect(t, h);
  }, r;
}
u(_p, "labelRect");
async function Ep(e, t) {
  const { labelStyles: r, nodeStyles: i } = It(t);
  t.labelStyle = r;
  const { shapeSvg: s, bbox: a } = await Qt(e, t, Xt(t)), n = Math.max(a.width + (t.padding ?? 0), (t == null ? void 0 : t.width) ?? 0), o = Math.max(a.height + (t.padding ?? 0), (t == null ? void 0 : t.height) ?? 0), h = [
    { x: 0, y: 0 },
    { x: n + 3 * o / 6, y: 0 },
    { x: n, y: -o },
    { x: -(3 * o) / 6, y: -o }
  ];
  let l;
  const { cssStyles: d } = t;
  if (t.look === "handDrawn") {
    const p = Rt.svg(s), g = Ot(t, {}), f = ce(h), y = p.path(f, g);
    l = s.insert(() => y, ":first-child").attr("transform", `translate(${-n / 2}, ${o / 2})`), d && l.attr("style", d);
  } else
    l = Mi(s, n, o, h);
  return i && l.attr("style", i), t.width = n, t.height = o, Pt(t, l), t.intersect = function(p) {
    return Dt.polygon(t, h, p);
  }, s;
}
u(Ep, "lean_left");
async function Ap(e, t) {
  const { labelStyles: r, nodeStyles: i } = It(t);
  t.labelStyle = r;
  const { shapeSvg: s, bbox: a } = await Qt(e, t, Xt(t)), n = Math.max(a.width + (t.padding ?? 0), (t == null ? void 0 : t.width) ?? 0), o = Math.max(a.height + (t.padding ?? 0), (t == null ? void 0 : t.height) ?? 0), h = [
    { x: -3 * o / 6, y: 0 },
    { x: n, y: 0 },
    { x: n + 3 * o / 6, y: -o },
    { x: 0, y: -o }
  ];
  let l;
  const { cssStyles: d } = t;
  if (t.look === "handDrawn") {
    const p = Rt.svg(s), g = Ot(t, {}), f = ce(h), y = p.path(f, g);
    l = s.insert(() => y, ":first-child").attr("transform", `translate(${-n / 2}, ${o / 2})`), d && l.attr("style", d);
  } else
    l = Mi(s, n, o, h);
  return i && l.attr("style", i), t.width = n, t.height = o, Pt(t, l), t.intersect = function(p) {
    return Dt.polygon(t, h, p);
  }, s;
}
u(Ap, "lean_right");
function Lp(e, t) {
  const { labelStyles: r, nodeStyles: i } = It(t);
  t.label = "", t.labelStyle = r;
  const s = e.insert("g").attr("class", Xt(t)).attr("id", t.domId ?? t.id), { cssStyles: a } = t, n = Math.max(35, (t == null ? void 0 : t.width) ?? 0), o = Math.max(35, (t == null ? void 0 : t.height) ?? 0), h = 7, l = [
    { x: n, y: 0 },
    { x: 0, y: o + h / 2 },
    { x: n - 2 * h, y: o + h / 2 },
    { x: 0, y: 2 * o },
    { x: n, y: o - h / 2 },
    { x: 2 * h, y: o - h / 2 }
  ], d = Rt.svg(s), p = Ot(t, {});
  t.look !== "handDrawn" && (p.roughness = 0, p.fillStyle = "solid");
  const g = ce(l), f = d.path(g, p), y = s.insert(() => f, ":first-child");
  return a && t.look !== "handDrawn" && y.selectAll("path").attr("style", a), i && t.look !== "handDrawn" && y.selectAll("path").attr("style", i), y.attr("transform", `translate(-${n / 2},${-o})`), Pt(t, y), t.intersect = function(m) {
    return I.info("lightningBolt intersect", t, m), Dt.polygon(t, l, m);
  }, s;
}
u(Lp, "lightningBolt");
var F3 = /* @__PURE__ */ u((e, t, r, i, s, a, n) => [
  `M${e},${t + a}`,
  `a${s},${a} 0,0,0 ${r},0`,
  `a${s},${a} 0,0,0 ${-r},0`,
  `l0,${i}`,
  `a${s},${a} 0,0,0 ${r},0`,
  `l0,${-i}`,
  `M${e},${t + a + n}`,
  `a${s},${a} 0,0,0 ${r},0`
].join(" "), "createCylinderPathD"), N3 = /* @__PURE__ */ u((e, t, r, i, s, a, n) => [
  `M${e},${t + a}`,
  `M${e + r},${t + a}`,
  `a${s},${a} 0,0,0 ${-r},0`,
  `l0,${i}`,
  `a${s},${a} 0,0,0 ${r},0`,
  `l0,${-i}`,
  `M${e},${t + a + n}`,
  `a${s},${a} 0,0,0 ${r},0`
].join(" "), "createOuterCylinderPathD"), R3 = /* @__PURE__ */ u((e, t, r, i, s, a) => [`M${e - r / 2},${-i / 2}`, `a${s},${a} 0,0,0 ${r},0`].join(" "), "createInnerCylinderPathD");
async function Bp(e, t) {
  const { labelStyles: r, nodeStyles: i } = It(t);
  t.labelStyle = r;
  const { shapeSvg: s, bbox: a, label: n } = await Qt(e, t, Xt(t)), o = Math.max(a.width + (t.padding ?? 0), t.width ?? 0), h = o / 2, l = h / (2.5 + o / 50), d = Math.max(a.height + l + (t.padding ?? 0), t.height ?? 0), p = d * 0.1;
  let g;
  const { cssStyles: f } = t;
  if (t.look === "handDrawn") {
    const y = Rt.svg(s), m = N3(0, 0, o, d, h, l, p), x = R3(0, l, o, d, h, l), b = Ot(t, {}), v = y.path(m, b), _ = y.path(x, b);
    s.insert(() => _, ":first-child").attr("class", "line"), g = s.insert(() => v, ":first-child"), g.attr("class", "basic label-container"), f && g.attr("style", f);
  } else {
    const y = F3(0, 0, o, d, h, l, p);
    g = s.insert("path", ":first-child").attr("d", y).attr("class", "basic label-container").attr("style", ar(f)).attr("style", i);
  }
  return g.attr("label-offset-y", l), g.attr("transform", `translate(${-o / 2}, ${-(d / 2 + l)})`), Pt(t, g), n.attr(
    "transform",
    `translate(${-(a.width / 2) - (a.x - (a.left ?? 0))}, ${-(a.height / 2) + l - (a.y - (a.top ?? 0))})`
  ), t.intersect = function(y) {
    const m = Dt.rect(t, y), x = m.x - (t.x ?? 0);
    if (h != 0 && (Math.abs(x) < (t.width ?? 0) / 2 || Math.abs(x) == (t.width ?? 0) / 2 && Math.abs(m.y - (t.y ?? 0)) > (t.height ?? 0) / 2 - l)) {
      let b = l * l * (1 - x * x / (h * h));
      b > 0 && (b = Math.sqrt(b)), b = l - b, y.y - (t.y ?? 0) > 0 && (b = -b), m.y += b;
    }
    return m;
  }, s;
}
u(Bp, "linedCylinder");
async function Dp(e, t) {
  const { labelStyles: r, nodeStyles: i } = It(t);
  t.labelStyle = r;
  const { shapeSvg: s, bbox: a, label: n } = await Qt(e, t, Xt(t)), o = Math.max(a.width + (t.padding ?? 0) * 2, (t == null ? void 0 : t.width) ?? 0), h = Math.max(a.height + (t.padding ?? 0) * 2, (t == null ? void 0 : t.height) ?? 0), l = h / 4, d = h + l, { cssStyles: p } = t, g = Rt.svg(s), f = Ot(t, {});
  t.look !== "handDrawn" && (f.roughness = 0, f.fillStyle = "solid");
  const y = [
    { x: -o / 2 - o / 2 * 0.1, y: -d / 2 },
    { x: -o / 2 - o / 2 * 0.1, y: d / 2 },
    ...Di(
      -o / 2 - o / 2 * 0.1,
      d / 2,
      o / 2 + o / 2 * 0.1,
      d / 2,
      l,
      0.8
    ),
    { x: o / 2 + o / 2 * 0.1, y: -d / 2 },
    { x: -o / 2 - o / 2 * 0.1, y: -d / 2 },
    { x: -o / 2, y: -d / 2 },
    { x: -o / 2, y: d / 2 * 1.1 },
    { x: -o / 2, y: -d / 2 }
  ], m = g.polygon(
    y.map((b) => [b.x, b.y]),
    f
  ), x = s.insert(() => m, ":first-child");
  return x.attr("class", "basic label-container"), p && t.look !== "handDrawn" && x.selectAll("path").attr("style", p), i && t.look !== "handDrawn" && x.selectAll("path").attr("style", i), x.attr("transform", `translate(0,${-l / 2})`), n.attr(
    "transform",
    `translate(${-o / 2 + (t.padding ?? 0) + o / 2 * 0.1 / 2 - (a.x - (a.left ?? 0))},${-h / 2 + (t.padding ?? 0) - l / 2 - (a.y - (a.top ?? 0))})`
  ), Pt(t, x), t.intersect = function(b) {
    return Dt.polygon(t, y, b);
  }, s;
}
u(Dp, "linedWaveEdgedRect");
async function Ip(e, t) {
  const { labelStyles: r, nodeStyles: i } = It(t);
  t.labelStyle = r;
  const { shapeSvg: s, bbox: a, label: n } = await Qt(e, t, Xt(t)), o = Math.max(a.width + (t.padding ?? 0) * 2, (t == null ? void 0 : t.width) ?? 0), h = Math.max(a.height + (t.padding ?? 0) * 2, (t == null ? void 0 : t.height) ?? 0), l = 5, d = -o / 2, p = -h / 2, { cssStyles: g } = t, f = Rt.svg(s), y = Ot(t, {}), m = [
    { x: d - l, y: p + l },
    { x: d - l, y: p + h + l },
    { x: d + o - l, y: p + h + l },
    { x: d + o - l, y: p + h },
    { x: d + o, y: p + h },
    { x: d + o, y: p + h - l },
    { x: d + o + l, y: p + h - l },
    { x: d + o + l, y: p - l },
    { x: d + l, y: p - l },
    { x: d + l, y: p },
    { x: d, y: p },
    { x: d, y: p + l }
  ], x = [
    { x: d, y: p + l },
    { x: d + o - l, y: p + l },
    { x: d + o - l, y: p + h },
    { x: d + o, y: p + h },
    { x: d + o, y: p },
    { x: d, y: p }
  ];
  t.look !== "handDrawn" && (y.roughness = 0, y.fillStyle = "solid");
  const b = ce(m), v = f.path(b, y), _ = ce(x), A = f.path(_, { ...y, fill: "none" }), S = s.insert(() => A, ":first-child");
  return S.insert(() => v, ":first-child"), S.attr("class", "basic label-container"), g && t.look !== "handDrawn" && S.selectAll("path").attr("style", g), i && t.look !== "handDrawn" && S.selectAll("path").attr("style", i), n.attr(
    "transform",
    `translate(${-(a.width / 2) - l - (a.x - (a.left ?? 0))}, ${-(a.height / 2) + l - (a.y - (a.top ?? 0))})`
  ), Pt(t, S), t.intersect = function(k) {
    return Dt.polygon(t, m, k);
  }, s;
}
u(Ip, "multiRect");
async function Fp(e, t) {
  const { labelStyles: r, nodeStyles: i } = It(t);
  t.labelStyle = r;
  const { shapeSvg: s, bbox: a, label: n } = await Qt(e, t, Xt(t)), o = Math.max(a.width + (t.padding ?? 0) * 2, (t == null ? void 0 : t.width) ?? 0), h = Math.max(a.height + (t.padding ?? 0) * 2, (t == null ? void 0 : t.height) ?? 0), l = h / 4, d = h + l, p = -o / 2, g = -d / 2, f = 5, { cssStyles: y } = t, m = Di(
    p - f,
    g + d + f,
    p + o - f,
    g + d + f,
    l,
    0.8
  ), x = m == null ? void 0 : m[m.length - 1], b = [
    { x: p - f, y: g + f },
    { x: p - f, y: g + d + f },
    ...m,
    { x: p + o - f, y: x.y - f },
    { x: p + o, y: x.y - f },
    { x: p + o, y: x.y - 2 * f },
    { x: p + o + f, y: x.y - 2 * f },
    { x: p + o + f, y: g - f },
    { x: p + f, y: g - f },
    { x: p + f, y: g },
    { x: p, y: g },
    { x: p, y: g + f }
  ], v = [
    { x: p, y: g + f },
    { x: p + o - f, y: g + f },
    { x: p + o - f, y: x.y - f },
    { x: p + o, y: x.y - f },
    { x: p + o, y: g },
    { x: p, y: g }
  ], _ = Rt.svg(s), A = Ot(t, {});
  t.look !== "handDrawn" && (A.roughness = 0, A.fillStyle = "solid");
  const S = ce(b), k = _.path(S, A), L = ce(v), T = _.path(L, A), C = s.insert(() => k, ":first-child");
  return C.insert(() => T), C.attr("class", "basic label-container"), y && t.look !== "handDrawn" && C.selectAll("path").attr("style", y), i && t.look !== "handDrawn" && C.selectAll("path").attr("style", i), C.attr("transform", `translate(0,${-l / 2})`), n.attr(
    "transform",
    `translate(${-(a.width / 2) - f - (a.x - (a.left ?? 0))}, ${-(a.height / 2) + f - l / 2 - (a.y - (a.top ?? 0))})`
  ), Pt(t, C), t.intersect = function(E) {
    return Dt.polygon(t, b, E);
  }, s;
}
u(Fp, "multiWaveEdgedRectangle");
async function Np(e, t, { config: { themeVariables: r } }) {
  var v;
  const { labelStyles: i, nodeStyles: s } = It(t);
  t.labelStyle = i, t.useHtmlLabels || ((v = fe().flowchart) == null ? void 0 : v.htmlLabels) !== !1 || (t.centerLabel = !0);
  const { shapeSvg: n, bbox: o, label: h } = await Qt(e, t, Xt(t)), l = Math.max(o.width + (t.padding ?? 0) * 2, (t == null ? void 0 : t.width) ?? 0), d = Math.max(o.height + (t.padding ?? 0) * 2, (t == null ? void 0 : t.height) ?? 0), p = -l / 2, g = -d / 2, { cssStyles: f } = t, y = Rt.svg(n), m = Ot(t, {
    fill: r.noteBkgColor,
    stroke: r.noteBorderColor
  });
  t.look !== "handDrawn" && (m.roughness = 0, m.fillStyle = "solid");
  const x = y.rectangle(p, g, l, d, m), b = n.insert(() => x, ":first-child");
  return b.attr("class", "basic label-container"), f && t.look !== "handDrawn" && b.selectAll("path").attr("style", f), s && t.look !== "handDrawn" && b.selectAll("path").attr("style", s), h.attr(
    "transform",
    `translate(${-o.width / 2 - (o.x - (o.left ?? 0))}, ${-(o.height / 2) - (o.y - (o.top ?? 0))})`
  ), Pt(t, b), t.intersect = function(_) {
    return Dt.rect(t, _);
  }, n;
}
u(Np, "note");
var M3 = /* @__PURE__ */ u((e, t, r) => [
  `M${e + r / 2},${t}`,
  `L${e + r},${t - r / 2}`,
  `L${e + r / 2},${t - r}`,
  `L${e},${t - r / 2}`,
  "Z"
].join(" "), "createDecisionBoxPathD");
async function Rp(e, t) {
  const { labelStyles: r, nodeStyles: i } = It(t);
  t.labelStyle = r;
  const { shapeSvg: s, bbox: a } = await Qt(e, t, Xt(t)), n = a.width + t.padding, o = a.height + t.padding, h = n + o, l = 0.5, d = [
    { x: h / 2, y: 0 },
    { x: h, y: -h / 2 },
    { x: h / 2, y: -h },
    { x: 0, y: -h / 2 }
  ];
  let p;
  const { cssStyles: g } = t;
  if (t.look === "handDrawn") {
    const f = Rt.svg(s), y = Ot(t, {}), m = M3(0, 0, h), x = f.path(m, y);
    p = s.insert(() => x, ":first-child").attr("transform", `translate(${-h / 2 + l}, ${h / 2})`), g && p.attr("style", g);
  } else
    p = Mi(s, h, h, d), p.attr("transform", `translate(${-h / 2 + l}, ${h / 2})`);
  return i && p.attr("style", i), Pt(t, p), t.calcIntersect = function(f, y) {
    const m = f.width, x = [
      { x: m / 2, y: 0 },
      { x: m, y: -m / 2 },
      { x: m / 2, y: -m },
      { x: 0, y: -m / 2 }
    ], b = Dt.polygon(f, x, y);
    return { x: b.x - 0.5, y: b.y - 0.5 };
  }, t.intersect = function(f) {
    return this.calcIntersect(t, f);
  }, s;
}
u(Rp, "question");
async function Mp(e, t) {
  const { labelStyles: r, nodeStyles: i } = It(t);
  t.labelStyle = r;
  const { shapeSvg: s, bbox: a, label: n } = await Qt(e, t, Xt(t)), o = Math.max(a.width + (t.padding ?? 0), (t == null ? void 0 : t.width) ?? 0), h = Math.max(a.height + (t.padding ?? 0), (t == null ? void 0 : t.height) ?? 0), l = -o / 2, d = -h / 2, p = d / 2, g = [
    { x: l + p, y: d },
    { x: l, y: 0 },
    { x: l + p, y: -d },
    { x: -l, y: -d },
    { x: -l, y: d }
  ], { cssStyles: f } = t, y = Rt.svg(s), m = Ot(t, {});
  t.look !== "handDrawn" && (m.roughness = 0, m.fillStyle = "solid");
  const x = ce(g), b = y.path(x, m), v = s.insert(() => b, ":first-child");
  return v.attr("class", "basic label-container"), f && t.look !== "handDrawn" && v.selectAll("path").attr("style", f), i && t.look !== "handDrawn" && v.selectAll("path").attr("style", i), v.attr("transform", `translate(${-p / 2},0)`), n.attr(
    "transform",
    `translate(${-p / 2 - a.width / 2 - (a.x - (a.left ?? 0))}, ${-(a.height / 2) - (a.y - (a.top ?? 0))})`
  ), Pt(t, v), t.intersect = function(_) {
    return Dt.polygon(t, g, _);
  }, s;
}
u(Mp, "rect_left_inv_arrow");
async function Op(e, t) {
  var T, C;
  const { labelStyles: r, nodeStyles: i } = It(t);
  t.labelStyle = r;
  let s;
  t.cssClasses ? s = "node " + t.cssClasses : s = "node default";
  const a = e.insert("g").attr("class", s).attr("id", t.domId || t.id), n = a.insert("g"), o = a.insert("g").attr("class", "label").attr("style", i), h = t.description, l = t.label, d = o.node().appendChild(await Xi(l, t.labelStyle, !0, !0));
  let p = { width: 0, height: 0 };
  if (ke((C = (T = K()) == null ? void 0 : T.flowchart) == null ? void 0 : C.htmlLabels)) {
    const E = d.children[0], w = yt(d);
    p = E.getBoundingClientRect(), w.attr("width", p.width), w.attr("height", p.height);
  }
  I.info("Text 2", h);
  const g = h || [], f = d.getBBox(), y = o.node().appendChild(
    await Xi(
      g.join ? g.join("<br/>") : g,
      t.labelStyle,
      !0,
      !0
    )
  ), m = y.children[0], x = yt(y);
  p = m.getBoundingClientRect(), x.attr("width", p.width), x.attr("height", p.height);
  const b = (t.padding || 0) / 2;
  yt(y).attr(
    "transform",
    "translate( " + (p.width > f.width ? 0 : (f.width - p.width) / 2) + ", " + (f.height + b + 5) + ")"
  ), yt(d).attr(
    "transform",
    "translate( " + (p.width < f.width ? 0 : -(f.width - p.width) / 2) + ", 0)"
  ), p = o.node().getBBox(), o.attr(
    "transform",
    "translate(" + -p.width / 2 + ", " + (-p.height / 2 - b + 3) + ")"
  );
  const v = p.width + (t.padding || 0), _ = p.height + (t.padding || 0), A = -p.width / 2 - b, S = -p.height / 2 - b;
  let k, L;
  if (t.look === "handDrawn") {
    const E = Rt.svg(a), w = Ot(t, {}), W = E.path(
      Ri(A, S, v, _, t.rx || 0),
      w
    ), N = E.line(
      -p.width / 2 - b,
      -p.height / 2 - b + f.height + b,
      p.width / 2 + b,
      -p.height / 2 - b + f.height + b,
      w
    );
    L = a.insert(() => (I.debug("Rough node insert CXC", W), N), ":first-child"), k = a.insert(() => (I.debug("Rough node insert CXC", W), W), ":first-child");
  } else
    k = n.insert("rect", ":first-child"), L = n.insert("line"), k.attr("class", "outer title-state").attr("style", i).attr("x", -p.width / 2 - b).attr("y", -p.height / 2 - b).attr("width", p.width + (t.padding || 0)).attr("height", p.height + (t.padding || 0)), L.attr("class", "divider").attr("x1", -p.width / 2 - b).attr("x2", p.width / 2 + b).attr("y1", -p.height / 2 - b + f.height + b).attr("y2", -p.height / 2 - b + f.height + b);
  return Pt(t, k), t.intersect = function(E) {
    return Dt.rect(t, E);
  }, a;
}
u(Op, "rectWithTitle");
function Da(e, t, r, i, s, a, n) {
  const h = (e + r) / 2, l = (t + i) / 2, d = Math.atan2(i - t, r - e), p = (r - e) / 2, g = (i - t) / 2, f = p / s, y = g / a, m = Math.sqrt(f ** 2 + y ** 2);
  if (m > 1)
    throw new Error("The given radii are too small to create an arc between the points.");
  const x = Math.sqrt(1 - m ** 2), b = h + x * a * Math.sin(d) * (n ? -1 : 1), v = l - x * s * Math.cos(d) * (n ? -1 : 1), _ = Math.atan2((t - v) / a, (e - b) / s);
  let S = Math.atan2((i - v) / a, (r - b) / s) - _;
  n && S < 0 && (S += 2 * Math.PI), !n && S > 0 && (S -= 2 * Math.PI);
  const k = [];
  for (let L = 0; L < 20; L++) {
    const T = L / 19, C = _ + T * S, E = b + s * Math.cos(C), w = v + a * Math.sin(C);
    k.push({ x: E, y: w });
  }
  return k;
}
u(Da, "generateArcPoints");
async function Pp(e, t) {
  const { labelStyles: r, nodeStyles: i } = It(t);
  t.labelStyle = r;
  const { shapeSvg: s, bbox: a } = await Qt(e, t, Xt(t)), n = (t == null ? void 0 : t.padding) ?? 0, o = (t == null ? void 0 : t.padding) ?? 0, h = (t != null && t.width ? t == null ? void 0 : t.width : a.width) + n * 2, l = (t != null && t.height ? t == null ? void 0 : t.height : a.height) + o * 2, d = t.radius || 5, p = t.taper || 5, { cssStyles: g } = t, f = Rt.svg(s), y = Ot(t, {});
  t.stroke && (y.stroke = t.stroke), t.look !== "handDrawn" && (y.roughness = 0, y.fillStyle = "solid");
  const m = [
    // Top edge (left to right)
    { x: -h / 2 + p, y: -l / 2 },
    // Top-left corner start (1)
    { x: h / 2 - p, y: -l / 2 },
    // Top-right corner start (2)
    ...Da(h / 2 - p, -l / 2, h / 2, -l / 2 + p, d, d, !0),
    // Top-left arc (2 to 3)
    // Right edge (top to bottom)
    { x: h / 2, y: -l / 2 + p },
    // Top-right taper point (3)
    { x: h / 2, y: l / 2 - p },
    // Bottom-right taper point (4)
    ...Da(h / 2, l / 2 - p, h / 2 - p, l / 2, d, d, !0),
    // Top-left arc (4 to 5)
    // Bottom edge (right to left)
    { x: h / 2 - p, y: l / 2 },
    // Bottom-right corner start (5)
    { x: -h / 2 + p, y: l / 2 },
    // Bottom-left corner start (6)
    ...Da(-h / 2 + p, l / 2, -h / 2, l / 2 - p, d, d, !0),
    // Top-left arc (4 to 5)
    // Left edge (bottom to top)
    { x: -h / 2, y: l / 2 - p },
    // Bottom-left taper point (7)
    { x: -h / 2, y: -l / 2 + p },
    // Top-left taper point (8)
    ...Da(-h / 2, -l / 2 + p, -h / 2 + p, -l / 2, d, d, !0)
    // Top-left arc (4 to 5)
  ], x = ce(m), b = f.path(x, y), v = s.insert(() => b, ":first-child");
  return v.attr("class", "basic label-container outer-path"), g && t.look !== "handDrawn" && v.selectChildren("path").attr("style", g), i && t.look !== "handDrawn" && v.selectChildren("path").attr("style", i), Pt(t, v), t.intersect = function(_) {
    return Dt.polygon(t, m, _);
  }, s;
}
u(Pp, "roundedRect");
async function $p(e, t) {
  const { labelStyles: r, nodeStyles: i } = It(t);
  t.labelStyle = r;
  const { shapeSvg: s, bbox: a, label: n } = await Qt(e, t, Xt(t)), o = (t == null ? void 0 : t.padding) ?? 0, h = Math.max(a.width + (t.padding ?? 0) * 2, (t == null ? void 0 : t.width) ?? 0), l = Math.max(a.height + (t.padding ?? 0) * 2, (t == null ? void 0 : t.height) ?? 0), d = -a.width / 2 - o, p = -a.height / 2 - o, { cssStyles: g } = t, f = Rt.svg(s), y = Ot(t, {});
  t.look !== "handDrawn" && (y.roughness = 0, y.fillStyle = "solid");
  const m = [
    { x: d, y: p },
    { x: d + h + 8, y: p },
    { x: d + h + 8, y: p + l },
    { x: d - 8, y: p + l },
    { x: d - 8, y: p },
    { x: d, y: p },
    { x: d, y: p + l }
  ], x = f.polygon(
    m.map((v) => [v.x, v.y]),
    y
  ), b = s.insert(() => x, ":first-child");
  return b.attr("class", "basic label-container").attr("style", ar(g)), i && t.look !== "handDrawn" && b.selectAll("path").attr("style", i), g && t.look !== "handDrawn" && b.selectAll("path").attr("style", i), n.attr(
    "transform",
    `translate(${-h / 2 + 4 + (t.padding ?? 0) - (a.x - (a.left ?? 0))},${-l / 2 + (t.padding ?? 0) - (a.y - (a.top ?? 0))})`
  ), Pt(t, b), t.intersect = function(v) {
    return Dt.rect(t, v);
  }, s;
}
u($p, "shadedProcess");
async function Vp(e, t) {
  const { labelStyles: r, nodeStyles: i } = It(t);
  t.labelStyle = r;
  const { shapeSvg: s, bbox: a, label: n } = await Qt(e, t, Xt(t)), o = Math.max(a.width + (t.padding ?? 0) * 2, (t == null ? void 0 : t.width) ?? 0), h = Math.max(a.height + (t.padding ?? 0) * 2, (t == null ? void 0 : t.height) ?? 0), l = -o / 2, d = -h / 2, { cssStyles: p } = t, g = Rt.svg(s), f = Ot(t, {});
  t.look !== "handDrawn" && (f.roughness = 0, f.fillStyle = "solid");
  const y = [
    { x: l, y: d },
    { x: l, y: d + h },
    { x: l + o, y: d + h },
    { x: l + o, y: d - h / 2 }
  ], m = ce(y), x = g.path(m, f), b = s.insert(() => x, ":first-child");
  return b.attr("class", "basic label-container"), p && t.look !== "handDrawn" && b.selectChildren("path").attr("style", p), i && t.look !== "handDrawn" && b.selectChildren("path").attr("style", i), b.attr("transform", `translate(0, ${h / 4})`), n.attr(
    "transform",
    `translate(${-o / 2 + (t.padding ?? 0) - (a.x - (a.left ?? 0))}, ${-h / 4 + (t.padding ?? 0) - (a.y - (a.top ?? 0))})`
  ), Pt(t, b), t.intersect = function(v) {
    return Dt.polygon(t, y, v);
  }, s;
}
u(Vp, "slopedRect");
async function zp(e, t) {
  const r = {
    rx: 0,
    ry: 0,
    labelPaddingX: t.labelPaddingX ?? ((t == null ? void 0 : t.padding) || 0) * 2,
    labelPaddingY: ((t == null ? void 0 : t.padding) || 0) * 1
  };
  return Ro(e, t, r);
}
u(zp, "squareRect");
async function Wp(e, t) {
  const { labelStyles: r, nodeStyles: i } = It(t);
  t.labelStyle = r;
  const { shapeSvg: s, bbox: a } = await Qt(e, t, Xt(t)), n = a.height + t.padding, o = a.width + n / 4 + t.padding, h = n / 2, { cssStyles: l } = t, d = Rt.svg(s), p = Ot(t, {});
  t.look !== "handDrawn" && (p.roughness = 0, p.fillStyle = "solid");
  const g = [
    { x: -o / 2 + h, y: -n / 2 },
    { x: o / 2 - h, y: -n / 2 },
    ...Qa(-o / 2 + h, 0, h, 50, 90, 270),
    { x: o / 2 - h, y: n / 2 },
    ...Qa(o / 2 - h, 0, h, 50, 270, 450)
  ], f = ce(g), y = d.path(f, p), m = s.insert(() => y, ":first-child");
  return m.attr("class", "basic label-container outer-path"), l && t.look !== "handDrawn" && m.selectChildren("path").attr("style", l), i && t.look !== "handDrawn" && m.selectChildren("path").attr("style", i), Pt(t, m), t.intersect = function(x) {
    return Dt.polygon(t, g, x);
  }, s;
}
u(Wp, "stadium");
async function qp(e, t) {
  return Ro(e, t, {
    rx: 5,
    ry: 5
  });
}
u(qp, "state");
function Yp(e, t, { config: { themeVariables: r } }) {
  const { labelStyles: i, nodeStyles: s } = It(t);
  t.labelStyle = i;
  const { cssStyles: a } = t, { lineColor: n, stateBorder: o, nodeBorder: h } = r, l = e.insert("g").attr("class", "node default").attr("id", t.domId || t.id), d = Rt.svg(l), p = Ot(t, {});
  t.look !== "handDrawn" && (p.roughness = 0, p.fillStyle = "solid");
  const g = d.circle(0, 0, 14, {
    ...p,
    stroke: n,
    strokeWidth: 2
  }), f = o ?? h, y = d.circle(0, 0, 5, {
    ...p,
    fill: f,
    stroke: f,
    strokeWidth: 2,
    fillStyle: "solid"
  }), m = l.insert(() => g, ":first-child");
  return m.insert(() => y), a && m.selectAll("path").attr("style", a), s && m.selectAll("path").attr("style", s), Pt(t, m), t.intersect = function(x) {
    return Dt.circle(t, 7, x);
  }, l;
}
u(Yp, "stateEnd");
function Hp(e, t, { config: { themeVariables: r } }) {
  const { lineColor: i } = r, s = e.insert("g").attr("class", "node default").attr("id", t.domId || t.id);
  let a;
  if (t.look === "handDrawn") {
    const o = Rt.svg(s).circle(0, 0, 14, Jb(i));
    a = s.insert(() => o), a.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14);
  } else
    a = s.insert("circle", ":first-child"), a.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14);
  return Pt(t, a), t.intersect = function(n) {
    return Dt.circle(t, 7, n);
  }, s;
}
u(Hp, "stateStart");
async function Up(e, t) {
  const { labelStyles: r, nodeStyles: i } = It(t);
  t.labelStyle = r;
  const { shapeSvg: s, bbox: a } = await Qt(e, t, Xt(t)), n = ((t == null ? void 0 : t.padding) || 0) / 2, o = a.width + t.padding, h = a.height + t.padding, l = -a.width / 2 - n, d = -a.height / 2 - n, p = [
    { x: 0, y: 0 },
    { x: o, y: 0 },
    { x: o, y: -h },
    { x: 0, y: -h },
    { x: 0, y: 0 },
    { x: -8, y: 0 },
    { x: o + 8, y: 0 },
    { x: o + 8, y: -h },
    { x: -8, y: -h },
    { x: -8, y: 0 }
  ];
  if (t.look === "handDrawn") {
    const g = Rt.svg(s), f = Ot(t, {}), y = g.rectangle(l - 8, d, o + 16, h, f), m = g.line(l, d, l, d + h, f), x = g.line(l + o, d, l + o, d + h, f);
    s.insert(() => m, ":first-child"), s.insert(() => x, ":first-child");
    const b = s.insert(() => y, ":first-child"), { cssStyles: v } = t;
    b.attr("class", "basic label-container").attr("style", ar(v)), Pt(t, b);
  } else {
    const g = Mi(s, o, h, p);
    i && g.attr("style", i), Pt(t, g);
  }
  return t.intersect = function(g) {
    return Dt.polygon(t, p, g);
  }, s;
}
u(Up, "subroutine");
async function jp(e, t) {
  const { labelStyles: r, nodeStyles: i } = It(t);
  t.labelStyle = r;
  const { shapeSvg: s, bbox: a } = await Qt(e, t, Xt(t)), n = Math.max(a.width + (t.padding ?? 0) * 2, (t == null ? void 0 : t.width) ?? 0), o = Math.max(a.height + (t.padding ?? 0) * 2, (t == null ? void 0 : t.height) ?? 0), h = -n / 2, l = -o / 2, d = 0.2 * o, p = 0.2 * o, { cssStyles: g } = t, f = Rt.svg(s), y = Ot(t, {}), m = [
    { x: h - d / 2, y: l },
    { x: h + n + d / 2, y: l },
    { x: h + n + d / 2, y: l + o },
    { x: h - d / 2, y: l + o }
  ], x = [
    { x: h + n - d / 2, y: l + o },
    { x: h + n + d / 2, y: l + o },
    { x: h + n + d / 2, y: l + o - p }
  ];
  t.look !== "handDrawn" && (y.roughness = 0, y.fillStyle = "solid");
  const b = ce(m), v = f.path(b, y), _ = ce(x), A = f.path(_, { ...y, fillStyle: "solid" }), S = s.insert(() => A, ":first-child");
  return S.insert(() => v, ":first-child"), S.attr("class", "basic label-container"), g && t.look !== "handDrawn" && S.selectAll("path").attr("style", g), i && t.look !== "handDrawn" && S.selectAll("path").attr("style", i), Pt(t, S), t.intersect = function(k) {
    return Dt.polygon(t, m, k);
  }, s;
}
u(jp, "taggedRect");
async function Gp(e, t) {
  const { labelStyles: r, nodeStyles: i } = It(t);
  t.labelStyle = r;
  const { shapeSvg: s, bbox: a, label: n } = await Qt(e, t, Xt(t)), o = Math.max(a.width + (t.padding ?? 0) * 2, (t == null ? void 0 : t.width) ?? 0), h = Math.max(a.height + (t.padding ?? 0) * 2, (t == null ? void 0 : t.height) ?? 0), l = h / 4, d = 0.2 * o, p = 0.2 * h, g = h + l, { cssStyles: f } = t, y = Rt.svg(s), m = Ot(t, {});
  t.look !== "handDrawn" && (m.roughness = 0, m.fillStyle = "solid");
  const x = [
    { x: -o / 2 - o / 2 * 0.1, y: g / 2 },
    ...Di(
      -o / 2 - o / 2 * 0.1,
      g / 2,
      o / 2 + o / 2 * 0.1,
      g / 2,
      l,
      0.8
    ),
    { x: o / 2 + o / 2 * 0.1, y: -g / 2 },
    { x: -o / 2 - o / 2 * 0.1, y: -g / 2 }
  ], b = -o / 2 + o / 2 * 0.1, v = -g / 2 - p * 0.4, _ = [
    { x: b + o - d, y: (v + h) * 1.4 },
    { x: b + o, y: v + h - p },
    { x: b + o, y: (v + h) * 0.9 },
    ...Di(
      b + o,
      (v + h) * 1.3,
      b + o - d,
      (v + h) * 1.5,
      -h * 0.03,
      0.5
    )
  ], A = ce(x), S = y.path(A, m), k = ce(_), L = y.path(k, {
    ...m,
    fillStyle: "solid"
  }), T = s.insert(() => L, ":first-child");
  return T.insert(() => S, ":first-child"), T.attr("class", "basic label-container"), f && t.look !== "handDrawn" && T.selectAll("path").attr("style", f), i && t.look !== "handDrawn" && T.selectAll("path").attr("style", i), T.attr("transform", `translate(0,${-l / 2})`), n.attr(
    "transform",
    `translate(${-o / 2 + (t.padding ?? 0) - (a.x - (a.left ?? 0))},${-h / 2 + (t.padding ?? 0) - l / 2 - (a.y - (a.top ?? 0))})`
  ), Pt(t, T), t.intersect = function(C) {
    return Dt.polygon(t, x, C);
  }, s;
}
u(Gp, "taggedWaveEdgedRectangle");
async function Xp(e, t) {
  const { labelStyles: r, nodeStyles: i } = It(t);
  t.labelStyle = r;
  const { shapeSvg: s, bbox: a } = await Qt(e, t, Xt(t)), n = Math.max(a.width + t.padding, (t == null ? void 0 : t.width) || 0), o = Math.max(a.height + t.padding, (t == null ? void 0 : t.height) || 0), h = -n / 2, l = -o / 2, d = s.insert("rect", ":first-child");
  return d.attr("class", "text").attr("style", i).attr("rx", 0).attr("ry", 0).attr("x", h).attr("y", l).attr("width", n).attr("height", o), Pt(t, d), t.intersect = function(p) {
    return Dt.rect(t, p);
  }, s;
}
u(Xp, "text");
var O3 = /* @__PURE__ */ u((e, t, r, i, s, a) => `M${e},${t}
    a${s},${a} 0,0,1 0,${-i}
    l${r},0
    a${s},${a} 0,0,1 0,${i}
    M${r},${-i}
    a${s},${a} 0,0,0 0,${i}
    l${-r},0`, "createCylinderPathD"), P3 = /* @__PURE__ */ u((e, t, r, i, s, a) => [
  `M${e},${t}`,
  `M${e + r},${t}`,
  `a${s},${a} 0,0,0 0,${-i}`,
  `l${-r},0`,
  `a${s},${a} 0,0,0 0,${i}`,
  `l${r},0`
].join(" "), "createOuterCylinderPathD"), $3 = /* @__PURE__ */ u((e, t, r, i, s, a) => [`M${e + r / 2},${-i / 2}`, `a${s},${a} 0,0,0 0,${i}`].join(" "), "createInnerCylinderPathD");
async function Kp(e, t) {
  const { labelStyles: r, nodeStyles: i } = It(t);
  t.labelStyle = r;
  const { shapeSvg: s, bbox: a, label: n, halfPadding: o } = await Qt(
    e,
    t,
    Xt(t)
  ), h = t.look === "neo" ? o * 2 : o, l = a.height + h, d = l / 2, p = d / (2.5 + l / 50), g = a.width + p + h, { cssStyles: f } = t;
  let y;
  if (t.look === "handDrawn") {
    const m = Rt.svg(s), x = P3(0, 0, g, l, p, d), b = $3(0, 0, g, l, p, d), v = m.path(x, Ot(t, {})), _ = m.path(b, Ot(t, { fill: "none" }));
    y = s.insert(() => _, ":first-child"), y = s.insert(() => v, ":first-child"), y.attr("class", "basic label-container"), f && y.attr("style", f);
  } else {
    const m = O3(0, 0, g, l, p, d);
    y = s.insert("path", ":first-child").attr("d", m).attr("class", "basic label-container").attr("style", ar(f)).attr("style", i), y.attr("class", "basic label-container"), f && y.selectAll("path").attr("style", f), i && y.selectAll("path").attr("style", i);
  }
  return y.attr("label-offset-x", p), y.attr("transform", `translate(${-g / 2}, ${l / 2} )`), n.attr(
    "transform",
    `translate(${-(a.width / 2) - p - (a.x - (a.left ?? 0))}, ${-(a.height / 2) - (a.y - (a.top ?? 0))})`
  ), Pt(t, y), t.intersect = function(m) {
    const x = Dt.rect(t, m), b = x.y - (t.y ?? 0);
    if (d != 0 && (Math.abs(b) < (t.height ?? 0) / 2 || Math.abs(b) == (t.height ?? 0) / 2 && Math.abs(x.x - (t.x ?? 0)) > (t.width ?? 0) / 2 - p)) {
      let v = p * p * (1 - b * b / (d * d));
      v != 0 && (v = Math.sqrt(Math.abs(v))), v = p - v, m.x - (t.x ?? 0) > 0 && (v = -v), x.x += v;
    }
    return x;
  }, s;
}
u(Kp, "tiltedCylinder");
async function Qp(e, t) {
  const { labelStyles: r, nodeStyles: i } = It(t);
  t.labelStyle = r;
  const { shapeSvg: s, bbox: a } = await Qt(e, t, Xt(t)), n = a.width + t.padding, o = a.height + t.padding, h = [
    { x: -3 * o / 6, y: 0 },
    { x: n + 3 * o / 6, y: 0 },
    { x: n, y: -o },
    { x: 0, y: -o }
  ];
  let l;
  const { cssStyles: d } = t;
  if (t.look === "handDrawn") {
    const p = Rt.svg(s), g = Ot(t, {}), f = ce(h), y = p.path(f, g);
    l = s.insert(() => y, ":first-child").attr("transform", `translate(${-n / 2}, ${o / 2})`), d && l.attr("style", d);
  } else
    l = Mi(s, n, o, h);
  return i && l.attr("style", i), t.width = n, t.height = o, Pt(t, l), t.intersect = function(p) {
    return Dt.polygon(t, h, p);
  }, s;
}
u(Qp, "trapezoid");
async function Zp(e, t) {
  const { labelStyles: r, nodeStyles: i } = It(t);
  t.labelStyle = r;
  const { shapeSvg: s, bbox: a } = await Qt(e, t, Xt(t)), n = 60, o = 20, h = Math.max(n, a.width + (t.padding ?? 0) * 2, (t == null ? void 0 : t.width) ?? 0), l = Math.max(o, a.height + (t.padding ?? 0) * 2, (t == null ? void 0 : t.height) ?? 0), { cssStyles: d } = t, p = Rt.svg(s), g = Ot(t, {});
  t.look !== "handDrawn" && (g.roughness = 0, g.fillStyle = "solid");
  const f = [
    { x: -h / 2 * 0.8, y: -l / 2 },
    { x: h / 2 * 0.8, y: -l / 2 },
    { x: h / 2, y: -l / 2 * 0.6 },
    { x: h / 2, y: l / 2 },
    { x: -h / 2, y: l / 2 },
    { x: -h / 2, y: -l / 2 * 0.6 }
  ], y = ce(f), m = p.path(y, g), x = s.insert(() => m, ":first-child");
  return x.attr("class", "basic label-container"), d && t.look !== "handDrawn" && x.selectChildren("path").attr("style", d), i && t.look !== "handDrawn" && x.selectChildren("path").attr("style", i), Pt(t, x), t.intersect = function(b) {
    return Dt.polygon(t, f, b);
  }, s;
}
u(Zp, "trapezoidalPentagon");
async function Jp(e, t) {
  var v;
  const { labelStyles: r, nodeStyles: i } = It(t);
  t.labelStyle = r;
  const { shapeSvg: s, bbox: a, label: n } = await Qt(e, t, Xt(t)), o = ke((v = K().flowchart) == null ? void 0 : v.htmlLabels), h = a.width + (t.padding ?? 0), l = h + a.height, d = h + a.height, p = [
    { x: 0, y: 0 },
    { x: d, y: 0 },
    { x: d / 2, y: -l }
  ], { cssStyles: g } = t, f = Rt.svg(s), y = Ot(t, {});
  t.look !== "handDrawn" && (y.roughness = 0, y.fillStyle = "solid");
  const m = ce(p), x = f.path(m, y), b = s.insert(() => x, ":first-child").attr("transform", `translate(${-l / 2}, ${l / 2})`);
  return g && t.look !== "handDrawn" && b.selectChildren("path").attr("style", g), i && t.look !== "handDrawn" && b.selectChildren("path").attr("style", i), t.width = h, t.height = l, Pt(t, b), n.attr(
    "transform",
    `translate(${-a.width / 2 - (a.x - (a.left ?? 0))}, ${l / 2 - (a.height + (t.padding ?? 0) / (o ? 2 : 1) - (a.y - (a.top ?? 0)))})`
  ), t.intersect = function(_) {
    return I.info("Triangle intersect", t, p, _), Dt.polygon(t, p, _);
  }, s;
}
u(Jp, "triangle");
async function tg(e, t) {
  const { labelStyles: r, nodeStyles: i } = It(t);
  t.labelStyle = r;
  const { shapeSvg: s, bbox: a, label: n } = await Qt(e, t, Xt(t)), o = Math.max(a.width + (t.padding ?? 0) * 2, (t == null ? void 0 : t.width) ?? 0), h = Math.max(a.height + (t.padding ?? 0) * 2, (t == null ? void 0 : t.height) ?? 0), l = h / 8, d = h + l, { cssStyles: p } = t, f = 70 - o, y = f > 0 ? f / 2 : 0, m = Rt.svg(s), x = Ot(t, {});
  t.look !== "handDrawn" && (x.roughness = 0, x.fillStyle = "solid");
  const b = [
    { x: -o / 2 - y, y: d / 2 },
    ...Di(
      -o / 2 - y,
      d / 2,
      o / 2 + y,
      d / 2,
      l,
      0.8
    ),
    { x: o / 2 + y, y: -d / 2 },
    { x: -o / 2 - y, y: -d / 2 }
  ], v = ce(b), _ = m.path(v, x), A = s.insert(() => _, ":first-child");
  return A.attr("class", "basic label-container"), p && t.look !== "handDrawn" && A.selectAll("path").attr("style", p), i && t.look !== "handDrawn" && A.selectAll("path").attr("style", i), A.attr("transform", `translate(0,${-l / 2})`), n.attr(
    "transform",
    `translate(${-o / 2 + (t.padding ?? 0) - (a.x - (a.left ?? 0))},${-h / 2 + (t.padding ?? 0) - l - (a.y - (a.top ?? 0))})`
  ), Pt(t, A), t.intersect = function(S) {
    return Dt.polygon(t, b, S);
  }, s;
}
u(tg, "waveEdgedRectangle");
async function eg(e, t) {
  const { labelStyles: r, nodeStyles: i } = It(t);
  t.labelStyle = r;
  const { shapeSvg: s, bbox: a } = await Qt(e, t, Xt(t)), n = 100, o = 50, h = Math.max(a.width + (t.padding ?? 0) * 2, (t == null ? void 0 : t.width) ?? 0), l = Math.max(a.height + (t.padding ?? 0) * 2, (t == null ? void 0 : t.height) ?? 0), d = h / l;
  let p = h, g = l;
  p > g * d ? g = p / d : p = g * d, p = Math.max(p, n), g = Math.max(g, o);
  const f = Math.min(g * 0.2, g / 4), y = g + f * 2, { cssStyles: m } = t, x = Rt.svg(s), b = Ot(t, {});
  t.look !== "handDrawn" && (b.roughness = 0, b.fillStyle = "solid");
  const v = [
    { x: -p / 2, y: y / 2 },
    ...Di(-p / 2, y / 2, p / 2, y / 2, f, 1),
    { x: p / 2, y: -y / 2 },
    ...Di(p / 2, -y / 2, -p / 2, -y / 2, f, -1)
  ], _ = ce(v), A = x.path(_, b), S = s.insert(() => A, ":first-child");
  return S.attr("class", "basic label-container"), m && t.look !== "handDrawn" && S.selectAll("path").attr("style", m), i && t.look !== "handDrawn" && S.selectAll("path").attr("style", i), Pt(t, S), t.intersect = function(k) {
    return Dt.polygon(t, v, k);
  }, s;
}
u(eg, "waveRectangle");
async function rg(e, t) {
  const { labelStyles: r, nodeStyles: i } = It(t);
  t.labelStyle = r;
  const { shapeSvg: s, bbox: a, label: n } = await Qt(e, t, Xt(t)), o = Math.max(a.width + (t.padding ?? 0) * 2, (t == null ? void 0 : t.width) ?? 0), h = Math.max(a.height + (t.padding ?? 0) * 2, (t == null ? void 0 : t.height) ?? 0), l = 5, d = -o / 2, p = -h / 2, { cssStyles: g } = t, f = Rt.svg(s), y = Ot(t, {}), m = [
    { x: d - l, y: p - l },
    { x: d - l, y: p + h },
    { x: d + o, y: p + h },
    { x: d + o, y: p - l }
  ], x = `M${d - l},${p - l} L${d + o},${p - l} L${d + o},${p + h} L${d - l},${p + h} L${d - l},${p - l}
                M${d - l},${p} L${d + o},${p}
                M${d},${p - l} L${d},${p + h}`;
  t.look !== "handDrawn" && (y.roughness = 0, y.fillStyle = "solid");
  const b = f.path(x, y), v = s.insert(() => b, ":first-child");
  return v.attr("transform", `translate(${l / 2}, ${l / 2})`), v.attr("class", "basic label-container"), g && t.look !== "handDrawn" && v.selectAll("path").attr("style", g), i && t.look !== "handDrawn" && v.selectAll("path").attr("style", i), n.attr(
    "transform",
    `translate(${-(a.width / 2) + l / 2 - (a.x - (a.left ?? 0))}, ${-(a.height / 2) + l / 2 - (a.y - (a.top ?? 0))})`
  ), Pt(t, v), t.intersect = function(_) {
    return Dt.polygon(t, m, _);
  }, s;
}
u(rg, "windowPane");
async function Qc(e, t) {
  var G, rt, ht, Z;
  const r = t;
  if (r.alias && (t.label = r.alias), t.look === "handDrawn") {
    const { themeVariables: ot } = fe(), { background: it } = ot, bt = {
      ...t,
      id: t.id + "-background",
      look: "default",
      cssStyles: ["stroke: none", `fill: ${it}`]
    };
    await Qc(e, bt);
  }
  const i = fe();
  t.useHtmlLabels = i.htmlLabels;
  let s = ((G = i.er) == null ? void 0 : G.diagramPadding) ?? 10, a = ((rt = i.er) == null ? void 0 : rt.entityPadding) ?? 6;
  const { cssStyles: n } = t, { labelStyles: o, nodeStyles: h } = It(t);
  if (r.attributes.length === 0 && t.label) {
    const ot = {
      rx: 0,
      ry: 0,
      labelPaddingX: s,
      labelPaddingY: s * 1.5
    };
    dr(t.label, i) + ot.labelPaddingX * 2 < i.er.minEntityWidth && (t.width = i.er.minEntityWidth);
    const it = await Ro(e, t, ot);
    if (!ke(i.htmlLabels)) {
      const bt = it.select("text"), xt = (ht = bt.node()) == null ? void 0 : ht.getBBox();
      bt.attr("transform", `translate(${-xt.width / 2}, 0)`);
    }
    return it;
  }
  i.htmlLabels || (s *= 1.25, a *= 1.25);
  let l = Xt(t);
  l || (l = "node default");
  const d = e.insert("g").attr("class", l).attr("id", t.domId || t.id), p = await ks(d, t.label ?? "", i, 0, 0, ["name"], o);
  p.height += a;
  let g = 0;
  const f = [], y = [];
  let m = 0, x = 0, b = 0, v = 0, _ = !0, A = !0;
  for (const ot of r.attributes) {
    const it = await ks(
      d,
      ot.type,
      i,
      0,
      g,
      ["attribute-type"],
      o
    );
    m = Math.max(m, it.width + s);
    const bt = await ks(
      d,
      ot.name,
      i,
      0,
      g,
      ["attribute-name"],
      o
    );
    x = Math.max(x, bt.width + s);
    const xt = await ks(
      d,
      ot.keys.join(),
      i,
      0,
      g,
      ["attribute-keys"],
      o
    );
    b = Math.max(b, xt.width + s);
    const Ct = await ks(
      d,
      ot.comment,
      i,
      0,
      g,
      ["attribute-comment"],
      o
    );
    v = Math.max(v, Ct.width + s);
    const at = Math.max(it.height, bt.height, xt.height, Ct.height) + a;
    y.push({ yOffset: g, rowHeight: at }), g += at;
  }
  let S = 4;
  b <= s && (_ = !1, b = 0, S--), v <= s && (A = !1, v = 0, S--);
  const k = d.node().getBBox();
  if (p.width + s * 2 - (m + x + b + v) > 0) {
    const ot = p.width + s * 2 - (m + x + b + v);
    m += ot / S, x += ot / S, b > 0 && (b += ot / S), v > 0 && (v += ot / S);
  }
  const L = m + x + b + v, T = Rt.svg(d), C = Ot(t, {});
  t.look !== "handDrawn" && (C.roughness = 0, C.fillStyle = "solid");
  let E = 0;
  y.length > 0 && (E = y.reduce((ot, it) => ot + ((it == null ? void 0 : it.rowHeight) ?? 0), 0));
  const w = Math.max(k.width + s * 2, (t == null ? void 0 : t.width) || 0, L), W = Math.max((E ?? 0) + p.height, (t == null ? void 0 : t.height) || 0), N = -w / 2, B = -W / 2;
  d.selectAll("g:not(:first-child)").each((ot, it, bt) => {
    const xt = yt(bt[it]), Ct = xt.attr("transform");
    let at = 0, lt = 0;
    if (Ct) {
      const U = RegExp(/translate\(([^,]+),([^)]+)\)/).exec(Ct);
      U && (at = parseFloat(U[1]), lt = parseFloat(U[2]), xt.attr("class").includes("attribute-name") ? at += m : xt.attr("class").includes("attribute-keys") ? at += m + x : xt.attr("class").includes("attribute-comment") && (at += m + x + b));
    }
    xt.attr(
      "transform",
      `translate(${N + s / 2 + at}, ${lt + B + p.height + a / 2})`
    );
  }), d.select(".name").attr("transform", "translate(" + -p.width / 2 + ", " + (B + a / 2) + ")");
  const R = T.rectangle(N, B, w, W, C), V = d.insert(() => R, ":first-child").attr("style", n.join("")), { themeVariables: $ } = fe(), { rowEven: D, rowOdd: O, nodeBorder: Y } = $;
  f.push(0);
  for (const [ot, it] of y.entries()) {
    const xt = (ot + 1) % 2 === 0 && it.yOffset !== 0, Ct = T.rectangle(N, p.height + B + (it == null ? void 0 : it.yOffset), w, it == null ? void 0 : it.rowHeight, {
      ...C,
      fill: xt ? D : O,
      stroke: Y
    });
    d.insert(() => Ct, "g.label").attr("style", n.join("")).attr("class", `row-rect-${xt ? "even" : "odd"}`);
  }
  let M = T.line(N, p.height + B, w + N, p.height + B, C);
  d.insert(() => M).attr("class", "divider"), M = T.line(m + N, p.height + B, m + N, W + B, C), d.insert(() => M).attr("class", "divider"), _ && (M = T.line(
    m + x + N,
    p.height + B,
    m + x + N,
    W + B,
    C
  ), d.insert(() => M).attr("class", "divider")), A && (M = T.line(
    m + x + b + N,
    p.height + B,
    m + x + b + N,
    W + B,
    C
  ), d.insert(() => M).attr("class", "divider"));
  for (const ot of f)
    M = T.line(
      N,
      p.height + B + ot,
      w + N,
      p.height + B + ot,
      C
    ), d.insert(() => M).attr("class", "divider");
  if (Pt(t, V), h && t.look !== "handDrawn") {
    const ot = h.split(";"), it = (Z = ot == null ? void 0 : ot.filter((bt) => bt.includes("stroke"))) == null ? void 0 : Z.map((bt) => `${bt}`).join("; ");
    d.selectAll("path").attr("style", it ?? ""), d.selectAll(".row-rect-even path").attr("style", h);
  }
  return t.intersect = function(ot) {
    return Dt.rect(t, ot);
  }, d;
}
u(Qc, "erBox");
async function ks(e, t, r, i = 0, s = 0, a = [], n = "") {
  const o = e.insert("g").attr("class", `label ${a.join(" ")}`).attr("transform", `translate(${i}, ${s})`).attr("style", n);
  t !== vi(t) && (t = vi(t), t = t.replaceAll("<", "&lt;").replaceAll(">", "&gt;"));
  const h = o.node().appendChild(
    await _r(
      o,
      t,
      {
        width: dr(t, r) + 100,
        style: n,
        useHtmlLabels: r.htmlLabels
      },
      r
    )
  );
  if (t.includes("&lt;") || t.includes("&gt;")) {
    let d = h.children[0];
    for (d.textContent = d.textContent.replaceAll("&lt;", "<").replaceAll("&gt;", ">"); d.childNodes[0]; )
      d = d.childNodes[0], d.textContent = d.textContent.replaceAll("&lt;", "<").replaceAll("&gt;", ">");
  }
  let l = h.getBBox();
  if (ke(r.htmlLabels)) {
    const d = h.children[0];
    d.style.textAlign = "start";
    const p = yt(h);
    l = d.getBoundingClientRect(), p.attr("width", l.width), p.attr("height", l.height);
  }
  return l;
}
u(ks, "addText");
async function ig(e, t, r, i, s = r.class.padding ?? 12) {
  const a = i ? 0 : 3, n = e.insert("g").attr("class", Xt(t)).attr("id", t.domId || t.id);
  let o = null, h = null, l = null, d = null, p = 0, g = 0, f = 0;
  if (o = n.insert("g").attr("class", "annotation-group text"), t.annotations.length > 0) {
    const v = t.annotations[0];
    await Ia(o, { text: `${v}` }, 0), p = o.node().getBBox().height;
  }
  h = n.insert("g").attr("class", "label-group text"), await Ia(h, t, 0, ["font-weight: bolder"]);
  const y = h.node().getBBox();
  g = y.height, l = n.insert("g").attr("class", "members-group text");
  let m = 0;
  for (const v of t.members) {
    const _ = await Ia(l, v, m, [v.parseClassifier()]);
    m += _ + a;
  }
  f = l.node().getBBox().height, f <= 0 && (f = s / 2), d = n.insert("g").attr("class", "methods-group text");
  let x = 0;
  for (const v of t.methods) {
    const _ = await Ia(d, v, x, [v.parseClassifier()]);
    x += _ + a;
  }
  let b = n.node().getBBox();
  if (o !== null) {
    const v = o.node().getBBox();
    o.attr("transform", `translate(${-v.width / 2})`);
  }
  return h.attr("transform", `translate(${-y.width / 2}, ${p})`), b = n.node().getBBox(), l.attr(
    "transform",
    `translate(0, ${p + g + s * 2})`
  ), b = n.node().getBBox(), d.attr(
    "transform",
    `translate(0, ${p + g + (f ? f + s * 4 : s * 2)})`
  ), b = n.node().getBBox(), { shapeSvg: n, bbox: b };
}
u(ig, "textHelper");
async function Ia(e, t, r, i = []) {
  const s = e.insert("g").attr("class", "label").attr("style", i.join("; ")), a = fe();
  let n = "useHtmlLabels" in t ? t.useHtmlLabels : ke(a.htmlLabels) ?? !0, o = "";
  "text" in t ? o = t.text : o = t.label, !n && o.startsWith("\\") && (o = o.substring(1)), Ee(o) && (n = !0);
  const h = await _r(
    s,
    Ic(Qr(o)),
    {
      width: dr(o, a) + 50,
      // Add room for error when splitting text into multiple lines
      classes: "markdown-node-label",
      useHtmlLabels: n
    },
    a
  );
  let l, d = 1;
  if (n) {
    const p = h.children[0], g = yt(h);
    d = p.innerHTML.split("<br>").length, p.innerHTML.includes("</math>") && (d += p.innerHTML.split("<mrow>").length - 1);
    const f = p.getElementsByTagName("img");
    if (f) {
      const y = o.replace(/<img[^>]*>/g, "").trim() === "";
      await Promise.all(
        [...f].map(
          (m) => new Promise((x) => {
            function b() {
              var v;
              if (m.style.display = "flex", m.style.flexDirection = "column", y) {
                const _ = ((v = a.fontSize) == null ? void 0 : v.toString()) ?? window.getComputedStyle(document.body).fontSize, S = parseInt(_, 10) * 5 + "px";
                m.style.minWidth = S, m.style.maxWidth = S;
              } else
                m.style.width = "100%";
              x(m);
            }
            u(b, "setupImage"), setTimeout(() => {
              m.complete && b();
            }), m.addEventListener("error", b), m.addEventListener("load", b);
          })
        )
      );
    }
    l = p.getBoundingClientRect(), g.attr("width", l.width), g.attr("height", l.height);
  } else {
    i.includes("font-weight: bolder") && yt(h).selectAll("tspan").attr("font-weight", ""), d = h.children.length;
    const p = h.children[0];
    (h.textContent === "" || h.textContent.includes("&gt")) && (p.textContent = o[0] + o.substring(1).replaceAll("&gt;", ">").replaceAll("&lt;", "<").trim(), o[1] === " " && (p.textContent = p.textContent[0] + " " + p.textContent.substring(1))), p.textContent === "undefined" && (p.textContent = ""), l = h.getBBox();
  }
  return s.attr("transform", "translate(0," + (-l.height / (2 * d) + r) + ")"), l.height;
}
u(Ia, "addText");
async function sg(e, t) {
  var C, E;
  const r = K(), i = r.class.padding ?? 12, s = i, a = t.useHtmlLabels ?? ke(r.htmlLabels) ?? !0, n = t;
  n.annotations = n.annotations ?? [], n.members = n.members ?? [], n.methods = n.methods ?? [];
  const { shapeSvg: o, bbox: h } = await ig(e, t, r, a, s), { labelStyles: l, nodeStyles: d } = It(t);
  t.labelStyle = l, t.cssStyles = n.styles || "";
  const p = ((C = n.styles) == null ? void 0 : C.join(";")) || d || "";
  t.cssStyles || (t.cssStyles = p.replaceAll("!important", "").split(";"));
  const g = n.members.length === 0 && n.methods.length === 0 && !((E = r.class) != null && E.hideEmptyMembersBox), f = Rt.svg(o), y = Ot(t, {});
  t.look !== "handDrawn" && (y.roughness = 0, y.fillStyle = "solid");
  const m = h.width;
  let x = h.height;
  n.members.length === 0 && n.methods.length === 0 ? x += s : n.members.length > 0 && n.methods.length === 0 && (x += s * 2);
  const b = -m / 2, v = -x / 2, _ = f.rectangle(
    b - i,
    v - i - (g ? i : n.members.length === 0 && n.methods.length === 0 ? -i / 2 : 0),
    m + 2 * i,
    x + 2 * i + (g ? i * 2 : n.members.length === 0 && n.methods.length === 0 ? -i : 0),
    y
  ), A = o.insert(() => _, ":first-child");
  A.attr("class", "basic label-container");
  const S = A.node().getBBox();
  o.selectAll(".text").each((w, W, N) => {
    var O;
    const B = yt(N[W]), R = B.attr("transform");
    let V = 0;
    if (R) {
      const M = RegExp(/translate\(([^,]+),([^)]+)\)/).exec(R);
      M && (V = parseFloat(M[2]));
    }
    let $ = V + v + i - (g ? i : n.members.length === 0 && n.methods.length === 0 ? -i / 2 : 0);
    a || ($ -= 4);
    let D = b;
    (B.attr("class").includes("label-group") || B.attr("class").includes("annotation-group")) && (D = -((O = B.node()) == null ? void 0 : O.getBBox().width) / 2 || 0, o.selectAll("text").each(function(Y, M, G) {
      window.getComputedStyle(G[M]).textAnchor === "middle" && (D = 0);
    })), B.attr("transform", `translate(${D}, ${$})`);
  });
  const k = o.select(".annotation-group").node().getBBox().height - (g ? i / 2 : 0) || 0, L = o.select(".label-group").node().getBBox().height - (g ? i / 2 : 0) || 0, T = o.select(".members-group").node().getBBox().height - (g ? i / 2 : 0) || 0;
  if (n.members.length > 0 || n.methods.length > 0 || g) {
    const w = f.line(
      S.x,
      k + L + v + i,
      S.x + S.width,
      k + L + v + i,
      y
    );
    o.insert(() => w).attr("class", "divider").attr("style", p);
  }
  if (g || n.members.length > 0 || n.methods.length > 0) {
    const w = f.line(
      S.x,
      k + L + T + v + s * 2 + i,
      S.x + S.width,
      k + L + T + v + i + s * 2,
      y
    );
    o.insert(() => w).attr("class", "divider").attr("style", p);
  }
  if (n.look !== "handDrawn" && o.selectAll("path").attr("style", p), A.select(":nth-child(2)").attr("style", p), o.selectAll(".divider").select("path").attr("style", p), t.labelStyle ? o.selectAll("span").attr("style", t.labelStyle) : o.selectAll("span").attr("style", p), !a) {
    const w = RegExp(/color\s*:\s*([^;]*)/), W = w.exec(p);
    if (W) {
      const N = W[0].replace("color", "fill");
      o.selectAll("tspan").attr("style", N);
    } else if (l) {
      const N = w.exec(l);
      if (N) {
        const B = N[0].replace("color", "fill");
        o.selectAll("tspan").attr("style", B);
      }
    }
  }
  return Pt(t, A), t.intersect = function(w) {
    return Dt.rect(t, w);
  }, o;
}
u(sg, "classBox");
async function ag(e, t) {
  var k, L;
  const { labelStyles: r, nodeStyles: i } = It(t);
  t.labelStyle = r;
  const s = t, a = t, n = 20, o = 20, h = "verifyMethod" in t, l = Xt(t), d = e.insert("g").attr("class", l).attr("id", t.domId ?? t.id);
  let p;
  h ? p = await Hr(
    d,
    `&lt;&lt;${s.type}&gt;&gt;`,
    0,
    t.labelStyle
  ) : p = await Hr(d, "&lt;&lt;Element&gt;&gt;", 0, t.labelStyle);
  let g = p;
  const f = await Hr(
    d,
    s.name,
    g,
    t.labelStyle + "; font-weight: bold;"
  );
  if (g += f + o, h) {
    const T = await Hr(
      d,
      `${s.requirementId ? `ID: ${s.requirementId}` : ""}`,
      g,
      t.labelStyle
    );
    g += T;
    const C = await Hr(
      d,
      `${s.text ? `Text: ${s.text}` : ""}`,
      g,
      t.labelStyle
    );
    g += C;
    const E = await Hr(
      d,
      `${s.risk ? `Risk: ${s.risk}` : ""}`,
      g,
      t.labelStyle
    );
    g += E, await Hr(
      d,
      `${s.verifyMethod ? `Verification: ${s.verifyMethod}` : ""}`,
      g,
      t.labelStyle
    );
  } else {
    const T = await Hr(
      d,
      `${a.type ? `Type: ${a.type}` : ""}`,
      g,
      t.labelStyle
    );
    g += T, await Hr(
      d,
      `${a.docRef ? `Doc Ref: ${a.docRef}` : ""}`,
      g,
      t.labelStyle
    );
  }
  const y = (((k = d.node()) == null ? void 0 : k.getBBox().width) ?? 200) + n, m = (((L = d.node()) == null ? void 0 : L.getBBox().height) ?? 200) + n, x = -y / 2, b = -m / 2, v = Rt.svg(d), _ = Ot(t, {});
  t.look !== "handDrawn" && (_.roughness = 0, _.fillStyle = "solid");
  const A = v.rectangle(x, b, y, m, _), S = d.insert(() => A, ":first-child");
  if (S.attr("class", "basic label-container").attr("style", i), d.selectAll(".label").each((T, C, E) => {
    const w = yt(E[C]), W = w.attr("transform");
    let N = 0, B = 0;
    if (W) {
      const D = RegExp(/translate\(([^,]+),([^)]+)\)/).exec(W);
      D && (N = parseFloat(D[1]), B = parseFloat(D[2]));
    }
    const R = B - m / 2;
    let V = x + n / 2;
    (C === 0 || C === 1) && (V = N), w.attr("transform", `translate(${V}, ${R + n})`);
  }), g > p + f + o) {
    const T = v.line(
      x,
      b + p + f + o,
      x + y,
      b + p + f + o,
      _
    );
    d.insert(() => T).attr("style", i);
  }
  return Pt(t, S), t.intersect = function(T) {
    return Dt.rect(t, T);
  }, d;
}
u(ag, "requirementBox");
async function Hr(e, t, r, i = "") {
  if (t === "")
    return 0;
  const s = e.insert("g").attr("class", "label").attr("style", i), a = K(), n = a.htmlLabels ?? !0, o = await _r(
    s,
    Ic(Qr(t)),
    {
      width: dr(t, a) + 50,
      // Add room for error when splitting text into multiple lines
      classes: "markdown-node-label",
      useHtmlLabels: n,
      style: i
    },
    a
  );
  let h;
  if (n) {
    const l = o.children[0], d = yt(o);
    h = l.getBoundingClientRect(), d.attr("width", h.width), d.attr("height", h.height);
  } else {
    const l = o.children[0];
    for (const d of l.children)
      d.textContent = d.textContent.replaceAll("&gt;", ">").replaceAll("&lt;", "<"), i && d.setAttribute("style", i);
    h = o.getBBox(), h.height += 6;
  }
  return s.attr("transform", `translate(${-h.width / 2},${-h.height / 2 + r})`), h.height;
}
u(Hr, "addText");
var V3 = /* @__PURE__ */ u((e) => {
  switch (e) {
    case "Very High":
      return "red";
    case "High":
      return "orange";
    case "Medium":
      return null;
    case "Low":
      return "blue";
    case "Very Low":
      return "lightblue";
  }
}, "colorFromPriority");
async function ng(e, t, { config: r }) {
  var W, N;
  const { labelStyles: i, nodeStyles: s } = It(t);
  t.labelStyle = i || "";
  const a = 10, n = t.width;
  t.width = (t.width ?? 200) - 10;
  const {
    shapeSvg: o,
    bbox: h,
    label: l
  } = await Qt(e, t, Xt(t)), d = t.padding || 10;
  let p = "", g;
  "ticket" in t && t.ticket && ((W = r == null ? void 0 : r.kanban) != null && W.ticketBaseUrl) && (p = (N = r == null ? void 0 : r.kanban) == null ? void 0 : N.ticketBaseUrl.replace("#TICKET#", t.ticket), g = o.insert("svg:a", ":first-child").attr("class", "kanban-ticket-link").attr("xlink:href", p).attr("target", "_blank"));
  const f = {
    useHtmlLabels: t.useHtmlLabels,
    labelStyle: t.labelStyle || "",
    width: t.width,
    img: t.img,
    padding: t.padding || 8,
    centerLabel: !1
  };
  let y, m;
  g ? { label: y, bbox: m } = await sl(
    g,
    "ticket" in t && t.ticket || "",
    f
  ) : { label: y, bbox: m } = await sl(
    o,
    "ticket" in t && t.ticket || "",
    f
  );
  const { label: x, bbox: b } = await sl(
    o,
    "assigned" in t && t.assigned || "",
    f
  );
  t.width = n;
  const v = 10, _ = (t == null ? void 0 : t.width) || 0, A = Math.max(m.height, b.height) / 2, S = Math.max(h.height + v * 2, (t == null ? void 0 : t.height) || 0) + A, k = -_ / 2, L = -S / 2;
  l.attr(
    "transform",
    "translate(" + (d - _ / 2) + ", " + (-A - h.height / 2) + ")"
  ), y.attr(
    "transform",
    "translate(" + (d - _ / 2) + ", " + (-A + h.height / 2) + ")"
  ), x.attr(
    "transform",
    "translate(" + (d + _ / 2 - b.width - 2 * a) + ", " + (-A + h.height / 2) + ")"
  );
  let T;
  const { rx: C, ry: E } = t, { cssStyles: w } = t;
  if (t.look === "handDrawn") {
    const B = Rt.svg(o), R = Ot(t, {}), V = C || E ? B.path(Ri(k, L, _, S, C || 0), R) : B.rectangle(k, L, _, S, R);
    T = o.insert(() => V, ":first-child"), T.attr("class", "basic label-container").attr("style", w || null);
  } else {
    T = o.insert("rect", ":first-child"), T.attr("class", "basic label-container __APA__").attr("style", s).attr("rx", C ?? 5).attr("ry", E ?? 5).attr("x", k).attr("y", L).attr("width", _).attr("height", S);
    const B = "priority" in t && t.priority;
    if (B) {
      const R = o.append("line"), V = k + 2, $ = L + Math.floor((C ?? 0) / 2), D = L + S - Math.floor((C ?? 0) / 2);
      R.attr("x1", V).attr("y1", $).attr("x2", V).attr("y2", D).attr("stroke-width", "4").attr("stroke", V3(B));
    }
  }
  return Pt(t, T), t.height = S, t.intersect = function(B) {
    return Dt.rect(t, B);
  }, o;
}
u(ng, "kanbanItem");
async function og(e, t) {
  const { labelStyles: r, nodeStyles: i } = It(t);
  t.labelStyle = r;
  const { shapeSvg: s, bbox: a, halfPadding: n, label: o } = await Qt(
    e,
    t,
    Xt(t)
  ), h = a.width + 10 * n, l = a.height + 8 * n, d = 0.15 * h, { cssStyles: p } = t, g = a.width + 20, f = a.height + 20, y = Math.max(h, g), m = Math.max(l, f);
  o.attr("transform", `translate(${-a.width / 2}, ${-a.height / 2})`);
  let x;
  const b = `M0 0 
    a${d},${d} 1 0,0 ${y * 0.25},${-1 * m * 0.1}
    a${d},${d} 1 0,0 ${y * 0.25},0
    a${d},${d} 1 0,0 ${y * 0.25},0
    a${d},${d} 1 0,0 ${y * 0.25},${m * 0.1}

    a${d},${d} 1 0,0 ${y * 0.15},${m * 0.33}
    a${d * 0.8},${d * 0.8} 1 0,0 0,${m * 0.34}
    a${d},${d} 1 0,0 ${-1 * y * 0.15},${m * 0.33}

    a${d},${d} 1 0,0 ${-1 * y * 0.25},${m * 0.15}
    a${d},${d} 1 0,0 ${-1 * y * 0.25},0
    a${d},${d} 1 0,0 ${-1 * y * 0.25},0
    a${d},${d} 1 0,0 ${-1 * y * 0.25},${-1 * m * 0.15}

    a${d},${d} 1 0,0 ${-1 * y * 0.1},${-1 * m * 0.33}
    a${d * 0.8},${d * 0.8} 1 0,0 0,${-1 * m * 0.34}
    a${d},${d} 1 0,0 ${y * 0.1},${-1 * m * 0.33}
  H0 V0 Z`;
  if (t.look === "handDrawn") {
    const v = Rt.svg(s), _ = Ot(t, {}), A = v.path(b, _);
    x = s.insert(() => A, ":first-child"), x.attr("class", "basic label-container").attr("style", ar(p));
  } else
    x = s.insert("path", ":first-child").attr("class", "basic label-container").attr("style", i).attr("d", b);
  return x.attr("transform", `translate(${-y / 2}, ${-m / 2})`), Pt(t, x), t.calcIntersect = function(v, _) {
    return Dt.rect(v, _);
  }, t.intersect = function(v) {
    return I.info("Bang intersect", t, v), Dt.rect(t, v);
  }, s;
}
u(og, "bang");
async function lg(e, t) {
  const { labelStyles: r, nodeStyles: i } = It(t);
  t.labelStyle = r;
  const { shapeSvg: s, bbox: a, halfPadding: n, label: o } = await Qt(
    e,
    t,
    Xt(t)
  ), h = a.width + 2 * n, l = a.height + 2 * n, d = 0.15 * h, p = 0.25 * h, g = 0.35 * h, f = 0.2 * h, { cssStyles: y } = t;
  let m;
  const x = `M0 0 
    a${d},${d} 0 0,1 ${h * 0.25},${-1 * h * 0.1}
    a${g},${g} 1 0,1 ${h * 0.4},${-1 * h * 0.1}
    a${p},${p} 1 0,1 ${h * 0.35},${h * 0.2}

    a${d},${d} 1 0,1 ${h * 0.15},${l * 0.35}
    a${f},${f} 1 0,1 ${-1 * h * 0.15},${l * 0.65}

    a${p},${d} 1 0,1 ${-1 * h * 0.25},${h * 0.15}
    a${g},${g} 1 0,1 ${-1 * h * 0.5},0
    a${d},${d} 1 0,1 ${-1 * h * 0.25},${-1 * h * 0.15}

    a${d},${d} 1 0,1 ${-1 * h * 0.1},${-1 * l * 0.35}
    a${f},${f} 1 0,1 ${h * 0.1},${-1 * l * 0.65}
  H0 V0 Z`;
  if (t.look === "handDrawn") {
    const b = Rt.svg(s), v = Ot(t, {}), _ = b.path(x, v);
    m = s.insert(() => _, ":first-child"), m.attr("class", "basic label-container").attr("style", ar(y));
  } else
    m = s.insert("path", ":first-child").attr("class", "basic label-container").attr("style", i).attr("d", x);
  return o.attr("transform", `translate(${-a.width / 2}, ${-a.height / 2})`), m.attr("transform", `translate(${-h / 2}, ${-l / 2})`), Pt(t, m), t.calcIntersect = function(b, v) {
    return Dt.rect(b, v);
  }, t.intersect = function(b) {
    return I.info("Cloud intersect", t, b), Dt.rect(t, b);
  }, s;
}
u(lg, "cloud");
async function cg(e, t) {
  const { labelStyles: r, nodeStyles: i } = It(t);
  t.labelStyle = r;
  const { shapeSvg: s, bbox: a, halfPadding: n, label: o } = await Qt(
    e,
    t,
    Xt(t)
  ), h = a.width + 8 * n, l = a.height + 2 * n, d = 5, p = `
    M${-h / 2} ${l / 2 - d}
    v${-l + 2 * d}
    q0,-${d} ${d},-${d}
    h${h - 2 * d}
    q${d},0 ${d},${d}
    v${l - 2 * d}
    q0,${d} -${d},${d}
    h${-h + 2 * d}
    q-${d},0 -${d},-${d}
    Z
  `, g = s.append("path").attr("id", "node-" + t.id).attr("class", "node-bkg node-" + t.type).attr("style", i).attr("d", p);
  return s.append("line").attr("class", "node-line-").attr("x1", -h / 2).attr("y1", l / 2).attr("x2", h / 2).attr("y2", l / 2), o.attr("transform", `translate(${-a.width / 2}, ${-a.height / 2})`), s.append(() => o.node()), Pt(t, g), t.calcIntersect = function(f, y) {
    return Dt.rect(f, y);
  }, t.intersect = function(f) {
    return Dt.rect(t, f);
  }, s;
}
u(cg, "defaultMindmapNode");
async function hg(e, t) {
  const r = {
    padding: t.padding ?? 0
  };
  return Kc(e, t, r);
}
u(hg, "mindmapCircle");
var z3 = [
  {
    semanticName: "Process",
    name: "Rectangle",
    shortName: "rect",
    description: "Standard process shape",
    aliases: ["proc", "process", "rectangle"],
    internalAliases: ["squareRect"],
    handler: zp
  },
  {
    semanticName: "Event",
    name: "Rounded Rectangle",
    shortName: "rounded",
    description: "Represents an event",
    aliases: ["event"],
    internalAliases: ["roundedRect"],
    handler: Pp
  },
  {
    semanticName: "Terminal Point",
    name: "Stadium",
    shortName: "stadium",
    description: "Terminal point",
    aliases: ["terminal", "pill"],
    handler: Wp
  },
  {
    semanticName: "Subprocess",
    name: "Framed Rectangle",
    shortName: "fr-rect",
    description: "Subprocess",
    aliases: ["subprocess", "subproc", "framed-rectangle", "subroutine"],
    handler: Up
  },
  {
    semanticName: "Database",
    name: "Cylinder",
    shortName: "cyl",
    description: "Database storage",
    aliases: ["db", "database", "cylinder"],
    handler: up
  },
  {
    semanticName: "Start",
    name: "Circle",
    shortName: "circle",
    description: "Starting point",
    aliases: ["circ"],
    handler: Kc
  },
  {
    semanticName: "Bang",
    name: "Bang",
    shortName: "bang",
    description: "Bang",
    aliases: ["bang"],
    handler: og
  },
  {
    semanticName: "Cloud",
    name: "Cloud",
    shortName: "cloud",
    description: "cloud",
    aliases: ["cloud"],
    handler: lg
  },
  {
    semanticName: "Decision",
    name: "Diamond",
    shortName: "diam",
    description: "Decision-making step",
    aliases: ["decision", "diamond", "question"],
    handler: Rp
  },
  {
    semanticName: "Prepare Conditional",
    name: "Hexagon",
    shortName: "hex",
    description: "Preparation or condition step",
    aliases: ["hexagon", "prepare"],
    handler: xp
  },
  {
    semanticName: "Data Input/Output",
    name: "Lean Right",
    shortName: "lean-r",
    description: "Represents input or output",
    aliases: ["lean-right", "in-out"],
    internalAliases: ["lean_right"],
    handler: Ap
  },
  {
    semanticName: "Data Input/Output",
    name: "Lean Left",
    shortName: "lean-l",
    description: "Represents output or input",
    aliases: ["lean-left", "out-in"],
    internalAliases: ["lean_left"],
    handler: Ep
  },
  {
    semanticName: "Priority Action",
    name: "Trapezoid Base Bottom",
    shortName: "trap-b",
    description: "Priority action",
    aliases: ["priority", "trapezoid-bottom", "trapezoid"],
    handler: Qp
  },
  {
    semanticName: "Manual Operation",
    name: "Trapezoid Base Top",
    shortName: "trap-t",
    description: "Represents a manual task",
    aliases: ["manual", "trapezoid-top", "inv-trapezoid"],
    internalAliases: ["inv_trapezoid"],
    handler: Tp
  },
  {
    semanticName: "Stop",
    name: "Double Circle",
    shortName: "dbl-circ",
    description: "Represents a stop point",
    aliases: ["double-circle"],
    internalAliases: ["doublecircle"],
    handler: pp
  },
  {
    semanticName: "Text Block",
    name: "Text Block",
    shortName: "text",
    description: "Text block",
    handler: Xp
  },
  {
    semanticName: "Card",
    name: "Notched Rectangle",
    shortName: "notch-rect",
    description: "Represents a card",
    aliases: ["card", "notched-rectangle"],
    handler: ip
  },
  {
    semanticName: "Lined/Shaded Process",
    name: "Lined Rectangle",
    shortName: "lin-rect",
    description: "Lined process shape",
    aliases: ["lined-rectangle", "lined-process", "lin-proc", "shaded-process"],
    handler: $p
  },
  {
    semanticName: "Start",
    name: "Small Circle",
    shortName: "sm-circ",
    description: "Small starting point",
    aliases: ["start", "small-circle"],
    internalAliases: ["stateStart"],
    handler: Hp
  },
  {
    semanticName: "Stop",
    name: "Framed Circle",
    shortName: "fr-circ",
    description: "Stop point",
    aliases: ["stop", "framed-circle"],
    internalAliases: ["stateEnd"],
    handler: Yp
  },
  {
    semanticName: "Fork/Join",
    name: "Filled Rectangle",
    shortName: "fork",
    description: "Fork or join in process flow",
    aliases: ["join"],
    internalAliases: ["forkJoin"],
    handler: yp
  },
  {
    semanticName: "Collate",
    name: "Hourglass",
    shortName: "hourglass",
    description: "Represents a collate operation",
    aliases: ["hourglass", "collate"],
    handler: bp
  },
  {
    semanticName: "Comment",
    name: "Curly Brace",
    shortName: "brace",
    description: "Adds a comment",
    aliases: ["comment", "brace-l"],
    handler: op
  },
  {
    semanticName: "Comment Right",
    name: "Curly Brace",
    shortName: "brace-r",
    description: "Adds a comment",
    handler: lp
  },
  {
    semanticName: "Comment with braces on both sides",
    name: "Curly Braces",
    shortName: "braces",
    description: "Adds a comment",
    handler: cp
  },
  {
    semanticName: "Com Link",
    name: "Lightning Bolt",
    shortName: "bolt",
    description: "Communication link",
    aliases: ["com-link", "lightning-bolt"],
    handler: Lp
  },
  {
    semanticName: "Document",
    name: "Document",
    shortName: "doc",
    description: "Represents a document",
    aliases: ["doc", "document"],
    handler: tg
  },
  {
    semanticName: "Delay",
    name: "Half-Rounded Rectangle",
    shortName: "delay",
    description: "Represents a delay",
    aliases: ["half-rounded-rectangle"],
    handler: mp
  },
  {
    semanticName: "Direct Access Storage",
    name: "Horizontal Cylinder",
    shortName: "h-cyl",
    description: "Direct access storage",
    aliases: ["das", "horizontal-cylinder"],
    handler: Kp
  },
  {
    semanticName: "Disk Storage",
    name: "Lined Cylinder",
    shortName: "lin-cyl",
    description: "Disk storage",
    aliases: ["disk", "lined-cylinder"],
    handler: Bp
  },
  {
    semanticName: "Display",
    name: "Curved Trapezoid",
    shortName: "curv-trap",
    description: "Represents a display",
    aliases: ["curved-trapezoid", "display"],
    handler: hp
  },
  {
    semanticName: "Divided Process",
    name: "Divided Rectangle",
    shortName: "div-rect",
    description: "Divided process shape",
    aliases: ["div-proc", "divided-rectangle", "divided-process"],
    handler: dp
  },
  {
    semanticName: "Extract",
    name: "Triangle",
    shortName: "tri",
    description: "Extraction process",
    aliases: ["extract", "triangle"],
    handler: Jp
  },
  {
    semanticName: "Internal Storage",
    name: "Window Pane",
    shortName: "win-pane",
    description: "Internal storage",
    aliases: ["internal-storage", "window-pane"],
    handler: rg
  },
  {
    semanticName: "Junction",
    name: "Filled Circle",
    shortName: "f-circ",
    description: "Junction point",
    aliases: ["junction", "filled-circle"],
    handler: gp
  },
  {
    semanticName: "Loop Limit",
    name: "Trapezoidal Pentagon",
    shortName: "notch-pent",
    description: "Loop limit step",
    aliases: ["loop-limit", "notched-pentagon"],
    handler: Zp
  },
  {
    semanticName: "Manual File",
    name: "Flipped Triangle",
    shortName: "flip-tri",
    description: "Manual file operation",
    aliases: ["manual-file", "flipped-triangle"],
    handler: fp
  },
  {
    semanticName: "Manual Input",
    name: "Sloped Rectangle",
    shortName: "sl-rect",
    description: "Manual input step",
    aliases: ["manual-input", "sloped-rectangle"],
    handler: Vp
  },
  {
    semanticName: "Multi-Document",
    name: "Stacked Document",
    shortName: "docs",
    description: "Multiple documents",
    aliases: ["documents", "st-doc", "stacked-document"],
    handler: Fp
  },
  {
    semanticName: "Multi-Process",
    name: "Stacked Rectangle",
    shortName: "st-rect",
    description: "Multiple processes",
    aliases: ["procs", "processes", "stacked-rectangle"],
    handler: Ip
  },
  {
    semanticName: "Stored Data",
    name: "Bow Tie Rectangle",
    shortName: "bow-rect",
    description: "Stored data",
    aliases: ["stored-data", "bow-tie-rectangle"],
    handler: rp
  },
  {
    semanticName: "Summary",
    name: "Crossed Circle",
    shortName: "cross-circ",
    description: "Summary",
    aliases: ["summary", "crossed-circle"],
    handler: np
  },
  {
    semanticName: "Tagged Document",
    name: "Tagged Document",
    shortName: "tag-doc",
    description: "Tagged document",
    aliases: ["tag-doc", "tagged-document"],
    handler: Gp
  },
  {
    semanticName: "Tagged Process",
    name: "Tagged Rectangle",
    shortName: "tag-rect",
    description: "Tagged process",
    aliases: ["tagged-rectangle", "tag-proc", "tagged-process"],
    handler: jp
  },
  {
    semanticName: "Paper Tape",
    name: "Flag",
    shortName: "flag",
    description: "Paper tape",
    aliases: ["paper-tape"],
    handler: eg
  },
  {
    semanticName: "Odd",
    name: "Odd",
    shortName: "odd",
    description: "Odd shape",
    internalAliases: ["rect_left_inv_arrow"],
    handler: Mp
  },
  {
    semanticName: "Lined Document",
    name: "Lined Document",
    shortName: "lin-doc",
    description: "Lined document",
    aliases: ["lined-document"],
    handler: Dp
  }
], W3 = /* @__PURE__ */ u(() => {
  const t = [
    ...Object.entries({
      // States
      state: qp,
      choice: sp,
      note: Np,
      // Rectangles
      rectWithTitle: Op,
      labelRect: _p,
      // Icons
      iconSquare: Cp,
      iconCircle: vp,
      icon: kp,
      iconRounded: Sp,
      imageSquare: wp,
      anchor: ep,
      // Kanban diagram
      kanbanItem: ng,
      //Mindmap diagram
      mindmapCircle: hg,
      defaultMindmapNode: cg,
      // class diagram
      classBox: sg,
      // er diagram
      erBox: Qc,
      // Requirement diagram
      requirementBox: ag
    }),
    ...z3.flatMap((r) => [
      r.shortName,
      ..."aliases" in r ? r.aliases : [],
      ..."internalAliases" in r ? r.internalAliases : []
    ].map((s) => [s, r.handler]))
  ];
  return Object.fromEntries(t);
}, "generateShapeMap"), ug = W3();
function dg(e) {
  return e in ug;
}
u(dg, "isValidShape");
var Mo = /* @__PURE__ */ new Map();
async function Oo(e, t, r) {
  let i, s;
  t.shape === "rect" && (t.rx && t.ry ? t.shape = "roundedRect" : t.shape = "squareRect");
  const a = t.shape ? ug[t.shape] : void 0;
  if (!a)
    throw new Error(`No such shape: ${t.shape}. Please check your syntax.`);
  if (t.link) {
    let n;
    r.config.securityLevel === "sandbox" ? n = "_top" : t.linkTarget && (n = t.linkTarget || "_blank"), i = e.insert("svg:a").attr("xlink:href", t.link).attr("target", n ?? null), s = await a(i, t, r);
  } else
    s = await a(e, t, r), i = s;
  return t.tooltip && s.attr("title", t.tooltip), Mo.set(t.id, i), t.haveCallback && i.attr("class", i.attr("class") + " clickable"), i;
}
u(Oo, "insertNode");
var q3 = /* @__PURE__ */ u((e, t) => {
  Mo.set(t.id, e);
}, "setNodeElem"), Y3 = /* @__PURE__ */ u(() => {
  Mo.clear();
}, "clear"), Pl = /* @__PURE__ */ u((e) => {
  const t = Mo.get(e.id);
  I.trace(
    "Transforming node",
    e.diff,
    e,
    "translate(" + (e.x - e.width / 2 - 5) + ", " + e.width / 2 + ")"
  );
  const r = 8, i = e.diff || 0;
  return e.clusterNode ? t.attr(
    "transform",
    "translate(" + (e.x + i - e.width / 2) + ", " + (e.y - e.height / 2 - r) + ")"
  ) : t.attr("transform", "translate(" + e.x + ", " + e.y + ")"), i;
}, "positionNode"), H3 = /* @__PURE__ */ u((e, t, r, i, s, a) => {
  t.arrowTypeStart && du(e, "start", t.arrowTypeStart, r, i, s, a), t.arrowTypeEnd && du(e, "end", t.arrowTypeEnd, r, i, s, a);
}, "addEdgeMarkers"), U3 = {
  arrow_cross: { type: "cross", fill: !1 },
  arrow_point: { type: "point", fill: !0 },
  arrow_barb: { type: "barb", fill: !0 },
  arrow_circle: { type: "circle", fill: !1 },
  aggregation: { type: "aggregation", fill: !1 },
  extension: { type: "extension", fill: !1 },
  composition: { type: "composition", fill: !0 },
  dependency: { type: "dependency", fill: !0 },
  lollipop: { type: "lollipop", fill: !1 },
  only_one: { type: "onlyOne", fill: !1 },
  zero_or_one: { type: "zeroOrOne", fill: !1 },
  one_or_more: { type: "oneOrMore", fill: !1 },
  zero_or_more: { type: "zeroOrMore", fill: !1 },
  requirement_arrow: { type: "requirement_arrow", fill: !1 },
  requirement_contains: { type: "requirement_contains", fill: !1 }
}, du = /* @__PURE__ */ u((e, t, r, i, s, a, n) => {
  var p;
  const o = U3[r];
  if (!o) {
    I.warn(`Unknown arrow type: ${r}`);
    return;
  }
  const h = o.type, d = `${s}_${a}-${h}${t === "start" ? "Start" : "End"}`;
  if (n && n.trim() !== "") {
    const g = n.replace(/[^\dA-Za-z]/g, "_"), f = `${d}_${g}`;
    if (!document.getElementById(f)) {
      const y = document.getElementById(d);
      if (y) {
        const m = y.cloneNode(!0);
        m.id = f, m.querySelectorAll("path, circle, line").forEach((b) => {
          b.setAttribute("stroke", n), o.fill && b.setAttribute("fill", n);
        }), (p = y.parentNode) == null || p.appendChild(m);
      }
    }
    e.attr(`marker-${t}`, `url(${i}#${f})`);
  } else
    e.attr(`marker-${t}`, `url(${i}#${d})`);
}, "addEdgeMarker"), eo = /* @__PURE__ */ new Map(), Ze = /* @__PURE__ */ new Map(), j3 = /* @__PURE__ */ u(() => {
  eo.clear(), Ze.clear();
}, "clear"), Tn = /* @__PURE__ */ u((e) => e ? e.reduce((r, i) => r + ";" + i, "") : "", "getLabelStyles"), pg = /* @__PURE__ */ u(async (e, t) => {
  let r = ke(K().flowchart.htmlLabels);
  const { labelStyles: i } = It(t);
  t.labelStyle = i;
  const s = await _r(e, t.label, {
    style: t.labelStyle,
    useHtmlLabels: r,
    addSvgBackground: !0,
    isNode: !1
  });
  I.info("abc82", t, t.labelType);
  const a = e.insert("g").attr("class", "edgeLabel"), n = a.insert("g").attr("class", "label").attr("data-id", t.id);
  n.node().appendChild(s);
  let o = s.getBBox();
  if (r) {
    const l = s.children[0], d = yt(s);
    o = l.getBoundingClientRect(), d.attr("width", o.width), d.attr("height", o.height);
  }
  n.attr("transform", "translate(" + -o.width / 2 + ", " + -o.height / 2 + ")"), eo.set(t.id, a), t.width = o.width, t.height = o.height;
  let h;
  if (t.startLabelLeft) {
    const l = await Xi(
      t.startLabelLeft,
      Tn(t.labelStyle)
    ), d = e.insert("g").attr("class", "edgeTerminals"), p = d.insert("g").attr("class", "inner");
    h = p.node().appendChild(l);
    const g = l.getBBox();
    p.attr("transform", "translate(" + -g.width / 2 + ", " + -g.height / 2 + ")"), Ze.get(t.id) || Ze.set(t.id, {}), Ze.get(t.id).startLeft = d, Fa(h, t.startLabelLeft);
  }
  if (t.startLabelRight) {
    const l = await Xi(
      t.startLabelRight,
      Tn(t.labelStyle)
    ), d = e.insert("g").attr("class", "edgeTerminals"), p = d.insert("g").attr("class", "inner");
    h = d.node().appendChild(l), p.node().appendChild(l);
    const g = l.getBBox();
    p.attr("transform", "translate(" + -g.width / 2 + ", " + -g.height / 2 + ")"), Ze.get(t.id) || Ze.set(t.id, {}), Ze.get(t.id).startRight = d, Fa(h, t.startLabelRight);
  }
  if (t.endLabelLeft) {
    const l = await Xi(t.endLabelLeft, Tn(t.labelStyle)), d = e.insert("g").attr("class", "edgeTerminals"), p = d.insert("g").attr("class", "inner");
    h = p.node().appendChild(l);
    const g = l.getBBox();
    p.attr("transform", "translate(" + -g.width / 2 + ", " + -g.height / 2 + ")"), d.node().appendChild(l), Ze.get(t.id) || Ze.set(t.id, {}), Ze.get(t.id).endLeft = d, Fa(h, t.endLabelLeft);
  }
  if (t.endLabelRight) {
    const l = await Xi(t.endLabelRight, Tn(t.labelStyle)), d = e.insert("g").attr("class", "edgeTerminals"), p = d.insert("g").attr("class", "inner");
    h = p.node().appendChild(l);
    const g = l.getBBox();
    p.attr("transform", "translate(" + -g.width / 2 + ", " + -g.height / 2 + ")"), d.node().appendChild(l), Ze.get(t.id) || Ze.set(t.id, {}), Ze.get(t.id).endRight = d, Fa(h, t.endLabelRight);
  }
  return s;
}, "insertEdgeLabel");
function Fa(e, t) {
  K().flowchart.htmlLabels && e && (e.style.width = t.length * 9 + "px", e.style.height = "12px");
}
u(Fa, "setTerminalWidth");
var gg = /* @__PURE__ */ u((e, t) => {
  I.debug("Moving label abc88 ", e.id, e.label, eo.get(e.id), t);
  let r = t.updatedPath ? t.updatedPath : t.originalPath;
  const i = K(), { subGraphTitleTotalMargin: s } = gn(i);
  if (e.label) {
    const a = eo.get(e.id);
    let n = e.x, o = e.y;
    if (r) {
      const h = ee.calcLabelPosition(r);
      I.debug(
        "Moving label " + e.label + " from (",
        n,
        ",",
        o,
        ") to (",
        h.x,
        ",",
        h.y,
        ") abc88"
      ), t.updatedPath && (n = h.x, o = h.y);
    }
    a.attr("transform", `translate(${n}, ${o + s / 2})`);
  }
  if (e.startLabelLeft) {
    const a = Ze.get(e.id).startLeft;
    let n = e.x, o = e.y;
    if (r) {
      const h = ee.calcTerminalLabelPosition(e.arrowTypeStart ? 10 : 0, "start_left", r);
      n = h.x, o = h.y;
    }
    a.attr("transform", `translate(${n}, ${o})`);
  }
  if (e.startLabelRight) {
    const a = Ze.get(e.id).startRight;
    let n = e.x, o = e.y;
    if (r) {
      const h = ee.calcTerminalLabelPosition(
        e.arrowTypeStart ? 10 : 0,
        "start_right",
        r
      );
      n = h.x, o = h.y;
    }
    a.attr("transform", `translate(${n}, ${o})`);
  }
  if (e.endLabelLeft) {
    const a = Ze.get(e.id).endLeft;
    let n = e.x, o = e.y;
    if (r) {
      const h = ee.calcTerminalLabelPosition(e.arrowTypeEnd ? 10 : 0, "end_left", r);
      n = h.x, o = h.y;
    }
    a.attr("transform", `translate(${n}, ${o})`);
  }
  if (e.endLabelRight) {
    const a = Ze.get(e.id).endRight;
    let n = e.x, o = e.y;
    if (r) {
      const h = ee.calcTerminalLabelPosition(e.arrowTypeEnd ? 10 : 0, "end_right", r);
      n = h.x, o = h.y;
    }
    a.attr("transform", `translate(${n}, ${o})`);
  }
}, "positionEdgeLabel"), G3 = /* @__PURE__ */ u((e, t) => {
  const r = e.x, i = e.y, s = Math.abs(t.x - r), a = Math.abs(t.y - i), n = e.width / 2, o = e.height / 2;
  return s >= n || a >= o;
}, "outsideNode"), X3 = /* @__PURE__ */ u((e, t, r) => {
  I.debug(`intersection calc abc89:
  outsidePoint: ${JSON.stringify(t)}
  insidePoint : ${JSON.stringify(r)}
  node        : x:${e.x} y:${e.y} w:${e.width} h:${e.height}`);
  const i = e.x, s = e.y, a = Math.abs(i - r.x), n = e.width / 2;
  let o = r.x < t.x ? n - a : n + a;
  const h = e.height / 2, l = Math.abs(t.y - r.y), d = Math.abs(t.x - r.x);
  if (Math.abs(s - t.y) * n > Math.abs(i - t.x) * h) {
    let p = r.y < t.y ? t.y - h - s : s - h - t.y;
    o = d * p / l;
    const g = {
      x: r.x < t.x ? r.x + o : r.x - d + o,
      y: r.y < t.y ? r.y + l - p : r.y - l + p
    };
    return o === 0 && (g.x = t.x, g.y = t.y), d === 0 && (g.x = t.x), l === 0 && (g.y = t.y), I.debug(`abc89 top/bottom calc, Q ${l}, q ${p}, R ${d}, r ${o}`, g), g;
  } else {
    r.x < t.x ? o = t.x - n - i : o = i - n - t.x;
    let p = l * o / d, g = r.x < t.x ? r.x + d - o : r.x - d + o, f = r.y < t.y ? r.y + p : r.y - p;
    return I.debug(`sides calc abc89, Q ${l}, q ${p}, R ${d}, r ${o}`, { _x: g, _y: f }), o === 0 && (g = t.x, f = t.y), d === 0 && (g = t.x), l === 0 && (f = t.y), { x: g, y: f };
  }
}, "intersection"), pu = /* @__PURE__ */ u((e, t) => {
  I.warn("abc88 cutPathAtIntersect", e, t);
  let r = [], i = e[0], s = !1;
  return e.forEach((a) => {
    if (I.info("abc88 checking point", a, t), !G3(t, a) && !s) {
      const n = X3(t, i, a);
      I.debug("abc88 inside", a, i, n), I.debug("abc88 intersection", n, t);
      let o = !1;
      r.forEach((h) => {
        o = o || h.x === n.x && h.y === n.y;
      }), r.some((h) => h.x === n.x && h.y === n.y) ? I.warn("abc88 no intersect", n, r) : r.push(n), s = !0;
    } else
      I.warn("abc88 outside", a, i), i = a, s || r.push(a);
  }), I.debug("returning points", r), r;
}, "cutPathAtIntersect");
function fg(e) {
  const t = [], r = [];
  for (let i = 1; i < e.length - 1; i++) {
    const s = e[i - 1], a = e[i], n = e[i + 1];
    (s.x === a.x && a.y === n.y && Math.abs(a.x - n.x) > 5 && Math.abs(a.y - s.y) > 5 || s.y === a.y && a.x === n.x && Math.abs(a.x - s.x) > 5 && Math.abs(a.y - n.y) > 5) && (t.push(a), r.push(i));
  }
  return { cornerPoints: t, cornerPointPositions: r };
}
u(fg, "extractCornerPoints");
var gu = /* @__PURE__ */ u(function(e, t, r) {
  const i = t.x - e.x, s = t.y - e.y, a = Math.sqrt(i * i + s * s), n = r / a;
  return { x: t.x - n * i, y: t.y - n * s };
}, "findAdjacentPoint"), K3 = /* @__PURE__ */ u(function(e) {
  const { cornerPointPositions: t } = fg(e), r = [];
  for (let i = 0; i < e.length; i++)
    if (t.includes(i)) {
      const s = e[i - 1], a = e[i + 1], n = e[i], o = gu(s, n, 5), h = gu(a, n, 5), l = h.x - o.x, d = h.y - o.y;
      r.push(o);
      const p = Math.sqrt(2) * 2;
      let g = { x: n.x, y: n.y };
      if (Math.abs(a.x - s.x) > 10 && Math.abs(a.y - s.y) >= 10) {
        I.debug(
          "Corner point fixing",
          Math.abs(a.x - s.x),
          Math.abs(a.y - s.y)
        );
        const f = 5;
        n.x === o.x ? g = {
          x: l < 0 ? o.x - f + p : o.x + f - p,
          y: d < 0 ? o.y - p : o.y + p
        } : g = {
          x: l < 0 ? o.x - p : o.x + p,
          y: d < 0 ? o.y - f + p : o.y + f - p
        };
      } else
        I.debug(
          "Corner point skipping fixing",
          Math.abs(a.x - s.x),
          Math.abs(a.y - s.y)
        );
      r.push(g, h);
    } else
      r.push(e[i]);
  return r;
}, "fixCorners"), Q3 = /* @__PURE__ */ u((e, t, r) => {
  const i = e - t - r, s = 2, a = 2, n = s + a, o = Math.floor(i / n), h = Array(o).fill(`${s} ${a}`).join(" ");
  return `0 ${t} ${h} ${r}`;
}, "generateDashArray"), yg = /* @__PURE__ */ u(function(e, t, r, i, s, a, n, o = !1) {
  var B;
  const { handDrawnSeed: h } = K();
  let l = t.points, d = !1;
  const p = s;
  var g = a;
  const f = [];
  for (const R in t.cssCompiledStyles)
    Vc(R) || f.push(t.cssCompiledStyles[R]);
  I.debug("UIO intersect check", t.points, g.x, p.x), g.intersect && p.intersect && !o && (l = l.slice(1, t.points.length - 1), l.unshift(p.intersect(l[0])), I.debug(
    "Last point UIO",
    t.start,
    "-->",
    t.end,
    l[l.length - 1],
    g,
    g.intersect(l[l.length - 1])
  ), l.push(g.intersect(l[l.length - 1])));
  const y = btoa(JSON.stringify(l));
  t.toCluster && (I.info("to cluster abc88", r.get(t.toCluster)), l = pu(t.points, r.get(t.toCluster).node), d = !0), t.fromCluster && (I.debug(
    "from cluster abc88",
    r.get(t.fromCluster),
    JSON.stringify(l, null, 2)
  ), l = pu(l.reverse(), r.get(t.fromCluster).node).reverse(), d = !0);
  let m = l.filter((R) => !Number.isNaN(R.y));
  m = K3(m);
  let x = _s;
  switch (x = ul, t.curve) {
    case "linear":
      x = ul;
      break;
    case "basis":
      x = _s;
      break;
    case "cardinal":
      x = md;
      break;
    case "bumpX":
      x = bd;
      break;
    case "bumpY":
      x = xd;
      break;
    case "catmullRom":
      x = yd;
      break;
    case "monotoneX":
      x = fd;
      break;
    case "monotoneY":
      x = gd;
      break;
    case "natural":
      x = pd;
      break;
    case "step":
      x = dd;
      break;
    case "stepAfter":
      x = ud;
      break;
    case "stepBefore":
      x = hd;
      break;
    default:
      x = _s;
  }
  const { x: b, y: v } = b0(t), _ = Ha().x(b).y(v).curve(x);
  let A;
  switch (t.thickness) {
    case "normal":
      A = "edge-thickness-normal";
      break;
    case "thick":
      A = "edge-thickness-thick";
      break;
    case "invisible":
      A = "edge-thickness-invisible";
      break;
    default:
      A = "edge-thickness-normal";
  }
  switch (t.pattern) {
    case "solid":
      A += " edge-pattern-solid";
      break;
    case "dotted":
      A += " edge-pattern-dotted";
      break;
    case "dashed":
      A += " edge-pattern-dashed";
      break;
    default:
      A += " edge-pattern-solid";
  }
  let S, k = t.curve === "rounded" ? mg(xg(m, t), 5) : _(m);
  const L = Array.isArray(t.style) ? t.style : [t.style];
  let T = L.find((R) => R == null ? void 0 : R.startsWith("stroke:")), C = !1;
  if (t.look === "handDrawn") {
    const R = Rt.svg(e);
    Object.assign([], m);
    const V = R.path(k, {
      roughness: 0.3,
      seed: h
    });
    A += " transition", S = yt(V).select("path").attr("id", t.id).attr("class", " " + A + (t.classes ? " " + t.classes : "")).attr("style", L ? L.reduce((D, O) => D + ";" + O, "") : "");
    let $ = S.attr("d");
    S.attr("d", $), e.node().appendChild(S.node());
  } else {
    const R = f.join(";"), V = L ? L.reduce((rt, ht) => rt + ht + ";", "") : "";
    let $ = "";
    t.animate && ($ = " edge-animation-fast"), t.animation && ($ = " edge-animation-" + t.animation);
    const D = (R ? R + ";" + V + ";" : V) + ";" + (L ? L.reduce((rt, ht) => rt + ";" + ht, "") : "");
    S = e.append("path").attr("d", k).attr("id", t.id).attr(
      "class",
      " " + A + (t.classes ? " " + t.classes : "") + ($ ?? "")
    ).attr("style", D), T = (B = D.match(/stroke:([^;]+)/)) == null ? void 0 : B[1], C = t.animate === !0 || !!t.animation || R.includes("animation");
    const O = S.node(), Y = typeof O.getTotalLength == "function" ? O.getTotalLength() : 0, M = cu[t.arrowTypeStart] || 0, G = cu[t.arrowTypeEnd] || 0;
    if (t.look === "neo" && !C) {
      const ht = `stroke-dasharray: ${t.pattern === "dotted" || t.pattern === "dashed" ? Q3(Y, M, G) : `0 ${M} ${Y - M - G} ${G}`}; stroke-dashoffset: 0;`;
      S.attr("style", ht + S.attr("style"));
    }
  }
  S.attr("data-edge", !0), S.attr("data-et", "edge"), S.attr("data-id", t.id), S.attr("data-points", y), t.showPoints && m.forEach((R) => {
    e.append("circle").style("stroke", "red").style("fill", "red").attr("r", 1).attr("cx", R.x).attr("cy", R.y);
  });
  let E = "";
  (K().flowchart.arrowMarkerAbsolute || K().state.arrowMarkerAbsolute) && (E = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search, E = E.replace(/\(/g, "\\(").replace(/\)/g, "\\)")), I.info("arrowTypeStart", t.arrowTypeStart), I.info("arrowTypeEnd", t.arrowTypeEnd), H3(S, t, E, n, i, T);
  const w = Math.floor(l.length / 2), W = l[w];
  ee.isLabelCoordinateInPath(W, S.attr("d")) || (d = !0);
  let N = {};
  return d && (N.updatedPath = l), N.originalPath = t.points, N;
}, "insertEdge");
function mg(e, t) {
  if (e.length < 2)
    return "";
  let r = "";
  const i = e.length, s = 1e-5;
  for (let a = 0; a < i; a++) {
    const n = e[a], o = e[a - 1], h = e[a + 1];
    if (a === 0)
      r += `M${n.x},${n.y}`;
    else if (a === i - 1)
      r += `L${n.x},${n.y}`;
    else {
      const l = n.x - o.x, d = n.y - o.y, p = h.x - n.x, g = h.y - n.y, f = Math.hypot(l, d), y = Math.hypot(p, g);
      if (f < s || y < s) {
        r += `L${n.x},${n.y}`;
        continue;
      }
      const m = l / f, x = d / f, b = p / y, v = g / y, _ = m * b + x * v, A = Math.max(-1, Math.min(1, _)), S = Math.acos(A);
      if (S < s || Math.abs(Math.PI - S) < s) {
        r += `L${n.x},${n.y}`;
        continue;
      }
      const k = Math.min(t / Math.sin(S / 2), f / 2, y / 2), L = n.x - m * k, T = n.y - x * k, C = n.x + b * k, E = n.y + v * k;
      r += `L${L},${T}`, r += `Q${n.x},${n.y} ${C},${E}`;
    }
  }
  return r;
}
u(mg, "generateRoundedPath");
function $l(e, t) {
  if (!e || !t)
    return { angle: 0, deltaX: 0, deltaY: 0 };
  const r = t.x - e.x, i = t.y - e.y;
  return { angle: Math.atan2(i, r), deltaX: r, deltaY: i };
}
u($l, "calculateDeltaAndAngle");
function xg(e, t) {
  const r = e.map((s) => ({ ...s }));
  if (e.length >= 2 && er[t.arrowTypeStart]) {
    const s = er[t.arrowTypeStart], a = e[0], n = e[1], { angle: o } = $l(a, n), h = s * Math.cos(o), l = s * Math.sin(o);
    r[0].x = a.x + h, r[0].y = a.y + l;
  }
  const i = e.length;
  if (i >= 2 && er[t.arrowTypeEnd]) {
    const s = er[t.arrowTypeEnd], a = e[i - 1], n = e[i - 2], { angle: o } = $l(n, a), h = s * Math.cos(o), l = s * Math.sin(o);
    r[i - 1].x = a.x - h, r[i - 1].y = a.y - l;
  }
  return r;
}
u(xg, "applyMarkerOffsetsToPoints");
var Z3 = /* @__PURE__ */ u((e, t, r, i) => {
  t.forEach((s) => {
    g4[s](e, r, i);
  });
}, "insertMarkers"), J3 = /* @__PURE__ */ u((e, t, r) => {
  I.trace("Making markers for ", r), e.append("defs").append("marker").attr("id", r + "_" + t + "-extensionStart").attr("class", "marker extension " + t).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 1,7 L18,13 V 1 Z"), e.append("defs").append("marker").attr("id", r + "_" + t + "-extensionEnd").attr("class", "marker extension " + t).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 1,1 V 13 L18,7 Z");
}, "extension"), t4 = /* @__PURE__ */ u((e, t, r) => {
  e.append("defs").append("marker").attr("id", r + "_" + t + "-compositionStart").attr("class", "marker composition " + t).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"), e.append("defs").append("marker").attr("id", r + "_" + t + "-compositionEnd").attr("class", "marker composition " + t).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
}, "composition"), e4 = /* @__PURE__ */ u((e, t, r) => {
  e.append("defs").append("marker").attr("id", r + "_" + t + "-aggregationStart").attr("class", "marker aggregation " + t).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"), e.append("defs").append("marker").attr("id", r + "_" + t + "-aggregationEnd").attr("class", "marker aggregation " + t).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
}, "aggregation"), r4 = /* @__PURE__ */ u((e, t, r) => {
  e.append("defs").append("marker").attr("id", r + "_" + t + "-dependencyStart").attr("class", "marker dependency " + t).attr("refX", 6).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 5,7 L9,13 L1,7 L9,1 Z"), e.append("defs").append("marker").attr("id", r + "_" + t + "-dependencyEnd").attr("class", "marker dependency " + t).attr("refX", 13).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
}, "dependency"), i4 = /* @__PURE__ */ u((e, t, r) => {
  e.append("defs").append("marker").attr("id", r + "_" + t + "-lollipopStart").attr("class", "marker lollipop " + t).attr("refX", 13).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("circle").attr("stroke", "black").attr("fill", "transparent").attr("cx", 7).attr("cy", 7).attr("r", 6), e.append("defs").append("marker").attr("id", r + "_" + t + "-lollipopEnd").attr("class", "marker lollipop " + t).attr("refX", 1).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("circle").attr("stroke", "black").attr("fill", "transparent").attr("cx", 7).attr("cy", 7).attr("r", 6);
}, "lollipop"), s4 = /* @__PURE__ */ u((e, t, r) => {
  e.append("marker").attr("id", r + "_" + t + "-pointEnd").attr("class", "marker " + t).attr("viewBox", "0 0 10 10").attr("refX", 5).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 8).attr("markerHeight", 8).attr("orient", "auto").append("path").attr("d", "M 0 0 L 10 5 L 0 10 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0"), e.append("marker").attr("id", r + "_" + t + "-pointStart").attr("class", "marker " + t).attr("viewBox", "0 0 10 10").attr("refX", 4.5).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 8).attr("markerHeight", 8).attr("orient", "auto").append("path").attr("d", "M 0 5 L 10 10 L 10 0 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
}, "point"), a4 = /* @__PURE__ */ u((e, t, r) => {
  e.append("marker").attr("id", r + "_" + t + "-circleEnd").attr("class", "marker " + t).attr("viewBox", "0 0 10 10").attr("refX", 11).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0"), e.append("marker").attr("id", r + "_" + t + "-circleStart").attr("class", "marker " + t).attr("viewBox", "0 0 10 10").attr("refX", -1).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
}, "circle"), n4 = /* @__PURE__ */ u((e, t, r) => {
  e.append("marker").attr("id", r + "_" + t + "-crossEnd").attr("class", "marker cross " + t).attr("viewBox", "0 0 11 11").attr("refX", 12).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0"), e.append("marker").attr("id", r + "_" + t + "-crossStart").attr("class", "marker cross " + t).attr("viewBox", "0 0 11 11").attr("refX", -1).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0");
}, "cross"), o4 = /* @__PURE__ */ u((e, t, r) => {
  e.append("defs").append("marker").attr("id", r + "_" + t + "-barbEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 14).attr("markerUnits", "userSpaceOnUse").attr("orient", "auto").append("path").attr("d", "M 19,7 L9,13 L14,7 L9,1 Z");
}, "barb"), l4 = /* @__PURE__ */ u((e, t, r) => {
  e.append("defs").append("marker").attr("id", r + "_" + t + "-onlyOneStart").attr("class", "marker onlyOne " + t).attr("refX", 0).attr("refY", 9).attr("markerWidth", 18).attr("markerHeight", 18).attr("orient", "auto").append("path").attr("d", "M9,0 L9,18 M15,0 L15,18"), e.append("defs").append("marker").attr("id", r + "_" + t + "-onlyOneEnd").attr("class", "marker onlyOne " + t).attr("refX", 18).attr("refY", 9).attr("markerWidth", 18).attr("markerHeight", 18).attr("orient", "auto").append("path").attr("d", "M3,0 L3,18 M9,0 L9,18");
}, "only_one"), c4 = /* @__PURE__ */ u((e, t, r) => {
  const i = e.append("defs").append("marker").attr("id", r + "_" + t + "-zeroOrOneStart").attr("class", "marker zeroOrOne " + t).attr("refX", 0).attr("refY", 9).attr("markerWidth", 30).attr("markerHeight", 18).attr("orient", "auto");
  i.append("circle").attr("fill", "white").attr("cx", 21).attr("cy", 9).attr("r", 6), i.append("path").attr("d", "M9,0 L9,18");
  const s = e.append("defs").append("marker").attr("id", r + "_" + t + "-zeroOrOneEnd").attr("class", "marker zeroOrOne " + t).attr("refX", 30).attr("refY", 9).attr("markerWidth", 30).attr("markerHeight", 18).attr("orient", "auto");
  s.append("circle").attr("fill", "white").attr("cx", 9).attr("cy", 9).attr("r", 6), s.append("path").attr("d", "M21,0 L21,18");
}, "zero_or_one"), h4 = /* @__PURE__ */ u((e, t, r) => {
  e.append("defs").append("marker").attr("id", r + "_" + t + "-oneOrMoreStart").attr("class", "marker oneOrMore " + t).attr("refX", 18).attr("refY", 18).attr("markerWidth", 45).attr("markerHeight", 36).attr("orient", "auto").append("path").attr("d", "M0,18 Q 18,0 36,18 Q 18,36 0,18 M42,9 L42,27"), e.append("defs").append("marker").attr("id", r + "_" + t + "-oneOrMoreEnd").attr("class", "marker oneOrMore " + t).attr("refX", 27).attr("refY", 18).attr("markerWidth", 45).attr("markerHeight", 36).attr("orient", "auto").append("path").attr("d", "M3,9 L3,27 M9,18 Q27,0 45,18 Q27,36 9,18");
}, "one_or_more"), u4 = /* @__PURE__ */ u((e, t, r) => {
  const i = e.append("defs").append("marker").attr("id", r + "_" + t + "-zeroOrMoreStart").attr("class", "marker zeroOrMore " + t).attr("refX", 18).attr("refY", 18).attr("markerWidth", 57).attr("markerHeight", 36).attr("orient", "auto");
  i.append("circle").attr("fill", "white").attr("cx", 48).attr("cy", 18).attr("r", 6), i.append("path").attr("d", "M0,18 Q18,0 36,18 Q18,36 0,18");
  const s = e.append("defs").append("marker").attr("id", r + "_" + t + "-zeroOrMoreEnd").attr("class", "marker zeroOrMore " + t).attr("refX", 39).attr("refY", 18).attr("markerWidth", 57).attr("markerHeight", 36).attr("orient", "auto");
  s.append("circle").attr("fill", "white").attr("cx", 9).attr("cy", 18).attr("r", 6), s.append("path").attr("d", "M21,18 Q39,0 57,18 Q39,36 21,18");
}, "zero_or_more"), d4 = /* @__PURE__ */ u((e, t, r) => {
  e.append("defs").append("marker").attr("id", r + "_" + t + "-requirement_arrowEnd").attr("refX", 20).attr("refY", 10).attr("markerWidth", 20).attr("markerHeight", 20).attr("orient", "auto").append("path").attr(
    "d",
    `M0,0
      L20,10
      M20,10
      L0,20`
  );
}, "requirement_arrow"), p4 = /* @__PURE__ */ u((e, t, r) => {
  const i = e.append("defs").append("marker").attr("id", r + "_" + t + "-requirement_containsStart").attr("refX", 0).attr("refY", 10).attr("markerWidth", 20).attr("markerHeight", 20).attr("orient", "auto").append("g");
  i.append("circle").attr("cx", 10).attr("cy", 10).attr("r", 9).attr("fill", "none"), i.append("line").attr("x1", 1).attr("x2", 19).attr("y1", 10).attr("y2", 10), i.append("line").attr("y1", 1).attr("y2", 19).attr("x1", 10).attr("x2", 10);
}, "requirement_contains"), g4 = {
  extension: J3,
  composition: t4,
  aggregation: e4,
  dependency: r4,
  lollipop: i4,
  point: s4,
  circle: a4,
  cross: n4,
  barb: o4,
  only_one: l4,
  zero_or_one: c4,
  one_or_more: h4,
  zero_or_more: u4,
  requirement_arrow: d4,
  requirement_contains: p4
}, bg = Z3, f4 = {
  common: St,
  getConfig: fe,
  insertCluster: Xc,
  insertEdge: yg,
  insertEdgeLabel: pg,
  insertMarkers: bg,
  insertNode: Oo,
  interpolateToCurve: zc,
  labelHelper: Qt,
  log: I,
  positionEdgeLabel: gg
}, Za = {}, kg = /* @__PURE__ */ u((e) => {
  for (const t of e)
    Za[t.name] = t;
}, "registerLayoutLoaders"), y4 = /* @__PURE__ */ u(() => {
  kg([
    {
      name: "dagre",
      loader: /* @__PURE__ */ u(async () => await Promise.resolve().then(() => i6), "loader")
    },
    {
      name: "cose-bilkent",
      loader: /* @__PURE__ */ u(async () => await Promise.resolve().then(() => n6), "loader")
    }
  ]);
}, "registerDefaultLayoutLoaders");
y4();
var wa = /* @__PURE__ */ u(async (e, t) => {
  if (!(e.layoutAlgorithm in Za))
    throw new Error(`Unknown layout algorithm: ${e.layoutAlgorithm}`);
  const r = Za[e.layoutAlgorithm];
  return (await r.loader()).render(e, t, f4, {
    algorithm: r.algorithm
  });
}, "render"), fn = /* @__PURE__ */ u((e = "", { fallback: t = "dagre" } = {}) => {
  if (e in Za)
    return e;
  if (t in Za)
    return I.warn(`Layout algorithm ${e} is not registered. Using ${t} as fallback.`), t;
  throw new Error(`Both layout algorithms ${e} and ${t} are not registered.`);
}, "getRegisteredLayoutAlgorithm"), vg = "c4", m4 = /* @__PURE__ */ u((e) => /^\s*C4Context|C4Container|C4Component|C4Dynamic|C4Deployment/.test(e), "detector"), x4 = /* @__PURE__ */ u(async () => {
  const { diagram: e } = await Promise.resolve().then(() => rv);
  return { id: vg, diagram: e };
}, "loader"), b4 = {
  id: vg,
  detector: m4,
  loader: x4
}, k4 = b4, Sg = "flowchart", v4 = /* @__PURE__ */ u((e, t) => {
  var r, i;
  return ((r = t == null ? void 0 : t.flowchart) == null ? void 0 : r.defaultRenderer) === "dagre-wrapper" || ((i = t == null ? void 0 : t.flowchart) == null ? void 0 : i.defaultRenderer) === "elk" ? !1 : /^\s*graph/.test(e);
}, "detector"), S4 = /* @__PURE__ */ u(async () => {
  const { diagram: e } = await Promise.resolve().then(() => oh);
  return { id: Sg, diagram: e };
}, "loader"), C4 = {
  id: Sg,
  detector: v4,
  loader: S4
}, w4 = C4, Cg = "flowchart-v2", T4 = /* @__PURE__ */ u((e, t) => {
  var r, i, s;
  return ((r = t == null ? void 0 : t.flowchart) == null ? void 0 : r.defaultRenderer) === "dagre-d3" ? !1 : (((i = t == null ? void 0 : t.flowchart) == null ? void 0 : i.defaultRenderer) === "elk" && (t.layout = "elk"), /^\s*graph/.test(e) && ((s = t == null ? void 0 : t.flowchart) == null ? void 0 : s.defaultRenderer) === "dagre-wrapper" ? !0 : /^\s*flowchart/.test(e));
}, "detector"), _4 = /* @__PURE__ */ u(async () => {
  const { diagram: e } = await Promise.resolve().then(() => oh);
  return { id: Cg, diagram: e };
}, "loader"), E4 = {
  id: Cg,
  detector: T4,
  loader: _4
}, A4 = E4, wg = "er", L4 = /* @__PURE__ */ u((e) => /^\s*erDiagram/.test(e), "detector"), B4 = /* @__PURE__ */ u(async () => {
  const { diagram: e } = await Promise.resolve().then(() => Sv);
  return { id: wg, diagram: e };
}, "loader"), D4 = {
  id: wg,
  detector: L4,
  loader: B4
}, I4 = D4, Tg = "gitGraph", F4 = /* @__PURE__ */ u((e) => /^\s*gitGraph/.test(e), "detector"), N4 = /* @__PURE__ */ u(async () => {
  const { diagram: e } = await Promise.resolve().then(() => yS);
  return { id: Tg, diagram: e };
}, "loader"), R4 = {
  id: Tg,
  detector: F4,
  loader: N4
}, M4 = R4, _g = "gantt", O4 = /* @__PURE__ */ u((e) => /^\s*gantt/.test(e), "detector"), P4 = /* @__PURE__ */ u(async () => {
  const { diagram: e } = await Promise.resolve().then(() => oC);
  return { id: _g, diagram: e };
}, "loader"), $4 = {
  id: _g,
  detector: O4,
  loader: P4
}, V4 = $4, Eg = "info", z4 = /* @__PURE__ */ u((e) => /^\s*info/.test(e), "detector"), W4 = /* @__PURE__ */ u(async () => {
  const { diagram: e } = await Promise.resolve().then(() => fC);
  return { id: Eg, diagram: e };
}, "loader"), q4 = {
  id: Eg,
  detector: z4,
  loader: W4
}, Ag = "pie", Y4 = /* @__PURE__ */ u((e) => /^\s*pie/.test(e), "detector"), H4 = /* @__PURE__ */ u(async () => {
  const { diagram: e } = await Promise.resolve().then(() => IC);
  return { id: Ag, diagram: e };
}, "loader"), U4 = {
  id: Ag,
  detector: Y4,
  loader: H4
}, Lg = "quadrantChart", j4 = /* @__PURE__ */ u((e) => /^\s*quadrantChart/.test(e), "detector"), G4 = /* @__PURE__ */ u(async () => {
  const { diagram: e } = await Promise.resolve().then(() => zC);
  return { id: Lg, diagram: e };
}, "loader"), X4 = {
  id: Lg,
  detector: j4,
  loader: G4
}, K4 = X4, Bg = "xychart", Q4 = /* @__PURE__ */ u((e) => /^\s*xychart(-beta)?/.test(e), "detector"), Z4 = /* @__PURE__ */ u(async () => {
  const { diagram: e } = await Promise.resolve().then(() => rw);
  return { id: Bg, diagram: e };
}, "loader"), J4 = {
  id: Bg,
  detector: Q4,
  loader: Z4
}, t5 = J4, Dg = "requirement", e5 = /* @__PURE__ */ u((e) => /^\s*requirement(Diagram)?/.test(e), "detector"), r5 = /* @__PURE__ */ u(async () => {
  const { diagram: e } = await Promise.resolve().then(() => cw);
  return { id: Dg, diagram: e };
}, "loader"), i5 = {
  id: Dg,
  detector: e5,
  loader: r5
}, s5 = i5, Ig = "sequence", a5 = /* @__PURE__ */ u((e) => /^\s*sequenceDiagram/.test(e), "detector"), n5 = /* @__PURE__ */ u(async () => {
  const { diagram: e } = await Promise.resolve().then(() => Kw);
  return { id: Ig, diagram: e };
}, "loader"), o5 = {
  id: Ig,
  detector: a5,
  loader: n5
}, l5 = o5, Fg = "class", c5 = /* @__PURE__ */ u((e, t) => {
  var r;
  return ((r = t == null ? void 0 : t.class) == null ? void 0 : r.defaultRenderer) === "dagre-wrapper" ? !1 : /^\s*classDiagram/.test(e);
}, "detector"), h5 = /* @__PURE__ */ u(async () => {
  const { diagram: e } = await Promise.resolve().then(() => rT);
  return { id: Fg, diagram: e };
}, "loader"), u5 = {
  id: Fg,
  detector: c5,
  loader: h5
}, d5 = u5, Ng = "classDiagram", p5 = /* @__PURE__ */ u((e, t) => {
  var r;
  return /^\s*classDiagram/.test(e) && ((r = t == null ? void 0 : t.class) == null ? void 0 : r.defaultRenderer) === "dagre-wrapper" ? !0 : /^\s*classDiagram-v2/.test(e);
}, "detector"), g5 = /* @__PURE__ */ u(async () => {
  const { diagram: e } = await Promise.resolve().then(() => sT);
  return { id: Ng, diagram: e };
}, "loader"), f5 = {
  id: Ng,
  detector: p5,
  loader: g5
}, y5 = f5, Rg = "state", m5 = /* @__PURE__ */ u((e, t) => {
  var r;
  return ((r = t == null ? void 0 : t.state) == null ? void 0 : r.defaultRenderer) === "dagre-wrapper" ? !1 : /^\s*stateDiagram/.test(e);
}, "detector"), x5 = /* @__PURE__ */ u(async () => {
  const { diagram: e } = await Promise.resolve().then(() => jT);
  return { id: Rg, diagram: e };
}, "loader"), b5 = {
  id: Rg,
  detector: m5,
  loader: x5
}, k5 = b5, Mg = "stateDiagram", v5 = /* @__PURE__ */ u((e, t) => {
  var r;
  return !!(/^\s*stateDiagram-v2/.test(e) || /^\s*stateDiagram/.test(e) && ((r = t == null ? void 0 : t.state) == null ? void 0 : r.defaultRenderer) === "dagre-wrapper");
}, "detector"), S5 = /* @__PURE__ */ u(async () => {
  const { diagram: e } = await Promise.resolve().then(() => XT);
  return { id: Mg, diagram: e };
}, "loader"), C5 = {
  id: Mg,
  detector: v5,
  loader: S5
}, w5 = C5, Og = "journey", T5 = /* @__PURE__ */ u((e) => /^\s*journey/.test(e), "detector"), _5 = /* @__PURE__ */ u(async () => {
  const { diagram: e } = await Promise.resolve().then(() => m7);
  return { id: Og, diagram: e };
}, "loader"), E5 = {
  id: Og,
  detector: T5,
  loader: _5
}, A5 = E5, L5 = /* @__PURE__ */ u((e, t, r) => {
  I.debug(`rendering svg for syntax error
`);
  const i = xi(t), s = i.append("g");
  i.attr("viewBox", "0 0 2412 512"), fr(i, 100, 512, !0), s.append("path").attr("class", "error-icon").attr(
    "d",
    "m411.313,123.313c6.25-6.25 6.25-16.375 0-22.625s-16.375-6.25-22.625,0l-32,32-9.375,9.375-20.688-20.688c-12.484-12.5-32.766-12.5-45.25,0l-16,16c-1.261,1.261-2.304,2.648-3.31,4.051-21.739-8.561-45.324-13.426-70.065-13.426-105.867,0-192,86.133-192,192s86.133,192 192,192 192-86.133 192-192c0-24.741-4.864-48.327-13.426-70.065 1.402-1.007 2.79-2.049 4.051-3.31l16-16c12.5-12.492 12.5-32.758 0-45.25l-20.688-20.688 9.375-9.375 32.001-31.999zm-219.313,100.687c-52.938,0-96,43.063-96,96 0,8.836-7.164,16-16,16s-16-7.164-16-16c0-70.578 57.422-128 128-128 8.836,0 16,7.164 16,16s-7.164,16-16,16z"
  ), s.append("path").attr("class", "error-icon").attr(
    "d",
    "m459.02,148.98c-6.25-6.25-16.375-6.25-22.625,0s-6.25,16.375 0,22.625l16,16c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688 6.25-6.25 6.25-16.375 0-22.625l-16.001-16z"
  ), s.append("path").attr("class", "error-icon").attr(
    "d",
    "m340.395,75.605c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688 6.25-6.25 6.25-16.375 0-22.625l-16-16c-6.25-6.25-16.375-6.25-22.625,0s-6.25,16.375 0,22.625l15.999,16z"
  ), s.append("path").attr("class", "error-icon").attr(
    "d",
    "m400,64c8.844,0 16-7.164 16-16v-32c0-8.836-7.156-16-16-16-8.844,0-16,7.164-16,16v32c0,8.836 7.156,16 16,16z"
  ), s.append("path").attr("class", "error-icon").attr(
    "d",
    "m496,96.586h-32c-8.844,0-16,7.164-16,16 0,8.836 7.156,16 16,16h32c8.844,0 16-7.164 16-16 0-8.836-7.156-16-16-16z"
  ), s.append("path").attr("class", "error-icon").attr(
    "d",
    "m436.98,75.605c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688l32-32c6.25-6.25 6.25-16.375 0-22.625s-16.375-6.25-22.625,0l-32,32c-6.251,6.25-6.251,16.375-0.001,22.625z"
  ), s.append("text").attr("class", "error-text").attr("x", 1440).attr("y", 250).attr("font-size", "150px").style("text-anchor", "middle").text("Syntax error in text"), s.append("text").attr("class", "error-text").attr("x", 1250).attr("y", 400).attr("font-size", "100px").style("text-anchor", "middle").text(`mermaid version ${r}`);
}, "draw"), Pg = { draw: L5 }, B5 = Pg, D5 = {
  db: {},
  renderer: Pg,
  parser: {
    parse: /* @__PURE__ */ u(() => {
    }, "parse")
  }
}, I5 = D5, $g = "flowchart-elk", F5 = /* @__PURE__ */ u((e, t = {}) => {
  var r;
  return (
    // If diagram explicitly states flowchart-elk
    /^\s*flowchart-elk/.test(e) || // If a flowchart/graph diagram has their default renderer set to elk
    /^\s*(flowchart|graph)/.test(e) && ((r = t == null ? void 0 : t.flowchart) == null ? void 0 : r.defaultRenderer) === "elk" ? (t.layout = "elk", !0) : !1
  );
}, "detector"), N5 = /* @__PURE__ */ u(async () => {
  const { diagram: e } = await Promise.resolve().then(() => oh);
  return { id: $g, diagram: e };
}, "loader"), R5 = {
  id: $g,
  detector: F5,
  loader: N5
}, M5 = R5, Vg = "timeline", O5 = /* @__PURE__ */ u((e) => /^\s*timeline/.test(e), "detector"), P5 = /* @__PURE__ */ u(async () => {
  const { diagram: e } = await Promise.resolve().then(() => $7);
  return { id: Vg, diagram: e };
}, "loader"), $5 = {
  id: Vg,
  detector: O5,
  loader: P5
}, V5 = $5, zg = "mindmap", z5 = /* @__PURE__ */ u((e) => /^\s*mindmap/.test(e), "detector"), W5 = /* @__PURE__ */ u(async () => {
  const { diagram: e } = await Promise.resolve().then(() => G7);
  return { id: zg, diagram: e };
}, "loader"), q5 = {
  id: zg,
  detector: z5,
  loader: W5
}, Y5 = q5, Wg = "kanban", H5 = /* @__PURE__ */ u((e) => /^\s*kanban/.test(e), "detector"), U5 = /* @__PURE__ */ u(async () => {
  const { diagram: e } = await Promise.resolve().then(() => g8);
  return { id: Wg, diagram: e };
}, "loader"), j5 = {
  id: Wg,
  detector: H5,
  loader: U5
}, G5 = j5, qg = "sankey", X5 = /* @__PURE__ */ u((e) => /^\s*sankey(-beta)?/.test(e), "detector"), K5 = /* @__PURE__ */ u(async () => {
  const { diagram: e } = await Promise.resolve().then(() => I8);
  return { id: qg, diagram: e };
}, "loader"), Q5 = {
  id: qg,
  detector: X5,
  loader: K5
}, Z5 = Q5, Yg = "packet", J5 = /* @__PURE__ */ u((e) => /^\s*packet(-beta)?/.test(e), "detector"), tk = /* @__PURE__ */ u(async () => {
  const { diagram: e } = await Promise.resolve().then(() => q8);
  return { id: Yg, diagram: e };
}, "loader"), ek = {
  id: Yg,
  detector: J5,
  loader: tk
}, Hg = "radar", rk = /* @__PURE__ */ u((e) => /^\s*radar-beta/.test(e), "detector"), ik = /* @__PURE__ */ u(async () => {
  const { diagram: e } = await Promise.resolve().then(() => h_);
  return { id: Hg, diagram: e };
}, "loader"), sk = {
  id: Hg,
  detector: rk,
  loader: ik
}, Ug = "block", ak = /* @__PURE__ */ u((e) => /^\s*block(-beta)?/.test(e), "detector"), nk = /* @__PURE__ */ u(async () => {
  const { diagram: e } = await Promise.resolve().then(() => ME);
  return { id: Ug, diagram: e };
}, "loader"), ok = {
  id: Ug,
  detector: ak,
  loader: nk
}, lk = ok, jg = "architecture", ck = /* @__PURE__ */ u((e) => /^\s*architecture/.test(e), "detector"), hk = /* @__PURE__ */ u(async () => {
  const { diagram: e } = await Promise.resolve().then(() => r9);
  return { id: jg, diagram: e };
}, "loader"), uk = {
  id: jg,
  detector: ck,
  loader: hk
}, dk = uk, Gg = "treemap", pk = /* @__PURE__ */ u((e) => /^\s*treemap/.test(e), "detector"), gk = /* @__PURE__ */ u(async () => {
  const { diagram: e } = await Promise.resolve().then(() => p9);
  return { id: Gg, diagram: e };
}, "loader"), fk = {
  id: Gg,
  detector: pk,
  loader: gk
}, fu = !1, Po = /* @__PURE__ */ u(() => {
  fu || (fu = !0, Un("error", I5, (e) => e.toLowerCase().trim() === "error"), Un(
    "---",
    // --- diagram type may appear if YAML front-matter is not parsed correctly
    {
      db: {
        clear: /* @__PURE__ */ u(() => {
        }, "clear")
      },
      styles: {},
      // should never be used
      renderer: {
        draw: /* @__PURE__ */ u(() => {
        }, "draw")
      },
      parser: {
        parse: /* @__PURE__ */ u(() => {
          throw new Error(
            "Diagrams beginning with --- are not valid. If you were trying to use a YAML front-matter, please ensure that you've correctly opened and closed the YAML front-matter with un-indented `---` blocks"
          );
        }, "parse")
      },
      init: /* @__PURE__ */ u(() => null, "init")
      // no op
    },
    (e) => e.toLowerCase().trimStart().startsWith("---")
  ), pl(M5, Y5, dk), pl(
    k4,
    G5,
    y5,
    d5,
    I4,
    V4,
    q4,
    U4,
    s5,
    l5,
    A4,
    w4,
    V5,
    M4,
    w5,
    k5,
    A5,
    K4,
    Z5,
    ek,
    t5,
    lk,
    sk,
    fk
  ));
}, "addDiagrams"), yk = /* @__PURE__ */ u(async () => {
  I.debug("Loading registered diagrams");
  const t = (await Promise.allSettled(
    Object.entries(es).map(async ([r, { detector: i, loader: s }]) => {
      if (s)
        try {
          xl(r);
        } catch {
          try {
            const { diagram: a, id: n } = await s();
            Un(n, a, i);
          } catch (a) {
            throw I.error(`Failed to load external diagram with key ${r}. Removing from detectors.`), delete es[r], a;
          }
        }
    })
  )).filter((r) => r.status === "rejected");
  if (t.length > 0) {
    I.error(`Failed to load ${t.length} external diagrams`);
    for (const r of t)
      I.error(r);
    throw new Error(`Failed to load ${t.length} external diagrams`);
  }
}, "loadRegisteredDiagrams"), mk = "graphics-document document";
function Xg(e, t) {
  e.attr("role", mk), t !== "" && e.attr("aria-roledescription", t);
}
u(Xg, "setA11yDiagramInfo");
function Kg(e, t, r, i) {
  if (e.insert !== void 0) {
    if (r) {
      const s = `chart-desc-${i}`;
      e.attr("aria-describedby", s), e.insert("desc", ":first-child").attr("id", s).text(r);
    }
    if (t) {
      const s = `chart-title-${i}`;
      e.attr("aria-labelledby", s), e.insert("title", ":first-child").attr("id", s).text(t);
    }
  }
}
u(Kg, "addSVGa11yTitleDescription");
var Ji, Vl = (Ji = class {
  constructor(t, r, i, s, a) {
    this.type = t, this.text = r, this.db = i, this.parser = s, this.renderer = a;
  }
  static async fromText(t, r = {}) {
    var l, d;
    const i = fe(), s = _c(t, i);
    t = f3(t) + `
`;
    try {
      xl(s);
    } catch {
      const p = hx(s);
      if (!p)
        throw new Td(`Diagram ${s} not found.`);
      const { id: g, diagram: f } = await p();
      Un(g, f);
    }
    const { db: a, parser: n, renderer: o, init: h } = xl(s);
    return n.parser && (n.parser.yy = a), (l = a.clear) == null || l.call(a), h == null || h(i), r.title && ((d = a.setDiagramTitle) == null || d.call(a, r.title)), await n.parse(t), new Ji(s, t, a, n, o);
  }
  async render(t, r) {
    await this.renderer.draw(this.text, t, r, this);
  }
  getParser() {
    return this.parser;
  }
  getType() {
    return this.type;
  }
}, u(Ji, "Diagram"), Ji), yu = [], xk = /* @__PURE__ */ u(() => {
  yu.forEach((e) => {
    e();
  }), yu = [];
}, "attachFunctions"), bk = /* @__PURE__ */ u((e) => e.replace(/^\s*%%(?!{)[^\n]+\n?/gm, "").trimStart(), "cleanupComments");
function Qg(e) {
  const t = e.match(wd);
  if (!t)
    return {
      text: e,
      metadata: {}
    };
  let r = Io(t[1], {
    // To support config, we need JSON schema.
    // https://www.yaml.org/spec/1.2/spec.html#id2803231
    schema: Do
  }) ?? {};
  r = typeof r == "object" && !Array.isArray(r) ? r : {};
  const i = {};
  return r.displayMode && (i.displayMode = r.displayMode.toString()), r.title && (i.title = r.title.toString()), r.config && (i.config = r.config), {
    text: e.slice(t[0].length),
    metadata: i
  };
}
u(Qg, "extractFrontMatter");
var kk = /* @__PURE__ */ u((e) => e.replace(/\r\n?/g, `
`).replace(
  /<(\w+)([^>]*)>/g,
  (t, r, i) => "<" + r + i.replace(/="([^"]*)"/g, "='$1'") + ">"
), "cleanupText"), vk = /* @__PURE__ */ u((e) => {
  const { text: t, metadata: r } = Qg(e), { displayMode: i, title: s, config: a = {} } = r;
  return i && (a.gantt || (a.gantt = {}), a.gantt.displayMode = i), { title: s, config: a, text: t };
}, "processFrontmatter"), Sk = /* @__PURE__ */ u((e) => {
  const t = ee.detectInit(e) ?? {}, r = ee.detectDirective(e, "wrap");
  return Array.isArray(r) ? t.wrap = r.some(({ type: i }) => i === "wrap") : (r == null ? void 0 : r.type) === "wrap" && (t.wrap = !0), {
    text: a3(e),
    directive: t
  };
}, "processDirectives");
function Zc(e) {
  const t = kk(e), r = vk(t), i = Sk(r.text), s = gr(r.config, i.directive);
  return e = bk(i.text), {
    code: e,
    title: r.title,
    config: s
  };
}
u(Zc, "preprocessDiagram");
function Zg(e) {
  const t = new TextEncoder().encode(e), r = Array.from(t, (i) => String.fromCodePoint(i)).join("");
  return btoa(r);
}
u(Zg, "toBase64");
var Ck = 5e4, wk = "graph TB;a[Maximum text size in diagram exceeded];style a fill:#faa", Tk = "sandbox", _k = "loose", Ek = "http://www.w3.org/2000/svg", Ak = "http://www.w3.org/1999/xlink", Lk = "http://www.w3.org/1999/xhtml", Bk = "100%", Dk = "100%", Ik = "border:0;margin:0;", Fk = "margin:0", Nk = "allow-top-navigation-by-user-activation allow-popups", Rk = 'The "iframe" tag is not supported by your browser.', Mk = ["foreignobject"], Ok = ["dominant-baseline"];
function Jc(e) {
  const t = Zc(e);
  return Yn(), Tx(t.config ?? {}), t;
}
u(Jc, "processAndSetConfigs");
async function Jg(e, t) {
  Po();
  try {
    const { code: r, config: i } = Jc(e);
    return { diagramType: (await ef(r)).type, config: i };
  } catch (r) {
    if (t != null && t.suppressErrors)
      return !1;
    throw r;
  }
}
u(Jg, "parse");
var mu = /* @__PURE__ */ u((e, t, r = []) => `
.${e} ${t} { ${r.join(" !important; ")} !important; }`, "cssImportantStyles"), Pk = /* @__PURE__ */ u((e, t = /* @__PURE__ */ new Map()) => {
  var i;
  let r = "";
  if (e.themeCSS !== void 0 && (r += `
${e.themeCSS}`), e.fontFamily !== void 0 && (r += `
:root { --mermaid-font-family: ${e.fontFamily}}`), e.altFontFamily !== void 0 && (r += `
:root { --mermaid-alt-font-family: ${e.altFontFamily}}`), t instanceof Map) {
    const o = e.htmlLabels ?? ((i = e.flowchart) == null ? void 0 : i.htmlLabels) ? ["> *", "span"] : ["rect", "polygon", "ellipse", "circle", "path"];
    t.forEach((h) => {
      Gh(h.styles) || o.forEach((l) => {
        r += mu(h.id, l, h.styles);
      }), Gh(h.textStyles) || (r += mu(
        h.id,
        "tspan",
        ((h == null ? void 0 : h.textStyles) || []).map((l) => l.replace("color", "fill"))
      ));
    });
  }
  return r;
}, "createCssStyles"), $k = /* @__PURE__ */ u((e, t, r, i) => {
  const s = Pk(e, r), a = Yx(t, s, e.themeVariables);
  return Bm(Im(`${i}{${a}}`), Dm);
}, "createUserStyles"), Vk = /* @__PURE__ */ u((e = "", t, r) => {
  let i = e;
  return !r && !t && (i = i.replace(
    /marker-end="url\([\d+./:=?A-Za-z-]*?#/g,
    'marker-end="url(#'
  )), i = Qr(i), i = i.replace(/<br>/g, "<br/>"), i;
}, "cleanUpSvgCode"), zk = /* @__PURE__ */ u((e = "", t) => {
  var s, a;
  const r = (a = (s = t == null ? void 0 : t.viewBox) == null ? void 0 : s.baseVal) != null && a.height ? t.viewBox.baseVal.height + "px" : Dk, i = Zg(`<body style="${Fk}">${e}</body>`);
  return `<iframe style="width:${Bk};height:${r};${Ik}" src="data:text/html;charset=UTF-8;base64,${i}" sandbox="${Nk}">
  ${Rk}
</iframe>`;
}, "putIntoIFrame"), xu = /* @__PURE__ */ u((e, t, r, i, s) => {
  const a = e.append("div");
  a.attr("id", r), i && a.attr("style", i);
  const n = a.append("svg").attr("id", t).attr("width", "100%").attr("xmlns", Ek);
  return s && n.attr("xmlns:xlink", s), n.append("g"), e;
}, "appendDivSvgG");
function zl(e, t) {
  return e.append("iframe").attr("id", t).attr("style", "width: 100%; height: 100%;").attr("sandbox", "");
}
u(zl, "sandboxedIframe");
var Wk = /* @__PURE__ */ u((e, t, r, i) => {
  var s, a, n;
  (s = e.getElementById(t)) == null || s.remove(), (a = e.getElementById(r)) == null || a.remove(), (n = e.getElementById(i)) == null || n.remove();
}, "removeExistingElements"), qk = /* @__PURE__ */ u(async function(e, t, r) {
  var W, N, B, R, V, $;
  Po();
  const i = Jc(t);
  t = i.code;
  const s = fe();
  I.debug(s), t.length > ((s == null ? void 0 : s.maxTextSize) ?? Ck) && (t = wk);
  const a = "#" + e, n = "i" + e, o = "#" + n, h = "d" + e, l = "#" + h, d = /* @__PURE__ */ u(() => {
    const O = yt(g ? o : l).node();
    O && "remove" in O && O.remove();
  }, "removeTempElements");
  let p = yt("body");
  const g = s.securityLevel === Tk, f = s.securityLevel === _k, y = s.fontFamily;
  if (r !== void 0) {
    if (r && (r.innerHTML = ""), g) {
      const D = zl(yt(r), n);
      p = yt(D.nodes()[0].contentDocument.body), p.node().style.margin = 0;
    } else
      p = yt(r);
    xu(p, e, h, `font-family: ${y}`, Ak);
  } else {
    if (Wk(document, e, h, n), g) {
      const D = zl(yt("body"), n);
      p = yt(D.nodes()[0].contentDocument.body), p.node().style.margin = 0;
    } else
      p = yt("body");
    xu(p, e, h);
  }
  let m, x;
  try {
    m = await Vl.fromText(t, { title: i.title });
  } catch (D) {
    if (s.suppressErrorRendering)
      throw d(), D;
    m = await Vl.fromText("error"), x = D;
  }
  const b = p.select(l).node(), v = m.type, _ = b.firstChild, A = _.firstChild, S = (N = (W = m.renderer).getClasses) == null ? void 0 : N.call(W, t, m), k = $k(s, v, S, a), L = document.createElement("style");
  L.innerHTML = k, _.insertBefore(L, A);
  try {
    await m.renderer.draw(t, e, dl.version, m);
  } catch (D) {
    throw s.suppressErrorRendering ? d() : B5.draw(t, e, dl.version), D;
  }
  const T = p.select(`${l} svg`), C = (R = (B = m.db).getAccTitle) == null ? void 0 : R.call(B), E = ($ = (V = m.db).getAccDescription) == null ? void 0 : $.call(V);
  rf(v, T, C, E), p.select(`[id="${e}"]`).selectAll("foreignobject > *").attr("xmlns", Lk);
  let w = p.select(l).node().innerHTML;
  if (I.debug("config.arrowMarkerAbsolute", s.arrowMarkerAbsolute), w = Vk(w, g, ke(s.arrowMarkerAbsolute)), g) {
    const D = p.select(l + " svg").node();
    w = zk(w, D);
  } else f || (w = ua.sanitize(w, {
    ADD_TAGS: Mk,
    ADD_ATTR: Ok,
    HTML_INTEGRATION_POINTS: { foreignobject: !0 }
  }));
  if (xk(), x)
    throw x;
  return d(), {
    diagramType: v,
    svg: w,
    bindFunctions: m.db.bindFunctions
  };
}, "render");
function tf(e = {}) {
  var i;
  const t = De({}, e);
  t != null && t.fontFamily && !((i = t.themeVariables) != null && i.fontFamily) && (t.themeVariables || (t.themeVariables = {}), t.themeVariables.fontFamily = t.fontFamily), Cx(t), t != null && t.theme && t.theme in yi ? t.themeVariables = yi[t.theme].getThemeVariables(
    t.themeVariables
  ) : t && (t.themeVariables = yi.default.getThemeVariables(t.themeVariables));
  const r = typeof t == "object" ? Sx(t) : Ld();
  Tc(r.logLevel), Po();
}
u(tf, "initialize");
var ef = /* @__PURE__ */ u((e, t = {}) => {
  const { code: r } = Zc(e);
  return Vl.fromText(r, t);
}, "getDiagramFromText");
function rf(e, t, r, i) {
  Xg(t, e), Kg(t, r, i, t.attr("id"));
}
u(rf, "addA11yInfo");
var ss = Object.freeze({
  render: qk,
  parse: Jg,
  getDiagramFromText: ef,
  initialize: tf,
  getConfig: fe,
  setConfig: Bd,
  getSiteConfig: Ld,
  updateSiteConfig: wx,
  reset: /* @__PURE__ */ u(() => {
    Yn();
  }, "reset"),
  globalReset: /* @__PURE__ */ u(() => {
    Yn(pa);
  }, "globalReset"),
  defaultConfig: pa
});
Tc(fe().logLevel);
Yn(fe());
var Yk = /* @__PURE__ */ u((e, t, r) => {
  I.warn(e), Uc(e) ? (r && r(e.str, e.hash), t.push({ ...e, message: e.str, error: e })) : (r && r(e), e instanceof Error && t.push({
    str: e.message,
    message: e.message,
    hash: e.name,
    error: e
  }));
}, "handleError"), sf = /* @__PURE__ */ u(async function(e = {
  querySelector: ".mermaid"
}) {
  try {
    await Hk(e);
  } catch (t) {
    if (Uc(t) && I.error(t.str), Tr.parseError && Tr.parseError(t), !e.suppressErrors)
      throw I.error("Use the suppressErrors option to suppress these errors"), t;
  }
}, "run"), Hk = /* @__PURE__ */ u(async function({ postRenderCallback: e, querySelector: t, nodes: r } = {
  querySelector: ".mermaid"
}) {
  const i = ss.getConfig();
  I.debug(`${e ? "" : "No "}Callback function found`);
  let s;
  if (r)
    s = r;
  else if (t)
    s = document.querySelectorAll(t);
  else
    throw new Error("Nodes and querySelector are both undefined");
  I.debug(`Found ${s.length} diagrams`), (i == null ? void 0 : i.startOnLoad) !== void 0 && (I.debug("Start On Load: " + (i == null ? void 0 : i.startOnLoad)), ss.updateSiteConfig({ startOnLoad: i == null ? void 0 : i.startOnLoad }));
  const a = new ee.InitIDGenerator(i.deterministicIds, i.deterministicIDSeed);
  let n;
  const o = [];
  for (const h of Array.from(s)) {
    if (I.info("Rendering diagram: " + h.id), h.getAttribute("data-processed"))
      continue;
    h.setAttribute("data-processed", "true");
    const l = `mermaid-${a.next()}`;
    n = h.innerHTML, n = vd(ee.entityDecode(n)).trim().replace(/<br\s*\/?>/gi, "<br/>");
    const d = ee.detectInit(n);
    d && I.debug("Detected early reinit: ", d);
    try {
      const { svg: p, bindFunctions: g } = await lf(l, n, h);
      h.innerHTML = p, e && await e(l), g && g(h);
    } catch (p) {
      Yk(p, o, Tr.parseError);
    }
  }
  if (o.length > 0)
    throw o[0];
}, "runThrowsErrors"), af = /* @__PURE__ */ u(function(e) {
  ss.initialize(e);
}, "initialize"), Uk = /* @__PURE__ */ u(async function(e, t, r) {
  I.warn("mermaid.init is deprecated. Please use run instead."), e && af(e);
  const i = { postRenderCallback: r, querySelector: ".mermaid" };
  typeof t == "string" ? i.querySelector = t : t && (t instanceof HTMLElement ? i.nodes = [t] : i.nodes = t), await sf(i);
}, "init"), jk = /* @__PURE__ */ u(async (e, {
  lazyLoad: t = !0
} = {}) => {
  Po(), pl(...e), t === !1 && await yk();
}, "registerExternalDiagrams"), nf = /* @__PURE__ */ u(function() {
  if (Tr.startOnLoad) {
    const { startOnLoad: e } = ss.getConfig();
    e && Tr.run().catch((t) => I.error("Mermaid failed to initialize", t));
  }
}, "contentLoaded");
typeof document < "u" && window.addEventListener("load", nf, !1);
var Gk = /* @__PURE__ */ u(function(e) {
  Tr.parseError = e;
}, "setParseErrorHandler"), ro = [], al = !1, of = /* @__PURE__ */ u(async () => {
  if (!al) {
    for (al = !0; ro.length > 0; ) {
      const e = ro.shift();
      if (e)
        try {
          await e();
        } catch (t) {
          I.error("Error executing queue", t);
        }
    }
    al = !1;
  }
}, "executeQueue"), Xk = /* @__PURE__ */ u(async (e, t) => new Promise((r, i) => {
  const s = /* @__PURE__ */ u(() => new Promise((a, n) => {
    ss.parse(e, t).then(
      (o) => {
        a(o), r(o);
      },
      (o) => {
        var h;
        I.error("Error parsing", o), (h = Tr.parseError) == null || h.call(Tr, o), n(o), i(o);
      }
    );
  }), "performCall");
  ro.push(s), of().catch(i);
}), "parse"), lf = /* @__PURE__ */ u((e, t, r) => new Promise((i, s) => {
  const a = /* @__PURE__ */ u(() => new Promise((n, o) => {
    ss.render(e, t, r).then(
      (h) => {
        n(h), i(h);
      },
      (h) => {
        var l;
        I.error("Error parsing", h), (l = Tr.parseError) == null || l.call(Tr, h), o(h), s(h);
      }
    );
  }), "performCall");
  ro.push(a), of().catch(s);
}), "render"), Kk = /* @__PURE__ */ u(() => Object.keys(es).map((e) => ({
  id: e
})), "getRegisteredDiagramsMetadata"), Tr = {
  startOnLoad: !0,
  mermaidAPI: ss,
  parse: Xk,
  render: lf,
  init: Uk,
  run: sf,
  registerExternalDiagrams: jk,
  registerLayoutLoaders: kg,
  initialize: af,
  parseError: void 0,
  contentLoaded: nf,
  setParseErrorHandler: Gk,
  detectType: _c,
  registerIconPacks: F0,
  getRegisteredDiagramsMetadata: Kk
}, y9 = Tr;
/*! Check if previously processed */
/*!
 * Wait for document loaded before starting the execution
 */
var le = /* @__PURE__ */ new Map(), Ki = /* @__PURE__ */ new Map(), cf = /* @__PURE__ */ new Map(), Qk = /* @__PURE__ */ u(() => {
  Ki.clear(), cf.clear(), le.clear();
}, "clear"), io = /* @__PURE__ */ u((e, t) => {
  const r = Ki.get(t) || [];
  return I.trace("In isDescendant", t, " ", e, " = ", r.includes(e)), r.includes(e);
}, "isDescendant"), Zk = /* @__PURE__ */ u((e, t) => {
  const r = Ki.get(t) || [];
  return I.info("Descendants of ", t, " is ", r), I.info("Edge is ", e), e.v === t || e.w === t ? !1 : r ? r.includes(e.v) || io(e.v, t) || io(e.w, t) || r.includes(e.w) : (I.debug("Tilt, ", t, ",not in descendants"), !1);
}, "edgeInCluster"), hf = /* @__PURE__ */ u((e, t, r, i) => {
  I.warn(
    "Copying children of ",
    e,
    "root",
    i,
    "data",
    t.node(e),
    i
  );
  const s = t.children(e) || [];
  e !== i && s.push(e), I.warn("Copying (nodes) clusterId", e, "nodes", s), s.forEach((a) => {
    if (t.children(a).length > 0)
      hf(a, t, r, i);
    else {
      const n = t.node(a);
      I.info("cp ", a, " to ", i, " with parent ", e), r.setNode(a, n), i !== t.parent(a) && (I.warn("Setting parent", a, t.parent(a)), r.setParent(a, t.parent(a))), e !== i && a !== e ? (I.debug("Setting parent", a, e), r.setParent(a, e)) : (I.info("In copy ", e, "root", i, "data", t.node(e), i), I.debug(
        "Not Setting parent for node=",
        a,
        "cluster!==rootId",
        e !== i,
        "node!==clusterId",
        a !== e
      ));
      const o = t.edges(a);
      I.debug("Copying Edges", o), o.forEach((h) => {
        I.info("Edge", h);
        const l = t.edge(h.v, h.w, h.name);
        I.info("Edge data", l, i);
        try {
          Zk(h, i) ? (I.info("Copying as ", h.v, h.w, l, h.name), r.setEdge(h.v, h.w, l, h.name), I.info("newGraph edges ", r.edges(), r.edge(r.edges()[0]))) : I.info(
            "Skipping copy of edge ",
            h.v,
            "-->",
            h.w,
            " rootId: ",
            i,
            " clusterId:",
            e
          );
        } catch (d) {
          I.error(d);
        }
      });
    }
    I.debug("Removing node", a), t.removeNode(a);
  });
}, "copy"), uf = /* @__PURE__ */ u((e, t) => {
  const r = t.children(e);
  let i = [...r];
  for (const s of r)
    cf.set(s, e), i = [...i, ...uf(s, t)];
  return i;
}, "extractDescendants"), Jk = /* @__PURE__ */ u((e, t, r) => {
  const i = e.edges().filter((h) => h.v === t || h.w === t), s = e.edges().filter((h) => h.v === r || h.w === r), a = i.map((h) => ({ v: h.v === t ? r : h.v, w: h.w === t ? t : h.w })), n = s.map((h) => ({ v: h.v, w: h.w }));
  return a.filter((h) => n.some((l) => h.v === l.v && h.w === l.w));
}, "findCommonEdges"), Ja = /* @__PURE__ */ u((e, t, r) => {
  const i = t.children(e);
  if (I.trace("Searching children of id ", e, i), i.length < 1)
    return e;
  let s;
  for (const a of i) {
    const n = Ja(a, t, r), o = Jk(t, r, n);
    if (n)
      if (o.length > 0)
        s = n;
      else
        return n;
  }
  return s;
}, "findNonClusterChild"), bu = /* @__PURE__ */ u((e) => !le.has(e) || !le.get(e).externalConnections ? e : le.has(e) ? le.get(e).id : e, "getAnchorId"), t6 = /* @__PURE__ */ u((e, t) => {
  if (!e || t > 10) {
    I.debug("Opting out, no graph ");
    return;
  } else
    I.debug("Opting in, graph ");
  e.nodes().forEach(function(r) {
    e.children(r).length > 0 && (I.warn(
      "Cluster identified",
      r,
      " Replacement id in edges: ",
      Ja(r, e, r)
    ), Ki.set(r, uf(r, e)), le.set(r, { id: Ja(r, e, r), clusterData: e.node(r) }));
  }), e.nodes().forEach(function(r) {
    const i = e.children(r), s = e.edges();
    i.length > 0 ? (I.debug("Cluster identified", r, Ki), s.forEach((a) => {
      const n = io(a.v, r), o = io(a.w, r);
      n ^ o && (I.warn("Edge: ", a, " leaves cluster ", r), I.warn("Descendants of XXX ", r, ": ", Ki.get(r)), le.get(r).externalConnections = !0);
    })) : I.debug("Not a cluster ", r, Ki);
  });
  for (let r of le.keys()) {
    const i = le.get(r).id, s = e.parent(i);
    s !== r && le.has(s) && !le.get(s).externalConnections && (le.get(r).id = s);
  }
  e.edges().forEach(function(r) {
    const i = e.edge(r);
    I.warn("Edge " + r.v + " -> " + r.w + ": " + JSON.stringify(r)), I.warn("Edge " + r.v + " -> " + r.w + ": " + JSON.stringify(e.edge(r)));
    let s = r.v, a = r.w;
    if (I.warn(
      "Fix XXX",
      le,
      "ids:",
      r.v,
      r.w,
      "Translating: ",
      le.get(r.v),
      " --- ",
      le.get(r.w)
    ), le.get(r.v) || le.get(r.w)) {
      if (I.warn("Fixing and trying - removing XXX", r.v, r.w, r.name), s = bu(r.v), a = bu(r.w), e.removeEdge(r.v, r.w, r.name), s !== r.v) {
        const n = e.parent(s);
        le.get(n).externalConnections = !0, i.fromCluster = r.v;
      }
      if (a !== r.w) {
        const n = e.parent(a);
        le.get(n).externalConnections = !0, i.toCluster = r.w;
      }
      I.warn("Fix Replacing with XXX", s, a, r.name), e.setEdge(s, a, i, r.name);
    }
  }), I.warn("Adjusted Graph", Gr(e)), df(e, 0), I.trace(le);
}, "adjustClustersAndEdges"), df = /* @__PURE__ */ u((e, t) => {
  var s, a;
  if (I.warn("extractor - ", t, Gr(e), e.children("D")), t > 10) {
    I.error("Bailing out");
    return;
  }
  let r = e.nodes(), i = !1;
  for (const n of r) {
    const o = e.children(n);
    i = i || o.length > 0;
  }
  if (!i) {
    I.debug("Done, no node has children", e.nodes());
    return;
  }
  I.debug("Nodes = ", r, t);
  for (const n of r)
    if (I.debug(
      "Extracting node",
      n,
      le,
      le.has(n) && !le.get(n).externalConnections,
      !e.parent(n),
      e.node(n),
      e.children("D"),
      " Depth ",
      t
    ), !le.has(n))
      I.debug("Not a cluster", n, t);
    else if (!le.get(n).externalConnections && e.children(n) && e.children(n).length > 0) {
      I.warn(
        "Cluster without external connections, without a parent and with children",
        n,
        t
      );
      let h = e.graph().rankdir === "TB" ? "LR" : "TB";
      (a = (s = le.get(n)) == null ? void 0 : s.clusterData) != null && a.dir && (h = le.get(n).clusterData.dir, I.warn("Fixing dir", le.get(n).clusterData.dir, h));
      const l = new vo({
        multigraph: !0,
        compound: !0
      }).setGraph({
        rankdir: h,
        nodesep: 50,
        ranksep: 50,
        marginx: 8,
        marginy: 8
      }).setDefaultEdgeLabel(function() {
        return {};
      });
      I.warn("Old graph before copy", Gr(e)), hf(n, e, l, n), e.setNode(n, {
        clusterNode: !0,
        id: n,
        clusterData: le.get(n).clusterData,
        label: le.get(n).label,
        graph: l
      }), I.warn("New graph after copy node: (", n, ")", Gr(l)), I.debug("Old graph after copy", Gr(e));
    } else
      I.warn(
        "Cluster ** ",
        n,
        " **not meeting the criteria !externalConnections:",
        !le.get(n).externalConnections,
        " no parent: ",
        !e.parent(n),
        " children ",
        e.children(n) && e.children(n).length > 0,
        e.children("D"),
        t
      ), I.debug(le);
  r = e.nodes(), I.warn("New list of nodes", r);
  for (const n of r) {
    const o = e.node(n);
    I.warn(" Now next level", n, o), o != null && o.clusterNode && df(o.graph, t + 1);
  }
}, "extractor"), pf = /* @__PURE__ */ u((e, t) => {
  if (t.length === 0)
    return [];
  let r = Object.assign([], t);
  return t.forEach((i) => {
    const s = e.children(i), a = pf(e, s);
    r = [...r, ...a];
  }), r;
}, "sorter"), e6 = /* @__PURE__ */ u((e) => pf(e, e.children()), "sortNodesByHierarchy"), gf = /* @__PURE__ */ u(async (e, t, r, i, s, a) => {
  I.warn("Graph in recursive render:XAX", Gr(t), s);
  const n = t.graph().rankdir;
  I.trace("Dir in recursive render - dir:", n);
  const o = e.insert("g").attr("class", "root");
  t.nodes() ? I.info("Recursive render XXX", t.nodes()) : I.info("No nodes found for", t), t.edges().length > 0 && I.info("Recursive edges", t.edge(t.edges()[0]));
  const h = o.insert("g").attr("class", "clusters"), l = o.insert("g").attr("class", "edgePaths"), d = o.insert("g").attr("class", "edgeLabels"), p = o.insert("g").attr("class", "nodes");
  await Promise.all(
    t.nodes().map(async function(m) {
      const x = t.node(m);
      if (s !== void 0) {
        const b = JSON.parse(JSON.stringify(s.clusterData));
        I.trace(
          `Setting data for parent cluster XXX
 Node.id = `,
          m,
          `
 data=`,
          b.height,
          `
Parent cluster`,
          s.height
        ), t.setNode(s.id, b), t.parent(m) || (I.trace("Setting parent", m, s.id), t.setParent(m, s.id, b));
      }
      if (I.info("(Insert) Node XXX" + m + ": " + JSON.stringify(t.node(m))), x != null && x.clusterNode) {
        I.info("Cluster identified XBX", m, x.width, t.node(m));
        const { ranksep: b, nodesep: v } = t.graph();
        x.graph.setGraph({
          ...x.graph.graph(),
          ranksep: b + 25,
          nodesep: v
        });
        const _ = await gf(
          p,
          x.graph,
          r,
          i,
          t.node(m),
          a
        ), A = _.elem;
        Pt(x, A), x.diff = _.diff || 0, I.info(
          "New compound node after recursive render XAX",
          m,
          "width",
          // node,
          x.width,
          "height",
          x.height
          // node.x,
          // node.y
        ), q3(A, x);
      } else
        t.children(m).length > 0 ? (I.trace(
          "Cluster - the non recursive path XBX",
          m,
          x.id,
          x,
          x.width,
          "Graph:",
          t
        ), I.trace(Ja(x.id, t)), le.set(x.id, { id: Ja(x.id, t), node: x })) : (I.trace("Node - the non recursive path XAX", m, p, t.node(m), n), await Oo(p, t.node(m), { config: a, dir: n }));
    })
  ), await (/* @__PURE__ */ u(async () => {
    const m = t.edges().map(async function(x) {
      const b = t.edge(x.v, x.w, x.name);
      I.info("Edge " + x.v + " -> " + x.w + ": " + JSON.stringify(x)), I.info("Edge " + x.v + " -> " + x.w + ": ", x, " ", JSON.stringify(t.edge(x))), I.info(
        "Fix",
        le,
        "ids:",
        x.v,
        x.w,
        "Translating: ",
        le.get(x.v),
        le.get(x.w)
      ), await pg(d, b);
    });
    await Promise.all(m);
  }, "processEdges"))(), I.info("Graph before layout:", JSON.stringify(Gr(t))), I.info("############################################# XXX"), I.info("###                Layout                 ### XXX"), I.info("############################################# XXX"), Sd(t), I.info("Graph after layout:", JSON.stringify(Gr(t)));
  let f = 0, { subGraphTitleTotalMargin: y } = gn(a);
  return await Promise.all(
    e6(t).map(async function(m) {
      var b;
      const x = t.node(m);
      if (I.info(
        "Position XBX => " + m + ": (" + x.x,
        "," + x.y,
        ") width: ",
        x.width,
        " height: ",
        x.height
      ), x != null && x.clusterNode)
        x.y += y, I.info(
          "A tainted cluster node XBX1",
          m,
          x.id,
          x.width,
          x.height,
          x.x,
          x.y,
          t.parent(m)
        ), le.get(x.id).node = x, Pl(x);
      else if (t.children(m).length > 0) {
        I.info(
          "A pure cluster node XBX1",
          m,
          x.id,
          x.x,
          x.y,
          x.width,
          x.height,
          t.parent(m)
        ), x.height += y, t.node(x.parentId);
        const v = (x == null ? void 0 : x.padding) / 2 || 0, _ = ((b = x == null ? void 0 : x.labelBBox) == null ? void 0 : b.height) || 0, A = _ - v || 0;
        I.debug("OffsetY", A, "labelHeight", _, "halfPadding", v), await Xc(h, x), le.get(x.id).node = x;
      } else {
        const v = t.node(x.parentId);
        x.y += y / 2, I.info(
          "A regular node XBX1 - using the padding",
          x.id,
          "parent",
          x.parentId,
          x.width,
          x.height,
          x.x,
          x.y,
          "offsetY",
          x.offsetY,
          "parent",
          v,
          v == null ? void 0 : v.offsetY,
          x
        ), Pl(x);
      }
    })
  ), t.edges().forEach(function(m) {
    const x = t.edge(m);
    I.info("Edge " + m.v + " -> " + m.w + ": " + JSON.stringify(x), x), x.points.forEach((A) => A.y += y / 2);
    const b = t.node(m.v);
    var v = t.node(m.w);
    const _ = yg(l, x, le, r, b, v, i);
    gg(x, _);
  }), t.nodes().forEach(function(m) {
    const x = t.node(m);
    I.info(m, x.type, x.diff), x.isGroup && (f = x.diff);
  }), I.warn("Returning from recursive render XAX", o, f), { elem: o, diff: f };
}, "recursiveRender"), r6 = /* @__PURE__ */ u(async (e, t) => {
  var a, n, o, h, l, d;
  const r = new vo({
    multigraph: !0,
    compound: !0
  }).setGraph({
    rankdir: e.direction,
    nodesep: ((a = e.config) == null ? void 0 : a.nodeSpacing) || ((o = (n = e.config) == null ? void 0 : n.flowchart) == null ? void 0 : o.nodeSpacing) || e.nodeSpacing,
    ranksep: ((h = e.config) == null ? void 0 : h.rankSpacing) || ((d = (l = e.config) == null ? void 0 : l.flowchart) == null ? void 0 : d.rankSpacing) || e.rankSpacing,
    marginx: 8,
    marginy: 8
  }).setDefaultEdgeLabel(function() {
    return {};
  }), i = t.select("g");
  bg(i, e.markers, e.type, e.diagramId), Y3(), j3(), T3(), Qk(), e.nodes.forEach((p) => {
    r.setNode(p.id, { ...p }), p.parentId && r.setParent(p.id, p.parentId);
  }), I.debug("Edges:", e.edges), e.edges.forEach((p) => {
    if (p.start === p.end) {
      const g = p.start, f = g + "---" + g + "---1", y = g + "---" + g + "---2", m = r.node(g);
      r.setNode(f, {
        domId: f,
        id: f,
        parentId: m.parentId,
        labelStyle: "",
        label: "",
        padding: 0,
        shape: "labelRect",
        // shape: 'rect',
        style: "",
        width: 10,
        height: 10
      }), r.setParent(f, m.parentId), r.setNode(y, {
        domId: y,
        id: y,
        parentId: m.parentId,
        labelStyle: "",
        padding: 0,
        // shape: 'rect',
        shape: "labelRect",
        label: "",
        style: "",
        width: 10,
        height: 10
      }), r.setParent(y, m.parentId);
      const x = structuredClone(p), b = structuredClone(p), v = structuredClone(p);
      x.label = "", x.arrowTypeEnd = "none", x.id = g + "-cyclic-special-1", b.arrowTypeStart = "none", b.arrowTypeEnd = "none", b.id = g + "-cyclic-special-mid", v.label = "", m.isGroup && (x.fromCluster = g, v.toCluster = g), v.id = g + "-cyclic-special-2", v.arrowTypeStart = "none", r.setEdge(g, f, x, g + "-cyclic-special-0"), r.setEdge(f, y, b, g + "-cyclic-special-1"), r.setEdge(y, g, v, g + "-cyc<lic-special-2");
    } else
      r.setEdge(p.start, p.end, { ...p }, p.id);
  }), I.warn("Graph at first:", JSON.stringify(Gr(r))), t6(r), I.warn("Graph after XAX:", JSON.stringify(Gr(r)));
  const s = K();
  await gf(
    i,
    r,
    e.type,
    e.diagramId,
    void 0,
    s
  );
}, "render");
const i6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  render: r6
}, Symbol.toStringTag, { value: "Module" }));
So.use(Fm);
function ff(e, t) {
  e.forEach((r) => {
    const i = {
      id: r.id,
      labelText: r.label,
      height: r.height,
      width: r.width,
      padding: r.padding ?? 0
    };
    Object.keys(r).forEach((s) => {
      ["id", "label", "height", "width", "padding", "x", "y"].includes(s) || (i[s] = r[s]);
    }), t.add({
      group: "nodes",
      data: i,
      position: {
        x: r.x ?? 0,
        y: r.y ?? 0
      }
    });
  });
}
u(ff, "addNodes");
function yf(e, t) {
  e.forEach((r) => {
    const i = {
      id: r.id,
      source: r.start,
      target: r.end
    };
    Object.keys(r).forEach((s) => {
      ["id", "start", "end"].includes(s) || (i[s] = r[s]);
    }), t.add({
      group: "edges",
      data: i
    });
  });
}
u(yf, "addEdges");
function mf(e) {
  return new Promise((t) => {
    const r = yt("body").append("div").attr("id", "cy").attr("style", "display:none"), i = So({
      container: document.getElementById("cy"),
      // container to render in
      style: [
        {
          selector: "edge",
          style: {
            "curve-style": "bezier"
          }
        }
      ]
    });
    r.remove(), ff(e.nodes, i), yf(e.edges, i), i.nodes().forEach(function(a) {
      a.layoutDimensions = () => {
        const n = a.data();
        return { w: n.width, h: n.height };
      };
    });
    const s = {
      name: "cose-bilkent",
      // @ts-ignore Types for cose-bilkent are not correct?
      quality: "proof",
      styleEnabled: !1,
      animate: !1
    };
    i.layout(s).run(), i.ready((a) => {
      I.info("Cytoscape ready", a), t(i);
    });
  });
}
u(mf, "createCytoscapeInstance");
function xf(e) {
  return e.nodes().map((t) => {
    const r = t.data(), i = t.position(), s = {
      id: r.id,
      x: i.x,
      y: i.y
    };
    return Object.keys(r).forEach((a) => {
      a !== "id" && (s[a] = r[a]);
    }), s;
  });
}
u(xf, "extractPositionedNodes");
function bf(e) {
  return e.edges().map((t) => {
    const r = t.data(), i = t._private.rscratch, s = {
      id: r.id,
      source: r.source,
      target: r.target,
      startX: i.startX,
      startY: i.startY,
      midX: i.midX,
      midY: i.midY,
      endX: i.endX,
      endY: i.endY
    };
    return Object.keys(r).forEach((a) => {
      ["id", "source", "target"].includes(a) || (s[a] = r[a]);
    }), s;
  });
}
u(bf, "extractPositionedEdges");
async function kf(e, t) {
  I.debug("Starting cose-bilkent layout algorithm");
  try {
    vf(e);
    const r = await mf(e), i = xf(r), s = bf(r);
    return I.debug(`Layout completed: ${i.length} nodes, ${s.length} edges`), {
      nodes: i,
      edges: s
    };
  } catch (r) {
    throw I.error("Error in cose-bilkent layout algorithm:", r), r;
  }
}
u(kf, "executeCoseBilkentLayout");
function vf(e) {
  if (!e)
    throw new Error("Layout data is required");
  if (!e.config)
    throw new Error("Configuration is required in layout data");
  if (!e.rootNode)
    throw new Error("Root node is required");
  if (!e.nodes || !Array.isArray(e.nodes))
    throw new Error("No nodes found in layout data");
  if (!Array.isArray(e.edges))
    throw new Error("Edges array is required in layout data");
  return !0;
}
u(vf, "validateLayoutData");
var s6 = /* @__PURE__ */ u(async (e, t, {
  insertCluster: r,
  insertEdge: i,
  insertEdgeLabel: s,
  insertMarkers: a,
  insertNode: n,
  log: o,
  positionEdgeLabel: h
}, { algorithm: l }) => {
  const d = {}, p = {}, g = t.select("g");
  a(g, e.markers, e.type, e.diagramId);
  const f = g.insert("g").attr("class", "subgraphs"), y = g.insert("g").attr("class", "edgePaths"), m = g.insert("g").attr("class", "edgeLabels"), x = g.insert("g").attr("class", "nodes");
  o.debug("Inserting nodes into DOM for dimension calculation"), await Promise.all(
    e.nodes.map(async (_) => {
      if (_.isGroup) {
        const A = { ..._ };
        p[_.id] = A, d[_.id] = A, await r(f, _);
      } else {
        const A = { ..._ };
        d[_.id] = A;
        const S = await n(x, _, {
          config: e.config,
          dir: e.direction || "TB"
        }), k = S.node().getBBox();
        A.width = k.width, A.height = k.height, A.domId = S, o.debug(`Node ${_.id} dimensions: ${k.width}x${k.height}`);
      }
    })
  ), o.debug("Running cose-bilkent layout algorithm");
  const b = {
    ...e,
    nodes: e.nodes.map((_) => {
      const A = d[_.id];
      return {
        ..._,
        width: A.width,
        height: A.height
      };
    })
  }, v = await kf(b, e.config);
  o.debug("Positioning nodes based on layout results"), v.nodes.forEach((_) => {
    const A = d[_.id];
    A != null && A.domId && (A.domId.attr(
      "transform",
      `translate(${_.x}, ${_.y})`
    ), A.x = _.x, A.y = _.y, o.debug(`Positioned node ${A.id} at center (${_.x}, ${_.y})`));
  }), v.edges.forEach((_) => {
    const A = e.edges.find((S) => S.id === _.id);
    A && (A.points = [
      { x: _.startX, y: _.startY },
      { x: _.midX, y: _.midY },
      { x: _.endX, y: _.endY }
    ]);
  }), o.debug("Inserting and positioning edges"), await Promise.all(
    e.edges.map(async (_) => {
      await s(m, _);
      const A = d[_.start ?? ""], S = d[_.end ?? ""];
      if (A && S) {
        const k = v.edges.find((L) => L.id === _.id);
        if (k) {
          o.debug("APA01 positionedEdge", k);
          const L = { ..._ }, T = i(
            y,
            L,
            p,
            e.type,
            A,
            S,
            e.diagramId
          );
          h(L, T);
        } else {
          const L = {
            ..._,
            points: [
              { x: A.x || 0, y: A.y || 0 },
              { x: S.x || 0, y: S.y || 0 }
            ]
          }, T = i(
            y,
            L,
            p,
            e.type,
            A,
            S,
            e.diagramId
          );
          h(L, T);
        }
      }
    })
  ), o.debug("Cose-bilkent rendering completed");
}, "render"), a6 = s6;
const n6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  render: a6
}, Symbol.toStringTag, { value: "Module" }));
var $o = /* @__PURE__ */ u((e, t) => {
  const r = e.append("rect");
  if (r.attr("x", t.x), r.attr("y", t.y), r.attr("fill", t.fill), r.attr("stroke", t.stroke), r.attr("width", t.width), r.attr("height", t.height), t.name && r.attr("name", t.name), t.rx && r.attr("rx", t.rx), t.ry && r.attr("ry", t.ry), t.attrs !== void 0)
    for (const i in t.attrs)
      r.attr(i, t.attrs[i]);
  return t.class && r.attr("class", t.class), r;
}, "drawRect"), Sf = /* @__PURE__ */ u((e, t) => {
  const r = {
    x: t.startx,
    y: t.starty,
    width: t.stopx - t.startx,
    height: t.stopy - t.starty,
    fill: t.fill,
    stroke: t.stroke,
    class: "rect"
  };
  $o(e, r).lower();
}, "drawBackgroundRect"), o6 = /* @__PURE__ */ u((e, t) => {
  const r = t.text.replace(va, " "), i = e.append("text");
  i.attr("x", t.x), i.attr("y", t.y), i.attr("class", "legend"), i.style("text-anchor", t.anchor), t.class && i.attr("class", t.class);
  const s = i.append("tspan");
  return s.attr("x", t.x + t.textMargin * 2), s.text(r), i;
}, "drawText"), th = /* @__PURE__ */ u((e, t, r, i) => {
  const s = e.append("image");
  s.attr("x", t), s.attr("y", r);
  const a = ns(i);
  s.attr("xlink:href", a);
}, "drawImage"), eh = /* @__PURE__ */ u((e, t, r, i) => {
  const s = e.append("use");
  s.attr("x", t), s.attr("y", r);
  const a = ns(i);
  s.attr("xlink:href", `#${a}`);
}, "drawEmbeddedImage"), Er = /* @__PURE__ */ u(() => ({
  x: 0,
  y: 0,
  width: 100,
  height: 100,
  fill: "#EDF2AE",
  stroke: "#666",
  anchor: "start",
  rx: 0,
  ry: 0
}), "getNoteRect"), rh = /* @__PURE__ */ u(() => ({
  x: 0,
  y: 0,
  width: 100,
  height: 100,
  "text-anchor": "start",
  style: "#666",
  textMargin: 0,
  rx: 0,
  ry: 0,
  tspan: !0
}), "getTextObj"), so = function() {
  var e = /* @__PURE__ */ u(function(ie, dt, wt, nt) {
    for (wt = wt || {}, nt = ie.length; nt--; wt[ie[nt]] = dt) ;
    return wt;
  }, "o"), t = [1, 24], r = [1, 25], i = [1, 26], s = [1, 27], a = [1, 28], n = [1, 63], o = [1, 64], h = [1, 65], l = [1, 66], d = [1, 67], p = [1, 68], g = [1, 69], f = [1, 29], y = [1, 30], m = [1, 31], x = [1, 32], b = [1, 33], v = [1, 34], _ = [1, 35], A = [1, 36], S = [1, 37], k = [1, 38], L = [1, 39], T = [1, 40], C = [1, 41], E = [1, 42], w = [1, 43], W = [1, 44], N = [1, 45], B = [1, 46], R = [1, 47], V = [1, 48], $ = [1, 50], D = [1, 51], O = [1, 52], Y = [1, 53], M = [1, 54], G = [1, 55], rt = [1, 56], ht = [1, 57], Z = [1, 58], ot = [1, 59], it = [1, 60], bt = [14, 42], xt = [14, 34, 36, 37, 38, 39, 40, 41, 42, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74], Ct = [12, 14, 34, 36, 37, 38, 39, 40, 41, 42, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74], at = [1, 82], lt = [1, 83], Q = [1, 84], U = [1, 85], et = [12, 14, 42], z = [12, 14, 33, 42], Tt = [12, 14, 33, 42, 76, 77, 79, 80], F = [12, 33], te = [34, 36, 37, 38, 39, 40, 41, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74], J = {
    trace: /* @__PURE__ */ u(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, start: 3, mermaidDoc: 4, direction: 5, direction_tb: 6, direction_bt: 7, direction_rl: 8, direction_lr: 9, graphConfig: 10, C4_CONTEXT: 11, NEWLINE: 12, statements: 13, EOF: 14, C4_CONTAINER: 15, C4_COMPONENT: 16, C4_DYNAMIC: 17, C4_DEPLOYMENT: 18, otherStatements: 19, diagramStatements: 20, otherStatement: 21, title: 22, accDescription: 23, acc_title: 24, acc_title_value: 25, acc_descr: 26, acc_descr_value: 27, acc_descr_multiline_value: 28, boundaryStatement: 29, boundaryStartStatement: 30, boundaryStopStatement: 31, boundaryStart: 32, LBRACE: 33, ENTERPRISE_BOUNDARY: 34, attributes: 35, SYSTEM_BOUNDARY: 36, BOUNDARY: 37, CONTAINER_BOUNDARY: 38, NODE: 39, NODE_L: 40, NODE_R: 41, RBRACE: 42, diagramStatement: 43, PERSON: 44, PERSON_EXT: 45, SYSTEM: 46, SYSTEM_DB: 47, SYSTEM_QUEUE: 48, SYSTEM_EXT: 49, SYSTEM_EXT_DB: 50, SYSTEM_EXT_QUEUE: 51, CONTAINER: 52, CONTAINER_DB: 53, CONTAINER_QUEUE: 54, CONTAINER_EXT: 55, CONTAINER_EXT_DB: 56, CONTAINER_EXT_QUEUE: 57, COMPONENT: 58, COMPONENT_DB: 59, COMPONENT_QUEUE: 60, COMPONENT_EXT: 61, COMPONENT_EXT_DB: 62, COMPONENT_EXT_QUEUE: 63, REL: 64, BIREL: 65, REL_U: 66, REL_D: 67, REL_L: 68, REL_R: 69, REL_B: 70, REL_INDEX: 71, UPDATE_EL_STYLE: 72, UPDATE_REL_STYLE: 73, UPDATE_LAYOUT_CONFIG: 74, attribute: 75, STR: 76, STR_KEY: 77, STR_VALUE: 78, ATTRIBUTE: 79, ATTRIBUTE_EMPTY: 80, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 6: "direction_tb", 7: "direction_bt", 8: "direction_rl", 9: "direction_lr", 11: "C4_CONTEXT", 12: "NEWLINE", 14: "EOF", 15: "C4_CONTAINER", 16: "C4_COMPONENT", 17: "C4_DYNAMIC", 18: "C4_DEPLOYMENT", 22: "title", 23: "accDescription", 24: "acc_title", 25: "acc_title_value", 26: "acc_descr", 27: "acc_descr_value", 28: "acc_descr_multiline_value", 33: "LBRACE", 34: "ENTERPRISE_BOUNDARY", 36: "SYSTEM_BOUNDARY", 37: "BOUNDARY", 38: "CONTAINER_BOUNDARY", 39: "NODE", 40: "NODE_L", 41: "NODE_R", 42: "RBRACE", 44: "PERSON", 45: "PERSON_EXT", 46: "SYSTEM", 47: "SYSTEM_DB", 48: "SYSTEM_QUEUE", 49: "SYSTEM_EXT", 50: "SYSTEM_EXT_DB", 51: "SYSTEM_EXT_QUEUE", 52: "CONTAINER", 53: "CONTAINER_DB", 54: "CONTAINER_QUEUE", 55: "CONTAINER_EXT", 56: "CONTAINER_EXT_DB", 57: "CONTAINER_EXT_QUEUE", 58: "COMPONENT", 59: "COMPONENT_DB", 60: "COMPONENT_QUEUE", 61: "COMPONENT_EXT", 62: "COMPONENT_EXT_DB", 63: "COMPONENT_EXT_QUEUE", 64: "REL", 65: "BIREL", 66: "REL_U", 67: "REL_D", 68: "REL_L", 69: "REL_R", 70: "REL_B", 71: "REL_INDEX", 72: "UPDATE_EL_STYLE", 73: "UPDATE_REL_STYLE", 74: "UPDATE_LAYOUT_CONFIG", 76: "STR", 77: "STR_KEY", 78: "STR_VALUE", 79: "ATTRIBUTE", 80: "ATTRIBUTE_EMPTY" },
    productions_: [0, [3, 1], [3, 1], [5, 1], [5, 1], [5, 1], [5, 1], [4, 1], [10, 4], [10, 4], [10, 4], [10, 4], [10, 4], [13, 1], [13, 1], [13, 2], [19, 1], [19, 2], [19, 3], [21, 1], [21, 1], [21, 2], [21, 2], [21, 1], [29, 3], [30, 3], [30, 3], [30, 4], [32, 2], [32, 2], [32, 2], [32, 2], [32, 2], [32, 2], [32, 2], [31, 1], [20, 1], [20, 2], [20, 3], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 1], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [43, 2], [35, 1], [35, 2], [75, 1], [75, 2], [75, 1], [75, 1]],
    performAction: /* @__PURE__ */ u(function(dt, wt, nt, ut, kt, X, ft) {
      var P = X.length - 1;
      switch (kt) {
        case 3:
          ut.setDirection("TB");
          break;
        case 4:
          ut.setDirection("BT");
          break;
        case 5:
          ut.setDirection("RL");
          break;
        case 6:
          ut.setDirection("LR");
          break;
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
          ut.setC4Type(X[P - 3]);
          break;
        case 19:
          ut.setTitle(X[P].substring(6)), this.$ = X[P].substring(6);
          break;
        case 20:
          ut.setAccDescription(X[P].substring(15)), this.$ = X[P].substring(15);
          break;
        case 21:
          this.$ = X[P].trim(), ut.setTitle(this.$);
          break;
        case 22:
        case 23:
          this.$ = X[P].trim(), ut.setAccDescription(this.$);
          break;
        case 28:
          X[P].splice(2, 0, "ENTERPRISE"), ut.addPersonOrSystemBoundary(...X[P]), this.$ = X[P];
          break;
        case 29:
          X[P].splice(2, 0, "SYSTEM"), ut.addPersonOrSystemBoundary(...X[P]), this.$ = X[P];
          break;
        case 30:
          ut.addPersonOrSystemBoundary(...X[P]), this.$ = X[P];
          break;
        case 31:
          X[P].splice(2, 0, "CONTAINER"), ut.addContainerBoundary(...X[P]), this.$ = X[P];
          break;
        case 32:
          ut.addDeploymentNode("node", ...X[P]), this.$ = X[P];
          break;
        case 33:
          ut.addDeploymentNode("nodeL", ...X[P]), this.$ = X[P];
          break;
        case 34:
          ut.addDeploymentNode("nodeR", ...X[P]), this.$ = X[P];
          break;
        case 35:
          ut.popBoundaryParseStack();
          break;
        case 39:
          ut.addPersonOrSystem("person", ...X[P]), this.$ = X[P];
          break;
        case 40:
          ut.addPersonOrSystem("external_person", ...X[P]), this.$ = X[P];
          break;
        case 41:
          ut.addPersonOrSystem("system", ...X[P]), this.$ = X[P];
          break;
        case 42:
          ut.addPersonOrSystem("system_db", ...X[P]), this.$ = X[P];
          break;
        case 43:
          ut.addPersonOrSystem("system_queue", ...X[P]), this.$ = X[P];
          break;
        case 44:
          ut.addPersonOrSystem("external_system", ...X[P]), this.$ = X[P];
          break;
        case 45:
          ut.addPersonOrSystem("external_system_db", ...X[P]), this.$ = X[P];
          break;
        case 46:
          ut.addPersonOrSystem("external_system_queue", ...X[P]), this.$ = X[P];
          break;
        case 47:
          ut.addContainer("container", ...X[P]), this.$ = X[P];
          break;
        case 48:
          ut.addContainer("container_db", ...X[P]), this.$ = X[P];
          break;
        case 49:
          ut.addContainer("container_queue", ...X[P]), this.$ = X[P];
          break;
        case 50:
          ut.addContainer("external_container", ...X[P]), this.$ = X[P];
          break;
        case 51:
          ut.addContainer("external_container_db", ...X[P]), this.$ = X[P];
          break;
        case 52:
          ut.addContainer("external_container_queue", ...X[P]), this.$ = X[P];
          break;
        case 53:
          ut.addComponent("component", ...X[P]), this.$ = X[P];
          break;
        case 54:
          ut.addComponent("component_db", ...X[P]), this.$ = X[P];
          break;
        case 55:
          ut.addComponent("component_queue", ...X[P]), this.$ = X[P];
          break;
        case 56:
          ut.addComponent("external_component", ...X[P]), this.$ = X[P];
          break;
        case 57:
          ut.addComponent("external_component_db", ...X[P]), this.$ = X[P];
          break;
        case 58:
          ut.addComponent("external_component_queue", ...X[P]), this.$ = X[P];
          break;
        case 60:
          ut.addRel("rel", ...X[P]), this.$ = X[P];
          break;
        case 61:
          ut.addRel("birel", ...X[P]), this.$ = X[P];
          break;
        case 62:
          ut.addRel("rel_u", ...X[P]), this.$ = X[P];
          break;
        case 63:
          ut.addRel("rel_d", ...X[P]), this.$ = X[P];
          break;
        case 64:
          ut.addRel("rel_l", ...X[P]), this.$ = X[P];
          break;
        case 65:
          ut.addRel("rel_r", ...X[P]), this.$ = X[P];
          break;
        case 66:
          ut.addRel("rel_b", ...X[P]), this.$ = X[P];
          break;
        case 67:
          X[P].splice(0, 1), ut.addRel("rel", ...X[P]), this.$ = X[P];
          break;
        case 68:
          ut.updateElStyle("update_el_style", ...X[P]), this.$ = X[P];
          break;
        case 69:
          ut.updateRelStyle("update_rel_style", ...X[P]), this.$ = X[P];
          break;
        case 70:
          ut.updateLayoutConfig("update_layout_config", ...X[P]), this.$ = X[P];
          break;
        case 71:
          this.$ = [X[P]];
          break;
        case 72:
          X[P].unshift(X[P - 1]), this.$ = X[P];
          break;
        case 73:
        case 75:
          this.$ = X[P].trim();
          break;
        case 74:
          let At = {};
          At[X[P - 1].trim()] = X[P].trim(), this.$ = At;
          break;
        case 76:
          this.$ = "";
          break;
      }
    }, "anonymous"),
    table: [{ 3: 1, 4: 2, 5: 3, 6: [1, 5], 7: [1, 6], 8: [1, 7], 9: [1, 8], 10: 4, 11: [1, 9], 15: [1, 10], 16: [1, 11], 17: [1, 12], 18: [1, 13] }, { 1: [3] }, { 1: [2, 1] }, { 1: [2, 2] }, { 1: [2, 7] }, { 1: [2, 3] }, { 1: [2, 4] }, { 1: [2, 5] }, { 1: [2, 6] }, { 12: [1, 14] }, { 12: [1, 15] }, { 12: [1, 16] }, { 12: [1, 17] }, { 12: [1, 18] }, { 13: 19, 19: 20, 20: 21, 21: 22, 22: t, 23: r, 24: i, 26: s, 28: a, 29: 49, 30: 61, 32: 62, 34: n, 36: o, 37: h, 38: l, 39: d, 40: p, 41: g, 43: 23, 44: f, 45: y, 46: m, 47: x, 48: b, 49: v, 50: _, 51: A, 52: S, 53: k, 54: L, 55: T, 56: C, 57: E, 58: w, 59: W, 60: N, 61: B, 62: R, 63: V, 64: $, 65: D, 66: O, 67: Y, 68: M, 69: G, 70: rt, 71: ht, 72: Z, 73: ot, 74: it }, { 13: 70, 19: 20, 20: 21, 21: 22, 22: t, 23: r, 24: i, 26: s, 28: a, 29: 49, 30: 61, 32: 62, 34: n, 36: o, 37: h, 38: l, 39: d, 40: p, 41: g, 43: 23, 44: f, 45: y, 46: m, 47: x, 48: b, 49: v, 50: _, 51: A, 52: S, 53: k, 54: L, 55: T, 56: C, 57: E, 58: w, 59: W, 60: N, 61: B, 62: R, 63: V, 64: $, 65: D, 66: O, 67: Y, 68: M, 69: G, 70: rt, 71: ht, 72: Z, 73: ot, 74: it }, { 13: 71, 19: 20, 20: 21, 21: 22, 22: t, 23: r, 24: i, 26: s, 28: a, 29: 49, 30: 61, 32: 62, 34: n, 36: o, 37: h, 38: l, 39: d, 40: p, 41: g, 43: 23, 44: f, 45: y, 46: m, 47: x, 48: b, 49: v, 50: _, 51: A, 52: S, 53: k, 54: L, 55: T, 56: C, 57: E, 58: w, 59: W, 60: N, 61: B, 62: R, 63: V, 64: $, 65: D, 66: O, 67: Y, 68: M, 69: G, 70: rt, 71: ht, 72: Z, 73: ot, 74: it }, { 13: 72, 19: 20, 20: 21, 21: 22, 22: t, 23: r, 24: i, 26: s, 28: a, 29: 49, 30: 61, 32: 62, 34: n, 36: o, 37: h, 38: l, 39: d, 40: p, 41: g, 43: 23, 44: f, 45: y, 46: m, 47: x, 48: b, 49: v, 50: _, 51: A, 52: S, 53: k, 54: L, 55: T, 56: C, 57: E, 58: w, 59: W, 60: N, 61: B, 62: R, 63: V, 64: $, 65: D, 66: O, 67: Y, 68: M, 69: G, 70: rt, 71: ht, 72: Z, 73: ot, 74: it }, { 13: 73, 19: 20, 20: 21, 21: 22, 22: t, 23: r, 24: i, 26: s, 28: a, 29: 49, 30: 61, 32: 62, 34: n, 36: o, 37: h, 38: l, 39: d, 40: p, 41: g, 43: 23, 44: f, 45: y, 46: m, 47: x, 48: b, 49: v, 50: _, 51: A, 52: S, 53: k, 54: L, 55: T, 56: C, 57: E, 58: w, 59: W, 60: N, 61: B, 62: R, 63: V, 64: $, 65: D, 66: O, 67: Y, 68: M, 69: G, 70: rt, 71: ht, 72: Z, 73: ot, 74: it }, { 14: [1, 74] }, e(bt, [2, 13], { 43: 23, 29: 49, 30: 61, 32: 62, 20: 75, 34: n, 36: o, 37: h, 38: l, 39: d, 40: p, 41: g, 44: f, 45: y, 46: m, 47: x, 48: b, 49: v, 50: _, 51: A, 52: S, 53: k, 54: L, 55: T, 56: C, 57: E, 58: w, 59: W, 60: N, 61: B, 62: R, 63: V, 64: $, 65: D, 66: O, 67: Y, 68: M, 69: G, 70: rt, 71: ht, 72: Z, 73: ot, 74: it }), e(bt, [2, 14]), e(xt, [2, 16], { 12: [1, 76] }), e(bt, [2, 36], { 12: [1, 77] }), e(Ct, [2, 19]), e(Ct, [2, 20]), { 25: [1, 78] }, { 27: [1, 79] }, e(Ct, [2, 23]), { 35: 80, 75: 81, 76: at, 77: lt, 79: Q, 80: U }, { 35: 86, 75: 81, 76: at, 77: lt, 79: Q, 80: U }, { 35: 87, 75: 81, 76: at, 77: lt, 79: Q, 80: U }, { 35: 88, 75: 81, 76: at, 77: lt, 79: Q, 80: U }, { 35: 89, 75: 81, 76: at, 77: lt, 79: Q, 80: U }, { 35: 90, 75: 81, 76: at, 77: lt, 79: Q, 80: U }, { 35: 91, 75: 81, 76: at, 77: lt, 79: Q, 80: U }, { 35: 92, 75: 81, 76: at, 77: lt, 79: Q, 80: U }, { 35: 93, 75: 81, 76: at, 77: lt, 79: Q, 80: U }, { 35: 94, 75: 81, 76: at, 77: lt, 79: Q, 80: U }, { 35: 95, 75: 81, 76: at, 77: lt, 79: Q, 80: U }, { 35: 96, 75: 81, 76: at, 77: lt, 79: Q, 80: U }, { 35: 97, 75: 81, 76: at, 77: lt, 79: Q, 80: U }, { 35: 98, 75: 81, 76: at, 77: lt, 79: Q, 80: U }, { 35: 99, 75: 81, 76: at, 77: lt, 79: Q, 80: U }, { 35: 100, 75: 81, 76: at, 77: lt, 79: Q, 80: U }, { 35: 101, 75: 81, 76: at, 77: lt, 79: Q, 80: U }, { 35: 102, 75: 81, 76: at, 77: lt, 79: Q, 80: U }, { 35: 103, 75: 81, 76: at, 77: lt, 79: Q, 80: U }, { 35: 104, 75: 81, 76: at, 77: lt, 79: Q, 80: U }, e(et, [2, 59]), { 35: 105, 75: 81, 76: at, 77: lt, 79: Q, 80: U }, { 35: 106, 75: 81, 76: at, 77: lt, 79: Q, 80: U }, { 35: 107, 75: 81, 76: at, 77: lt, 79: Q, 80: U }, { 35: 108, 75: 81, 76: at, 77: lt, 79: Q, 80: U }, { 35: 109, 75: 81, 76: at, 77: lt, 79: Q, 80: U }, { 35: 110, 75: 81, 76: at, 77: lt, 79: Q, 80: U }, { 35: 111, 75: 81, 76: at, 77: lt, 79: Q, 80: U }, { 35: 112, 75: 81, 76: at, 77: lt, 79: Q, 80: U }, { 35: 113, 75: 81, 76: at, 77: lt, 79: Q, 80: U }, { 35: 114, 75: 81, 76: at, 77: lt, 79: Q, 80: U }, { 35: 115, 75: 81, 76: at, 77: lt, 79: Q, 80: U }, { 20: 116, 29: 49, 30: 61, 32: 62, 34: n, 36: o, 37: h, 38: l, 39: d, 40: p, 41: g, 43: 23, 44: f, 45: y, 46: m, 47: x, 48: b, 49: v, 50: _, 51: A, 52: S, 53: k, 54: L, 55: T, 56: C, 57: E, 58: w, 59: W, 60: N, 61: B, 62: R, 63: V, 64: $, 65: D, 66: O, 67: Y, 68: M, 69: G, 70: rt, 71: ht, 72: Z, 73: ot, 74: it }, { 12: [1, 118], 33: [1, 117] }, { 35: 119, 75: 81, 76: at, 77: lt, 79: Q, 80: U }, { 35: 120, 75: 81, 76: at, 77: lt, 79: Q, 80: U }, { 35: 121, 75: 81, 76: at, 77: lt, 79: Q, 80: U }, { 35: 122, 75: 81, 76: at, 77: lt, 79: Q, 80: U }, { 35: 123, 75: 81, 76: at, 77: lt, 79: Q, 80: U }, { 35: 124, 75: 81, 76: at, 77: lt, 79: Q, 80: U }, { 35: 125, 75: 81, 76: at, 77: lt, 79: Q, 80: U }, { 14: [1, 126] }, { 14: [1, 127] }, { 14: [1, 128] }, { 14: [1, 129] }, { 1: [2, 8] }, e(bt, [2, 15]), e(xt, [2, 17], { 21: 22, 19: 130, 22: t, 23: r, 24: i, 26: s, 28: a }), e(bt, [2, 37], { 19: 20, 20: 21, 21: 22, 43: 23, 29: 49, 30: 61, 32: 62, 13: 131, 22: t, 23: r, 24: i, 26: s, 28: a, 34: n, 36: o, 37: h, 38: l, 39: d, 40: p, 41: g, 44: f, 45: y, 46: m, 47: x, 48: b, 49: v, 50: _, 51: A, 52: S, 53: k, 54: L, 55: T, 56: C, 57: E, 58: w, 59: W, 60: N, 61: B, 62: R, 63: V, 64: $, 65: D, 66: O, 67: Y, 68: M, 69: G, 70: rt, 71: ht, 72: Z, 73: ot, 74: it }), e(Ct, [2, 21]), e(Ct, [2, 22]), e(et, [2, 39]), e(z, [2, 71], { 75: 81, 35: 132, 76: at, 77: lt, 79: Q, 80: U }), e(Tt, [2, 73]), { 78: [1, 133] }, e(Tt, [2, 75]), e(Tt, [2, 76]), e(et, [2, 40]), e(et, [2, 41]), e(et, [2, 42]), e(et, [2, 43]), e(et, [2, 44]), e(et, [2, 45]), e(et, [2, 46]), e(et, [2, 47]), e(et, [2, 48]), e(et, [2, 49]), e(et, [2, 50]), e(et, [2, 51]), e(et, [2, 52]), e(et, [2, 53]), e(et, [2, 54]), e(et, [2, 55]), e(et, [2, 56]), e(et, [2, 57]), e(et, [2, 58]), e(et, [2, 60]), e(et, [2, 61]), e(et, [2, 62]), e(et, [2, 63]), e(et, [2, 64]), e(et, [2, 65]), e(et, [2, 66]), e(et, [2, 67]), e(et, [2, 68]), e(et, [2, 69]), e(et, [2, 70]), { 31: 134, 42: [1, 135] }, { 12: [1, 136] }, { 33: [1, 137] }, e(F, [2, 28]), e(F, [2, 29]), e(F, [2, 30]), e(F, [2, 31]), e(F, [2, 32]), e(F, [2, 33]), e(F, [2, 34]), { 1: [2, 9] }, { 1: [2, 10] }, { 1: [2, 11] }, { 1: [2, 12] }, e(xt, [2, 18]), e(bt, [2, 38]), e(z, [2, 72]), e(Tt, [2, 74]), e(et, [2, 24]), e(et, [2, 35]), e(te, [2, 25]), e(te, [2, 26], { 12: [1, 138] }), e(te, [2, 27])],
    defaultActions: { 2: [2, 1], 3: [2, 2], 4: [2, 7], 5: [2, 3], 6: [2, 4], 7: [2, 5], 8: [2, 6], 74: [2, 8], 126: [2, 9], 127: [2, 10], 128: [2, 11], 129: [2, 12] },
    parseError: /* @__PURE__ */ u(function(dt, wt) {
      if (wt.recoverable)
        this.trace(dt);
      else {
        var nt = new Error(dt);
        throw nt.hash = wt, nt;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ u(function(dt) {
      var wt = this, nt = [0], ut = [], kt = [null], X = [], ft = this.table, P = "", At = 0, q = 0, vt = 2, ct = 1, Nt = X.slice.call(arguments, 1), pt = Object.create(this.lexer), gt = { yy: {} };
      for (var Jt in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, Jt) && (gt.yy[Jt] = this.yy[Jt]);
      pt.setInput(dt, gt.yy), gt.yy.lexer = pt, gt.yy.parser = this, typeof pt.yylloc > "u" && (pt.yylloc = {});
      var Et = pt.yylloc;
      X.push(Et);
      var ue = pt.options && pt.options.ranges;
      typeof gt.yy.parseError == "function" ? this.parseError = gt.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function Ke(Zt) {
        nt.length = nt.length - 2 * Zt, kt.length = kt.length - Zt, X.length = X.length - Zt;
      }
      u(Ke, "popStack");
      function se() {
        var Zt;
        return Zt = ut.pop() || pt.lex() || ct, typeof Zt != "number" && (Zt instanceof Array && (ut = Zt, Zt = ut.pop()), Zt = wt.symbols_[Zt] || Zt), Zt;
      }
      u(se, "lex");
      for (var me, Pe, Gt, Se, ve = {}, Ue, qt, ye, Mt; ; ) {
        if (Pe = nt[nt.length - 1], this.defaultActions[Pe] ? Gt = this.defaultActions[Pe] : ((me === null || typeof me > "u") && (me = se()), Gt = ft[Pe] && ft[Pe][me]), typeof Gt > "u" || !Gt.length || !Gt[0]) {
          var ae = "";
          Mt = [];
          for (Ue in ft[Pe])
            this.terminals_[Ue] && Ue > vt && Mt.push("'" + this.terminals_[Ue] + "'");
          pt.showPosition ? ae = "Parse error on line " + (At + 1) + `:
` + pt.showPosition() + `
Expecting ` + Mt.join(", ") + ", got '" + (this.terminals_[me] || me) + "'" : ae = "Parse error on line " + (At + 1) + ": Unexpected " + (me == ct ? "end of input" : "'" + (this.terminals_[me] || me) + "'"), this.parseError(ae, {
            text: pt.match,
            token: this.terminals_[me] || me,
            line: pt.yylineno,
            loc: Et,
            expected: Mt
          });
        }
        if (Gt[0] instanceof Array && Gt.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + Pe + ", token: " + me);
        switch (Gt[0]) {
          case 1:
            nt.push(me), kt.push(pt.yytext), X.push(pt.yylloc), nt.push(Gt[1]), me = null, q = pt.yyleng, P = pt.yytext, At = pt.yylineno, Et = pt.yylloc;
            break;
          case 2:
            if (qt = this.productions_[Gt[1]][1], ve.$ = kt[kt.length - qt], ve._$ = {
              first_line: X[X.length - (qt || 1)].first_line,
              last_line: X[X.length - 1].last_line,
              first_column: X[X.length - (qt || 1)].first_column,
              last_column: X[X.length - 1].last_column
            }, ue && (ve._$.range = [
              X[X.length - (qt || 1)].range[0],
              X[X.length - 1].range[1]
            ]), Se = this.performAction.apply(ve, [
              P,
              q,
              At,
              gt.yy,
              Gt[1],
              kt,
              X
            ].concat(Nt)), typeof Se < "u")
              return Se;
            qt && (nt = nt.slice(0, -1 * qt * 2), kt = kt.slice(0, -1 * qt), X = X.slice(0, -1 * qt)), nt.push(this.productions_[Gt[1]][0]), kt.push(ve.$), X.push(ve._$), ye = ft[nt[nt.length - 2]][nt[nt.length - 1]], nt.push(ye);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, Ut = /* @__PURE__ */ function() {
    var ie = {
      EOF: 1,
      parseError: /* @__PURE__ */ u(function(wt, nt) {
        if (this.yy.parser)
          this.yy.parser.parseError(wt, nt);
        else
          throw new Error(wt);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ u(function(dt, wt) {
        return this.yy = wt || this.yy || {}, this._input = dt, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ u(function() {
        var dt = this._input[0];
        this.yytext += dt, this.yyleng++, this.offset++, this.match += dt, this.matched += dt;
        var wt = dt.match(/(?:\r\n?|\n).*/g);
        return wt ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), dt;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ u(function(dt) {
        var wt = dt.length, nt = dt.split(/(?:\r\n?|\n)/g);
        this._input = dt + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - wt), this.offset -= wt;
        var ut = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), nt.length - 1 && (this.yylineno -= nt.length - 1);
        var kt = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: nt ? (nt.length === ut.length ? this.yylloc.first_column : 0) + ut[ut.length - nt.length].length - nt[0].length : this.yylloc.first_column - wt
        }, this.options.ranges && (this.yylloc.range = [kt[0], kt[0] + this.yyleng - wt]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ u(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ u(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ u(function(dt) {
        this.unput(this.match.slice(dt));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ u(function() {
        var dt = this.matched.substr(0, this.matched.length - this.match.length);
        return (dt.length > 20 ? "..." : "") + dt.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ u(function() {
        var dt = this.match;
        return dt.length < 20 && (dt += this._input.substr(0, 20 - dt.length)), (dt.substr(0, 20) + (dt.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ u(function() {
        var dt = this.pastInput(), wt = new Array(dt.length + 1).join("-");
        return dt + this.upcomingInput() + `
` + wt + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ u(function(dt, wt) {
        var nt, ut, kt;
        if (this.options.backtrack_lexer && (kt = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (kt.yylloc.range = this.yylloc.range.slice(0))), ut = dt[0].match(/(?:\r\n?|\n).*/g), ut && (this.yylineno += ut.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: ut ? ut[ut.length - 1].length - ut[ut.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + dt[0].length
        }, this.yytext += dt[0], this.match += dt[0], this.matches = dt, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(dt[0].length), this.matched += dt[0], nt = this.performAction.call(this, this.yy, this, wt, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), nt)
          return nt;
        if (this._backtrack) {
          for (var X in kt)
            this[X] = kt[X];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ u(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var dt, wt, nt, ut;
        this._more || (this.yytext = "", this.match = "");
        for (var kt = this._currentRules(), X = 0; X < kt.length; X++)
          if (nt = this._input.match(this.rules[kt[X]]), nt && (!wt || nt[0].length > wt[0].length)) {
            if (wt = nt, ut = X, this.options.backtrack_lexer) {
              if (dt = this.test_match(nt, kt[X]), dt !== !1)
                return dt;
              if (this._backtrack) {
                wt = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return wt ? (dt = this.test_match(wt, kt[ut]), dt !== !1 ? dt : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ u(function() {
        var wt = this.next();
        return wt || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ u(function(wt) {
        this.conditionStack.push(wt);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ u(function() {
        var wt = this.conditionStack.length - 1;
        return wt > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ u(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ u(function(wt) {
        return wt = this.conditionStack.length - 1 - Math.abs(wt || 0), wt >= 0 ? this.conditionStack[wt] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ u(function(wt) {
        this.begin(wt);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ u(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: {},
      performAction: /* @__PURE__ */ u(function(wt, nt, ut, kt) {
        switch (ut) {
          case 0:
            return 6;
          case 1:
            return 7;
          case 2:
            return 8;
          case 3:
            return 9;
          case 4:
            return 22;
          case 5:
            return 23;
          case 6:
            return this.begin("acc_title"), 24;
          case 7:
            return this.popState(), "acc_title_value";
          case 8:
            return this.begin("acc_descr"), 26;
          case 9:
            return this.popState(), "acc_descr_value";
          case 10:
            this.begin("acc_descr_multiline");
            break;
          case 11:
            this.popState();
            break;
          case 12:
            return "acc_descr_multiline_value";
          case 13:
            break;
          case 14:
            c;
            break;
          case 15:
            return 12;
          case 16:
            break;
          case 17:
            return 11;
          case 18:
            return 15;
          case 19:
            return 16;
          case 20:
            return 17;
          case 21:
            return 18;
          case 22:
            return this.begin("person_ext"), 45;
          case 23:
            return this.begin("person"), 44;
          case 24:
            return this.begin("system_ext_queue"), 51;
          case 25:
            return this.begin("system_ext_db"), 50;
          case 26:
            return this.begin("system_ext"), 49;
          case 27:
            return this.begin("system_queue"), 48;
          case 28:
            return this.begin("system_db"), 47;
          case 29:
            return this.begin("system"), 46;
          case 30:
            return this.begin("boundary"), 37;
          case 31:
            return this.begin("enterprise_boundary"), 34;
          case 32:
            return this.begin("system_boundary"), 36;
          case 33:
            return this.begin("container_ext_queue"), 57;
          case 34:
            return this.begin("container_ext_db"), 56;
          case 35:
            return this.begin("container_ext"), 55;
          case 36:
            return this.begin("container_queue"), 54;
          case 37:
            return this.begin("container_db"), 53;
          case 38:
            return this.begin("container"), 52;
          case 39:
            return this.begin("container_boundary"), 38;
          case 40:
            return this.begin("component_ext_queue"), 63;
          case 41:
            return this.begin("component_ext_db"), 62;
          case 42:
            return this.begin("component_ext"), 61;
          case 43:
            return this.begin("component_queue"), 60;
          case 44:
            return this.begin("component_db"), 59;
          case 45:
            return this.begin("component"), 58;
          case 46:
            return this.begin("node"), 39;
          case 47:
            return this.begin("node"), 39;
          case 48:
            return this.begin("node_l"), 40;
          case 49:
            return this.begin("node_r"), 41;
          case 50:
            return this.begin("rel"), 64;
          case 51:
            return this.begin("birel"), 65;
          case 52:
            return this.begin("rel_u"), 66;
          case 53:
            return this.begin("rel_u"), 66;
          case 54:
            return this.begin("rel_d"), 67;
          case 55:
            return this.begin("rel_d"), 67;
          case 56:
            return this.begin("rel_l"), 68;
          case 57:
            return this.begin("rel_l"), 68;
          case 58:
            return this.begin("rel_r"), 69;
          case 59:
            return this.begin("rel_r"), 69;
          case 60:
            return this.begin("rel_b"), 70;
          case 61:
            return this.begin("rel_index"), 71;
          case 62:
            return this.begin("update_el_style"), 72;
          case 63:
            return this.begin("update_rel_style"), 73;
          case 64:
            return this.begin("update_layout_config"), 74;
          case 65:
            return "EOF_IN_STRUCT";
          case 66:
            return this.begin("attribute"), "ATTRIBUTE_EMPTY";
          case 67:
            this.begin("attribute");
            break;
          case 68:
            this.popState(), this.popState();
            break;
          case 69:
            return 80;
          case 70:
            break;
          case 71:
            return 80;
          case 72:
            this.begin("string");
            break;
          case 73:
            this.popState();
            break;
          case 74:
            return "STR";
          case 75:
            this.begin("string_kv");
            break;
          case 76:
            return this.begin("string_kv_key"), "STR_KEY";
          case 77:
            this.popState(), this.begin("string_kv_value");
            break;
          case 78:
            return "STR_VALUE";
          case 79:
            this.popState(), this.popState();
            break;
          case 80:
            return "STR";
          case 81:
            return "LBRACE";
          case 82:
            return "RBRACE";
          case 83:
            return "SPACE";
          case 84:
            return "EOL";
          case 85:
            return 14;
        }
      }, "anonymous"),
      rules: [/^(?:.*direction\s+TB[^\n]*)/, /^(?:.*direction\s+BT[^\n]*)/, /^(?:.*direction\s+RL[^\n]*)/, /^(?:.*direction\s+LR[^\n]*)/, /^(?:title\s[^#\n;]+)/, /^(?:accDescription\s[^#\n;]+)/, /^(?:accTitle\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*\{\s*)/, /^(?:[\}])/, /^(?:[^\}]*)/, /^(?:%%(?!\{)*[^\n]*(\r?\n?)+)/, /^(?:%%[^\n]*(\r?\n)*)/, /^(?:\s*(\r?\n)+)/, /^(?:\s+)/, /^(?:C4Context\b)/, /^(?:C4Container\b)/, /^(?:C4Component\b)/, /^(?:C4Dynamic\b)/, /^(?:C4Deployment\b)/, /^(?:Person_Ext\b)/, /^(?:Person\b)/, /^(?:SystemQueue_Ext\b)/, /^(?:SystemDb_Ext\b)/, /^(?:System_Ext\b)/, /^(?:SystemQueue\b)/, /^(?:SystemDb\b)/, /^(?:System\b)/, /^(?:Boundary\b)/, /^(?:Enterprise_Boundary\b)/, /^(?:System_Boundary\b)/, /^(?:ContainerQueue_Ext\b)/, /^(?:ContainerDb_Ext\b)/, /^(?:Container_Ext\b)/, /^(?:ContainerQueue\b)/, /^(?:ContainerDb\b)/, /^(?:Container\b)/, /^(?:Container_Boundary\b)/, /^(?:ComponentQueue_Ext\b)/, /^(?:ComponentDb_Ext\b)/, /^(?:Component_Ext\b)/, /^(?:ComponentQueue\b)/, /^(?:ComponentDb\b)/, /^(?:Component\b)/, /^(?:Deployment_Node\b)/, /^(?:Node\b)/, /^(?:Node_L\b)/, /^(?:Node_R\b)/, /^(?:Rel\b)/, /^(?:BiRel\b)/, /^(?:Rel_Up\b)/, /^(?:Rel_U\b)/, /^(?:Rel_Down\b)/, /^(?:Rel_D\b)/, /^(?:Rel_Left\b)/, /^(?:Rel_L\b)/, /^(?:Rel_Right\b)/, /^(?:Rel_R\b)/, /^(?:Rel_Back\b)/, /^(?:RelIndex\b)/, /^(?:UpdateElementStyle\b)/, /^(?:UpdateRelStyle\b)/, /^(?:UpdateLayoutConfig\b)/, /^(?:$)/, /^(?:[(][ ]*[,])/, /^(?:[(])/, /^(?:[)])/, /^(?:,,)/, /^(?:,)/, /^(?:[ ]*["]["])/, /^(?:[ ]*["])/, /^(?:["])/, /^(?:[^"]*)/, /^(?:[ ]*[\$])/, /^(?:[^=]*)/, /^(?:[=][ ]*["])/, /^(?:[^"]+)/, /^(?:["])/, /^(?:[^,]+)/, /^(?:\{)/, /^(?:\})/, /^(?:[\s]+)/, /^(?:[\n\r]+)/, /^(?:$)/],
      conditions: { acc_descr_multiline: { rules: [11, 12], inclusive: !1 }, acc_descr: { rules: [9], inclusive: !1 }, acc_title: { rules: [7], inclusive: !1 }, string_kv_value: { rules: [78, 79], inclusive: !1 }, string_kv_key: { rules: [77], inclusive: !1 }, string_kv: { rules: [76], inclusive: !1 }, string: { rules: [73, 74], inclusive: !1 }, attribute: { rules: [68, 69, 70, 71, 72, 75, 80], inclusive: !1 }, update_layout_config: { rules: [65, 66, 67, 68], inclusive: !1 }, update_rel_style: { rules: [65, 66, 67, 68], inclusive: !1 }, update_el_style: { rules: [65, 66, 67, 68], inclusive: !1 }, rel_b: { rules: [65, 66, 67, 68], inclusive: !1 }, rel_r: { rules: [65, 66, 67, 68], inclusive: !1 }, rel_l: { rules: [65, 66, 67, 68], inclusive: !1 }, rel_d: { rules: [65, 66, 67, 68], inclusive: !1 }, rel_u: { rules: [65, 66, 67, 68], inclusive: !1 }, rel_bi: { rules: [], inclusive: !1 }, rel: { rules: [65, 66, 67, 68], inclusive: !1 }, node_r: { rules: [65, 66, 67, 68], inclusive: !1 }, node_l: { rules: [65, 66, 67, 68], inclusive: !1 }, node: { rules: [65, 66, 67, 68], inclusive: !1 }, index: { rules: [], inclusive: !1 }, rel_index: { rules: [65, 66, 67, 68], inclusive: !1 }, component_ext_queue: { rules: [], inclusive: !1 }, component_ext_db: { rules: [65, 66, 67, 68], inclusive: !1 }, component_ext: { rules: [65, 66, 67, 68], inclusive: !1 }, component_queue: { rules: [65, 66, 67, 68], inclusive: !1 }, component_db: { rules: [65, 66, 67, 68], inclusive: !1 }, component: { rules: [65, 66, 67, 68], inclusive: !1 }, container_boundary: { rules: [65, 66, 67, 68], inclusive: !1 }, container_ext_queue: { rules: [65, 66, 67, 68], inclusive: !1 }, container_ext_db: { rules: [65, 66, 67, 68], inclusive: !1 }, container_ext: { rules: [65, 66, 67, 68], inclusive: !1 }, container_queue: { rules: [65, 66, 67, 68], inclusive: !1 }, container_db: { rules: [65, 66, 67, 68], inclusive: !1 }, container: { rules: [65, 66, 67, 68], inclusive: !1 }, birel: { rules: [65, 66, 67, 68], inclusive: !1 }, system_boundary: { rules: [65, 66, 67, 68], inclusive: !1 }, enterprise_boundary: { rules: [65, 66, 67, 68], inclusive: !1 }, boundary: { rules: [65, 66, 67, 68], inclusive: !1 }, system_ext_queue: { rules: [65, 66, 67, 68], inclusive: !1 }, system_ext_db: { rules: [65, 66, 67, 68], inclusive: !1 }, system_ext: { rules: [65, 66, 67, 68], inclusive: !1 }, system_queue: { rules: [65, 66, 67, 68], inclusive: !1 }, system_db: { rules: [65, 66, 67, 68], inclusive: !1 }, system: { rules: [65, 66, 67, 68], inclusive: !1 }, person_ext: { rules: [65, 66, 67, 68], inclusive: !1 }, person: { rules: [65, 66, 67, 68], inclusive: !1 }, INITIAL: { rules: [0, 1, 2, 3, 4, 5, 6, 8, 10, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 81, 82, 83, 84, 85], inclusive: !0 } }
    };
    return ie;
  }();
  J.lexer = Ut;
  function Wt() {
    this.yy = {};
  }
  return u(Wt, "Parser"), Wt.prototype = J, J.Parser = Wt, new Wt();
}();
so.parser = so;
var l6 = so, zr = [], Ai = [""], pr = "global", $r = "", Zr = [
  {
    alias: "global",
    label: { text: "global" },
    type: { text: "global" },
    tags: null,
    link: null,
    parentBoundary: ""
  }
], tn = [], ih = "", sh = !1, ao = 4, no = 2, Cf, c6 = /* @__PURE__ */ u(function() {
  return Cf;
}, "getC4Type"), h6 = /* @__PURE__ */ u(function(e) {
  Cf = ge(e, K());
}, "setC4Type"), u6 = /* @__PURE__ */ u(function(e, t, r, i, s, a, n, o, h) {
  if (e == null || t === void 0 || t === null || r === void 0 || r === null || i === void 0 || i === null)
    return;
  let l = {};
  const d = tn.find((p) => p.from === t && p.to === r);
  if (d ? l = d : tn.push(l), l.type = e, l.from = t, l.to = r, l.label = { text: i }, s == null)
    l.techn = { text: "" };
  else if (typeof s == "object") {
    let [p, g] = Object.entries(s)[0];
    l[p] = { text: g };
  } else
    l.techn = { text: s };
  if (a == null)
    l.descr = { text: "" };
  else if (typeof a == "object") {
    let [p, g] = Object.entries(a)[0];
    l[p] = { text: g };
  } else
    l.descr = { text: a };
  if (typeof n == "object") {
    let [p, g] = Object.entries(n)[0];
    l[p] = g;
  } else
    l.sprite = n;
  if (typeof o == "object") {
    let [p, g] = Object.entries(o)[0];
    l[p] = g;
  } else
    l.tags = o;
  if (typeof h == "object") {
    let [p, g] = Object.entries(h)[0];
    l[p] = g;
  } else
    l.link = h;
  l.wrap = Oi();
}, "addRel"), d6 = /* @__PURE__ */ u(function(e, t, r, i, s, a, n) {
  if (t === null || r === null)
    return;
  let o = {};
  const h = zr.find((l) => l.alias === t);
  if (h && t === h.alias ? o = h : (o.alias = t, zr.push(o)), r == null ? o.label = { text: "" } : o.label = { text: r }, i == null)
    o.descr = { text: "" };
  else if (typeof i == "object") {
    let [l, d] = Object.entries(i)[0];
    o[l] = { text: d };
  } else
    o.descr = { text: i };
  if (typeof s == "object") {
    let [l, d] = Object.entries(s)[0];
    o[l] = d;
  } else
    o.sprite = s;
  if (typeof a == "object") {
    let [l, d] = Object.entries(a)[0];
    o[l] = d;
  } else
    o.tags = a;
  if (typeof n == "object") {
    let [l, d] = Object.entries(n)[0];
    o[l] = d;
  } else
    o.link = n;
  o.typeC4Shape = { text: e }, o.parentBoundary = pr, o.wrap = Oi();
}, "addPersonOrSystem"), p6 = /* @__PURE__ */ u(function(e, t, r, i, s, a, n, o) {
  if (t === null || r === null)
    return;
  let h = {};
  const l = zr.find((d) => d.alias === t);
  if (l && t === l.alias ? h = l : (h.alias = t, zr.push(h)), r == null ? h.label = { text: "" } : h.label = { text: r }, i == null)
    h.techn = { text: "" };
  else if (typeof i == "object") {
    let [d, p] = Object.entries(i)[0];
    h[d] = { text: p };
  } else
    h.techn = { text: i };
  if (s == null)
    h.descr = { text: "" };
  else if (typeof s == "object") {
    let [d, p] = Object.entries(s)[0];
    h[d] = { text: p };
  } else
    h.descr = { text: s };
  if (typeof a == "object") {
    let [d, p] = Object.entries(a)[0];
    h[d] = p;
  } else
    h.sprite = a;
  if (typeof n == "object") {
    let [d, p] = Object.entries(n)[0];
    h[d] = p;
  } else
    h.tags = n;
  if (typeof o == "object") {
    let [d, p] = Object.entries(o)[0];
    h[d] = p;
  } else
    h.link = o;
  h.wrap = Oi(), h.typeC4Shape = { text: e }, h.parentBoundary = pr;
}, "addContainer"), g6 = /* @__PURE__ */ u(function(e, t, r, i, s, a, n, o) {
  if (t === null || r === null)
    return;
  let h = {};
  const l = zr.find((d) => d.alias === t);
  if (l && t === l.alias ? h = l : (h.alias = t, zr.push(h)), r == null ? h.label = { text: "" } : h.label = { text: r }, i == null)
    h.techn = { text: "" };
  else if (typeof i == "object") {
    let [d, p] = Object.entries(i)[0];
    h[d] = { text: p };
  } else
    h.techn = { text: i };
  if (s == null)
    h.descr = { text: "" };
  else if (typeof s == "object") {
    let [d, p] = Object.entries(s)[0];
    h[d] = { text: p };
  } else
    h.descr = { text: s };
  if (typeof a == "object") {
    let [d, p] = Object.entries(a)[0];
    h[d] = p;
  } else
    h.sprite = a;
  if (typeof n == "object") {
    let [d, p] = Object.entries(n)[0];
    h[d] = p;
  } else
    h.tags = n;
  if (typeof o == "object") {
    let [d, p] = Object.entries(o)[0];
    h[d] = p;
  } else
    h.link = o;
  h.wrap = Oi(), h.typeC4Shape = { text: e }, h.parentBoundary = pr;
}, "addComponent"), f6 = /* @__PURE__ */ u(function(e, t, r, i, s) {
  if (e === null || t === null)
    return;
  let a = {};
  const n = Zr.find((o) => o.alias === e);
  if (n && e === n.alias ? a = n : (a.alias = e, Zr.push(a)), t == null ? a.label = { text: "" } : a.label = { text: t }, r == null)
    a.type = { text: "system" };
  else if (typeof r == "object") {
    let [o, h] = Object.entries(r)[0];
    a[o] = { text: h };
  } else
    a.type = { text: r };
  if (typeof i == "object") {
    let [o, h] = Object.entries(i)[0];
    a[o] = h;
  } else
    a.tags = i;
  if (typeof s == "object") {
    let [o, h] = Object.entries(s)[0];
    a[o] = h;
  } else
    a.link = s;
  a.parentBoundary = pr, a.wrap = Oi(), $r = pr, pr = e, Ai.push($r);
}, "addPersonOrSystemBoundary"), y6 = /* @__PURE__ */ u(function(e, t, r, i, s) {
  if (e === null || t === null)
    return;
  let a = {};
  const n = Zr.find((o) => o.alias === e);
  if (n && e === n.alias ? a = n : (a.alias = e, Zr.push(a)), t == null ? a.label = { text: "" } : a.label = { text: t }, r == null)
    a.type = { text: "container" };
  else if (typeof r == "object") {
    let [o, h] = Object.entries(r)[0];
    a[o] = { text: h };
  } else
    a.type = { text: r };
  if (typeof i == "object") {
    let [o, h] = Object.entries(i)[0];
    a[o] = h;
  } else
    a.tags = i;
  if (typeof s == "object") {
    let [o, h] = Object.entries(s)[0];
    a[o] = h;
  } else
    a.link = s;
  a.parentBoundary = pr, a.wrap = Oi(), $r = pr, pr = e, Ai.push($r);
}, "addContainerBoundary"), m6 = /* @__PURE__ */ u(function(e, t, r, i, s, a, n, o) {
  if (t === null || r === null)
    return;
  let h = {};
  const l = Zr.find((d) => d.alias === t);
  if (l && t === l.alias ? h = l : (h.alias = t, Zr.push(h)), r == null ? h.label = { text: "" } : h.label = { text: r }, i == null)
    h.type = { text: "node" };
  else if (typeof i == "object") {
    let [d, p] = Object.entries(i)[0];
    h[d] = { text: p };
  } else
    h.type = { text: i };
  if (s == null)
    h.descr = { text: "" };
  else if (typeof s == "object") {
    let [d, p] = Object.entries(s)[0];
    h[d] = { text: p };
  } else
    h.descr = { text: s };
  if (typeof n == "object") {
    let [d, p] = Object.entries(n)[0];
    h[d] = p;
  } else
    h.tags = n;
  if (typeof o == "object") {
    let [d, p] = Object.entries(o)[0];
    h[d] = p;
  } else
    h.link = o;
  h.nodeType = e, h.parentBoundary = pr, h.wrap = Oi(), $r = pr, pr = t, Ai.push($r);
}, "addDeploymentNode"), x6 = /* @__PURE__ */ u(function() {
  pr = $r, Ai.pop(), $r = Ai.pop(), Ai.push($r);
}, "popBoundaryParseStack"), b6 = /* @__PURE__ */ u(function(e, t, r, i, s, a, n, o, h, l, d) {
  let p = zr.find((g) => g.alias === t);
  if (!(p === void 0 && (p = Zr.find((g) => g.alias === t), p === void 0))) {
    if (r != null)
      if (typeof r == "object") {
        let [g, f] = Object.entries(r)[0];
        p[g] = f;
      } else
        p.bgColor = r;
    if (i != null)
      if (typeof i == "object") {
        let [g, f] = Object.entries(i)[0];
        p[g] = f;
      } else
        p.fontColor = i;
    if (s != null)
      if (typeof s == "object") {
        let [g, f] = Object.entries(s)[0];
        p[g] = f;
      } else
        p.borderColor = s;
    if (a != null)
      if (typeof a == "object") {
        let [g, f] = Object.entries(a)[0];
        p[g] = f;
      } else
        p.shadowing = a;
    if (n != null)
      if (typeof n == "object") {
        let [g, f] = Object.entries(n)[0];
        p[g] = f;
      } else
        p.shape = n;
    if (o != null)
      if (typeof o == "object") {
        let [g, f] = Object.entries(o)[0];
        p[g] = f;
      } else
        p.sprite = o;
    if (h != null)
      if (typeof h == "object") {
        let [g, f] = Object.entries(h)[0];
        p[g] = f;
      } else
        p.techn = h;
    if (l != null)
      if (typeof l == "object") {
        let [g, f] = Object.entries(l)[0];
        p[g] = f;
      } else
        p.legendText = l;
    if (d != null)
      if (typeof d == "object") {
        let [g, f] = Object.entries(d)[0];
        p[g] = f;
      } else
        p.legendSprite = d;
  }
}, "updateElStyle"), k6 = /* @__PURE__ */ u(function(e, t, r, i, s, a, n) {
  const o = tn.find((h) => h.from === t && h.to === r);
  if (o !== void 0) {
    if (i != null)
      if (typeof i == "object") {
        let [h, l] = Object.entries(i)[0];
        o[h] = l;
      } else
        o.textColor = i;
    if (s != null)
      if (typeof s == "object") {
        let [h, l] = Object.entries(s)[0];
        o[h] = l;
      } else
        o.lineColor = s;
    if (a != null)
      if (typeof a == "object") {
        let [h, l] = Object.entries(a)[0];
        o[h] = parseInt(l);
      } else
        o.offsetX = parseInt(a);
    if (n != null)
      if (typeof n == "object") {
        let [h, l] = Object.entries(n)[0];
        o[h] = parseInt(l);
      } else
        o.offsetY = parseInt(n);
  }
}, "updateRelStyle"), v6 = /* @__PURE__ */ u(function(e, t, r) {
  let i = ao, s = no;
  if (typeof t == "object") {
    const a = Object.values(t)[0];
    i = parseInt(a);
  } else
    i = parseInt(t);
  if (typeof r == "object") {
    const a = Object.values(r)[0];
    s = parseInt(a);
  } else
    s = parseInt(r);
  i >= 1 && (ao = i), s >= 1 && (no = s);
}, "updateLayoutConfig"), S6 = /* @__PURE__ */ u(function() {
  return ao;
}, "getC4ShapeInRow"), C6 = /* @__PURE__ */ u(function() {
  return no;
}, "getC4BoundaryInRow"), w6 = /* @__PURE__ */ u(function() {
  return pr;
}, "getCurrentBoundaryParse"), T6 = /* @__PURE__ */ u(function() {
  return $r;
}, "getParentBoundaryParse"), wf = /* @__PURE__ */ u(function(e) {
  return e == null ? zr : zr.filter((t) => t.parentBoundary === e);
}, "getC4ShapeArray"), _6 = /* @__PURE__ */ u(function(e) {
  return zr.find((t) => t.alias === e);
}, "getC4Shape"), E6 = /* @__PURE__ */ u(function(e) {
  return Object.keys(wf(e));
}, "getC4ShapeKeys"), Tf = /* @__PURE__ */ u(function(e) {
  return e == null ? Zr : Zr.filter((t) => t.parentBoundary === e);
}, "getBoundaries"), A6 = Tf, L6 = /* @__PURE__ */ u(function() {
  return tn;
}, "getRels"), B6 = /* @__PURE__ */ u(function() {
  return ih;
}, "getTitle"), D6 = /* @__PURE__ */ u(function(e) {
  sh = e;
}, "setWrap"), Oi = /* @__PURE__ */ u(function() {
  return sh;
}, "autoWrap"), I6 = /* @__PURE__ */ u(function() {
  zr = [], Zr = [
    {
      alias: "global",
      label: { text: "global" },
      type: { text: "global" },
      tags: null,
      link: null,
      parentBoundary: ""
    }
  ], $r = "", pr = "global", Ai = [""], tn = [], Ai = [""], ih = "", sh = !1, ao = 4, no = 2;
}, "clear"), F6 = {
  SOLID: 0,
  DOTTED: 1,
  NOTE: 2,
  SOLID_CROSS: 3,
  DOTTED_CROSS: 4,
  SOLID_OPEN: 5,
  DOTTED_OPEN: 6,
  LOOP_START: 10,
  LOOP_END: 11,
  ALT_START: 12,
  ALT_ELSE: 13,
  ALT_END: 14,
  OPT_START: 15,
  OPT_END: 16,
  ACTIVE_START: 17,
  ACTIVE_END: 18,
  PAR_START: 19,
  PAR_AND: 20,
  PAR_END: 21,
  RECT_START: 22,
  RECT_END: 23,
  SOLID_POINT: 24,
  DOTTED_POINT: 25
}, N6 = {
  FILLED: 0,
  OPEN: 1
}, R6 = {
  LEFTOF: 0,
  RIGHTOF: 1,
  OVER: 2
}, M6 = /* @__PURE__ */ u(function(e) {
  ih = ge(e, K());
}, "setTitle"), Wl = {
  addPersonOrSystem: d6,
  addPersonOrSystemBoundary: f6,
  addContainer: p6,
  addContainerBoundary: y6,
  addComponent: g6,
  addDeploymentNode: m6,
  popBoundaryParseStack: x6,
  addRel: u6,
  updateElStyle: b6,
  updateRelStyle: k6,
  updateLayoutConfig: v6,
  autoWrap: Oi,
  setWrap: D6,
  getC4ShapeArray: wf,
  getC4Shape: _6,
  getC4ShapeKeys: E6,
  getBoundaries: Tf,
  getBoundarys: A6,
  getCurrentBoundaryParse: w6,
  getParentBoundaryParse: T6,
  getRels: L6,
  getTitle: B6,
  getC4Type: c6,
  getC4ShapeInRow: S6,
  getC4BoundaryInRow: C6,
  setAccTitle: Re,
  getAccTitle: qe,
  getAccDescription: He,
  setAccDescription: Ye,
  getConfig: /* @__PURE__ */ u(() => K().c4, "getConfig"),
  clear: I6,
  LINETYPE: F6,
  ARROWTYPE: N6,
  PLACEMENT: R6,
  setTitle: M6,
  setC4Type: h6
  // apply,
}, ah = /* @__PURE__ */ u(function(e, t) {
  return $o(e, t);
}, "drawRect"), _f = /* @__PURE__ */ u(function(e, t, r, i, s, a) {
  const n = e.append("image");
  n.attr("width", t), n.attr("height", r), n.attr("x", i), n.attr("y", s);
  let o = a.startsWith("data:image/png;base64") ? a : ns(a);
  n.attr("xlink:href", o);
}, "drawImage"), O6 = /* @__PURE__ */ u((e, t, r) => {
  const i = e.append("g");
  let s = 0;
  for (let a of t) {
    let n = a.textColor ? a.textColor : "#444444", o = a.lineColor ? a.lineColor : "#444444", h = a.offsetX ? parseInt(a.offsetX) : 0, l = a.offsetY ? parseInt(a.offsetY) : 0, d = "";
    if (s === 0) {
      let g = i.append("line");
      g.attr("x1", a.startPoint.x), g.attr("y1", a.startPoint.y), g.attr("x2", a.endPoint.x), g.attr("y2", a.endPoint.y), g.attr("stroke-width", "1"), g.attr("stroke", o), g.style("fill", "none"), a.type !== "rel_b" && g.attr("marker-end", "url(" + d + "#arrowhead)"), (a.type === "birel" || a.type === "rel_b") && g.attr("marker-start", "url(" + d + "#arrowend)"), s = -1;
    } else {
      let g = i.append("path");
      g.attr("fill", "none").attr("stroke-width", "1").attr("stroke", o).attr(
        "d",
        "Mstartx,starty Qcontrolx,controly stopx,stopy ".replaceAll("startx", a.startPoint.x).replaceAll("starty", a.startPoint.y).replaceAll(
          "controlx",
          a.startPoint.x + (a.endPoint.x - a.startPoint.x) / 2 - (a.endPoint.x - a.startPoint.x) / 4
        ).replaceAll("controly", a.startPoint.y + (a.endPoint.y - a.startPoint.y) / 2).replaceAll("stopx", a.endPoint.x).replaceAll("stopy", a.endPoint.y)
      ), a.type !== "rel_b" && g.attr("marker-end", "url(" + d + "#arrowhead)"), (a.type === "birel" || a.type === "rel_b") && g.attr("marker-start", "url(" + d + "#arrowend)");
    }
    let p = r.messageFont();
    pi(r)(
      a.label.text,
      i,
      Math.min(a.startPoint.x, a.endPoint.x) + Math.abs(a.endPoint.x - a.startPoint.x) / 2 + h,
      Math.min(a.startPoint.y, a.endPoint.y) + Math.abs(a.endPoint.y - a.startPoint.y) / 2 + l,
      a.label.width,
      a.label.height,
      { fill: n },
      p
    ), a.techn && a.techn.text !== "" && (p = r.messageFont(), pi(r)(
      "[" + a.techn.text + "]",
      i,
      Math.min(a.startPoint.x, a.endPoint.x) + Math.abs(a.endPoint.x - a.startPoint.x) / 2 + h,
      Math.min(a.startPoint.y, a.endPoint.y) + Math.abs(a.endPoint.y - a.startPoint.y) / 2 + r.messageFontSize + 5 + l,
      Math.max(a.label.width, a.techn.width),
      a.techn.height,
      { fill: n, "font-style": "italic" },
      p
    ));
  }
}, "drawRels"), P6 = /* @__PURE__ */ u(function(e, t, r) {
  const i = e.append("g");
  let s = t.bgColor ? t.bgColor : "none", a = t.borderColor ? t.borderColor : "#444444", n = t.fontColor ? t.fontColor : "black", o = { "stroke-width": 1, "stroke-dasharray": "7.0,7.0" };
  t.nodeType && (o = { "stroke-width": 1 });
  let h = {
    x: t.x,
    y: t.y,
    fill: s,
    stroke: a,
    width: t.width,
    height: t.height,
    rx: 2.5,
    ry: 2.5,
    attrs: o
  };
  ah(i, h);
  let l = r.boundaryFont();
  l.fontWeight = "bold", l.fontSize = l.fontSize + 2, l.fontColor = n, pi(r)(
    t.label.text,
    i,
    t.x,
    t.y + t.label.Y,
    t.width,
    t.height,
    { fill: "#444444" },
    l
  ), t.type && t.type.text !== "" && (l = r.boundaryFont(), l.fontColor = n, pi(r)(
    t.type.text,
    i,
    t.x,
    t.y + t.type.Y,
    t.width,
    t.height,
    { fill: "#444444" },
    l
  )), t.descr && t.descr.text !== "" && (l = r.boundaryFont(), l.fontSize = l.fontSize - 2, l.fontColor = n, pi(r)(
    t.descr.text,
    i,
    t.x,
    t.y + t.descr.Y,
    t.width,
    t.height,
    { fill: "#444444" },
    l
  ));
}, "drawBoundary"), $6 = /* @__PURE__ */ u(function(e, t, r) {
  var p;
  let i = t.bgColor ? t.bgColor : r[t.typeC4Shape.text + "_bg_color"], s = t.borderColor ? t.borderColor : r[t.typeC4Shape.text + "_border_color"], a = t.fontColor ? t.fontColor : "#FFFFFF", n = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAIAAADYYG7QAAACD0lEQVR4Xu2YoU4EMRCGT+4j8Ai8AhaH4QHgAUjQuFMECUgMIUgwJAgMhgQsAYUiJCiQIBBY+EITsjfTdme6V24v4c8vyGbb+ZjOtN0bNcvjQXmkH83WvYBWto6PLm6v7p7uH1/w2fXD+PBycX1Pv2l3IdDm/vn7x+dXQiAubRzoURa7gRZWd0iGRIiJbOnhnfYBQZNJjNbuyY2eJG8fkDE3bbG4ep6MHUAsgYxmE3nVs6VsBWJSGccsOlFPmLIViMzLOB7pCVO2AtHJMohH7Fh6zqitQK7m0rJvAVYgGcEpe//PLdDz65sM4pF9N7ICcXDKIB5Nv6j7tD0NoSdM2QrU9Gg0ewE1LqBhHR3BBdvj2vapnidjHxD/q6vd7Pvhr31AwcY8eXMTXAKECZZJFXuEq27aLgQK5uLMohCenGGuGewOxSjBvYBqeG6B+Nqiblggdjnc+ZXDy+FNFpFzw76O3UBAROuXh6FoiAcf5g9eTvUgzy0nWg6I8cXHRUpg5bOVBCo+KDpFajOf23GgPme7RSQ+lacIENUgJ6gg1k6HjgOlqnLqip4tEuhv0hNEMXUD0clyXE3p6pZA0S2nnvTlXwLJEZWlb7cTQH1+USgTN4VhAenm/wea1OCAOmqo6fE1WCb9WSKBah+rbUWPWAmE2Rvk0ApiB45eOyNAzU8xcTvj8KvkKEoOaIYeHNA3ZuygAvFMUO0AAAAASUVORK5CYII=";
  switch (t.typeC4Shape.text) {
    case "person":
      n = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAIAAADYYG7QAAACD0lEQVR4Xu2YoU4EMRCGT+4j8Ai8AhaH4QHgAUjQuFMECUgMIUgwJAgMhgQsAYUiJCiQIBBY+EITsjfTdme6V24v4c8vyGbb+ZjOtN0bNcvjQXmkH83WvYBWto6PLm6v7p7uH1/w2fXD+PBycX1Pv2l3IdDm/vn7x+dXQiAubRzoURa7gRZWd0iGRIiJbOnhnfYBQZNJjNbuyY2eJG8fkDE3bbG4ep6MHUAsgYxmE3nVs6VsBWJSGccsOlFPmLIViMzLOB7pCVO2AtHJMohH7Fh6zqitQK7m0rJvAVYgGcEpe//PLdDz65sM4pF9N7ICcXDKIB5Nv6j7tD0NoSdM2QrU9Gg0ewE1LqBhHR3BBdvj2vapnidjHxD/q6vd7Pvhr31AwcY8eXMTXAKECZZJFXuEq27aLgQK5uLMohCenGGuGewOxSjBvYBqeG6B+Nqiblggdjnc+ZXDy+FNFpFzw76O3UBAROuXh6FoiAcf5g9eTvUgzy0nWg6I8cXHRUpg5bOVBCo+KDpFajOf23GgPme7RSQ+lacIENUgJ6gg1k6HjgOlqnLqip4tEuhv0hNEMXUD0clyXE3p6pZA0S2nnvTlXwLJEZWlb7cTQH1+USgTN4VhAenm/wea1OCAOmqo6fE1WCb9WSKBah+rbUWPWAmE2Rvk0ApiB45eOyNAzU8xcTvj8KvkKEoOaIYeHNA3ZuygAvFMUO0AAAAASUVORK5CYII=";
      break;
    case "external_person":
      n = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAIAAADYYG7QAAAB6ElEQVR4Xu2YLY+EMBCG9+dWr0aj0Wg0Go1Go0+j8Xdv2uTCvv1gpt0ebHKPuhDaeW4605Z9mJvx4AdXUyTUdd08z+u6flmWZRnHsWkafk9DptAwDPu+f0eAYtu2PEaGWuj5fCIZrBAC2eLBAnRCsEkkxmeaJp7iDJ2QMDdHsLg8SxKFEJaAo8lAXnmuOFIhTMpxxKATebo4UiFknuNo4OniSIXQyRxEA3YsnjGCVEjVXD7yLUAqxBGUyPv/Y4W2beMgGuS7kVQIBycH0fD+oi5pezQETxdHKmQKGk1eQEYldK+jw5GxPfZ9z7Mk0Qnhf1W1m3w//EUn5BDmSZsbR44QQLBEqrBHqOrmSKaQAxdnLArCrxZcM7A7ZKs4ioRq8LFC+NpC3WCBJsvpVw5edm9iEXFuyNfxXAgSwfrFQ1c0iNda8AdejvUgnktOtJQQxmcfFzGglc5WVCj7oDgFqU18boeFSs52CUh8LE8BIVQDT1ABrB0HtgSEYlX5doJnCwv9TXocKCaKbnwhdDKPq4lf3SwU3HLq4V/+WYhHVMa/3b4IlfyikAduCkcBc7mQ3/z/Qq/cTuikhkzB12Ae/mcJC9U+Vo8Ej1gWAtgbeGgFsAMHr50BIWOLCbezvhpBFUdY6EJuJ/QDW0XoMX60zZ0AAAAASUVORK5CYII=";
      break;
  }
  const o = e.append("g");
  o.attr("class", "person-man");
  const h = Er();
  switch (t.typeC4Shape.text) {
    case "person":
    case "external_person":
    case "system":
    case "external_system":
    case "container":
    case "external_container":
    case "component":
    case "external_component":
      h.x = t.x, h.y = t.y, h.fill = i, h.width = t.width, h.height = t.height, h.stroke = s, h.rx = 2.5, h.ry = 2.5, h.attrs = { "stroke-width": 0.5 }, ah(o, h);
      break;
    case "system_db":
    case "external_system_db":
    case "container_db":
    case "external_container_db":
    case "component_db":
    case "external_component_db":
      o.append("path").attr("fill", i).attr("stroke-width", "0.5").attr("stroke", s).attr(
        "d",
        "Mstartx,startyc0,-10 half,-10 half,-10c0,0 half,0 half,10l0,heightc0,10 -half,10 -half,10c0,0 -half,0 -half,-10l0,-height".replaceAll("startx", t.x).replaceAll("starty", t.y).replaceAll("half", t.width / 2).replaceAll("height", t.height)
      ), o.append("path").attr("fill", "none").attr("stroke-width", "0.5").attr("stroke", s).attr(
        "d",
        "Mstartx,startyc0,10 half,10 half,10c0,0 half,0 half,-10".replaceAll("startx", t.x).replaceAll("starty", t.y).replaceAll("half", t.width / 2)
      );
      break;
    case "system_queue":
    case "external_system_queue":
    case "container_queue":
    case "external_container_queue":
    case "component_queue":
    case "external_component_queue":
      o.append("path").attr("fill", i).attr("stroke-width", "0.5").attr("stroke", s).attr(
        "d",
        "Mstartx,startylwidth,0c5,0 5,half 5,halfc0,0 0,half -5,halfl-width,0c-5,0 -5,-half -5,-halfc0,0 0,-half 5,-half".replaceAll("startx", t.x).replaceAll("starty", t.y).replaceAll("width", t.width).replaceAll("half", t.height / 2)
      ), o.append("path").attr("fill", "none").attr("stroke-width", "0.5").attr("stroke", s).attr(
        "d",
        "Mstartx,startyc-5,0 -5,half -5,halfc0,half 5,half 5,half".replaceAll("startx", t.x + t.width).replaceAll("starty", t.y).replaceAll("half", t.height / 2)
      );
      break;
  }
  let l = G6(r, t.typeC4Shape.text);
  switch (o.append("text").attr("fill", a).attr("font-family", l.fontFamily).attr("font-size", l.fontSize - 2).attr("font-style", "italic").attr("lengthAdjust", "spacing").attr("textLength", t.typeC4Shape.width).attr("x", t.x + t.width / 2 - t.typeC4Shape.width / 2).attr("y", t.y + t.typeC4Shape.Y).text("<<" + t.typeC4Shape.text + ">>"), t.typeC4Shape.text) {
    case "person":
    case "external_person":
      _f(
        o,
        48,
        48,
        t.x + t.width / 2 - 24,
        t.y + t.image.Y,
        n
      );
      break;
  }
  let d = r[t.typeC4Shape.text + "Font"]();
  return d.fontWeight = "bold", d.fontSize = d.fontSize + 2, d.fontColor = a, pi(r)(
    t.label.text,
    o,
    t.x,
    t.y + t.label.Y,
    t.width,
    t.height,
    { fill: a },
    d
  ), d = r[t.typeC4Shape.text + "Font"](), d.fontColor = a, t.techn && ((p = t.techn) == null ? void 0 : p.text) !== "" ? pi(r)(
    t.techn.text,
    o,
    t.x,
    t.y + t.techn.Y,
    t.width,
    t.height,
    { fill: a, "font-style": "italic" },
    d
  ) : t.type && t.type.text !== "" && pi(r)(
    t.type.text,
    o,
    t.x,
    t.y + t.type.Y,
    t.width,
    t.height,
    { fill: a, "font-style": "italic" },
    d
  ), t.descr && t.descr.text !== "" && (d = r.personFont(), d.fontColor = a, pi(r)(
    t.descr.text,
    o,
    t.x,
    t.y + t.descr.Y,
    t.width,
    t.height,
    { fill: a },
    d
  )), t.height;
}, "drawC4Shape"), V6 = /* @__PURE__ */ u(function(e) {
  e.append("defs").append("symbol").attr("id", "database").attr("fill-rule", "evenodd").attr("clip-rule", "evenodd").append("path").attr("transform", "scale(.5)").attr(
    "d",
    "M12.258.001l.256.004.255.005.253.008.251.01.249.012.247.015.246.016.242.019.241.02.239.023.236.024.233.027.231.028.229.031.225.032.223.034.22.036.217.038.214.04.211.041.208.043.205.045.201.046.198.048.194.05.191.051.187.053.183.054.18.056.175.057.172.059.168.06.163.061.16.063.155.064.15.066.074.033.073.033.071.034.07.034.069.035.068.035.067.035.066.035.064.036.064.036.062.036.06.036.06.037.058.037.058.037.055.038.055.038.053.038.052.038.051.039.05.039.048.039.047.039.045.04.044.04.043.04.041.04.04.041.039.041.037.041.036.041.034.041.033.042.032.042.03.042.029.042.027.042.026.043.024.043.023.043.021.043.02.043.018.044.017.043.015.044.013.044.012.044.011.045.009.044.007.045.006.045.004.045.002.045.001.045v17l-.001.045-.002.045-.004.045-.006.045-.007.045-.009.044-.011.045-.012.044-.013.044-.015.044-.017.043-.018.044-.02.043-.021.043-.023.043-.024.043-.026.043-.027.042-.029.042-.03.042-.032.042-.033.042-.034.041-.036.041-.037.041-.039.041-.04.041-.041.04-.043.04-.044.04-.045.04-.047.039-.048.039-.05.039-.051.039-.052.038-.053.038-.055.038-.055.038-.058.037-.058.037-.06.037-.06.036-.062.036-.064.036-.064.036-.066.035-.067.035-.068.035-.069.035-.07.034-.071.034-.073.033-.074.033-.15.066-.155.064-.16.063-.163.061-.168.06-.172.059-.175.057-.18.056-.183.054-.187.053-.191.051-.194.05-.198.048-.201.046-.205.045-.208.043-.211.041-.214.04-.217.038-.22.036-.223.034-.225.032-.229.031-.231.028-.233.027-.236.024-.239.023-.241.02-.242.019-.246.016-.247.015-.249.012-.251.01-.253.008-.255.005-.256.004-.258.001-.258-.001-.256-.004-.255-.005-.253-.008-.251-.01-.249-.012-.247-.015-.245-.016-.243-.019-.241-.02-.238-.023-.236-.024-.234-.027-.231-.028-.228-.031-.226-.032-.223-.034-.22-.036-.217-.038-.214-.04-.211-.041-.208-.043-.204-.045-.201-.046-.198-.048-.195-.05-.19-.051-.187-.053-.184-.054-.179-.056-.176-.057-.172-.059-.167-.06-.164-.061-.159-.063-.155-.064-.151-.066-.074-.033-.072-.033-.072-.034-.07-.034-.069-.035-.068-.035-.067-.035-.066-.035-.064-.036-.063-.036-.062-.036-.061-.036-.06-.037-.058-.037-.057-.037-.056-.038-.055-.038-.053-.038-.052-.038-.051-.039-.049-.039-.049-.039-.046-.039-.046-.04-.044-.04-.043-.04-.041-.04-.04-.041-.039-.041-.037-.041-.036-.041-.034-.041-.033-.042-.032-.042-.03-.042-.029-.042-.027-.042-.026-.043-.024-.043-.023-.043-.021-.043-.02-.043-.018-.044-.017-.043-.015-.044-.013-.044-.012-.044-.011-.045-.009-.044-.007-.045-.006-.045-.004-.045-.002-.045-.001-.045v-17l.001-.045.002-.045.004-.045.006-.045.007-.045.009-.044.011-.045.012-.044.013-.044.015-.044.017-.043.018-.044.02-.043.021-.043.023-.043.024-.043.026-.043.027-.042.029-.042.03-.042.032-.042.033-.042.034-.041.036-.041.037-.041.039-.041.04-.041.041-.04.043-.04.044-.04.046-.04.046-.039.049-.039.049-.039.051-.039.052-.038.053-.038.055-.038.056-.038.057-.037.058-.037.06-.037.061-.036.062-.036.063-.036.064-.036.066-.035.067-.035.068-.035.069-.035.07-.034.072-.034.072-.033.074-.033.151-.066.155-.064.159-.063.164-.061.167-.06.172-.059.176-.057.179-.056.184-.054.187-.053.19-.051.195-.05.198-.048.201-.046.204-.045.208-.043.211-.041.214-.04.217-.038.22-.036.223-.034.226-.032.228-.031.231-.028.234-.027.236-.024.238-.023.241-.02.243-.019.245-.016.247-.015.249-.012.251-.01.253-.008.255-.005.256-.004.258-.001.258.001zm-9.258 20.499v.01l.001.021.003.021.004.022.005.021.006.022.007.022.009.023.01.022.011.023.012.023.013.023.015.023.016.024.017.023.018.024.019.024.021.024.022.025.023.024.024.025.052.049.056.05.061.051.066.051.07.051.075.051.079.052.084.052.088.052.092.052.097.052.102.051.105.052.11.052.114.051.119.051.123.051.127.05.131.05.135.05.139.048.144.049.147.047.152.047.155.047.16.045.163.045.167.043.171.043.176.041.178.041.183.039.187.039.19.037.194.035.197.035.202.033.204.031.209.03.212.029.216.027.219.025.222.024.226.021.23.02.233.018.236.016.24.015.243.012.246.01.249.008.253.005.256.004.259.001.26-.001.257-.004.254-.005.25-.008.247-.011.244-.012.241-.014.237-.016.233-.018.231-.021.226-.021.224-.024.22-.026.216-.027.212-.028.21-.031.205-.031.202-.034.198-.034.194-.036.191-.037.187-.039.183-.04.179-.04.175-.042.172-.043.168-.044.163-.045.16-.046.155-.046.152-.047.148-.048.143-.049.139-.049.136-.05.131-.05.126-.05.123-.051.118-.052.114-.051.11-.052.106-.052.101-.052.096-.052.092-.052.088-.053.083-.051.079-.052.074-.052.07-.051.065-.051.06-.051.056-.05.051-.05.023-.024.023-.025.021-.024.02-.024.019-.024.018-.024.017-.024.015-.023.014-.024.013-.023.012-.023.01-.023.01-.022.008-.022.006-.022.006-.022.004-.022.004-.021.001-.021.001-.021v-4.127l-.077.055-.08.053-.083.054-.085.053-.087.052-.09.052-.093.051-.095.05-.097.05-.1.049-.102.049-.105.048-.106.047-.109.047-.111.046-.114.045-.115.045-.118.044-.12.043-.122.042-.124.042-.126.041-.128.04-.13.04-.132.038-.134.038-.135.037-.138.037-.139.035-.142.035-.143.034-.144.033-.147.032-.148.031-.15.03-.151.03-.153.029-.154.027-.156.027-.158.026-.159.025-.161.024-.162.023-.163.022-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.011-.178.01-.179.008-.179.008-.181.006-.182.005-.182.004-.184.003-.184.002h-.37l-.184-.002-.184-.003-.182-.004-.182-.005-.181-.006-.179-.008-.179-.008-.178-.01-.176-.011-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.022-.162-.023-.161-.024-.159-.025-.157-.026-.156-.027-.155-.027-.153-.029-.151-.03-.15-.03-.148-.031-.146-.032-.145-.033-.143-.034-.141-.035-.14-.035-.137-.037-.136-.037-.134-.038-.132-.038-.13-.04-.128-.04-.126-.041-.124-.042-.122-.042-.12-.044-.117-.043-.116-.045-.113-.045-.112-.046-.109-.047-.106-.047-.105-.048-.102-.049-.1-.049-.097-.05-.095-.05-.093-.052-.09-.051-.087-.052-.085-.053-.083-.054-.08-.054-.077-.054v4.127zm0-5.654v.011l.001.021.003.021.004.021.005.022.006.022.007.022.009.022.01.022.011.023.012.023.013.023.015.024.016.023.017.024.018.024.019.024.021.024.022.024.023.025.024.024.052.05.056.05.061.05.066.051.07.051.075.052.079.051.084.052.088.052.092.052.097.052.102.052.105.052.11.051.114.051.119.052.123.05.127.051.131.05.135.049.139.049.144.048.147.048.152.047.155.046.16.045.163.045.167.044.171.042.176.042.178.04.183.04.187.038.19.037.194.036.197.034.202.033.204.032.209.03.212.028.216.027.219.025.222.024.226.022.23.02.233.018.236.016.24.014.243.012.246.01.249.008.253.006.256.003.259.001.26-.001.257-.003.254-.006.25-.008.247-.01.244-.012.241-.015.237-.016.233-.018.231-.02.226-.022.224-.024.22-.025.216-.027.212-.029.21-.03.205-.032.202-.033.198-.035.194-.036.191-.037.187-.039.183-.039.179-.041.175-.042.172-.043.168-.044.163-.045.16-.045.155-.047.152-.047.148-.048.143-.048.139-.05.136-.049.131-.05.126-.051.123-.051.118-.051.114-.052.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.051.07-.052.065-.051.06-.05.056-.051.051-.049.023-.025.023-.024.021-.025.02-.024.019-.024.018-.024.017-.024.015-.023.014-.023.013-.024.012-.022.01-.023.01-.023.008-.022.006-.022.006-.022.004-.021.004-.022.001-.021.001-.021v-4.139l-.077.054-.08.054-.083.054-.085.052-.087.053-.09.051-.093.051-.095.051-.097.05-.1.049-.102.049-.105.048-.106.047-.109.047-.111.046-.114.045-.115.044-.118.044-.12.044-.122.042-.124.042-.126.041-.128.04-.13.039-.132.039-.134.038-.135.037-.138.036-.139.036-.142.035-.143.033-.144.033-.147.033-.148.031-.15.03-.151.03-.153.028-.154.028-.156.027-.158.026-.159.025-.161.024-.162.023-.163.022-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.011-.178.009-.179.009-.179.007-.181.007-.182.005-.182.004-.184.003-.184.002h-.37l-.184-.002-.184-.003-.182-.004-.182-.005-.181-.007-.179-.007-.179-.009-.178-.009-.176-.011-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.022-.162-.023-.161-.024-.159-.025-.157-.026-.156-.027-.155-.028-.153-.028-.151-.03-.15-.03-.148-.031-.146-.033-.145-.033-.143-.033-.141-.035-.14-.036-.137-.036-.136-.037-.134-.038-.132-.039-.13-.039-.128-.04-.126-.041-.124-.042-.122-.043-.12-.043-.117-.044-.116-.044-.113-.046-.112-.046-.109-.046-.106-.047-.105-.048-.102-.049-.1-.049-.097-.05-.095-.051-.093-.051-.09-.051-.087-.053-.085-.052-.083-.054-.08-.054-.077-.054v4.139zm0-5.666v.011l.001.02.003.022.004.021.005.022.006.021.007.022.009.023.01.022.011.023.012.023.013.023.015.023.016.024.017.024.018.023.019.024.021.025.022.024.023.024.024.025.052.05.056.05.061.05.066.051.07.051.075.052.079.051.084.052.088.052.092.052.097.052.102.052.105.051.11.052.114.051.119.051.123.051.127.05.131.05.135.05.139.049.144.048.147.048.152.047.155.046.16.045.163.045.167.043.171.043.176.042.178.04.183.04.187.038.19.037.194.036.197.034.202.033.204.032.209.03.212.028.216.027.219.025.222.024.226.021.23.02.233.018.236.017.24.014.243.012.246.01.249.008.253.006.256.003.259.001.26-.001.257-.003.254-.006.25-.008.247-.01.244-.013.241-.014.237-.016.233-.018.231-.02.226-.022.224-.024.22-.025.216-.027.212-.029.21-.03.205-.032.202-.033.198-.035.194-.036.191-.037.187-.039.183-.039.179-.041.175-.042.172-.043.168-.044.163-.045.16-.045.155-.047.152-.047.148-.048.143-.049.139-.049.136-.049.131-.051.126-.05.123-.051.118-.052.114-.051.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.052.07-.051.065-.051.06-.051.056-.05.051-.049.023-.025.023-.025.021-.024.02-.024.019-.024.018-.024.017-.024.015-.023.014-.024.013-.023.012-.023.01-.022.01-.023.008-.022.006-.022.006-.022.004-.022.004-.021.001-.021.001-.021v-4.153l-.077.054-.08.054-.083.053-.085.053-.087.053-.09.051-.093.051-.095.051-.097.05-.1.049-.102.048-.105.048-.106.048-.109.046-.111.046-.114.046-.115.044-.118.044-.12.043-.122.043-.124.042-.126.041-.128.04-.13.039-.132.039-.134.038-.135.037-.138.036-.139.036-.142.034-.143.034-.144.033-.147.032-.148.032-.15.03-.151.03-.153.028-.154.028-.156.027-.158.026-.159.024-.161.024-.162.023-.163.023-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.01-.178.01-.179.009-.179.007-.181.006-.182.006-.182.004-.184.003-.184.001-.185.001-.185-.001-.184-.001-.184-.003-.182-.004-.182-.006-.181-.006-.179-.007-.179-.009-.178-.01-.176-.01-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.023-.162-.023-.161-.024-.159-.024-.157-.026-.156-.027-.155-.028-.153-.028-.151-.03-.15-.03-.148-.032-.146-.032-.145-.033-.143-.034-.141-.034-.14-.036-.137-.036-.136-.037-.134-.038-.132-.039-.13-.039-.128-.041-.126-.041-.124-.041-.122-.043-.12-.043-.117-.044-.116-.044-.113-.046-.112-.046-.109-.046-.106-.048-.105-.048-.102-.048-.1-.05-.097-.049-.095-.051-.093-.051-.09-.052-.087-.052-.085-.053-.083-.053-.08-.054-.077-.054v4.153zm8.74-8.179l-.257.004-.254.005-.25.008-.247.011-.244.012-.241.014-.237.016-.233.018-.231.021-.226.022-.224.023-.22.026-.216.027-.212.028-.21.031-.205.032-.202.033-.198.034-.194.036-.191.038-.187.038-.183.04-.179.041-.175.042-.172.043-.168.043-.163.045-.16.046-.155.046-.152.048-.148.048-.143.048-.139.049-.136.05-.131.05-.126.051-.123.051-.118.051-.114.052-.11.052-.106.052-.101.052-.096.052-.092.052-.088.052-.083.052-.079.052-.074.051-.07.052-.065.051-.06.05-.056.05-.051.05-.023.025-.023.024-.021.024-.02.025-.019.024-.018.024-.017.023-.015.024-.014.023-.013.023-.012.023-.01.023-.01.022-.008.022-.006.023-.006.021-.004.022-.004.021-.001.021-.001.021.001.021.001.021.004.021.004.022.006.021.006.023.008.022.01.022.01.023.012.023.013.023.014.023.015.024.017.023.018.024.019.024.02.025.021.024.023.024.023.025.051.05.056.05.06.05.065.051.07.052.074.051.079.052.083.052.088.052.092.052.096.052.101.052.106.052.11.052.114.052.118.051.123.051.126.051.131.05.136.05.139.049.143.048.148.048.152.048.155.046.16.046.163.045.168.043.172.043.175.042.179.041.183.04.187.038.191.038.194.036.198.034.202.033.205.032.21.031.212.028.216.027.22.026.224.023.226.022.231.021.233.018.237.016.241.014.244.012.247.011.25.008.254.005.257.004.26.001.26-.001.257-.004.254-.005.25-.008.247-.011.244-.012.241-.014.237-.016.233-.018.231-.021.226-.022.224-.023.22-.026.216-.027.212-.028.21-.031.205-.032.202-.033.198-.034.194-.036.191-.038.187-.038.183-.04.179-.041.175-.042.172-.043.168-.043.163-.045.16-.046.155-.046.152-.048.148-.048.143-.048.139-.049.136-.05.131-.05.126-.051.123-.051.118-.051.114-.052.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.051.07-.052.065-.051.06-.05.056-.05.051-.05.023-.025.023-.024.021-.024.02-.025.019-.024.018-.024.017-.023.015-.024.014-.023.013-.023.012-.023.01-.023.01-.022.008-.022.006-.023.006-.021.004-.022.004-.021.001-.021.001-.021-.001-.021-.001-.021-.004-.021-.004-.022-.006-.021-.006-.023-.008-.022-.01-.022-.01-.023-.012-.023-.013-.023-.014-.023-.015-.024-.017-.023-.018-.024-.019-.024-.02-.025-.021-.024-.023-.024-.023-.025-.051-.05-.056-.05-.06-.05-.065-.051-.07-.052-.074-.051-.079-.052-.083-.052-.088-.052-.092-.052-.096-.052-.101-.052-.106-.052-.11-.052-.114-.052-.118-.051-.123-.051-.126-.051-.131-.05-.136-.05-.139-.049-.143-.048-.148-.048-.152-.048-.155-.046-.16-.046-.163-.045-.168-.043-.172-.043-.175-.042-.179-.041-.183-.04-.187-.038-.191-.038-.194-.036-.198-.034-.202-.033-.205-.032-.21-.031-.212-.028-.216-.027-.22-.026-.224-.023-.226-.022-.231-.021-.233-.018-.237-.016-.241-.014-.244-.012-.247-.011-.25-.008-.254-.005-.257-.004-.26-.001-.26.001z"
  );
}, "insertDatabaseIcon"), z6 = /* @__PURE__ */ u(function(e) {
  e.append("defs").append("symbol").attr("id", "computer").attr("width", "24").attr("height", "24").append("path").attr("transform", "scale(.5)").attr(
    "d",
    "M2 2v13h20v-13h-20zm18 11h-16v-9h16v9zm-10.228 6l.466-1h3.524l.467 1h-4.457zm14.228 3h-24l2-6h2.104l-1.33 4h18.45l-1.297-4h2.073l2 6zm-5-10h-14v-7h14v7z"
  );
}, "insertComputerIcon"), W6 = /* @__PURE__ */ u(function(e) {
  e.append("defs").append("symbol").attr("id", "clock").attr("width", "24").attr("height", "24").append("path").attr("transform", "scale(.5)").attr(
    "d",
    "M12 2c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm5.848 12.459c.202.038.202.333.001.372-1.907.361-6.045 1.111-6.547 1.111-.719 0-1.301-.582-1.301-1.301 0-.512.77-5.447 1.125-7.445.034-.192.312-.181.343.014l.985 6.238 5.394 1.011z"
  );
}, "insertClockIcon"), q6 = /* @__PURE__ */ u(function(e) {
  e.append("defs").append("marker").attr("id", "arrowhead").attr("refX", 9).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 0 0 L 10 5 L 0 10 z");
}, "insertArrowHead"), Y6 = /* @__PURE__ */ u(function(e) {
  e.append("defs").append("marker").attr("id", "arrowend").attr("refX", 1).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 10 0 L 0 5 L 10 10 z");
}, "insertArrowEnd"), H6 = /* @__PURE__ */ u(function(e) {
  e.append("defs").append("marker").attr("id", "filled-head").attr("refX", 18).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
}, "insertArrowFilledHead"), U6 = /* @__PURE__ */ u(function(e) {
  e.append("defs").append("marker").attr("id", "sequencenumber").attr("refX", 15).attr("refY", 15).attr("markerWidth", 60).attr("markerHeight", 40).attr("orient", "auto").append("circle").attr("cx", 15).attr("cy", 15).attr("r", 6);
}, "insertDynamicNumber"), j6 = /* @__PURE__ */ u(function(e) {
  const r = e.append("defs").append("marker").attr("id", "crosshead").attr("markerWidth", 15).attr("markerHeight", 8).attr("orient", "auto").attr("refX", 16).attr("refY", 4);
  r.append("path").attr("fill", "black").attr("stroke", "#000000").style("stroke-dasharray", "0, 0").attr("stroke-width", "1px").attr("d", "M 9,2 V 6 L16,4 Z"), r.append("path").attr("fill", "none").attr("stroke", "#000000").style("stroke-dasharray", "0, 0").attr("stroke-width", "1px").attr("d", "M 0,1 L 6,7 M 6,1 L 0,7");
}, "insertArrowCrossHead"), G6 = /* @__PURE__ */ u((e, t) => ({
  fontFamily: e[t + "FontFamily"],
  fontSize: e[t + "FontSize"],
  fontWeight: e[t + "FontWeight"]
}), "getC4ShapeFont"), pi = /* @__PURE__ */ function() {
  function e(s, a, n, o, h, l, d) {
    const p = a.append("text").attr("x", n + h / 2).attr("y", o + l / 2 + 5).style("text-anchor", "middle").text(s);
    i(p, d);
  }
  u(e, "byText");
  function t(s, a, n, o, h, l, d, p) {
    const { fontSize: g, fontFamily: f, fontWeight: y } = p, m = s.split(St.lineBreakRegex);
    for (let x = 0; x < m.length; x++) {
      const b = x * g - g * (m.length - 1) / 2, v = a.append("text").attr("x", n + h / 2).attr("y", o).style("text-anchor", "middle").attr("dominant-baseline", "middle").style("font-size", g).style("font-weight", y).style("font-family", f);
      v.append("tspan").attr("dy", b).text(m[x]).attr("alignment-baseline", "mathematical"), i(v, d);
    }
  }
  u(t, "byTspan");
  function r(s, a, n, o, h, l, d, p) {
    const g = a.append("switch"), y = g.append("foreignObject").attr("x", n).attr("y", o).attr("width", h).attr("height", l).append("xhtml:div").style("display", "table").style("height", "100%").style("width", "100%");
    y.append("div").style("display", "table-cell").style("text-align", "center").style("vertical-align", "middle").text(s), t(s, g, n, o, h, l, d, p), i(y, d);
  }
  u(r, "byFo");
  function i(s, a) {
    for (const n in a)
      a.hasOwnProperty(n) && s.attr(n, a[n]);
  }
  return u(i, "_setTextAttrs"), function(s) {
    return s.textPlacement === "fo" ? r : s.textPlacement === "old" ? e : t;
  };
}(), jr = {
  drawRect: ah,
  drawBoundary: P6,
  drawC4Shape: $6,
  drawRels: O6,
  drawImage: _f,
  insertArrowHead: q6,
  insertArrowEnd: Y6,
  insertArrowFilledHead: H6,
  insertDynamicNumber: U6,
  insertArrowCrossHead: j6,
  insertDatabaseIcon: V6,
  insertComputerIcon: z6,
  insertClockIcon: W6
}, oo = 0, lo = 0, Ef = 4, ql = 2;
so.yy = Wl;
var Vt = {}, Ps, Af = (Ps = class {
  constructor(t) {
    this.name = "", this.data = {}, this.data.startx = void 0, this.data.stopx = void 0, this.data.starty = void 0, this.data.stopy = void 0, this.data.widthLimit = void 0, this.nextData = {}, this.nextData.startx = void 0, this.nextData.stopx = void 0, this.nextData.starty = void 0, this.nextData.stopy = void 0, this.nextData.cnt = 0, Yl(t.db.getConfig());
  }
  setData(t, r, i, s) {
    this.nextData.startx = this.data.startx = t, this.nextData.stopx = this.data.stopx = r, this.nextData.starty = this.data.starty = i, this.nextData.stopy = this.data.stopy = s;
  }
  updateVal(t, r, i, s) {
    t[r] === void 0 ? t[r] = i : t[r] = s(i, t[r]);
  }
  insert(t) {
    this.nextData.cnt = this.nextData.cnt + 1;
    let r = this.nextData.startx === this.nextData.stopx ? this.nextData.stopx + t.margin : this.nextData.stopx + t.margin * 2, i = r + t.width, s = this.nextData.starty + t.margin * 2, a = s + t.height;
    (r >= this.data.widthLimit || i >= this.data.widthLimit || this.nextData.cnt > Ef) && (r = this.nextData.startx + t.margin + Vt.nextLinePaddingX, s = this.nextData.stopy + t.margin * 2, this.nextData.stopx = i = r + t.width, this.nextData.starty = this.nextData.stopy, this.nextData.stopy = a = s + t.height, this.nextData.cnt = 1), t.x = r, t.y = s, this.updateVal(this.data, "startx", r, Math.min), this.updateVal(this.data, "starty", s, Math.min), this.updateVal(this.data, "stopx", i, Math.max), this.updateVal(this.data, "stopy", a, Math.max), this.updateVal(this.nextData, "startx", r, Math.min), this.updateVal(this.nextData, "starty", s, Math.min), this.updateVal(this.nextData, "stopx", i, Math.max), this.updateVal(this.nextData, "stopy", a, Math.max);
  }
  init(t) {
    this.name = "", this.data = {
      startx: void 0,
      stopx: void 0,
      starty: void 0,
      stopy: void 0,
      widthLimit: void 0
    }, this.nextData = {
      startx: void 0,
      stopx: void 0,
      starty: void 0,
      stopy: void 0,
      cnt: 0
    }, Yl(t.db.getConfig());
  }
  bumpLastMargin(t) {
    this.data.stopx += t, this.data.stopy += t;
  }
}, u(Ps, "Bounds"), Ps), Yl = /* @__PURE__ */ u(function(e) {
  De(Vt, e), e.fontFamily && (Vt.personFontFamily = Vt.systemFontFamily = Vt.messageFontFamily = e.fontFamily), e.fontSize && (Vt.personFontSize = Vt.systemFontSize = Vt.messageFontSize = e.fontSize), e.fontWeight && (Vt.personFontWeight = Vt.systemFontWeight = Vt.messageFontWeight = e.fontWeight);
}, "setConf"), Aa = /* @__PURE__ */ u((e, t) => ({
  fontFamily: e[t + "FontFamily"],
  fontSize: e[t + "FontSize"],
  fontWeight: e[t + "FontWeight"]
}), "c4ShapeFont"), Rn = /* @__PURE__ */ u((e) => ({
  fontFamily: e.boundaryFontFamily,
  fontSize: e.boundaryFontSize,
  fontWeight: e.boundaryFontWeight
}), "boundaryFont"), X6 = /* @__PURE__ */ u((e) => ({
  fontFamily: e.messageFontFamily,
  fontSize: e.messageFontSize,
  fontWeight: e.messageFontWeight
}), "messageFont");
function Rr(e, t, r, i, s) {
  if (!t[e].width)
    if (r)
      t[e].text = L0(t[e].text, s, i), t[e].textLines = t[e].text.split(St.lineBreakRegex).length, t[e].width = s, t[e].height = Jn(t[e].text, i);
    else {
      let a = t[e].text.split(St.lineBreakRegex);
      t[e].textLines = a.length;
      let n = 0;
      t[e].height = 0, t[e].width = 0;
      for (const o of a)
        t[e].width = Math.max(
          dr(o, i),
          t[e].width
        ), n = Jn(o, i), t[e].height = t[e].height + n;
    }
}
u(Rr, "calcC4ShapeTextWH");
var Lf = /* @__PURE__ */ u(function(e, t, r) {
  t.x = r.data.startx, t.y = r.data.starty, t.width = r.data.stopx - r.data.startx, t.height = r.data.stopy - r.data.starty, t.label.y = Vt.c4ShapeMargin - 35;
  let i = t.wrap && Vt.wrap, s = Rn(Vt);
  s.fontSize = s.fontSize + 2, s.fontWeight = "bold";
  let a = dr(t.label.text, s);
  Rr("label", t, i, s, a), jr.drawBoundary(e, t, Vt);
}, "drawBoundary"), Bf = /* @__PURE__ */ u(function(e, t, r, i) {
  let s = 0;
  for (const a of i) {
    s = 0;
    const n = r[a];
    let o = Aa(Vt, n.typeC4Shape.text);
    switch (o.fontSize = o.fontSize - 2, n.typeC4Shape.width = dr(
      "" + n.typeC4Shape.text + "",
      o
    ), n.typeC4Shape.height = o.fontSize + 2, n.typeC4Shape.Y = Vt.c4ShapePadding, s = n.typeC4Shape.Y + n.typeC4Shape.height - 4, n.image = { width: 0, height: 0, Y: 0 }, n.typeC4Shape.text) {
      case "person":
      case "external_person":
        n.image.width = 48, n.image.height = 48, n.image.Y = s, s = n.image.Y + n.image.height;
        break;
    }
    n.sprite && (n.image.width = 48, n.image.height = 48, n.image.Y = s, s = n.image.Y + n.image.height);
    let h = n.wrap && Vt.wrap, l = Vt.width - Vt.c4ShapePadding * 2, d = Aa(Vt, n.typeC4Shape.text);
    if (d.fontSize = d.fontSize + 2, d.fontWeight = "bold", Rr("label", n, h, d, l), n.label.Y = s + 8, s = n.label.Y + n.label.height, n.type && n.type.text !== "") {
      n.type.text = "[" + n.type.text + "]";
      let f = Aa(Vt, n.typeC4Shape.text);
      Rr("type", n, h, f, l), n.type.Y = s + 5, s = n.type.Y + n.type.height;
    } else if (n.techn && n.techn.text !== "") {
      n.techn.text = "[" + n.techn.text + "]";
      let f = Aa(Vt, n.techn.text);
      Rr("techn", n, h, f, l), n.techn.Y = s + 5, s = n.techn.Y + n.techn.height;
    }
    let p = s, g = n.label.width;
    if (n.descr && n.descr.text !== "") {
      let f = Aa(Vt, n.typeC4Shape.text);
      Rr("descr", n, h, f, l), n.descr.Y = s + 20, s = n.descr.Y + n.descr.height, g = Math.max(n.label.width, n.descr.width), p = s - n.descr.textLines * 5;
    }
    g = g + Vt.c4ShapePadding, n.width = Math.max(n.width || Vt.width, g, Vt.width), n.height = Math.max(n.height || Vt.height, p, Vt.height), n.margin = n.margin || Vt.c4ShapeMargin, e.insert(n), jr.drawC4Shape(t, n, Vt);
  }
  e.bumpLastMargin(Vt.c4ShapeMargin);
}, "drawC4ShapeArray"), $s, Dr = ($s = class {
  constructor(t, r) {
    this.x = t, this.y = r;
  }
}, u($s, "Point"), $s), ku = /* @__PURE__ */ u(function(e, t) {
  let r = e.x, i = e.y, s = t.x, a = t.y, n = r + e.width / 2, o = i + e.height / 2, h = Math.abs(r - s), l = Math.abs(i - a), d = l / h, p = e.height / e.width, g = null;
  return i == a && r < s ? g = new Dr(r + e.width, o) : i == a && r > s ? g = new Dr(r, o) : r == s && i < a ? g = new Dr(n, i + e.height) : r == s && i > a && (g = new Dr(n, i)), r > s && i < a ? p >= d ? g = new Dr(r, o + d * e.width / 2) : g = new Dr(
    n - h / l * e.height / 2,
    i + e.height
  ) : r < s && i < a ? p >= d ? g = new Dr(r + e.width, o + d * e.width / 2) : g = new Dr(
    n + h / l * e.height / 2,
    i + e.height
  ) : r < s && i > a ? p >= d ? g = new Dr(r + e.width, o - d * e.width / 2) : g = new Dr(n + e.height / 2 * h / l, i) : r > s && i > a && (p >= d ? g = new Dr(r, o - e.width / 2 * d) : g = new Dr(n - e.height / 2 * h / l, i)), g;
}, "getIntersectPoint"), K6 = /* @__PURE__ */ u(function(e, t) {
  let r = { x: 0, y: 0 };
  r.x = t.x + t.width / 2, r.y = t.y + t.height / 2;
  let i = ku(e, r);
  r.x = e.x + e.width / 2, r.y = e.y + e.height / 2;
  let s = ku(t, r);
  return { startPoint: i, endPoint: s };
}, "getIntersectPoints"), Q6 = /* @__PURE__ */ u(function(e, t, r, i) {
  let s = 0;
  for (let a of t) {
    s = s + 1;
    let n = a.wrap && Vt.wrap, o = X6(Vt);
    i.db.getC4Type() === "C4Dynamic" && (a.label.text = s + ": " + a.label.text);
    let l = dr(a.label.text, o);
    Rr("label", a, n, o, l), a.techn && a.techn.text !== "" && (l = dr(a.techn.text, o), Rr("techn", a, n, o, l)), a.descr && a.descr.text !== "" && (l = dr(a.descr.text, o), Rr("descr", a, n, o, l));
    let d = r(a.from), p = r(a.to), g = K6(d, p);
    a.startPoint = g.startPoint, a.endPoint = g.endPoint;
  }
  jr.drawRels(e, t, Vt);
}, "drawRels");
function nh(e, t, r, i, s) {
  let a = new Af(s);
  a.data.widthLimit = r.data.widthLimit / Math.min(ql, i.length);
  for (let [n, o] of i.entries()) {
    let h = 0;
    o.image = { width: 0, height: 0, Y: 0 }, o.sprite && (o.image.width = 48, o.image.height = 48, o.image.Y = h, h = o.image.Y + o.image.height);
    let l = o.wrap && Vt.wrap, d = Rn(Vt);
    if (d.fontSize = d.fontSize + 2, d.fontWeight = "bold", Rr(
      "label",
      o,
      l,
      d,
      a.data.widthLimit
    ), o.label.Y = h + 8, h = o.label.Y + o.label.height, o.type && o.type.text !== "") {
      o.type.text = "[" + o.type.text + "]";
      let y = Rn(Vt);
      Rr(
        "type",
        o,
        l,
        y,
        a.data.widthLimit
      ), o.type.Y = h + 5, h = o.type.Y + o.type.height;
    }
    if (o.descr && o.descr.text !== "") {
      let y = Rn(Vt);
      y.fontSize = y.fontSize - 2, Rr(
        "descr",
        o,
        l,
        y,
        a.data.widthLimit
      ), o.descr.Y = h + 20, h = o.descr.Y + o.descr.height;
    }
    if (n == 0 || n % ql === 0) {
      let y = r.data.startx + Vt.diagramMarginX, m = r.data.stopy + Vt.diagramMarginY + h;
      a.setData(y, y, m, m);
    } else {
      let y = a.data.stopx !== a.data.startx ? a.data.stopx + Vt.diagramMarginX : a.data.startx, m = a.data.starty;
      a.setData(y, y, m, m);
    }
    a.name = o.alias;
    let p = s.db.getC4ShapeArray(o.alias), g = s.db.getC4ShapeKeys(o.alias);
    g.length > 0 && Bf(
      a,
      e,
      p,
      g
    ), t = o.alias;
    let f = s.db.getBoundaries(t);
    f.length > 0 && nh(
      e,
      t,
      a,
      f,
      s
    ), o.alias !== "global" && Lf(e, o, a), r.data.stopy = Math.max(
      a.data.stopy + Vt.c4ShapeMargin,
      r.data.stopy
    ), r.data.stopx = Math.max(
      a.data.stopx + Vt.c4ShapeMargin,
      r.data.stopx
    ), oo = Math.max(oo, r.data.stopx), lo = Math.max(lo, r.data.stopy);
  }
}
u(nh, "drawInsideBoundary");
var Z6 = /* @__PURE__ */ u(function(e, t, r, i) {
  Vt = K().c4;
  const s = K().securityLevel;
  let a;
  s === "sandbox" && (a = yt("#i" + t));
  const n = s === "sandbox" ? yt(a.nodes()[0].contentDocument.body) : yt("body");
  let o = i.db;
  i.db.setWrap(Vt.wrap), Ef = o.getC4ShapeInRow(), ql = o.getC4BoundaryInRow(), I.debug(`C:${JSON.stringify(Vt, null, 2)}`);
  const h = s === "sandbox" ? n.select(`[id="${t}"]`) : yt(`[id="${t}"]`);
  jr.insertComputerIcon(h), jr.insertDatabaseIcon(h), jr.insertClockIcon(h);
  let l = new Af(i);
  l.setData(
    Vt.diagramMarginX,
    Vt.diagramMarginX,
    Vt.diagramMarginY,
    Vt.diagramMarginY
  ), l.data.widthLimit = screen.availWidth, oo = Vt.diagramMarginX, lo = Vt.diagramMarginY;
  const d = i.db.getTitle();
  let p = i.db.getBoundaries("");
  nh(h, "", l, p, i), jr.insertArrowHead(h), jr.insertArrowEnd(h), jr.insertArrowCrossHead(h), jr.insertArrowFilledHead(h), Q6(h, i.db.getRels(), i.db.getC4Shape, i), l.data.stopx = oo, l.data.stopy = lo;
  const g = l.data;
  let y = g.stopy - g.starty + 2 * Vt.diagramMarginY;
  const x = g.stopx - g.startx + 2 * Vt.diagramMarginX;
  d && h.append("text").text(d).attr("x", (g.stopx - g.startx) / 2 - 4 * Vt.diagramMarginX).attr("y", g.starty + Vt.diagramMarginY), fr(h, y, x, Vt.useMaxWidth);
  const b = d ? 60 : 0;
  h.attr(
    "viewBox",
    g.startx - Vt.diagramMarginX + " -" + (Vt.diagramMarginY + b) + " " + x + " " + (y + b)
  ), I.debug("models:", g);
}, "draw"), vu = {
  drawPersonOrSystemArray: Bf,
  drawBoundary: Lf,
  setConf: Yl,
  draw: Z6
}, J6 = /* @__PURE__ */ u((e) => `.person {
    stroke: ${e.personBorder};
    fill: ${e.personBkg};
  }
`, "getStyles"), tv = J6, ev = {
  parser: l6,
  db: Wl,
  renderer: vu,
  styles: tv,
  init: /* @__PURE__ */ u(({ c4: e, wrap: t }) => {
    vu.setConf(e), Wl.setWrap(t);
  }, "init")
};
const rv = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: ev
}, Symbol.toStringTag, { value: "Module" }));
var yn = /* @__PURE__ */ u(() => `
  /* Font Awesome icon styling - consolidated */
  .label-icon {
    display: inline-block;
    height: 1em;
    overflow: visible;
    vertical-align: -0.125em;
  }
  
  .node .label-icon path {
    fill: currentColor;
    stroke: revert;
    stroke-width: revert;
  }
`, "getIconStyles"), Ta = /* @__PURE__ */ u((e, t) => {
  let r;
  return t === "sandbox" && (r = yt("#i" + e)), (t === "sandbox" ? yt(r.nodes()[0].contentDocument.body) : yt("body")).select(`[id="${e}"]`);
}, "getDiagramElement"), cs = /* @__PURE__ */ u((e, t, r, i) => {
  e.attr("class", r);
  const { width: s, height: a, x: n, y: o } = iv(e, t);
  fr(e, a, s, i);
  const h = sv(n, o, s, a, t);
  e.attr("viewBox", h), I.debug(`viewBox configured: ${h} with padding: ${t}`);
}, "setupViewPortForSVG"), iv = /* @__PURE__ */ u((e, t) => {
  var i;
  const r = ((i = e.node()) == null ? void 0 : i.getBBox()) || { width: 0, height: 0, x: 0, y: 0 };
  return {
    width: r.width + t * 2,
    height: r.height + t * 2,
    x: r.x,
    y: r.y
  };
}, "calculateDimensionsWithPadding"), sv = /* @__PURE__ */ u((e, t, r, i, s) => `${e - s} ${t - s} ${r} ${i}`, "createViewBox"), av = "flowchart-", Vs, nv = (Vs = class {
  // cspell:ignore funs
  constructor() {
    this.vertexCounter = 0, this.config = K(), this.vertices = /* @__PURE__ */ new Map(), this.edges = [], this.classes = /* @__PURE__ */ new Map(), this.subGraphs = [], this.subGraphLookup = /* @__PURE__ */ new Map(), this.tooltips = /* @__PURE__ */ new Map(), this.subCount = 0, this.firstGraphFlag = !0, this.secCount = -1, this.posCrossRef = [], this.funs = [], this.setAccTitle = Re, this.setAccDescription = Ye, this.setDiagramTitle = Ge, this.getAccTitle = qe, this.getAccDescription = He, this.getDiagramTitle = Oe, this.funs.push(this.setupToolTips.bind(this)), this.addVertex = this.addVertex.bind(this), this.firstGraph = this.firstGraph.bind(this), this.setDirection = this.setDirection.bind(this), this.addSubGraph = this.addSubGraph.bind(this), this.addLink = this.addLink.bind(this), this.setLink = this.setLink.bind(this), this.updateLink = this.updateLink.bind(this), this.addClass = this.addClass.bind(this), this.setClass = this.setClass.bind(this), this.destructLink = this.destructLink.bind(this), this.setClickEvent = this.setClickEvent.bind(this), this.setTooltip = this.setTooltip.bind(this), this.updateLinkInterpolate = this.updateLinkInterpolate.bind(this), this.setClickFun = this.setClickFun.bind(this), this.bindFunctions = this.bindFunctions.bind(this), this.lex = {
      firstGraph: this.firstGraph.bind(this)
    }, this.clear(), this.setGen("gen-2");
  }
  sanitizeText(t) {
    return St.sanitizeText(t, this.config);
  }
  /**
   * Function to lookup domId from id in the graph definition.
   *
   * @param id - id of the node
   */
  lookUpDomId(t) {
    for (const r of this.vertices.values())
      if (r.id === t)
        return r.domId;
    return t;
  }
  /**
   * Function called by parser when a node definition has been found
   */
  addVertex(t, r, i, s, a, n, o = {}, h) {
    var f, y;
    if (!t || t.trim().length === 0)
      return;
    let l;
    if (h !== void 0) {
      let m;
      h.includes(`
`) ? m = h + `
` : m = `{
` + h + `
}`, l = Io(m, { schema: Do });
    }
    const d = this.edges.find((m) => m.id === t);
    if (d) {
      const m = l;
      (m == null ? void 0 : m.animate) !== void 0 && (d.animate = m.animate), (m == null ? void 0 : m.animation) !== void 0 && (d.animation = m.animation), (m == null ? void 0 : m.curve) !== void 0 && (d.interpolate = m.curve);
      return;
    }
    let p, g = this.vertices.get(t);
    if (g === void 0 && (g = {
      id: t,
      labelType: "text",
      domId: av + t + "-" + this.vertexCounter,
      styles: [],
      classes: []
    }, this.vertices.set(t, g)), this.vertexCounter++, r !== void 0 ? (this.config = K(), p = this.sanitizeText(r.text.trim()), g.labelType = r.type, p.startsWith('"') && p.endsWith('"') && (p = p.substring(1, p.length - 1)), g.text = p) : g.text === void 0 && (g.text = t), i !== void 0 && (g.type = i), s != null && s.forEach((m) => {
      g.styles.push(m);
    }), a != null && a.forEach((m) => {
      g.classes.push(m);
    }), n !== void 0 && (g.dir = n), g.props === void 0 ? g.props = o : o !== void 0 && Object.assign(g.props, o), l !== void 0) {
      if (l.shape) {
        if (l.shape !== l.shape.toLowerCase() || l.shape.includes("_"))
          throw new Error(`No such shape: ${l.shape}. Shape names should be lowercase.`);
        if (!dg(l.shape))
          throw new Error(`No such shape: ${l.shape}.`);
        g.type = l == null ? void 0 : l.shape;
      }
      l != null && l.label && (g.text = l == null ? void 0 : l.label), l != null && l.icon && (g.icon = l == null ? void 0 : l.icon, !((f = l.label) != null && f.trim()) && g.text === t && (g.text = "")), l != null && l.form && (g.form = l == null ? void 0 : l.form), l != null && l.pos && (g.pos = l == null ? void 0 : l.pos), l != null && l.img && (g.img = l == null ? void 0 : l.img, !((y = l.label) != null && y.trim()) && g.text === t && (g.text = "")), l != null && l.constraint && (g.constraint = l.constraint), l.w && (g.assetWidth = Number(l.w)), l.h && (g.assetHeight = Number(l.h));
    }
  }
  /**
   * Function called by parser when a link/edge definition has been found
   *
   */
  addSingleLink(t, r, i, s) {
    const o = {
      start: t,
      end: r,
      type: void 0,
      text: "",
      labelType: "text",
      classes: [],
      isUserDefinedId: !1,
      interpolate: this.edges.defaultInterpolate
    };
    I.info("abc78 Got edge...", o);
    const h = i.text;
    if (h !== void 0 && (o.text = this.sanitizeText(h.text.trim()), o.text.startsWith('"') && o.text.endsWith('"') && (o.text = o.text.substring(1, o.text.length - 1)), o.labelType = h.type), i !== void 0 && (o.type = i.type, o.stroke = i.stroke, o.length = i.length > 10 ? 10 : i.length), s && !this.edges.some((l) => l.id === s))
      o.id = s, o.isUserDefinedId = !0;
    else {
      const l = this.edges.filter((d) => d.start === o.start && d.end === o.end);
      l.length === 0 ? o.id = Es(o.start, o.end, { counter: 0, prefix: "L" }) : o.id = Es(o.start, o.end, {
        counter: l.length + 1,
        prefix: "L"
      });
    }
    if (this.edges.length < (this.config.maxEdges ?? 500))
      I.info("Pushing edge..."), this.edges.push(o);
    else
      throw new Error(
        `Edge limit exceeded. ${this.edges.length} edges found, but the limit is ${this.config.maxEdges}.

Initialize mermaid with maxEdges set to a higher number to allow more edges.
You cannot set this config via configuration inside the diagram as it is a secure config.
You have to call mermaid.initialize.`
      );
  }
  isLinkData(t) {
    return t !== null && typeof t == "object" && "id" in t && typeof t.id == "string";
  }
  addLink(t, r, i) {
    const s = this.isLinkData(i) ? i.id.replace("@", "") : void 0;
    I.info("addLink", t, r, s);
    for (const a of t)
      for (const n of r) {
        const o = a === t[t.length - 1], h = n === r[0];
        o && h ? this.addSingleLink(a, n, i, s) : this.addSingleLink(a, n, i, void 0);
      }
  }
  /**
   * Updates a link's line interpolation algorithm
   */
  updateLinkInterpolate(t, r) {
    t.forEach((i) => {
      i === "default" ? this.edges.defaultInterpolate = r : this.edges[i].interpolate = r;
    });
  }
  /**
   * Updates a link with a style
   *
   */
  updateLink(t, r) {
    t.forEach((i) => {
      var s, a, n, o, h, l;
      if (typeof i == "number" && i >= this.edges.length)
        throw new Error(
          `The index ${i} for linkStyle is out of bounds. Valid indices for linkStyle are between 0 and ${this.edges.length - 1}. (Help: Ensure that the index is within the range of existing edges.)`
        );
      i === "default" ? this.edges.defaultStyle = r : (this.edges[i].style = r, (((a = (s = this.edges[i]) == null ? void 0 : s.style) == null ? void 0 : a.length) ?? 0) > 0 && !((o = (n = this.edges[i]) == null ? void 0 : n.style) != null && o.some((d) => d == null ? void 0 : d.startsWith("fill"))) && ((l = (h = this.edges[i]) == null ? void 0 : h.style) == null || l.push("fill:none")));
    });
  }
  addClass(t, r) {
    const i = r.join().replace(/\\,/g, "").replace(/,/g, ";").replace(//g, ",").split(";");
    t.split(",").forEach((s) => {
      let a = this.classes.get(s);
      a === void 0 && (a = { id: s, styles: [], textStyles: [] }, this.classes.set(s, a)), i != null && i.forEach((n) => {
        if (/color/.exec(n)) {
          const o = n.replace("fill", "bgFill");
          a.textStyles.push(o);
        }
        a.styles.push(n);
      });
    });
  }
  /**
   * Called by parser when a graph definition is found, stores the direction of the chart.
   *
   */
  setDirection(t) {
    this.direction = t.trim(), /.*</.exec(this.direction) && (this.direction = "RL"), /.*\^/.exec(this.direction) && (this.direction = "BT"), /.*>/.exec(this.direction) && (this.direction = "LR"), /.*v/.exec(this.direction) && (this.direction = "TB"), this.direction === "TD" && (this.direction = "TB");
  }
  /**
   * Called by parser when a special node is found, e.g. a clickable element.
   *
   * @param ids - Comma separated list of ids
   * @param className - Class to add
   */
  setClass(t, r) {
    for (const i of t.split(",")) {
      const s = this.vertices.get(i);
      s && s.classes.push(r);
      const a = this.edges.find((o) => o.id === i);
      a && a.classes.push(r);
      const n = this.subGraphLookup.get(i);
      n && n.classes.push(r);
    }
  }
  setTooltip(t, r) {
    if (r !== void 0) {
      r = this.sanitizeText(r);
      for (const i of t.split(","))
        this.tooltips.set(this.version === "gen-1" ? this.lookUpDomId(i) : i, r);
    }
  }
  setClickFun(t, r, i) {
    const s = this.lookUpDomId(t);
    if (K().securityLevel !== "loose" || r === void 0)
      return;
    let a = [];
    if (typeof i == "string") {
      a = i.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
      for (let o = 0; o < a.length; o++) {
        let h = a[o].trim();
        h.startsWith('"') && h.endsWith('"') && (h = h.substr(1, h.length - 2)), a[o] = h;
      }
    }
    a.length === 0 && a.push(t);
    const n = this.vertices.get(t);
    n && (n.haveCallback = !0, this.funs.push(() => {
      const o = document.querySelector(`[id="${s}"]`);
      o !== null && o.addEventListener(
        "click",
        () => {
          ee.runFunc(r, ...a);
        },
        !1
      );
    }));
  }
  /**
   * Called by parser when a link is found. Adds the URL to the vertex data.
   *
   * @param ids - Comma separated list of ids
   * @param linkStr - URL to create a link for
   * @param target - Target attribute for the link
   */
  setLink(t, r, i) {
    t.split(",").forEach((s) => {
      const a = this.vertices.get(s);
      a !== void 0 && (a.link = ee.formatUrl(r, this.config), a.linkTarget = i);
    }), this.setClass(t, "clickable");
  }
  getTooltip(t) {
    return this.tooltips.get(t);
  }
  /**
   * Called by parser when a click definition is found. Registers an event handler.
   *
   * @param ids - Comma separated list of ids
   * @param functionName - Function to be called on click
   * @param functionArgs - Arguments to be passed to the function
   */
  setClickEvent(t, r, i) {
    t.split(",").forEach((s) => {
      this.setClickFun(s, r, i);
    }), this.setClass(t, "clickable");
  }
  bindFunctions(t) {
    this.funs.forEach((r) => {
      r(t);
    });
  }
  getDirection() {
    var t;
    return (t = this.direction) == null ? void 0 : t.trim();
  }
  /**
   * Retrieval function for fetching the found nodes after parsing has completed.
   *
   */
  getVertices() {
    return this.vertices;
  }
  /**
   * Retrieval function for fetching the found links after parsing has completed.
   *
   */
  getEdges() {
    return this.edges;
  }
  /**
   * Retrieval function for fetching the found class definitions after parsing has completed.
   *
   */
  getClasses() {
    return this.classes;
  }
  setupToolTips(t) {
    let r = yt(".mermaidTooltip");
    (r._groups || r)[0][0] === null && (r = yt("body").append("div").attr("class", "mermaidTooltip").style("opacity", 0)), yt(t).select("svg").selectAll("g.node").on("mouseover", (a) => {
      var l;
      const n = yt(a.currentTarget);
      if (n.attr("title") === null)
        return;
      const h = (l = a.currentTarget) == null ? void 0 : l.getBoundingClientRect();
      r.transition().duration(200).style("opacity", ".9"), r.text(n.attr("title")).style("left", window.scrollX + h.left + (h.right - h.left) / 2 + "px").style("top", window.scrollY + h.bottom + "px"), r.html(r.html().replace(/&lt;br\/&gt;/g, "<br/>")), n.classed("hover", !0);
    }).on("mouseout", (a) => {
      r.transition().duration(500).style("opacity", 0), yt(a.currentTarget).classed("hover", !1);
    });
  }
  /**
   * Clears the internal graph db so that a new graph can be parsed.
   *
   */
  clear(t = "gen-2") {
    this.vertices = /* @__PURE__ */ new Map(), this.classes = /* @__PURE__ */ new Map(), this.edges = [], this.funs = [this.setupToolTips.bind(this)], this.subGraphs = [], this.subGraphLookup = /* @__PURE__ */ new Map(), this.subCount = 0, this.tooltips = /* @__PURE__ */ new Map(), this.firstGraphFlag = !0, this.version = t, this.config = K(), Me();
  }
  setGen(t) {
    this.version = t || "gen-2";
  }
  defaultStyle() {
    return "fill:#ffa;stroke: #f66; stroke-width: 3px; stroke-dasharray: 5, 5;fill:#ffa;stroke: #666;";
  }
  addSubGraph(t, r, i) {
    let s = t.text.trim(), a = i.text;
    t === i && /\s/.exec(i.text) && (s = void 0);
    const o = (/* @__PURE__ */ u((g) => {
      const f = { boolean: {}, number: {}, string: {} }, y = [];
      let m;
      return { nodeList: g.filter(function(b) {
        const v = typeof b;
        return b.stmt && b.stmt === "dir" ? (m = b.value, !1) : b.trim() === "" ? !1 : v in f ? f[v].hasOwnProperty(b) ? !1 : f[v][b] = !0 : y.includes(b) ? !1 : y.push(b);
      }), dir: m };
    }, "uniq"))(r.flat()), h = o.nodeList;
    let l = o.dir;
    const d = K().flowchart ?? {};
    if (l = l ?? (d.inheritDir ? this.getDirection() ?? K().direction ?? void 0 : void 0), this.version === "gen-1")
      for (let g = 0; g < h.length; g++)
        h[g] = this.lookUpDomId(h[g]);
    s = s ?? "subGraph" + this.subCount, a = a || "", a = this.sanitizeText(a), this.subCount = this.subCount + 1;
    const p = {
      id: s,
      nodes: h,
      title: a.trim(),
      classes: [],
      dir: l,
      labelType: i.type
    };
    return I.info("Adding", p.id, p.nodes, p.dir), p.nodes = this.makeUniq(p, this.subGraphs).nodes, this.subGraphs.push(p), this.subGraphLookup.set(s, p), s;
  }
  getPosForId(t) {
    for (const [r, i] of this.subGraphs.entries())
      if (i.id === t)
        return r;
    return -1;
  }
  indexNodes2(t, r) {
    const i = this.subGraphs[r].nodes;
    if (this.secCount = this.secCount + 1, this.secCount > 2e3)
      return {
        result: !1,
        count: 0
      };
    if (this.posCrossRef[this.secCount] = r, this.subGraphs[r].id === t)
      return {
        result: !0,
        count: 0
      };
    let s = 0, a = 1;
    for (; s < i.length; ) {
      const n = this.getPosForId(i[s]);
      if (n >= 0) {
        const o = this.indexNodes2(t, n);
        if (o.result)
          return {
            result: !0,
            count: a + o.count
          };
        a = a + o.count;
      }
      s = s + 1;
    }
    return {
      result: !1,
      count: a
    };
  }
  getDepthFirstPos(t) {
    return this.posCrossRef[t];
  }
  indexNodes() {
    this.secCount = -1, this.subGraphs.length > 0 && this.indexNodes2("none", this.subGraphs.length - 1);
  }
  getSubGraphs() {
    return this.subGraphs;
  }
  firstGraph() {
    return this.firstGraphFlag ? (this.firstGraphFlag = !1, !0) : !1;
  }
  destructStartLink(t) {
    let r = t.trim(), i = "arrow_open";
    switch (r[0]) {
      case "<":
        i = "arrow_point", r = r.slice(1);
        break;
      case "x":
        i = "arrow_cross", r = r.slice(1);
        break;
      case "o":
        i = "arrow_circle", r = r.slice(1);
        break;
    }
    let s = "normal";
    return r.includes("=") && (s = "thick"), r.includes(".") && (s = "dotted"), { type: i, stroke: s };
  }
  countChar(t, r) {
    const i = r.length;
    let s = 0;
    for (let a = 0; a < i; ++a)
      r[a] === t && ++s;
    return s;
  }
  destructEndLink(t) {
    const r = t.trim();
    let i = r.slice(0, -1), s = "arrow_open";
    switch (r.slice(-1)) {
      case "x":
        s = "arrow_cross", r.startsWith("x") && (s = "double_" + s, i = i.slice(1));
        break;
      case ">":
        s = "arrow_point", r.startsWith("<") && (s = "double_" + s, i = i.slice(1));
        break;
      case "o":
        s = "arrow_circle", r.startsWith("o") && (s = "double_" + s, i = i.slice(1));
        break;
    }
    let a = "normal", n = i.length - 1;
    i.startsWith("=") && (a = "thick"), i.startsWith("~") && (a = "invisible");
    const o = this.countChar(".", i);
    return o && (a = "dotted", n = o), { type: s, stroke: a, length: n };
  }
  destructLink(t, r) {
    const i = this.destructEndLink(t);
    let s;
    if (r) {
      if (s = this.destructStartLink(r), s.stroke !== i.stroke)
        return { type: "INVALID", stroke: "INVALID" };
      if (s.type === "arrow_open")
        s.type = i.type;
      else {
        if (s.type !== i.type)
          return { type: "INVALID", stroke: "INVALID" };
        s.type = "double_" + s.type;
      }
      return s.type === "double_arrow" && (s.type = "double_arrow_point"), s.length = i.length, s;
    }
    return i;
  }
  // Todo optimizer this by caching existing nodes
  exists(t, r) {
    for (const i of t)
      if (i.nodes.includes(r))
        return !0;
    return !1;
  }
  /**
   * Deletes an id from all subgraphs
   *
   */
  makeUniq(t, r) {
    const i = [];
    return t.nodes.forEach((s, a) => {
      this.exists(r, s) || i.push(t.nodes[a]);
    }), { nodes: i };
  }
  getTypeFromVertex(t) {
    if (t.img)
      return "imageSquare";
    if (t.icon)
      return t.form === "circle" ? "iconCircle" : t.form === "square" ? "iconSquare" : t.form === "rounded" ? "iconRounded" : "icon";
    switch (t.type) {
      case "square":
      case void 0:
        return "squareRect";
      case "round":
        return "roundedRect";
      case "ellipse":
        return "ellipse";
      default:
        return t.type;
    }
  }
  findNode(t, r) {
    return t.find((i) => i.id === r);
  }
  destructEdgeType(t) {
    let r = "none", i = "arrow_point";
    switch (t) {
      case "arrow_point":
      case "arrow_circle":
      case "arrow_cross":
        i = t;
        break;
      case "double_arrow_point":
      case "double_arrow_circle":
      case "double_arrow_cross":
        r = t.replace("double_", ""), i = r;
        break;
    }
    return { arrowTypeStart: r, arrowTypeEnd: i };
  }
  addNodeFromVertex(t, r, i, s, a, n) {
    var d;
    const o = i.get(t.id), h = s.get(t.id) ?? !1, l = this.findNode(r, t.id);
    if (l)
      l.cssStyles = t.styles, l.cssCompiledStyles = this.getCompiledStyles(t.classes), l.cssClasses = t.classes.join(" ");
    else {
      const p = {
        id: t.id,
        label: t.text,
        labelStyle: "",
        parentId: o,
        padding: ((d = a.flowchart) == null ? void 0 : d.padding) || 8,
        cssStyles: t.styles,
        cssCompiledStyles: this.getCompiledStyles(["default", "node", ...t.classes]),
        cssClasses: "default " + t.classes.join(" "),
        dir: t.dir,
        domId: t.domId,
        look: n,
        link: t.link,
        linkTarget: t.linkTarget,
        tooltip: this.getTooltip(t.id),
        icon: t.icon,
        pos: t.pos,
        img: t.img,
        assetWidth: t.assetWidth,
        assetHeight: t.assetHeight,
        constraint: t.constraint
      };
      h ? r.push({
        ...p,
        isGroup: !0,
        shape: "rect"
      }) : r.push({
        ...p,
        isGroup: !1,
        shape: this.getTypeFromVertex(t)
      });
    }
  }
  getCompiledStyles(t) {
    let r = [];
    for (const i of t) {
      const s = this.classes.get(i);
      s != null && s.styles && (r = [...r, ...s.styles ?? []].map((a) => a.trim())), s != null && s.textStyles && (r = [...r, ...s.textStyles ?? []].map((a) => a.trim()));
    }
    return r;
  }
  getData() {
    const t = K(), r = [], i = [], s = this.getSubGraphs(), a = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
    for (let l = s.length - 1; l >= 0; l--) {
      const d = s[l];
      d.nodes.length > 0 && n.set(d.id, !0);
      for (const p of d.nodes)
        a.set(p, d.id);
    }
    for (let l = s.length - 1; l >= 0; l--) {
      const d = s[l];
      r.push({
        id: d.id,
        label: d.title,
        labelStyle: "",
        parentId: a.get(d.id),
        padding: 8,
        cssCompiledStyles: this.getCompiledStyles(d.classes),
        cssClasses: d.classes.join(" "),
        shape: "rect",
        dir: d.dir,
        isGroup: !0,
        look: t.look
      });
    }
    this.getVertices().forEach((l) => {
      this.addNodeFromVertex(l, r, a, n, t, t.look || "classic");
    });
    const h = this.getEdges();
    return h.forEach((l, d) => {
      var m;
      const { arrowTypeStart: p, arrowTypeEnd: g } = this.destructEdgeType(l.type), f = [...h.defaultStyle ?? []];
      l.style && f.push(...l.style);
      const y = {
        id: Es(l.start, l.end, { counter: d, prefix: "L" }, l.id),
        isUserDefinedId: l.isUserDefinedId,
        start: l.start,
        end: l.end,
        type: l.type ?? "normal",
        label: l.text,
        labelpos: "c",
        thickness: l.stroke,
        minlen: l.length,
        classes: (l == null ? void 0 : l.stroke) === "invisible" ? "" : "edge-thickness-normal edge-pattern-solid flowchart-link",
        arrowTypeStart: (l == null ? void 0 : l.stroke) === "invisible" || (l == null ? void 0 : l.type) === "arrow_open" ? "none" : p,
        arrowTypeEnd: (l == null ? void 0 : l.stroke) === "invisible" || (l == null ? void 0 : l.type) === "arrow_open" ? "none" : g,
        arrowheadStyle: "fill: #333",
        cssCompiledStyles: this.getCompiledStyles(l.classes),
        labelStyle: f,
        style: f,
        pattern: l.stroke,
        look: t.look,
        animate: l.animate,
        animation: l.animation,
        curve: l.interpolate || this.edges.defaultInterpolate || ((m = t.flowchart) == null ? void 0 : m.curve)
      };
      i.push(y);
    }), { nodes: r, edges: i, other: {}, config: t };
  }
  defaultConfig() {
    return Md.flowchart;
  }
}, u(Vs, "FlowDB"), Vs), ov = /* @__PURE__ */ u(function(e, t) {
  return t.db.getClasses();
}, "getClasses"), lv = /* @__PURE__ */ u(async function(e, t, r, i) {
  var f;
  I.info("REF0:"), I.info("Drawing state diagram (v2)", t);
  const { securityLevel: s, flowchart: a, layout: n } = K();
  let o;
  s === "sandbox" && (o = yt("#i" + t));
  const h = s === "sandbox" ? o.nodes()[0].contentDocument : document;
  I.debug("Before getData: ");
  const l = i.db.getData();
  I.debug("Data: ", l);
  const d = Ta(t, s), p = i.db.getDirection();
  l.type = i.type, l.layoutAlgorithm = fn(n), l.layoutAlgorithm === "dagre" && n === "elk" && I.warn(
    "flowchart-elk was moved to an external package in Mermaid v11. Please refer [release notes](https://github.com/mermaid-js/mermaid/releases/tag/v11.0.0) for more details. This diagram will be rendered using `dagre` layout as a fallback."
  ), l.direction = p, l.nodeSpacing = (a == null ? void 0 : a.nodeSpacing) || 50, l.rankSpacing = (a == null ? void 0 : a.rankSpacing) || 50, l.markers = ["point", "circle", "cross"], l.diagramId = t, I.debug("REF1:", l), await wa(l, d);
  const g = ((f = l.config.flowchart) == null ? void 0 : f.diagramPadding) ?? 8;
  ee.insertTitle(
    d,
    "flowchartTitleText",
    (a == null ? void 0 : a.titleTopMargin) || 0,
    i.db.getDiagramTitle()
  ), cs(d, g, "flowchart", (a == null ? void 0 : a.useMaxWidth) || !1);
  for (const y of l.nodes) {
    const m = yt(`#${t} [id="${y.id}"]`);
    if (!m || !y.link)
      continue;
    const x = h.createElementNS("http://www.w3.org/2000/svg", "a");
    x.setAttributeNS("http://www.w3.org/2000/svg", "class", y.cssClasses), x.setAttributeNS("http://www.w3.org/2000/svg", "rel", "noopener"), s === "sandbox" ? x.setAttributeNS("http://www.w3.org/2000/svg", "target", "_top") : y.linkTarget && x.setAttributeNS("http://www.w3.org/2000/svg", "target", y.linkTarget);
    const b = m.insert(function() {
      return x;
    }, ":first-child"), v = m.select(".label-container");
    v && b.append(function() {
      return v.node();
    });
    const _ = m.select(".label");
    _ && b.append(function() {
      return _.node();
    });
  }
}, "draw"), cv = {
  getClasses: ov,
  draw: lv
}, Hl = function() {
  var e = /* @__PURE__ */ u(function(ki, Yt, Kt, re) {
    for (Kt = Kt || {}, re = ki.length; re--; Kt[ki[re]] = Yt) ;
    return Kt;
  }, "o"), t = [1, 4], r = [1, 3], i = [1, 5], s = [1, 8, 9, 10, 11, 27, 34, 36, 38, 44, 60, 84, 85, 86, 87, 88, 89, 102, 105, 106, 109, 111, 114, 115, 116, 121, 122, 123, 124], a = [2, 2], n = [1, 13], o = [1, 14], h = [1, 15], l = [1, 16], d = [1, 23], p = [1, 25], g = [1, 26], f = [1, 27], y = [1, 49], m = [1, 48], x = [1, 29], b = [1, 30], v = [1, 31], _ = [1, 32], A = [1, 33], S = [1, 44], k = [1, 46], L = [1, 42], T = [1, 47], C = [1, 43], E = [1, 50], w = [1, 45], W = [1, 51], N = [1, 52], B = [1, 34], R = [1, 35], V = [1, 36], $ = [1, 37], D = [1, 57], O = [1, 8, 9, 10, 11, 27, 32, 34, 36, 38, 44, 60, 84, 85, 86, 87, 88, 89, 102, 105, 106, 109, 111, 114, 115, 116, 121, 122, 123, 124], Y = [1, 61], M = [1, 60], G = [1, 62], rt = [8, 9, 11, 75, 77, 78], ht = [1, 78], Z = [1, 91], ot = [1, 96], it = [1, 95], bt = [1, 92], xt = [1, 88], Ct = [1, 94], at = [1, 90], lt = [1, 97], Q = [1, 93], U = [1, 98], et = [1, 89], z = [8, 9, 10, 11, 40, 75, 77, 78], Tt = [8, 9, 10, 11, 40, 46, 75, 77, 78], F = [8, 9, 10, 11, 29, 40, 44, 46, 48, 50, 52, 54, 56, 58, 60, 63, 65, 67, 68, 70, 75, 77, 78, 89, 102, 105, 106, 109, 111, 114, 115, 116], te = [8, 9, 11, 44, 60, 75, 77, 78, 89, 102, 105, 106, 109, 111, 114, 115, 116], J = [44, 60, 89, 102, 105, 106, 109, 111, 114, 115, 116], Ut = [1, 121], Wt = [1, 122], ie = [1, 124], dt = [1, 123], wt = [44, 60, 62, 74, 89, 102, 105, 106, 109, 111, 114, 115, 116], nt = [1, 133], ut = [1, 147], kt = [1, 148], X = [1, 149], ft = [1, 150], P = [1, 135], At = [1, 137], q = [1, 141], vt = [1, 142], ct = [1, 143], Nt = [1, 144], pt = [1, 145], gt = [1, 146], Jt = [1, 151], Et = [1, 152], ue = [1, 131], Ke = [1, 132], se = [1, 139], me = [1, 134], Pe = [1, 138], Gt = [1, 136], Se = [8, 9, 10, 11, 27, 32, 34, 36, 38, 44, 60, 84, 85, 86, 87, 88, 89, 102, 105, 106, 109, 111, 114, 115, 116, 121, 122, 123, 124], ve = [1, 154], Ue = [1, 156], qt = [8, 9, 11], ye = [8, 9, 10, 11, 14, 44, 60, 89, 105, 106, 109, 111, 114, 115, 116], Mt = [1, 176], ae = [1, 172], Zt = [1, 173], jt = [1, 177], $t = [1, 174], ne = [1, 175], tr = [77, 116, 119], oe = [8, 9, 10, 11, 12, 14, 27, 29, 32, 44, 60, 75, 84, 85, 86, 87, 88, 89, 90, 105, 109, 111, 114, 115, 116], $e = [10, 106], vr = [31, 49, 51, 53, 55, 57, 62, 64, 66, 67, 69, 71, 116, 117, 118], Sr = [1, 247], _e = [1, 245], ti = [1, 249], ei = [1, 243], ri = [1, 244], ii = [1, 246], si = [1, 248], ai = [1, 250], gs = [1, 268], qh = [8, 9, 11, 106], qr = [8, 9, 10, 11, 60, 84, 105, 106, 109, 110, 111, 112], Zo = {
    trace: /* @__PURE__ */ u(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, start: 3, graphConfig: 4, document: 5, line: 6, statement: 7, SEMI: 8, NEWLINE: 9, SPACE: 10, EOF: 11, GRAPH: 12, NODIR: 13, DIR: 14, FirstStmtSeparator: 15, ending: 16, endToken: 17, spaceList: 18, spaceListNewline: 19, vertexStatement: 20, separator: 21, styleStatement: 22, linkStyleStatement: 23, classDefStatement: 24, classStatement: 25, clickStatement: 26, subgraph: 27, textNoTags: 28, SQS: 29, text: 30, SQE: 31, end: 32, direction: 33, acc_title: 34, acc_title_value: 35, acc_descr: 36, acc_descr_value: 37, acc_descr_multiline_value: 38, shapeData: 39, SHAPE_DATA: 40, link: 41, node: 42, styledVertex: 43, AMP: 44, vertex: 45, STYLE_SEPARATOR: 46, idString: 47, DOUBLECIRCLESTART: 48, DOUBLECIRCLEEND: 49, PS: 50, PE: 51, "(-": 52, "-)": 53, STADIUMSTART: 54, STADIUMEND: 55, SUBROUTINESTART: 56, SUBROUTINEEND: 57, VERTEX_WITH_PROPS_START: 58, "NODE_STRING[field]": 59, COLON: 60, "NODE_STRING[value]": 61, PIPE: 62, CYLINDERSTART: 63, CYLINDEREND: 64, DIAMOND_START: 65, DIAMOND_STOP: 66, TAGEND: 67, TRAPSTART: 68, TRAPEND: 69, INVTRAPSTART: 70, INVTRAPEND: 71, linkStatement: 72, arrowText: 73, TESTSTR: 74, START_LINK: 75, edgeText: 76, LINK: 77, LINK_ID: 78, edgeTextToken: 79, STR: 80, MD_STR: 81, textToken: 82, keywords: 83, STYLE: 84, LINKSTYLE: 85, CLASSDEF: 86, CLASS: 87, CLICK: 88, DOWN: 89, UP: 90, textNoTagsToken: 91, stylesOpt: 92, "idString[vertex]": 93, "idString[class]": 94, CALLBACKNAME: 95, CALLBACKARGS: 96, HREF: 97, LINK_TARGET: 98, "STR[link]": 99, "STR[tooltip]": 100, alphaNum: 101, DEFAULT: 102, numList: 103, INTERPOLATE: 104, NUM: 105, COMMA: 106, style: 107, styleComponent: 108, NODE_STRING: 109, UNIT: 110, BRKT: 111, PCT: 112, idStringToken: 113, MINUS: 114, MULT: 115, UNICODE_TEXT: 116, TEXT: 117, TAGSTART: 118, EDGE_TEXT: 119, alphaNumToken: 120, direction_tb: 121, direction_bt: 122, direction_rl: 123, direction_lr: 124, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 8: "SEMI", 9: "NEWLINE", 10: "SPACE", 11: "EOF", 12: "GRAPH", 13: "NODIR", 14: "DIR", 27: "subgraph", 29: "SQS", 31: "SQE", 32: "end", 34: "acc_title", 35: "acc_title_value", 36: "acc_descr", 37: "acc_descr_value", 38: "acc_descr_multiline_value", 40: "SHAPE_DATA", 44: "AMP", 46: "STYLE_SEPARATOR", 48: "DOUBLECIRCLESTART", 49: "DOUBLECIRCLEEND", 50: "PS", 51: "PE", 52: "(-", 53: "-)", 54: "STADIUMSTART", 55: "STADIUMEND", 56: "SUBROUTINESTART", 57: "SUBROUTINEEND", 58: "VERTEX_WITH_PROPS_START", 59: "NODE_STRING[field]", 60: "COLON", 61: "NODE_STRING[value]", 62: "PIPE", 63: "CYLINDERSTART", 64: "CYLINDEREND", 65: "DIAMOND_START", 66: "DIAMOND_STOP", 67: "TAGEND", 68: "TRAPSTART", 69: "TRAPEND", 70: "INVTRAPSTART", 71: "INVTRAPEND", 74: "TESTSTR", 75: "START_LINK", 77: "LINK", 78: "LINK_ID", 80: "STR", 81: "MD_STR", 84: "STYLE", 85: "LINKSTYLE", 86: "CLASSDEF", 87: "CLASS", 88: "CLICK", 89: "DOWN", 90: "UP", 93: "idString[vertex]", 94: "idString[class]", 95: "CALLBACKNAME", 96: "CALLBACKARGS", 97: "HREF", 98: "LINK_TARGET", 99: "STR[link]", 100: "STR[tooltip]", 102: "DEFAULT", 104: "INTERPOLATE", 105: "NUM", 106: "COMMA", 109: "NODE_STRING", 110: "UNIT", 111: "BRKT", 112: "PCT", 114: "MINUS", 115: "MULT", 116: "UNICODE_TEXT", 117: "TEXT", 118: "TAGSTART", 119: "EDGE_TEXT", 121: "direction_tb", 122: "direction_bt", 123: "direction_rl", 124: "direction_lr" },
    productions_: [0, [3, 2], [5, 0], [5, 2], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [4, 2], [4, 2], [4, 2], [4, 3], [16, 2], [16, 1], [17, 1], [17, 1], [17, 1], [15, 1], [15, 1], [15, 2], [19, 2], [19, 2], [19, 1], [19, 1], [18, 2], [18, 1], [7, 2], [7, 2], [7, 2], [7, 2], [7, 2], [7, 2], [7, 9], [7, 6], [7, 4], [7, 1], [7, 2], [7, 2], [7, 1], [21, 1], [21, 1], [21, 1], [39, 2], [39, 1], [20, 4], [20, 3], [20, 4], [20, 2], [20, 2], [20, 1], [42, 1], [42, 6], [42, 5], [43, 1], [43, 3], [45, 4], [45, 4], [45, 6], [45, 4], [45, 4], [45, 4], [45, 8], [45, 4], [45, 4], [45, 4], [45, 6], [45, 4], [45, 4], [45, 4], [45, 4], [45, 4], [45, 1], [41, 2], [41, 3], [41, 3], [41, 1], [41, 3], [41, 4], [76, 1], [76, 2], [76, 1], [76, 1], [72, 1], [72, 2], [73, 3], [30, 1], [30, 2], [30, 1], [30, 1], [83, 1], [83, 1], [83, 1], [83, 1], [83, 1], [83, 1], [83, 1], [83, 1], [83, 1], [83, 1], [83, 1], [28, 1], [28, 2], [28, 1], [28, 1], [24, 5], [25, 5], [26, 2], [26, 4], [26, 3], [26, 5], [26, 3], [26, 5], [26, 5], [26, 7], [26, 2], [26, 4], [26, 2], [26, 4], [26, 4], [26, 6], [22, 5], [23, 5], [23, 5], [23, 9], [23, 9], [23, 7], [23, 7], [103, 1], [103, 3], [92, 1], [92, 3], [107, 1], [107, 2], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [113, 1], [113, 1], [113, 1], [113, 1], [113, 1], [113, 1], [113, 1], [113, 1], [113, 1], [113, 1], [113, 1], [82, 1], [82, 1], [82, 1], [82, 1], [91, 1], [91, 1], [91, 1], [91, 1], [91, 1], [91, 1], [91, 1], [91, 1], [91, 1], [91, 1], [91, 1], [79, 1], [79, 1], [120, 1], [120, 1], [120, 1], [120, 1], [120, 1], [120, 1], [120, 1], [120, 1], [120, 1], [120, 1], [120, 1], [47, 1], [47, 2], [101, 1], [101, 2], [33, 1], [33, 1], [33, 1], [33, 1]],
    performAction: /* @__PURE__ */ u(function(Yt, Kt, re, _t, Ce, H, _a) {
      var j = H.length - 1;
      switch (Ce) {
        case 2:
          this.$ = [];
          break;
        case 3:
          (!Array.isArray(H[j]) || H[j].length > 0) && H[j - 1].push(H[j]), this.$ = H[j - 1];
          break;
        case 4:
        case 183:
          this.$ = H[j];
          break;
        case 11:
          _t.setDirection("TB"), this.$ = "TB";
          break;
        case 12:
          _t.setDirection(H[j - 1]), this.$ = H[j - 1];
          break;
        case 27:
          this.$ = H[j - 1].nodes;
          break;
        case 28:
        case 29:
        case 30:
        case 31:
        case 32:
          this.$ = [];
          break;
        case 33:
          this.$ = _t.addSubGraph(H[j - 6], H[j - 1], H[j - 4]);
          break;
        case 34:
          this.$ = _t.addSubGraph(H[j - 3], H[j - 1], H[j - 3]);
          break;
        case 35:
          this.$ = _t.addSubGraph(void 0, H[j - 1], void 0);
          break;
        case 37:
          this.$ = H[j].trim(), _t.setAccTitle(this.$);
          break;
        case 38:
        case 39:
          this.$ = H[j].trim(), _t.setAccDescription(this.$);
          break;
        case 43:
          this.$ = H[j - 1] + H[j];
          break;
        case 44:
          this.$ = H[j];
          break;
        case 45:
          _t.addVertex(H[j - 1][H[j - 1].length - 1], void 0, void 0, void 0, void 0, void 0, void 0, H[j]), _t.addLink(H[j - 3].stmt, H[j - 1], H[j - 2]), this.$ = { stmt: H[j - 1], nodes: H[j - 1].concat(H[j - 3].nodes) };
          break;
        case 46:
          _t.addLink(H[j - 2].stmt, H[j], H[j - 1]), this.$ = { stmt: H[j], nodes: H[j].concat(H[j - 2].nodes) };
          break;
        case 47:
          _t.addLink(H[j - 3].stmt, H[j - 1], H[j - 2]), this.$ = { stmt: H[j - 1], nodes: H[j - 1].concat(H[j - 3].nodes) };
          break;
        case 48:
          this.$ = { stmt: H[j - 1], nodes: H[j - 1] };
          break;
        case 49:
          _t.addVertex(H[j - 1][H[j - 1].length - 1], void 0, void 0, void 0, void 0, void 0, void 0, H[j]), this.$ = { stmt: H[j - 1], nodes: H[j - 1], shapeData: H[j] };
          break;
        case 50:
          this.$ = { stmt: H[j], nodes: H[j] };
          break;
        case 51:
          this.$ = [H[j]];
          break;
        case 52:
          _t.addVertex(H[j - 5][H[j - 5].length - 1], void 0, void 0, void 0, void 0, void 0, void 0, H[j - 4]), this.$ = H[j - 5].concat(H[j]);
          break;
        case 53:
          this.$ = H[j - 4].concat(H[j]);
          break;
        case 54:
          this.$ = H[j];
          break;
        case 55:
          this.$ = H[j - 2], _t.setClass(H[j - 2], H[j]);
          break;
        case 56:
          this.$ = H[j - 3], _t.addVertex(H[j - 3], H[j - 1], "square");
          break;
        case 57:
          this.$ = H[j - 3], _t.addVertex(H[j - 3], H[j - 1], "doublecircle");
          break;
        case 58:
          this.$ = H[j - 5], _t.addVertex(H[j - 5], H[j - 2], "circle");
          break;
        case 59:
          this.$ = H[j - 3], _t.addVertex(H[j - 3], H[j - 1], "ellipse");
          break;
        case 60:
          this.$ = H[j - 3], _t.addVertex(H[j - 3], H[j - 1], "stadium");
          break;
        case 61:
          this.$ = H[j - 3], _t.addVertex(H[j - 3], H[j - 1], "subroutine");
          break;
        case 62:
          this.$ = H[j - 7], _t.addVertex(H[j - 7], H[j - 1], "rect", void 0, void 0, void 0, Object.fromEntries([[H[j - 5], H[j - 3]]]));
          break;
        case 63:
          this.$ = H[j - 3], _t.addVertex(H[j - 3], H[j - 1], "cylinder");
          break;
        case 64:
          this.$ = H[j - 3], _t.addVertex(H[j - 3], H[j - 1], "round");
          break;
        case 65:
          this.$ = H[j - 3], _t.addVertex(H[j - 3], H[j - 1], "diamond");
          break;
        case 66:
          this.$ = H[j - 5], _t.addVertex(H[j - 5], H[j - 2], "hexagon");
          break;
        case 67:
          this.$ = H[j - 3], _t.addVertex(H[j - 3], H[j - 1], "odd");
          break;
        case 68:
          this.$ = H[j - 3], _t.addVertex(H[j - 3], H[j - 1], "trapezoid");
          break;
        case 69:
          this.$ = H[j - 3], _t.addVertex(H[j - 3], H[j - 1], "inv_trapezoid");
          break;
        case 70:
          this.$ = H[j - 3], _t.addVertex(H[j - 3], H[j - 1], "lean_right");
          break;
        case 71:
          this.$ = H[j - 3], _t.addVertex(H[j - 3], H[j - 1], "lean_left");
          break;
        case 72:
          this.$ = H[j], _t.addVertex(H[j]);
          break;
        case 73:
          H[j - 1].text = H[j], this.$ = H[j - 1];
          break;
        case 74:
        case 75:
          H[j - 2].text = H[j - 1], this.$ = H[j - 2];
          break;
        case 76:
          this.$ = H[j];
          break;
        case 77:
          var Fe = _t.destructLink(H[j], H[j - 2]);
          this.$ = { type: Fe.type, stroke: Fe.stroke, length: Fe.length, text: H[j - 1] };
          break;
        case 78:
          var Fe = _t.destructLink(H[j], H[j - 2]);
          this.$ = { type: Fe.type, stroke: Fe.stroke, length: Fe.length, text: H[j - 1], id: H[j - 3] };
          break;
        case 79:
          this.$ = { text: H[j], type: "text" };
          break;
        case 80:
          this.$ = { text: H[j - 1].text + "" + H[j], type: H[j - 1].type };
          break;
        case 81:
          this.$ = { text: H[j], type: "string" };
          break;
        case 82:
          this.$ = { text: H[j], type: "markdown" };
          break;
        case 83:
          var Fe = _t.destructLink(H[j]);
          this.$ = { type: Fe.type, stroke: Fe.stroke, length: Fe.length };
          break;
        case 84:
          var Fe = _t.destructLink(H[j]);
          this.$ = { type: Fe.type, stroke: Fe.stroke, length: Fe.length, id: H[j - 1] };
          break;
        case 85:
          this.$ = H[j - 1];
          break;
        case 86:
          this.$ = { text: H[j], type: "text" };
          break;
        case 87:
          this.$ = { text: H[j - 1].text + "" + H[j], type: H[j - 1].type };
          break;
        case 88:
          this.$ = { text: H[j], type: "string" };
          break;
        case 89:
        case 104:
          this.$ = { text: H[j], type: "markdown" };
          break;
        case 101:
          this.$ = { text: H[j], type: "text" };
          break;
        case 102:
          this.$ = { text: H[j - 1].text + "" + H[j], type: H[j - 1].type };
          break;
        case 103:
          this.$ = { text: H[j], type: "text" };
          break;
        case 105:
          this.$ = H[j - 4], _t.addClass(H[j - 2], H[j]);
          break;
        case 106:
          this.$ = H[j - 4], _t.setClass(H[j - 2], H[j]);
          break;
        case 107:
        case 115:
          this.$ = H[j - 1], _t.setClickEvent(H[j - 1], H[j]);
          break;
        case 108:
        case 116:
          this.$ = H[j - 3], _t.setClickEvent(H[j - 3], H[j - 2]), _t.setTooltip(H[j - 3], H[j]);
          break;
        case 109:
          this.$ = H[j - 2], _t.setClickEvent(H[j - 2], H[j - 1], H[j]);
          break;
        case 110:
          this.$ = H[j - 4], _t.setClickEvent(H[j - 4], H[j - 3], H[j - 2]), _t.setTooltip(H[j - 4], H[j]);
          break;
        case 111:
          this.$ = H[j - 2], _t.setLink(H[j - 2], H[j]);
          break;
        case 112:
          this.$ = H[j - 4], _t.setLink(H[j - 4], H[j - 2]), _t.setTooltip(H[j - 4], H[j]);
          break;
        case 113:
          this.$ = H[j - 4], _t.setLink(H[j - 4], H[j - 2], H[j]);
          break;
        case 114:
          this.$ = H[j - 6], _t.setLink(H[j - 6], H[j - 4], H[j]), _t.setTooltip(H[j - 6], H[j - 2]);
          break;
        case 117:
          this.$ = H[j - 1], _t.setLink(H[j - 1], H[j]);
          break;
        case 118:
          this.$ = H[j - 3], _t.setLink(H[j - 3], H[j - 2]), _t.setTooltip(H[j - 3], H[j]);
          break;
        case 119:
          this.$ = H[j - 3], _t.setLink(H[j - 3], H[j - 2], H[j]);
          break;
        case 120:
          this.$ = H[j - 5], _t.setLink(H[j - 5], H[j - 4], H[j]), _t.setTooltip(H[j - 5], H[j - 2]);
          break;
        case 121:
          this.$ = H[j - 4], _t.addVertex(H[j - 2], void 0, void 0, H[j]);
          break;
        case 122:
          this.$ = H[j - 4], _t.updateLink([H[j - 2]], H[j]);
          break;
        case 123:
          this.$ = H[j - 4], _t.updateLink(H[j - 2], H[j]);
          break;
        case 124:
          this.$ = H[j - 8], _t.updateLinkInterpolate([H[j - 6]], H[j - 2]), _t.updateLink([H[j - 6]], H[j]);
          break;
        case 125:
          this.$ = H[j - 8], _t.updateLinkInterpolate(H[j - 6], H[j - 2]), _t.updateLink(H[j - 6], H[j]);
          break;
        case 126:
          this.$ = H[j - 6], _t.updateLinkInterpolate([H[j - 4]], H[j]);
          break;
        case 127:
          this.$ = H[j - 6], _t.updateLinkInterpolate(H[j - 4], H[j]);
          break;
        case 128:
        case 130:
          this.$ = [H[j]];
          break;
        case 129:
        case 131:
          H[j - 2].push(H[j]), this.$ = H[j - 2];
          break;
        case 133:
          this.$ = H[j - 1] + H[j];
          break;
        case 181:
          this.$ = H[j];
          break;
        case 182:
          this.$ = H[j - 1] + "" + H[j];
          break;
        case 184:
          this.$ = H[j - 1] + "" + H[j];
          break;
        case 185:
          this.$ = { stmt: "dir", value: "TB" };
          break;
        case 186:
          this.$ = { stmt: "dir", value: "BT" };
          break;
        case 187:
          this.$ = { stmt: "dir", value: "RL" };
          break;
        case 188:
          this.$ = { stmt: "dir", value: "LR" };
          break;
      }
    }, "anonymous"),
    table: [{ 3: 1, 4: 2, 9: t, 10: r, 12: i }, { 1: [3] }, e(s, a, { 5: 6 }), { 4: 7, 9: t, 10: r, 12: i }, { 4: 8, 9: t, 10: r, 12: i }, { 13: [1, 9], 14: [1, 10] }, { 1: [2, 1], 6: 11, 7: 12, 8: n, 9: o, 10: h, 11: l, 20: 17, 22: 18, 23: 19, 24: 20, 25: 21, 26: 22, 27: d, 33: 24, 34: p, 36: g, 38: f, 42: 28, 43: 38, 44: y, 45: 39, 47: 40, 60: m, 84: x, 85: b, 86: v, 87: _, 88: A, 89: S, 102: k, 105: L, 106: T, 109: C, 111: E, 113: 41, 114: w, 115: W, 116: N, 121: B, 122: R, 123: V, 124: $ }, e(s, [2, 9]), e(s, [2, 10]), e(s, [2, 11]), { 8: [1, 54], 9: [1, 55], 10: D, 15: 53, 18: 56 }, e(O, [2, 3]), e(O, [2, 4]), e(O, [2, 5]), e(O, [2, 6]), e(O, [2, 7]), e(O, [2, 8]), { 8: Y, 9: M, 11: G, 21: 58, 41: 59, 72: 63, 75: [1, 64], 77: [1, 66], 78: [1, 65] }, { 8: Y, 9: M, 11: G, 21: 67 }, { 8: Y, 9: M, 11: G, 21: 68 }, { 8: Y, 9: M, 11: G, 21: 69 }, { 8: Y, 9: M, 11: G, 21: 70 }, { 8: Y, 9: M, 11: G, 21: 71 }, { 8: Y, 9: M, 10: [1, 72], 11: G, 21: 73 }, e(O, [2, 36]), { 35: [1, 74] }, { 37: [1, 75] }, e(O, [2, 39]), e(rt, [2, 50], { 18: 76, 39: 77, 10: D, 40: ht }), { 10: [1, 79] }, { 10: [1, 80] }, { 10: [1, 81] }, { 10: [1, 82] }, { 14: Z, 44: ot, 60: it, 80: [1, 86], 89: bt, 95: [1, 83], 97: [1, 84], 101: 85, 105: xt, 106: Ct, 109: at, 111: lt, 114: Q, 115: U, 116: et, 120: 87 }, e(O, [2, 185]), e(O, [2, 186]), e(O, [2, 187]), e(O, [2, 188]), e(z, [2, 51]), e(z, [2, 54], { 46: [1, 99] }), e(Tt, [2, 72], { 113: 112, 29: [1, 100], 44: y, 48: [1, 101], 50: [1, 102], 52: [1, 103], 54: [1, 104], 56: [1, 105], 58: [1, 106], 60: m, 63: [1, 107], 65: [1, 108], 67: [1, 109], 68: [1, 110], 70: [1, 111], 89: S, 102: k, 105: L, 106: T, 109: C, 111: E, 114: w, 115: W, 116: N }), e(F, [2, 181]), e(F, [2, 142]), e(F, [2, 143]), e(F, [2, 144]), e(F, [2, 145]), e(F, [2, 146]), e(F, [2, 147]), e(F, [2, 148]), e(F, [2, 149]), e(F, [2, 150]), e(F, [2, 151]), e(F, [2, 152]), e(s, [2, 12]), e(s, [2, 18]), e(s, [2, 19]), { 9: [1, 113] }, e(te, [2, 26], { 18: 114, 10: D }), e(O, [2, 27]), { 42: 115, 43: 38, 44: y, 45: 39, 47: 40, 60: m, 89: S, 102: k, 105: L, 106: T, 109: C, 111: E, 113: 41, 114: w, 115: W, 116: N }, e(O, [2, 40]), e(O, [2, 41]), e(O, [2, 42]), e(J, [2, 76], { 73: 116, 62: [1, 118], 74: [1, 117] }), { 76: 119, 79: 120, 80: Ut, 81: Wt, 116: ie, 119: dt }, { 75: [1, 125], 77: [1, 126] }, e(wt, [2, 83]), e(O, [2, 28]), e(O, [2, 29]), e(O, [2, 30]), e(O, [2, 31]), e(O, [2, 32]), { 10: nt, 12: ut, 14: kt, 27: X, 28: 127, 32: ft, 44: P, 60: At, 75: q, 80: [1, 129], 81: [1, 130], 83: 140, 84: vt, 85: ct, 86: Nt, 87: pt, 88: gt, 89: Jt, 90: Et, 91: 128, 105: ue, 109: Ke, 111: se, 114: me, 115: Pe, 116: Gt }, e(Se, a, { 5: 153 }), e(O, [2, 37]), e(O, [2, 38]), e(rt, [2, 48], { 44: ve }), e(rt, [2, 49], { 18: 155, 10: D, 40: Ue }), e(z, [2, 44]), { 44: y, 47: 157, 60: m, 89: S, 102: k, 105: L, 106: T, 109: C, 111: E, 113: 41, 114: w, 115: W, 116: N }, { 102: [1, 158], 103: 159, 105: [1, 160] }, { 44: y, 47: 161, 60: m, 89: S, 102: k, 105: L, 106: T, 109: C, 111: E, 113: 41, 114: w, 115: W, 116: N }, { 44: y, 47: 162, 60: m, 89: S, 102: k, 105: L, 106: T, 109: C, 111: E, 113: 41, 114: w, 115: W, 116: N }, e(qt, [2, 107], { 10: [1, 163], 96: [1, 164] }), { 80: [1, 165] }, e(qt, [2, 115], { 120: 167, 10: [1, 166], 14: Z, 44: ot, 60: it, 89: bt, 105: xt, 106: Ct, 109: at, 111: lt, 114: Q, 115: U, 116: et }), e(qt, [2, 117], { 10: [1, 168] }), e(ye, [2, 183]), e(ye, [2, 170]), e(ye, [2, 171]), e(ye, [2, 172]), e(ye, [2, 173]), e(ye, [2, 174]), e(ye, [2, 175]), e(ye, [2, 176]), e(ye, [2, 177]), e(ye, [2, 178]), e(ye, [2, 179]), e(ye, [2, 180]), { 44: y, 47: 169, 60: m, 89: S, 102: k, 105: L, 106: T, 109: C, 111: E, 113: 41, 114: w, 115: W, 116: N }, { 30: 170, 67: Mt, 80: ae, 81: Zt, 82: 171, 116: jt, 117: $t, 118: ne }, { 30: 178, 67: Mt, 80: ae, 81: Zt, 82: 171, 116: jt, 117: $t, 118: ne }, { 30: 180, 50: [1, 179], 67: Mt, 80: ae, 81: Zt, 82: 171, 116: jt, 117: $t, 118: ne }, { 30: 181, 67: Mt, 80: ae, 81: Zt, 82: 171, 116: jt, 117: $t, 118: ne }, { 30: 182, 67: Mt, 80: ae, 81: Zt, 82: 171, 116: jt, 117: $t, 118: ne }, { 30: 183, 67: Mt, 80: ae, 81: Zt, 82: 171, 116: jt, 117: $t, 118: ne }, { 109: [1, 184] }, { 30: 185, 67: Mt, 80: ae, 81: Zt, 82: 171, 116: jt, 117: $t, 118: ne }, { 30: 186, 65: [1, 187], 67: Mt, 80: ae, 81: Zt, 82: 171, 116: jt, 117: $t, 118: ne }, { 30: 188, 67: Mt, 80: ae, 81: Zt, 82: 171, 116: jt, 117: $t, 118: ne }, { 30: 189, 67: Mt, 80: ae, 81: Zt, 82: 171, 116: jt, 117: $t, 118: ne }, { 30: 190, 67: Mt, 80: ae, 81: Zt, 82: 171, 116: jt, 117: $t, 118: ne }, e(F, [2, 182]), e(s, [2, 20]), e(te, [2, 25]), e(rt, [2, 46], { 39: 191, 18: 192, 10: D, 40: ht }), e(J, [2, 73], { 10: [1, 193] }), { 10: [1, 194] }, { 30: 195, 67: Mt, 80: ae, 81: Zt, 82: 171, 116: jt, 117: $t, 118: ne }, { 77: [1, 196], 79: 197, 116: ie, 119: dt }, e(tr, [2, 79]), e(tr, [2, 81]), e(tr, [2, 82]), e(tr, [2, 168]), e(tr, [2, 169]), { 76: 198, 79: 120, 80: Ut, 81: Wt, 116: ie, 119: dt }, e(wt, [2, 84]), { 8: Y, 9: M, 10: nt, 11: G, 12: ut, 14: kt, 21: 200, 27: X, 29: [1, 199], 32: ft, 44: P, 60: At, 75: q, 83: 140, 84: vt, 85: ct, 86: Nt, 87: pt, 88: gt, 89: Jt, 90: Et, 91: 201, 105: ue, 109: Ke, 111: se, 114: me, 115: Pe, 116: Gt }, e(oe, [2, 101]), e(oe, [2, 103]), e(oe, [2, 104]), e(oe, [2, 157]), e(oe, [2, 158]), e(oe, [2, 159]), e(oe, [2, 160]), e(oe, [2, 161]), e(oe, [2, 162]), e(oe, [2, 163]), e(oe, [2, 164]), e(oe, [2, 165]), e(oe, [2, 166]), e(oe, [2, 167]), e(oe, [2, 90]), e(oe, [2, 91]), e(oe, [2, 92]), e(oe, [2, 93]), e(oe, [2, 94]), e(oe, [2, 95]), e(oe, [2, 96]), e(oe, [2, 97]), e(oe, [2, 98]), e(oe, [2, 99]), e(oe, [2, 100]), { 6: 11, 7: 12, 8: n, 9: o, 10: h, 11: l, 20: 17, 22: 18, 23: 19, 24: 20, 25: 21, 26: 22, 27: d, 32: [1, 202], 33: 24, 34: p, 36: g, 38: f, 42: 28, 43: 38, 44: y, 45: 39, 47: 40, 60: m, 84: x, 85: b, 86: v, 87: _, 88: A, 89: S, 102: k, 105: L, 106: T, 109: C, 111: E, 113: 41, 114: w, 115: W, 116: N, 121: B, 122: R, 123: V, 124: $ }, { 10: D, 18: 203 }, { 44: [1, 204] }, e(z, [2, 43]), { 10: [1, 205], 44: y, 60: m, 89: S, 102: k, 105: L, 106: T, 109: C, 111: E, 113: 112, 114: w, 115: W, 116: N }, { 10: [1, 206] }, { 10: [1, 207], 106: [1, 208] }, e($e, [2, 128]), { 10: [1, 209], 44: y, 60: m, 89: S, 102: k, 105: L, 106: T, 109: C, 111: E, 113: 112, 114: w, 115: W, 116: N }, { 10: [1, 210], 44: y, 60: m, 89: S, 102: k, 105: L, 106: T, 109: C, 111: E, 113: 112, 114: w, 115: W, 116: N }, { 80: [1, 211] }, e(qt, [2, 109], { 10: [1, 212] }), e(qt, [2, 111], { 10: [1, 213] }), { 80: [1, 214] }, e(ye, [2, 184]), { 80: [1, 215], 98: [1, 216] }, e(z, [2, 55], { 113: 112, 44: y, 60: m, 89: S, 102: k, 105: L, 106: T, 109: C, 111: E, 114: w, 115: W, 116: N }), { 31: [1, 217], 67: Mt, 82: 218, 116: jt, 117: $t, 118: ne }, e(vr, [2, 86]), e(vr, [2, 88]), e(vr, [2, 89]), e(vr, [2, 153]), e(vr, [2, 154]), e(vr, [2, 155]), e(vr, [2, 156]), { 49: [1, 219], 67: Mt, 82: 218, 116: jt, 117: $t, 118: ne }, { 30: 220, 67: Mt, 80: ae, 81: Zt, 82: 171, 116: jt, 117: $t, 118: ne }, { 51: [1, 221], 67: Mt, 82: 218, 116: jt, 117: $t, 118: ne }, { 53: [1, 222], 67: Mt, 82: 218, 116: jt, 117: $t, 118: ne }, { 55: [1, 223], 67: Mt, 82: 218, 116: jt, 117: $t, 118: ne }, { 57: [1, 224], 67: Mt, 82: 218, 116: jt, 117: $t, 118: ne }, { 60: [1, 225] }, { 64: [1, 226], 67: Mt, 82: 218, 116: jt, 117: $t, 118: ne }, { 66: [1, 227], 67: Mt, 82: 218, 116: jt, 117: $t, 118: ne }, { 30: 228, 67: Mt, 80: ae, 81: Zt, 82: 171, 116: jt, 117: $t, 118: ne }, { 31: [1, 229], 67: Mt, 82: 218, 116: jt, 117: $t, 118: ne }, { 67: Mt, 69: [1, 230], 71: [1, 231], 82: 218, 116: jt, 117: $t, 118: ne }, { 67: Mt, 69: [1, 233], 71: [1, 232], 82: 218, 116: jt, 117: $t, 118: ne }, e(rt, [2, 45], { 18: 155, 10: D, 40: Ue }), e(rt, [2, 47], { 44: ve }), e(J, [2, 75]), e(J, [2, 74]), { 62: [1, 234], 67: Mt, 82: 218, 116: jt, 117: $t, 118: ne }, e(J, [2, 77]), e(tr, [2, 80]), { 77: [1, 235], 79: 197, 116: ie, 119: dt }, { 30: 236, 67: Mt, 80: ae, 81: Zt, 82: 171, 116: jt, 117: $t, 118: ne }, e(Se, a, { 5: 237 }), e(oe, [2, 102]), e(O, [2, 35]), { 43: 238, 44: y, 45: 39, 47: 40, 60: m, 89: S, 102: k, 105: L, 106: T, 109: C, 111: E, 113: 41, 114: w, 115: W, 116: N }, { 10: D, 18: 239 }, { 10: Sr, 60: _e, 84: ti, 92: 240, 105: ei, 107: 241, 108: 242, 109: ri, 110: ii, 111: si, 112: ai }, { 10: Sr, 60: _e, 84: ti, 92: 251, 104: [1, 252], 105: ei, 107: 241, 108: 242, 109: ri, 110: ii, 111: si, 112: ai }, { 10: Sr, 60: _e, 84: ti, 92: 253, 104: [1, 254], 105: ei, 107: 241, 108: 242, 109: ri, 110: ii, 111: si, 112: ai }, { 105: [1, 255] }, { 10: Sr, 60: _e, 84: ti, 92: 256, 105: ei, 107: 241, 108: 242, 109: ri, 110: ii, 111: si, 112: ai }, { 44: y, 47: 257, 60: m, 89: S, 102: k, 105: L, 106: T, 109: C, 111: E, 113: 41, 114: w, 115: W, 116: N }, e(qt, [2, 108]), { 80: [1, 258] }, { 80: [1, 259], 98: [1, 260] }, e(qt, [2, 116]), e(qt, [2, 118], { 10: [1, 261] }), e(qt, [2, 119]), e(Tt, [2, 56]), e(vr, [2, 87]), e(Tt, [2, 57]), { 51: [1, 262], 67: Mt, 82: 218, 116: jt, 117: $t, 118: ne }, e(Tt, [2, 64]), e(Tt, [2, 59]), e(Tt, [2, 60]), e(Tt, [2, 61]), { 109: [1, 263] }, e(Tt, [2, 63]), e(Tt, [2, 65]), { 66: [1, 264], 67: Mt, 82: 218, 116: jt, 117: $t, 118: ne }, e(Tt, [2, 67]), e(Tt, [2, 68]), e(Tt, [2, 70]), e(Tt, [2, 69]), e(Tt, [2, 71]), e([10, 44, 60, 89, 102, 105, 106, 109, 111, 114, 115, 116], [2, 85]), e(J, [2, 78]), { 31: [1, 265], 67: Mt, 82: 218, 116: jt, 117: $t, 118: ne }, { 6: 11, 7: 12, 8: n, 9: o, 10: h, 11: l, 20: 17, 22: 18, 23: 19, 24: 20, 25: 21, 26: 22, 27: d, 32: [1, 266], 33: 24, 34: p, 36: g, 38: f, 42: 28, 43: 38, 44: y, 45: 39, 47: 40, 60: m, 84: x, 85: b, 86: v, 87: _, 88: A, 89: S, 102: k, 105: L, 106: T, 109: C, 111: E, 113: 41, 114: w, 115: W, 116: N, 121: B, 122: R, 123: V, 124: $ }, e(z, [2, 53]), { 43: 267, 44: y, 45: 39, 47: 40, 60: m, 89: S, 102: k, 105: L, 106: T, 109: C, 111: E, 113: 41, 114: w, 115: W, 116: N }, e(qt, [2, 121], { 106: gs }), e(qh, [2, 130], { 108: 269, 10: Sr, 60: _e, 84: ti, 105: ei, 109: ri, 110: ii, 111: si, 112: ai }), e(qr, [2, 132]), e(qr, [2, 134]), e(qr, [2, 135]), e(qr, [2, 136]), e(qr, [2, 137]), e(qr, [2, 138]), e(qr, [2, 139]), e(qr, [2, 140]), e(qr, [2, 141]), e(qt, [2, 122], { 106: gs }), { 10: [1, 270] }, e(qt, [2, 123], { 106: gs }), { 10: [1, 271] }, e($e, [2, 129]), e(qt, [2, 105], { 106: gs }), e(qt, [2, 106], { 113: 112, 44: y, 60: m, 89: S, 102: k, 105: L, 106: T, 109: C, 111: E, 114: w, 115: W, 116: N }), e(qt, [2, 110]), e(qt, [2, 112], { 10: [1, 272] }), e(qt, [2, 113]), { 98: [1, 273] }, { 51: [1, 274] }, { 62: [1, 275] }, { 66: [1, 276] }, { 8: Y, 9: M, 11: G, 21: 277 }, e(O, [2, 34]), e(z, [2, 52]), { 10: Sr, 60: _e, 84: ti, 105: ei, 107: 278, 108: 242, 109: ri, 110: ii, 111: si, 112: ai }, e(qr, [2, 133]), { 14: Z, 44: ot, 60: it, 89: bt, 101: 279, 105: xt, 106: Ct, 109: at, 111: lt, 114: Q, 115: U, 116: et, 120: 87 }, { 14: Z, 44: ot, 60: it, 89: bt, 101: 280, 105: xt, 106: Ct, 109: at, 111: lt, 114: Q, 115: U, 116: et, 120: 87 }, { 98: [1, 281] }, e(qt, [2, 120]), e(Tt, [2, 58]), { 30: 282, 67: Mt, 80: ae, 81: Zt, 82: 171, 116: jt, 117: $t, 118: ne }, e(Tt, [2, 66]), e(Se, a, { 5: 283 }), e(qh, [2, 131], { 108: 269, 10: Sr, 60: _e, 84: ti, 105: ei, 109: ri, 110: ii, 111: si, 112: ai }), e(qt, [2, 126], { 120: 167, 10: [1, 284], 14: Z, 44: ot, 60: it, 89: bt, 105: xt, 106: Ct, 109: at, 111: lt, 114: Q, 115: U, 116: et }), e(qt, [2, 127], { 120: 167, 10: [1, 285], 14: Z, 44: ot, 60: it, 89: bt, 105: xt, 106: Ct, 109: at, 111: lt, 114: Q, 115: U, 116: et }), e(qt, [2, 114]), { 31: [1, 286], 67: Mt, 82: 218, 116: jt, 117: $t, 118: ne }, { 6: 11, 7: 12, 8: n, 9: o, 10: h, 11: l, 20: 17, 22: 18, 23: 19, 24: 20, 25: 21, 26: 22, 27: d, 32: [1, 287], 33: 24, 34: p, 36: g, 38: f, 42: 28, 43: 38, 44: y, 45: 39, 47: 40, 60: m, 84: x, 85: b, 86: v, 87: _, 88: A, 89: S, 102: k, 105: L, 106: T, 109: C, 111: E, 113: 41, 114: w, 115: W, 116: N, 121: B, 122: R, 123: V, 124: $ }, { 10: Sr, 60: _e, 84: ti, 92: 288, 105: ei, 107: 241, 108: 242, 109: ri, 110: ii, 111: si, 112: ai }, { 10: Sr, 60: _e, 84: ti, 92: 289, 105: ei, 107: 241, 108: 242, 109: ri, 110: ii, 111: si, 112: ai }, e(Tt, [2, 62]), e(O, [2, 33]), e(qt, [2, 124], { 106: gs }), e(qt, [2, 125], { 106: gs })],
    defaultActions: {},
    parseError: /* @__PURE__ */ u(function(Yt, Kt) {
      if (Kt.recoverable)
        this.trace(Yt);
      else {
        var re = new Error(Yt);
        throw re.hash = Kt, re;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ u(function(Yt) {
      var Kt = this, re = [0], _t = [], Ce = [null], H = [], _a = this.table, j = "", Fe = 0, Yh = 0, dm = 2, Hh = 1, pm = H.slice.call(arguments, 1), je = Object.create(this.lexer), Vi = { yy: {} };
      for (var Jo in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, Jo) && (Vi.yy[Jo] = this.yy[Jo]);
      je.setInput(Yt, Vi.yy), Vi.yy.lexer = je, Vi.yy.parser = this, typeof je.yylloc > "u" && (je.yylloc = {});
      var tl = je.yylloc;
      H.push(tl);
      var gm = je.options && je.options.ranges;
      typeof Vi.yy.parseError == "function" ? this.parseError = Vi.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function fm(Cr) {
        re.length = re.length - 2 * Cr, Ce.length = Ce.length - Cr, H.length = H.length - Cr;
      }
      u(fm, "popStack");
      function Uh() {
        var Cr;
        return Cr = _t.pop() || je.lex() || Hh, typeof Cr != "number" && (Cr instanceof Array && (_t = Cr, Cr = _t.pop()), Cr = Kt.symbols_[Cr] || Cr), Cr;
      }
      u(Uh, "lex");
      for (var yr, zi, Lr, el, fs = {}, Sn, ni, jh, Cn; ; ) {
        if (zi = re[re.length - 1], this.defaultActions[zi] ? Lr = this.defaultActions[zi] : ((yr === null || typeof yr > "u") && (yr = Uh()), Lr = _a[zi] && _a[zi][yr]), typeof Lr > "u" || !Lr.length || !Lr[0]) {
          var rl = "";
          Cn = [];
          for (Sn in _a[zi])
            this.terminals_[Sn] && Sn > dm && Cn.push("'" + this.terminals_[Sn] + "'");
          je.showPosition ? rl = "Parse error on line " + (Fe + 1) + `:
` + je.showPosition() + `
Expecting ` + Cn.join(", ") + ", got '" + (this.terminals_[yr] || yr) + "'" : rl = "Parse error on line " + (Fe + 1) + ": Unexpected " + (yr == Hh ? "end of input" : "'" + (this.terminals_[yr] || yr) + "'"), this.parseError(rl, {
            text: je.match,
            token: this.terminals_[yr] || yr,
            line: je.yylineno,
            loc: tl,
            expected: Cn
          });
        }
        if (Lr[0] instanceof Array && Lr.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + zi + ", token: " + yr);
        switch (Lr[0]) {
          case 1:
            re.push(yr), Ce.push(je.yytext), H.push(je.yylloc), re.push(Lr[1]), yr = null, Yh = je.yyleng, j = je.yytext, Fe = je.yylineno, tl = je.yylloc;
            break;
          case 2:
            if (ni = this.productions_[Lr[1]][1], fs.$ = Ce[Ce.length - ni], fs._$ = {
              first_line: H[H.length - (ni || 1)].first_line,
              last_line: H[H.length - 1].last_line,
              first_column: H[H.length - (ni || 1)].first_column,
              last_column: H[H.length - 1].last_column
            }, gm && (fs._$.range = [
              H[H.length - (ni || 1)].range[0],
              H[H.length - 1].range[1]
            ]), el = this.performAction.apply(fs, [
              j,
              Yh,
              Fe,
              Vi.yy,
              Lr[1],
              Ce,
              H
            ].concat(pm)), typeof el < "u")
              return el;
            ni && (re = re.slice(0, -1 * ni * 2), Ce = Ce.slice(0, -1 * ni), H = H.slice(0, -1 * ni)), re.push(this.productions_[Lr[1]][0]), Ce.push(fs.$), H.push(fs._$), jh = _a[re[re.length - 2]][re[re.length - 1]], re.push(jh);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, um = /* @__PURE__ */ function() {
    var ki = {
      EOF: 1,
      parseError: /* @__PURE__ */ u(function(Kt, re) {
        if (this.yy.parser)
          this.yy.parser.parseError(Kt, re);
        else
          throw new Error(Kt);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ u(function(Yt, Kt) {
        return this.yy = Kt || this.yy || {}, this._input = Yt, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ u(function() {
        var Yt = this._input[0];
        this.yytext += Yt, this.yyleng++, this.offset++, this.match += Yt, this.matched += Yt;
        var Kt = Yt.match(/(?:\r\n?|\n).*/g);
        return Kt ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), Yt;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ u(function(Yt) {
        var Kt = Yt.length, re = Yt.split(/(?:\r\n?|\n)/g);
        this._input = Yt + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - Kt), this.offset -= Kt;
        var _t = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), re.length - 1 && (this.yylineno -= re.length - 1);
        var Ce = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: re ? (re.length === _t.length ? this.yylloc.first_column : 0) + _t[_t.length - re.length].length - re[0].length : this.yylloc.first_column - Kt
        }, this.options.ranges && (this.yylloc.range = [Ce[0], Ce[0] + this.yyleng - Kt]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ u(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ u(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ u(function(Yt) {
        this.unput(this.match.slice(Yt));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ u(function() {
        var Yt = this.matched.substr(0, this.matched.length - this.match.length);
        return (Yt.length > 20 ? "..." : "") + Yt.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ u(function() {
        var Yt = this.match;
        return Yt.length < 20 && (Yt += this._input.substr(0, 20 - Yt.length)), (Yt.substr(0, 20) + (Yt.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ u(function() {
        var Yt = this.pastInput(), Kt = new Array(Yt.length + 1).join("-");
        return Yt + this.upcomingInput() + `
` + Kt + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ u(function(Yt, Kt) {
        var re, _t, Ce;
        if (this.options.backtrack_lexer && (Ce = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (Ce.yylloc.range = this.yylloc.range.slice(0))), _t = Yt[0].match(/(?:\r\n?|\n).*/g), _t && (this.yylineno += _t.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: _t ? _t[_t.length - 1].length - _t[_t.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + Yt[0].length
        }, this.yytext += Yt[0], this.match += Yt[0], this.matches = Yt, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(Yt[0].length), this.matched += Yt[0], re = this.performAction.call(this, this.yy, this, Kt, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), re)
          return re;
        if (this._backtrack) {
          for (var H in Ce)
            this[H] = Ce[H];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ u(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var Yt, Kt, re, _t;
        this._more || (this.yytext = "", this.match = "");
        for (var Ce = this._currentRules(), H = 0; H < Ce.length; H++)
          if (re = this._input.match(this.rules[Ce[H]]), re && (!Kt || re[0].length > Kt[0].length)) {
            if (Kt = re, _t = H, this.options.backtrack_lexer) {
              if (Yt = this.test_match(re, Ce[H]), Yt !== !1)
                return Yt;
              if (this._backtrack) {
                Kt = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return Kt ? (Yt = this.test_match(Kt, Ce[_t]), Yt !== !1 ? Yt : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ u(function() {
        var Kt = this.next();
        return Kt || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ u(function(Kt) {
        this.conditionStack.push(Kt);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ u(function() {
        var Kt = this.conditionStack.length - 1;
        return Kt > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ u(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ u(function(Kt) {
        return Kt = this.conditionStack.length - 1 - Math.abs(Kt || 0), Kt >= 0 ? this.conditionStack[Kt] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ u(function(Kt) {
        this.begin(Kt);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ u(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: {},
      performAction: /* @__PURE__ */ u(function(Kt, re, _t, Ce) {
        switch (_t) {
          case 0:
            return this.begin("acc_title"), 34;
          case 1:
            return this.popState(), "acc_title_value";
          case 2:
            return this.begin("acc_descr"), 36;
          case 3:
            return this.popState(), "acc_descr_value";
          case 4:
            this.begin("acc_descr_multiline");
            break;
          case 5:
            this.popState();
            break;
          case 6:
            return "acc_descr_multiline_value";
          case 7:
            return this.pushState("shapeData"), re.yytext = "", 40;
          case 8:
            return this.pushState("shapeDataStr"), 40;
          case 9:
            return this.popState(), 40;
          case 10:
            const H = /\n\s*/g;
            return re.yytext = re.yytext.replace(H, "<br/>"), 40;
          case 11:
            return 40;
          case 12:
            this.popState();
            break;
          case 13:
            this.begin("callbackname");
            break;
          case 14:
            this.popState();
            break;
          case 15:
            this.popState(), this.begin("callbackargs");
            break;
          case 16:
            return 95;
          case 17:
            this.popState();
            break;
          case 18:
            return 96;
          case 19:
            return "MD_STR";
          case 20:
            this.popState();
            break;
          case 21:
            this.begin("md_string");
            break;
          case 22:
            return "STR";
          case 23:
            this.popState();
            break;
          case 24:
            this.pushState("string");
            break;
          case 25:
            return 84;
          case 26:
            return 102;
          case 27:
            return 85;
          case 28:
            return 104;
          case 29:
            return 86;
          case 30:
            return 87;
          case 31:
            return 97;
          case 32:
            this.begin("click");
            break;
          case 33:
            this.popState();
            break;
          case 34:
            return 88;
          case 35:
            return Kt.lex.firstGraph() && this.begin("dir"), 12;
          case 36:
            return Kt.lex.firstGraph() && this.begin("dir"), 12;
          case 37:
            return Kt.lex.firstGraph() && this.begin("dir"), 12;
          case 38:
            return 27;
          case 39:
            return 32;
          case 40:
            return 98;
          case 41:
            return 98;
          case 42:
            return 98;
          case 43:
            return 98;
          case 44:
            return this.popState(), 13;
          case 45:
            return this.popState(), 14;
          case 46:
            return this.popState(), 14;
          case 47:
            return this.popState(), 14;
          case 48:
            return this.popState(), 14;
          case 49:
            return this.popState(), 14;
          case 50:
            return this.popState(), 14;
          case 51:
            return this.popState(), 14;
          case 52:
            return this.popState(), 14;
          case 53:
            return this.popState(), 14;
          case 54:
            return this.popState(), 14;
          case 55:
            return 121;
          case 56:
            return 122;
          case 57:
            return 123;
          case 58:
            return 124;
          case 59:
            return 78;
          case 60:
            return 105;
          case 61:
            return 111;
          case 62:
            return 46;
          case 63:
            return 60;
          case 64:
            return 44;
          case 65:
            return 8;
          case 66:
            return 106;
          case 67:
            return 115;
          case 68:
            return this.popState(), 77;
          case 69:
            return this.pushState("edgeText"), 75;
          case 70:
            return 119;
          case 71:
            return this.popState(), 77;
          case 72:
            return this.pushState("thickEdgeText"), 75;
          case 73:
            return 119;
          case 74:
            return this.popState(), 77;
          case 75:
            return this.pushState("dottedEdgeText"), 75;
          case 76:
            return 119;
          case 77:
            return 77;
          case 78:
            return this.popState(), 53;
          case 79:
            return "TEXT";
          case 80:
            return this.pushState("ellipseText"), 52;
          case 81:
            return this.popState(), 55;
          case 82:
            return this.pushState("text"), 54;
          case 83:
            return this.popState(), 57;
          case 84:
            return this.pushState("text"), 56;
          case 85:
            return 58;
          case 86:
            return this.pushState("text"), 67;
          case 87:
            return this.popState(), 64;
          case 88:
            return this.pushState("text"), 63;
          case 89:
            return this.popState(), 49;
          case 90:
            return this.pushState("text"), 48;
          case 91:
            return this.popState(), 69;
          case 92:
            return this.popState(), 71;
          case 93:
            return 117;
          case 94:
            return this.pushState("trapText"), 68;
          case 95:
            return this.pushState("trapText"), 70;
          case 96:
            return 118;
          case 97:
            return 67;
          case 98:
            return 90;
          case 99:
            return "SEP";
          case 100:
            return 89;
          case 101:
            return 115;
          case 102:
            return 111;
          case 103:
            return 44;
          case 104:
            return 109;
          case 105:
            return 114;
          case 106:
            return 116;
          case 107:
            return this.popState(), 62;
          case 108:
            return this.pushState("text"), 62;
          case 109:
            return this.popState(), 51;
          case 110:
            return this.pushState("text"), 50;
          case 111:
            return this.popState(), 31;
          case 112:
            return this.pushState("text"), 29;
          case 113:
            return this.popState(), 66;
          case 114:
            return this.pushState("text"), 65;
          case 115:
            return "TEXT";
          case 116:
            return "QUOTE";
          case 117:
            return 9;
          case 118:
            return 10;
          case 119:
            return 11;
        }
      }, "anonymous"),
      rules: [/^(?:accTitle\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*\{\s*)/, /^(?:[\}])/, /^(?:[^\}]*)/, /^(?:@\{)/, /^(?:["])/, /^(?:["])/, /^(?:[^\"]+)/, /^(?:[^}^"]+)/, /^(?:\})/, /^(?:call[\s]+)/, /^(?:\([\s]*\))/, /^(?:\()/, /^(?:[^(]*)/, /^(?:\))/, /^(?:[^)]*)/, /^(?:[^`"]+)/, /^(?:[`]["])/, /^(?:["][`])/, /^(?:[^"]+)/, /^(?:["])/, /^(?:["])/, /^(?:style\b)/, /^(?:default\b)/, /^(?:linkStyle\b)/, /^(?:interpolate\b)/, /^(?:classDef\b)/, /^(?:class\b)/, /^(?:href[\s])/, /^(?:click[\s]+)/, /^(?:[\s\n])/, /^(?:[^\s\n]*)/, /^(?:flowchart-elk\b)/, /^(?:graph\b)/, /^(?:flowchart\b)/, /^(?:subgraph\b)/, /^(?:end\b\s*)/, /^(?:_self\b)/, /^(?:_blank\b)/, /^(?:_parent\b)/, /^(?:_top\b)/, /^(?:(\r?\n)*\s*\n)/, /^(?:\s*LR\b)/, /^(?:\s*RL\b)/, /^(?:\s*TB\b)/, /^(?:\s*BT\b)/, /^(?:\s*TD\b)/, /^(?:\s*BR\b)/, /^(?:\s*<)/, /^(?:\s*>)/, /^(?:\s*\^)/, /^(?:\s*v\b)/, /^(?:.*direction\s+TB[^\n]*)/, /^(?:.*direction\s+BT[^\n]*)/, /^(?:.*direction\s+RL[^\n]*)/, /^(?:.*direction\s+LR[^\n]*)/, /^(?:[^\s\"]+@(?=[^\{\"]))/, /^(?:[0-9]+)/, /^(?:#)/, /^(?::::)/, /^(?::)/, /^(?:&)/, /^(?:;)/, /^(?:,)/, /^(?:\*)/, /^(?:\s*[xo<]?--+[-xo>]\s*)/, /^(?:\s*[xo<]?--\s*)/, /^(?:[^-]|-(?!-)+)/, /^(?:\s*[xo<]?==+[=xo>]\s*)/, /^(?:\s*[xo<]?==\s*)/, /^(?:[^=]|=(?!))/, /^(?:\s*[xo<]?-?\.+-[xo>]?\s*)/, /^(?:\s*[xo<]?-\.\s*)/, /^(?:[^\.]|\.(?!))/, /^(?:\s*~~[\~]+\s*)/, /^(?:[-/\)][\)])/, /^(?:[^\(\)\[\]\{\}]|!\)+)/, /^(?:\(-)/, /^(?:\]\))/, /^(?:\(\[)/, /^(?:\]\])/, /^(?:\[\[)/, /^(?:\[\|)/, /^(?:>)/, /^(?:\)\])/, /^(?:\[\()/, /^(?:\)\)\))/, /^(?:\(\(\()/, /^(?:[\\(?=\])][\]])/, /^(?:\/(?=\])\])/, /^(?:\/(?!\])|\\(?!\])|[^\\\[\]\(\)\{\}\/]+)/, /^(?:\[\/)/, /^(?:\[\\)/, /^(?:<)/, /^(?:>)/, /^(?:\^)/, /^(?:\\\|)/, /^(?:v\b)/, /^(?:\*)/, /^(?:#)/, /^(?:&)/, /^(?:([A-Za-z0-9!"\#$%&'*+\.`?\\_\/]|-(?=[^\>\-\.])|(?!))+)/, /^(?:-)/, /^(?:[\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6]|[\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377]|[\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5]|[\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA]|[\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE]|[\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA]|[\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0]|[\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977]|[\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2]|[\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A]|[\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39]|[\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8]|[\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C]|[\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C]|[\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99]|[\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0]|[\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D]|[\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3]|[\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10]|[\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1]|[\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81]|[\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3]|[\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6]|[\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A]|[\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081]|[\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D]|[\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0]|[\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310]|[\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C]|[\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711]|[\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7]|[\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C]|[\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16]|[\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF]|[\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC]|[\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D]|[\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D]|[\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3]|[\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F]|[\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128]|[\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184]|[\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3]|[\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6]|[\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE]|[\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C]|[\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D]|[\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC]|[\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B]|[\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788]|[\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805]|[\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB]|[\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28]|[\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5]|[\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4]|[\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E]|[\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D]|[\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36]|[\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D]|[\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC]|[\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF]|[\uFFD2-\uFFD7\uFFDA-\uFFDC])/, /^(?:\|)/, /^(?:\|)/, /^(?:\))/, /^(?:\()/, /^(?:\])/, /^(?:\[)/, /^(?:(\}))/, /^(?:\{)/, /^(?:[^\[\]\(\)\{\}\|\"]+)/, /^(?:")/, /^(?:(\r?\n)+)/, /^(?:\s)/, /^(?:$)/],
      conditions: { shapeDataEndBracket: { rules: [21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, shapeDataStr: { rules: [9, 10, 21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, shapeData: { rules: [8, 11, 12, 21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, callbackargs: { rules: [17, 18, 21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, callbackname: { rules: [14, 15, 16, 21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, href: { rules: [21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, click: { rules: [21, 24, 33, 34, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, dottedEdgeText: { rules: [21, 24, 74, 76, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, thickEdgeText: { rules: [21, 24, 71, 73, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, edgeText: { rules: [21, 24, 68, 70, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, trapText: { rules: [21, 24, 77, 80, 82, 84, 88, 90, 91, 92, 93, 94, 95, 108, 110, 112, 114], inclusive: !1 }, ellipseText: { rules: [21, 24, 77, 78, 79, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, text: { rules: [21, 24, 77, 80, 81, 82, 83, 84, 87, 88, 89, 90, 94, 95, 107, 108, 109, 110, 111, 112, 113, 114, 115], inclusive: !1 }, vertex: { rules: [21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, dir: { rules: [21, 24, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, acc_descr_multiline: { rules: [5, 6, 21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, acc_descr: { rules: [3, 21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, acc_title: { rules: [1, 21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, md_string: { rules: [19, 20, 21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, string: { rules: [21, 22, 23, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114], inclusive: !1 }, INITIAL: { rules: [0, 2, 4, 7, 13, 21, 24, 25, 26, 27, 28, 29, 30, 31, 32, 35, 36, 37, 38, 39, 40, 41, 42, 43, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 71, 72, 74, 75, 77, 80, 82, 84, 85, 86, 88, 90, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 108, 110, 112, 114, 116, 117, 118, 119], inclusive: !0 } }
    };
    return ki;
  }();
  Zo.lexer = um;
  function vn() {
    this.yy = {};
  }
  return u(vn, "Parser"), vn.prototype = Zo, Zo.Parser = vn, new vn();
}();
Hl.parser = Hl;
var Df = Hl, If = Object.assign({}, Df);
If.parse = (e) => {
  const t = e.replace(/}\s*\n/g, `}
`);
  return Df.parse(t);
};
var hv = If, uv = /* @__PURE__ */ u((e, t) => {
  const r = wc, i = r(e, "r"), s = r(e, "g"), a = r(e, "b");
  return Zi(i, s, a, t);
}, "fade"), dv = /* @__PURE__ */ u((e) => `.label {
    font-family: ${e.fontFamily};
    color: ${e.nodeTextColor || e.textColor};
  }
  .cluster-label text {
    fill: ${e.titleColor};
  }
  .cluster-label span {
    color: ${e.titleColor};
  }
  .cluster-label span p {
    background-color: transparent;
  }

  .label text,span {
    fill: ${e.nodeTextColor || e.textColor};
    color: ${e.nodeTextColor || e.textColor};
  }

  .node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${e.mainBkg};
    stroke: ${e.nodeBorder};
    stroke-width: 1px;
  }
  .rough-node .label text , .node .label text, .image-shape .label, .icon-shape .label {
    text-anchor: middle;
  }
  // .flowchart-label .text-outer-tspan {
  //   text-anchor: middle;
  // }
  // .flowchart-label .text-inner-tspan {
  //   text-anchor: start;
  // }

  .node .katex path {
    fill: #000;
    stroke: #000;
    stroke-width: 1px;
  }

  .rough-node .label,.node .label, .image-shape .label, .icon-shape .label {
    text-align: center;
  }
  .node.clickable {
    cursor: pointer;
  }


  .root .anchor path {
    fill: ${e.lineColor} !important;
    stroke-width: 0;
    stroke: ${e.lineColor};
  }

  .arrowheadPath {
    fill: ${e.arrowheadColor};
  }

  .edgePath .path {
    stroke: ${e.lineColor};
    stroke-width: 2.0px;
  }

  .flowchart-link {
    stroke: ${e.lineColor};
    fill: none;
  }

  .edgeLabel {
    background-color: ${e.edgeLabelBackground};
    p {
      background-color: ${e.edgeLabelBackground};
    }
    rect {
      opacity: 0.5;
      background-color: ${e.edgeLabelBackground};
      fill: ${e.edgeLabelBackground};
    }
    text-align: center;
  }

  /* For html labels only */
  .labelBkg {
    background-color: ${uv(e.edgeLabelBackground, 0.5)};
    // background-color:
  }

  .cluster rect {
    fill: ${e.clusterBkg};
    stroke: ${e.clusterBorder};
    stroke-width: 1px;
  }

  .cluster text {
    fill: ${e.titleColor};
  }

  .cluster span {
    color: ${e.titleColor};
  }
  /* .cluster div {
    color: ${e.titleColor};
  } */

  div.mermaidTooltip {
    position: absolute;
    text-align: center;
    max-width: 200px;
    padding: 2px;
    font-family: ${e.fontFamily};
    font-size: 12px;
    background: ${e.tertiaryColor};
    border: 1px solid ${e.border2};
    border-radius: 2px;
    pointer-events: none;
    z-index: 100;
  }

  .flowchartTitleText {
    text-anchor: middle;
    font-size: 18px;
    fill: ${e.textColor};
  }

  rect.text {
    fill: none;
    stroke-width: 0;
  }

  .icon-shape, .image-shape {
    background-color: ${e.edgeLabelBackground};
    p {
      background-color: ${e.edgeLabelBackground};
      padding: 2px;
    }
    rect {
      opacity: 0.5;
      background-color: ${e.edgeLabelBackground};
      fill: ${e.edgeLabelBackground};
    }
    text-align: center;
  }
  ${yn()}
`, "getStyles"), pv = dv, gv = {
  parser: hv,
  get db() {
    return new nv();
  },
  renderer: cv,
  styles: pv,
  init: /* @__PURE__ */ u((e) => {
    e.flowchart || (e.flowchart = {}), e.layout && ml({ layout: e.layout }), e.flowchart.arrowMarkerAbsolute = e.arrowMarkerAbsolute, ml({ flowchart: { arrowMarkerAbsolute: e.arrowMarkerAbsolute } });
  }, "init")
};
const oh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: gv
}, Symbol.toStringTag, { value: "Module" }));
var Ul = function() {
  var e = /* @__PURE__ */ u(function(lt, Q, U, et) {
    for (U = U || {}, et = lt.length; et--; U[lt[et]] = Q) ;
    return U;
  }, "o"), t = [6, 8, 10, 22, 24, 26, 28, 33, 34, 35, 36, 37, 40, 43, 44, 50], r = [1, 10], i = [1, 11], s = [1, 12], a = [1, 13], n = [1, 20], o = [1, 21], h = [1, 22], l = [1, 23], d = [1, 24], p = [1, 19], g = [1, 25], f = [1, 26], y = [1, 18], m = [1, 33], x = [1, 34], b = [1, 35], v = [1, 36], _ = [1, 37], A = [6, 8, 10, 13, 15, 17, 20, 21, 22, 24, 26, 28, 33, 34, 35, 36, 37, 40, 43, 44, 50, 63, 64, 65, 66, 67], S = [1, 42], k = [1, 43], L = [1, 52], T = [40, 50, 68, 69], C = [1, 63], E = [1, 61], w = [1, 58], W = [1, 62], N = [1, 64], B = [6, 8, 10, 13, 17, 22, 24, 26, 28, 33, 34, 35, 36, 37, 40, 41, 42, 43, 44, 48, 49, 50, 63, 64, 65, 66, 67], R = [63, 64, 65, 66, 67], V = [1, 81], $ = [1, 80], D = [1, 78], O = [1, 79], Y = [6, 10, 42, 47], M = [6, 10, 13, 41, 42, 47, 48, 49], G = [1, 89], rt = [1, 88], ht = [1, 87], Z = [19, 56], ot = [1, 98], it = [1, 97], bt = [19, 56, 58, 60], xt = {
    trace: /* @__PURE__ */ u(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, start: 3, ER_DIAGRAM: 4, document: 5, EOF: 6, line: 7, SPACE: 8, statement: 9, NEWLINE: 10, entityName: 11, relSpec: 12, COLON: 13, role: 14, STYLE_SEPARATOR: 15, idList: 16, BLOCK_START: 17, attributes: 18, BLOCK_STOP: 19, SQS: 20, SQE: 21, title: 22, title_value: 23, acc_title: 24, acc_title_value: 25, acc_descr: 26, acc_descr_value: 27, acc_descr_multiline_value: 28, direction: 29, classDefStatement: 30, classStatement: 31, styleStatement: 32, direction_tb: 33, direction_bt: 34, direction_rl: 35, direction_lr: 36, CLASSDEF: 37, stylesOpt: 38, separator: 39, UNICODE_TEXT: 40, STYLE_TEXT: 41, COMMA: 42, CLASS: 43, STYLE: 44, style: 45, styleComponent: 46, SEMI: 47, NUM: 48, BRKT: 49, ENTITY_NAME: 50, attribute: 51, attributeType: 52, attributeName: 53, attributeKeyTypeList: 54, attributeComment: 55, ATTRIBUTE_WORD: 56, attributeKeyType: 57, ",": 58, ATTRIBUTE_KEY: 59, COMMENT: 60, cardinality: 61, relType: 62, ZERO_OR_ONE: 63, ZERO_OR_MORE: 64, ONE_OR_MORE: 65, ONLY_ONE: 66, MD_PARENT: 67, NON_IDENTIFYING: 68, IDENTIFYING: 69, WORD: 70, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 4: "ER_DIAGRAM", 6: "EOF", 8: "SPACE", 10: "NEWLINE", 13: "COLON", 15: "STYLE_SEPARATOR", 17: "BLOCK_START", 19: "BLOCK_STOP", 20: "SQS", 21: "SQE", 22: "title", 23: "title_value", 24: "acc_title", 25: "acc_title_value", 26: "acc_descr", 27: "acc_descr_value", 28: "acc_descr_multiline_value", 33: "direction_tb", 34: "direction_bt", 35: "direction_rl", 36: "direction_lr", 37: "CLASSDEF", 40: "UNICODE_TEXT", 41: "STYLE_TEXT", 42: "COMMA", 43: "CLASS", 44: "STYLE", 47: "SEMI", 48: "NUM", 49: "BRKT", 50: "ENTITY_NAME", 56: "ATTRIBUTE_WORD", 58: ",", 59: "ATTRIBUTE_KEY", 60: "COMMENT", 63: "ZERO_OR_ONE", 64: "ZERO_OR_MORE", 65: "ONE_OR_MORE", 66: "ONLY_ONE", 67: "MD_PARENT", 68: "NON_IDENTIFYING", 69: "IDENTIFYING", 70: "WORD" },
    productions_: [0, [3, 3], [5, 0], [5, 2], [7, 2], [7, 1], [7, 1], [7, 1], [9, 5], [9, 9], [9, 7], [9, 7], [9, 4], [9, 6], [9, 3], [9, 5], [9, 1], [9, 3], [9, 7], [9, 9], [9, 6], [9, 8], [9, 4], [9, 6], [9, 2], [9, 2], [9, 2], [9, 1], [9, 1], [9, 1], [9, 1], [9, 1], [29, 1], [29, 1], [29, 1], [29, 1], [30, 4], [16, 1], [16, 1], [16, 3], [16, 3], [31, 3], [32, 4], [38, 1], [38, 3], [45, 1], [45, 2], [39, 1], [39, 1], [39, 1], [46, 1], [46, 1], [46, 1], [46, 1], [11, 1], [11, 1], [18, 1], [18, 2], [51, 2], [51, 3], [51, 3], [51, 4], [52, 1], [53, 1], [54, 1], [54, 3], [57, 1], [55, 1], [12, 3], [61, 1], [61, 1], [61, 1], [61, 1], [61, 1], [62, 1], [62, 1], [14, 1], [14, 1], [14, 1]],
    performAction: /* @__PURE__ */ u(function(Q, U, et, z, Tt, F, te) {
      var J = F.length - 1;
      switch (Tt) {
        case 1:
          break;
        case 2:
          this.$ = [];
          break;
        case 3:
          F[J - 1].push(F[J]), this.$ = F[J - 1];
          break;
        case 4:
        case 5:
          this.$ = F[J];
          break;
        case 6:
        case 7:
          this.$ = [];
          break;
        case 8:
          z.addEntity(F[J - 4]), z.addEntity(F[J - 2]), z.addRelationship(F[J - 4], F[J], F[J - 2], F[J - 3]);
          break;
        case 9:
          z.addEntity(F[J - 8]), z.addEntity(F[J - 4]), z.addRelationship(F[J - 8], F[J], F[J - 4], F[J - 5]), z.setClass([F[J - 8]], F[J - 6]), z.setClass([F[J - 4]], F[J - 2]);
          break;
        case 10:
          z.addEntity(F[J - 6]), z.addEntity(F[J - 2]), z.addRelationship(F[J - 6], F[J], F[J - 2], F[J - 3]), z.setClass([F[J - 6]], F[J - 4]);
          break;
        case 11:
          z.addEntity(F[J - 6]), z.addEntity(F[J - 4]), z.addRelationship(F[J - 6], F[J], F[J - 4], F[J - 5]), z.setClass([F[J - 4]], F[J - 2]);
          break;
        case 12:
          z.addEntity(F[J - 3]), z.addAttributes(F[J - 3], F[J - 1]);
          break;
        case 13:
          z.addEntity(F[J - 5]), z.addAttributes(F[J - 5], F[J - 1]), z.setClass([F[J - 5]], F[J - 3]);
          break;
        case 14:
          z.addEntity(F[J - 2]);
          break;
        case 15:
          z.addEntity(F[J - 4]), z.setClass([F[J - 4]], F[J - 2]);
          break;
        case 16:
          z.addEntity(F[J]);
          break;
        case 17:
          z.addEntity(F[J - 2]), z.setClass([F[J - 2]], F[J]);
          break;
        case 18:
          z.addEntity(F[J - 6], F[J - 4]), z.addAttributes(F[J - 6], F[J - 1]);
          break;
        case 19:
          z.addEntity(F[J - 8], F[J - 6]), z.addAttributes(F[J - 8], F[J - 1]), z.setClass([F[J - 8]], F[J - 3]);
          break;
        case 20:
          z.addEntity(F[J - 5], F[J - 3]);
          break;
        case 21:
          z.addEntity(F[J - 7], F[J - 5]), z.setClass([F[J - 7]], F[J - 2]);
          break;
        case 22:
          z.addEntity(F[J - 3], F[J - 1]);
          break;
        case 23:
          z.addEntity(F[J - 5], F[J - 3]), z.setClass([F[J - 5]], F[J]);
          break;
        case 24:
        case 25:
          this.$ = F[J].trim(), z.setAccTitle(this.$);
          break;
        case 26:
        case 27:
          this.$ = F[J].trim(), z.setAccDescription(this.$);
          break;
        case 32:
          z.setDirection("TB");
          break;
        case 33:
          z.setDirection("BT");
          break;
        case 34:
          z.setDirection("RL");
          break;
        case 35:
          z.setDirection("LR");
          break;
        case 36:
          this.$ = F[J - 3], z.addClass(F[J - 2], F[J - 1]);
          break;
        case 37:
        case 38:
        case 56:
        case 64:
          this.$ = [F[J]];
          break;
        case 39:
        case 40:
          this.$ = F[J - 2].concat([F[J]]);
          break;
        case 41:
          this.$ = F[J - 2], z.setClass(F[J - 1], F[J]);
          break;
        case 42:
          this.$ = F[J - 3], z.addCssStyles(F[J - 2], F[J - 1]);
          break;
        case 43:
          this.$ = [F[J]];
          break;
        case 44:
          F[J - 2].push(F[J]), this.$ = F[J - 2];
          break;
        case 46:
          this.$ = F[J - 1] + F[J];
          break;
        case 54:
        case 76:
        case 77:
          this.$ = F[J].replace(/"/g, "");
          break;
        case 55:
        case 78:
          this.$ = F[J];
          break;
        case 57:
          F[J].push(F[J - 1]), this.$ = F[J];
          break;
        case 58:
          this.$ = { type: F[J - 1], name: F[J] };
          break;
        case 59:
          this.$ = { type: F[J - 2], name: F[J - 1], keys: F[J] };
          break;
        case 60:
          this.$ = { type: F[J - 2], name: F[J - 1], comment: F[J] };
          break;
        case 61:
          this.$ = { type: F[J - 3], name: F[J - 2], keys: F[J - 1], comment: F[J] };
          break;
        case 62:
        case 63:
        case 66:
          this.$ = F[J];
          break;
        case 65:
          F[J - 2].push(F[J]), this.$ = F[J - 2];
          break;
        case 67:
          this.$ = F[J].replace(/"/g, "");
          break;
        case 68:
          this.$ = { cardA: F[J], relType: F[J - 1], cardB: F[J - 2] };
          break;
        case 69:
          this.$ = z.Cardinality.ZERO_OR_ONE;
          break;
        case 70:
          this.$ = z.Cardinality.ZERO_OR_MORE;
          break;
        case 71:
          this.$ = z.Cardinality.ONE_OR_MORE;
          break;
        case 72:
          this.$ = z.Cardinality.ONLY_ONE;
          break;
        case 73:
          this.$ = z.Cardinality.MD_PARENT;
          break;
        case 74:
          this.$ = z.Identification.NON_IDENTIFYING;
          break;
        case 75:
          this.$ = z.Identification.IDENTIFYING;
          break;
      }
    }, "anonymous"),
    table: [{ 3: 1, 4: [1, 2] }, { 1: [3] }, e(t, [2, 2], { 5: 3 }), { 6: [1, 4], 7: 5, 8: [1, 6], 9: 7, 10: [1, 8], 11: 9, 22: r, 24: i, 26: s, 28: a, 29: 14, 30: 15, 31: 16, 32: 17, 33: n, 34: o, 35: h, 36: l, 37: d, 40: p, 43: g, 44: f, 50: y }, e(t, [2, 7], { 1: [2, 1] }), e(t, [2, 3]), { 9: 27, 11: 9, 22: r, 24: i, 26: s, 28: a, 29: 14, 30: 15, 31: 16, 32: 17, 33: n, 34: o, 35: h, 36: l, 37: d, 40: p, 43: g, 44: f, 50: y }, e(t, [2, 5]), e(t, [2, 6]), e(t, [2, 16], { 12: 28, 61: 32, 15: [1, 29], 17: [1, 30], 20: [1, 31], 63: m, 64: x, 65: b, 66: v, 67: _ }), { 23: [1, 38] }, { 25: [1, 39] }, { 27: [1, 40] }, e(t, [2, 27]), e(t, [2, 28]), e(t, [2, 29]), e(t, [2, 30]), e(t, [2, 31]), e(A, [2, 54]), e(A, [2, 55]), e(t, [2, 32]), e(t, [2, 33]), e(t, [2, 34]), e(t, [2, 35]), { 16: 41, 40: S, 41: k }, { 16: 44, 40: S, 41: k }, { 16: 45, 40: S, 41: k }, e(t, [2, 4]), { 11: 46, 40: p, 50: y }, { 16: 47, 40: S, 41: k }, { 18: 48, 19: [1, 49], 51: 50, 52: 51, 56: L }, { 11: 53, 40: p, 50: y }, { 62: 54, 68: [1, 55], 69: [1, 56] }, e(T, [2, 69]), e(T, [2, 70]), e(T, [2, 71]), e(T, [2, 72]), e(T, [2, 73]), e(t, [2, 24]), e(t, [2, 25]), e(t, [2, 26]), { 13: C, 38: 57, 41: E, 42: w, 45: 59, 46: 60, 48: W, 49: N }, e(B, [2, 37]), e(B, [2, 38]), { 16: 65, 40: S, 41: k, 42: w }, { 13: C, 38: 66, 41: E, 42: w, 45: 59, 46: 60, 48: W, 49: N }, { 13: [1, 67], 15: [1, 68] }, e(t, [2, 17], { 61: 32, 12: 69, 17: [1, 70], 42: w, 63: m, 64: x, 65: b, 66: v, 67: _ }), { 19: [1, 71] }, e(t, [2, 14]), { 18: 72, 19: [2, 56], 51: 50, 52: 51, 56: L }, { 53: 73, 56: [1, 74] }, { 56: [2, 62] }, { 21: [1, 75] }, { 61: 76, 63: m, 64: x, 65: b, 66: v, 67: _ }, e(R, [2, 74]), e(R, [2, 75]), { 6: V, 10: $, 39: 77, 42: D, 47: O }, { 40: [1, 82], 41: [1, 83] }, e(Y, [2, 43], { 46: 84, 13: C, 41: E, 48: W, 49: N }), e(M, [2, 45]), e(M, [2, 50]), e(M, [2, 51]), e(M, [2, 52]), e(M, [2, 53]), e(t, [2, 41], { 42: w }), { 6: V, 10: $, 39: 85, 42: D, 47: O }, { 14: 86, 40: G, 50: rt, 70: ht }, { 16: 90, 40: S, 41: k }, { 11: 91, 40: p, 50: y }, { 18: 92, 19: [1, 93], 51: 50, 52: 51, 56: L }, e(t, [2, 12]), { 19: [2, 57] }, e(Z, [2, 58], { 54: 94, 55: 95, 57: 96, 59: ot, 60: it }), e([19, 56, 59, 60], [2, 63]), e(t, [2, 22], { 15: [1, 100], 17: [1, 99] }), e([40, 50], [2, 68]), e(t, [2, 36]), { 13: C, 41: E, 45: 101, 46: 60, 48: W, 49: N }, e(t, [2, 47]), e(t, [2, 48]), e(t, [2, 49]), e(B, [2, 39]), e(B, [2, 40]), e(M, [2, 46]), e(t, [2, 42]), e(t, [2, 8]), e(t, [2, 76]), e(t, [2, 77]), e(t, [2, 78]), { 13: [1, 102], 42: w }, { 13: [1, 104], 15: [1, 103] }, { 19: [1, 105] }, e(t, [2, 15]), e(Z, [2, 59], { 55: 106, 58: [1, 107], 60: it }), e(Z, [2, 60]), e(bt, [2, 64]), e(Z, [2, 67]), e(bt, [2, 66]), { 18: 108, 19: [1, 109], 51: 50, 52: 51, 56: L }, { 16: 110, 40: S, 41: k }, e(Y, [2, 44], { 46: 84, 13: C, 41: E, 48: W, 49: N }), { 14: 111, 40: G, 50: rt, 70: ht }, { 16: 112, 40: S, 41: k }, { 14: 113, 40: G, 50: rt, 70: ht }, e(t, [2, 13]), e(Z, [2, 61]), { 57: 114, 59: ot }, { 19: [1, 115] }, e(t, [2, 20]), e(t, [2, 23], { 17: [1, 116], 42: w }), e(t, [2, 11]), { 13: [1, 117], 42: w }, e(t, [2, 10]), e(bt, [2, 65]), e(t, [2, 18]), { 18: 118, 19: [1, 119], 51: 50, 52: 51, 56: L }, { 14: 120, 40: G, 50: rt, 70: ht }, { 19: [1, 121] }, e(t, [2, 21]), e(t, [2, 9]), e(t, [2, 19])],
    defaultActions: { 52: [2, 62], 72: [2, 57] },
    parseError: /* @__PURE__ */ u(function(Q, U) {
      if (U.recoverable)
        this.trace(Q);
      else {
        var et = new Error(Q);
        throw et.hash = U, et;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ u(function(Q) {
      var U = this, et = [0], z = [], Tt = [null], F = [], te = this.table, J = "", Ut = 0, Wt = 0, ie = 2, dt = 1, wt = F.slice.call(arguments, 1), nt = Object.create(this.lexer), ut = { yy: {} };
      for (var kt in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, kt) && (ut.yy[kt] = this.yy[kt]);
      nt.setInput(Q, ut.yy), ut.yy.lexer = nt, ut.yy.parser = this, typeof nt.yylloc > "u" && (nt.yylloc = {});
      var X = nt.yylloc;
      F.push(X);
      var ft = nt.options && nt.options.ranges;
      typeof ut.yy.parseError == "function" ? this.parseError = ut.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function P(se) {
        et.length = et.length - 2 * se, Tt.length = Tt.length - se, F.length = F.length - se;
      }
      u(P, "popStack");
      function At() {
        var se;
        return se = z.pop() || nt.lex() || dt, typeof se != "number" && (se instanceof Array && (z = se, se = z.pop()), se = U.symbols_[se] || se), se;
      }
      u(At, "lex");
      for (var q, vt, ct, Nt, pt = {}, gt, Jt, Et, ue; ; ) {
        if (vt = et[et.length - 1], this.defaultActions[vt] ? ct = this.defaultActions[vt] : ((q === null || typeof q > "u") && (q = At()), ct = te[vt] && te[vt][q]), typeof ct > "u" || !ct.length || !ct[0]) {
          var Ke = "";
          ue = [];
          for (gt in te[vt])
            this.terminals_[gt] && gt > ie && ue.push("'" + this.terminals_[gt] + "'");
          nt.showPosition ? Ke = "Parse error on line " + (Ut + 1) + `:
` + nt.showPosition() + `
Expecting ` + ue.join(", ") + ", got '" + (this.terminals_[q] || q) + "'" : Ke = "Parse error on line " + (Ut + 1) + ": Unexpected " + (q == dt ? "end of input" : "'" + (this.terminals_[q] || q) + "'"), this.parseError(Ke, {
            text: nt.match,
            token: this.terminals_[q] || q,
            line: nt.yylineno,
            loc: X,
            expected: ue
          });
        }
        if (ct[0] instanceof Array && ct.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + vt + ", token: " + q);
        switch (ct[0]) {
          case 1:
            et.push(q), Tt.push(nt.yytext), F.push(nt.yylloc), et.push(ct[1]), q = null, Wt = nt.yyleng, J = nt.yytext, Ut = nt.yylineno, X = nt.yylloc;
            break;
          case 2:
            if (Jt = this.productions_[ct[1]][1], pt.$ = Tt[Tt.length - Jt], pt._$ = {
              first_line: F[F.length - (Jt || 1)].first_line,
              last_line: F[F.length - 1].last_line,
              first_column: F[F.length - (Jt || 1)].first_column,
              last_column: F[F.length - 1].last_column
            }, ft && (pt._$.range = [
              F[F.length - (Jt || 1)].range[0],
              F[F.length - 1].range[1]
            ]), Nt = this.performAction.apply(pt, [
              J,
              Wt,
              Ut,
              ut.yy,
              ct[1],
              Tt,
              F
            ].concat(wt)), typeof Nt < "u")
              return Nt;
            Jt && (et = et.slice(0, -1 * Jt * 2), Tt = Tt.slice(0, -1 * Jt), F = F.slice(0, -1 * Jt)), et.push(this.productions_[ct[1]][0]), Tt.push(pt.$), F.push(pt._$), Et = te[et[et.length - 2]][et[et.length - 1]], et.push(Et);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, Ct = /* @__PURE__ */ function() {
    var lt = {
      EOF: 1,
      parseError: /* @__PURE__ */ u(function(U, et) {
        if (this.yy.parser)
          this.yy.parser.parseError(U, et);
        else
          throw new Error(U);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ u(function(Q, U) {
        return this.yy = U || this.yy || {}, this._input = Q, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ u(function() {
        var Q = this._input[0];
        this.yytext += Q, this.yyleng++, this.offset++, this.match += Q, this.matched += Q;
        var U = Q.match(/(?:\r\n?|\n).*/g);
        return U ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), Q;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ u(function(Q) {
        var U = Q.length, et = Q.split(/(?:\r\n?|\n)/g);
        this._input = Q + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - U), this.offset -= U;
        var z = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), et.length - 1 && (this.yylineno -= et.length - 1);
        var Tt = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: et ? (et.length === z.length ? this.yylloc.first_column : 0) + z[z.length - et.length].length - et[0].length : this.yylloc.first_column - U
        }, this.options.ranges && (this.yylloc.range = [Tt[0], Tt[0] + this.yyleng - U]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ u(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ u(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ u(function(Q) {
        this.unput(this.match.slice(Q));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ u(function() {
        var Q = this.matched.substr(0, this.matched.length - this.match.length);
        return (Q.length > 20 ? "..." : "") + Q.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ u(function() {
        var Q = this.match;
        return Q.length < 20 && (Q += this._input.substr(0, 20 - Q.length)), (Q.substr(0, 20) + (Q.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ u(function() {
        var Q = this.pastInput(), U = new Array(Q.length + 1).join("-");
        return Q + this.upcomingInput() + `
` + U + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ u(function(Q, U) {
        var et, z, Tt;
        if (this.options.backtrack_lexer && (Tt = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (Tt.yylloc.range = this.yylloc.range.slice(0))), z = Q[0].match(/(?:\r\n?|\n).*/g), z && (this.yylineno += z.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: z ? z[z.length - 1].length - z[z.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + Q[0].length
        }, this.yytext += Q[0], this.match += Q[0], this.matches = Q, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(Q[0].length), this.matched += Q[0], et = this.performAction.call(this, this.yy, this, U, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), et)
          return et;
        if (this._backtrack) {
          for (var F in Tt)
            this[F] = Tt[F];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ u(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var Q, U, et, z;
        this._more || (this.yytext = "", this.match = "");
        for (var Tt = this._currentRules(), F = 0; F < Tt.length; F++)
          if (et = this._input.match(this.rules[Tt[F]]), et && (!U || et[0].length > U[0].length)) {
            if (U = et, z = F, this.options.backtrack_lexer) {
              if (Q = this.test_match(et, Tt[F]), Q !== !1)
                return Q;
              if (this._backtrack) {
                U = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return U ? (Q = this.test_match(U, Tt[z]), Q !== !1 ? Q : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ u(function() {
        var U = this.next();
        return U || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ u(function(U) {
        this.conditionStack.push(U);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ u(function() {
        var U = this.conditionStack.length - 1;
        return U > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ u(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ u(function(U) {
        return U = this.conditionStack.length - 1 - Math.abs(U || 0), U >= 0 ? this.conditionStack[U] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ u(function(U) {
        this.begin(U);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ u(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: { "case-insensitive": !0 },
      performAction: /* @__PURE__ */ u(function(U, et, z, Tt) {
        switch (z) {
          case 0:
            return this.begin("acc_title"), 24;
          case 1:
            return this.popState(), "acc_title_value";
          case 2:
            return this.begin("acc_descr"), 26;
          case 3:
            return this.popState(), "acc_descr_value";
          case 4:
            this.begin("acc_descr_multiline");
            break;
          case 5:
            this.popState();
            break;
          case 6:
            return "acc_descr_multiline_value";
          case 7:
            return 33;
          case 8:
            return 34;
          case 9:
            return 35;
          case 10:
            return 36;
          case 11:
            return 10;
          case 12:
            break;
          case 13:
            return 8;
          case 14:
            return 50;
          case 15:
            return 70;
          case 16:
            return 4;
          case 17:
            return this.begin("block"), 17;
          case 18:
            return 49;
          case 19:
            return 49;
          case 20:
            return 42;
          case 21:
            return 15;
          case 22:
            return 13;
          case 23:
            break;
          case 24:
            return 59;
          case 25:
            return 56;
          case 26:
            return 56;
          case 27:
            return 60;
          case 28:
            break;
          case 29:
            return this.popState(), 19;
          case 30:
            return et.yytext[0];
          case 31:
            return 20;
          case 32:
            return 21;
          case 33:
            return this.begin("style"), 44;
          case 34:
            return this.popState(), 10;
          case 35:
            break;
          case 36:
            return 13;
          case 37:
            return 42;
          case 38:
            return 49;
          case 39:
            return this.begin("style"), 37;
          case 40:
            return 43;
          case 41:
            return 63;
          case 42:
            return 65;
          case 43:
            return 65;
          case 44:
            return 65;
          case 45:
            return 63;
          case 46:
            return 63;
          case 47:
            return 64;
          case 48:
            return 64;
          case 49:
            return 64;
          case 50:
            return 64;
          case 51:
            return 64;
          case 52:
            return 65;
          case 53:
            return 64;
          case 54:
            return 65;
          case 55:
            return 66;
          case 56:
            return 66;
          case 57:
            return 66;
          case 58:
            return 66;
          case 59:
            return 63;
          case 60:
            return 64;
          case 61:
            return 65;
          case 62:
            return 67;
          case 63:
            return 68;
          case 64:
            return 69;
          case 65:
            return 69;
          case 66:
            return 68;
          case 67:
            return 68;
          case 68:
            return 68;
          case 69:
            return 41;
          case 70:
            return 47;
          case 71:
            return 40;
          case 72:
            return 48;
          case 73:
            return et.yytext[0];
          case 74:
            return 6;
        }
      }, "anonymous"),
      rules: [/^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:.*direction\s+TB[^\n]*)/i, /^(?:.*direction\s+BT[^\n]*)/i, /^(?:.*direction\s+RL[^\n]*)/i, /^(?:.*direction\s+LR[^\n]*)/i, /^(?:[\n]+)/i, /^(?:\s+)/i, /^(?:[\s]+)/i, /^(?:"[^"%\r\n\v\b\\]+")/i, /^(?:"[^"]*")/i, /^(?:erDiagram\b)/i, /^(?:\{)/i, /^(?:#)/i, /^(?:#)/i, /^(?:,)/i, /^(?::::)/i, /^(?::)/i, /^(?:\s+)/i, /^(?:\b((?:PK)|(?:FK)|(?:UK))\b)/i, /^(?:([^\s]*)[~].*[~]([^\s]*))/i, /^(?:([\*A-Za-z_\u00C0-\uFFFF][A-Za-z0-9\-\_\[\]\(\)\u00C0-\uFFFF\*]*))/i, /^(?:"[^"]*")/i, /^(?:[\n]+)/i, /^(?:\})/i, /^(?:.)/i, /^(?:\[)/i, /^(?:\])/i, /^(?:style\b)/i, /^(?:[\n]+)/i, /^(?:\s+)/i, /^(?::)/i, /^(?:,)/i, /^(?:#)/i, /^(?:classDef\b)/i, /^(?:class\b)/i, /^(?:one or zero\b)/i, /^(?:one or more\b)/i, /^(?:one or many\b)/i, /^(?:1\+)/i, /^(?:\|o\b)/i, /^(?:zero or one\b)/i, /^(?:zero or more\b)/i, /^(?:zero or many\b)/i, /^(?:0\+)/i, /^(?:\}o\b)/i, /^(?:many\(0\))/i, /^(?:many\(1\))/i, /^(?:many\b)/i, /^(?:\}\|)/i, /^(?:one\b)/i, /^(?:only one\b)/i, /^(?:1\b)/i, /^(?:\|\|)/i, /^(?:o\|)/i, /^(?:o\{)/i, /^(?:\|\{)/i, /^(?:\s*u\b)/i, /^(?:\.\.)/i, /^(?:--)/i, /^(?:to\b)/i, /^(?:optionally to\b)/i, /^(?:\.-)/i, /^(?:-\.)/i, /^(?:([^\x00-\x7F]|\w|-|\*)+)/i, /^(?:;)/i, /^(?:([^\x00-\x7F]|\w|-|\*)+)/i, /^(?:[0-9])/i, /^(?:.)/i, /^(?:$)/i],
      conditions: { style: { rules: [34, 35, 36, 37, 38, 69, 70], inclusive: !1 }, acc_descr_multiline: { rules: [5, 6], inclusive: !1 }, acc_descr: { rules: [3], inclusive: !1 }, acc_title: { rules: [1], inclusive: !1 }, block: { rules: [23, 24, 25, 26, 27, 28, 29, 30], inclusive: !1 }, INITIAL: { rules: [0, 2, 4, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 31, 32, 33, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 71, 72, 73, 74], inclusive: !0 } }
    };
    return lt;
  }();
  xt.lexer = Ct;
  function at() {
    this.yy = {};
  }
  return u(at, "Parser"), at.prototype = xt, xt.Parser = at, new at();
}();
Ul.parser = Ul;
var fv = Ul, zs, yv = (zs = class {
  constructor() {
    this.entities = /* @__PURE__ */ new Map(), this.relationships = [], this.classes = /* @__PURE__ */ new Map(), this.direction = "TB", this.Cardinality = {
      ZERO_OR_ONE: "ZERO_OR_ONE",
      ZERO_OR_MORE: "ZERO_OR_MORE",
      ONE_OR_MORE: "ONE_OR_MORE",
      ONLY_ONE: "ONLY_ONE",
      MD_PARENT: "MD_PARENT"
    }, this.Identification = {
      NON_IDENTIFYING: "NON_IDENTIFYING",
      IDENTIFYING: "IDENTIFYING"
    }, this.setAccTitle = Re, this.getAccTitle = qe, this.setAccDescription = Ye, this.getAccDescription = He, this.setDiagramTitle = Ge, this.getDiagramTitle = Oe, this.getConfig = /* @__PURE__ */ u(() => K().er, "getConfig"), this.clear(), this.addEntity = this.addEntity.bind(this), this.addAttributes = this.addAttributes.bind(this), this.addRelationship = this.addRelationship.bind(this), this.setDirection = this.setDirection.bind(this), this.addCssStyles = this.addCssStyles.bind(this), this.addClass = this.addClass.bind(this), this.setClass = this.setClass.bind(this), this.setAccTitle = this.setAccTitle.bind(this), this.setAccDescription = this.setAccDescription.bind(this);
  }
  /**
   * Add entity
   * @param name - The name of the entity
   * @param alias - The alias of the entity
   */
  addEntity(t, r = "") {
    var i;
    return this.entities.has(t) ? !((i = this.entities.get(t)) != null && i.alias) && r && (this.entities.get(t).alias = r, I.info(`Add alias '${r}' to entity '${t}'`)) : (this.entities.set(t, {
      id: `entity-${t}-${this.entities.size}`,
      label: t,
      attributes: [],
      alias: r,
      shape: "erBox",
      look: K().look ?? "default",
      cssClasses: "default",
      cssStyles: []
    }), I.info("Added new entity :", t)), this.entities.get(t);
  }
  getEntity(t) {
    return this.entities.get(t);
  }
  getEntities() {
    return this.entities;
  }
  getClasses() {
    return this.classes;
  }
  addAttributes(t, r) {
    const i = this.addEntity(t);
    let s;
    for (s = r.length - 1; s >= 0; s--)
      r[s].keys || (r[s].keys = []), r[s].comment || (r[s].comment = ""), i.attributes.push(r[s]), I.debug("Added attribute ", r[s].name);
  }
  /**
   * Add a relationship
   *
   * @param entA - The first entity in the relationship
   * @param rolA - The role played by the first entity in relation to the second
   * @param entB - The second entity in the relationship
   * @param rSpec - The details of the relationship between the two entities
   */
  addRelationship(t, r, i, s) {
    const a = this.entities.get(t), n = this.entities.get(i);
    if (!a || !n)
      return;
    const o = {
      entityA: a.id,
      roleA: r,
      entityB: n.id,
      relSpec: s
    };
    this.relationships.push(o), I.debug("Added new relationship :", o);
  }
  getRelationships() {
    return this.relationships;
  }
  getDirection() {
    return this.direction;
  }
  setDirection(t) {
    this.direction = t;
  }
  getCompiledStyles(t) {
    let r = [];
    for (const i of t) {
      const s = this.classes.get(i);
      s != null && s.styles && (r = [...r, ...s.styles ?? []].map((a) => a.trim())), s != null && s.textStyles && (r = [...r, ...s.textStyles ?? []].map((a) => a.trim()));
    }
    return r;
  }
  addCssStyles(t, r) {
    for (const i of t) {
      const s = this.entities.get(i);
      if (!r || !s)
        return;
      for (const a of r)
        s.cssStyles.push(a);
    }
  }
  addClass(t, r) {
    t.forEach((i) => {
      let s = this.classes.get(i);
      s === void 0 && (s = { id: i, styles: [], textStyles: [] }, this.classes.set(i, s)), r && r.forEach(function(a) {
        if (/color/.exec(a)) {
          const n = a.replace("fill", "bgFill");
          s.textStyles.push(n);
        }
        s.styles.push(a);
      });
    });
  }
  setClass(t, r) {
    for (const i of t) {
      const s = this.entities.get(i);
      if (s)
        for (const a of r)
          s.cssClasses += " " + a;
    }
  }
  clear() {
    this.entities = /* @__PURE__ */ new Map(), this.classes = /* @__PURE__ */ new Map(), this.relationships = [], Me();
  }
  getData() {
    const t = [], r = [], i = K();
    for (const a of this.entities.keys()) {
      const n = this.entities.get(a);
      n && (n.cssCompiledStyles = this.getCompiledStyles(n.cssClasses.split(" ")), t.push(n));
    }
    let s = 0;
    for (const a of this.relationships) {
      const n = {
        id: Es(a.entityA, a.entityB, {
          prefix: "id",
          counter: s++
        }),
        type: "normal",
        curve: "basis",
        start: a.entityA,
        end: a.entityB,
        label: a.roleA,
        labelpos: "c",
        thickness: "normal",
        classes: "relationshipLine",
        arrowTypeStart: a.relSpec.cardB.toLowerCase(),
        arrowTypeEnd: a.relSpec.cardA.toLowerCase(),
        pattern: a.relSpec.relType == "IDENTIFYING" ? "solid" : "dashed",
        look: i.look
      };
      r.push(n);
    }
    return { nodes: t, edges: r, other: {}, config: i, direction: "TB" };
  }
}, u(zs, "ErDB"), zs), Ff = {};
Co(Ff, {
  draw: () => mv
});
var mv = /* @__PURE__ */ u(async function(e, t, r, i) {
  I.info("REF0:"), I.info("Drawing er diagram (unified)", t);
  const { securityLevel: s, er: a, layout: n } = K(), o = i.db.getData(), h = Ta(t, s);
  o.type = i.type, o.layoutAlgorithm = fn(n), o.config.flowchart.nodeSpacing = (a == null ? void 0 : a.nodeSpacing) || 140, o.config.flowchart.rankSpacing = (a == null ? void 0 : a.rankSpacing) || 80, o.direction = i.db.getDirection(), o.markers = ["only_one", "zero_or_one", "one_or_more", "zero_or_more"], o.diagramId = t, await wa(o, h), o.layoutAlgorithm === "elk" && h.select(".edges").lower();
  const l = h.selectAll('[id*="-background"]');
  Array.from(l).length > 0 && l.each(function() {
    const p = yt(this), f = p.attr("id").replace("-background", ""), y = h.select(`#${CSS.escape(f)}`);
    if (!y.empty()) {
      const m = y.attr("transform");
      p.attr("transform", m);
    }
  });
  const d = 8;
  ee.insertTitle(
    h,
    "erDiagramTitleText",
    (a == null ? void 0 : a.titleTopMargin) ?? 25,
    i.db.getDiagramTitle()
  ), cs(h, d, "erDiagram", (a == null ? void 0 : a.useMaxWidth) ?? !0);
}, "draw"), xv = /* @__PURE__ */ u((e, t) => {
  const r = wc, i = r(e, "r"), s = r(e, "g"), a = r(e, "b");
  return Zi(i, s, a, t);
}, "fade"), bv = /* @__PURE__ */ u((e) => `
  .entityBox {
    fill: ${e.mainBkg};
    stroke: ${e.nodeBorder};
  }

  .relationshipLabelBox {
    fill: ${e.tertiaryColor};
    opacity: 0.7;
    background-color: ${e.tertiaryColor};
      rect {
        opacity: 0.5;
      }
  }

  .labelBkg {
    background-color: ${xv(e.tertiaryColor, 0.5)};
  }

  .edgeLabel .label {
    fill: ${e.nodeBorder};
    font-size: 14px;
  }

  .label {
    font-family: ${e.fontFamily};
    color: ${e.nodeTextColor || e.textColor};
  }

  .edge-pattern-dashed {
    stroke-dasharray: 8,8;
  }

  .node rect,
  .node circle,
  .node ellipse,
  .node polygon
  {
    fill: ${e.mainBkg};
    stroke: ${e.nodeBorder};
    stroke-width: 1px;
  }

  .relationshipLine {
    stroke: ${e.lineColor};
    stroke-width: 1;
    fill: none;
  }

  .marker {
    fill: none !important;
    stroke: ${e.lineColor} !important;
    stroke-width: 1;
  }
`, "getStyles"), kv = bv, vv = {
  parser: fv,
  get db() {
    return new yv();
  },
  renderer: Ff,
  styles: kv
};
const Sv = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: vv
}, Symbol.toStringTag, { value: "Module" }));
function hs(e, t) {
  var r, i, s;
  e.accDescr && ((r = t.setAccDescription) == null || r.call(t, e.accDescr)), e.accTitle && ((i = t.setAccTitle) == null || i.call(t, e.accTitle)), e.title && ((s = t.setDiagramTitle) == null || s.call(t, e.title));
}
u(hs, "populateCommonDb");
var Ws, Nf = (Ws = class {
  /**
   * @param init - Function that creates the default state.
   */
  constructor(t) {
    this.init = t, this.records = this.init();
  }
  reset() {
    this.records = this.init();
  }
}, u(Ws, "ImperativeState"), Ws), be = {
  NORMAL: 0,
  REVERSE: 1,
  HIGHLIGHT: 2,
  MERGE: 3,
  CHERRY_PICK: 4
}, Cv = de.gitGraph, us = /* @__PURE__ */ u(() => gr({
  ...Cv,
  ...fe().gitGraph
}), "getConfig"), Lt = new Nf(() => {
  const e = us(), t = e.mainBranchName, r = e.mainBranchOrder;
  return {
    mainBranchName: t,
    commits: /* @__PURE__ */ new Map(),
    head: null,
    branchConfig: /* @__PURE__ */ new Map([[t, { name: t, order: r }]]),
    branches: /* @__PURE__ */ new Map([[t, null]]),
    currBranch: t,
    direction: "LR",
    seq: 0,
    options: {}
  };
});
function Vo() {
  return A0({ length: 7 });
}
u(Vo, "getID");
function Rf(e, t) {
  const r = /* @__PURE__ */ Object.create(null);
  return e.reduce((i, s) => {
    const a = t(s);
    return r[a] || (r[a] = !0, i.push(s)), i;
  }, []);
}
u(Rf, "uniqBy");
var wv = /* @__PURE__ */ u(function(e) {
  Lt.records.direction = e;
}, "setDirection"), Tv = /* @__PURE__ */ u(function(e) {
  I.debug("options str", e), e = e == null ? void 0 : e.trim(), e = e || "{}";
  try {
    Lt.records.options = JSON.parse(e);
  } catch (t) {
    I.error("error while parsing gitGraph options", t.message);
  }
}, "setOptions"), _v = /* @__PURE__ */ u(function() {
  return Lt.records.options;
}, "getOptions"), Ev = /* @__PURE__ */ u(function(e) {
  let t = e.msg, r = e.id;
  const i = e.type;
  let s = e.tags;
  I.info("commit", t, r, i, s), I.debug("Entering commit:", t, r, i, s);
  const a = us();
  r = St.sanitizeText(r, a), t = St.sanitizeText(t, a), s = s == null ? void 0 : s.map((o) => St.sanitizeText(o, a));
  const n = {
    id: r || Lt.records.seq + "-" + Vo(),
    message: t,
    seq: Lt.records.seq++,
    type: i ?? be.NORMAL,
    tags: s ?? [],
    parents: Lt.records.head == null ? [] : [Lt.records.head.id],
    branch: Lt.records.currBranch
  };
  Lt.records.head = n, I.info("main branch", a.mainBranchName), Lt.records.commits.has(n.id) && I.warn(`Commit ID ${n.id} already exists`), Lt.records.commits.set(n.id, n), Lt.records.branches.set(Lt.records.currBranch, n.id), I.debug("in pushCommit " + n.id);
}, "commit"), Av = /* @__PURE__ */ u(function(e) {
  let t = e.name;
  const r = e.order;
  if (t = St.sanitizeText(t, us()), Lt.records.branches.has(t))
    throw new Error(
      `Trying to create an existing branch. (Help: Either use a new name if you want create a new branch or try using "checkout ${t}")`
    );
  Lt.records.branches.set(t, Lt.records.head != null ? Lt.records.head.id : null), Lt.records.branchConfig.set(t, { name: t, order: r }), Mf(t), I.debug("in createBranch");
}, "branch"), Lv = /* @__PURE__ */ u((e) => {
  let t = e.branch, r = e.id;
  const i = e.type, s = e.tags, a = us();
  t = St.sanitizeText(t, a), r && (r = St.sanitizeText(r, a));
  const n = Lt.records.branches.get(Lt.records.currBranch), o = Lt.records.branches.get(t), h = n ? Lt.records.commits.get(n) : void 0, l = o ? Lt.records.commits.get(o) : void 0;
  if (h && l && h.branch === t)
    throw new Error(`Cannot merge branch '${t}' into itself.`);
  if (Lt.records.currBranch === t) {
    const g = new Error('Incorrect usage of "merge". Cannot merge a branch to itself');
    throw g.hash = {
      text: `merge ${t}`,
      token: `merge ${t}`,
      expected: ["branch abc"]
    }, g;
  }
  if (h === void 0 || !h) {
    const g = new Error(
      `Incorrect usage of "merge". Current branch (${Lt.records.currBranch})has no commits`
    );
    throw g.hash = {
      text: `merge ${t}`,
      token: `merge ${t}`,
      expected: ["commit"]
    }, g;
  }
  if (!Lt.records.branches.has(t)) {
    const g = new Error(
      'Incorrect usage of "merge". Branch to be merged (' + t + ") does not exist"
    );
    throw g.hash = {
      text: `merge ${t}`,
      token: `merge ${t}`,
      expected: [`branch ${t}`]
    }, g;
  }
  if (l === void 0 || !l) {
    const g = new Error(
      'Incorrect usage of "merge". Branch to be merged (' + t + ") has no commits"
    );
    throw g.hash = {
      text: `merge ${t}`,
      token: `merge ${t}`,
      expected: ['"commit"']
    }, g;
  }
  if (h === l) {
    const g = new Error('Incorrect usage of "merge". Both branches have same head');
    throw g.hash = {
      text: `merge ${t}`,
      token: `merge ${t}`,
      expected: ["branch abc"]
    }, g;
  }
  if (r && Lt.records.commits.has(r)) {
    const g = new Error(
      'Incorrect usage of "merge". Commit with id:' + r + " already exists, use different custom id"
    );
    throw g.hash = {
      text: `merge ${t} ${r} ${i} ${s == null ? void 0 : s.join(" ")}`,
      token: `merge ${t} ${r} ${i} ${s == null ? void 0 : s.join(" ")}`,
      expected: [
        `merge ${t} ${r}_UNIQUE ${i} ${s == null ? void 0 : s.join(" ")}`
      ]
    }, g;
  }
  const d = o || "", p = {
    id: r || `${Lt.records.seq}-${Vo()}`,
    message: `merged branch ${t} into ${Lt.records.currBranch}`,
    seq: Lt.records.seq++,
    parents: Lt.records.head == null ? [] : [Lt.records.head.id, d],
    branch: Lt.records.currBranch,
    type: be.MERGE,
    customType: i,
    customId: !!r,
    tags: s ?? []
  };
  Lt.records.head = p, Lt.records.commits.set(p.id, p), Lt.records.branches.set(Lt.records.currBranch, p.id), I.debug(Lt.records.branches), I.debug("in mergeBranch");
}, "merge"), Bv = /* @__PURE__ */ u(function(e) {
  let t = e.id, r = e.targetId, i = e.tags, s = e.parent;
  I.debug("Entering cherryPick:", t, r, i);
  const a = us();
  if (t = St.sanitizeText(t, a), r = St.sanitizeText(r, a), i = i == null ? void 0 : i.map((h) => St.sanitizeText(h, a)), s = St.sanitizeText(s, a), !t || !Lt.records.commits.has(t)) {
    const h = new Error(
      'Incorrect usage of "cherryPick". Source commit id should exist and provided'
    );
    throw h.hash = {
      text: `cherryPick ${t} ${r}`,
      token: `cherryPick ${t} ${r}`,
      expected: ["cherry-pick abc"]
    }, h;
  }
  const n = Lt.records.commits.get(t);
  if (n === void 0 || !n)
    throw new Error('Incorrect usage of "cherryPick". Source commit id should exist and provided');
  if (s && !(Array.isArray(n.parents) && n.parents.includes(s)))
    throw new Error(
      "Invalid operation: The specified parent commit is not an immediate parent of the cherry-picked commit."
    );
  const o = n.branch;
  if (n.type === be.MERGE && !s)
    throw new Error(
      "Incorrect usage of cherry-pick: If the source commit is a merge commit, an immediate parent commit must be specified."
    );
  if (!r || !Lt.records.commits.has(r)) {
    if (o === Lt.records.currBranch) {
      const p = new Error(
        'Incorrect usage of "cherryPick". Source commit is already on current branch'
      );
      throw p.hash = {
        text: `cherryPick ${t} ${r}`,
        token: `cherryPick ${t} ${r}`,
        expected: ["cherry-pick abc"]
      }, p;
    }
    const h = Lt.records.branches.get(Lt.records.currBranch);
    if (h === void 0 || !h) {
      const p = new Error(
        `Incorrect usage of "cherry-pick". Current branch (${Lt.records.currBranch})has no commits`
      );
      throw p.hash = {
        text: `cherryPick ${t} ${r}`,
        token: `cherryPick ${t} ${r}`,
        expected: ["cherry-pick abc"]
      }, p;
    }
    const l = Lt.records.commits.get(h);
    if (l === void 0 || !l) {
      const p = new Error(
        `Incorrect usage of "cherry-pick". Current branch (${Lt.records.currBranch})has no commits`
      );
      throw p.hash = {
        text: `cherryPick ${t} ${r}`,
        token: `cherryPick ${t} ${r}`,
        expected: ["cherry-pick abc"]
      }, p;
    }
    const d = {
      id: Lt.records.seq + "-" + Vo(),
      message: `cherry-picked ${n == null ? void 0 : n.message} into ${Lt.records.currBranch}`,
      seq: Lt.records.seq++,
      parents: Lt.records.head == null ? [] : [Lt.records.head.id, n.id],
      branch: Lt.records.currBranch,
      type: be.CHERRY_PICK,
      tags: i ? i.filter(Boolean) : [
        `cherry-pick:${n.id}${n.type === be.MERGE ? `|parent:${s}` : ""}`
      ]
    };
    Lt.records.head = d, Lt.records.commits.set(d.id, d), Lt.records.branches.set(Lt.records.currBranch, d.id), I.debug(Lt.records.branches), I.debug("in cherryPick");
  }
}, "cherryPick"), Mf = /* @__PURE__ */ u(function(e) {
  if (e = St.sanitizeText(e, us()), Lt.records.branches.has(e)) {
    Lt.records.currBranch = e;
    const t = Lt.records.branches.get(Lt.records.currBranch);
    t === void 0 || !t ? Lt.records.head = null : Lt.records.head = Lt.records.commits.get(t) ?? null;
  } else {
    const t = new Error(
      `Trying to checkout branch which is not yet created. (Help try using "branch ${e}")`
    );
    throw t.hash = {
      text: `checkout ${e}`,
      token: `checkout ${e}`,
      expected: [`branch ${e}`]
    }, t;
  }
}, "checkout");
function jl(e, t, r) {
  const i = e.indexOf(t);
  i === -1 ? e.push(r) : e.splice(i, 1, r);
}
u(jl, "upsert");
function lh(e) {
  const t = e.reduce((s, a) => s.seq > a.seq ? s : a, e[0]);
  let r = "";
  e.forEach(function(s) {
    s === t ? r += "	*" : r += "	|";
  });
  const i = [r, t.id, t.seq];
  for (const s in Lt.records.branches)
    Lt.records.branches.get(s) === t.id && i.push(s);
  if (I.debug(i.join(" ")), t.parents && t.parents.length == 2 && t.parents[0] && t.parents[1]) {
    const s = Lt.records.commits.get(t.parents[0]);
    jl(e, t, s), t.parents[1] && e.push(Lt.records.commits.get(t.parents[1]));
  } else {
    if (t.parents.length == 0)
      return;
    if (t.parents[0]) {
      const s = Lt.records.commits.get(t.parents[0]);
      jl(e, t, s);
    }
  }
  e = Rf(e, (s) => s.id), lh(e);
}
u(lh, "prettyPrintCommitHistory");
var Dv = /* @__PURE__ */ u(function() {
  I.debug(Lt.records.commits);
  const e = Of()[0];
  lh([e]);
}, "prettyPrint"), Iv = /* @__PURE__ */ u(function() {
  Lt.reset(), Me();
}, "clear"), Fv = /* @__PURE__ */ u(function() {
  return [...Lt.records.branchConfig.values()].map((t, r) => t.order !== null && t.order !== void 0 ? t : {
    ...t,
    order: parseFloat(`0.${r}`)
  }).sort((t, r) => (t.order ?? 0) - (r.order ?? 0)).map(({ name: t }) => ({ name: t }));
}, "getBranchesAsObjArray"), Nv = /* @__PURE__ */ u(function() {
  return Lt.records.branches;
}, "getBranches"), Rv = /* @__PURE__ */ u(function() {
  return Lt.records.commits;
}, "getCommits"), Of = /* @__PURE__ */ u(function() {
  const e = [...Lt.records.commits.values()];
  return e.forEach(function(t) {
    I.debug(t.id);
  }), e.sort((t, r) => t.seq - r.seq), e;
}, "getCommitsArray"), Mv = /* @__PURE__ */ u(function() {
  return Lt.records.currBranch;
}, "getCurrentBranch"), Ov = /* @__PURE__ */ u(function() {
  return Lt.records.direction;
}, "getDirection"), Pv = /* @__PURE__ */ u(function() {
  return Lt.records.head;
}, "getHead"), Pf = {
  commitType: be,
  getConfig: us,
  setDirection: wv,
  setOptions: Tv,
  getOptions: _v,
  commit: Ev,
  branch: Av,
  merge: Lv,
  cherryPick: Bv,
  checkout: Mf,
  //reset,
  prettyPrint: Dv,
  clear: Iv,
  getBranchesAsObjArray: Fv,
  getBranches: Nv,
  getCommits: Rv,
  getCommitsArray: Of,
  getCurrentBranch: Mv,
  getDirection: Ov,
  getHead: Pv,
  setAccTitle: Re,
  getAccTitle: qe,
  getAccDescription: He,
  setAccDescription: Ye,
  setDiagramTitle: Ge,
  getDiagramTitle: Oe
}, $v = /* @__PURE__ */ u((e, t) => {
  hs(e, t), e.dir && t.setDirection(e.dir);
  for (const r of e.statements)
    Vv(r, t);
}, "populate"), Vv = /* @__PURE__ */ u((e, t) => {
  const i = {
    Commit: /* @__PURE__ */ u((s) => t.commit(zv(s)), "Commit"),
    Branch: /* @__PURE__ */ u((s) => t.branch(Wv(s)), "Branch"),
    Merge: /* @__PURE__ */ u((s) => t.merge(qv(s)), "Merge"),
    Checkout: /* @__PURE__ */ u((s) => t.checkout(Yv(s)), "Checkout"),
    CherryPicking: /* @__PURE__ */ u((s) => t.cherryPick(Hv(s)), "CherryPicking")
  }[e.$type];
  i ? i(e) : I.error(`Unknown statement type: ${e.$type}`);
}, "parseStatement"), zv = /* @__PURE__ */ u((e) => ({
  id: e.id,
  msg: e.message ?? "",
  type: e.type !== void 0 ? be[e.type] : be.NORMAL,
  tags: e.tags ?? void 0
}), "parseCommit"), Wv = /* @__PURE__ */ u((e) => ({
  name: e.name,
  order: e.order ?? 0
}), "parseBranch"), qv = /* @__PURE__ */ u((e) => ({
  branch: e.branch,
  id: e.id ?? "",
  type: e.type !== void 0 ? be[e.type] : void 0,
  tags: e.tags ?? void 0
}), "parseMerge"), Yv = /* @__PURE__ */ u((e) => e.branch, "parseCheckout"), Hv = /* @__PURE__ */ u((e) => {
  var r;
  return {
    id: e.id,
    targetId: "",
    tags: ((r = e.tags) == null ? void 0 : r.length) === 0 ? void 0 : e.tags,
    parent: e.parent
  };
}, "parseCherryPicking"), Uv = {
  parse: /* @__PURE__ */ u(async (e) => {
    const t = await os("gitGraph", e);
    I.debug(t), $v(t, Pf);
  }, "parse")
}, nl = K(), Ne = nl == null ? void 0 : nl.gitGraph, Ti = 10, _i = 40, Ur = 4, di = 2, Yi = 8, br = /* @__PURE__ */ new Map(), kr = /* @__PURE__ */ new Map(), co = 30, Na = /* @__PURE__ */ new Map(), ho = [], Ci = 0, pe = "LR", jv = /* @__PURE__ */ u(() => {
  br.clear(), kr.clear(), Na.clear(), Ci = 0, ho = [], pe = "LR";
}, "clear"), $f = /* @__PURE__ */ u((e) => {
  const t = document.createElementNS("http://www.w3.org/2000/svg", "text");
  return (typeof e == "string" ? e.split(/\\n|\n|<br\s*\/?>/gi) : e).forEach((i) => {
    const s = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
    s.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"), s.setAttribute("dy", "1em"), s.setAttribute("x", "0"), s.setAttribute("class", "row"), s.textContent = i.trim(), t.appendChild(s);
  }), t;
}, "drawText"), Vf = /* @__PURE__ */ u((e) => {
  let t, r, i;
  return pe === "BT" ? (r = /* @__PURE__ */ u((s, a) => s <= a, "comparisonFunc"), i = 1 / 0) : (r = /* @__PURE__ */ u((s, a) => s >= a, "comparisonFunc"), i = 0), e.forEach((s) => {
    var n, o;
    const a = pe === "TB" || pe == "BT" ? (n = kr.get(s)) == null ? void 0 : n.y : (o = kr.get(s)) == null ? void 0 : o.x;
    a !== void 0 && r(a, i) && (t = s, i = a);
  }), t;
}, "findClosestParent"), Gv = /* @__PURE__ */ u((e) => {
  let t = "", r = 1 / 0;
  return e.forEach((i) => {
    const s = kr.get(i).y;
    s <= r && (t = i, r = s);
  }), t || void 0;
}, "findClosestParentBT"), Xv = /* @__PURE__ */ u((e, t, r) => {
  let i = r, s = r;
  const a = [];
  e.forEach((n) => {
    const o = t.get(n);
    if (!o)
      throw new Error(`Commit not found for key ${n}`);
    o.parents.length ? (i = Qv(o), s = Math.max(i, s)) : a.push(o), Zv(o, i);
  }), i = s, a.forEach((n) => {
    Jv(n, i, r);
  }), e.forEach((n) => {
    const o = t.get(n);
    if (o != null && o.parents.length) {
      const h = Gv(o.parents);
      i = kr.get(h).y - _i, i <= s && (s = i);
      const l = br.get(o.branch).pos, d = i - Ti;
      kr.set(o.id, { x: l, y: d });
    }
  });
}, "setParallelBTPos"), Kv = /* @__PURE__ */ u((e) => {
  var i;
  const t = Vf(e.parents.filter((s) => s !== null));
  if (!t)
    throw new Error(`Closest parent not found for commit ${e.id}`);
  const r = (i = kr.get(t)) == null ? void 0 : i.y;
  if (r === void 0)
    throw new Error(`Closest parent position not found for commit ${e.id}`);
  return r;
}, "findClosestParentPos"), Qv = /* @__PURE__ */ u((e) => Kv(e) + _i, "calculateCommitPosition"), Zv = /* @__PURE__ */ u((e, t) => {
  const r = br.get(e.branch);
  if (!r)
    throw new Error(`Branch not found for commit ${e.id}`);
  const i = r.pos, s = t + Ti;
  return kr.set(e.id, { x: i, y: s }), { x: i, y: s };
}, "setCommitPosition"), Jv = /* @__PURE__ */ u((e, t, r) => {
  const i = br.get(e.branch);
  if (!i)
    throw new Error(`Branch not found for commit ${e.id}`);
  const s = t + r, a = i.pos;
  kr.set(e.id, { x: a, y: s });
}, "setRootPosition"), tS = /* @__PURE__ */ u((e, t, r, i, s, a) => {
  if (a === be.HIGHLIGHT)
    e.append("rect").attr("x", r.x - 10).attr("y", r.y - 10).attr("width", 20).attr("height", 20).attr(
      "class",
      `commit ${t.id} commit-highlight${s % Yi} ${i}-outer`
    ), e.append("rect").attr("x", r.x - 6).attr("y", r.y - 6).attr("width", 12).attr("height", 12).attr(
      "class",
      `commit ${t.id} commit${s % Yi} ${i}-inner`
    );
  else if (a === be.CHERRY_PICK)
    e.append("circle").attr("cx", r.x).attr("cy", r.y).attr("r", 10).attr("class", `commit ${t.id} ${i}`), e.append("circle").attr("cx", r.x - 3).attr("cy", r.y + 2).attr("r", 2.75).attr("fill", "#fff").attr("class", `commit ${t.id} ${i}`), e.append("circle").attr("cx", r.x + 3).attr("cy", r.y + 2).attr("r", 2.75).attr("fill", "#fff").attr("class", `commit ${t.id} ${i}`), e.append("line").attr("x1", r.x + 3).attr("y1", r.y + 1).attr("x2", r.x).attr("y2", r.y - 5).attr("stroke", "#fff").attr("class", `commit ${t.id} ${i}`), e.append("line").attr("x1", r.x - 3).attr("y1", r.y + 1).attr("x2", r.x).attr("y2", r.y - 5).attr("stroke", "#fff").attr("class", `commit ${t.id} ${i}`);
  else {
    const n = e.append("circle");
    if (n.attr("cx", r.x), n.attr("cy", r.y), n.attr("r", t.type === be.MERGE ? 9 : 10), n.attr("class", `commit ${t.id} commit${s % Yi}`), a === be.MERGE) {
      const o = e.append("circle");
      o.attr("cx", r.x), o.attr("cy", r.y), o.attr("r", 6), o.attr(
        "class",
        `commit ${i} ${t.id} commit${s % Yi}`
      );
    }
    a === be.REVERSE && e.append("path").attr(
      "d",
      `M ${r.x - 5},${r.y - 5}L${r.x + 5},${r.y + 5}M${r.x - 5},${r.y + 5}L${r.x + 5},${r.y - 5}`
    ).attr("class", `commit ${i} ${t.id} commit${s % Yi}`);
  }
}, "drawCommitBullet"), eS = /* @__PURE__ */ u((e, t, r, i) => {
  var s;
  if (t.type !== be.CHERRY_PICK && (t.customId && t.type === be.MERGE || t.type !== be.MERGE) && (Ne != null && Ne.showCommitLabel)) {
    const a = e.append("g"), n = a.insert("rect").attr("class", "commit-label-bkg"), o = a.append("text").attr("x", i).attr("y", r.y + 25).attr("class", "commit-label").text(t.id), h = (s = o.node()) == null ? void 0 : s.getBBox();
    if (h && (n.attr("x", r.posWithOffset - h.width / 2 - di).attr("y", r.y + 13.5).attr("width", h.width + 2 * di).attr("height", h.height + 2 * di), pe === "TB" || pe === "BT" ? (n.attr("x", r.x - (h.width + 4 * Ur + 5)).attr("y", r.y - 12), o.attr("x", r.x - (h.width + 4 * Ur)).attr("y", r.y + h.height - 12)) : o.attr("x", r.posWithOffset - h.width / 2), Ne.rotateCommitLabel))
      if (pe === "TB" || pe === "BT")
        o.attr(
          "transform",
          "rotate(-45, " + r.x + ", " + r.y + ")"
        ), n.attr(
          "transform",
          "rotate(-45, " + r.x + ", " + r.y + ")"
        );
      else {
        const l = -7.5 - (h.width + 10) / 25 * 9.5, d = 10 + h.width / 25 * 8.5;
        a.attr(
          "transform",
          "translate(" + l + ", " + d + ") rotate(-45, " + i + ", " + r.y + ")"
        );
      }
  }
}, "drawCommitLabel"), rS = /* @__PURE__ */ u((e, t, r, i) => {
  var s;
  if (t.tags.length > 0) {
    let a = 0, n = 0, o = 0;
    const h = [];
    for (const l of t.tags.reverse()) {
      const d = e.insert("polygon"), p = e.append("circle"), g = e.append("text").attr("y", r.y - 16 - a).attr("class", "tag-label").text(l), f = (s = g.node()) == null ? void 0 : s.getBBox();
      if (!f)
        throw new Error("Tag bbox not found");
      n = Math.max(n, f.width), o = Math.max(o, f.height), g.attr("x", r.posWithOffset - f.width / 2), h.push({
        tag: g,
        hole: p,
        rect: d,
        yOffset: a
      }), a += 20;
    }
    for (const { tag: l, hole: d, rect: p, yOffset: g } of h) {
      const f = o / 2, y = r.y - 19.2 - g;
      if (p.attr("class", "tag-label-bkg").attr(
        "points",
        `
      ${i - n / 2 - Ur / 2},${y + di}  
      ${i - n / 2 - Ur / 2},${y - di}
      ${r.posWithOffset - n / 2 - Ur},${y - f - di}
      ${r.posWithOffset + n / 2 + Ur},${y - f - di}
      ${r.posWithOffset + n / 2 + Ur},${y + f + di}
      ${r.posWithOffset - n / 2 - Ur},${y + f + di}`
      ), d.attr("cy", y).attr("cx", i - n / 2 + Ur / 2).attr("r", 1.5).attr("class", "tag-hole"), pe === "TB" || pe === "BT") {
        const m = i + g;
        p.attr("class", "tag-label-bkg").attr(
          "points",
          `
        ${r.x},${m + 2}
        ${r.x},${m - 2}
        ${r.x + Ti},${m - f - 2}
        ${r.x + Ti + n + 4},${m - f - 2}
        ${r.x + Ti + n + 4},${m + f + 2}
        ${r.x + Ti},${m + f + 2}`
        ).attr("transform", "translate(12,12) rotate(45, " + r.x + "," + i + ")"), d.attr("cx", r.x + Ur / 2).attr("cy", m).attr("transform", "translate(12,12) rotate(45, " + r.x + "," + i + ")"), l.attr("x", r.x + 5).attr("y", m + 3).attr("transform", "translate(14,14) rotate(45, " + r.x + "," + i + ")");
      }
    }
  }
}, "drawCommitTags"), iS = /* @__PURE__ */ u((e) => {
  switch (e.customType ?? e.type) {
    case be.NORMAL:
      return "commit-normal";
    case be.REVERSE:
      return "commit-reverse";
    case be.HIGHLIGHT:
      return "commit-highlight";
    case be.MERGE:
      return "commit-merge";
    case be.CHERRY_PICK:
      return "commit-cherry-pick";
    default:
      return "commit-normal";
  }
}, "getCommitClassType"), sS = /* @__PURE__ */ u((e, t, r, i) => {
  const s = { x: 0, y: 0 };
  if (e.parents.length > 0) {
    const a = Vf(e.parents);
    if (a) {
      const n = i.get(a) ?? s;
      return t === "TB" ? n.y + _i : t === "BT" ? (i.get(e.id) ?? s).y - _i : n.x + _i;
    }
  } else
    return t === "TB" ? co : t === "BT" ? (i.get(e.id) ?? s).y - _i : 0;
  return 0;
}, "calculatePosition"), aS = /* @__PURE__ */ u((e, t, r) => {
  var n, o;
  const i = pe === "BT" && r ? t : t + Ti, s = pe === "TB" || pe === "BT" ? i : (n = br.get(e.branch)) == null ? void 0 : n.pos, a = pe === "TB" || pe === "BT" ? (o = br.get(e.branch)) == null ? void 0 : o.pos : i;
  if (a === void 0 || s === void 0)
    throw new Error(`Position were undefined for commit ${e.id}`);
  return { x: a, y: s, posWithOffset: i };
}, "getCommitPosition"), Su = /* @__PURE__ */ u((e, t, r) => {
  if (!Ne)
    throw new Error("GitGraph config not found");
  const i = e.append("g").attr("class", "commit-bullets"), s = e.append("g").attr("class", "commit-labels");
  let a = pe === "TB" || pe === "BT" ? co : 0;
  const n = [...t.keys()], o = (Ne == null ? void 0 : Ne.parallelCommits) ?? !1, h = /* @__PURE__ */ u((d, p) => {
    var y, m;
    const g = (y = t.get(d)) == null ? void 0 : y.seq, f = (m = t.get(p)) == null ? void 0 : m.seq;
    return g !== void 0 && f !== void 0 ? g - f : 0;
  }, "sortKeys");
  let l = n.sort(h);
  pe === "BT" && (o && Xv(l, t, a), l = l.reverse()), l.forEach((d) => {
    var f;
    const p = t.get(d);
    if (!p)
      throw new Error(`Commit not found for key ${d}`);
    o && (a = sS(p, pe, a, kr));
    const g = aS(p, a, o);
    if (r) {
      const y = iS(p), m = p.customType ?? p.type, x = ((f = br.get(p.branch)) == null ? void 0 : f.index) ?? 0;
      tS(i, p, g, y, x, m), eS(s, p, g, a), rS(s, p, g, a);
    }
    pe === "TB" || pe === "BT" ? kr.set(p.id, { x: g.x, y: g.posWithOffset }) : kr.set(p.id, { x: g.posWithOffset, y: g.y }), a = pe === "BT" && o ? a + _i : a + _i + Ti, a > Ci && (Ci = a);
  });
}, "drawCommits"), nS = /* @__PURE__ */ u((e, t, r, i, s) => {
  const n = (pe === "TB" || pe === "BT" ? r.x < i.x : r.y < i.y) ? t.branch : e.branch, o = /* @__PURE__ */ u((l) => l.branch === n, "isOnBranchToGetCurve"), h = /* @__PURE__ */ u((l) => l.seq > e.seq && l.seq < t.seq, "isBetweenCommits");
  return [...s.values()].some((l) => h(l) && o(l));
}, "shouldRerouteArrow"), Ra = /* @__PURE__ */ u((e, t, r = 0) => {
  const i = e + Math.abs(e - t) / 2;
  if (r > 5)
    return i;
  if (ho.every((n) => Math.abs(n - i) >= 10))
    return ho.push(i), i;
  const a = Math.abs(e - t);
  return Ra(e, t - a / 5, r + 1);
}, "findLane"), oS = /* @__PURE__ */ u((e, t, r, i) => {
  var f, y, m, x, b;
  const s = kr.get(t.id), a = kr.get(r.id);
  if (s === void 0 || a === void 0)
    throw new Error(`Commit positions not found for commits ${t.id} and ${r.id}`);
  const n = nS(t, r, s, a, i);
  let o = "", h = "", l = 0, d = 0, p = (f = br.get(r.branch)) == null ? void 0 : f.index;
  r.type === be.MERGE && t.id !== r.parents[0] && (p = (y = br.get(t.branch)) == null ? void 0 : y.index);
  let g;
  if (n) {
    o = "A 10 10, 0, 0, 0,", h = "A 10 10, 0, 0, 1,", l = 10, d = 10;
    const v = s.y < a.y ? Ra(s.y, a.y) : Ra(a.y, s.y), _ = s.x < a.x ? Ra(s.x, a.x) : Ra(a.x, s.x);
    pe === "TB" ? s.x < a.x ? g = `M ${s.x} ${s.y} L ${_ - l} ${s.y} ${h} ${_} ${s.y + d} L ${_} ${a.y - l} ${o} ${_ + d} ${a.y} L ${a.x} ${a.y}` : (p = (m = br.get(t.branch)) == null ? void 0 : m.index, g = `M ${s.x} ${s.y} L ${_ + l} ${s.y} ${o} ${_} ${s.y + d} L ${_} ${a.y - l} ${h} ${_ - d} ${a.y} L ${a.x} ${a.y}`) : pe === "BT" ? s.x < a.x ? g = `M ${s.x} ${s.y} L ${_ - l} ${s.y} ${o} ${_} ${s.y - d} L ${_} ${a.y + l} ${h} ${_ + d} ${a.y} L ${a.x} ${a.y}` : (p = (x = br.get(t.branch)) == null ? void 0 : x.index, g = `M ${s.x} ${s.y} L ${_ + l} ${s.y} ${h} ${_} ${s.y - d} L ${_} ${a.y + l} ${o} ${_ - d} ${a.y} L ${a.x} ${a.y}`) : s.y < a.y ? g = `M ${s.x} ${s.y} L ${s.x} ${v - l} ${o} ${s.x + d} ${v} L ${a.x - l} ${v} ${h} ${a.x} ${v + d} L ${a.x} ${a.y}` : (p = (b = br.get(t.branch)) == null ? void 0 : b.index, g = `M ${s.x} ${s.y} L ${s.x} ${v + l} ${h} ${s.x + d} ${v} L ${a.x - l} ${v} ${o} ${a.x} ${v - d} L ${a.x} ${a.y}`);
  } else
    o = "A 20 20, 0, 0, 0,", h = "A 20 20, 0, 0, 1,", l = 20, d = 20, pe === "TB" ? (s.x < a.x && (r.type === be.MERGE && t.id !== r.parents[0] ? g = `M ${s.x} ${s.y} L ${s.x} ${a.y - l} ${o} ${s.x + d} ${a.y} L ${a.x} ${a.y}` : g = `M ${s.x} ${s.y} L ${a.x - l} ${s.y} ${h} ${a.x} ${s.y + d} L ${a.x} ${a.y}`), s.x > a.x && (o = "A 20 20, 0, 0, 0,", h = "A 20 20, 0, 0, 1,", l = 20, d = 20, r.type === be.MERGE && t.id !== r.parents[0] ? g = `M ${s.x} ${s.y} L ${s.x} ${a.y - l} ${h} ${s.x - d} ${a.y} L ${a.x} ${a.y}` : g = `M ${s.x} ${s.y} L ${a.x + l} ${s.y} ${o} ${a.x} ${s.y + d} L ${a.x} ${a.y}`), s.x === a.x && (g = `M ${s.x} ${s.y} L ${a.x} ${a.y}`)) : pe === "BT" ? (s.x < a.x && (r.type === be.MERGE && t.id !== r.parents[0] ? g = `M ${s.x} ${s.y} L ${s.x} ${a.y + l} ${h} ${s.x + d} ${a.y} L ${a.x} ${a.y}` : g = `M ${s.x} ${s.y} L ${a.x - l} ${s.y} ${o} ${a.x} ${s.y - d} L ${a.x} ${a.y}`), s.x > a.x && (o = "A 20 20, 0, 0, 0,", h = "A 20 20, 0, 0, 1,", l = 20, d = 20, r.type === be.MERGE && t.id !== r.parents[0] ? g = `M ${s.x} ${s.y} L ${s.x} ${a.y + l} ${o} ${s.x - d} ${a.y} L ${a.x} ${a.y}` : g = `M ${s.x} ${s.y} L ${a.x - l} ${s.y} ${o} ${a.x} ${s.y - d} L ${a.x} ${a.y}`), s.x === a.x && (g = `M ${s.x} ${s.y} L ${a.x} ${a.y}`)) : (s.y < a.y && (r.type === be.MERGE && t.id !== r.parents[0] ? g = `M ${s.x} ${s.y} L ${a.x - l} ${s.y} ${h} ${a.x} ${s.y + d} L ${a.x} ${a.y}` : g = `M ${s.x} ${s.y} L ${s.x} ${a.y - l} ${o} ${s.x + d} ${a.y} L ${a.x} ${a.y}`), s.y > a.y && (r.type === be.MERGE && t.id !== r.parents[0] ? g = `M ${s.x} ${s.y} L ${a.x - l} ${s.y} ${o} ${a.x} ${s.y - d} L ${a.x} ${a.y}` : g = `M ${s.x} ${s.y} L ${s.x} ${a.y + l} ${h} ${s.x + d} ${a.y} L ${a.x} ${a.y}`), s.y === a.y && (g = `M ${s.x} ${s.y} L ${a.x} ${a.y}`));
  if (g === void 0)
    throw new Error("Line definition not found");
  e.append("path").attr("d", g).attr("class", "arrow arrow" + p % Yi);
}, "drawArrow"), lS = /* @__PURE__ */ u((e, t) => {
  const r = e.append("g").attr("class", "commit-arrows");
  [...t.keys()].forEach((i) => {
    const s = t.get(i);
    s.parents && s.parents.length > 0 && s.parents.forEach((a) => {
      oS(r, t.get(a), s, t);
    });
  });
}, "drawArrows"), cS = /* @__PURE__ */ u((e, t) => {
  const r = e.append("g");
  t.forEach((i, s) => {
    var y;
    const a = s % Yi, n = (y = br.get(i.name)) == null ? void 0 : y.pos;
    if (n === void 0)
      throw new Error(`Position not found for branch ${i.name}`);
    const o = r.append("line");
    o.attr("x1", 0), o.attr("y1", n), o.attr("x2", Ci), o.attr("y2", n), o.attr("class", "branch branch" + a), pe === "TB" ? (o.attr("y1", co), o.attr("x1", n), o.attr("y2", Ci), o.attr("x2", n)) : pe === "BT" && (o.attr("y1", Ci), o.attr("x1", n), o.attr("y2", co), o.attr("x2", n)), ho.push(n);
    const h = i.name, l = $f(h), d = r.insert("rect"), g = r.insert("g").attr("class", "branchLabel").insert("g").attr("class", "label branch-label" + a);
    g.node().appendChild(l);
    const f = l.getBBox();
    d.attr("class", "branchLabelBkg label" + a).attr("rx", 4).attr("ry", 4).attr("x", -f.width - 4 - ((Ne == null ? void 0 : Ne.rotateCommitLabel) === !0 ? 30 : 0)).attr("y", -f.height / 2 + 8).attr("width", f.width + 18).attr("height", f.height + 4), g.attr(
      "transform",
      "translate(" + (-f.width - 14 - ((Ne == null ? void 0 : Ne.rotateCommitLabel) === !0 ? 30 : 0)) + ", " + (n - f.height / 2 - 1) + ")"
    ), pe === "TB" ? (d.attr("x", n - f.width / 2 - 10).attr("y", 0), g.attr("transform", "translate(" + (n - f.width / 2 - 5) + ", 0)")) : pe === "BT" ? (d.attr("x", n - f.width / 2 - 10).attr("y", Ci), g.attr("transform", "translate(" + (n - f.width / 2 - 5) + ", " + Ci + ")")) : d.attr("transform", "translate(-19, " + (n - f.height / 2) + ")");
  });
}, "drawBranches"), hS = /* @__PURE__ */ u(function(e, t, r, i, s) {
  return br.set(e, { pos: t, index: r }), t += 50 + (s ? 40 : 0) + (pe === "TB" || pe === "BT" ? i.width / 2 : 0), t;
}, "setBranchPosition"), uS = /* @__PURE__ */ u(function(e, t, r, i) {
  if (jv(), I.debug("in gitgraph renderer", e + `
`, "id:", t, r), !Ne)
    throw new Error("GitGraph config not found");
  const s = Ne.rotateCommitLabel ?? !1, a = i.db;
  Na = a.getCommits();
  const n = a.getBranchesAsObjArray();
  pe = a.getDirection();
  const o = yt(`[id="${t}"]`);
  let h = 0;
  n.forEach((l, d) => {
    var x;
    const p = $f(l.name), g = o.append("g"), f = g.insert("g").attr("class", "branchLabel"), y = f.insert("g").attr("class", "label branch-label");
    (x = y.node()) == null || x.appendChild(p);
    const m = p.getBBox();
    h = hS(l.name, h, d, m, s), y.remove(), f.remove(), g.remove();
  }), Su(o, Na, !1), Ne.showBranches && cS(o, n), lS(o, Na), Su(o, Na, !0), ee.insertTitle(
    o,
    "gitTitleText",
    Ne.titleTopMargin ?? 0,
    a.getDiagramTitle()
  ), Od(
    void 0,
    o,
    Ne.diagramPadding,
    Ne.useMaxWidth
  );
}, "draw"), dS = {
  draw: uS
}, pS = /* @__PURE__ */ u((e) => `
  .commit-id,
  .commit-msg,
  .branch-label {
    fill: lightgrey;
    color: lightgrey;
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);
  }
  ${[0, 1, 2, 3, 4, 5, 6, 7].map(
  (t) => `
        .branch-label${t} { fill: ${e["gitBranchLabel" + t]}; }
        .commit${t} { stroke: ${e["git" + t]}; fill: ${e["git" + t]}; }
        .commit-highlight${t} { stroke: ${e["gitInv" + t]}; fill: ${e["gitInv" + t]}; }
        .label${t}  { fill: ${e["git" + t]}; }
        .arrow${t} { stroke: ${e["git" + t]}; }
        `
).join(`
`)}

  .branch {
    stroke-width: 1;
    stroke: ${e.lineColor};
    stroke-dasharray: 2;
  }
  .commit-label { font-size: ${e.commitLabelFontSize}; fill: ${e.commitLabelColor};}
  .commit-label-bkg { font-size: ${e.commitLabelFontSize}; fill: ${e.commitLabelBackground}; opacity: 0.5; }
  .tag-label { font-size: ${e.tagLabelFontSize}; fill: ${e.tagLabelColor};}
  .tag-label-bkg { fill: ${e.tagLabelBackground}; stroke: ${e.tagLabelBorder}; }
  .tag-hole { fill: ${e.textColor}; }

  .commit-merge {
    stroke: ${e.primaryColor};
    fill: ${e.primaryColor};
  }
  .commit-reverse {
    stroke: ${e.primaryColor};
    fill: ${e.primaryColor};
    stroke-width: 3;
  }
  .commit-highlight-outer {
  }
  .commit-highlight-inner {
    stroke: ${e.primaryColor};
    fill: ${e.primaryColor};
  }

  .arrow { stroke-width: 8; stroke-linecap: round; fill: none}
  .gitTitleText {
    text-anchor: middle;
    font-size: 18px;
    fill: ${e.textColor};
  }
`, "getStyles"), gS = pS, fS = {
  parser: Uv,
  db: Pf,
  renderer: dS,
  styles: gS
};
const yS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: fS
}, Symbol.toStringTag, { value: "Module" }));
var Gl = function() {
  var e = /* @__PURE__ */ u(function(N, B, R, V) {
    for (R = R || {}, V = N.length; V--; R[N[V]] = B) ;
    return R;
  }, "o"), t = [6, 8, 10, 12, 13, 14, 15, 16, 17, 18, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 33, 35, 36, 38, 40], r = [1, 26], i = [1, 27], s = [1, 28], a = [1, 29], n = [1, 30], o = [1, 31], h = [1, 32], l = [1, 33], d = [1, 34], p = [1, 9], g = [1, 10], f = [1, 11], y = [1, 12], m = [1, 13], x = [1, 14], b = [1, 15], v = [1, 16], _ = [1, 19], A = [1, 20], S = [1, 21], k = [1, 22], L = [1, 23], T = [1, 25], C = [1, 35], E = {
    trace: /* @__PURE__ */ u(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, start: 3, gantt: 4, document: 5, EOF: 6, line: 7, SPACE: 8, statement: 9, NL: 10, weekday: 11, weekday_monday: 12, weekday_tuesday: 13, weekday_wednesday: 14, weekday_thursday: 15, weekday_friday: 16, weekday_saturday: 17, weekday_sunday: 18, weekend: 19, weekend_friday: 20, weekend_saturday: 21, dateFormat: 22, inclusiveEndDates: 23, topAxis: 24, axisFormat: 25, tickInterval: 26, excludes: 27, includes: 28, todayMarker: 29, title: 30, acc_title: 31, acc_title_value: 32, acc_descr: 33, acc_descr_value: 34, acc_descr_multiline_value: 35, section: 36, clickStatement: 37, taskTxt: 38, taskData: 39, click: 40, callbackname: 41, callbackargs: 42, href: 43, clickStatementDebug: 44, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 4: "gantt", 6: "EOF", 8: "SPACE", 10: "NL", 12: "weekday_monday", 13: "weekday_tuesday", 14: "weekday_wednesday", 15: "weekday_thursday", 16: "weekday_friday", 17: "weekday_saturday", 18: "weekday_sunday", 20: "weekend_friday", 21: "weekend_saturday", 22: "dateFormat", 23: "inclusiveEndDates", 24: "topAxis", 25: "axisFormat", 26: "tickInterval", 27: "excludes", 28: "includes", 29: "todayMarker", 30: "title", 31: "acc_title", 32: "acc_title_value", 33: "acc_descr", 34: "acc_descr_value", 35: "acc_descr_multiline_value", 36: "section", 38: "taskTxt", 39: "taskData", 40: "click", 41: "callbackname", 42: "callbackargs", 43: "href" },
    productions_: [0, [3, 3], [5, 0], [5, 2], [7, 2], [7, 1], [7, 1], [7, 1], [11, 1], [11, 1], [11, 1], [11, 1], [11, 1], [11, 1], [11, 1], [19, 1], [19, 1], [9, 1], [9, 1], [9, 1], [9, 1], [9, 1], [9, 1], [9, 1], [9, 1], [9, 1], [9, 1], [9, 1], [9, 2], [9, 2], [9, 1], [9, 1], [9, 1], [9, 2], [37, 2], [37, 3], [37, 3], [37, 4], [37, 3], [37, 4], [37, 2], [44, 2], [44, 3], [44, 3], [44, 4], [44, 3], [44, 4], [44, 2]],
    performAction: /* @__PURE__ */ u(function(B, R, V, $, D, O, Y) {
      var M = O.length - 1;
      switch (D) {
        case 1:
          return O[M - 1];
        case 2:
          this.$ = [];
          break;
        case 3:
          O[M - 1].push(O[M]), this.$ = O[M - 1];
          break;
        case 4:
        case 5:
          this.$ = O[M];
          break;
        case 6:
        case 7:
          this.$ = [];
          break;
        case 8:
          $.setWeekday("monday");
          break;
        case 9:
          $.setWeekday("tuesday");
          break;
        case 10:
          $.setWeekday("wednesday");
          break;
        case 11:
          $.setWeekday("thursday");
          break;
        case 12:
          $.setWeekday("friday");
          break;
        case 13:
          $.setWeekday("saturday");
          break;
        case 14:
          $.setWeekday("sunday");
          break;
        case 15:
          $.setWeekend("friday");
          break;
        case 16:
          $.setWeekend("saturday");
          break;
        case 17:
          $.setDateFormat(O[M].substr(11)), this.$ = O[M].substr(11);
          break;
        case 18:
          $.enableInclusiveEndDates(), this.$ = O[M].substr(18);
          break;
        case 19:
          $.TopAxis(), this.$ = O[M].substr(8);
          break;
        case 20:
          $.setAxisFormat(O[M].substr(11)), this.$ = O[M].substr(11);
          break;
        case 21:
          $.setTickInterval(O[M].substr(13)), this.$ = O[M].substr(13);
          break;
        case 22:
          $.setExcludes(O[M].substr(9)), this.$ = O[M].substr(9);
          break;
        case 23:
          $.setIncludes(O[M].substr(9)), this.$ = O[M].substr(9);
          break;
        case 24:
          $.setTodayMarker(O[M].substr(12)), this.$ = O[M].substr(12);
          break;
        case 27:
          $.setDiagramTitle(O[M].substr(6)), this.$ = O[M].substr(6);
          break;
        case 28:
          this.$ = O[M].trim(), $.setAccTitle(this.$);
          break;
        case 29:
        case 30:
          this.$ = O[M].trim(), $.setAccDescription(this.$);
          break;
        case 31:
          $.addSection(O[M].substr(8)), this.$ = O[M].substr(8);
          break;
        case 33:
          $.addTask(O[M - 1], O[M]), this.$ = "task";
          break;
        case 34:
          this.$ = O[M - 1], $.setClickEvent(O[M - 1], O[M], null);
          break;
        case 35:
          this.$ = O[M - 2], $.setClickEvent(O[M - 2], O[M - 1], O[M]);
          break;
        case 36:
          this.$ = O[M - 2], $.setClickEvent(O[M - 2], O[M - 1], null), $.setLink(O[M - 2], O[M]);
          break;
        case 37:
          this.$ = O[M - 3], $.setClickEvent(O[M - 3], O[M - 2], O[M - 1]), $.setLink(O[M - 3], O[M]);
          break;
        case 38:
          this.$ = O[M - 2], $.setClickEvent(O[M - 2], O[M], null), $.setLink(O[M - 2], O[M - 1]);
          break;
        case 39:
          this.$ = O[M - 3], $.setClickEvent(O[M - 3], O[M - 1], O[M]), $.setLink(O[M - 3], O[M - 2]);
          break;
        case 40:
          this.$ = O[M - 1], $.setLink(O[M - 1], O[M]);
          break;
        case 41:
        case 47:
          this.$ = O[M - 1] + " " + O[M];
          break;
        case 42:
        case 43:
        case 45:
          this.$ = O[M - 2] + " " + O[M - 1] + " " + O[M];
          break;
        case 44:
        case 46:
          this.$ = O[M - 3] + " " + O[M - 2] + " " + O[M - 1] + " " + O[M];
          break;
      }
    }, "anonymous"),
    table: [{ 3: 1, 4: [1, 2] }, { 1: [3] }, e(t, [2, 2], { 5: 3 }), { 6: [1, 4], 7: 5, 8: [1, 6], 9: 7, 10: [1, 8], 11: 17, 12: r, 13: i, 14: s, 15: a, 16: n, 17: o, 18: h, 19: 18, 20: l, 21: d, 22: p, 23: g, 24: f, 25: y, 26: m, 27: x, 28: b, 29: v, 30: _, 31: A, 33: S, 35: k, 36: L, 37: 24, 38: T, 40: C }, e(t, [2, 7], { 1: [2, 1] }), e(t, [2, 3]), { 9: 36, 11: 17, 12: r, 13: i, 14: s, 15: a, 16: n, 17: o, 18: h, 19: 18, 20: l, 21: d, 22: p, 23: g, 24: f, 25: y, 26: m, 27: x, 28: b, 29: v, 30: _, 31: A, 33: S, 35: k, 36: L, 37: 24, 38: T, 40: C }, e(t, [2, 5]), e(t, [2, 6]), e(t, [2, 17]), e(t, [2, 18]), e(t, [2, 19]), e(t, [2, 20]), e(t, [2, 21]), e(t, [2, 22]), e(t, [2, 23]), e(t, [2, 24]), e(t, [2, 25]), e(t, [2, 26]), e(t, [2, 27]), { 32: [1, 37] }, { 34: [1, 38] }, e(t, [2, 30]), e(t, [2, 31]), e(t, [2, 32]), { 39: [1, 39] }, e(t, [2, 8]), e(t, [2, 9]), e(t, [2, 10]), e(t, [2, 11]), e(t, [2, 12]), e(t, [2, 13]), e(t, [2, 14]), e(t, [2, 15]), e(t, [2, 16]), { 41: [1, 40], 43: [1, 41] }, e(t, [2, 4]), e(t, [2, 28]), e(t, [2, 29]), e(t, [2, 33]), e(t, [2, 34], { 42: [1, 42], 43: [1, 43] }), e(t, [2, 40], { 41: [1, 44] }), e(t, [2, 35], { 43: [1, 45] }), e(t, [2, 36]), e(t, [2, 38], { 42: [1, 46] }), e(t, [2, 37]), e(t, [2, 39])],
    defaultActions: {},
    parseError: /* @__PURE__ */ u(function(B, R) {
      if (R.recoverable)
        this.trace(B);
      else {
        var V = new Error(B);
        throw V.hash = R, V;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ u(function(B) {
      var R = this, V = [0], $ = [], D = [null], O = [], Y = this.table, M = "", G = 0, rt = 0, ht = 2, Z = 1, ot = O.slice.call(arguments, 1), it = Object.create(this.lexer), bt = { yy: {} };
      for (var xt in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, xt) && (bt.yy[xt] = this.yy[xt]);
      it.setInput(B, bt.yy), bt.yy.lexer = it, bt.yy.parser = this, typeof it.yylloc > "u" && (it.yylloc = {});
      var Ct = it.yylloc;
      O.push(Ct);
      var at = it.options && it.options.ranges;
      typeof bt.yy.parseError == "function" ? this.parseError = bt.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function lt(dt) {
        V.length = V.length - 2 * dt, D.length = D.length - dt, O.length = O.length - dt;
      }
      u(lt, "popStack");
      function Q() {
        var dt;
        return dt = $.pop() || it.lex() || Z, typeof dt != "number" && (dt instanceof Array && ($ = dt, dt = $.pop()), dt = R.symbols_[dt] || dt), dt;
      }
      u(Q, "lex");
      for (var U, et, z, Tt, F = {}, te, J, Ut, Wt; ; ) {
        if (et = V[V.length - 1], this.defaultActions[et] ? z = this.defaultActions[et] : ((U === null || typeof U > "u") && (U = Q()), z = Y[et] && Y[et][U]), typeof z > "u" || !z.length || !z[0]) {
          var ie = "";
          Wt = [];
          for (te in Y[et])
            this.terminals_[te] && te > ht && Wt.push("'" + this.terminals_[te] + "'");
          it.showPosition ? ie = "Parse error on line " + (G + 1) + `:
` + it.showPosition() + `
Expecting ` + Wt.join(", ") + ", got '" + (this.terminals_[U] || U) + "'" : ie = "Parse error on line " + (G + 1) + ": Unexpected " + (U == Z ? "end of input" : "'" + (this.terminals_[U] || U) + "'"), this.parseError(ie, {
            text: it.match,
            token: this.terminals_[U] || U,
            line: it.yylineno,
            loc: Ct,
            expected: Wt
          });
        }
        if (z[0] instanceof Array && z.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + et + ", token: " + U);
        switch (z[0]) {
          case 1:
            V.push(U), D.push(it.yytext), O.push(it.yylloc), V.push(z[1]), U = null, rt = it.yyleng, M = it.yytext, G = it.yylineno, Ct = it.yylloc;
            break;
          case 2:
            if (J = this.productions_[z[1]][1], F.$ = D[D.length - J], F._$ = {
              first_line: O[O.length - (J || 1)].first_line,
              last_line: O[O.length - 1].last_line,
              first_column: O[O.length - (J || 1)].first_column,
              last_column: O[O.length - 1].last_column
            }, at && (F._$.range = [
              O[O.length - (J || 1)].range[0],
              O[O.length - 1].range[1]
            ]), Tt = this.performAction.apply(F, [
              M,
              rt,
              G,
              bt.yy,
              z[1],
              D,
              O
            ].concat(ot)), typeof Tt < "u")
              return Tt;
            J && (V = V.slice(0, -1 * J * 2), D = D.slice(0, -1 * J), O = O.slice(0, -1 * J)), V.push(this.productions_[z[1]][0]), D.push(F.$), O.push(F._$), Ut = Y[V[V.length - 2]][V[V.length - 1]], V.push(Ut);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, w = /* @__PURE__ */ function() {
    var N = {
      EOF: 1,
      parseError: /* @__PURE__ */ u(function(R, V) {
        if (this.yy.parser)
          this.yy.parser.parseError(R, V);
        else
          throw new Error(R);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ u(function(B, R) {
        return this.yy = R || this.yy || {}, this._input = B, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ u(function() {
        var B = this._input[0];
        this.yytext += B, this.yyleng++, this.offset++, this.match += B, this.matched += B;
        var R = B.match(/(?:\r\n?|\n).*/g);
        return R ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), B;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ u(function(B) {
        var R = B.length, V = B.split(/(?:\r\n?|\n)/g);
        this._input = B + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - R), this.offset -= R;
        var $ = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), V.length - 1 && (this.yylineno -= V.length - 1);
        var D = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: V ? (V.length === $.length ? this.yylloc.first_column : 0) + $[$.length - V.length].length - V[0].length : this.yylloc.first_column - R
        }, this.options.ranges && (this.yylloc.range = [D[0], D[0] + this.yyleng - R]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ u(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ u(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ u(function(B) {
        this.unput(this.match.slice(B));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ u(function() {
        var B = this.matched.substr(0, this.matched.length - this.match.length);
        return (B.length > 20 ? "..." : "") + B.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ u(function() {
        var B = this.match;
        return B.length < 20 && (B += this._input.substr(0, 20 - B.length)), (B.substr(0, 20) + (B.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ u(function() {
        var B = this.pastInput(), R = new Array(B.length + 1).join("-");
        return B + this.upcomingInput() + `
` + R + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ u(function(B, R) {
        var V, $, D;
        if (this.options.backtrack_lexer && (D = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (D.yylloc.range = this.yylloc.range.slice(0))), $ = B[0].match(/(?:\r\n?|\n).*/g), $ && (this.yylineno += $.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: $ ? $[$.length - 1].length - $[$.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + B[0].length
        }, this.yytext += B[0], this.match += B[0], this.matches = B, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(B[0].length), this.matched += B[0], V = this.performAction.call(this, this.yy, this, R, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), V)
          return V;
        if (this._backtrack) {
          for (var O in D)
            this[O] = D[O];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ u(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var B, R, V, $;
        this._more || (this.yytext = "", this.match = "");
        for (var D = this._currentRules(), O = 0; O < D.length; O++)
          if (V = this._input.match(this.rules[D[O]]), V && (!R || V[0].length > R[0].length)) {
            if (R = V, $ = O, this.options.backtrack_lexer) {
              if (B = this.test_match(V, D[O]), B !== !1)
                return B;
              if (this._backtrack) {
                R = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return R ? (B = this.test_match(R, D[$]), B !== !1 ? B : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ u(function() {
        var R = this.next();
        return R || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ u(function(R) {
        this.conditionStack.push(R);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ u(function() {
        var R = this.conditionStack.length - 1;
        return R > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ u(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ u(function(R) {
        return R = this.conditionStack.length - 1 - Math.abs(R || 0), R >= 0 ? this.conditionStack[R] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ u(function(R) {
        this.begin(R);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ u(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: { "case-insensitive": !0 },
      performAction: /* @__PURE__ */ u(function(R, V, $, D) {
        switch ($) {
          case 0:
            return this.begin("open_directive"), "open_directive";
          case 1:
            return this.begin("acc_title"), 31;
          case 2:
            return this.popState(), "acc_title_value";
          case 3:
            return this.begin("acc_descr"), 33;
          case 4:
            return this.popState(), "acc_descr_value";
          case 5:
            this.begin("acc_descr_multiline");
            break;
          case 6:
            this.popState();
            break;
          case 7:
            return "acc_descr_multiline_value";
          case 8:
            break;
          case 9:
            break;
          case 10:
            break;
          case 11:
            return 10;
          case 12:
            break;
          case 13:
            break;
          case 14:
            this.begin("href");
            break;
          case 15:
            this.popState();
            break;
          case 16:
            return 43;
          case 17:
            this.begin("callbackname");
            break;
          case 18:
            this.popState();
            break;
          case 19:
            this.popState(), this.begin("callbackargs");
            break;
          case 20:
            return 41;
          case 21:
            this.popState();
            break;
          case 22:
            return 42;
          case 23:
            this.begin("click");
            break;
          case 24:
            this.popState();
            break;
          case 25:
            return 40;
          case 26:
            return 4;
          case 27:
            return 22;
          case 28:
            return 23;
          case 29:
            return 24;
          case 30:
            return 25;
          case 31:
            return 26;
          case 32:
            return 28;
          case 33:
            return 27;
          case 34:
            return 29;
          case 35:
            return 12;
          case 36:
            return 13;
          case 37:
            return 14;
          case 38:
            return 15;
          case 39:
            return 16;
          case 40:
            return 17;
          case 41:
            return 18;
          case 42:
            return 20;
          case 43:
            return 21;
          case 44:
            return "date";
          case 45:
            return 30;
          case 46:
            return "accDescription";
          case 47:
            return 36;
          case 48:
            return 38;
          case 49:
            return 39;
          case 50:
            return ":";
          case 51:
            return 6;
          case 52:
            return "INVALID";
        }
      }, "anonymous"),
      rules: [/^(?:%%\{)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:%%(?!\{)*[^\n]*)/i, /^(?:[^\}]%%*[^\n]*)/i, /^(?:%%*[^\n]*[\n]*)/i, /^(?:[\n]+)/i, /^(?:\s+)/i, /^(?:%[^\n]*)/i, /^(?:href[\s]+["])/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:call[\s]+)/i, /^(?:\([\s]*\))/i, /^(?:\()/i, /^(?:[^(]*)/i, /^(?:\))/i, /^(?:[^)]*)/i, /^(?:click[\s]+)/i, /^(?:[\s\n])/i, /^(?:[^\s\n]*)/i, /^(?:gantt\b)/i, /^(?:dateFormat\s[^#\n;]+)/i, /^(?:inclusiveEndDates\b)/i, /^(?:topAxis\b)/i, /^(?:axisFormat\s[^#\n;]+)/i, /^(?:tickInterval\s[^#\n;]+)/i, /^(?:includes\s[^#\n;]+)/i, /^(?:excludes\s[^#\n;]+)/i, /^(?:todayMarker\s[^\n;]+)/i, /^(?:weekday\s+monday\b)/i, /^(?:weekday\s+tuesday\b)/i, /^(?:weekday\s+wednesday\b)/i, /^(?:weekday\s+thursday\b)/i, /^(?:weekday\s+friday\b)/i, /^(?:weekday\s+saturday\b)/i, /^(?:weekday\s+sunday\b)/i, /^(?:weekend\s+friday\b)/i, /^(?:weekend\s+saturday\b)/i, /^(?:\d\d\d\d-\d\d-\d\d\b)/i, /^(?:title\s[^\n]+)/i, /^(?:accDescription\s[^#\n;]+)/i, /^(?:section\s[^\n]+)/i, /^(?:[^:\n]+)/i, /^(?::[^#\n;]+)/i, /^(?::)/i, /^(?:$)/i, /^(?:.)/i],
      conditions: { acc_descr_multiline: { rules: [6, 7], inclusive: !1 }, acc_descr: { rules: [4], inclusive: !1 }, acc_title: { rules: [2], inclusive: !1 }, callbackargs: { rules: [21, 22], inclusive: !1 }, callbackname: { rules: [18, 19, 20], inclusive: !1 }, href: { rules: [15, 16], inclusive: !1 }, click: { rules: [24, 25], inclusive: !1 }, INITIAL: { rules: [0, 1, 3, 5, 8, 9, 10, 11, 12, 13, 14, 17, 23, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52], inclusive: !0 } }
    };
    return N;
  }();
  E.lexer = w;
  function W() {
    this.yy = {};
  }
  return u(W, "Parser"), W.prototype = E, E.Parser = W, new W();
}();
Gl.parser = Gl;
var mS = Gl;
ir.extend(jm);
ir.extend(Gm);
ir.extend(Xm);
var Cu = { friday: 5, saturday: 6 }, Xr = "", ch = "", hh = void 0, uh = "", mn = [], xn = [], dh = /* @__PURE__ */ new Map(), ph = [], uo = [], ya = "", gh = "", zf = ["active", "done", "crit", "milestone", "vert"], fh = [], bn = !1, yh = !1, mh = "sunday", po = "saturday", Xl = 0, xS = /* @__PURE__ */ u(function() {
  ph = [], uo = [], ya = "", fh = [], Mn = 0, Ql = void 0, On = void 0, Ve = [], Xr = "", ch = "", gh = "", hh = void 0, uh = "", mn = [], xn = [], bn = !1, yh = !1, Xl = 0, dh = /* @__PURE__ */ new Map(), Me(), mh = "sunday", po = "saturday";
}, "clear"), bS = /* @__PURE__ */ u(function(e) {
  ch = e;
}, "setAxisFormat"), kS = /* @__PURE__ */ u(function() {
  return ch;
}, "getAxisFormat"), vS = /* @__PURE__ */ u(function(e) {
  hh = e;
}, "setTickInterval"), SS = /* @__PURE__ */ u(function() {
  return hh;
}, "getTickInterval"), CS = /* @__PURE__ */ u(function(e) {
  uh = e;
}, "setTodayMarker"), wS = /* @__PURE__ */ u(function() {
  return uh;
}, "getTodayMarker"), TS = /* @__PURE__ */ u(function(e) {
  Xr = e;
}, "setDateFormat"), _S = /* @__PURE__ */ u(function() {
  bn = !0;
}, "enableInclusiveEndDates"), ES = /* @__PURE__ */ u(function() {
  return bn;
}, "endDatesAreInclusive"), AS = /* @__PURE__ */ u(function() {
  yh = !0;
}, "enableTopAxis"), LS = /* @__PURE__ */ u(function() {
  return yh;
}, "topAxisEnabled"), BS = /* @__PURE__ */ u(function(e) {
  gh = e;
}, "setDisplayMode"), DS = /* @__PURE__ */ u(function() {
  return gh;
}, "getDisplayMode"), IS = /* @__PURE__ */ u(function() {
  return Xr;
}, "getDateFormat"), FS = /* @__PURE__ */ u(function(e) {
  mn = e.toLowerCase().split(/[\s,]+/);
}, "setIncludes"), NS = /* @__PURE__ */ u(function() {
  return mn;
}, "getIncludes"), RS = /* @__PURE__ */ u(function(e) {
  xn = e.toLowerCase().split(/[\s,]+/);
}, "setExcludes"), MS = /* @__PURE__ */ u(function() {
  return xn;
}, "getExcludes"), OS = /* @__PURE__ */ u(function() {
  return dh;
}, "getLinks"), PS = /* @__PURE__ */ u(function(e) {
  ya = e, ph.push(e);
}, "addSection"), $S = /* @__PURE__ */ u(function() {
  return ph;
}, "getSections"), VS = /* @__PURE__ */ u(function() {
  let e = wu();
  const t = 10;
  let r = 0;
  for (; !e && r < t; )
    e = wu(), r++;
  return uo = Ve, uo;
}, "getTasks"), Wf = /* @__PURE__ */ u(function(e, t, r, i) {
  const s = e.format(t.trim()), a = e.format("YYYY-MM-DD");
  return i.includes(s) || i.includes(a) ? !1 : r.includes("weekends") && (e.isoWeekday() === Cu[po] || e.isoWeekday() === Cu[po] + 1) || r.includes(e.format("dddd").toLowerCase()) ? !0 : r.includes(s) || r.includes(a);
}, "isInvalidDate"), zS = /* @__PURE__ */ u(function(e) {
  mh = e;
}, "setWeekday"), WS = /* @__PURE__ */ u(function() {
  return mh;
}, "getWeekday"), qS = /* @__PURE__ */ u(function(e) {
  po = e;
}, "setWeekend"), qf = /* @__PURE__ */ u(function(e, t, r, i) {
  if (!r.length || e.manualEndTime)
    return;
  let s;
  e.startTime instanceof Date ? s = ir(e.startTime) : s = ir(e.startTime, t, !0), s = s.add(1, "d");
  let a;
  e.endTime instanceof Date ? a = ir(e.endTime) : a = ir(e.endTime, t, !0);
  const [n, o] = YS(
    s,
    a,
    t,
    r,
    i
  );
  e.endTime = n.toDate(), e.renderEndTime = o;
}, "checkTaskDates"), YS = /* @__PURE__ */ u(function(e, t, r, i, s) {
  let a = !1, n = null;
  for (; e <= t; )
    a || (n = t.toDate()), a = Wf(e, r, i, s), a && (t = t.add(1, "d")), e = e.add(1, "d");
  return [t, n];
}, "fixTaskDates"), Kl = /* @__PURE__ */ u(function(e, t, r) {
  if (r = r.trim(), (t.trim() === "x" || t.trim() === "X") && /^\d+$/.test(r))
    return new Date(Number(r));
  const s = /^after\s+(?<ids>[\d\w- ]+)/.exec(r);
  if (s !== null) {
    let n = null;
    for (const h of s.groups.ids.split(" ")) {
      let l = ds(h);
      l !== void 0 && (!n || l.endTime > n.endTime) && (n = l);
    }
    if (n)
      return n.endTime;
    const o = /* @__PURE__ */ new Date();
    return o.setHours(0, 0, 0, 0), o;
  }
  let a = ir(r, t.trim(), !0);
  if (a.isValid())
    return a.toDate();
  {
    I.debug("Invalid date:" + r), I.debug("With date format:" + t.trim());
    const n = new Date(r);
    if (n === void 0 || isNaN(n.getTime()) || // WebKit browsers can mis-parse invalid dates to be ridiculously
    // huge numbers, e.g. new Date('202304') gets parsed as January 1, 202304.
    // This can cause virtually infinite loops while rendering, so for the
    // purposes of Gantt charts we'll just treat any date beyond 10,000 AD/BC as
    // invalid.
    n.getFullYear() < -1e4 || n.getFullYear() > 1e4)
      throw new Error("Invalid date:" + r);
    return n;
  }
}, "getStartDate"), Yf = /* @__PURE__ */ u(function(e) {
  const t = /^(\d+(?:\.\d+)?)([Mdhmswy]|ms)$/.exec(e.trim());
  return t !== null ? [Number.parseFloat(t[1]), t[2]] : [NaN, "ms"];
}, "parseDuration"), Hf = /* @__PURE__ */ u(function(e, t, r, i = !1) {
  r = r.trim();
  const a = /^until\s+(?<ids>[\d\w- ]+)/.exec(r);
  if (a !== null) {
    let d = null;
    for (const g of a.groups.ids.split(" ")) {
      let f = ds(g);
      f !== void 0 && (!d || f.startTime < d.startTime) && (d = f);
    }
    if (d)
      return d.startTime;
    const p = /* @__PURE__ */ new Date();
    return p.setHours(0, 0, 0, 0), p;
  }
  let n = ir(r, t.trim(), !0);
  if (n.isValid())
    return i && (n = n.add(1, "d")), n.toDate();
  let o = ir(e);
  const [h, l] = Yf(r);
  if (!Number.isNaN(h)) {
    const d = o.add(h, l);
    d.isValid() && (o = d);
  }
  return o.toDate();
}, "getEndDate"), Mn = 0, As = /* @__PURE__ */ u(function(e) {
  return e === void 0 ? (Mn = Mn + 1, "task" + Mn) : e;
}, "parseId"), HS = /* @__PURE__ */ u(function(e, t) {
  let r;
  t.substr(0, 1) === ":" ? r = t.substr(1, t.length) : r = t;
  const i = r.split(","), s = {};
  xh(i, s, zf);
  for (let n = 0; n < i.length; n++)
    i[n] = i[n].trim();
  let a = "";
  switch (i.length) {
    case 1:
      s.id = As(), s.startTime = e.endTime, a = i[0];
      break;
    case 2:
      s.id = As(), s.startTime = Kl(void 0, Xr, i[0]), a = i[1];
      break;
    case 3:
      s.id = As(i[0]), s.startTime = Kl(void 0, Xr, i[1]), a = i[2];
      break;
  }
  return a && (s.endTime = Hf(s.startTime, Xr, a, bn), s.manualEndTime = ir(a, "YYYY-MM-DD", !0).isValid(), qf(s, Xr, xn, mn)), s;
}, "compileData"), US = /* @__PURE__ */ u(function(e, t) {
  let r;
  t.substr(0, 1) === ":" ? r = t.substr(1, t.length) : r = t;
  const i = r.split(","), s = {};
  xh(i, s, zf);
  for (let a = 0; a < i.length; a++)
    i[a] = i[a].trim();
  switch (i.length) {
    case 1:
      s.id = As(), s.startTime = {
        type: "prevTaskEnd",
        id: e
      }, s.endTime = {
        data: i[0]
      };
      break;
    case 2:
      s.id = As(), s.startTime = {
        type: "getStartDate",
        startData: i[0]
      }, s.endTime = {
        data: i[1]
      };
      break;
    case 3:
      s.id = As(i[0]), s.startTime = {
        type: "getStartDate",
        startData: i[1]
      }, s.endTime = {
        data: i[2]
      };
      break;
  }
  return s;
}, "parseData"), Ql, On, Ve = [], Uf = {}, jS = /* @__PURE__ */ u(function(e, t) {
  const r = {
    section: ya,
    type: ya,
    processed: !1,
    manualEndTime: !1,
    renderEndTime: null,
    raw: { data: t },
    task: e,
    classes: []
  }, i = US(On, t);
  r.raw.startTime = i.startTime, r.raw.endTime = i.endTime, r.id = i.id, r.prevTaskId = On, r.active = i.active, r.done = i.done, r.crit = i.crit, r.milestone = i.milestone, r.vert = i.vert, r.order = Xl, Xl++;
  const s = Ve.push(r);
  On = r.id, Uf[r.id] = s - 1;
}, "addTask"), ds = /* @__PURE__ */ u(function(e) {
  const t = Uf[e];
  return Ve[t];
}, "findTaskById"), GS = /* @__PURE__ */ u(function(e, t) {
  const r = {
    section: ya,
    type: ya,
    description: e,
    task: e,
    classes: []
  }, i = HS(Ql, t);
  r.startTime = i.startTime, r.endTime = i.endTime, r.id = i.id, r.active = i.active, r.done = i.done, r.crit = i.crit, r.milestone = i.milestone, r.vert = i.vert, Ql = r, uo.push(r);
}, "addTaskOrg"), wu = /* @__PURE__ */ u(function() {
  const e = /* @__PURE__ */ u(function(r) {
    const i = Ve[r];
    let s = "";
    switch (Ve[r].raw.startTime.type) {
      case "prevTaskEnd": {
        const a = ds(i.prevTaskId);
        i.startTime = a.endTime;
        break;
      }
      case "getStartDate":
        s = Kl(void 0, Xr, Ve[r].raw.startTime.startData), s && (Ve[r].startTime = s);
        break;
    }
    return Ve[r].startTime && (Ve[r].endTime = Hf(
      Ve[r].startTime,
      Xr,
      Ve[r].raw.endTime.data,
      bn
    ), Ve[r].endTime && (Ve[r].processed = !0, Ve[r].manualEndTime = ir(
      Ve[r].raw.endTime.data,
      "YYYY-MM-DD",
      !0
    ).isValid(), qf(Ve[r], Xr, xn, mn))), Ve[r].processed;
  }, "compileTask");
  let t = !0;
  for (const [r, i] of Ve.entries())
    e(r), t = t && i.processed;
  return t;
}, "compileTasks"), XS = /* @__PURE__ */ u(function(e, t) {
  let r = t;
  K().securityLevel !== "loose" && (r = ns(t)), e.split(",").forEach(function(i) {
    ds(i) !== void 0 && (Gf(i, () => {
      window.open(r, "_self");
    }), dh.set(i, r));
  }), jf(e, "clickable");
}, "setLink"), jf = /* @__PURE__ */ u(function(e, t) {
  e.split(",").forEach(function(r) {
    let i = ds(r);
    i !== void 0 && i.classes.push(t);
  });
}, "setClass"), KS = /* @__PURE__ */ u(function(e, t, r) {
  if (K().securityLevel !== "loose" || t === void 0)
    return;
  let i = [];
  if (typeof r == "string") {
    i = r.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
    for (let a = 0; a < i.length; a++) {
      let n = i[a].trim();
      n.startsWith('"') && n.endsWith('"') && (n = n.substr(1, n.length - 2)), i[a] = n;
    }
  }
  i.length === 0 && i.push(e), ds(e) !== void 0 && Gf(e, () => {
    ee.runFunc(t, ...i);
  });
}, "setClickFun"), Gf = /* @__PURE__ */ u(function(e, t) {
  fh.push(
    function() {
      const r = document.querySelector(`[id="${e}"]`);
      r !== null && r.addEventListener("click", function() {
        t();
      });
    },
    function() {
      const r = document.querySelector(`[id="${e}-text"]`);
      r !== null && r.addEventListener("click", function() {
        t();
      });
    }
  );
}, "pushFun"), QS = /* @__PURE__ */ u(function(e, t, r) {
  e.split(",").forEach(function(i) {
    KS(i, t, r);
  }), jf(e, "clickable");
}, "setClickEvent"), ZS = /* @__PURE__ */ u(function(e) {
  fh.forEach(function(t) {
    t(e);
  });
}, "bindFunctions"), JS = {
  getConfig: /* @__PURE__ */ u(() => K().gantt, "getConfig"),
  clear: xS,
  setDateFormat: TS,
  getDateFormat: IS,
  enableInclusiveEndDates: _S,
  endDatesAreInclusive: ES,
  enableTopAxis: AS,
  topAxisEnabled: LS,
  setAxisFormat: bS,
  getAxisFormat: kS,
  setTickInterval: vS,
  getTickInterval: SS,
  setTodayMarker: CS,
  getTodayMarker: wS,
  setAccTitle: Re,
  getAccTitle: qe,
  setDiagramTitle: Ge,
  getDiagramTitle: Oe,
  setDisplayMode: BS,
  getDisplayMode: DS,
  setAccDescription: Ye,
  getAccDescription: He,
  addSection: PS,
  getSections: $S,
  getTasks: VS,
  addTask: jS,
  findTaskById: ds,
  addTaskOrg: GS,
  setIncludes: FS,
  getIncludes: NS,
  setExcludes: RS,
  getExcludes: MS,
  setClickEvent: QS,
  setLink: XS,
  getLinks: OS,
  bindFunctions: ZS,
  parseDuration: Yf,
  isInvalidDate: Wf,
  setWeekday: zS,
  getWeekday: WS,
  setWeekend: qS
};
function xh(e, t, r) {
  let i = !0;
  for (; i; )
    i = !1, r.forEach(function(s) {
      const a = "^\\s*" + s + "\\s*$", n = new RegExp(a);
      e[0].match(n) && (t[s] = !0, e.shift(1), i = !0);
    });
}
u(xh, "getTaskTags");
var tC = /* @__PURE__ */ u(function() {
  I.debug("Something is calling, setConf, remove the call");
}, "setConf"), Tu = {
  monday: Hm,
  tuesday: Ym,
  wednesday: qm,
  thursday: Wm,
  friday: zm,
  saturday: Vm,
  sunday: $m
}, eC = /* @__PURE__ */ u((e, t) => {
  let r = [...e].map(() => -1 / 0), i = [...e].sort((a, n) => a.startTime - n.startTime || a.order - n.order), s = 0;
  for (const a of i)
    for (let n = 0; n < r.length; n++)
      if (a.startTime >= r[n]) {
        r[n] = a.endTime, a.order = n + t, n > s && (s = n);
        break;
      }
  return s;
}, "getMaxIntersections"), li, rC = /* @__PURE__ */ u(function(e, t, r, i) {
  const s = K().gantt, a = K().securityLevel;
  let n;
  a === "sandbox" && (n = yt("#i" + t));
  const o = a === "sandbox" ? yt(n.nodes()[0].contentDocument.body) : yt("body"), h = a === "sandbox" ? n.nodes()[0].contentDocument : document, l = h.getElementById(t);
  li = l.parentElement.offsetWidth, li === void 0 && (li = 1200), s.useWidth !== void 0 && (li = s.useWidth);
  const d = i.db.getTasks();
  let p = [];
  for (const T of d)
    p.push(T.type);
  p = L(p);
  const g = {};
  let f = 2 * s.topPadding;
  if (i.db.getDisplayMode() === "compact" || s.displayMode === "compact") {
    const T = {};
    for (const E of d)
      T[E.section] === void 0 ? T[E.section] = [E] : T[E.section].push(E);
    let C = 0;
    for (const E of Object.keys(T)) {
      const w = eC(T[E], C) + 1;
      C += w, f += w * (s.barHeight + s.barGap), g[E] = w;
    }
  } else {
    f += d.length * (s.barHeight + s.barGap);
    for (const T of p)
      g[T] = d.filter((C) => C.type === T).length;
  }
  l.setAttribute("viewBox", "0 0 " + li + " " + f);
  const y = o.select(`[id="${t}"]`), m = Nm().domain([
    Rm(d, function(T) {
      return T.startTime;
    }),
    Mm(d, function(T) {
      return T.endTime;
    })
  ]).rangeRound([0, li - s.leftPadding - s.rightPadding]);
  function x(T, C) {
    const E = T.startTime, w = C.startTime;
    let W = 0;
    return E > w ? W = 1 : E < w && (W = -1), W;
  }
  u(x, "taskCompare"), d.sort(x), b(d, li, f), fr(y, f, li, s.useMaxWidth), y.append("text").text(i.db.getDiagramTitle()).attr("x", li / 2).attr("y", s.titleTopMargin).attr("class", "titleText");
  function b(T, C, E) {
    const w = s.barHeight, W = w + s.barGap, N = s.topPadding, B = s.leftPadding, R = Ua().domain([0, p.length]).range(["#00B9FA", "#F95002"]).interpolate(Om);
    _(
      W,
      N,
      B,
      C,
      E,
      T,
      i.db.getExcludes(),
      i.db.getIncludes()
    ), A(B, N, C, E), v(T, W, N, B, w, R, C), S(W, N), k(B, N, C, E);
  }
  u(b, "makeGantt");
  function v(T, C, E, w, W, N, B) {
    T.sort((Y, M) => Y.vert === M.vert ? 0 : Y.vert ? 1 : -1);
    const V = [...new Set(T.map((Y) => Y.order))].map((Y) => T.find((M) => M.order === Y));
    y.append("g").selectAll("rect").data(V).enter().append("rect").attr("x", 0).attr("y", function(Y, M) {
      return M = Y.order, M * C + E - 2;
    }).attr("width", function() {
      return B - s.rightPadding / 2;
    }).attr("height", C).attr("class", function(Y) {
      for (const [M, G] of p.entries())
        if (Y.type === G)
          return "section section" + M % s.numberSectionStyles;
      return "section section0";
    }).enter();
    const $ = y.append("g").selectAll("rect").data(T).enter(), D = i.db.getLinks();
    if ($.append("rect").attr("id", function(Y) {
      return Y.id;
    }).attr("rx", 3).attr("ry", 3).attr("x", function(Y) {
      return Y.milestone ? m(Y.startTime) + w + 0.5 * (m(Y.endTime) - m(Y.startTime)) - 0.5 * W : m(Y.startTime) + w;
    }).attr("y", function(Y, M) {
      return M = Y.order, Y.vert ? s.gridLineStartPadding : M * C + E;
    }).attr("width", function(Y) {
      return Y.milestone ? W : Y.vert ? 0.08 * W : m(Y.renderEndTime || Y.endTime) - m(Y.startTime);
    }).attr("height", function(Y) {
      return Y.vert ? d.length * (s.barHeight + s.barGap) + s.barHeight * 2 : W;
    }).attr("transform-origin", function(Y, M) {
      return M = Y.order, (m(Y.startTime) + w + 0.5 * (m(Y.endTime) - m(Y.startTime))).toString() + "px " + (M * C + E + 0.5 * W).toString() + "px";
    }).attr("class", function(Y) {
      const M = "task";
      let G = "";
      Y.classes.length > 0 && (G = Y.classes.join(" "));
      let rt = 0;
      for (const [Z, ot] of p.entries())
        Y.type === ot && (rt = Z % s.numberSectionStyles);
      let ht = "";
      return Y.active ? Y.crit ? ht += " activeCrit" : ht = " active" : Y.done ? Y.crit ? ht = " doneCrit" : ht = " done" : Y.crit && (ht += " crit"), ht.length === 0 && (ht = " task"), Y.milestone && (ht = " milestone " + ht), Y.vert && (ht = " vert " + ht), ht += rt, ht += " " + G, M + ht;
    }), $.append("text").attr("id", function(Y) {
      return Y.id + "-text";
    }).text(function(Y) {
      return Y.task;
    }).attr("font-size", s.fontSize).attr("x", function(Y) {
      let M = m(Y.startTime), G = m(Y.renderEndTime || Y.endTime);
      if (Y.milestone && (M += 0.5 * (m(Y.endTime) - m(Y.startTime)) - 0.5 * W, G = M + W), Y.vert)
        return m(Y.startTime) + w;
      const rt = this.getBBox().width;
      return rt > G - M ? G + rt + 1.5 * s.leftPadding > B ? M + w - 5 : G + w + 5 : (G - M) / 2 + M + w;
    }).attr("y", function(Y, M) {
      return Y.vert ? s.gridLineStartPadding + d.length * (s.barHeight + s.barGap) + 60 : (M = Y.order, M * C + s.barHeight / 2 + (s.fontSize / 2 - 2) + E);
    }).attr("text-height", W).attr("class", function(Y) {
      const M = m(Y.startTime);
      let G = m(Y.endTime);
      Y.milestone && (G = M + W);
      const rt = this.getBBox().width;
      let ht = "";
      Y.classes.length > 0 && (ht = Y.classes.join(" "));
      let Z = 0;
      for (const [it, bt] of p.entries())
        Y.type === bt && (Z = it % s.numberSectionStyles);
      let ot = "";
      return Y.active && (Y.crit ? ot = "activeCritText" + Z : ot = "activeText" + Z), Y.done ? Y.crit ? ot = ot + " doneCritText" + Z : ot = ot + " doneText" + Z : Y.crit && (ot = ot + " critText" + Z), Y.milestone && (ot += " milestoneText"), Y.vert && (ot += " vertText"), rt > G - M ? G + rt + 1.5 * s.leftPadding > B ? ht + " taskTextOutsideLeft taskTextOutside" + Z + " " + ot : ht + " taskTextOutsideRight taskTextOutside" + Z + " " + ot + " width-" + rt : ht + " taskText taskText" + Z + " " + ot + " width-" + rt;
    }), K().securityLevel === "sandbox") {
      let Y;
      Y = yt("#i" + t);
      const M = Y.nodes()[0].contentDocument;
      $.filter(function(G) {
        return D.has(G.id);
      }).each(function(G) {
        var rt = M.querySelector("#" + G.id), ht = M.querySelector("#" + G.id + "-text");
        const Z = rt.parentNode;
        var ot = M.createElement("a");
        ot.setAttribute("xlink:href", D.get(G.id)), ot.setAttribute("target", "_top"), Z.appendChild(ot), ot.appendChild(rt), ot.appendChild(ht);
      });
    }
  }
  u(v, "drawRects");
  function _(T, C, E, w, W, N, B, R) {
    if (B.length === 0 && R.length === 0)
      return;
    let V, $;
    for (const { startTime: rt, endTime: ht } of N)
      (V === void 0 || rt < V) && (V = rt), ($ === void 0 || ht > $) && ($ = ht);
    if (!V || !$)
      return;
    if (ir($).diff(ir(V), "year") > 5) {
      I.warn(
        "The difference between the min and max time is more than 5 years. This will cause performance issues. Skipping drawing exclude days."
      );
      return;
    }
    const D = i.db.getDateFormat(), O = [];
    let Y = null, M = ir(V);
    for (; M.valueOf() <= $; )
      i.db.isInvalidDate(M, D, B, R) ? Y ? Y.end = M : Y = {
        start: M,
        end: M
      } : Y && (O.push(Y), Y = null), M = M.add(1, "d");
    y.append("g").selectAll("rect").data(O).enter().append("rect").attr("id", (rt) => "exclude-" + rt.start.format("YYYY-MM-DD")).attr("x", (rt) => m(rt.start.startOf("day")) + E).attr("y", s.gridLineStartPadding).attr("width", (rt) => m(rt.end.endOf("day")) - m(rt.start.startOf("day"))).attr("height", W - C - s.gridLineStartPadding).attr("transform-origin", function(rt, ht) {
      return (m(rt.start) + E + 0.5 * (m(rt.end) - m(rt.start))).toString() + "px " + (ht * T + 0.5 * W).toString() + "px";
    }).attr("class", "exclude-range");
  }
  u(_, "drawExcludeDays");
  function A(T, C, E, w) {
    const W = i.db.getDateFormat(), N = i.db.getAxisFormat();
    let B;
    N ? B = N : W === "D" ? B = "%d" : B = s.axisFormat ?? "%Y-%m-%d";
    let R = Pm(m).tickSize(-w + C + s.gridLineStartPadding).tickFormat(Xh(B));
    const $ = /^([1-9]\d*)(millisecond|second|minute|hour|day|week|month)$/.exec(
      i.db.getTickInterval() || s.tickInterval
    );
    if ($ !== null) {
      const D = $[1], O = $[2], Y = i.db.getWeekday() || s.weekday;
      switch (O) {
        case "millisecond":
          R.ticks(eu.every(D));
          break;
        case "second":
          R.ticks(tu.every(D));
          break;
        case "minute":
          R.ticks(Jh.every(D));
          break;
        case "hour":
          R.ticks(Zh.every(D));
          break;
        case "day":
          R.ticks(Qh.every(D));
          break;
        case "week":
          R.ticks(Tu[Y].every(D));
          break;
        case "month":
          R.ticks(Kh.every(D));
          break;
      }
    }
    if (y.append("g").attr("class", "grid").attr("transform", "translate(" + T + ", " + (w - 50) + ")").call(R).selectAll("text").style("text-anchor", "middle").attr("fill", "#000").attr("stroke", "none").attr("font-size", 10).attr("dy", "1em"), i.db.topAxisEnabled() || s.topAxis) {
      let D = Um(m).tickSize(-w + C + s.gridLineStartPadding).tickFormat(Xh(B));
      if ($ !== null) {
        const O = $[1], Y = $[2], M = i.db.getWeekday() || s.weekday;
        switch (Y) {
          case "millisecond":
            D.ticks(eu.every(O));
            break;
          case "second":
            D.ticks(tu.every(O));
            break;
          case "minute":
            D.ticks(Jh.every(O));
            break;
          case "hour":
            D.ticks(Zh.every(O));
            break;
          case "day":
            D.ticks(Qh.every(O));
            break;
          case "week":
            D.ticks(Tu[M].every(O));
            break;
          case "month":
            D.ticks(Kh.every(O));
            break;
        }
      }
      y.append("g").attr("class", "grid").attr("transform", "translate(" + T + ", " + C + ")").call(D).selectAll("text").style("text-anchor", "middle").attr("fill", "#000").attr("stroke", "none").attr("font-size", 10);
    }
  }
  u(A, "makeGrid");
  function S(T, C) {
    let E = 0;
    const w = Object.keys(g).map((W) => [W, g[W]]);
    y.append("g").selectAll("text").data(w).enter().append(function(W) {
      const N = W[0].split(St.lineBreakRegex), B = -(N.length - 1) / 2, R = h.createElementNS("http://www.w3.org/2000/svg", "text");
      R.setAttribute("dy", B + "em");
      for (const [V, $] of N.entries()) {
        const D = h.createElementNS("http://www.w3.org/2000/svg", "tspan");
        D.setAttribute("alignment-baseline", "central"), D.setAttribute("x", "10"), V > 0 && D.setAttribute("dy", "1em"), D.textContent = $, R.appendChild(D);
      }
      return R;
    }).attr("x", 10).attr("y", function(W, N) {
      if (N > 0)
        for (let B = 0; B < N; B++)
          return E += w[N - 1][1], W[1] * T / 2 + E * T + C;
      else
        return W[1] * T / 2 + C;
    }).attr("font-size", s.sectionFontSize).attr("class", function(W) {
      for (const [N, B] of p.entries())
        if (W[0] === B)
          return "sectionTitle sectionTitle" + N % s.numberSectionStyles;
      return "sectionTitle";
    });
  }
  u(S, "vertLabels");
  function k(T, C, E, w) {
    const W = i.db.getTodayMarker();
    if (W === "off")
      return;
    const N = y.append("g").attr("class", "today"), B = /* @__PURE__ */ new Date(), R = N.append("line");
    R.attr("x1", m(B) + T).attr("x2", m(B) + T).attr("y1", s.titleTopMargin).attr("y2", w - s.titleTopMargin).attr("class", "today"), W !== "" && R.attr("style", W.replace(/,/g, ";"));
  }
  u(k, "drawToday");
  function L(T) {
    const C = {}, E = [];
    for (let w = 0, W = T.length; w < W; ++w)
      Object.prototype.hasOwnProperty.call(C, T[w]) || (C[T[w]] = !0, E.push(T[w]));
    return E;
  }
  u(L, "checkUnique");
}, "draw"), iC = {
  setConf: tC,
  draw: rC
}, sC = /* @__PURE__ */ u((e) => `
  .mermaid-main-font {
        font-family: ${e.fontFamily};
  }

  .exclude-range {
    fill: ${e.excludeBkgColor};
  }

  .section {
    stroke: none;
    opacity: 0.2;
  }

  .section0 {
    fill: ${e.sectionBkgColor};
  }

  .section2 {
    fill: ${e.sectionBkgColor2};
  }

  .section1,
  .section3 {
    fill: ${e.altSectionBkgColor};
    opacity: 0.2;
  }

  .sectionTitle0 {
    fill: ${e.titleColor};
  }

  .sectionTitle1 {
    fill: ${e.titleColor};
  }

  .sectionTitle2 {
    fill: ${e.titleColor};
  }

  .sectionTitle3 {
    fill: ${e.titleColor};
  }

  .sectionTitle {
    text-anchor: start;
    font-family: ${e.fontFamily};
  }


  /* Grid and axis */

  .grid .tick {
    stroke: ${e.gridColor};
    opacity: 0.8;
    shape-rendering: crispEdges;
  }

  .grid .tick text {
    font-family: ${e.fontFamily};
    fill: ${e.textColor};
  }

  .grid path {
    stroke-width: 0;
  }


  /* Today line */

  .today {
    fill: none;
    stroke: ${e.todayLineColor};
    stroke-width: 2px;
  }


  /* Task styling */

  /* Default task */

  .task {
    stroke-width: 2;
  }

  .taskText {
    text-anchor: middle;
    font-family: ${e.fontFamily};
  }

  .taskTextOutsideRight {
    fill: ${e.taskTextDarkColor};
    text-anchor: start;
    font-family: ${e.fontFamily};
  }

  .taskTextOutsideLeft {
    fill: ${e.taskTextDarkColor};
    text-anchor: end;
  }


  /* Special case clickable */

  .task.clickable {
    cursor: pointer;
  }

  .taskText.clickable {
    cursor: pointer;
    fill: ${e.taskTextClickableColor} !important;
    font-weight: bold;
  }

  .taskTextOutsideLeft.clickable {
    cursor: pointer;
    fill: ${e.taskTextClickableColor} !important;
    font-weight: bold;
  }

  .taskTextOutsideRight.clickable {
    cursor: pointer;
    fill: ${e.taskTextClickableColor} !important;
    font-weight: bold;
  }


  /* Specific task settings for the sections*/

  .taskText0,
  .taskText1,
  .taskText2,
  .taskText3 {
    fill: ${e.taskTextColor};
  }

  .task0,
  .task1,
  .task2,
  .task3 {
    fill: ${e.taskBkgColor};
    stroke: ${e.taskBorderColor};
  }

  .taskTextOutside0,
  .taskTextOutside2
  {
    fill: ${e.taskTextOutsideColor};
  }

  .taskTextOutside1,
  .taskTextOutside3 {
    fill: ${e.taskTextOutsideColor};
  }


  /* Active task */

  .active0,
  .active1,
  .active2,
  .active3 {
    fill: ${e.activeTaskBkgColor};
    stroke: ${e.activeTaskBorderColor};
  }

  .activeText0,
  .activeText1,
  .activeText2,
  .activeText3 {
    fill: ${e.taskTextDarkColor} !important;
  }


  /* Completed task */

  .done0,
  .done1,
  .done2,
  .done3 {
    stroke: ${e.doneTaskBorderColor};
    fill: ${e.doneTaskBkgColor};
    stroke-width: 2;
  }

  .doneText0,
  .doneText1,
  .doneText2,
  .doneText3 {
    fill: ${e.taskTextDarkColor} !important;
  }


  /* Tasks on the critical line */

  .crit0,
  .crit1,
  .crit2,
  .crit3 {
    stroke: ${e.critBorderColor};
    fill: ${e.critBkgColor};
    stroke-width: 2;
  }

  .activeCrit0,
  .activeCrit1,
  .activeCrit2,
  .activeCrit3 {
    stroke: ${e.critBorderColor};
    fill: ${e.activeTaskBkgColor};
    stroke-width: 2;
  }

  .doneCrit0,
  .doneCrit1,
  .doneCrit2,
  .doneCrit3 {
    stroke: ${e.critBorderColor};
    fill: ${e.doneTaskBkgColor};
    stroke-width: 2;
    cursor: pointer;
    shape-rendering: crispEdges;
  }

  .milestone {
    transform: rotate(45deg) scale(0.8,0.8);
  }

  .milestoneText {
    font-style: italic;
  }
  .doneCritText0,
  .doneCritText1,
  .doneCritText2,
  .doneCritText3 {
    fill: ${e.taskTextDarkColor} !important;
  }

  .vert {
    stroke: ${e.vertLineColor};
  }

  .vertText {
    font-size: 15px;
    text-anchor: middle;
    fill: ${e.vertLineColor} !important;
  }

  .activeCritText0,
  .activeCritText1,
  .activeCritText2,
  .activeCritText3 {
    fill: ${e.taskTextDarkColor} !important;
  }

  .titleText {
    text-anchor: middle;
    font-size: 18px;
    fill: ${e.titleColor || e.textColor};
    font-family: ${e.fontFamily};
  }
`, "getStyles"), aC = sC, nC = {
  parser: mS,
  db: JS,
  renderer: iC,
  styles: aC
};
const oC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: nC
}, Symbol.toStringTag, { value: "Module" }));
var lC = {
  parse: /* @__PURE__ */ u(async (e) => {
    const t = await os("info", e);
    I.debug(t);
  }, "parse")
}, cC = {
  version: dl.version + ""
}, hC = /* @__PURE__ */ u(() => cC.version, "getVersion"), uC = {
  getVersion: hC
}, dC = /* @__PURE__ */ u((e, t, r) => {
  I.debug(`rendering info diagram
` + e);
  const i = xi(t);
  fr(i, 100, 400, !0), i.append("g").append("text").attr("x", 100).attr("y", 40).attr("class", "version").attr("font-size", 32).style("text-anchor", "middle").text(`v${r}`);
}, "draw"), pC = { draw: dC }, gC = {
  parser: lC,
  db: uC,
  renderer: pC
};
const fC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: gC
}, Symbol.toStringTag, { value: "Module" }));
var yC = de.pie, bh = {
  sections: /* @__PURE__ */ new Map(),
  showData: !1
}, go = bh.sections, kh = bh.showData, mC = structuredClone(yC), xC = /* @__PURE__ */ u(() => structuredClone(mC), "getConfig"), bC = /* @__PURE__ */ u(() => {
  go = /* @__PURE__ */ new Map(), kh = bh.showData, Me();
}, "clear"), kC = /* @__PURE__ */ u(({ label: e, value: t }) => {
  if (t < 0)
    throw new Error(
      `"${e}" has invalid value: ${t}. Negative values are not allowed in pie charts. All slice values must be >= 0.`
    );
  go.has(e) || (go.set(e, t), I.debug(`added new section: ${e}, with value: ${t}`));
}, "addSection"), vC = /* @__PURE__ */ u(() => go, "getSections"), SC = /* @__PURE__ */ u((e) => {
  kh = e;
}, "setShowData"), CC = /* @__PURE__ */ u(() => kh, "getShowData"), Xf = {
  getConfig: xC,
  clear: bC,
  setDiagramTitle: Ge,
  getDiagramTitle: Oe,
  setAccTitle: Re,
  getAccTitle: qe,
  setAccDescription: Ye,
  getAccDescription: He,
  addSection: kC,
  getSections: vC,
  setShowData: SC,
  getShowData: CC
}, wC = /* @__PURE__ */ u((e, t) => {
  hs(e, t), t.setShowData(e.showData), e.sections.map(t.addSection);
}, "populateDb"), TC = {
  parse: /* @__PURE__ */ u(async (e) => {
    const t = await os("pie", e);
    I.debug(t), wC(t, Xf);
  }, "parse")
}, _C = /* @__PURE__ */ u((e) => `
  .pieCircle{
    stroke: ${e.pieStrokeColor};
    stroke-width : ${e.pieStrokeWidth};
    opacity : ${e.pieOpacity};
  }
  .pieOuterCircle{
    stroke: ${e.pieOuterStrokeColor};
    stroke-width: ${e.pieOuterStrokeWidth};
    fill: none;
  }
  .pieTitleText {
    text-anchor: middle;
    font-size: ${e.pieTitleTextSize};
    fill: ${e.pieTitleTextColor};
    font-family: ${e.fontFamily};
  }
  .slice {
    font-family: ${e.fontFamily};
    fill: ${e.pieSectionTextColor};
    font-size:${e.pieSectionTextSize};
    // fill: white;
  }
  .legend text {
    fill: ${e.pieLegendTextColor};
    font-family: ${e.fontFamily};
    font-size: ${e.pieLegendTextSize};
  }
`, "getStyles"), EC = _C, AC = /* @__PURE__ */ u((e) => {
  const t = [...e.values()].reduce((s, a) => s + a, 0), r = [...e.entries()].map(([s, a]) => ({ label: s, value: a })).filter((s) => s.value / t * 100 >= 1).sort((s, a) => a.value - s.value);
  return Km().value((s) => s.value)(r);
}, "createPieArcs"), LC = /* @__PURE__ */ u((e, t, r, i) => {
  I.debug(`rendering pie chart
` + e);
  const s = i.db, a = K(), n = gr(s.getConfig(), a.pie), o = 40, h = 18, l = 4, d = 450, p = d, g = xi(t), f = g.append("g");
  f.attr("transform", "translate(" + p / 2 + "," + d / 2 + ")");
  const { themeVariables: y } = a;
  let [m] = ls(y.pieOuterStrokeWidth);
  m ?? (m = 2);
  const x = n.textPosition, b = Math.min(p, d) / 2 - o, v = da().innerRadius(0).outerRadius(b), _ = da().innerRadius(b * x).outerRadius(b * x);
  f.append("circle").attr("cx", 0).attr("cy", 0).attr("r", b + m / 2).attr("class", "pieOuterCircle");
  const A = s.getSections(), S = AC(A), k = [
    y.pie1,
    y.pie2,
    y.pie3,
    y.pie4,
    y.pie5,
    y.pie6,
    y.pie7,
    y.pie8,
    y.pie9,
    y.pie10,
    y.pie11,
    y.pie12
  ];
  let L = 0;
  A.forEach((B) => {
    L += B;
  });
  const T = S.filter((B) => (B.data.value / L * 100).toFixed(0) !== "0"), C = Va(k);
  f.selectAll("mySlices").data(T).enter().append("path").attr("d", v).attr("fill", (B) => C(B.data.label)).attr("class", "pieCircle"), f.selectAll("mySlices").data(T).enter().append("text").text((B) => (B.data.value / L * 100).toFixed(0) + "%").attr("transform", (B) => "translate(" + _.centroid(B) + ")").style("text-anchor", "middle").attr("class", "slice"), f.append("text").text(s.getDiagramTitle()).attr("x", 0).attr("y", -400 / 2).attr("class", "pieTitleText");
  const E = [...A.entries()].map(([B, R]) => ({
    label: B,
    value: R
  })), w = f.selectAll(".legend").data(E).enter().append("g").attr("class", "legend").attr("transform", (B, R) => {
    const V = h + l, $ = V * E.length / 2, D = 12 * h, O = R * V - $;
    return "translate(" + D + "," + O + ")";
  });
  w.append("rect").attr("width", h).attr("height", h).style("fill", (B) => C(B.label)).style("stroke", (B) => C(B.label)), w.append("text").attr("x", h + l).attr("y", h - l).text((B) => s.getShowData() ? `${B.label} [${B.value}]` : B.label);
  const W = Math.max(
    ...w.selectAll("text").nodes().map((B) => (B == null ? void 0 : B.getBoundingClientRect().width) ?? 0)
  ), N = p + o + h + l + W;
  g.attr("viewBox", `0 0 ${N} ${d}`), fr(g, d, N, n.useMaxWidth);
}, "draw"), BC = { draw: LC }, DC = {
  parser: TC,
  db: Xf,
  renderer: BC,
  styles: EC
};
const IC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: DC
}, Symbol.toStringTag, { value: "Module" }));
var Zl = function() {
  var e = /* @__PURE__ */ u(function(At, q, vt, ct) {
    for (vt = vt || {}, ct = At.length; ct--; vt[At[ct]] = q) ;
    return vt;
  }, "o"), t = [1, 3], r = [1, 4], i = [1, 5], s = [1, 6], a = [1, 7], n = [1, 4, 5, 10, 12, 13, 14, 18, 25, 35, 37, 39, 41, 42, 48, 50, 51, 52, 53, 54, 55, 56, 57, 60, 61, 63, 64, 65, 66, 67], o = [1, 4, 5, 10, 12, 13, 14, 18, 25, 28, 35, 37, 39, 41, 42, 48, 50, 51, 52, 53, 54, 55, 56, 57, 60, 61, 63, 64, 65, 66, 67], h = [55, 56, 57], l = [2, 36], d = [1, 37], p = [1, 36], g = [1, 38], f = [1, 35], y = [1, 43], m = [1, 41], x = [1, 14], b = [1, 23], v = [1, 18], _ = [1, 19], A = [1, 20], S = [1, 21], k = [1, 22], L = [1, 24], T = [1, 25], C = [1, 26], E = [1, 27], w = [1, 28], W = [1, 29], N = [1, 32], B = [1, 33], R = [1, 34], V = [1, 39], $ = [1, 40], D = [1, 42], O = [1, 44], Y = [1, 62], M = [1, 61], G = [4, 5, 8, 10, 12, 13, 14, 18, 44, 47, 49, 55, 56, 57, 63, 64, 65, 66, 67], rt = [1, 65], ht = [1, 66], Z = [1, 67], ot = [1, 68], it = [1, 69], bt = [1, 70], xt = [1, 71], Ct = [1, 72], at = [1, 73], lt = [1, 74], Q = [1, 75], U = [1, 76], et = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 18], z = [1, 90], Tt = [1, 91], F = [1, 92], te = [1, 99], J = [1, 93], Ut = [1, 96], Wt = [1, 94], ie = [1, 95], dt = [1, 97], wt = [1, 98], nt = [1, 102], ut = [10, 55, 56, 57], kt = [4, 5, 6, 8, 10, 11, 13, 17, 18, 19, 20, 55, 56, 57], X = {
    trace: /* @__PURE__ */ u(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, idStringToken: 3, ALPHA: 4, NUM: 5, NODE_STRING: 6, DOWN: 7, MINUS: 8, DEFAULT: 9, COMMA: 10, COLON: 11, AMP: 12, BRKT: 13, MULT: 14, UNICODE_TEXT: 15, styleComponent: 16, UNIT: 17, SPACE: 18, STYLE: 19, PCT: 20, idString: 21, style: 22, stylesOpt: 23, classDefStatement: 24, CLASSDEF: 25, start: 26, eol: 27, QUADRANT: 28, document: 29, line: 30, statement: 31, axisDetails: 32, quadrantDetails: 33, points: 34, title: 35, title_value: 36, acc_title: 37, acc_title_value: 38, acc_descr: 39, acc_descr_value: 40, acc_descr_multiline_value: 41, section: 42, text: 43, point_start: 44, point_x: 45, point_y: 46, class_name: 47, "X-AXIS": 48, "AXIS-TEXT-DELIMITER": 49, "Y-AXIS": 50, QUADRANT_1: 51, QUADRANT_2: 52, QUADRANT_3: 53, QUADRANT_4: 54, NEWLINE: 55, SEMI: 56, EOF: 57, alphaNumToken: 58, textNoTagsToken: 59, STR: 60, MD_STR: 61, alphaNum: 62, PUNCTUATION: 63, PLUS: 64, EQUALS: 65, DOT: 66, UNDERSCORE: 67, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 4: "ALPHA", 5: "NUM", 6: "NODE_STRING", 7: "DOWN", 8: "MINUS", 9: "DEFAULT", 10: "COMMA", 11: "COLON", 12: "AMP", 13: "BRKT", 14: "MULT", 15: "UNICODE_TEXT", 17: "UNIT", 18: "SPACE", 19: "STYLE", 20: "PCT", 25: "CLASSDEF", 28: "QUADRANT", 35: "title", 36: "title_value", 37: "acc_title", 38: "acc_title_value", 39: "acc_descr", 40: "acc_descr_value", 41: "acc_descr_multiline_value", 42: "section", 44: "point_start", 45: "point_x", 46: "point_y", 47: "class_name", 48: "X-AXIS", 49: "AXIS-TEXT-DELIMITER", 50: "Y-AXIS", 51: "QUADRANT_1", 52: "QUADRANT_2", 53: "QUADRANT_3", 54: "QUADRANT_4", 55: "NEWLINE", 56: "SEMI", 57: "EOF", 60: "STR", 61: "MD_STR", 63: "PUNCTUATION", 64: "PLUS", 65: "EQUALS", 66: "DOT", 67: "UNDERSCORE" },
    productions_: [0, [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [16, 1], [16, 1], [16, 1], [16, 1], [16, 1], [16, 1], [16, 1], [16, 1], [16, 1], [16, 1], [21, 1], [21, 2], [22, 1], [22, 2], [23, 1], [23, 3], [24, 5], [26, 2], [26, 2], [26, 2], [29, 0], [29, 2], [30, 2], [31, 0], [31, 1], [31, 2], [31, 1], [31, 1], [31, 1], [31, 2], [31, 2], [31, 2], [31, 1], [31, 1], [34, 4], [34, 5], [34, 5], [34, 6], [32, 4], [32, 3], [32, 2], [32, 4], [32, 3], [32, 2], [33, 2], [33, 2], [33, 2], [33, 2], [27, 1], [27, 1], [27, 1], [43, 1], [43, 2], [43, 1], [43, 1], [62, 1], [62, 2], [58, 1], [58, 1], [58, 1], [58, 1], [58, 1], [58, 1], [58, 1], [58, 1], [58, 1], [58, 1], [58, 1], [59, 1], [59, 1], [59, 1]],
    performAction: /* @__PURE__ */ u(function(q, vt, ct, Nt, pt, gt, Jt) {
      var Et = gt.length - 1;
      switch (pt) {
        case 23:
          this.$ = gt[Et];
          break;
        case 24:
          this.$ = gt[Et - 1] + "" + gt[Et];
          break;
        case 26:
          this.$ = gt[Et - 1] + gt[Et];
          break;
        case 27:
          this.$ = [gt[Et].trim()];
          break;
        case 28:
          gt[Et - 2].push(gt[Et].trim()), this.$ = gt[Et - 2];
          break;
        case 29:
          this.$ = gt[Et - 4], Nt.addClass(gt[Et - 2], gt[Et]);
          break;
        case 37:
          this.$ = [];
          break;
        case 42:
          this.$ = gt[Et].trim(), Nt.setDiagramTitle(this.$);
          break;
        case 43:
          this.$ = gt[Et].trim(), Nt.setAccTitle(this.$);
          break;
        case 44:
        case 45:
          this.$ = gt[Et].trim(), Nt.setAccDescription(this.$);
          break;
        case 46:
          Nt.addSection(gt[Et].substr(8)), this.$ = gt[Et].substr(8);
          break;
        case 47:
          Nt.addPoint(gt[Et - 3], "", gt[Et - 1], gt[Et], []);
          break;
        case 48:
          Nt.addPoint(gt[Et - 4], gt[Et - 3], gt[Et - 1], gt[Et], []);
          break;
        case 49:
          Nt.addPoint(gt[Et - 4], "", gt[Et - 2], gt[Et - 1], gt[Et]);
          break;
        case 50:
          Nt.addPoint(gt[Et - 5], gt[Et - 4], gt[Et - 2], gt[Et - 1], gt[Et]);
          break;
        case 51:
          Nt.setXAxisLeftText(gt[Et - 2]), Nt.setXAxisRightText(gt[Et]);
          break;
        case 52:
          gt[Et - 1].text += "  ", Nt.setXAxisLeftText(gt[Et - 1]);
          break;
        case 53:
          Nt.setXAxisLeftText(gt[Et]);
          break;
        case 54:
          Nt.setYAxisBottomText(gt[Et - 2]), Nt.setYAxisTopText(gt[Et]);
          break;
        case 55:
          gt[Et - 1].text += "  ", Nt.setYAxisBottomText(gt[Et - 1]);
          break;
        case 56:
          Nt.setYAxisBottomText(gt[Et]);
          break;
        case 57:
          Nt.setQuadrant1Text(gt[Et]);
          break;
        case 58:
          Nt.setQuadrant2Text(gt[Et]);
          break;
        case 59:
          Nt.setQuadrant3Text(gt[Et]);
          break;
        case 60:
          Nt.setQuadrant4Text(gt[Et]);
          break;
        case 64:
          this.$ = { text: gt[Et], type: "text" };
          break;
        case 65:
          this.$ = { text: gt[Et - 1].text + "" + gt[Et], type: gt[Et - 1].type };
          break;
        case 66:
          this.$ = { text: gt[Et], type: "text" };
          break;
        case 67:
          this.$ = { text: gt[Et], type: "markdown" };
          break;
        case 68:
          this.$ = gt[Et];
          break;
        case 69:
          this.$ = gt[Et - 1] + "" + gt[Et];
          break;
      }
    }, "anonymous"),
    table: [{ 18: t, 26: 1, 27: 2, 28: r, 55: i, 56: s, 57: a }, { 1: [3] }, { 18: t, 26: 8, 27: 2, 28: r, 55: i, 56: s, 57: a }, { 18: t, 26: 9, 27: 2, 28: r, 55: i, 56: s, 57: a }, e(n, [2, 33], { 29: 10 }), e(o, [2, 61]), e(o, [2, 62]), e(o, [2, 63]), { 1: [2, 30] }, { 1: [2, 31] }, e(h, l, { 30: 11, 31: 12, 24: 13, 32: 15, 33: 16, 34: 17, 43: 30, 58: 31, 1: [2, 32], 4: d, 5: p, 10: g, 12: f, 13: y, 14: m, 18: x, 25: b, 35: v, 37: _, 39: A, 41: S, 42: k, 48: L, 50: T, 51: C, 52: E, 53: w, 54: W, 60: N, 61: B, 63: R, 64: V, 65: $, 66: D, 67: O }), e(n, [2, 34]), { 27: 45, 55: i, 56: s, 57: a }, e(h, [2, 37]), e(h, l, { 24: 13, 32: 15, 33: 16, 34: 17, 43: 30, 58: 31, 31: 46, 4: d, 5: p, 10: g, 12: f, 13: y, 14: m, 18: x, 25: b, 35: v, 37: _, 39: A, 41: S, 42: k, 48: L, 50: T, 51: C, 52: E, 53: w, 54: W, 60: N, 61: B, 63: R, 64: V, 65: $, 66: D, 67: O }), e(h, [2, 39]), e(h, [2, 40]), e(h, [2, 41]), { 36: [1, 47] }, { 38: [1, 48] }, { 40: [1, 49] }, e(h, [2, 45]), e(h, [2, 46]), { 18: [1, 50] }, { 4: d, 5: p, 10: g, 12: f, 13: y, 14: m, 43: 51, 58: 31, 60: N, 61: B, 63: R, 64: V, 65: $, 66: D, 67: O }, { 4: d, 5: p, 10: g, 12: f, 13: y, 14: m, 43: 52, 58: 31, 60: N, 61: B, 63: R, 64: V, 65: $, 66: D, 67: O }, { 4: d, 5: p, 10: g, 12: f, 13: y, 14: m, 43: 53, 58: 31, 60: N, 61: B, 63: R, 64: V, 65: $, 66: D, 67: O }, { 4: d, 5: p, 10: g, 12: f, 13: y, 14: m, 43: 54, 58: 31, 60: N, 61: B, 63: R, 64: V, 65: $, 66: D, 67: O }, { 4: d, 5: p, 10: g, 12: f, 13: y, 14: m, 43: 55, 58: 31, 60: N, 61: B, 63: R, 64: V, 65: $, 66: D, 67: O }, { 4: d, 5: p, 10: g, 12: f, 13: y, 14: m, 43: 56, 58: 31, 60: N, 61: B, 63: R, 64: V, 65: $, 66: D, 67: O }, { 4: d, 5: p, 8: Y, 10: g, 12: f, 13: y, 14: m, 18: M, 44: [1, 57], 47: [1, 58], 58: 60, 59: 59, 63: R, 64: V, 65: $, 66: D, 67: O }, e(G, [2, 64]), e(G, [2, 66]), e(G, [2, 67]), e(G, [2, 70]), e(G, [2, 71]), e(G, [2, 72]), e(G, [2, 73]), e(G, [2, 74]), e(G, [2, 75]), e(G, [2, 76]), e(G, [2, 77]), e(G, [2, 78]), e(G, [2, 79]), e(G, [2, 80]), e(n, [2, 35]), e(h, [2, 38]), e(h, [2, 42]), e(h, [2, 43]), e(h, [2, 44]), { 3: 64, 4: rt, 5: ht, 6: Z, 7: ot, 8: it, 9: bt, 10: xt, 11: Ct, 12: at, 13: lt, 14: Q, 15: U, 21: 63 }, e(h, [2, 53], { 59: 59, 58: 60, 4: d, 5: p, 8: Y, 10: g, 12: f, 13: y, 14: m, 18: M, 49: [1, 77], 63: R, 64: V, 65: $, 66: D, 67: O }), e(h, [2, 56], { 59: 59, 58: 60, 4: d, 5: p, 8: Y, 10: g, 12: f, 13: y, 14: m, 18: M, 49: [1, 78], 63: R, 64: V, 65: $, 66: D, 67: O }), e(h, [2, 57], { 59: 59, 58: 60, 4: d, 5: p, 8: Y, 10: g, 12: f, 13: y, 14: m, 18: M, 63: R, 64: V, 65: $, 66: D, 67: O }), e(h, [2, 58], { 59: 59, 58: 60, 4: d, 5: p, 8: Y, 10: g, 12: f, 13: y, 14: m, 18: M, 63: R, 64: V, 65: $, 66: D, 67: O }), e(h, [2, 59], { 59: 59, 58: 60, 4: d, 5: p, 8: Y, 10: g, 12: f, 13: y, 14: m, 18: M, 63: R, 64: V, 65: $, 66: D, 67: O }), e(h, [2, 60], { 59: 59, 58: 60, 4: d, 5: p, 8: Y, 10: g, 12: f, 13: y, 14: m, 18: M, 63: R, 64: V, 65: $, 66: D, 67: O }), { 45: [1, 79] }, { 44: [1, 80] }, e(G, [2, 65]), e(G, [2, 81]), e(G, [2, 82]), e(G, [2, 83]), { 3: 82, 4: rt, 5: ht, 6: Z, 7: ot, 8: it, 9: bt, 10: xt, 11: Ct, 12: at, 13: lt, 14: Q, 15: U, 18: [1, 81] }, e(et, [2, 23]), e(et, [2, 1]), e(et, [2, 2]), e(et, [2, 3]), e(et, [2, 4]), e(et, [2, 5]), e(et, [2, 6]), e(et, [2, 7]), e(et, [2, 8]), e(et, [2, 9]), e(et, [2, 10]), e(et, [2, 11]), e(et, [2, 12]), e(h, [2, 52], { 58: 31, 43: 83, 4: d, 5: p, 10: g, 12: f, 13: y, 14: m, 60: N, 61: B, 63: R, 64: V, 65: $, 66: D, 67: O }), e(h, [2, 55], { 58: 31, 43: 84, 4: d, 5: p, 10: g, 12: f, 13: y, 14: m, 60: N, 61: B, 63: R, 64: V, 65: $, 66: D, 67: O }), { 46: [1, 85] }, { 45: [1, 86] }, { 4: z, 5: Tt, 6: F, 8: te, 11: J, 13: Ut, 16: 89, 17: Wt, 18: ie, 19: dt, 20: wt, 22: 88, 23: 87 }, e(et, [2, 24]), e(h, [2, 51], { 59: 59, 58: 60, 4: d, 5: p, 8: Y, 10: g, 12: f, 13: y, 14: m, 18: M, 63: R, 64: V, 65: $, 66: D, 67: O }), e(h, [2, 54], { 59: 59, 58: 60, 4: d, 5: p, 8: Y, 10: g, 12: f, 13: y, 14: m, 18: M, 63: R, 64: V, 65: $, 66: D, 67: O }), e(h, [2, 47], { 22: 88, 16: 89, 23: 100, 4: z, 5: Tt, 6: F, 8: te, 11: J, 13: Ut, 17: Wt, 18: ie, 19: dt, 20: wt }), { 46: [1, 101] }, e(h, [2, 29], { 10: nt }), e(ut, [2, 27], { 16: 103, 4: z, 5: Tt, 6: F, 8: te, 11: J, 13: Ut, 17: Wt, 18: ie, 19: dt, 20: wt }), e(kt, [2, 25]), e(kt, [2, 13]), e(kt, [2, 14]), e(kt, [2, 15]), e(kt, [2, 16]), e(kt, [2, 17]), e(kt, [2, 18]), e(kt, [2, 19]), e(kt, [2, 20]), e(kt, [2, 21]), e(kt, [2, 22]), e(h, [2, 49], { 10: nt }), e(h, [2, 48], { 22: 88, 16: 89, 23: 104, 4: z, 5: Tt, 6: F, 8: te, 11: J, 13: Ut, 17: Wt, 18: ie, 19: dt, 20: wt }), { 4: z, 5: Tt, 6: F, 8: te, 11: J, 13: Ut, 16: 89, 17: Wt, 18: ie, 19: dt, 20: wt, 22: 105 }, e(kt, [2, 26]), e(h, [2, 50], { 10: nt }), e(ut, [2, 28], { 16: 103, 4: z, 5: Tt, 6: F, 8: te, 11: J, 13: Ut, 17: Wt, 18: ie, 19: dt, 20: wt })],
    defaultActions: { 8: [2, 30], 9: [2, 31] },
    parseError: /* @__PURE__ */ u(function(q, vt) {
      if (vt.recoverable)
        this.trace(q);
      else {
        var ct = new Error(q);
        throw ct.hash = vt, ct;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ u(function(q) {
      var vt = this, ct = [0], Nt = [], pt = [null], gt = [], Jt = this.table, Et = "", ue = 0, Ke = 0, se = 2, me = 1, Pe = gt.slice.call(arguments, 1), Gt = Object.create(this.lexer), Se = { yy: {} };
      for (var ve in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, ve) && (Se.yy[ve] = this.yy[ve]);
      Gt.setInput(q, Se.yy), Se.yy.lexer = Gt, Se.yy.parser = this, typeof Gt.yylloc > "u" && (Gt.yylloc = {});
      var Ue = Gt.yylloc;
      gt.push(Ue);
      var qt = Gt.options && Gt.options.ranges;
      typeof Se.yy.parseError == "function" ? this.parseError = Se.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function ye(_e) {
        ct.length = ct.length - 2 * _e, pt.length = pt.length - _e, gt.length = gt.length - _e;
      }
      u(ye, "popStack");
      function Mt() {
        var _e;
        return _e = Nt.pop() || Gt.lex() || me, typeof _e != "number" && (_e instanceof Array && (Nt = _e, _e = Nt.pop()), _e = vt.symbols_[_e] || _e), _e;
      }
      u(Mt, "lex");
      for (var ae, Zt, jt, $t, ne = {}, tr, oe, $e, vr; ; ) {
        if (Zt = ct[ct.length - 1], this.defaultActions[Zt] ? jt = this.defaultActions[Zt] : ((ae === null || typeof ae > "u") && (ae = Mt()), jt = Jt[Zt] && Jt[Zt][ae]), typeof jt > "u" || !jt.length || !jt[0]) {
          var Sr = "";
          vr = [];
          for (tr in Jt[Zt])
            this.terminals_[tr] && tr > se && vr.push("'" + this.terminals_[tr] + "'");
          Gt.showPosition ? Sr = "Parse error on line " + (ue + 1) + `:
` + Gt.showPosition() + `
Expecting ` + vr.join(", ") + ", got '" + (this.terminals_[ae] || ae) + "'" : Sr = "Parse error on line " + (ue + 1) + ": Unexpected " + (ae == me ? "end of input" : "'" + (this.terminals_[ae] || ae) + "'"), this.parseError(Sr, {
            text: Gt.match,
            token: this.terminals_[ae] || ae,
            line: Gt.yylineno,
            loc: Ue,
            expected: vr
          });
        }
        if (jt[0] instanceof Array && jt.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + Zt + ", token: " + ae);
        switch (jt[0]) {
          case 1:
            ct.push(ae), pt.push(Gt.yytext), gt.push(Gt.yylloc), ct.push(jt[1]), ae = null, Ke = Gt.yyleng, Et = Gt.yytext, ue = Gt.yylineno, Ue = Gt.yylloc;
            break;
          case 2:
            if (oe = this.productions_[jt[1]][1], ne.$ = pt[pt.length - oe], ne._$ = {
              first_line: gt[gt.length - (oe || 1)].first_line,
              last_line: gt[gt.length - 1].last_line,
              first_column: gt[gt.length - (oe || 1)].first_column,
              last_column: gt[gt.length - 1].last_column
            }, qt && (ne._$.range = [
              gt[gt.length - (oe || 1)].range[0],
              gt[gt.length - 1].range[1]
            ]), $t = this.performAction.apply(ne, [
              Et,
              Ke,
              ue,
              Se.yy,
              jt[1],
              pt,
              gt
            ].concat(Pe)), typeof $t < "u")
              return $t;
            oe && (ct = ct.slice(0, -1 * oe * 2), pt = pt.slice(0, -1 * oe), gt = gt.slice(0, -1 * oe)), ct.push(this.productions_[jt[1]][0]), pt.push(ne.$), gt.push(ne._$), $e = Jt[ct[ct.length - 2]][ct[ct.length - 1]], ct.push($e);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, ft = /* @__PURE__ */ function() {
    var At = {
      EOF: 1,
      parseError: /* @__PURE__ */ u(function(vt, ct) {
        if (this.yy.parser)
          this.yy.parser.parseError(vt, ct);
        else
          throw new Error(vt);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ u(function(q, vt) {
        return this.yy = vt || this.yy || {}, this._input = q, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ u(function() {
        var q = this._input[0];
        this.yytext += q, this.yyleng++, this.offset++, this.match += q, this.matched += q;
        var vt = q.match(/(?:\r\n?|\n).*/g);
        return vt ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), q;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ u(function(q) {
        var vt = q.length, ct = q.split(/(?:\r\n?|\n)/g);
        this._input = q + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - vt), this.offset -= vt;
        var Nt = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), ct.length - 1 && (this.yylineno -= ct.length - 1);
        var pt = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: ct ? (ct.length === Nt.length ? this.yylloc.first_column : 0) + Nt[Nt.length - ct.length].length - ct[0].length : this.yylloc.first_column - vt
        }, this.options.ranges && (this.yylloc.range = [pt[0], pt[0] + this.yyleng - vt]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ u(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ u(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ u(function(q) {
        this.unput(this.match.slice(q));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ u(function() {
        var q = this.matched.substr(0, this.matched.length - this.match.length);
        return (q.length > 20 ? "..." : "") + q.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ u(function() {
        var q = this.match;
        return q.length < 20 && (q += this._input.substr(0, 20 - q.length)), (q.substr(0, 20) + (q.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ u(function() {
        var q = this.pastInput(), vt = new Array(q.length + 1).join("-");
        return q + this.upcomingInput() + `
` + vt + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ u(function(q, vt) {
        var ct, Nt, pt;
        if (this.options.backtrack_lexer && (pt = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (pt.yylloc.range = this.yylloc.range.slice(0))), Nt = q[0].match(/(?:\r\n?|\n).*/g), Nt && (this.yylineno += Nt.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: Nt ? Nt[Nt.length - 1].length - Nt[Nt.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + q[0].length
        }, this.yytext += q[0], this.match += q[0], this.matches = q, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(q[0].length), this.matched += q[0], ct = this.performAction.call(this, this.yy, this, vt, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), ct)
          return ct;
        if (this._backtrack) {
          for (var gt in pt)
            this[gt] = pt[gt];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ u(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var q, vt, ct, Nt;
        this._more || (this.yytext = "", this.match = "");
        for (var pt = this._currentRules(), gt = 0; gt < pt.length; gt++)
          if (ct = this._input.match(this.rules[pt[gt]]), ct && (!vt || ct[0].length > vt[0].length)) {
            if (vt = ct, Nt = gt, this.options.backtrack_lexer) {
              if (q = this.test_match(ct, pt[gt]), q !== !1)
                return q;
              if (this._backtrack) {
                vt = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return vt ? (q = this.test_match(vt, pt[Nt]), q !== !1 ? q : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ u(function() {
        var vt = this.next();
        return vt || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ u(function(vt) {
        this.conditionStack.push(vt);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ u(function() {
        var vt = this.conditionStack.length - 1;
        return vt > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ u(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ u(function(vt) {
        return vt = this.conditionStack.length - 1 - Math.abs(vt || 0), vt >= 0 ? this.conditionStack[vt] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ u(function(vt) {
        this.begin(vt);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ u(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: { "case-insensitive": !0 },
      performAction: /* @__PURE__ */ u(function(vt, ct, Nt, pt) {
        switch (Nt) {
          case 0:
            break;
          case 1:
            break;
          case 2:
            return 55;
          case 3:
            break;
          case 4:
            return this.begin("title"), 35;
          case 5:
            return this.popState(), "title_value";
          case 6:
            return this.begin("acc_title"), 37;
          case 7:
            return this.popState(), "acc_title_value";
          case 8:
            return this.begin("acc_descr"), 39;
          case 9:
            return this.popState(), "acc_descr_value";
          case 10:
            this.begin("acc_descr_multiline");
            break;
          case 11:
            this.popState();
            break;
          case 12:
            return "acc_descr_multiline_value";
          case 13:
            return 48;
          case 14:
            return 50;
          case 15:
            return 49;
          case 16:
            return 51;
          case 17:
            return 52;
          case 18:
            return 53;
          case 19:
            return 54;
          case 20:
            return 25;
          case 21:
            this.begin("md_string");
            break;
          case 22:
            return "MD_STR";
          case 23:
            this.popState();
            break;
          case 24:
            this.begin("string");
            break;
          case 25:
            this.popState();
            break;
          case 26:
            return "STR";
          case 27:
            this.begin("class_name");
            break;
          case 28:
            return this.popState(), 47;
          case 29:
            return this.begin("point_start"), 44;
          case 30:
            return this.begin("point_x"), 45;
          case 31:
            this.popState();
            break;
          case 32:
            this.popState(), this.begin("point_y");
            break;
          case 33:
            return this.popState(), 46;
          case 34:
            return 28;
          case 35:
            return 4;
          case 36:
            return 11;
          case 37:
            return 64;
          case 38:
            return 10;
          case 39:
            return 65;
          case 40:
            return 65;
          case 41:
            return 14;
          case 42:
            return 13;
          case 43:
            return 67;
          case 44:
            return 66;
          case 45:
            return 12;
          case 46:
            return 8;
          case 47:
            return 5;
          case 48:
            return 18;
          case 49:
            return 56;
          case 50:
            return 63;
          case 51:
            return 57;
        }
      }, "anonymous"),
      rules: [/^(?:%%(?!\{)[^\n]*)/i, /^(?:[^\}]%%[^\n]*)/i, /^(?:[\n\r]+)/i, /^(?:%%[^\n]*)/i, /^(?:title\b)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?: *x-axis *)/i, /^(?: *y-axis *)/i, /^(?: *--+> *)/i, /^(?: *quadrant-1 *)/i, /^(?: *quadrant-2 *)/i, /^(?: *quadrant-3 *)/i, /^(?: *quadrant-4 *)/i, /^(?:classDef\b)/i, /^(?:["][`])/i, /^(?:[^`"]+)/i, /^(?:[`]["])/i, /^(?:["])/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?::::)/i, /^(?:^\w+)/i, /^(?:\s*:\s*\[\s*)/i, /^(?:(1)|(0(.\d+)?))/i, /^(?:\s*\] *)/i, /^(?:\s*,\s*)/i, /^(?:(1)|(0(.\d+)?))/i, /^(?: *quadrantChart *)/i, /^(?:[A-Za-z]+)/i, /^(?::)/i, /^(?:\+)/i, /^(?:,)/i, /^(?:=)/i, /^(?:=)/i, /^(?:\*)/i, /^(?:#)/i, /^(?:[\_])/i, /^(?:\.)/i, /^(?:&)/i, /^(?:-)/i, /^(?:[0-9]+)/i, /^(?:\s)/i, /^(?:;)/i, /^(?:[!"#$%&'*+,-.`?\\_/])/i, /^(?:$)/i],
      conditions: { class_name: { rules: [28], inclusive: !1 }, point_y: { rules: [33], inclusive: !1 }, point_x: { rules: [32], inclusive: !1 }, point_start: { rules: [30, 31], inclusive: !1 }, acc_descr_multiline: { rules: [11, 12], inclusive: !1 }, acc_descr: { rules: [9], inclusive: !1 }, acc_title: { rules: [7], inclusive: !1 }, title: { rules: [5], inclusive: !1 }, md_string: { rules: [22, 23], inclusive: !1 }, string: { rules: [25, 26], inclusive: !1 }, INITIAL: { rules: [0, 1, 2, 3, 4, 6, 8, 10, 13, 14, 15, 16, 17, 18, 19, 20, 21, 24, 27, 29, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51], inclusive: !0 } }
    };
    return At;
  }();
  X.lexer = ft;
  function P() {
    this.yy = {};
  }
  return u(P, "Parser"), P.prototype = X, X.Parser = P, new P();
}();
Zl.parser = Zl;
var FC = Zl, or = _o(), qs, NC = (qs = class {
  constructor() {
    this.classes = /* @__PURE__ */ new Map(), this.config = this.getDefaultConfig(), this.themeConfig = this.getDefaultThemeConfig(), this.data = this.getDefaultData();
  }
  getDefaultData() {
    return {
      titleText: "",
      quadrant1Text: "",
      quadrant2Text: "",
      quadrant3Text: "",
      quadrant4Text: "",
      xAxisLeftText: "",
      xAxisRightText: "",
      yAxisBottomText: "",
      yAxisTopText: "",
      points: []
    };
  }
  getDefaultConfig() {
    var t, r, i, s, a, n, o, h, l, d, p, g, f, y, m, x, b, v;
    return {
      showXAxis: !0,
      showYAxis: !0,
      showTitle: !0,
      chartHeight: ((t = de.quadrantChart) == null ? void 0 : t.chartWidth) || 500,
      chartWidth: ((r = de.quadrantChart) == null ? void 0 : r.chartHeight) || 500,
      titlePadding: ((i = de.quadrantChart) == null ? void 0 : i.titlePadding) || 10,
      titleFontSize: ((s = de.quadrantChart) == null ? void 0 : s.titleFontSize) || 20,
      quadrantPadding: ((a = de.quadrantChart) == null ? void 0 : a.quadrantPadding) || 5,
      xAxisLabelPadding: ((n = de.quadrantChart) == null ? void 0 : n.xAxisLabelPadding) || 5,
      yAxisLabelPadding: ((o = de.quadrantChart) == null ? void 0 : o.yAxisLabelPadding) || 5,
      xAxisLabelFontSize: ((h = de.quadrantChart) == null ? void 0 : h.xAxisLabelFontSize) || 16,
      yAxisLabelFontSize: ((l = de.quadrantChart) == null ? void 0 : l.yAxisLabelFontSize) || 16,
      quadrantLabelFontSize: ((d = de.quadrantChart) == null ? void 0 : d.quadrantLabelFontSize) || 16,
      quadrantTextTopPadding: ((p = de.quadrantChart) == null ? void 0 : p.quadrantTextTopPadding) || 5,
      pointTextPadding: ((g = de.quadrantChart) == null ? void 0 : g.pointTextPadding) || 5,
      pointLabelFontSize: ((f = de.quadrantChart) == null ? void 0 : f.pointLabelFontSize) || 12,
      pointRadius: ((y = de.quadrantChart) == null ? void 0 : y.pointRadius) || 5,
      xAxisPosition: ((m = de.quadrantChart) == null ? void 0 : m.xAxisPosition) || "top",
      yAxisPosition: ((x = de.quadrantChart) == null ? void 0 : x.yAxisPosition) || "left",
      quadrantInternalBorderStrokeWidth: ((b = de.quadrantChart) == null ? void 0 : b.quadrantInternalBorderStrokeWidth) || 1,
      quadrantExternalBorderStrokeWidth: ((v = de.quadrantChart) == null ? void 0 : v.quadrantExternalBorderStrokeWidth) || 2
    };
  }
  getDefaultThemeConfig() {
    return {
      quadrant1Fill: or.quadrant1Fill,
      quadrant2Fill: or.quadrant2Fill,
      quadrant3Fill: or.quadrant3Fill,
      quadrant4Fill: or.quadrant4Fill,
      quadrant1TextFill: or.quadrant1TextFill,
      quadrant2TextFill: or.quadrant2TextFill,
      quadrant3TextFill: or.quadrant3TextFill,
      quadrant4TextFill: or.quadrant4TextFill,
      quadrantPointFill: or.quadrantPointFill,
      quadrantPointTextFill: or.quadrantPointTextFill,
      quadrantXAxisTextFill: or.quadrantXAxisTextFill,
      quadrantYAxisTextFill: or.quadrantYAxisTextFill,
      quadrantTitleFill: or.quadrantTitleFill,
      quadrantInternalBorderStrokeFill: or.quadrantInternalBorderStrokeFill,
      quadrantExternalBorderStrokeFill: or.quadrantExternalBorderStrokeFill
    };
  }
  clear() {
    this.config = this.getDefaultConfig(), this.themeConfig = this.getDefaultThemeConfig(), this.data = this.getDefaultData(), this.classes = /* @__PURE__ */ new Map(), I.info("clear called");
  }
  setData(t) {
    this.data = { ...this.data, ...t };
  }
  addPoints(t) {
    this.data.points = [...t, ...this.data.points];
  }
  addClass(t, r) {
    this.classes.set(t, r);
  }
  setConfig(t) {
    I.trace("setConfig called with: ", t), this.config = { ...this.config, ...t };
  }
  setThemeConfig(t) {
    I.trace("setThemeConfig called with: ", t), this.themeConfig = { ...this.themeConfig, ...t };
  }
  calculateSpace(t, r, i, s) {
    const a = this.config.xAxisLabelPadding * 2 + this.config.xAxisLabelFontSize, n = {
      top: t === "top" && r ? a : 0,
      bottom: t === "bottom" && r ? a : 0
    }, o = this.config.yAxisLabelPadding * 2 + this.config.yAxisLabelFontSize, h = {
      left: this.config.yAxisPosition === "left" && i ? o : 0,
      right: this.config.yAxisPosition === "right" && i ? o : 0
    }, l = this.config.titleFontSize + this.config.titlePadding * 2, d = {
      top: s ? l : 0
    }, p = this.config.quadrantPadding + h.left, g = this.config.quadrantPadding + n.top + d.top, f = this.config.chartWidth - this.config.quadrantPadding * 2 - h.left - h.right, y = this.config.chartHeight - this.config.quadrantPadding * 2 - n.top - n.bottom - d.top, m = f / 2, x = y / 2;
    return {
      xAxisSpace: n,
      yAxisSpace: h,
      titleSpace: d,
      quadrantSpace: {
        quadrantLeft: p,
        quadrantTop: g,
        quadrantWidth: f,
        quadrantHalfWidth: m,
        quadrantHeight: y,
        quadrantHalfHeight: x
      }
    };
  }
  getAxisLabels(t, r, i, s) {
    const { quadrantSpace: a, titleSpace: n } = s, {
      quadrantHalfHeight: o,
      quadrantHeight: h,
      quadrantLeft: l,
      quadrantHalfWidth: d,
      quadrantTop: p,
      quadrantWidth: g
    } = a, f = !!this.data.xAxisRightText, y = !!this.data.yAxisTopText, m = [];
    return this.data.xAxisLeftText && r && m.push({
      text: this.data.xAxisLeftText,
      fill: this.themeConfig.quadrantXAxisTextFill,
      x: l + (f ? d / 2 : 0),
      y: t === "top" ? this.config.xAxisLabelPadding + n.top : this.config.xAxisLabelPadding + p + h + this.config.quadrantPadding,
      fontSize: this.config.xAxisLabelFontSize,
      verticalPos: f ? "center" : "left",
      horizontalPos: "top",
      rotation: 0
    }), this.data.xAxisRightText && r && m.push({
      text: this.data.xAxisRightText,
      fill: this.themeConfig.quadrantXAxisTextFill,
      x: l + d + (f ? d / 2 : 0),
      y: t === "top" ? this.config.xAxisLabelPadding + n.top : this.config.xAxisLabelPadding + p + h + this.config.quadrantPadding,
      fontSize: this.config.xAxisLabelFontSize,
      verticalPos: f ? "center" : "left",
      horizontalPos: "top",
      rotation: 0
    }), this.data.yAxisBottomText && i && m.push({
      text: this.data.yAxisBottomText,
      fill: this.themeConfig.quadrantYAxisTextFill,
      x: this.config.yAxisPosition === "left" ? this.config.yAxisLabelPadding : this.config.yAxisLabelPadding + l + g + this.config.quadrantPadding,
      y: p + h - (y ? o / 2 : 0),
      fontSize: this.config.yAxisLabelFontSize,
      verticalPos: y ? "center" : "left",
      horizontalPos: "top",
      rotation: -90
    }), this.data.yAxisTopText && i && m.push({
      text: this.data.yAxisTopText,
      fill: this.themeConfig.quadrantYAxisTextFill,
      x: this.config.yAxisPosition === "left" ? this.config.yAxisLabelPadding : this.config.yAxisLabelPadding + l + g + this.config.quadrantPadding,
      y: p + o - (y ? o / 2 : 0),
      fontSize: this.config.yAxisLabelFontSize,
      verticalPos: y ? "center" : "left",
      horizontalPos: "top",
      rotation: -90
    }), m;
  }
  getQuadrants(t) {
    const { quadrantSpace: r } = t, { quadrantHalfHeight: i, quadrantLeft: s, quadrantHalfWidth: a, quadrantTop: n } = r, o = [
      {
        text: {
          text: this.data.quadrant1Text,
          fill: this.themeConfig.quadrant1TextFill,
          x: 0,
          y: 0,
          fontSize: this.config.quadrantLabelFontSize,
          verticalPos: "center",
          horizontalPos: "middle",
          rotation: 0
        },
        x: s + a,
        y: n,
        width: a,
        height: i,
        fill: this.themeConfig.quadrant1Fill
      },
      {
        text: {
          text: this.data.quadrant2Text,
          fill: this.themeConfig.quadrant2TextFill,
          x: 0,
          y: 0,
          fontSize: this.config.quadrantLabelFontSize,
          verticalPos: "center",
          horizontalPos: "middle",
          rotation: 0
        },
        x: s,
        y: n,
        width: a,
        height: i,
        fill: this.themeConfig.quadrant2Fill
      },
      {
        text: {
          text: this.data.quadrant3Text,
          fill: this.themeConfig.quadrant3TextFill,
          x: 0,
          y: 0,
          fontSize: this.config.quadrantLabelFontSize,
          verticalPos: "center",
          horizontalPos: "middle",
          rotation: 0
        },
        x: s,
        y: n + i,
        width: a,
        height: i,
        fill: this.themeConfig.quadrant3Fill
      },
      {
        text: {
          text: this.data.quadrant4Text,
          fill: this.themeConfig.quadrant4TextFill,
          x: 0,
          y: 0,
          fontSize: this.config.quadrantLabelFontSize,
          verticalPos: "center",
          horizontalPos: "middle",
          rotation: 0
        },
        x: s + a,
        y: n + i,
        width: a,
        height: i,
        fill: this.themeConfig.quadrant4Fill
      }
    ];
    for (const h of o)
      h.text.x = h.x + h.width / 2, this.data.points.length === 0 ? (h.text.y = h.y + h.height / 2, h.text.horizontalPos = "middle") : (h.text.y = h.y + this.config.quadrantTextTopPadding, h.text.horizontalPos = "top");
    return o;
  }
  getQuadrantPoints(t) {
    const { quadrantSpace: r } = t, { quadrantHeight: i, quadrantLeft: s, quadrantTop: a, quadrantWidth: n } = r, o = Ua().domain([0, 1]).range([s, n + s]), h = Ua().domain([0, 1]).range([i + a, a]);
    return this.data.points.map((d) => {
      const p = this.classes.get(d.className);
      return p && (d = { ...p, ...d }), {
        x: o(d.x),
        y: h(d.y),
        fill: d.color ?? this.themeConfig.quadrantPointFill,
        radius: d.radius ?? this.config.pointRadius,
        text: {
          text: d.text,
          fill: this.themeConfig.quadrantPointTextFill,
          x: o(d.x),
          y: h(d.y) + this.config.pointTextPadding,
          verticalPos: "center",
          horizontalPos: "top",
          fontSize: this.config.pointLabelFontSize,
          rotation: 0
        },
        strokeColor: d.strokeColor ?? this.themeConfig.quadrantPointFill,
        strokeWidth: d.strokeWidth ?? "0px"
      };
    });
  }
  getBorders(t) {
    const r = this.config.quadrantExternalBorderStrokeWidth / 2, { quadrantSpace: i } = t, {
      quadrantHalfHeight: s,
      quadrantHeight: a,
      quadrantLeft: n,
      quadrantHalfWidth: o,
      quadrantTop: h,
      quadrantWidth: l
    } = i;
    return [
      // top border
      {
        strokeFill: this.themeConfig.quadrantExternalBorderStrokeFill,
        strokeWidth: this.config.quadrantExternalBorderStrokeWidth,
        x1: n - r,
        y1: h,
        x2: n + l + r,
        y2: h
      },
      // right border
      {
        strokeFill: this.themeConfig.quadrantExternalBorderStrokeFill,
        strokeWidth: this.config.quadrantExternalBorderStrokeWidth,
        x1: n + l,
        y1: h + r,
        x2: n + l,
        y2: h + a - r
      },
      // bottom border
      {
        strokeFill: this.themeConfig.quadrantExternalBorderStrokeFill,
        strokeWidth: this.config.quadrantExternalBorderStrokeWidth,
        x1: n - r,
        y1: h + a,
        x2: n + l + r,
        y2: h + a
      },
      // left border
      {
        strokeFill: this.themeConfig.quadrantExternalBorderStrokeFill,
        strokeWidth: this.config.quadrantExternalBorderStrokeWidth,
        x1: n,
        y1: h + r,
        x2: n,
        y2: h + a - r
      },
      // vertical inner border
      {
        strokeFill: this.themeConfig.quadrantInternalBorderStrokeFill,
        strokeWidth: this.config.quadrantInternalBorderStrokeWidth,
        x1: n + o,
        y1: h + r,
        x2: n + o,
        y2: h + a - r
      },
      // horizontal inner border
      {
        strokeFill: this.themeConfig.quadrantInternalBorderStrokeFill,
        strokeWidth: this.config.quadrantInternalBorderStrokeWidth,
        x1: n + r,
        y1: h + s,
        x2: n + l - r,
        y2: h + s
      }
    ];
  }
  getTitle(t) {
    if (t)
      return {
        text: this.data.titleText,
        fill: this.themeConfig.quadrantTitleFill,
        fontSize: this.config.titleFontSize,
        horizontalPos: "top",
        verticalPos: "center",
        rotation: 0,
        y: this.config.titlePadding,
        x: this.config.chartWidth / 2
      };
  }
  build() {
    const t = this.config.showXAxis && !!(this.data.xAxisLeftText || this.data.xAxisRightText), r = this.config.showYAxis && !!(this.data.yAxisTopText || this.data.yAxisBottomText), i = this.config.showTitle && !!this.data.titleText, s = this.data.points.length > 0 ? "bottom" : this.config.xAxisPosition, a = this.calculateSpace(s, t, r, i);
    return {
      points: this.getQuadrantPoints(a),
      quadrants: this.getQuadrants(a),
      axisLabels: this.getAxisLabels(s, t, r, a),
      borderLines: this.getBorders(a),
      title: this.getTitle(i)
    };
  }
}, u(qs, "QuadrantBuilder"), qs), Ys, _n = (Ys = class extends Error {
  constructor(t, r, i) {
    super(`value for ${t} ${r} is invalid, please use a valid ${i}`), this.name = "InvalidStyleError";
  }
}, u(Ys, "InvalidStyleError"), Ys);
function Jl(e) {
  return !/^#?([\dA-Fa-f]{6}|[\dA-Fa-f]{3})$/.test(e);
}
u(Jl, "validateHexCode");
function Kf(e) {
  return !/^\d+$/.test(e);
}
u(Kf, "validateNumber");
function Qf(e) {
  return !/^\d+px$/.test(e);
}
u(Qf, "validateSizeInPixels");
var RC = K();
function Jr(e) {
  return ge(e.trim(), RC);
}
u(Jr, "textSanitizer");
var Je = new NC();
function Zf(e) {
  Je.setData({ quadrant1Text: Jr(e.text) });
}
u(Zf, "setQuadrant1Text");
function Jf(e) {
  Je.setData({ quadrant2Text: Jr(e.text) });
}
u(Jf, "setQuadrant2Text");
function t2(e) {
  Je.setData({ quadrant3Text: Jr(e.text) });
}
u(t2, "setQuadrant3Text");
function e2(e) {
  Je.setData({ quadrant4Text: Jr(e.text) });
}
u(e2, "setQuadrant4Text");
function r2(e) {
  Je.setData({ xAxisLeftText: Jr(e.text) });
}
u(r2, "setXAxisLeftText");
function i2(e) {
  Je.setData({ xAxisRightText: Jr(e.text) });
}
u(i2, "setXAxisRightText");
function s2(e) {
  Je.setData({ yAxisTopText: Jr(e.text) });
}
u(s2, "setYAxisTopText");
function a2(e) {
  Je.setData({ yAxisBottomText: Jr(e.text) });
}
u(a2, "setYAxisBottomText");
function zo(e) {
  const t = {};
  for (const r of e) {
    const [i, s] = r.trim().split(/\s*:\s*/);
    if (i === "radius") {
      if (Kf(s))
        throw new _n(i, s, "number");
      t.radius = parseInt(s);
    } else if (i === "color") {
      if (Jl(s))
        throw new _n(i, s, "hex code");
      t.color = s;
    } else if (i === "stroke-color") {
      if (Jl(s))
        throw new _n(i, s, "hex code");
      t.strokeColor = s;
    } else if (i === "stroke-width") {
      if (Qf(s))
        throw new _n(i, s, "number of pixels (eg. 10px)");
      t.strokeWidth = s;
    } else
      throw new Error(`style named ${i} is not supported.`);
  }
  return t;
}
u(zo, "parseStyles");
function n2(e, t, r, i, s) {
  const a = zo(s);
  Je.addPoints([
    {
      x: r,
      y: i,
      text: Jr(e.text),
      className: t,
      ...a
    }
  ]);
}
u(n2, "addPoint");
function o2(e, t) {
  Je.addClass(e, zo(t));
}
u(o2, "addClass");
function l2(e) {
  Je.setConfig({ chartWidth: e });
}
u(l2, "setWidth");
function c2(e) {
  Je.setConfig({ chartHeight: e });
}
u(c2, "setHeight");
function h2() {
  const e = K(), { themeVariables: t, quadrantChart: r } = e;
  return r && Je.setConfig(r), Je.setThemeConfig({
    quadrant1Fill: t.quadrant1Fill,
    quadrant2Fill: t.quadrant2Fill,
    quadrant3Fill: t.quadrant3Fill,
    quadrant4Fill: t.quadrant4Fill,
    quadrant1TextFill: t.quadrant1TextFill,
    quadrant2TextFill: t.quadrant2TextFill,
    quadrant3TextFill: t.quadrant3TextFill,
    quadrant4TextFill: t.quadrant4TextFill,
    quadrantPointFill: t.quadrantPointFill,
    quadrantPointTextFill: t.quadrantPointTextFill,
    quadrantXAxisTextFill: t.quadrantXAxisTextFill,
    quadrantYAxisTextFill: t.quadrantYAxisTextFill,
    quadrantExternalBorderStrokeFill: t.quadrantExternalBorderStrokeFill,
    quadrantInternalBorderStrokeFill: t.quadrantInternalBorderStrokeFill,
    quadrantTitleFill: t.quadrantTitleFill
  }), Je.setData({ titleText: Oe() }), Je.build();
}
u(h2, "getQuadrantData");
var MC = /* @__PURE__ */ u(function() {
  Je.clear(), Me();
}, "clear"), OC = {
  setWidth: l2,
  setHeight: c2,
  setQuadrant1Text: Zf,
  setQuadrant2Text: Jf,
  setQuadrant3Text: t2,
  setQuadrant4Text: e2,
  setXAxisLeftText: r2,
  setXAxisRightText: i2,
  setYAxisTopText: s2,
  setYAxisBottomText: a2,
  parseStyles: zo,
  addPoint: n2,
  addClass: o2,
  getQuadrantData: h2,
  clear: MC,
  setAccTitle: Re,
  getAccTitle: qe,
  setDiagramTitle: Ge,
  getDiagramTitle: Oe,
  getAccDescription: He,
  setAccDescription: Ye
}, PC = /* @__PURE__ */ u((e, t, r, i) => {
  var T, C, E;
  function s(w) {
    return w === "top" ? "hanging" : "middle";
  }
  u(s, "getDominantBaseLine");
  function a(w) {
    return w === "left" ? "start" : "middle";
  }
  u(a, "getTextAnchor");
  function n(w) {
    return `translate(${w.x}, ${w.y}) rotate(${w.rotation || 0})`;
  }
  u(n, "getTransformation");
  const o = K();
  I.debug(`Rendering quadrant chart
` + e);
  const h = o.securityLevel;
  let l;
  h === "sandbox" && (l = yt("#i" + t));
  const p = (h === "sandbox" ? yt(l.nodes()[0].contentDocument.body) : yt("body")).select(`[id="${t}"]`), g = p.append("g").attr("class", "main"), f = ((T = o.quadrantChart) == null ? void 0 : T.chartWidth) ?? 500, y = ((C = o.quadrantChart) == null ? void 0 : C.chartHeight) ?? 500;
  fr(p, y, f, ((E = o.quadrantChart) == null ? void 0 : E.useMaxWidth) ?? !0), p.attr("viewBox", "0 0 " + f + " " + y), i.db.setHeight(y), i.db.setWidth(f);
  const m = i.db.getQuadrantData(), x = g.append("g").attr("class", "quadrants"), b = g.append("g").attr("class", "border"), v = g.append("g").attr("class", "data-points"), _ = g.append("g").attr("class", "labels"), A = g.append("g").attr("class", "title");
  m.title && A.append("text").attr("x", 0).attr("y", 0).attr("fill", m.title.fill).attr("font-size", m.title.fontSize).attr("dominant-baseline", s(m.title.horizontalPos)).attr("text-anchor", a(m.title.verticalPos)).attr("transform", n(m.title)).text(m.title.text), m.borderLines && b.selectAll("line").data(m.borderLines).enter().append("line").attr("x1", (w) => w.x1).attr("y1", (w) => w.y1).attr("x2", (w) => w.x2).attr("y2", (w) => w.y2).style("stroke", (w) => w.strokeFill).style("stroke-width", (w) => w.strokeWidth);
  const S = x.selectAll("g.quadrant").data(m.quadrants).enter().append("g").attr("class", "quadrant");
  S.append("rect").attr("x", (w) => w.x).attr("y", (w) => w.y).attr("width", (w) => w.width).attr("height", (w) => w.height).attr("fill", (w) => w.fill), S.append("text").attr("x", 0).attr("y", 0).attr("fill", (w) => w.text.fill).attr("font-size", (w) => w.text.fontSize).attr(
    "dominant-baseline",
    (w) => s(w.text.horizontalPos)
  ).attr("text-anchor", (w) => a(w.text.verticalPos)).attr("transform", (w) => n(w.text)).text((w) => w.text.text), _.selectAll("g.label").data(m.axisLabels).enter().append("g").attr("class", "label").append("text").attr("x", 0).attr("y", 0).text((w) => w.text).attr("fill", (w) => w.fill).attr("font-size", (w) => w.fontSize).attr("dominant-baseline", (w) => s(w.horizontalPos)).attr("text-anchor", (w) => a(w.verticalPos)).attr("transform", (w) => n(w));
  const L = v.selectAll("g.data-point").data(m.points).enter().append("g").attr("class", "data-point");
  L.append("circle").attr("cx", (w) => w.x).attr("cy", (w) => w.y).attr("r", (w) => w.radius).attr("fill", (w) => w.fill).attr("stroke", (w) => w.strokeColor).attr("stroke-width", (w) => w.strokeWidth), L.append("text").attr("x", 0).attr("y", 0).text((w) => w.text.text).attr("fill", (w) => w.text.fill).attr("font-size", (w) => w.text.fontSize).attr(
    "dominant-baseline",
    (w) => s(w.text.horizontalPos)
  ).attr("text-anchor", (w) => a(w.text.verticalPos)).attr("transform", (w) => n(w.text));
}, "draw"), $C = {
  draw: PC
}, VC = {
  parser: FC,
  db: OC,
  renderer: $C,
  styles: /* @__PURE__ */ u(() => "", "styles")
};
const zC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: VC
}, Symbol.toStringTag, { value: "Module" }));
var tc = function() {
  var e = /* @__PURE__ */ u(function(R, V, $, D) {
    for ($ = $ || {}, D = R.length; D--; $[R[D]] = V) ;
    return $;
  }, "o"), t = [1, 10, 12, 14, 16, 18, 19, 21, 23], r = [2, 6], i = [1, 3], s = [1, 5], a = [1, 6], n = [1, 7], o = [1, 5, 10, 12, 14, 16, 18, 19, 21, 23, 34, 35, 36], h = [1, 25], l = [1, 26], d = [1, 28], p = [1, 29], g = [1, 30], f = [1, 31], y = [1, 32], m = [1, 33], x = [1, 34], b = [1, 35], v = [1, 36], _ = [1, 37], A = [1, 43], S = [1, 42], k = [1, 47], L = [1, 50], T = [1, 10, 12, 14, 16, 18, 19, 21, 23, 34, 35, 36], C = [1, 10, 12, 14, 16, 18, 19, 21, 23, 24, 26, 27, 28, 34, 35, 36], E = [1, 10, 12, 14, 16, 18, 19, 21, 23, 24, 26, 27, 28, 34, 35, 36, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50], w = [1, 64], W = {
    trace: /* @__PURE__ */ u(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, start: 3, eol: 4, XYCHART: 5, chartConfig: 6, document: 7, CHART_ORIENTATION: 8, statement: 9, title: 10, text: 11, X_AXIS: 12, parseXAxis: 13, Y_AXIS: 14, parseYAxis: 15, LINE: 16, plotData: 17, BAR: 18, acc_title: 19, acc_title_value: 20, acc_descr: 21, acc_descr_value: 22, acc_descr_multiline_value: 23, SQUARE_BRACES_START: 24, commaSeparatedNumbers: 25, SQUARE_BRACES_END: 26, NUMBER_WITH_DECIMAL: 27, COMMA: 28, xAxisData: 29, bandData: 30, ARROW_DELIMITER: 31, commaSeparatedTexts: 32, yAxisData: 33, NEWLINE: 34, SEMI: 35, EOF: 36, alphaNum: 37, STR: 38, MD_STR: 39, alphaNumToken: 40, AMP: 41, NUM: 42, ALPHA: 43, PLUS: 44, EQUALS: 45, MULT: 46, DOT: 47, BRKT: 48, MINUS: 49, UNDERSCORE: 50, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 5: "XYCHART", 8: "CHART_ORIENTATION", 10: "title", 12: "X_AXIS", 14: "Y_AXIS", 16: "LINE", 18: "BAR", 19: "acc_title", 20: "acc_title_value", 21: "acc_descr", 22: "acc_descr_value", 23: "acc_descr_multiline_value", 24: "SQUARE_BRACES_START", 26: "SQUARE_BRACES_END", 27: "NUMBER_WITH_DECIMAL", 28: "COMMA", 31: "ARROW_DELIMITER", 34: "NEWLINE", 35: "SEMI", 36: "EOF", 38: "STR", 39: "MD_STR", 41: "AMP", 42: "NUM", 43: "ALPHA", 44: "PLUS", 45: "EQUALS", 46: "MULT", 47: "DOT", 48: "BRKT", 49: "MINUS", 50: "UNDERSCORE" },
    productions_: [0, [3, 2], [3, 3], [3, 2], [3, 1], [6, 1], [7, 0], [7, 2], [9, 2], [9, 2], [9, 2], [9, 2], [9, 2], [9, 3], [9, 2], [9, 3], [9, 2], [9, 2], [9, 1], [17, 3], [25, 3], [25, 1], [13, 1], [13, 2], [13, 1], [29, 1], [29, 3], [30, 3], [32, 3], [32, 1], [15, 1], [15, 2], [15, 1], [33, 3], [4, 1], [4, 1], [4, 1], [11, 1], [11, 1], [11, 1], [37, 1], [37, 2], [40, 1], [40, 1], [40, 1], [40, 1], [40, 1], [40, 1], [40, 1], [40, 1], [40, 1], [40, 1]],
    performAction: /* @__PURE__ */ u(function(V, $, D, O, Y, M, G) {
      var rt = M.length - 1;
      switch (Y) {
        case 5:
          O.setOrientation(M[rt]);
          break;
        case 9:
          O.setDiagramTitle(M[rt].text.trim());
          break;
        case 12:
          O.setLineData({ text: "", type: "text" }, M[rt]);
          break;
        case 13:
          O.setLineData(M[rt - 1], M[rt]);
          break;
        case 14:
          O.setBarData({ text: "", type: "text" }, M[rt]);
          break;
        case 15:
          O.setBarData(M[rt - 1], M[rt]);
          break;
        case 16:
          this.$ = M[rt].trim(), O.setAccTitle(this.$);
          break;
        case 17:
        case 18:
          this.$ = M[rt].trim(), O.setAccDescription(this.$);
          break;
        case 19:
          this.$ = M[rt - 1];
          break;
        case 20:
          this.$ = [Number(M[rt - 2]), ...M[rt]];
          break;
        case 21:
          this.$ = [Number(M[rt])];
          break;
        case 22:
          O.setXAxisTitle(M[rt]);
          break;
        case 23:
          O.setXAxisTitle(M[rt - 1]);
          break;
        case 24:
          O.setXAxisTitle({ type: "text", text: "" });
          break;
        case 25:
          O.setXAxisBand(M[rt]);
          break;
        case 26:
          O.setXAxisRangeData(Number(M[rt - 2]), Number(M[rt]));
          break;
        case 27:
          this.$ = M[rt - 1];
          break;
        case 28:
          this.$ = [M[rt - 2], ...M[rt]];
          break;
        case 29:
          this.$ = [M[rt]];
          break;
        case 30:
          O.setYAxisTitle(M[rt]);
          break;
        case 31:
          O.setYAxisTitle(M[rt - 1]);
          break;
        case 32:
          O.setYAxisTitle({ type: "text", text: "" });
          break;
        case 33:
          O.setYAxisRangeData(Number(M[rt - 2]), Number(M[rt]));
          break;
        case 37:
          this.$ = { text: M[rt], type: "text" };
          break;
        case 38:
          this.$ = { text: M[rt], type: "text" };
          break;
        case 39:
          this.$ = { text: M[rt], type: "markdown" };
          break;
        case 40:
          this.$ = M[rt];
          break;
        case 41:
          this.$ = M[rt - 1] + "" + M[rt];
          break;
      }
    }, "anonymous"),
    table: [e(t, r, { 3: 1, 4: 2, 7: 4, 5: i, 34: s, 35: a, 36: n }), { 1: [3] }, e(t, r, { 4: 2, 7: 4, 3: 8, 5: i, 34: s, 35: a, 36: n }), e(t, r, { 4: 2, 7: 4, 6: 9, 3: 10, 5: i, 8: [1, 11], 34: s, 35: a, 36: n }), { 1: [2, 4], 9: 12, 10: [1, 13], 12: [1, 14], 14: [1, 15], 16: [1, 16], 18: [1, 17], 19: [1, 18], 21: [1, 19], 23: [1, 20] }, e(o, [2, 34]), e(o, [2, 35]), e(o, [2, 36]), { 1: [2, 1] }, e(t, r, { 4: 2, 7: 4, 3: 21, 5: i, 34: s, 35: a, 36: n }), { 1: [2, 3] }, e(o, [2, 5]), e(t, [2, 7], { 4: 22, 34: s, 35: a, 36: n }), { 11: 23, 37: 24, 38: h, 39: l, 40: 27, 41: d, 42: p, 43: g, 44: f, 45: y, 46: m, 47: x, 48: b, 49: v, 50: _ }, { 11: 39, 13: 38, 24: A, 27: S, 29: 40, 30: 41, 37: 24, 38: h, 39: l, 40: 27, 41: d, 42: p, 43: g, 44: f, 45: y, 46: m, 47: x, 48: b, 49: v, 50: _ }, { 11: 45, 15: 44, 27: k, 33: 46, 37: 24, 38: h, 39: l, 40: 27, 41: d, 42: p, 43: g, 44: f, 45: y, 46: m, 47: x, 48: b, 49: v, 50: _ }, { 11: 49, 17: 48, 24: L, 37: 24, 38: h, 39: l, 40: 27, 41: d, 42: p, 43: g, 44: f, 45: y, 46: m, 47: x, 48: b, 49: v, 50: _ }, { 11: 52, 17: 51, 24: L, 37: 24, 38: h, 39: l, 40: 27, 41: d, 42: p, 43: g, 44: f, 45: y, 46: m, 47: x, 48: b, 49: v, 50: _ }, { 20: [1, 53] }, { 22: [1, 54] }, e(T, [2, 18]), { 1: [2, 2] }, e(T, [2, 8]), e(T, [2, 9]), e(C, [2, 37], { 40: 55, 41: d, 42: p, 43: g, 44: f, 45: y, 46: m, 47: x, 48: b, 49: v, 50: _ }), e(C, [2, 38]), e(C, [2, 39]), e(E, [2, 40]), e(E, [2, 42]), e(E, [2, 43]), e(E, [2, 44]), e(E, [2, 45]), e(E, [2, 46]), e(E, [2, 47]), e(E, [2, 48]), e(E, [2, 49]), e(E, [2, 50]), e(E, [2, 51]), e(T, [2, 10]), e(T, [2, 22], { 30: 41, 29: 56, 24: A, 27: S }), e(T, [2, 24]), e(T, [2, 25]), { 31: [1, 57] }, { 11: 59, 32: 58, 37: 24, 38: h, 39: l, 40: 27, 41: d, 42: p, 43: g, 44: f, 45: y, 46: m, 47: x, 48: b, 49: v, 50: _ }, e(T, [2, 11]), e(T, [2, 30], { 33: 60, 27: k }), e(T, [2, 32]), { 31: [1, 61] }, e(T, [2, 12]), { 17: 62, 24: L }, { 25: 63, 27: w }, e(T, [2, 14]), { 17: 65, 24: L }, e(T, [2, 16]), e(T, [2, 17]), e(E, [2, 41]), e(T, [2, 23]), { 27: [1, 66] }, { 26: [1, 67] }, { 26: [2, 29], 28: [1, 68] }, e(T, [2, 31]), { 27: [1, 69] }, e(T, [2, 13]), { 26: [1, 70] }, { 26: [2, 21], 28: [1, 71] }, e(T, [2, 15]), e(T, [2, 26]), e(T, [2, 27]), { 11: 59, 32: 72, 37: 24, 38: h, 39: l, 40: 27, 41: d, 42: p, 43: g, 44: f, 45: y, 46: m, 47: x, 48: b, 49: v, 50: _ }, e(T, [2, 33]), e(T, [2, 19]), { 25: 73, 27: w }, { 26: [2, 28] }, { 26: [2, 20] }],
    defaultActions: { 8: [2, 1], 10: [2, 3], 21: [2, 2], 72: [2, 28], 73: [2, 20] },
    parseError: /* @__PURE__ */ u(function(V, $) {
      if ($.recoverable)
        this.trace(V);
      else {
        var D = new Error(V);
        throw D.hash = $, D;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ u(function(V) {
      var $ = this, D = [0], O = [], Y = [null], M = [], G = this.table, rt = "", ht = 0, Z = 0, ot = 2, it = 1, bt = M.slice.call(arguments, 1), xt = Object.create(this.lexer), Ct = { yy: {} };
      for (var at in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, at) && (Ct.yy[at] = this.yy[at]);
      xt.setInput(V, Ct.yy), Ct.yy.lexer = xt, Ct.yy.parser = this, typeof xt.yylloc > "u" && (xt.yylloc = {});
      var lt = xt.yylloc;
      M.push(lt);
      var Q = xt.options && xt.options.ranges;
      typeof Ct.yy.parseError == "function" ? this.parseError = Ct.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function U(nt) {
        D.length = D.length - 2 * nt, Y.length = Y.length - nt, M.length = M.length - nt;
      }
      u(U, "popStack");
      function et() {
        var nt;
        return nt = O.pop() || xt.lex() || it, typeof nt != "number" && (nt instanceof Array && (O = nt, nt = O.pop()), nt = $.symbols_[nt] || nt), nt;
      }
      u(et, "lex");
      for (var z, Tt, F, te, J = {}, Ut, Wt, ie, dt; ; ) {
        if (Tt = D[D.length - 1], this.defaultActions[Tt] ? F = this.defaultActions[Tt] : ((z === null || typeof z > "u") && (z = et()), F = G[Tt] && G[Tt][z]), typeof F > "u" || !F.length || !F[0]) {
          var wt = "";
          dt = [];
          for (Ut in G[Tt])
            this.terminals_[Ut] && Ut > ot && dt.push("'" + this.terminals_[Ut] + "'");
          xt.showPosition ? wt = "Parse error on line " + (ht + 1) + `:
` + xt.showPosition() + `
Expecting ` + dt.join(", ") + ", got '" + (this.terminals_[z] || z) + "'" : wt = "Parse error on line " + (ht + 1) + ": Unexpected " + (z == it ? "end of input" : "'" + (this.terminals_[z] || z) + "'"), this.parseError(wt, {
            text: xt.match,
            token: this.terminals_[z] || z,
            line: xt.yylineno,
            loc: lt,
            expected: dt
          });
        }
        if (F[0] instanceof Array && F.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + Tt + ", token: " + z);
        switch (F[0]) {
          case 1:
            D.push(z), Y.push(xt.yytext), M.push(xt.yylloc), D.push(F[1]), z = null, Z = xt.yyleng, rt = xt.yytext, ht = xt.yylineno, lt = xt.yylloc;
            break;
          case 2:
            if (Wt = this.productions_[F[1]][1], J.$ = Y[Y.length - Wt], J._$ = {
              first_line: M[M.length - (Wt || 1)].first_line,
              last_line: M[M.length - 1].last_line,
              first_column: M[M.length - (Wt || 1)].first_column,
              last_column: M[M.length - 1].last_column
            }, Q && (J._$.range = [
              M[M.length - (Wt || 1)].range[0],
              M[M.length - 1].range[1]
            ]), te = this.performAction.apply(J, [
              rt,
              Z,
              ht,
              Ct.yy,
              F[1],
              Y,
              M
            ].concat(bt)), typeof te < "u")
              return te;
            Wt && (D = D.slice(0, -1 * Wt * 2), Y = Y.slice(0, -1 * Wt), M = M.slice(0, -1 * Wt)), D.push(this.productions_[F[1]][0]), Y.push(J.$), M.push(J._$), ie = G[D[D.length - 2]][D[D.length - 1]], D.push(ie);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, N = /* @__PURE__ */ function() {
    var R = {
      EOF: 1,
      parseError: /* @__PURE__ */ u(function($, D) {
        if (this.yy.parser)
          this.yy.parser.parseError($, D);
        else
          throw new Error($);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ u(function(V, $) {
        return this.yy = $ || this.yy || {}, this._input = V, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ u(function() {
        var V = this._input[0];
        this.yytext += V, this.yyleng++, this.offset++, this.match += V, this.matched += V;
        var $ = V.match(/(?:\r\n?|\n).*/g);
        return $ ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), V;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ u(function(V) {
        var $ = V.length, D = V.split(/(?:\r\n?|\n)/g);
        this._input = V + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - $), this.offset -= $;
        var O = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), D.length - 1 && (this.yylineno -= D.length - 1);
        var Y = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: D ? (D.length === O.length ? this.yylloc.first_column : 0) + O[O.length - D.length].length - D[0].length : this.yylloc.first_column - $
        }, this.options.ranges && (this.yylloc.range = [Y[0], Y[0] + this.yyleng - $]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ u(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ u(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ u(function(V) {
        this.unput(this.match.slice(V));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ u(function() {
        var V = this.matched.substr(0, this.matched.length - this.match.length);
        return (V.length > 20 ? "..." : "") + V.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ u(function() {
        var V = this.match;
        return V.length < 20 && (V += this._input.substr(0, 20 - V.length)), (V.substr(0, 20) + (V.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ u(function() {
        var V = this.pastInput(), $ = new Array(V.length + 1).join("-");
        return V + this.upcomingInput() + `
` + $ + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ u(function(V, $) {
        var D, O, Y;
        if (this.options.backtrack_lexer && (Y = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (Y.yylloc.range = this.yylloc.range.slice(0))), O = V[0].match(/(?:\r\n?|\n).*/g), O && (this.yylineno += O.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: O ? O[O.length - 1].length - O[O.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + V[0].length
        }, this.yytext += V[0], this.match += V[0], this.matches = V, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(V[0].length), this.matched += V[0], D = this.performAction.call(this, this.yy, this, $, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), D)
          return D;
        if (this._backtrack) {
          for (var M in Y)
            this[M] = Y[M];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ u(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var V, $, D, O;
        this._more || (this.yytext = "", this.match = "");
        for (var Y = this._currentRules(), M = 0; M < Y.length; M++)
          if (D = this._input.match(this.rules[Y[M]]), D && (!$ || D[0].length > $[0].length)) {
            if ($ = D, O = M, this.options.backtrack_lexer) {
              if (V = this.test_match(D, Y[M]), V !== !1)
                return V;
              if (this._backtrack) {
                $ = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return $ ? (V = this.test_match($, Y[O]), V !== !1 ? V : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ u(function() {
        var $ = this.next();
        return $ || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ u(function($) {
        this.conditionStack.push($);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ u(function() {
        var $ = this.conditionStack.length - 1;
        return $ > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ u(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ u(function($) {
        return $ = this.conditionStack.length - 1 - Math.abs($ || 0), $ >= 0 ? this.conditionStack[$] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ u(function($) {
        this.begin($);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ u(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: { "case-insensitive": !0 },
      performAction: /* @__PURE__ */ u(function($, D, O, Y) {
        switch (O) {
          case 0:
            break;
          case 1:
            break;
          case 2:
            return this.popState(), 34;
          case 3:
            return this.popState(), 34;
          case 4:
            return 34;
          case 5:
            break;
          case 6:
            return 10;
          case 7:
            return this.pushState("acc_title"), 19;
          case 8:
            return this.popState(), "acc_title_value";
          case 9:
            return this.pushState("acc_descr"), 21;
          case 10:
            return this.popState(), "acc_descr_value";
          case 11:
            this.pushState("acc_descr_multiline");
            break;
          case 12:
            this.popState();
            break;
          case 13:
            return "acc_descr_multiline_value";
          case 14:
            return 5;
          case 15:
            return 5;
          case 16:
            return 8;
          case 17:
            return this.pushState("axis_data"), "X_AXIS";
          case 18:
            return this.pushState("axis_data"), "Y_AXIS";
          case 19:
            return this.pushState("axis_band_data"), 24;
          case 20:
            return 31;
          case 21:
            return this.pushState("data"), 16;
          case 22:
            return this.pushState("data"), 18;
          case 23:
            return this.pushState("data_inner"), 24;
          case 24:
            return 27;
          case 25:
            return this.popState(), 26;
          case 26:
            this.popState();
            break;
          case 27:
            this.pushState("string");
            break;
          case 28:
            this.popState();
            break;
          case 29:
            return "STR";
          case 30:
            return 24;
          case 31:
            return 26;
          case 32:
            return 43;
          case 33:
            return "COLON";
          case 34:
            return 44;
          case 35:
            return 28;
          case 36:
            return 45;
          case 37:
            return 46;
          case 38:
            return 48;
          case 39:
            return 50;
          case 40:
            return 47;
          case 41:
            return 41;
          case 42:
            return 49;
          case 43:
            return 42;
          case 44:
            break;
          case 45:
            return 35;
          case 46:
            return 36;
        }
      }, "anonymous"),
      rules: [/^(?:%%(?!\{)[^\n]*)/i, /^(?:[^\}]%%[^\n]*)/i, /^(?:(\r?\n))/i, /^(?:(\r?\n))/i, /^(?:[\n\r]+)/i, /^(?:%%[^\n]*)/i, /^(?:title\b)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:\{)/i, /^(?:[^\}]*)/i, /^(?:xychart-beta\b)/i, /^(?:xychart\b)/i, /^(?:(?:vertical|horizontal))/i, /^(?:x-axis\b)/i, /^(?:y-axis\b)/i, /^(?:\[)/i, /^(?:-->)/i, /^(?:line\b)/i, /^(?:bar\b)/i, /^(?:\[)/i, /^(?:[+-]?(?:\d+(?:\.\d+)?|\.\d+))/i, /^(?:\])/i, /^(?:(?:`\)                                    \{ this\.pushState\(md_string\); \}\n<md_string>\(\?:\(\?!`"\)\.\)\+                  \{ return MD_STR; \}\n<md_string>\(\?:`))/i, /^(?:["])/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:\[)/i, /^(?:\])/i, /^(?:[A-Za-z]+)/i, /^(?::)/i, /^(?:\+)/i, /^(?:,)/i, /^(?:=)/i, /^(?:\*)/i, /^(?:#)/i, /^(?:[\_])/i, /^(?:\.)/i, /^(?:&)/i, /^(?:-)/i, /^(?:[0-9]+)/i, /^(?:\s+)/i, /^(?:;)/i, /^(?:$)/i],
      conditions: { data_inner: { rules: [0, 1, 4, 5, 6, 7, 9, 11, 14, 15, 16, 17, 18, 21, 22, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46], inclusive: !0 }, data: { rules: [0, 1, 3, 4, 5, 6, 7, 9, 11, 14, 15, 16, 17, 18, 21, 22, 23, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46], inclusive: !0 }, axis_band_data: { rules: [0, 1, 4, 5, 6, 7, 9, 11, 14, 15, 16, 17, 18, 21, 22, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46], inclusive: !0 }, axis_data: { rules: [0, 1, 2, 4, 5, 6, 7, 9, 11, 14, 15, 16, 17, 18, 19, 20, 21, 22, 24, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46], inclusive: !0 }, acc_descr_multiline: { rules: [12, 13], inclusive: !1 }, acc_descr: { rules: [10], inclusive: !1 }, acc_title: { rules: [8], inclusive: !1 }, title: { rules: [], inclusive: !1 }, md_string: { rules: [], inclusive: !1 }, string: { rules: [28, 29], inclusive: !1 }, INITIAL: { rules: [0, 1, 4, 5, 6, 7, 9, 11, 14, 15, 16, 17, 18, 21, 22, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46], inclusive: !0 } }
    };
    return R;
  }();
  W.lexer = N;
  function B() {
    this.yy = {};
  }
  return u(B, "Parser"), B.prototype = W, W.Parser = B, new B();
}();
tc.parser = tc;
var WC = tc;
function ec(e) {
  return e.type === "bar";
}
u(ec, "isBarPlot");
function vh(e) {
  return e.type === "band";
}
u(vh, "isBandAxisData");
function Ls(e) {
  return e.type === "linear";
}
u(Ls, "isLinearAxisData");
var Hs, u2 = (Hs = class {
  constructor(t) {
    this.parentGroup = t;
  }
  getMaxDimension(t, r) {
    if (!this.parentGroup)
      return {
        width: t.reduce((a, n) => Math.max(n.length, a), 0) * r,
        height: r
      };
    const i = {
      width: 0,
      height: 0
    }, s = this.parentGroup.append("g").attr("visibility", "hidden").attr("font-size", r);
    for (const a of t) {
      const n = q0(s, 1, a), o = n ? n.width : a.length * r, h = n ? n.height : r;
      i.width = Math.max(i.width, o), i.height = Math.max(i.height, h);
    }
    return s.remove(), i;
  }
}, u(Hs, "TextDimensionCalculatorWithFont"), Hs), _u = 0.7, Eu = 0.2, Us, d2 = (Us = class {
  constructor(t, r, i, s) {
    this.axisConfig = t, this.title = r, this.textDimensionCalculator = i, this.axisThemeConfig = s, this.boundingRect = { x: 0, y: 0, width: 0, height: 0 }, this.axisPosition = "left", this.showTitle = !1, this.showLabel = !1, this.showTick = !1, this.showAxisLine = !1, this.outerPadding = 0, this.titleTextHeight = 0, this.labelTextHeight = 0, this.range = [0, 10], this.boundingRect = { x: 0, y: 0, width: 0, height: 0 }, this.axisPosition = "left";
  }
  setRange(t) {
    this.range = t, this.axisPosition === "left" || this.axisPosition === "right" ? this.boundingRect.height = t[1] - t[0] : this.boundingRect.width = t[1] - t[0], this.recalculateScale();
  }
  getRange() {
    return [this.range[0] + this.outerPadding, this.range[1] - this.outerPadding];
  }
  setAxisPosition(t) {
    this.axisPosition = t, this.setRange(this.range);
  }
  getTickDistance() {
    const t = this.getRange();
    return Math.abs(t[0] - t[1]) / this.getTickValues().length;
  }
  getAxisOuterPadding() {
    return this.outerPadding;
  }
  getLabelDimension() {
    return this.textDimensionCalculator.getMaxDimension(
      this.getTickValues().map((t) => t.toString()),
      this.axisConfig.labelFontSize
    );
  }
  recalculateOuterPaddingToDrawBar() {
    _u * this.getTickDistance() > this.outerPadding * 2 && (this.outerPadding = Math.floor(_u * this.getTickDistance() / 2)), this.recalculateScale();
  }
  calculateSpaceIfDrawnHorizontally(t) {
    let r = t.height;
    if (this.axisConfig.showAxisLine && r > this.axisConfig.axisLineWidth && (r -= this.axisConfig.axisLineWidth, this.showAxisLine = !0), this.axisConfig.showLabel) {
      const i = this.getLabelDimension(), s = Eu * t.width;
      this.outerPadding = Math.min(i.width / 2, s);
      const a = i.height + this.axisConfig.labelPadding * 2;
      this.labelTextHeight = i.height, a <= r && (r -= a, this.showLabel = !0);
    }
    if (this.axisConfig.showTick && r >= this.axisConfig.tickLength && (this.showTick = !0, r -= this.axisConfig.tickLength), this.axisConfig.showTitle && this.title) {
      const i = this.textDimensionCalculator.getMaxDimension(
        [this.title],
        this.axisConfig.titleFontSize
      ), s = i.height + this.axisConfig.titlePadding * 2;
      this.titleTextHeight = i.height, s <= r && (r -= s, this.showTitle = !0);
    }
    this.boundingRect.width = t.width, this.boundingRect.height = t.height - r;
  }
  calculateSpaceIfDrawnVertical(t) {
    let r = t.width;
    if (this.axisConfig.showAxisLine && r > this.axisConfig.axisLineWidth && (r -= this.axisConfig.axisLineWidth, this.showAxisLine = !0), this.axisConfig.showLabel) {
      const i = this.getLabelDimension(), s = Eu * t.height;
      this.outerPadding = Math.min(i.height / 2, s);
      const a = i.width + this.axisConfig.labelPadding * 2;
      a <= r && (r -= a, this.showLabel = !0);
    }
    if (this.axisConfig.showTick && r >= this.axisConfig.tickLength && (this.showTick = !0, r -= this.axisConfig.tickLength), this.axisConfig.showTitle && this.title) {
      const i = this.textDimensionCalculator.getMaxDimension(
        [this.title],
        this.axisConfig.titleFontSize
      ), s = i.height + this.axisConfig.titlePadding * 2;
      this.titleTextHeight = i.height, s <= r && (r -= s, this.showTitle = !0);
    }
    this.boundingRect.width = t.width - r, this.boundingRect.height = t.height;
  }
  calculateSpace(t) {
    return this.axisPosition === "left" || this.axisPosition === "right" ? this.calculateSpaceIfDrawnVertical(t) : this.calculateSpaceIfDrawnHorizontally(t), this.recalculateScale(), {
      width: this.boundingRect.width,
      height: this.boundingRect.height
    };
  }
  setBoundingBoxXY(t) {
    this.boundingRect.x = t.x, this.boundingRect.y = t.y;
  }
  getDrawableElementsForLeftAxis() {
    const t = [];
    if (this.showAxisLine) {
      const r = this.boundingRect.x + this.boundingRect.width - this.axisConfig.axisLineWidth / 2;
      t.push({
        type: "path",
        groupTexts: ["left-axis", "axisl-line"],
        data: [
          {
            path: `M ${r},${this.boundingRect.y} L ${r},${this.boundingRect.y + this.boundingRect.height} `,
            strokeFill: this.axisThemeConfig.axisLineColor,
            strokeWidth: this.axisConfig.axisLineWidth
          }
        ]
      });
    }
    if (this.showLabel && t.push({
      type: "text",
      groupTexts: ["left-axis", "label"],
      data: this.getTickValues().map((r) => ({
        text: r.toString(),
        x: this.boundingRect.x + this.boundingRect.width - (this.showLabel ? this.axisConfig.labelPadding : 0) - (this.showTick ? this.axisConfig.tickLength : 0) - (this.showAxisLine ? this.axisConfig.axisLineWidth : 0),
        y: this.getScaleValue(r),
        fill: this.axisThemeConfig.labelColor,
        fontSize: this.axisConfig.labelFontSize,
        rotation: 0,
        verticalPos: "middle",
        horizontalPos: "right"
      }))
    }), this.showTick) {
      const r = this.boundingRect.x + this.boundingRect.width - (this.showAxisLine ? this.axisConfig.axisLineWidth : 0);
      t.push({
        type: "path",
        groupTexts: ["left-axis", "ticks"],
        data: this.getTickValues().map((i) => ({
          path: `M ${r},${this.getScaleValue(i)} L ${r - this.axisConfig.tickLength},${this.getScaleValue(i)}`,
          strokeFill: this.axisThemeConfig.tickColor,
          strokeWidth: this.axisConfig.tickWidth
        }))
      });
    }
    return this.showTitle && t.push({
      type: "text",
      groupTexts: ["left-axis", "title"],
      data: [
        {
          text: this.title,
          x: this.boundingRect.x + this.axisConfig.titlePadding,
          y: this.boundingRect.y + this.boundingRect.height / 2,
          fill: this.axisThemeConfig.titleColor,
          fontSize: this.axisConfig.titleFontSize,
          rotation: 270,
          verticalPos: "top",
          horizontalPos: "center"
        }
      ]
    }), t;
  }
  getDrawableElementsForBottomAxis() {
    const t = [];
    if (this.showAxisLine) {
      const r = this.boundingRect.y + this.axisConfig.axisLineWidth / 2;
      t.push({
        type: "path",
        groupTexts: ["bottom-axis", "axis-line"],
        data: [
          {
            path: `M ${this.boundingRect.x},${r} L ${this.boundingRect.x + this.boundingRect.width},${r}`,
            strokeFill: this.axisThemeConfig.axisLineColor,
            strokeWidth: this.axisConfig.axisLineWidth
          }
        ]
      });
    }
    if (this.showLabel && t.push({
      type: "text",
      groupTexts: ["bottom-axis", "label"],
      data: this.getTickValues().map((r) => ({
        text: r.toString(),
        x: this.getScaleValue(r),
        y: this.boundingRect.y + this.axisConfig.labelPadding + (this.showTick ? this.axisConfig.tickLength : 0) + (this.showAxisLine ? this.axisConfig.axisLineWidth : 0),
        fill: this.axisThemeConfig.labelColor,
        fontSize: this.axisConfig.labelFontSize,
        rotation: 0,
        verticalPos: "top",
        horizontalPos: "center"
      }))
    }), this.showTick) {
      const r = this.boundingRect.y + (this.showAxisLine ? this.axisConfig.axisLineWidth : 0);
      t.push({
        type: "path",
        groupTexts: ["bottom-axis", "ticks"],
        data: this.getTickValues().map((i) => ({
          path: `M ${this.getScaleValue(i)},${r} L ${this.getScaleValue(i)},${r + this.axisConfig.tickLength}`,
          strokeFill: this.axisThemeConfig.tickColor,
          strokeWidth: this.axisConfig.tickWidth
        }))
      });
    }
    return this.showTitle && t.push({
      type: "text",
      groupTexts: ["bottom-axis", "title"],
      data: [
        {
          text: this.title,
          x: this.range[0] + (this.range[1] - this.range[0]) / 2,
          y: this.boundingRect.y + this.boundingRect.height - this.axisConfig.titlePadding - this.titleTextHeight,
          fill: this.axisThemeConfig.titleColor,
          fontSize: this.axisConfig.titleFontSize,
          rotation: 0,
          verticalPos: "top",
          horizontalPos: "center"
        }
      ]
    }), t;
  }
  getDrawableElementsForTopAxis() {
    const t = [];
    if (this.showAxisLine) {
      const r = this.boundingRect.y + this.boundingRect.height - this.axisConfig.axisLineWidth / 2;
      t.push({
        type: "path",
        groupTexts: ["top-axis", "axis-line"],
        data: [
          {
            path: `M ${this.boundingRect.x},${r} L ${this.boundingRect.x + this.boundingRect.width},${r}`,
            strokeFill: this.axisThemeConfig.axisLineColor,
            strokeWidth: this.axisConfig.axisLineWidth
          }
        ]
      });
    }
    if (this.showLabel && t.push({
      type: "text",
      groupTexts: ["top-axis", "label"],
      data: this.getTickValues().map((r) => ({
        text: r.toString(),
        x: this.getScaleValue(r),
        y: this.boundingRect.y + (this.showTitle ? this.titleTextHeight + this.axisConfig.titlePadding * 2 : 0) + this.axisConfig.labelPadding,
        fill: this.axisThemeConfig.labelColor,
        fontSize: this.axisConfig.labelFontSize,
        rotation: 0,
        verticalPos: "top",
        horizontalPos: "center"
      }))
    }), this.showTick) {
      const r = this.boundingRect.y;
      t.push({
        type: "path",
        groupTexts: ["top-axis", "ticks"],
        data: this.getTickValues().map((i) => ({
          path: `M ${this.getScaleValue(i)},${r + this.boundingRect.height - (this.showAxisLine ? this.axisConfig.axisLineWidth : 0)} L ${this.getScaleValue(i)},${r + this.boundingRect.height - this.axisConfig.tickLength - (this.showAxisLine ? this.axisConfig.axisLineWidth : 0)}`,
          strokeFill: this.axisThemeConfig.tickColor,
          strokeWidth: this.axisConfig.tickWidth
        }))
      });
    }
    return this.showTitle && t.push({
      type: "text",
      groupTexts: ["top-axis", "title"],
      data: [
        {
          text: this.title,
          x: this.boundingRect.x + this.boundingRect.width / 2,
          y: this.boundingRect.y + this.axisConfig.titlePadding,
          fill: this.axisThemeConfig.titleColor,
          fontSize: this.axisConfig.titleFontSize,
          rotation: 0,
          verticalPos: "top",
          horizontalPos: "center"
        }
      ]
    }), t;
  }
  getDrawableElements() {
    if (this.axisPosition === "left")
      return this.getDrawableElementsForLeftAxis();
    if (this.axisPosition === "right")
      throw Error("Drawing of right axis is not implemented");
    return this.axisPosition === "bottom" ? this.getDrawableElementsForBottomAxis() : this.axisPosition === "top" ? this.getDrawableElementsForTopAxis() : [];
  }
}, u(Us, "BaseAxis"), Us), js, qC = (js = class extends d2 {
  constructor(t, r, i, s, a) {
    super(t, s, a, r), this.categories = i, this.scale = ru().domain(this.categories).range(this.getRange());
  }
  setRange(t) {
    super.setRange(t);
  }
  recalculateScale() {
    this.scale = ru().domain(this.categories).range(this.getRange()).paddingInner(1).paddingOuter(0).align(0.5), I.trace("BandAxis axis final categories, range: ", this.categories, this.getRange());
  }
  getTickValues() {
    return this.categories;
  }
  getScaleValue(t) {
    return this.scale(t) ?? this.getRange()[0];
  }
}, u(js, "BandAxis"), js), Gs, YC = (Gs = class extends d2 {
  constructor(t, r, i, s, a) {
    super(t, s, a, r), this.domain = i, this.scale = Ua().domain(this.domain).range(this.getRange());
  }
  getTickValues() {
    return this.scale.ticks();
  }
  recalculateScale() {
    const t = [...this.domain];
    this.axisPosition === "left" && t.reverse(), this.scale = Ua().domain(t).range(this.getRange());
  }
  getScaleValue(t) {
    return this.scale(t);
  }
}, u(Gs, "LinearAxis"), Gs);
function rc(e, t, r, i) {
  const s = new u2(i);
  return vh(e) ? new qC(
    t,
    r,
    e.categories,
    e.title,
    s
  ) : new YC(
    t,
    r,
    [e.min, e.max],
    e.title,
    s
  );
}
u(rc, "getAxis");
var Xs, HC = (Xs = class {
  constructor(t, r, i, s) {
    this.textDimensionCalculator = t, this.chartConfig = r, this.chartData = i, this.chartThemeConfig = s, this.boundingRect = {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    }, this.showChartTitle = !1;
  }
  setBoundingBoxXY(t) {
    this.boundingRect.x = t.x, this.boundingRect.y = t.y;
  }
  calculateSpace(t) {
    const r = this.textDimensionCalculator.getMaxDimension(
      [this.chartData.title],
      this.chartConfig.titleFontSize
    ), i = Math.max(r.width, t.width), s = r.height + 2 * this.chartConfig.titlePadding;
    return r.width <= i && r.height <= s && this.chartConfig.showTitle && this.chartData.title && (this.boundingRect.width = i, this.boundingRect.height = s, this.showChartTitle = !0), {
      width: this.boundingRect.width,
      height: this.boundingRect.height
    };
  }
  getDrawableElements() {
    const t = [];
    return this.showChartTitle && t.push({
      groupTexts: ["chart-title"],
      type: "text",
      data: [
        {
          fontSize: this.chartConfig.titleFontSize,
          text: this.chartData.title,
          verticalPos: "middle",
          horizontalPos: "center",
          x: this.boundingRect.x + this.boundingRect.width / 2,
          y: this.boundingRect.y + this.boundingRect.height / 2,
          fill: this.chartThemeConfig.titleColor,
          rotation: 0
        }
      ]
    }), t;
  }
}, u(Xs, "ChartTitle"), Xs);
function p2(e, t, r, i) {
  const s = new u2(i);
  return new HC(s, e, t, r);
}
u(p2, "getChartTitleComponent");
var Ks, UC = (Ks = class {
  constructor(t, r, i, s, a) {
    this.plotData = t, this.xAxis = r, this.yAxis = i, this.orientation = s, this.plotIndex = a;
  }
  getDrawableElement() {
    const t = this.plotData.data.map((i) => [
      this.xAxis.getScaleValue(i[0]),
      this.yAxis.getScaleValue(i[1])
    ]);
    let r;
    return this.orientation === "horizontal" ? r = Ha().y((i) => i[0]).x((i) => i[1])(t) : r = Ha().x((i) => i[0]).y((i) => i[1])(t), r ? [
      {
        groupTexts: ["plot", `line-plot-${this.plotIndex}`],
        type: "path",
        data: [
          {
            path: r,
            strokeFill: this.plotData.strokeFill,
            strokeWidth: this.plotData.strokeWidth
          }
        ]
      }
    ] : [];
  }
}, u(Ks, "LinePlot"), Ks), Qs, jC = (Qs = class {
  constructor(t, r, i, s, a, n) {
    this.barData = t, this.boundingRect = r, this.xAxis = i, this.yAxis = s, this.orientation = a, this.plotIndex = n;
  }
  getDrawableElement() {
    const t = this.barData.data.map((a) => [
      this.xAxis.getScaleValue(a[0]),
      this.yAxis.getScaleValue(a[1])
    ]), i = Math.min(this.xAxis.getAxisOuterPadding() * 2, this.xAxis.getTickDistance()) * (1 - 0.05), s = i / 2;
    return this.orientation === "horizontal" ? [
      {
        groupTexts: ["plot", `bar-plot-${this.plotIndex}`],
        type: "rect",
        data: t.map((a) => ({
          x: this.boundingRect.x,
          y: a[0] - s,
          height: i,
          width: a[1] - this.boundingRect.x,
          fill: this.barData.fill,
          strokeWidth: 0,
          strokeFill: this.barData.fill
        }))
      }
    ] : [
      {
        groupTexts: ["plot", `bar-plot-${this.plotIndex}`],
        type: "rect",
        data: t.map((a) => ({
          x: a[0] - s,
          y: a[1],
          width: i,
          height: this.boundingRect.y + this.boundingRect.height - a[1],
          fill: this.barData.fill,
          strokeWidth: 0,
          strokeFill: this.barData.fill
        }))
      }
    ];
  }
}, u(Qs, "BarPlot"), Qs), Zs, GC = (Zs = class {
  constructor(t, r, i) {
    this.chartConfig = t, this.chartData = r, this.chartThemeConfig = i, this.boundingRect = {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
  }
  setAxes(t, r) {
    this.xAxis = t, this.yAxis = r;
  }
  setBoundingBoxXY(t) {
    this.boundingRect.x = t.x, this.boundingRect.y = t.y;
  }
  calculateSpace(t) {
    return this.boundingRect.width = t.width, this.boundingRect.height = t.height, {
      width: this.boundingRect.width,
      height: this.boundingRect.height
    };
  }
  getDrawableElements() {
    if (!(this.xAxis && this.yAxis))
      throw Error("Axes must be passed to render Plots");
    const t = [];
    for (const [r, i] of this.chartData.plots.entries())
      switch (i.type) {
        case "line":
          {
            const s = new UC(
              i,
              this.xAxis,
              this.yAxis,
              this.chartConfig.chartOrientation,
              r
            );
            t.push(...s.getDrawableElement());
          }
          break;
        case "bar":
          {
            const s = new jC(
              i,
              this.boundingRect,
              this.xAxis,
              this.yAxis,
              this.chartConfig.chartOrientation,
              r
            );
            t.push(...s.getDrawableElement());
          }
          break;
      }
    return t;
  }
}, u(Zs, "BasePlot"), Zs);
function g2(e, t, r) {
  return new GC(e, t, r);
}
u(g2, "getPlotComponent");
var Js, XC = (Js = class {
  constructor(t, r, i, s) {
    this.chartConfig = t, this.chartData = r, this.componentStore = {
      title: p2(t, r, i, s),
      plot: g2(t, r, i),
      xAxis: rc(
        r.xAxis,
        t.xAxis,
        {
          titleColor: i.xAxisTitleColor,
          labelColor: i.xAxisLabelColor,
          tickColor: i.xAxisTickColor,
          axisLineColor: i.xAxisLineColor
        },
        s
      ),
      yAxis: rc(
        r.yAxis,
        t.yAxis,
        {
          titleColor: i.yAxisTitleColor,
          labelColor: i.yAxisLabelColor,
          tickColor: i.yAxisTickColor,
          axisLineColor: i.yAxisLineColor
        },
        s
      )
    };
  }
  calculateVerticalSpace() {
    let t = this.chartConfig.width, r = this.chartConfig.height, i = 0, s = 0, a = Math.floor(t * this.chartConfig.plotReservedSpacePercent / 100), n = Math.floor(
      r * this.chartConfig.plotReservedSpacePercent / 100
    ), o = this.componentStore.plot.calculateSpace({
      width: a,
      height: n
    });
    t -= o.width, r -= o.height, o = this.componentStore.title.calculateSpace({
      width: this.chartConfig.width,
      height: r
    }), s = o.height, r -= o.height, this.componentStore.xAxis.setAxisPosition("bottom"), o = this.componentStore.xAxis.calculateSpace({
      width: t,
      height: r
    }), r -= o.height, this.componentStore.yAxis.setAxisPosition("left"), o = this.componentStore.yAxis.calculateSpace({
      width: t,
      height: r
    }), i = o.width, t -= o.width, t > 0 && (a += t, t = 0), r > 0 && (n += r, r = 0), this.componentStore.plot.calculateSpace({
      width: a,
      height: n
    }), this.componentStore.plot.setBoundingBoxXY({ x: i, y: s }), this.componentStore.xAxis.setRange([i, i + a]), this.componentStore.xAxis.setBoundingBoxXY({ x: i, y: s + n }), this.componentStore.yAxis.setRange([s, s + n]), this.componentStore.yAxis.setBoundingBoxXY({ x: 0, y: s }), this.chartData.plots.some((h) => ec(h)) && this.componentStore.xAxis.recalculateOuterPaddingToDrawBar();
  }
  calculateHorizontalSpace() {
    let t = this.chartConfig.width, r = this.chartConfig.height, i = 0, s = 0, a = 0, n = Math.floor(t * this.chartConfig.plotReservedSpacePercent / 100), o = Math.floor(
      r * this.chartConfig.plotReservedSpacePercent / 100
    ), h = this.componentStore.plot.calculateSpace({
      width: n,
      height: o
    });
    t -= h.width, r -= h.height, h = this.componentStore.title.calculateSpace({
      width: this.chartConfig.width,
      height: r
    }), i = h.height, r -= h.height, this.componentStore.xAxis.setAxisPosition("left"), h = this.componentStore.xAxis.calculateSpace({
      width: t,
      height: r
    }), t -= h.width, s = h.width, this.componentStore.yAxis.setAxisPosition("top"), h = this.componentStore.yAxis.calculateSpace({
      width: t,
      height: r
    }), r -= h.height, a = i + h.height, t > 0 && (n += t, t = 0), r > 0 && (o += r, r = 0), this.componentStore.plot.calculateSpace({
      width: n,
      height: o
    }), this.componentStore.plot.setBoundingBoxXY({ x: s, y: a }), this.componentStore.yAxis.setRange([s, s + n]), this.componentStore.yAxis.setBoundingBoxXY({ x: s, y: i }), this.componentStore.xAxis.setRange([a, a + o]), this.componentStore.xAxis.setBoundingBoxXY({ x: 0, y: a }), this.chartData.plots.some((l) => ec(l)) && this.componentStore.xAxis.recalculateOuterPaddingToDrawBar();
  }
  calculateSpace() {
    this.chartConfig.chartOrientation === "horizontal" ? this.calculateHorizontalSpace() : this.calculateVerticalSpace();
  }
  getDrawableElement() {
    this.calculateSpace();
    const t = [];
    this.componentStore.plot.setAxes(this.componentStore.xAxis, this.componentStore.yAxis);
    for (const r of Object.values(this.componentStore))
      t.push(...r.getDrawableElements());
    return t;
  }
}, u(Js, "Orchestrator"), Js), ta, KC = (ta = class {
  static build(t, r, i, s) {
    return new XC(t, r, i, s).getDrawableElement();
  }
}, u(ta, "XYChartBuilder"), ta), en = 0, f2, rn = wh(), sn = Ch(), xe = Th(), ic = sn.plotColorPalette.split(",").map((e) => e.trim()), Wo = !1, Sh = !1;
function Ch() {
  const e = _o(), t = fe();
  return gr(e.xyChart, t.themeVariables.xyChart);
}
u(Ch, "getChartDefaultThemeConfig");
function wh() {
  const e = fe();
  return gr(
    de.xyChart,
    e.xyChart
  );
}
u(wh, "getChartDefaultConfig");
function Th() {
  return {
    yAxis: {
      type: "linear",
      title: "",
      min: 1 / 0,
      max: -1 / 0
    },
    xAxis: {
      type: "band",
      title: "",
      categories: []
    },
    title: "",
    plots: []
  };
}
u(Th, "getChartDefaultData");
function qo(e) {
  const t = fe();
  return ge(e.trim(), t);
}
u(qo, "textSanitizer");
function y2(e) {
  f2 = e;
}
u(y2, "setTmpSVGG");
function m2(e) {
  e === "horizontal" ? rn.chartOrientation = "horizontal" : rn.chartOrientation = "vertical";
}
u(m2, "setOrientation");
function x2(e) {
  xe.xAxis.title = qo(e.text);
}
u(x2, "setXAxisTitle");
function _h(e, t) {
  xe.xAxis = { type: "linear", title: xe.xAxis.title, min: e, max: t }, Wo = !0;
}
u(_h, "setXAxisRangeData");
function b2(e) {
  xe.xAxis = {
    type: "band",
    title: xe.xAxis.title,
    categories: e.map((t) => qo(t.text))
  }, Wo = !0;
}
u(b2, "setXAxisBand");
function k2(e) {
  xe.yAxis.title = qo(e.text);
}
u(k2, "setYAxisTitle");
function v2(e, t) {
  xe.yAxis = { type: "linear", title: xe.yAxis.title, min: e, max: t }, Sh = !0;
}
u(v2, "setYAxisRangeData");
function S2(e) {
  const t = Math.min(...e), r = Math.max(...e), i = Ls(xe.yAxis) ? xe.yAxis.min : 1 / 0, s = Ls(xe.yAxis) ? xe.yAxis.max : -1 / 0;
  xe.yAxis = {
    type: "linear",
    title: xe.yAxis.title,
    min: Math.min(i, t),
    max: Math.max(s, r)
  };
}
u(S2, "setYAxisRangeFromPlotData");
function Eh(e) {
  let t = [];
  if (e.length === 0)
    return t;
  if (!Wo) {
    const r = Ls(xe.xAxis) ? xe.xAxis.min : 1 / 0, i = Ls(xe.xAxis) ? xe.xAxis.max : -1 / 0;
    _h(Math.min(r, 1), Math.max(i, e.length));
  }
  if (Sh || S2(e), vh(xe.xAxis) && (t = xe.xAxis.categories.map((r, i) => [r, e[i]])), Ls(xe.xAxis)) {
    const r = xe.xAxis.min, i = xe.xAxis.max, s = (i - r) / (e.length - 1), a = [];
    for (let n = r; n <= i; n += s)
      a.push(`${n}`);
    t = a.map((n, o) => [n, e[o]]);
  }
  return t;
}
u(Eh, "transformDataWithoutCategory");
function Ah(e) {
  return ic[e === 0 ? 0 : e % ic.length];
}
u(Ah, "getPlotColorFromPalette");
function C2(e, t) {
  const r = Eh(t);
  xe.plots.push({
    type: "line",
    strokeFill: Ah(en),
    strokeWidth: 2,
    data: r
  }), en++;
}
u(C2, "setLineData");
function w2(e, t) {
  const r = Eh(t);
  xe.plots.push({
    type: "bar",
    fill: Ah(en),
    data: r
  }), en++;
}
u(w2, "setBarData");
function T2() {
  if (xe.plots.length === 0)
    throw Error("No Plot to render, please provide a plot with some data");
  return xe.title = Oe(), KC.build(rn, xe, sn, f2);
}
u(T2, "getDrawableElem");
function _2() {
  return sn;
}
u(_2, "getChartThemeConfig");
function E2() {
  return rn;
}
u(E2, "getChartConfig");
function A2() {
  return xe;
}
u(A2, "getXYChartData");
var QC = /* @__PURE__ */ u(function() {
  Me(), en = 0, rn = wh(), xe = Th(), sn = Ch(), ic = sn.plotColorPalette.split(",").map((e) => e.trim()), Wo = !1, Sh = !1;
}, "clear"), ZC = {
  getDrawableElem: T2,
  clear: QC,
  setAccTitle: Re,
  getAccTitle: qe,
  setDiagramTitle: Ge,
  getDiagramTitle: Oe,
  getAccDescription: He,
  setAccDescription: Ye,
  setOrientation: m2,
  setXAxisTitle: x2,
  setXAxisRangeData: _h,
  setXAxisBand: b2,
  setYAxisTitle: k2,
  setYAxisRangeData: v2,
  setLineData: C2,
  setBarData: w2,
  setTmpSVGG: y2,
  getChartThemeConfig: _2,
  getChartConfig: E2,
  getXYChartData: A2
}, JC = /* @__PURE__ */ u((e, t, r, i) => {
  const s = i.db, a = s.getChartThemeConfig(), n = s.getChartConfig(), o = s.getXYChartData().plots[0].data.map((b) => b[1]);
  function h(b) {
    return b === "top" ? "text-before-edge" : "middle";
  }
  u(h, "getDominantBaseLine");
  function l(b) {
    return b === "left" ? "start" : b === "right" ? "end" : "middle";
  }
  u(l, "getTextAnchor");
  function d(b) {
    return `translate(${b.x}, ${b.y}) rotate(${b.rotation || 0})`;
  }
  u(d, "getTextTransformation"), I.debug(`Rendering xychart chart
` + e);
  const p = xi(t), g = p.append("g").attr("class", "main"), f = g.append("rect").attr("width", n.width).attr("height", n.height).attr("class", "background");
  fr(p, n.height, n.width, !0), p.attr("viewBox", `0 0 ${n.width} ${n.height}`), f.attr("fill", a.backgroundColor), s.setTmpSVGG(p.append("g").attr("class", "mermaid-tmp-group"));
  const y = s.getDrawableElem(), m = {};
  function x(b) {
    let v = g, _ = "";
    for (const [A] of b.entries()) {
      let S = g;
      A > 0 && m[_] && (S = m[_]), _ += b[A], v = m[_], v || (v = m[_] = S.append("g").attr("class", b[A]));
    }
    return v;
  }
  u(x, "getGroup");
  for (const b of y) {
    if (b.data.length === 0)
      continue;
    const v = x(b.groupTexts);
    switch (b.type) {
      case "rect":
        if (v.selectAll("rect").data(b.data).enter().append("rect").attr("x", (_) => _.x).attr("y", (_) => _.y).attr("width", (_) => _.width).attr("height", (_) => _.height).attr("fill", (_) => _.fill).attr("stroke", (_) => _.strokeFill).attr("stroke-width", (_) => _.strokeWidth), n.showDataLabel)
          if (n.chartOrientation === "horizontal") {
            let _ = function(T, C) {
              const { data: E, label: w } = T;
              return C * w.length * A <= E.width - 10;
            };
            u(_, "fitsHorizontally");
            const A = 0.7, S = b.data.map((T, C) => ({ data: T, label: o[C].toString() })).filter((T) => T.data.width > 0 && T.data.height > 0), k = S.map((T) => {
              const { data: C } = T;
              let E = C.height * 0.7;
              for (; !_(T, E) && E > 0; )
                E -= 1;
              return E;
            }), L = Math.floor(Math.min(...k));
            v.selectAll("text").data(S).enter().append("text").attr("x", (T) => T.data.x + T.data.width - 10).attr("y", (T) => T.data.y + T.data.height / 2).attr("text-anchor", "end").attr("dominant-baseline", "middle").attr("fill", "black").attr("font-size", `${L}px`).text((T) => T.label);
          } else {
            let _ = function(T, C, E) {
              const { data: w, label: W } = T, B = C * W.length * 0.7, R = w.x + w.width / 2, V = R - B / 2, $ = R + B / 2, D = V >= w.x && $ <= w.x + w.width, O = w.y + E + C <= w.y + w.height;
              return D && O;
            };
            u(_, "fitsInBar");
            const A = 10, S = b.data.map((T, C) => ({ data: T, label: o[C].toString() })).filter((T) => T.data.width > 0 && T.data.height > 0), k = S.map((T) => {
              const { data: C, label: E } = T;
              let w = C.width / (E.length * 0.7);
              for (; !_(T, w, A) && w > 0; )
                w -= 1;
              return w;
            }), L = Math.floor(Math.min(...k));
            v.selectAll("text").data(S).enter().append("text").attr("x", (T) => T.data.x + T.data.width / 2).attr("y", (T) => T.data.y + A).attr("text-anchor", "middle").attr("dominant-baseline", "hanging").attr("fill", "black").attr("font-size", `${L}px`).text((T) => T.label);
          }
        break;
      case "text":
        v.selectAll("text").data(b.data).enter().append("text").attr("x", 0).attr("y", 0).attr("fill", (_) => _.fill).attr("font-size", (_) => _.fontSize).attr("dominant-baseline", (_) => h(_.verticalPos)).attr("text-anchor", (_) => l(_.horizontalPos)).attr("transform", (_) => d(_)).text((_) => _.text);
        break;
      case "path":
        v.selectAll("path").data(b.data).enter().append("path").attr("d", (_) => _.path).attr("fill", (_) => _.fill ? _.fill : "none").attr("stroke", (_) => _.strokeFill).attr("stroke-width", (_) => _.strokeWidth);
        break;
    }
  }
}, "draw"), tw = {
  draw: JC
}, ew = {
  parser: WC,
  db: ZC,
  renderer: tw
};
const rw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: ew
}, Symbol.toStringTag, { value: "Module" }));
var sc = function() {
  var e = /* @__PURE__ */ u(function(X, ft, P, At) {
    for (P = P || {}, At = X.length; At--; P[X[At]] = ft) ;
    return P;
  }, "o"), t = [1, 3], r = [1, 4], i = [1, 5], s = [1, 6], a = [5, 6, 8, 9, 11, 13, 21, 22, 23, 24, 41, 42, 43, 44, 45, 46, 54, 72, 74, 77, 89, 90], n = [1, 22], o = [2, 7], h = [1, 26], l = [1, 27], d = [1, 28], p = [1, 29], g = [1, 33], f = [1, 34], y = [1, 35], m = [1, 36], x = [1, 37], b = [1, 38], v = [1, 24], _ = [1, 31], A = [1, 32], S = [1, 30], k = [1, 39], L = [1, 40], T = [5, 8, 9, 11, 13, 21, 22, 23, 24, 41, 42, 43, 44, 45, 46, 54, 72, 74, 77, 89, 90], C = [1, 61], E = [89, 90], w = [5, 8, 9, 11, 13, 21, 22, 23, 24, 27, 29, 41, 42, 43, 44, 45, 46, 54, 61, 63, 72, 74, 75, 76, 77, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90], W = [27, 29], N = [1, 70], B = [1, 71], R = [1, 72], V = [1, 73], $ = [1, 74], D = [1, 75], O = [1, 76], Y = [1, 83], M = [1, 80], G = [1, 84], rt = [1, 85], ht = [1, 86], Z = [1, 87], ot = [1, 88], it = [1, 89], bt = [1, 90], xt = [1, 91], Ct = [1, 92], at = [5, 8, 9, 11, 13, 21, 22, 23, 24, 27, 41, 42, 43, 44, 45, 46, 54, 72, 74, 75, 76, 77, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90], lt = [63, 64], Q = [1, 101], U = [5, 8, 9, 11, 13, 21, 22, 23, 24, 41, 42, 43, 44, 45, 46, 54, 72, 74, 76, 77, 89, 90], et = [5, 8, 9, 11, 13, 21, 22, 23, 24, 41, 42, 43, 44, 45, 46, 54, 72, 74, 75, 76, 77, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90], z = [1, 110], Tt = [1, 106], F = [1, 107], te = [1, 108], J = [1, 109], Ut = [1, 111], Wt = [1, 116], ie = [1, 117], dt = [1, 114], wt = [1, 115], nt = {
    trace: /* @__PURE__ */ u(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, start: 3, directive: 4, NEWLINE: 5, RD: 6, diagram: 7, EOF: 8, acc_title: 9, acc_title_value: 10, acc_descr: 11, acc_descr_value: 12, acc_descr_multiline_value: 13, requirementDef: 14, elementDef: 15, relationshipDef: 16, direction: 17, styleStatement: 18, classDefStatement: 19, classStatement: 20, direction_tb: 21, direction_bt: 22, direction_rl: 23, direction_lr: 24, requirementType: 25, requirementName: 26, STRUCT_START: 27, requirementBody: 28, STYLE_SEPARATOR: 29, idList: 30, ID: 31, COLONSEP: 32, id: 33, TEXT: 34, text: 35, RISK: 36, riskLevel: 37, VERIFYMTHD: 38, verifyType: 39, STRUCT_STOP: 40, REQUIREMENT: 41, FUNCTIONAL_REQUIREMENT: 42, INTERFACE_REQUIREMENT: 43, PERFORMANCE_REQUIREMENT: 44, PHYSICAL_REQUIREMENT: 45, DESIGN_CONSTRAINT: 46, LOW_RISK: 47, MED_RISK: 48, HIGH_RISK: 49, VERIFY_ANALYSIS: 50, VERIFY_DEMONSTRATION: 51, VERIFY_INSPECTION: 52, VERIFY_TEST: 53, ELEMENT: 54, elementName: 55, elementBody: 56, TYPE: 57, type: 58, DOCREF: 59, ref: 60, END_ARROW_L: 61, relationship: 62, LINE: 63, END_ARROW_R: 64, CONTAINS: 65, COPIES: 66, DERIVES: 67, SATISFIES: 68, VERIFIES: 69, REFINES: 70, TRACES: 71, CLASSDEF: 72, stylesOpt: 73, CLASS: 74, ALPHA: 75, COMMA: 76, STYLE: 77, style: 78, styleComponent: 79, NUM: 80, COLON: 81, UNIT: 82, SPACE: 83, BRKT: 84, PCT: 85, MINUS: 86, LABEL: 87, SEMICOLON: 88, unqString: 89, qString: 90, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 5: "NEWLINE", 6: "RD", 8: "EOF", 9: "acc_title", 10: "acc_title_value", 11: "acc_descr", 12: "acc_descr_value", 13: "acc_descr_multiline_value", 21: "direction_tb", 22: "direction_bt", 23: "direction_rl", 24: "direction_lr", 27: "STRUCT_START", 29: "STYLE_SEPARATOR", 31: "ID", 32: "COLONSEP", 34: "TEXT", 36: "RISK", 38: "VERIFYMTHD", 40: "STRUCT_STOP", 41: "REQUIREMENT", 42: "FUNCTIONAL_REQUIREMENT", 43: "INTERFACE_REQUIREMENT", 44: "PERFORMANCE_REQUIREMENT", 45: "PHYSICAL_REQUIREMENT", 46: "DESIGN_CONSTRAINT", 47: "LOW_RISK", 48: "MED_RISK", 49: "HIGH_RISK", 50: "VERIFY_ANALYSIS", 51: "VERIFY_DEMONSTRATION", 52: "VERIFY_INSPECTION", 53: "VERIFY_TEST", 54: "ELEMENT", 57: "TYPE", 59: "DOCREF", 61: "END_ARROW_L", 63: "LINE", 64: "END_ARROW_R", 65: "CONTAINS", 66: "COPIES", 67: "DERIVES", 68: "SATISFIES", 69: "VERIFIES", 70: "REFINES", 71: "TRACES", 72: "CLASSDEF", 74: "CLASS", 75: "ALPHA", 76: "COMMA", 77: "STYLE", 80: "NUM", 81: "COLON", 82: "UNIT", 83: "SPACE", 84: "BRKT", 85: "PCT", 86: "MINUS", 87: "LABEL", 88: "SEMICOLON", 89: "unqString", 90: "qString" },
    productions_: [0, [3, 3], [3, 2], [3, 4], [4, 2], [4, 2], [4, 1], [7, 0], [7, 2], [7, 2], [7, 2], [7, 2], [7, 2], [7, 2], [7, 2], [7, 2], [7, 2], [17, 1], [17, 1], [17, 1], [17, 1], [14, 5], [14, 7], [28, 5], [28, 5], [28, 5], [28, 5], [28, 2], [28, 1], [25, 1], [25, 1], [25, 1], [25, 1], [25, 1], [25, 1], [37, 1], [37, 1], [37, 1], [39, 1], [39, 1], [39, 1], [39, 1], [15, 5], [15, 7], [56, 5], [56, 5], [56, 2], [56, 1], [16, 5], [16, 5], [62, 1], [62, 1], [62, 1], [62, 1], [62, 1], [62, 1], [62, 1], [19, 3], [20, 3], [20, 3], [30, 1], [30, 3], [30, 1], [30, 3], [18, 3], [73, 1], [73, 3], [78, 1], [78, 2], [79, 1], [79, 1], [79, 1], [79, 1], [79, 1], [79, 1], [79, 1], [79, 1], [79, 1], [79, 1], [26, 1], [26, 1], [33, 1], [33, 1], [35, 1], [35, 1], [55, 1], [55, 1], [58, 1], [58, 1], [60, 1], [60, 1]],
    performAction: /* @__PURE__ */ u(function(ft, P, At, q, vt, ct, Nt) {
      var pt = ct.length - 1;
      switch (vt) {
        case 4:
          this.$ = ct[pt].trim(), q.setAccTitle(this.$);
          break;
        case 5:
        case 6:
          this.$ = ct[pt].trim(), q.setAccDescription(this.$);
          break;
        case 7:
          this.$ = [];
          break;
        case 17:
          q.setDirection("TB");
          break;
        case 18:
          q.setDirection("BT");
          break;
        case 19:
          q.setDirection("RL");
          break;
        case 20:
          q.setDirection("LR");
          break;
        case 21:
          q.addRequirement(ct[pt - 3], ct[pt - 4]);
          break;
        case 22:
          q.addRequirement(ct[pt - 5], ct[pt - 6]), q.setClass([ct[pt - 5]], ct[pt - 3]);
          break;
        case 23:
          q.setNewReqId(ct[pt - 2]);
          break;
        case 24:
          q.setNewReqText(ct[pt - 2]);
          break;
        case 25:
          q.setNewReqRisk(ct[pt - 2]);
          break;
        case 26:
          q.setNewReqVerifyMethod(ct[pt - 2]);
          break;
        case 29:
          this.$ = q.RequirementType.REQUIREMENT;
          break;
        case 30:
          this.$ = q.RequirementType.FUNCTIONAL_REQUIREMENT;
          break;
        case 31:
          this.$ = q.RequirementType.INTERFACE_REQUIREMENT;
          break;
        case 32:
          this.$ = q.RequirementType.PERFORMANCE_REQUIREMENT;
          break;
        case 33:
          this.$ = q.RequirementType.PHYSICAL_REQUIREMENT;
          break;
        case 34:
          this.$ = q.RequirementType.DESIGN_CONSTRAINT;
          break;
        case 35:
          this.$ = q.RiskLevel.LOW_RISK;
          break;
        case 36:
          this.$ = q.RiskLevel.MED_RISK;
          break;
        case 37:
          this.$ = q.RiskLevel.HIGH_RISK;
          break;
        case 38:
          this.$ = q.VerifyType.VERIFY_ANALYSIS;
          break;
        case 39:
          this.$ = q.VerifyType.VERIFY_DEMONSTRATION;
          break;
        case 40:
          this.$ = q.VerifyType.VERIFY_INSPECTION;
          break;
        case 41:
          this.$ = q.VerifyType.VERIFY_TEST;
          break;
        case 42:
          q.addElement(ct[pt - 3]);
          break;
        case 43:
          q.addElement(ct[pt - 5]), q.setClass([ct[pt - 5]], ct[pt - 3]);
          break;
        case 44:
          q.setNewElementType(ct[pt - 2]);
          break;
        case 45:
          q.setNewElementDocRef(ct[pt - 2]);
          break;
        case 48:
          q.addRelationship(ct[pt - 2], ct[pt], ct[pt - 4]);
          break;
        case 49:
          q.addRelationship(ct[pt - 2], ct[pt - 4], ct[pt]);
          break;
        case 50:
          this.$ = q.Relationships.CONTAINS;
          break;
        case 51:
          this.$ = q.Relationships.COPIES;
          break;
        case 52:
          this.$ = q.Relationships.DERIVES;
          break;
        case 53:
          this.$ = q.Relationships.SATISFIES;
          break;
        case 54:
          this.$ = q.Relationships.VERIFIES;
          break;
        case 55:
          this.$ = q.Relationships.REFINES;
          break;
        case 56:
          this.$ = q.Relationships.TRACES;
          break;
        case 57:
          this.$ = ct[pt - 2], q.defineClass(ct[pt - 1], ct[pt]);
          break;
        case 58:
          q.setClass(ct[pt - 1], ct[pt]);
          break;
        case 59:
          q.setClass([ct[pt - 2]], ct[pt]);
          break;
        case 60:
        case 62:
          this.$ = [ct[pt]];
          break;
        case 61:
        case 63:
          this.$ = ct[pt - 2].concat([ct[pt]]);
          break;
        case 64:
          this.$ = ct[pt - 2], q.setCssStyle(ct[pt - 1], ct[pt]);
          break;
        case 65:
          this.$ = [ct[pt]];
          break;
        case 66:
          ct[pt - 2].push(ct[pt]), this.$ = ct[pt - 2];
          break;
        case 68:
          this.$ = ct[pt - 1] + ct[pt];
          break;
      }
    }, "anonymous"),
    table: [{ 3: 1, 4: 2, 6: t, 9: r, 11: i, 13: s }, { 1: [3] }, { 3: 8, 4: 2, 5: [1, 7], 6: t, 9: r, 11: i, 13: s }, { 5: [1, 9] }, { 10: [1, 10] }, { 12: [1, 11] }, e(a, [2, 6]), { 3: 12, 4: 2, 6: t, 9: r, 11: i, 13: s }, { 1: [2, 2] }, { 4: 17, 5: n, 7: 13, 8: o, 9: r, 11: i, 13: s, 14: 14, 15: 15, 16: 16, 17: 18, 18: 19, 19: 20, 20: 21, 21: h, 22: l, 23: d, 24: p, 25: 23, 33: 25, 41: g, 42: f, 43: y, 44: m, 45: x, 46: b, 54: v, 72: _, 74: A, 77: S, 89: k, 90: L }, e(a, [2, 4]), e(a, [2, 5]), { 1: [2, 1] }, { 8: [1, 41] }, { 4: 17, 5: n, 7: 42, 8: o, 9: r, 11: i, 13: s, 14: 14, 15: 15, 16: 16, 17: 18, 18: 19, 19: 20, 20: 21, 21: h, 22: l, 23: d, 24: p, 25: 23, 33: 25, 41: g, 42: f, 43: y, 44: m, 45: x, 46: b, 54: v, 72: _, 74: A, 77: S, 89: k, 90: L }, { 4: 17, 5: n, 7: 43, 8: o, 9: r, 11: i, 13: s, 14: 14, 15: 15, 16: 16, 17: 18, 18: 19, 19: 20, 20: 21, 21: h, 22: l, 23: d, 24: p, 25: 23, 33: 25, 41: g, 42: f, 43: y, 44: m, 45: x, 46: b, 54: v, 72: _, 74: A, 77: S, 89: k, 90: L }, { 4: 17, 5: n, 7: 44, 8: o, 9: r, 11: i, 13: s, 14: 14, 15: 15, 16: 16, 17: 18, 18: 19, 19: 20, 20: 21, 21: h, 22: l, 23: d, 24: p, 25: 23, 33: 25, 41: g, 42: f, 43: y, 44: m, 45: x, 46: b, 54: v, 72: _, 74: A, 77: S, 89: k, 90: L }, { 4: 17, 5: n, 7: 45, 8: o, 9: r, 11: i, 13: s, 14: 14, 15: 15, 16: 16, 17: 18, 18: 19, 19: 20, 20: 21, 21: h, 22: l, 23: d, 24: p, 25: 23, 33: 25, 41: g, 42: f, 43: y, 44: m, 45: x, 46: b, 54: v, 72: _, 74: A, 77: S, 89: k, 90: L }, { 4: 17, 5: n, 7: 46, 8: o, 9: r, 11: i, 13: s, 14: 14, 15: 15, 16: 16, 17: 18, 18: 19, 19: 20, 20: 21, 21: h, 22: l, 23: d, 24: p, 25: 23, 33: 25, 41: g, 42: f, 43: y, 44: m, 45: x, 46: b, 54: v, 72: _, 74: A, 77: S, 89: k, 90: L }, { 4: 17, 5: n, 7: 47, 8: o, 9: r, 11: i, 13: s, 14: 14, 15: 15, 16: 16, 17: 18, 18: 19, 19: 20, 20: 21, 21: h, 22: l, 23: d, 24: p, 25: 23, 33: 25, 41: g, 42: f, 43: y, 44: m, 45: x, 46: b, 54: v, 72: _, 74: A, 77: S, 89: k, 90: L }, { 4: 17, 5: n, 7: 48, 8: o, 9: r, 11: i, 13: s, 14: 14, 15: 15, 16: 16, 17: 18, 18: 19, 19: 20, 20: 21, 21: h, 22: l, 23: d, 24: p, 25: 23, 33: 25, 41: g, 42: f, 43: y, 44: m, 45: x, 46: b, 54: v, 72: _, 74: A, 77: S, 89: k, 90: L }, { 4: 17, 5: n, 7: 49, 8: o, 9: r, 11: i, 13: s, 14: 14, 15: 15, 16: 16, 17: 18, 18: 19, 19: 20, 20: 21, 21: h, 22: l, 23: d, 24: p, 25: 23, 33: 25, 41: g, 42: f, 43: y, 44: m, 45: x, 46: b, 54: v, 72: _, 74: A, 77: S, 89: k, 90: L }, { 4: 17, 5: n, 7: 50, 8: o, 9: r, 11: i, 13: s, 14: 14, 15: 15, 16: 16, 17: 18, 18: 19, 19: 20, 20: 21, 21: h, 22: l, 23: d, 24: p, 25: 23, 33: 25, 41: g, 42: f, 43: y, 44: m, 45: x, 46: b, 54: v, 72: _, 74: A, 77: S, 89: k, 90: L }, { 26: 51, 89: [1, 52], 90: [1, 53] }, { 55: 54, 89: [1, 55], 90: [1, 56] }, { 29: [1, 59], 61: [1, 57], 63: [1, 58] }, e(T, [2, 17]), e(T, [2, 18]), e(T, [2, 19]), e(T, [2, 20]), { 30: 60, 33: 62, 75: C, 89: k, 90: L }, { 30: 63, 33: 62, 75: C, 89: k, 90: L }, { 30: 64, 33: 62, 75: C, 89: k, 90: L }, e(E, [2, 29]), e(E, [2, 30]), e(E, [2, 31]), e(E, [2, 32]), e(E, [2, 33]), e(E, [2, 34]), e(w, [2, 81]), e(w, [2, 82]), { 1: [2, 3] }, { 8: [2, 8] }, { 8: [2, 9] }, { 8: [2, 10] }, { 8: [2, 11] }, { 8: [2, 12] }, { 8: [2, 13] }, { 8: [2, 14] }, { 8: [2, 15] }, { 8: [2, 16] }, { 27: [1, 65], 29: [1, 66] }, e(W, [2, 79]), e(W, [2, 80]), { 27: [1, 67], 29: [1, 68] }, e(W, [2, 85]), e(W, [2, 86]), { 62: 69, 65: N, 66: B, 67: R, 68: V, 69: $, 70: D, 71: O }, { 62: 77, 65: N, 66: B, 67: R, 68: V, 69: $, 70: D, 71: O }, { 30: 78, 33: 62, 75: C, 89: k, 90: L }, { 73: 79, 75: Y, 76: M, 78: 81, 79: 82, 80: G, 81: rt, 82: ht, 83: Z, 84: ot, 85: it, 86: bt, 87: xt, 88: Ct }, e(at, [2, 60]), e(at, [2, 62]), { 73: 93, 75: Y, 76: M, 78: 81, 79: 82, 80: G, 81: rt, 82: ht, 83: Z, 84: ot, 85: it, 86: bt, 87: xt, 88: Ct }, { 30: 94, 33: 62, 75: C, 76: M, 89: k, 90: L }, { 5: [1, 95] }, { 30: 96, 33: 62, 75: C, 89: k, 90: L }, { 5: [1, 97] }, { 30: 98, 33: 62, 75: C, 89: k, 90: L }, { 63: [1, 99] }, e(lt, [2, 50]), e(lt, [2, 51]), e(lt, [2, 52]), e(lt, [2, 53]), e(lt, [2, 54]), e(lt, [2, 55]), e(lt, [2, 56]), { 64: [1, 100] }, e(T, [2, 59], { 76: M }), e(T, [2, 64], { 76: Q }), { 33: 103, 75: [1, 102], 89: k, 90: L }, e(U, [2, 65], { 79: 104, 75: Y, 80: G, 81: rt, 82: ht, 83: Z, 84: ot, 85: it, 86: bt, 87: xt, 88: Ct }), e(et, [2, 67]), e(et, [2, 69]), e(et, [2, 70]), e(et, [2, 71]), e(et, [2, 72]), e(et, [2, 73]), e(et, [2, 74]), e(et, [2, 75]), e(et, [2, 76]), e(et, [2, 77]), e(et, [2, 78]), e(T, [2, 57], { 76: Q }), e(T, [2, 58], { 76: M }), { 5: z, 28: 105, 31: Tt, 34: F, 36: te, 38: J, 40: Ut }, { 27: [1, 112], 76: M }, { 5: Wt, 40: ie, 56: 113, 57: dt, 59: wt }, { 27: [1, 118], 76: M }, { 33: 119, 89: k, 90: L }, { 33: 120, 89: k, 90: L }, { 75: Y, 78: 121, 79: 82, 80: G, 81: rt, 82: ht, 83: Z, 84: ot, 85: it, 86: bt, 87: xt, 88: Ct }, e(at, [2, 61]), e(at, [2, 63]), e(et, [2, 68]), e(T, [2, 21]), { 32: [1, 122] }, { 32: [1, 123] }, { 32: [1, 124] }, { 32: [1, 125] }, { 5: z, 28: 126, 31: Tt, 34: F, 36: te, 38: J, 40: Ut }, e(T, [2, 28]), { 5: [1, 127] }, e(T, [2, 42]), { 32: [1, 128] }, { 32: [1, 129] }, { 5: Wt, 40: ie, 56: 130, 57: dt, 59: wt }, e(T, [2, 47]), { 5: [1, 131] }, e(T, [2, 48]), e(T, [2, 49]), e(U, [2, 66], { 79: 104, 75: Y, 80: G, 81: rt, 82: ht, 83: Z, 84: ot, 85: it, 86: bt, 87: xt, 88: Ct }), { 33: 132, 89: k, 90: L }, { 35: 133, 89: [1, 134], 90: [1, 135] }, { 37: 136, 47: [1, 137], 48: [1, 138], 49: [1, 139] }, { 39: 140, 50: [1, 141], 51: [1, 142], 52: [1, 143], 53: [1, 144] }, e(T, [2, 27]), { 5: z, 28: 145, 31: Tt, 34: F, 36: te, 38: J, 40: Ut }, { 58: 146, 89: [1, 147], 90: [1, 148] }, { 60: 149, 89: [1, 150], 90: [1, 151] }, e(T, [2, 46]), { 5: Wt, 40: ie, 56: 152, 57: dt, 59: wt }, { 5: [1, 153] }, { 5: [1, 154] }, { 5: [2, 83] }, { 5: [2, 84] }, { 5: [1, 155] }, { 5: [2, 35] }, { 5: [2, 36] }, { 5: [2, 37] }, { 5: [1, 156] }, { 5: [2, 38] }, { 5: [2, 39] }, { 5: [2, 40] }, { 5: [2, 41] }, e(T, [2, 22]), { 5: [1, 157] }, { 5: [2, 87] }, { 5: [2, 88] }, { 5: [1, 158] }, { 5: [2, 89] }, { 5: [2, 90] }, e(T, [2, 43]), { 5: z, 28: 159, 31: Tt, 34: F, 36: te, 38: J, 40: Ut }, { 5: z, 28: 160, 31: Tt, 34: F, 36: te, 38: J, 40: Ut }, { 5: z, 28: 161, 31: Tt, 34: F, 36: te, 38: J, 40: Ut }, { 5: z, 28: 162, 31: Tt, 34: F, 36: te, 38: J, 40: Ut }, { 5: Wt, 40: ie, 56: 163, 57: dt, 59: wt }, { 5: Wt, 40: ie, 56: 164, 57: dt, 59: wt }, e(T, [2, 23]), e(T, [2, 24]), e(T, [2, 25]), e(T, [2, 26]), e(T, [2, 44]), e(T, [2, 45])],
    defaultActions: { 8: [2, 2], 12: [2, 1], 41: [2, 3], 42: [2, 8], 43: [2, 9], 44: [2, 10], 45: [2, 11], 46: [2, 12], 47: [2, 13], 48: [2, 14], 49: [2, 15], 50: [2, 16], 134: [2, 83], 135: [2, 84], 137: [2, 35], 138: [2, 36], 139: [2, 37], 141: [2, 38], 142: [2, 39], 143: [2, 40], 144: [2, 41], 147: [2, 87], 148: [2, 88], 150: [2, 89], 151: [2, 90] },
    parseError: /* @__PURE__ */ u(function(ft, P) {
      if (P.recoverable)
        this.trace(ft);
      else {
        var At = new Error(ft);
        throw At.hash = P, At;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ u(function(ft) {
      var P = this, At = [0], q = [], vt = [null], ct = [], Nt = this.table, pt = "", gt = 0, Jt = 0, Et = 2, ue = 1, Ke = ct.slice.call(arguments, 1), se = Object.create(this.lexer), me = { yy: {} };
      for (var Pe in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, Pe) && (me.yy[Pe] = this.yy[Pe]);
      se.setInput(ft, me.yy), me.yy.lexer = se, me.yy.parser = this, typeof se.yylloc > "u" && (se.yylloc = {});
      var Gt = se.yylloc;
      ct.push(Gt);
      var Se = se.options && se.options.ranges;
      typeof me.yy.parseError == "function" ? this.parseError = me.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function ve($e) {
        At.length = At.length - 2 * $e, vt.length = vt.length - $e, ct.length = ct.length - $e;
      }
      u(ve, "popStack");
      function Ue() {
        var $e;
        return $e = q.pop() || se.lex() || ue, typeof $e != "number" && ($e instanceof Array && (q = $e, $e = q.pop()), $e = P.symbols_[$e] || $e), $e;
      }
      u(Ue, "lex");
      for (var qt, ye, Mt, ae, Zt = {}, jt, $t, ne, tr; ; ) {
        if (ye = At[At.length - 1], this.defaultActions[ye] ? Mt = this.defaultActions[ye] : ((qt === null || typeof qt > "u") && (qt = Ue()), Mt = Nt[ye] && Nt[ye][qt]), typeof Mt > "u" || !Mt.length || !Mt[0]) {
          var oe = "";
          tr = [];
          for (jt in Nt[ye])
            this.terminals_[jt] && jt > Et && tr.push("'" + this.terminals_[jt] + "'");
          se.showPosition ? oe = "Parse error on line " + (gt + 1) + `:
` + se.showPosition() + `
Expecting ` + tr.join(", ") + ", got '" + (this.terminals_[qt] || qt) + "'" : oe = "Parse error on line " + (gt + 1) + ": Unexpected " + (qt == ue ? "end of input" : "'" + (this.terminals_[qt] || qt) + "'"), this.parseError(oe, {
            text: se.match,
            token: this.terminals_[qt] || qt,
            line: se.yylineno,
            loc: Gt,
            expected: tr
          });
        }
        if (Mt[0] instanceof Array && Mt.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + ye + ", token: " + qt);
        switch (Mt[0]) {
          case 1:
            At.push(qt), vt.push(se.yytext), ct.push(se.yylloc), At.push(Mt[1]), qt = null, Jt = se.yyleng, pt = se.yytext, gt = se.yylineno, Gt = se.yylloc;
            break;
          case 2:
            if ($t = this.productions_[Mt[1]][1], Zt.$ = vt[vt.length - $t], Zt._$ = {
              first_line: ct[ct.length - ($t || 1)].first_line,
              last_line: ct[ct.length - 1].last_line,
              first_column: ct[ct.length - ($t || 1)].first_column,
              last_column: ct[ct.length - 1].last_column
            }, Se && (Zt._$.range = [
              ct[ct.length - ($t || 1)].range[0],
              ct[ct.length - 1].range[1]
            ]), ae = this.performAction.apply(Zt, [
              pt,
              Jt,
              gt,
              me.yy,
              Mt[1],
              vt,
              ct
            ].concat(Ke)), typeof ae < "u")
              return ae;
            $t && (At = At.slice(0, -1 * $t * 2), vt = vt.slice(0, -1 * $t), ct = ct.slice(0, -1 * $t)), At.push(this.productions_[Mt[1]][0]), vt.push(Zt.$), ct.push(Zt._$), ne = Nt[At[At.length - 2]][At[At.length - 1]], At.push(ne);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, ut = /* @__PURE__ */ function() {
    var X = {
      EOF: 1,
      parseError: /* @__PURE__ */ u(function(P, At) {
        if (this.yy.parser)
          this.yy.parser.parseError(P, At);
        else
          throw new Error(P);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ u(function(ft, P) {
        return this.yy = P || this.yy || {}, this._input = ft, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ u(function() {
        var ft = this._input[0];
        this.yytext += ft, this.yyleng++, this.offset++, this.match += ft, this.matched += ft;
        var P = ft.match(/(?:\r\n?|\n).*/g);
        return P ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), ft;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ u(function(ft) {
        var P = ft.length, At = ft.split(/(?:\r\n?|\n)/g);
        this._input = ft + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - P), this.offset -= P;
        var q = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), At.length - 1 && (this.yylineno -= At.length - 1);
        var vt = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: At ? (At.length === q.length ? this.yylloc.first_column : 0) + q[q.length - At.length].length - At[0].length : this.yylloc.first_column - P
        }, this.options.ranges && (this.yylloc.range = [vt[0], vt[0] + this.yyleng - P]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ u(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ u(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ u(function(ft) {
        this.unput(this.match.slice(ft));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ u(function() {
        var ft = this.matched.substr(0, this.matched.length - this.match.length);
        return (ft.length > 20 ? "..." : "") + ft.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ u(function() {
        var ft = this.match;
        return ft.length < 20 && (ft += this._input.substr(0, 20 - ft.length)), (ft.substr(0, 20) + (ft.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ u(function() {
        var ft = this.pastInput(), P = new Array(ft.length + 1).join("-");
        return ft + this.upcomingInput() + `
` + P + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ u(function(ft, P) {
        var At, q, vt;
        if (this.options.backtrack_lexer && (vt = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (vt.yylloc.range = this.yylloc.range.slice(0))), q = ft[0].match(/(?:\r\n?|\n).*/g), q && (this.yylineno += q.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: q ? q[q.length - 1].length - q[q.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + ft[0].length
        }, this.yytext += ft[0], this.match += ft[0], this.matches = ft, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(ft[0].length), this.matched += ft[0], At = this.performAction.call(this, this.yy, this, P, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), At)
          return At;
        if (this._backtrack) {
          for (var ct in vt)
            this[ct] = vt[ct];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ u(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var ft, P, At, q;
        this._more || (this.yytext = "", this.match = "");
        for (var vt = this._currentRules(), ct = 0; ct < vt.length; ct++)
          if (At = this._input.match(this.rules[vt[ct]]), At && (!P || At[0].length > P[0].length)) {
            if (P = At, q = ct, this.options.backtrack_lexer) {
              if (ft = this.test_match(At, vt[ct]), ft !== !1)
                return ft;
              if (this._backtrack) {
                P = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return P ? (ft = this.test_match(P, vt[q]), ft !== !1 ? ft : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ u(function() {
        var P = this.next();
        return P || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ u(function(P) {
        this.conditionStack.push(P);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ u(function() {
        var P = this.conditionStack.length - 1;
        return P > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ u(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ u(function(P) {
        return P = this.conditionStack.length - 1 - Math.abs(P || 0), P >= 0 ? this.conditionStack[P] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ u(function(P) {
        this.begin(P);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ u(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: { "case-insensitive": !0 },
      performAction: /* @__PURE__ */ u(function(P, At, q, vt) {
        switch (q) {
          case 0:
            return "title";
          case 1:
            return this.begin("acc_title"), 9;
          case 2:
            return this.popState(), "acc_title_value";
          case 3:
            return this.begin("acc_descr"), 11;
          case 4:
            return this.popState(), "acc_descr_value";
          case 5:
            this.begin("acc_descr_multiline");
            break;
          case 6:
            this.popState();
            break;
          case 7:
            return "acc_descr_multiline_value";
          case 8:
            return 21;
          case 9:
            return 22;
          case 10:
            return 23;
          case 11:
            return 24;
          case 12:
            return 5;
          case 13:
            break;
          case 14:
            break;
          case 15:
            break;
          case 16:
            return 8;
          case 17:
            return 6;
          case 18:
            return 27;
          case 19:
            return 40;
          case 20:
            return 29;
          case 21:
            return 32;
          case 22:
            return 31;
          case 23:
            return 34;
          case 24:
            return 36;
          case 25:
            return 38;
          case 26:
            return 41;
          case 27:
            return 42;
          case 28:
            return 43;
          case 29:
            return 44;
          case 30:
            return 45;
          case 31:
            return 46;
          case 32:
            return 47;
          case 33:
            return 48;
          case 34:
            return 49;
          case 35:
            return 50;
          case 36:
            return 51;
          case 37:
            return 52;
          case 38:
            return 53;
          case 39:
            return 54;
          case 40:
            return 65;
          case 41:
            return 66;
          case 42:
            return 67;
          case 43:
            return 68;
          case 44:
            return 69;
          case 45:
            return 70;
          case 46:
            return 71;
          case 47:
            return 57;
          case 48:
            return 59;
          case 49:
            return this.begin("style"), 77;
          case 50:
            return 75;
          case 51:
            return 81;
          case 52:
            return 88;
          case 53:
            return "PERCENT";
          case 54:
            return 86;
          case 55:
            return 84;
          case 56:
            break;
          case 57:
            this.begin("string");
            break;
          case 58:
            this.popState();
            break;
          case 59:
            return this.begin("style"), 72;
          case 60:
            return this.begin("style"), 74;
          case 61:
            return 61;
          case 62:
            return 64;
          case 63:
            return 63;
          case 64:
            this.begin("string");
            break;
          case 65:
            this.popState();
            break;
          case 66:
            return "qString";
          case 67:
            return At.yytext = At.yytext.trim(), 89;
          case 68:
            return 75;
          case 69:
            return 80;
          case 70:
            return 76;
        }
      }, "anonymous"),
      rules: [/^(?:title\s[^#\n;]+)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:.*direction\s+TB[^\n]*)/i, /^(?:.*direction\s+BT[^\n]*)/i, /^(?:.*direction\s+RL[^\n]*)/i, /^(?:.*direction\s+LR[^\n]*)/i, /^(?:(\r?\n)+)/i, /^(?:\s+)/i, /^(?:#[^\n]*)/i, /^(?:%[^\n]*)/i, /^(?:$)/i, /^(?:requirementDiagram\b)/i, /^(?:\{)/i, /^(?:\})/i, /^(?::{3})/i, /^(?::)/i, /^(?:id\b)/i, /^(?:text\b)/i, /^(?:risk\b)/i, /^(?:verifyMethod\b)/i, /^(?:requirement\b)/i, /^(?:functionalRequirement\b)/i, /^(?:interfaceRequirement\b)/i, /^(?:performanceRequirement\b)/i, /^(?:physicalRequirement\b)/i, /^(?:designConstraint\b)/i, /^(?:low\b)/i, /^(?:medium\b)/i, /^(?:high\b)/i, /^(?:analysis\b)/i, /^(?:demonstration\b)/i, /^(?:inspection\b)/i, /^(?:test\b)/i, /^(?:element\b)/i, /^(?:contains\b)/i, /^(?:copies\b)/i, /^(?:derives\b)/i, /^(?:satisfies\b)/i, /^(?:verifies\b)/i, /^(?:refines\b)/i, /^(?:traces\b)/i, /^(?:type\b)/i, /^(?:docref\b)/i, /^(?:style\b)/i, /^(?:\w+)/i, /^(?::)/i, /^(?:;)/i, /^(?:%)/i, /^(?:-)/i, /^(?:#)/i, /^(?: )/i, /^(?:["])/i, /^(?:\n)/i, /^(?:classDef\b)/i, /^(?:class\b)/i, /^(?:<-)/i, /^(?:->)/i, /^(?:-)/i, /^(?:["])/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:[\w][^:,\r\n\{\<\>\-\=]*)/i, /^(?:\w+)/i, /^(?:[0-9]+)/i, /^(?:,)/i],
      conditions: { acc_descr_multiline: { rules: [6, 7, 68, 69, 70], inclusive: !1 }, acc_descr: { rules: [4, 68, 69, 70], inclusive: !1 }, acc_title: { rules: [2, 68, 69, 70], inclusive: !1 }, style: { rules: [50, 51, 52, 53, 54, 55, 56, 57, 58, 68, 69, 70], inclusive: !1 }, unqString: { rules: [68, 69, 70], inclusive: !1 }, token: { rules: [68, 69, 70], inclusive: !1 }, string: { rules: [65, 66, 68, 69, 70], inclusive: !1 }, INITIAL: { rules: [0, 1, 3, 5, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 59, 60, 61, 62, 63, 64, 67, 68, 69, 70], inclusive: !0 } }
    };
    return X;
  }();
  nt.lexer = ut;
  function kt() {
    this.yy = {};
  }
  return u(kt, "Parser"), kt.prototype = nt, nt.Parser = kt, new kt();
}();
sc.parser = sc;
var iw = sc, ea, sw = (ea = class {
  constructor() {
    this.relations = [], this.latestRequirement = this.getInitialRequirement(), this.requirements = /* @__PURE__ */ new Map(), this.latestElement = this.getInitialElement(), this.elements = /* @__PURE__ */ new Map(), this.classes = /* @__PURE__ */ new Map(), this.direction = "TB", this.RequirementType = {
      REQUIREMENT: "Requirement",
      FUNCTIONAL_REQUIREMENT: "Functional Requirement",
      INTERFACE_REQUIREMENT: "Interface Requirement",
      PERFORMANCE_REQUIREMENT: "Performance Requirement",
      PHYSICAL_REQUIREMENT: "Physical Requirement",
      DESIGN_CONSTRAINT: "Design Constraint"
    }, this.RiskLevel = {
      LOW_RISK: "Low",
      MED_RISK: "Medium",
      HIGH_RISK: "High"
    }, this.VerifyType = {
      VERIFY_ANALYSIS: "Analysis",
      VERIFY_DEMONSTRATION: "Demonstration",
      VERIFY_INSPECTION: "Inspection",
      VERIFY_TEST: "Test"
    }, this.Relationships = {
      CONTAINS: "contains",
      COPIES: "copies",
      DERIVES: "derives",
      SATISFIES: "satisfies",
      VERIFIES: "verifies",
      REFINES: "refines",
      TRACES: "traces"
    }, this.setAccTitle = Re, this.getAccTitle = qe, this.setAccDescription = Ye, this.getAccDescription = He, this.setDiagramTitle = Ge, this.getDiagramTitle = Oe, this.getConfig = /* @__PURE__ */ u(() => K().requirement, "getConfig"), this.clear(), this.setDirection = this.setDirection.bind(this), this.addRequirement = this.addRequirement.bind(this), this.setNewReqId = this.setNewReqId.bind(this), this.setNewReqRisk = this.setNewReqRisk.bind(this), this.setNewReqText = this.setNewReqText.bind(this), this.setNewReqVerifyMethod = this.setNewReqVerifyMethod.bind(this), this.addElement = this.addElement.bind(this), this.setNewElementType = this.setNewElementType.bind(this), this.setNewElementDocRef = this.setNewElementDocRef.bind(this), this.addRelationship = this.addRelationship.bind(this), this.setCssStyle = this.setCssStyle.bind(this), this.setClass = this.setClass.bind(this), this.defineClass = this.defineClass.bind(this), this.setAccTitle = this.setAccTitle.bind(this), this.setAccDescription = this.setAccDescription.bind(this);
  }
  getDirection() {
    return this.direction;
  }
  setDirection(t) {
    this.direction = t;
  }
  resetLatestRequirement() {
    this.latestRequirement = this.getInitialRequirement();
  }
  resetLatestElement() {
    this.latestElement = this.getInitialElement();
  }
  getInitialRequirement() {
    return {
      requirementId: "",
      text: "",
      risk: "",
      verifyMethod: "",
      name: "",
      type: "",
      cssStyles: [],
      classes: ["default"]
    };
  }
  getInitialElement() {
    return {
      name: "",
      type: "",
      docRef: "",
      cssStyles: [],
      classes: ["default"]
    };
  }
  addRequirement(t, r) {
    return this.requirements.has(t) || this.requirements.set(t, {
      name: t,
      type: r,
      requirementId: this.latestRequirement.requirementId,
      text: this.latestRequirement.text,
      risk: this.latestRequirement.risk,
      verifyMethod: this.latestRequirement.verifyMethod,
      cssStyles: [],
      classes: ["default"]
    }), this.resetLatestRequirement(), this.requirements.get(t);
  }
  getRequirements() {
    return this.requirements;
  }
  setNewReqId(t) {
    this.latestRequirement !== void 0 && (this.latestRequirement.requirementId = t);
  }
  setNewReqText(t) {
    this.latestRequirement !== void 0 && (this.latestRequirement.text = t);
  }
  setNewReqRisk(t) {
    this.latestRequirement !== void 0 && (this.latestRequirement.risk = t);
  }
  setNewReqVerifyMethod(t) {
    this.latestRequirement !== void 0 && (this.latestRequirement.verifyMethod = t);
  }
  addElement(t) {
    return this.elements.has(t) || (this.elements.set(t, {
      name: t,
      type: this.latestElement.type,
      docRef: this.latestElement.docRef,
      cssStyles: [],
      classes: ["default"]
    }), I.info("Added new element: ", t)), this.resetLatestElement(), this.elements.get(t);
  }
  getElements() {
    return this.elements;
  }
  setNewElementType(t) {
    this.latestElement !== void 0 && (this.latestElement.type = t);
  }
  setNewElementDocRef(t) {
    this.latestElement !== void 0 && (this.latestElement.docRef = t);
  }
  addRelationship(t, r, i) {
    this.relations.push({
      type: t,
      src: r,
      dst: i
    });
  }
  getRelationships() {
    return this.relations;
  }
  clear() {
    this.relations = [], this.resetLatestRequirement(), this.requirements = /* @__PURE__ */ new Map(), this.resetLatestElement(), this.elements = /* @__PURE__ */ new Map(), this.classes = /* @__PURE__ */ new Map(), Me();
  }
  setCssStyle(t, r) {
    for (const i of t) {
      const s = this.requirements.get(i) ?? this.elements.get(i);
      if (!r || !s)
        return;
      for (const a of r)
        a.includes(",") ? s.cssStyles.push(...a.split(",")) : s.cssStyles.push(a);
    }
  }
  setClass(t, r) {
    var i;
    for (const s of t) {
      const a = this.requirements.get(s) ?? this.elements.get(s);
      if (a)
        for (const n of r) {
          a.classes.push(n);
          const o = (i = this.classes.get(n)) == null ? void 0 : i.styles;
          o && a.cssStyles.push(...o);
        }
    }
  }
  defineClass(t, r) {
    for (const i of t) {
      let s = this.classes.get(i);
      s === void 0 && (s = { id: i, styles: [], textStyles: [] }, this.classes.set(i, s)), r && r.forEach(function(a) {
        if (/color/.exec(a)) {
          const n = a.replace("fill", "bgFill");
          s.textStyles.push(n);
        }
        s.styles.push(a);
      }), this.requirements.forEach((a) => {
        a.classes.includes(i) && a.cssStyles.push(...r.flatMap((n) => n.split(",")));
      }), this.elements.forEach((a) => {
        a.classes.includes(i) && a.cssStyles.push(...r.flatMap((n) => n.split(",")));
      });
    }
  }
  getClasses() {
    return this.classes;
  }
  getData() {
    var s, a, n, o;
    const t = K(), r = [], i = [];
    for (const h of this.requirements.values()) {
      const l = h;
      l.id = h.name, l.cssStyles = h.cssStyles, l.cssClasses = h.classes.join(" "), l.shape = "requirementBox", l.look = t.look, r.push(l);
    }
    for (const h of this.elements.values()) {
      const l = h;
      l.shape = "requirementBox", l.look = t.look, l.id = h.name, l.cssStyles = h.cssStyles, l.cssClasses = h.classes.join(" "), r.push(l);
    }
    for (const h of this.relations) {
      let l = 0;
      const d = h.type === this.Relationships.CONTAINS, p = {
        id: `${h.src}-${h.dst}-${l}`,
        start: ((s = this.requirements.get(h.src)) == null ? void 0 : s.name) ?? ((a = this.elements.get(h.src)) == null ? void 0 : a.name),
        end: ((n = this.requirements.get(h.dst)) == null ? void 0 : n.name) ?? ((o = this.elements.get(h.dst)) == null ? void 0 : o.name),
        label: `&lt;&lt;${h.type}&gt;&gt;`,
        classes: "relationshipLine",
        style: ["fill:none", d ? "" : "stroke-dasharray: 10,7"],
        labelpos: "c",
        thickness: "normal",
        type: "normal",
        pattern: d ? "normal" : "dashed",
        arrowTypeStart: d ? "requirement_contains" : "",
        arrowTypeEnd: d ? "" : "requirement_arrow",
        look: t.look
      };
      i.push(p), l++;
    }
    return { nodes: r, edges: i, other: {}, config: t, direction: this.getDirection() };
  }
}, u(ea, "RequirementDB"), ea), aw = /* @__PURE__ */ u((e) => `

  marker {
    fill: ${e.relationColor};
    stroke: ${e.relationColor};
  }

  marker.cross {
    stroke: ${e.lineColor};
  }

  svg {
    font-family: ${e.fontFamily};
    font-size: ${e.fontSize};
  }

  .reqBox {
    fill: ${e.requirementBackground};
    fill-opacity: 1.0;
    stroke: ${e.requirementBorderColor};
    stroke-width: ${e.requirementBorderSize};
  }
  
  .reqTitle, .reqLabel{
    fill:  ${e.requirementTextColor};
  }
  .reqLabelBox {
    fill: ${e.relationLabelBackground};
    fill-opacity: 1.0;
  }

  .req-title-line {
    stroke: ${e.requirementBorderColor};
    stroke-width: ${e.requirementBorderSize};
  }
  .relationshipLine {
    stroke: ${e.relationColor};
    stroke-width: 1;
  }
  .relationshipLabel {
    fill: ${e.relationLabelColor};
  }
  .divider {
    stroke: ${e.nodeBorder};
    stroke-width: 1;
  }
  .label {
    font-family: ${e.fontFamily};
    color: ${e.nodeTextColor || e.textColor};
  }
  .label text,span {
    fill: ${e.nodeTextColor || e.textColor};
    color: ${e.nodeTextColor || e.textColor};
  }
  .labelBkg {
    background-color: ${e.edgeLabelBackground};
  }

`, "getStyles"), nw = aw, L2 = {};
Co(L2, {
  draw: () => ow
});
var ow = /* @__PURE__ */ u(async function(e, t, r, i) {
  I.info("REF0:"), I.info("Drawing requirement diagram (unified)", t);
  const { securityLevel: s, state: a, layout: n } = K(), o = i.db.getData(), h = Ta(t, s);
  o.type = i.type, o.layoutAlgorithm = fn(n), o.nodeSpacing = (a == null ? void 0 : a.nodeSpacing) ?? 50, o.rankSpacing = (a == null ? void 0 : a.rankSpacing) ?? 50, o.markers = ["requirement_contains", "requirement_arrow"], o.diagramId = t, await wa(o, h);
  const l = 8;
  ee.insertTitle(
    h,
    "requirementDiagramTitleText",
    (a == null ? void 0 : a.titleTopMargin) ?? 25,
    i.db.getDiagramTitle()
  ), cs(h, l, "requirementDiagram", (a == null ? void 0 : a.useMaxWidth) ?? !0);
}, "draw"), lw = {
  parser: iw,
  get db() {
    return new sw();
  },
  renderer: L2,
  styles: nw
};
const cw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: lw
}, Symbol.toStringTag, { value: "Module" }));
var ac = function() {
  var e = /* @__PURE__ */ u(function(Ct, at, lt, Q) {
    for (lt = lt || {}, Q = Ct.length; Q--; lt[Ct[Q]] = at) ;
    return lt;
  }, "o"), t = [1, 2], r = [1, 3], i = [1, 4], s = [2, 4], a = [1, 9], n = [1, 11], o = [1, 13], h = [1, 14], l = [1, 16], d = [1, 17], p = [1, 18], g = [1, 24], f = [1, 25], y = [1, 26], m = [1, 27], x = [1, 28], b = [1, 29], v = [1, 30], _ = [1, 31], A = [1, 32], S = [1, 33], k = [1, 34], L = [1, 35], T = [1, 36], C = [1, 37], E = [1, 38], w = [1, 39], W = [1, 41], N = [1, 42], B = [1, 43], R = [1, 44], V = [1, 45], $ = [1, 46], D = [1, 4, 5, 13, 14, 16, 18, 21, 23, 29, 30, 31, 33, 35, 36, 37, 38, 39, 41, 43, 44, 46, 47, 48, 49, 50, 52, 53, 55, 60, 61, 62, 63, 71], O = [2, 71], Y = [4, 5, 16, 50, 52, 53], M = [4, 5, 13, 14, 16, 18, 21, 23, 29, 30, 31, 33, 35, 36, 37, 38, 39, 41, 43, 44, 46, 50, 52, 53, 55, 60, 61, 62, 63, 71], G = [4, 5, 13, 14, 16, 18, 21, 23, 29, 30, 31, 33, 35, 36, 37, 38, 39, 41, 43, 44, 46, 49, 50, 52, 53, 55, 60, 61, 62, 63, 71], rt = [4, 5, 13, 14, 16, 18, 21, 23, 29, 30, 31, 33, 35, 36, 37, 38, 39, 41, 43, 44, 46, 48, 50, 52, 53, 55, 60, 61, 62, 63, 71], ht = [4, 5, 13, 14, 16, 18, 21, 23, 29, 30, 31, 33, 35, 36, 37, 38, 39, 41, 43, 44, 46, 47, 50, 52, 53, 55, 60, 61, 62, 63, 71], Z = [69, 70, 71], ot = [1, 127], it = {
    trace: /* @__PURE__ */ u(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, start: 3, SPACE: 4, NEWLINE: 5, SD: 6, document: 7, line: 8, statement: 9, box_section: 10, box_line: 11, participant_statement: 12, create: 13, box: 14, restOfLine: 15, end: 16, signal: 17, autonumber: 18, NUM: 19, off: 20, activate: 21, actor: 22, deactivate: 23, note_statement: 24, links_statement: 25, link_statement: 26, properties_statement: 27, details_statement: 28, title: 29, legacy_title: 30, acc_title: 31, acc_title_value: 32, acc_descr: 33, acc_descr_value: 34, acc_descr_multiline_value: 35, loop: 36, rect: 37, opt: 38, alt: 39, else_sections: 40, par: 41, par_sections: 42, par_over: 43, critical: 44, option_sections: 45, break: 46, option: 47, and: 48, else: 49, participant: 50, AS: 51, participant_actor: 52, destroy: 53, actor_with_config: 54, note: 55, placement: 56, text2: 57, over: 58, actor_pair: 59, links: 60, link: 61, properties: 62, details: 63, spaceList: 64, ",": 65, left_of: 66, right_of: 67, signaltype: 68, "+": 69, "-": 70, ACTOR: 71, config_object: 72, CONFIG_START: 73, CONFIG_CONTENT: 74, CONFIG_END: 75, SOLID_OPEN_ARROW: 76, DOTTED_OPEN_ARROW: 77, SOLID_ARROW: 78, BIDIRECTIONAL_SOLID_ARROW: 79, DOTTED_ARROW: 80, BIDIRECTIONAL_DOTTED_ARROW: 81, SOLID_CROSS: 82, DOTTED_CROSS: 83, SOLID_POINT: 84, DOTTED_POINT: 85, TXT: 86, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 4: "SPACE", 5: "NEWLINE", 6: "SD", 13: "create", 14: "box", 15: "restOfLine", 16: "end", 18: "autonumber", 19: "NUM", 20: "off", 21: "activate", 23: "deactivate", 29: "title", 30: "legacy_title", 31: "acc_title", 32: "acc_title_value", 33: "acc_descr", 34: "acc_descr_value", 35: "acc_descr_multiline_value", 36: "loop", 37: "rect", 38: "opt", 39: "alt", 41: "par", 43: "par_over", 44: "critical", 46: "break", 47: "option", 48: "and", 49: "else", 50: "participant", 51: "AS", 52: "participant_actor", 53: "destroy", 55: "note", 58: "over", 60: "links", 61: "link", 62: "properties", 63: "details", 65: ",", 66: "left_of", 67: "right_of", 69: "+", 70: "-", 71: "ACTOR", 73: "CONFIG_START", 74: "CONFIG_CONTENT", 75: "CONFIG_END", 76: "SOLID_OPEN_ARROW", 77: "DOTTED_OPEN_ARROW", 78: "SOLID_ARROW", 79: "BIDIRECTIONAL_SOLID_ARROW", 80: "DOTTED_ARROW", 81: "BIDIRECTIONAL_DOTTED_ARROW", 82: "SOLID_CROSS", 83: "DOTTED_CROSS", 84: "SOLID_POINT", 85: "DOTTED_POINT", 86: "TXT" },
    productions_: [0, [3, 2], [3, 2], [3, 2], [7, 0], [7, 2], [8, 2], [8, 1], [8, 1], [10, 0], [10, 2], [11, 2], [11, 1], [11, 1], [9, 1], [9, 2], [9, 4], [9, 2], [9, 4], [9, 3], [9, 3], [9, 2], [9, 3], [9, 3], [9, 2], [9, 2], [9, 2], [9, 2], [9, 2], [9, 1], [9, 1], [9, 2], [9, 2], [9, 1], [9, 4], [9, 4], [9, 4], [9, 4], [9, 4], [9, 4], [9, 4], [9, 4], [45, 1], [45, 4], [42, 1], [42, 4], [40, 1], [40, 4], [12, 5], [12, 3], [12, 5], [12, 3], [12, 3], [12, 3], [24, 4], [24, 4], [25, 3], [26, 3], [27, 3], [28, 3], [64, 2], [64, 1], [59, 3], [59, 1], [56, 1], [56, 1], [17, 5], [17, 5], [17, 4], [54, 2], [72, 3], [22, 1], [68, 1], [68, 1], [68, 1], [68, 1], [68, 1], [68, 1], [68, 1], [68, 1], [68, 1], [68, 1], [57, 1]],
    performAction: /* @__PURE__ */ u(function(at, lt, Q, U, et, z, Tt) {
      var F = z.length - 1;
      switch (et) {
        case 3:
          return U.apply(z[F]), z[F];
        case 4:
        case 9:
          this.$ = [];
          break;
        case 5:
        case 10:
          z[F - 1].push(z[F]), this.$ = z[F - 1];
          break;
        case 6:
        case 7:
        case 11:
        case 12:
          this.$ = z[F];
          break;
        case 8:
        case 13:
          this.$ = [];
          break;
        case 15:
          z[F].type = "createParticipant", this.$ = z[F];
          break;
        case 16:
          z[F - 1].unshift({ type: "boxStart", boxData: U.parseBoxData(z[F - 2]) }), z[F - 1].push({ type: "boxEnd", boxText: z[F - 2] }), this.$ = z[F - 1];
          break;
        case 18:
          this.$ = { type: "sequenceIndex", sequenceIndex: Number(z[F - 2]), sequenceIndexStep: Number(z[F - 1]), sequenceVisible: !0, signalType: U.LINETYPE.AUTONUMBER };
          break;
        case 19:
          this.$ = { type: "sequenceIndex", sequenceIndex: Number(z[F - 1]), sequenceIndexStep: 1, sequenceVisible: !0, signalType: U.LINETYPE.AUTONUMBER };
          break;
        case 20:
          this.$ = { type: "sequenceIndex", sequenceVisible: !1, signalType: U.LINETYPE.AUTONUMBER };
          break;
        case 21:
          this.$ = { type: "sequenceIndex", sequenceVisible: !0, signalType: U.LINETYPE.AUTONUMBER };
          break;
        case 22:
          this.$ = { type: "activeStart", signalType: U.LINETYPE.ACTIVE_START, actor: z[F - 1].actor };
          break;
        case 23:
          this.$ = { type: "activeEnd", signalType: U.LINETYPE.ACTIVE_END, actor: z[F - 1].actor };
          break;
        case 29:
          U.setDiagramTitle(z[F].substring(6)), this.$ = z[F].substring(6);
          break;
        case 30:
          U.setDiagramTitle(z[F].substring(7)), this.$ = z[F].substring(7);
          break;
        case 31:
          this.$ = z[F].trim(), U.setAccTitle(this.$);
          break;
        case 32:
        case 33:
          this.$ = z[F].trim(), U.setAccDescription(this.$);
          break;
        case 34:
          z[F - 1].unshift({ type: "loopStart", loopText: U.parseMessage(z[F - 2]), signalType: U.LINETYPE.LOOP_START }), z[F - 1].push({ type: "loopEnd", loopText: z[F - 2], signalType: U.LINETYPE.LOOP_END }), this.$ = z[F - 1];
          break;
        case 35:
          z[F - 1].unshift({ type: "rectStart", color: U.parseMessage(z[F - 2]), signalType: U.LINETYPE.RECT_START }), z[F - 1].push({ type: "rectEnd", color: U.parseMessage(z[F - 2]), signalType: U.LINETYPE.RECT_END }), this.$ = z[F - 1];
          break;
        case 36:
          z[F - 1].unshift({ type: "optStart", optText: U.parseMessage(z[F - 2]), signalType: U.LINETYPE.OPT_START }), z[F - 1].push({ type: "optEnd", optText: U.parseMessage(z[F - 2]), signalType: U.LINETYPE.OPT_END }), this.$ = z[F - 1];
          break;
        case 37:
          z[F - 1].unshift({ type: "altStart", altText: U.parseMessage(z[F - 2]), signalType: U.LINETYPE.ALT_START }), z[F - 1].push({ type: "altEnd", signalType: U.LINETYPE.ALT_END }), this.$ = z[F - 1];
          break;
        case 38:
          z[F - 1].unshift({ type: "parStart", parText: U.parseMessage(z[F - 2]), signalType: U.LINETYPE.PAR_START }), z[F - 1].push({ type: "parEnd", signalType: U.LINETYPE.PAR_END }), this.$ = z[F - 1];
          break;
        case 39:
          z[F - 1].unshift({ type: "parStart", parText: U.parseMessage(z[F - 2]), signalType: U.LINETYPE.PAR_OVER_START }), z[F - 1].push({ type: "parEnd", signalType: U.LINETYPE.PAR_END }), this.$ = z[F - 1];
          break;
        case 40:
          z[F - 1].unshift({ type: "criticalStart", criticalText: U.parseMessage(z[F - 2]), signalType: U.LINETYPE.CRITICAL_START }), z[F - 1].push({ type: "criticalEnd", signalType: U.LINETYPE.CRITICAL_END }), this.$ = z[F - 1];
          break;
        case 41:
          z[F - 1].unshift({ type: "breakStart", breakText: U.parseMessage(z[F - 2]), signalType: U.LINETYPE.BREAK_START }), z[F - 1].push({ type: "breakEnd", optText: U.parseMessage(z[F - 2]), signalType: U.LINETYPE.BREAK_END }), this.$ = z[F - 1];
          break;
        case 43:
          this.$ = z[F - 3].concat([{ type: "option", optionText: U.parseMessage(z[F - 1]), signalType: U.LINETYPE.CRITICAL_OPTION }, z[F]]);
          break;
        case 45:
          this.$ = z[F - 3].concat([{ type: "and", parText: U.parseMessage(z[F - 1]), signalType: U.LINETYPE.PAR_AND }, z[F]]);
          break;
        case 47:
          this.$ = z[F - 3].concat([{ type: "else", altText: U.parseMessage(z[F - 1]), signalType: U.LINETYPE.ALT_ELSE }, z[F]]);
          break;
        case 48:
          z[F - 3].draw = "participant", z[F - 3].type = "addParticipant", z[F - 3].description = U.parseMessage(z[F - 1]), this.$ = z[F - 3];
          break;
        case 49:
          z[F - 1].draw = "participant", z[F - 1].type = "addParticipant", this.$ = z[F - 1];
          break;
        case 50:
          z[F - 3].draw = "actor", z[F - 3].type = "addParticipant", z[F - 3].description = U.parseMessage(z[F - 1]), this.$ = z[F - 3];
          break;
        case 51:
          z[F - 1].draw = "actor", z[F - 1].type = "addParticipant", this.$ = z[F - 1];
          break;
        case 52:
          z[F - 1].type = "destroyParticipant", this.$ = z[F - 1];
          break;
        case 53:
          z[F - 1].draw = "participant", z[F - 1].type = "addParticipant", this.$ = z[F - 1];
          break;
        case 54:
          this.$ = [z[F - 1], { type: "addNote", placement: z[F - 2], actor: z[F - 1].actor, text: z[F] }];
          break;
        case 55:
          z[F - 2] = [].concat(z[F - 1], z[F - 1]).slice(0, 2), z[F - 2][0] = z[F - 2][0].actor, z[F - 2][1] = z[F - 2][1].actor, this.$ = [z[F - 1], { type: "addNote", placement: U.PLACEMENT.OVER, actor: z[F - 2].slice(0, 2), text: z[F] }];
          break;
        case 56:
          this.$ = [z[F - 1], { type: "addLinks", actor: z[F - 1].actor, text: z[F] }];
          break;
        case 57:
          this.$ = [z[F - 1], { type: "addALink", actor: z[F - 1].actor, text: z[F] }];
          break;
        case 58:
          this.$ = [z[F - 1], { type: "addProperties", actor: z[F - 1].actor, text: z[F] }];
          break;
        case 59:
          this.$ = [z[F - 1], { type: "addDetails", actor: z[F - 1].actor, text: z[F] }];
          break;
        case 62:
          this.$ = [z[F - 2], z[F]];
          break;
        case 63:
          this.$ = z[F];
          break;
        case 64:
          this.$ = U.PLACEMENT.LEFTOF;
          break;
        case 65:
          this.$ = U.PLACEMENT.RIGHTOF;
          break;
        case 66:
          this.$ = [
            z[F - 4],
            z[F - 1],
            { type: "addMessage", from: z[F - 4].actor, to: z[F - 1].actor, signalType: z[F - 3], msg: z[F], activate: !0 },
            { type: "activeStart", signalType: U.LINETYPE.ACTIVE_START, actor: z[F - 1].actor }
          ];
          break;
        case 67:
          this.$ = [
            z[F - 4],
            z[F - 1],
            { type: "addMessage", from: z[F - 4].actor, to: z[F - 1].actor, signalType: z[F - 3], msg: z[F] },
            { type: "activeEnd", signalType: U.LINETYPE.ACTIVE_END, actor: z[F - 4].actor }
          ];
          break;
        case 68:
          this.$ = [z[F - 3], z[F - 1], { type: "addMessage", from: z[F - 3].actor, to: z[F - 1].actor, signalType: z[F - 2], msg: z[F] }];
          break;
        case 69:
          this.$ = {
            type: "addParticipant",
            actor: z[F - 1],
            config: z[F]
          };
          break;
        case 70:
          this.$ = z[F - 1].trim();
          break;
        case 71:
          this.$ = { type: "addParticipant", actor: z[F] };
          break;
        case 72:
          this.$ = U.LINETYPE.SOLID_OPEN;
          break;
        case 73:
          this.$ = U.LINETYPE.DOTTED_OPEN;
          break;
        case 74:
          this.$ = U.LINETYPE.SOLID;
          break;
        case 75:
          this.$ = U.LINETYPE.BIDIRECTIONAL_SOLID;
          break;
        case 76:
          this.$ = U.LINETYPE.DOTTED;
          break;
        case 77:
          this.$ = U.LINETYPE.BIDIRECTIONAL_DOTTED;
          break;
        case 78:
          this.$ = U.LINETYPE.SOLID_CROSS;
          break;
        case 79:
          this.$ = U.LINETYPE.DOTTED_CROSS;
          break;
        case 80:
          this.$ = U.LINETYPE.SOLID_POINT;
          break;
        case 81:
          this.$ = U.LINETYPE.DOTTED_POINT;
          break;
        case 82:
          this.$ = U.parseMessage(z[F].trim().substring(1));
          break;
      }
    }, "anonymous"),
    table: [{ 3: 1, 4: t, 5: r, 6: i }, { 1: [3] }, { 3: 5, 4: t, 5: r, 6: i }, { 3: 6, 4: t, 5: r, 6: i }, e([1, 4, 5, 13, 14, 18, 21, 23, 29, 30, 31, 33, 35, 36, 37, 38, 39, 41, 43, 44, 46, 50, 52, 53, 55, 60, 61, 62, 63, 71], s, { 7: 7 }), { 1: [2, 1] }, { 1: [2, 2] }, { 1: [2, 3], 4: a, 5: n, 8: 8, 9: 10, 12: 12, 13: o, 14: h, 17: 15, 18: l, 21: d, 22: 40, 23: p, 24: 19, 25: 20, 26: 21, 27: 22, 28: 23, 29: g, 30: f, 31: y, 33: m, 35: x, 36: b, 37: v, 38: _, 39: A, 41: S, 43: k, 44: L, 46: T, 50: C, 52: E, 53: w, 55: W, 60: N, 61: B, 62: R, 63: V, 71: $ }, e(D, [2, 5]), { 9: 47, 12: 12, 13: o, 14: h, 17: 15, 18: l, 21: d, 22: 40, 23: p, 24: 19, 25: 20, 26: 21, 27: 22, 28: 23, 29: g, 30: f, 31: y, 33: m, 35: x, 36: b, 37: v, 38: _, 39: A, 41: S, 43: k, 44: L, 46: T, 50: C, 52: E, 53: w, 55: W, 60: N, 61: B, 62: R, 63: V, 71: $ }, e(D, [2, 7]), e(D, [2, 8]), e(D, [2, 14]), { 12: 48, 50: C, 52: E, 53: w }, { 15: [1, 49] }, { 5: [1, 50] }, { 5: [1, 53], 19: [1, 51], 20: [1, 52] }, { 22: 54, 71: $ }, { 22: 55, 71: $ }, { 5: [1, 56] }, { 5: [1, 57] }, { 5: [1, 58] }, { 5: [1, 59] }, { 5: [1, 60] }, e(D, [2, 29]), e(D, [2, 30]), { 32: [1, 61] }, { 34: [1, 62] }, e(D, [2, 33]), { 15: [1, 63] }, { 15: [1, 64] }, { 15: [1, 65] }, { 15: [1, 66] }, { 15: [1, 67] }, { 15: [1, 68] }, { 15: [1, 69] }, { 15: [1, 70] }, { 22: 71, 54: 72, 71: [1, 73] }, { 22: 74, 71: $ }, { 22: 75, 71: $ }, { 68: 76, 76: [1, 77], 77: [1, 78], 78: [1, 79], 79: [1, 80], 80: [1, 81], 81: [1, 82], 82: [1, 83], 83: [1, 84], 84: [1, 85], 85: [1, 86] }, { 56: 87, 58: [1, 88], 66: [1, 89], 67: [1, 90] }, { 22: 91, 71: $ }, { 22: 92, 71: $ }, { 22: 93, 71: $ }, { 22: 94, 71: $ }, e([5, 51, 65, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86], O), e(D, [2, 6]), e(D, [2, 15]), e(Y, [2, 9], { 10: 95 }), e(D, [2, 17]), { 5: [1, 97], 19: [1, 96] }, { 5: [1, 98] }, e(D, [2, 21]), { 5: [1, 99] }, { 5: [1, 100] }, e(D, [2, 24]), e(D, [2, 25]), e(D, [2, 26]), e(D, [2, 27]), e(D, [2, 28]), e(D, [2, 31]), e(D, [2, 32]), e(M, s, { 7: 101 }), e(M, s, { 7: 102 }), e(M, s, { 7: 103 }), e(G, s, { 40: 104, 7: 105 }), e(rt, s, { 42: 106, 7: 107 }), e(rt, s, { 7: 107, 42: 108 }), e(ht, s, { 45: 109, 7: 110 }), e(M, s, { 7: 111 }), { 5: [1, 113], 51: [1, 112] }, { 5: [1, 114] }, e([5, 51], O, { 72: 115, 73: [1, 116] }), { 5: [1, 118], 51: [1, 117] }, { 5: [1, 119] }, { 22: 122, 69: [1, 120], 70: [1, 121], 71: $ }, e(Z, [2, 72]), e(Z, [2, 73]), e(Z, [2, 74]), e(Z, [2, 75]), e(Z, [2, 76]), e(Z, [2, 77]), e(Z, [2, 78]), e(Z, [2, 79]), e(Z, [2, 80]), e(Z, [2, 81]), { 22: 123, 71: $ }, { 22: 125, 59: 124, 71: $ }, { 71: [2, 64] }, { 71: [2, 65] }, { 57: 126, 86: ot }, { 57: 128, 86: ot }, { 57: 129, 86: ot }, { 57: 130, 86: ot }, { 4: [1, 133], 5: [1, 135], 11: 132, 12: 134, 16: [1, 131], 50: C, 52: E, 53: w }, { 5: [1, 136] }, e(D, [2, 19]), e(D, [2, 20]), e(D, [2, 22]), e(D, [2, 23]), { 4: a, 5: n, 8: 8, 9: 10, 12: 12, 13: o, 14: h, 16: [1, 137], 17: 15, 18: l, 21: d, 22: 40, 23: p, 24: 19, 25: 20, 26: 21, 27: 22, 28: 23, 29: g, 30: f, 31: y, 33: m, 35: x, 36: b, 37: v, 38: _, 39: A, 41: S, 43: k, 44: L, 46: T, 50: C, 52: E, 53: w, 55: W, 60: N, 61: B, 62: R, 63: V, 71: $ }, { 4: a, 5: n, 8: 8, 9: 10, 12: 12, 13: o, 14: h, 16: [1, 138], 17: 15, 18: l, 21: d, 22: 40, 23: p, 24: 19, 25: 20, 26: 21, 27: 22, 28: 23, 29: g, 30: f, 31: y, 33: m, 35: x, 36: b, 37: v, 38: _, 39: A, 41: S, 43: k, 44: L, 46: T, 50: C, 52: E, 53: w, 55: W, 60: N, 61: B, 62: R, 63: V, 71: $ }, { 4: a, 5: n, 8: 8, 9: 10, 12: 12, 13: o, 14: h, 16: [1, 139], 17: 15, 18: l, 21: d, 22: 40, 23: p, 24: 19, 25: 20, 26: 21, 27: 22, 28: 23, 29: g, 30: f, 31: y, 33: m, 35: x, 36: b, 37: v, 38: _, 39: A, 41: S, 43: k, 44: L, 46: T, 50: C, 52: E, 53: w, 55: W, 60: N, 61: B, 62: R, 63: V, 71: $ }, { 16: [1, 140] }, { 4: a, 5: n, 8: 8, 9: 10, 12: 12, 13: o, 14: h, 16: [2, 46], 17: 15, 18: l, 21: d, 22: 40, 23: p, 24: 19, 25: 20, 26: 21, 27: 22, 28: 23, 29: g, 30: f, 31: y, 33: m, 35: x, 36: b, 37: v, 38: _, 39: A, 41: S, 43: k, 44: L, 46: T, 49: [1, 141], 50: C, 52: E, 53: w, 55: W, 60: N, 61: B, 62: R, 63: V, 71: $ }, { 16: [1, 142] }, { 4: a, 5: n, 8: 8, 9: 10, 12: 12, 13: o, 14: h, 16: [2, 44], 17: 15, 18: l, 21: d, 22: 40, 23: p, 24: 19, 25: 20, 26: 21, 27: 22, 28: 23, 29: g, 30: f, 31: y, 33: m, 35: x, 36: b, 37: v, 38: _, 39: A, 41: S, 43: k, 44: L, 46: T, 48: [1, 143], 50: C, 52: E, 53: w, 55: W, 60: N, 61: B, 62: R, 63: V, 71: $ }, { 16: [1, 144] }, { 16: [1, 145] }, { 4: a, 5: n, 8: 8, 9: 10, 12: 12, 13: o, 14: h, 16: [2, 42], 17: 15, 18: l, 21: d, 22: 40, 23: p, 24: 19, 25: 20, 26: 21, 27: 22, 28: 23, 29: g, 30: f, 31: y, 33: m, 35: x, 36: b, 37: v, 38: _, 39: A, 41: S, 43: k, 44: L, 46: T, 47: [1, 146], 50: C, 52: E, 53: w, 55: W, 60: N, 61: B, 62: R, 63: V, 71: $ }, { 4: a, 5: n, 8: 8, 9: 10, 12: 12, 13: o, 14: h, 16: [1, 147], 17: 15, 18: l, 21: d, 22: 40, 23: p, 24: 19, 25: 20, 26: 21, 27: 22, 28: 23, 29: g, 30: f, 31: y, 33: m, 35: x, 36: b, 37: v, 38: _, 39: A, 41: S, 43: k, 44: L, 46: T, 50: C, 52: E, 53: w, 55: W, 60: N, 61: B, 62: R, 63: V, 71: $ }, { 15: [1, 148] }, e(D, [2, 49]), e(D, [2, 53]), { 5: [2, 69] }, { 74: [1, 149] }, { 15: [1, 150] }, e(D, [2, 51]), e(D, [2, 52]), { 22: 151, 71: $ }, { 22: 152, 71: $ }, { 57: 153, 86: ot }, { 57: 154, 86: ot }, { 57: 155, 86: ot }, { 65: [1, 156], 86: [2, 63] }, { 5: [2, 56] }, { 5: [2, 82] }, { 5: [2, 57] }, { 5: [2, 58] }, { 5: [2, 59] }, e(D, [2, 16]), e(Y, [2, 10]), { 12: 157, 50: C, 52: E, 53: w }, e(Y, [2, 12]), e(Y, [2, 13]), e(D, [2, 18]), e(D, [2, 34]), e(D, [2, 35]), e(D, [2, 36]), e(D, [2, 37]), { 15: [1, 158] }, e(D, [2, 38]), { 15: [1, 159] }, e(D, [2, 39]), e(D, [2, 40]), { 15: [1, 160] }, e(D, [2, 41]), { 5: [1, 161] }, { 75: [1, 162] }, { 5: [1, 163] }, { 57: 164, 86: ot }, { 57: 165, 86: ot }, { 5: [2, 68] }, { 5: [2, 54] }, { 5: [2, 55] }, { 22: 166, 71: $ }, e(Y, [2, 11]), e(G, s, { 7: 105, 40: 167 }), e(rt, s, { 7: 107, 42: 168 }), e(ht, s, { 7: 110, 45: 169 }), e(D, [2, 48]), { 5: [2, 70] }, e(D, [2, 50]), { 5: [2, 66] }, { 5: [2, 67] }, { 86: [2, 62] }, { 16: [2, 47] }, { 16: [2, 45] }, { 16: [2, 43] }],
    defaultActions: { 5: [2, 1], 6: [2, 2], 89: [2, 64], 90: [2, 65], 115: [2, 69], 126: [2, 56], 127: [2, 82], 128: [2, 57], 129: [2, 58], 130: [2, 59], 153: [2, 68], 154: [2, 54], 155: [2, 55], 162: [2, 70], 164: [2, 66], 165: [2, 67], 166: [2, 62], 167: [2, 47], 168: [2, 45], 169: [2, 43] },
    parseError: /* @__PURE__ */ u(function(at, lt) {
      if (lt.recoverable)
        this.trace(at);
      else {
        var Q = new Error(at);
        throw Q.hash = lt, Q;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ u(function(at) {
      var lt = this, Q = [0], U = [], et = [null], z = [], Tt = this.table, F = "", te = 0, J = 0, Ut = 2, Wt = 1, ie = z.slice.call(arguments, 1), dt = Object.create(this.lexer), wt = { yy: {} };
      for (var nt in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, nt) && (wt.yy[nt] = this.yy[nt]);
      dt.setInput(at, wt.yy), wt.yy.lexer = dt, wt.yy.parser = this, typeof dt.yylloc > "u" && (dt.yylloc = {});
      var ut = dt.yylloc;
      z.push(ut);
      var kt = dt.options && dt.options.ranges;
      typeof wt.yy.parseError == "function" ? this.parseError = wt.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function X(ue) {
        Q.length = Q.length - 2 * ue, et.length = et.length - ue, z.length = z.length - ue;
      }
      u(X, "popStack");
      function ft() {
        var ue;
        return ue = U.pop() || dt.lex() || Wt, typeof ue != "number" && (ue instanceof Array && (U = ue, ue = U.pop()), ue = lt.symbols_[ue] || ue), ue;
      }
      u(ft, "lex");
      for (var P, At, q, vt, ct = {}, Nt, pt, gt, Jt; ; ) {
        if (At = Q[Q.length - 1], this.defaultActions[At] ? q = this.defaultActions[At] : ((P === null || typeof P > "u") && (P = ft()), q = Tt[At] && Tt[At][P]), typeof q > "u" || !q.length || !q[0]) {
          var Et = "";
          Jt = [];
          for (Nt in Tt[At])
            this.terminals_[Nt] && Nt > Ut && Jt.push("'" + this.terminals_[Nt] + "'");
          dt.showPosition ? Et = "Parse error on line " + (te + 1) + `:
` + dt.showPosition() + `
Expecting ` + Jt.join(", ") + ", got '" + (this.terminals_[P] || P) + "'" : Et = "Parse error on line " + (te + 1) + ": Unexpected " + (P == Wt ? "end of input" : "'" + (this.terminals_[P] || P) + "'"), this.parseError(Et, {
            text: dt.match,
            token: this.terminals_[P] || P,
            line: dt.yylineno,
            loc: ut,
            expected: Jt
          });
        }
        if (q[0] instanceof Array && q.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + At + ", token: " + P);
        switch (q[0]) {
          case 1:
            Q.push(P), et.push(dt.yytext), z.push(dt.yylloc), Q.push(q[1]), P = null, J = dt.yyleng, F = dt.yytext, te = dt.yylineno, ut = dt.yylloc;
            break;
          case 2:
            if (pt = this.productions_[q[1]][1], ct.$ = et[et.length - pt], ct._$ = {
              first_line: z[z.length - (pt || 1)].first_line,
              last_line: z[z.length - 1].last_line,
              first_column: z[z.length - (pt || 1)].first_column,
              last_column: z[z.length - 1].last_column
            }, kt && (ct._$.range = [
              z[z.length - (pt || 1)].range[0],
              z[z.length - 1].range[1]
            ]), vt = this.performAction.apply(ct, [
              F,
              J,
              te,
              wt.yy,
              q[1],
              et,
              z
            ].concat(ie)), typeof vt < "u")
              return vt;
            pt && (Q = Q.slice(0, -1 * pt * 2), et = et.slice(0, -1 * pt), z = z.slice(0, -1 * pt)), Q.push(this.productions_[q[1]][0]), et.push(ct.$), z.push(ct._$), gt = Tt[Q[Q.length - 2]][Q[Q.length - 1]], Q.push(gt);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, bt = /* @__PURE__ */ function() {
    var Ct = {
      EOF: 1,
      parseError: /* @__PURE__ */ u(function(lt, Q) {
        if (this.yy.parser)
          this.yy.parser.parseError(lt, Q);
        else
          throw new Error(lt);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ u(function(at, lt) {
        return this.yy = lt || this.yy || {}, this._input = at, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ u(function() {
        var at = this._input[0];
        this.yytext += at, this.yyleng++, this.offset++, this.match += at, this.matched += at;
        var lt = at.match(/(?:\r\n?|\n).*/g);
        return lt ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), at;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ u(function(at) {
        var lt = at.length, Q = at.split(/(?:\r\n?|\n)/g);
        this._input = at + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - lt), this.offset -= lt;
        var U = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), Q.length - 1 && (this.yylineno -= Q.length - 1);
        var et = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: Q ? (Q.length === U.length ? this.yylloc.first_column : 0) + U[U.length - Q.length].length - Q[0].length : this.yylloc.first_column - lt
        }, this.options.ranges && (this.yylloc.range = [et[0], et[0] + this.yyleng - lt]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ u(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ u(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ u(function(at) {
        this.unput(this.match.slice(at));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ u(function() {
        var at = this.matched.substr(0, this.matched.length - this.match.length);
        return (at.length > 20 ? "..." : "") + at.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ u(function() {
        var at = this.match;
        return at.length < 20 && (at += this._input.substr(0, 20 - at.length)), (at.substr(0, 20) + (at.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ u(function() {
        var at = this.pastInput(), lt = new Array(at.length + 1).join("-");
        return at + this.upcomingInput() + `
` + lt + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ u(function(at, lt) {
        var Q, U, et;
        if (this.options.backtrack_lexer && (et = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (et.yylloc.range = this.yylloc.range.slice(0))), U = at[0].match(/(?:\r\n?|\n).*/g), U && (this.yylineno += U.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: U ? U[U.length - 1].length - U[U.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + at[0].length
        }, this.yytext += at[0], this.match += at[0], this.matches = at, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(at[0].length), this.matched += at[0], Q = this.performAction.call(this, this.yy, this, lt, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), Q)
          return Q;
        if (this._backtrack) {
          for (var z in et)
            this[z] = et[z];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ u(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var at, lt, Q, U;
        this._more || (this.yytext = "", this.match = "");
        for (var et = this._currentRules(), z = 0; z < et.length; z++)
          if (Q = this._input.match(this.rules[et[z]]), Q && (!lt || Q[0].length > lt[0].length)) {
            if (lt = Q, U = z, this.options.backtrack_lexer) {
              if (at = this.test_match(Q, et[z]), at !== !1)
                return at;
              if (this._backtrack) {
                lt = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return lt ? (at = this.test_match(lt, et[U]), at !== !1 ? at : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ u(function() {
        var lt = this.next();
        return lt || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ u(function(lt) {
        this.conditionStack.push(lt);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ u(function() {
        var lt = this.conditionStack.length - 1;
        return lt > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ u(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ u(function(lt) {
        return lt = this.conditionStack.length - 1 - Math.abs(lt || 0), lt >= 0 ? this.conditionStack[lt] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ u(function(lt) {
        this.begin(lt);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ u(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: { "case-insensitive": !0 },
      performAction: /* @__PURE__ */ u(function(lt, Q, U, et) {
        switch (U) {
          case 0:
            return 5;
          case 1:
            break;
          case 2:
            break;
          case 3:
            break;
          case 4:
            break;
          case 5:
            break;
          case 6:
            return 19;
          case 7:
            return this.begin("CONFIG"), 73;
          case 8:
            return 74;
          case 9:
            return this.popState(), this.popState(), 75;
          case 10:
            return Q.yytext = Q.yytext.trim(), 71;
          case 11:
            return Q.yytext = Q.yytext.trim(), this.begin("ALIAS"), 71;
          case 12:
            return this.begin("LINE"), 14;
          case 13:
            return this.begin("ID"), 50;
          case 14:
            return this.begin("ID"), 52;
          case 15:
            return 13;
          case 16:
            return this.begin("ID"), 53;
          case 17:
            return Q.yytext = Q.yytext.trim(), this.begin("ALIAS"), 71;
          case 18:
            return this.popState(), this.popState(), this.begin("LINE"), 51;
          case 19:
            return this.popState(), this.popState(), 5;
          case 20:
            return this.begin("LINE"), 36;
          case 21:
            return this.begin("LINE"), 37;
          case 22:
            return this.begin("LINE"), 38;
          case 23:
            return this.begin("LINE"), 39;
          case 24:
            return this.begin("LINE"), 49;
          case 25:
            return this.begin("LINE"), 41;
          case 26:
            return this.begin("LINE"), 43;
          case 27:
            return this.begin("LINE"), 48;
          case 28:
            return this.begin("LINE"), 44;
          case 29:
            return this.begin("LINE"), 47;
          case 30:
            return this.begin("LINE"), 46;
          case 31:
            return this.popState(), 15;
          case 32:
            return 16;
          case 33:
            return 66;
          case 34:
            return 67;
          case 35:
            return 60;
          case 36:
            return 61;
          case 37:
            return 62;
          case 38:
            return 63;
          case 39:
            return 58;
          case 40:
            return 55;
          case 41:
            return this.begin("ID"), 21;
          case 42:
            return this.begin("ID"), 23;
          case 43:
            return 29;
          case 44:
            return 30;
          case 45:
            return this.begin("acc_title"), 31;
          case 46:
            return this.popState(), "acc_title_value";
          case 47:
            return this.begin("acc_descr"), 33;
          case 48:
            return this.popState(), "acc_descr_value";
          case 49:
            this.begin("acc_descr_multiline");
            break;
          case 50:
            this.popState();
            break;
          case 51:
            return "acc_descr_multiline_value";
          case 52:
            return 6;
          case 53:
            return 18;
          case 54:
            return 20;
          case 55:
            return 65;
          case 56:
            return 5;
          case 57:
            return Q.yytext = Q.yytext.trim(), 71;
          case 58:
            return 78;
          case 59:
            return 79;
          case 60:
            return 80;
          case 61:
            return 81;
          case 62:
            return 76;
          case 63:
            return 77;
          case 64:
            return 82;
          case 65:
            return 83;
          case 66:
            return 84;
          case 67:
            return 85;
          case 68:
            return 86;
          case 69:
            return 86;
          case 70:
            return 69;
          case 71:
            return 70;
          case 72:
            return 5;
          case 73:
            return "INVALID";
        }
      }, "anonymous"),
      rules: [/^(?:[\n]+)/i, /^(?:\s+)/i, /^(?:((?!\n)\s)+)/i, /^(?:#[^\n]*)/i, /^(?:%(?!\{)[^\n]*)/i, /^(?:[^\}]%%[^\n]*)/i, /^(?:[0-9]+(?=[ \n]+))/i, /^(?:@\{)/i, /^(?:[^\}]+)/i, /^(?:\})/i, /^(?:[^\<->\->:\n,;@\s]+(?=@\{))/i, /^(?:[^\<->\->:\n,;@]+?([\-]*[^\<->\->:\n,;@]+?)*?(?=((?!\n)\s)+as(?!\n)\s|[#\n;]|$))/i, /^(?:box\b)/i, /^(?:participant\b)/i, /^(?:actor\b)/i, /^(?:create\b)/i, /^(?:destroy\b)/i, /^(?:[^<\->\->:\n,;]+?([\-]*[^<\->\->:\n,;]+?)*?(?=((?!\n)\s)+as(?!\n)\s|[#\n;]|$))/i, /^(?:as\b)/i, /^(?:(?:))/i, /^(?:loop\b)/i, /^(?:rect\b)/i, /^(?:opt\b)/i, /^(?:alt\b)/i, /^(?:else\b)/i, /^(?:par\b)/i, /^(?:par_over\b)/i, /^(?:and\b)/i, /^(?:critical\b)/i, /^(?:option\b)/i, /^(?:break\b)/i, /^(?:(?:[:]?(?:no)?wrap)?[^#\n;]*)/i, /^(?:end\b)/i, /^(?:left of\b)/i, /^(?:right of\b)/i, /^(?:links\b)/i, /^(?:link\b)/i, /^(?:properties\b)/i, /^(?:details\b)/i, /^(?:over\b)/i, /^(?:note\b)/i, /^(?:activate\b)/i, /^(?:deactivate\b)/i, /^(?:title\s[^#\n;]+)/i, /^(?:title:\s[^#\n;]+)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:sequenceDiagram\b)/i, /^(?:autonumber\b)/i, /^(?:off\b)/i, /^(?:,)/i, /^(?:;)/i, /^(?:[^+<\->\->:\n,;]+((?!(-x|--x|-\)|--\)))[\-]*[^\+<\->\->:\n,;]+)*)/i, /^(?:->>)/i, /^(?:<<->>)/i, /^(?:-->>)/i, /^(?:<<-->>)/i, /^(?:->)/i, /^(?:-->)/i, /^(?:-[x])/i, /^(?:--[x])/i, /^(?:-[\)])/i, /^(?:--[\)])/i, /^(?::(?:(?:no)?wrap)?[^#\n;]*)/i, /^(?::)/i, /^(?:\+)/i, /^(?:-)/i, /^(?:$)/i, /^(?:.)/i],
      conditions: { acc_descr_multiline: { rules: [50, 51], inclusive: !1 }, acc_descr: { rules: [48], inclusive: !1 }, acc_title: { rules: [46], inclusive: !1 }, ID: { rules: [2, 3, 7, 10, 11, 17], inclusive: !1 }, ALIAS: { rules: [2, 3, 18, 19], inclusive: !1 }, LINE: { rules: [2, 3, 31], inclusive: !1 }, CONFIG: { rules: [8, 9], inclusive: !1 }, CONFIG_DATA: { rules: [], inclusive: !1 }, INITIAL: { rules: [0, 1, 3, 4, 5, 6, 12, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 47, 49, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73], inclusive: !0 } }
    };
    return Ct;
  }();
  it.lexer = bt;
  function xt() {
    this.yy = {};
  }
  return u(xt, "Parser"), xt.prototype = it, it.Parser = xt, new xt();
}();
ac.parser = ac;
var hw = ac, uw = {
  SOLID: 0,
  DOTTED: 1,
  NOTE: 2,
  SOLID_CROSS: 3,
  DOTTED_CROSS: 4,
  SOLID_OPEN: 5,
  DOTTED_OPEN: 6,
  LOOP_START: 10,
  LOOP_END: 11,
  ALT_START: 12,
  ALT_ELSE: 13,
  ALT_END: 14,
  OPT_START: 15,
  OPT_END: 16,
  ACTIVE_START: 17,
  ACTIVE_END: 18,
  PAR_START: 19,
  PAR_AND: 20,
  PAR_END: 21,
  RECT_START: 22,
  RECT_END: 23,
  SOLID_POINT: 24,
  DOTTED_POINT: 25,
  AUTONUMBER: 26,
  CRITICAL_START: 27,
  CRITICAL_OPTION: 28,
  CRITICAL_END: 29,
  BREAK_START: 30,
  BREAK_END: 31,
  PAR_OVER_START: 32,
  BIDIRECTIONAL_SOLID: 33,
  BIDIRECTIONAL_DOTTED: 34
}, dw = {
  FILLED: 0,
  OPEN: 1
}, pw = {
  LEFTOF: 0,
  RIGHTOF: 1,
  OVER: 2
}, En = {
  ACTOR: "actor",
  CONTROL: "control",
  DATABASE: "database",
  ENTITY: "entity"
}, ra, gw = (ra = class {
  constructor() {
    this.state = new Nf(() => ({
      prevActor: void 0,
      actors: /* @__PURE__ */ new Map(),
      createdActors: /* @__PURE__ */ new Map(),
      destroyedActors: /* @__PURE__ */ new Map(),
      boxes: [],
      messages: [],
      notes: [],
      sequenceNumbersEnabled: !1,
      wrapEnabled: void 0,
      currentBox: void 0,
      lastCreated: void 0,
      lastDestroyed: void 0
    })), this.setAccTitle = Re, this.setAccDescription = Ye, this.setDiagramTitle = Ge, this.getAccTitle = qe, this.getAccDescription = He, this.getDiagramTitle = Oe, this.apply = this.apply.bind(this), this.parseBoxData = this.parseBoxData.bind(this), this.parseMessage = this.parseMessage.bind(this), this.clear(), this.setWrap(K().wrap), this.LINETYPE = uw, this.ARROWTYPE = dw, this.PLACEMENT = pw;
  }
  addBox(t) {
    this.state.records.boxes.push({
      name: t.text,
      wrap: t.wrap ?? this.autoWrap(),
      fill: t.color,
      actorKeys: []
    }), this.state.records.currentBox = this.state.records.boxes.slice(-1)[0];
  }
  addActor(t, r, i, s, a) {
    let n = this.state.records.currentBox, o;
    if (a !== void 0) {
      let l;
      a.includes(`
`) ? l = a + `
` : l = `{
` + a + `
}`, o = Io(l, { schema: Do });
    }
    s = (o == null ? void 0 : o.type) ?? s;
    const h = this.state.records.actors.get(t);
    if (h) {
      if (this.state.records.currentBox && h.box && this.state.records.currentBox !== h.box)
        throw new Error(
          `A same participant should only be defined in one Box: ${h.name} can't be in '${h.box.name}' and in '${this.state.records.currentBox.name}' at the same time.`
        );
      if (n = h.box ? h.box : this.state.records.currentBox, h.box = n, h && r === h.name && i == null)
        return;
    }
    if ((i == null ? void 0 : i.text) == null && (i = { text: r, type: s }), (s == null || i.text == null) && (i = { text: r, type: s }), this.state.records.actors.set(t, {
      box: n,
      name: r,
      description: i.text,
      wrap: i.wrap ?? this.autoWrap(),
      prevActor: this.state.records.prevActor,
      links: {},
      properties: {},
      actorCnt: null,
      rectData: null,
      type: s ?? "participant"
    }), this.state.records.prevActor) {
      const l = this.state.records.actors.get(this.state.records.prevActor);
      l && (l.nextActor = t);
    }
    this.state.records.currentBox && this.state.records.currentBox.actorKeys.push(t), this.state.records.prevActor = t;
  }
  activationCount(t) {
    let r, i = 0;
    if (!t)
      return 0;
    for (r = 0; r < this.state.records.messages.length; r++)
      this.state.records.messages[r].type === this.LINETYPE.ACTIVE_START && this.state.records.messages[r].from === t && i++, this.state.records.messages[r].type === this.LINETYPE.ACTIVE_END && this.state.records.messages[r].from === t && i--;
    return i;
  }
  addMessage(t, r, i, s) {
    this.state.records.messages.push({
      id: this.state.records.messages.length.toString(),
      from: t,
      to: r,
      message: i.text,
      wrap: i.wrap ?? this.autoWrap(),
      answer: s
    });
  }
  addSignal(t, r, i, s, a = !1) {
    if (s === this.LINETYPE.ACTIVE_END && this.activationCount(t ?? "") < 1) {
      const o = new Error("Trying to inactivate an inactive participant (" + t + ")");
      throw o.hash = {
        text: "->>-",
        token: "->>-",
        line: "1",
        loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
        expected: ["'ACTIVE_PARTICIPANT'"]
      }, o;
    }
    return this.state.records.messages.push({
      id: this.state.records.messages.length.toString(),
      from: t,
      to: r,
      message: (i == null ? void 0 : i.text) ?? "",
      wrap: (i == null ? void 0 : i.wrap) ?? this.autoWrap(),
      type: s,
      activate: a
    }), !0;
  }
  hasAtLeastOneBox() {
    return this.state.records.boxes.length > 0;
  }
  hasAtLeastOneBoxWithTitle() {
    return this.state.records.boxes.some((t) => t.name);
  }
  getMessages() {
    return this.state.records.messages;
  }
  getBoxes() {
    return this.state.records.boxes;
  }
  getActors() {
    return this.state.records.actors;
  }
  getCreatedActors() {
    return this.state.records.createdActors;
  }
  getDestroyedActors() {
    return this.state.records.destroyedActors;
  }
  getActor(t) {
    return this.state.records.actors.get(t);
  }
  getActorKeys() {
    return [...this.state.records.actors.keys()];
  }
  enableSequenceNumbers() {
    this.state.records.sequenceNumbersEnabled = !0;
  }
  disableSequenceNumbers() {
    this.state.records.sequenceNumbersEnabled = !1;
  }
  showSequenceNumbers() {
    return this.state.records.sequenceNumbersEnabled;
  }
  setWrap(t) {
    this.state.records.wrapEnabled = t;
  }
  extractWrap(t) {
    if (t === void 0)
      return {};
    t = t.trim();
    const r = /^:?wrap:/.exec(t) !== null ? !0 : /^:?nowrap:/.exec(t) !== null ? !1 : void 0;
    return { cleanedText: (r === void 0 ? t : t.replace(/^:?(?:no)?wrap:/, "")).trim(), wrap: r };
  }
  autoWrap() {
    var t;
    return this.state.records.wrapEnabled !== void 0 ? this.state.records.wrapEnabled : ((t = K().sequence) == null ? void 0 : t.wrap) ?? !1;
  }
  clear() {
    this.state.reset(), Me();
  }
  parseMessage(t) {
    const r = t.trim(), { wrap: i, cleanedText: s } = this.extractWrap(r), a = {
      text: s,
      wrap: i
    };
    return I.debug(`parseMessage: ${JSON.stringify(a)}`), a;
  }
  // We expect the box statement to be color first then description
  // The color can be rgb,rgba,hsl,hsla, or css code names  #hex codes are not supported for now because of the way the char # is handled
  // We extract first segment as color, the rest of the line is considered as text
  parseBoxData(t) {
    const r = /^((?:rgba?|hsla?)\s*\(.*\)|\w*)(.*)$/.exec(t);
    let i = r != null && r[1] ? r[1].trim() : "transparent", s = r != null && r[2] ? r[2].trim() : void 0;
    if (window != null && window.CSS)
      window.CSS.supports("color", i) || (i = "transparent", s = t.trim());
    else {
      const o = new Option().style;
      o.color = i, o.color !== i && (i = "transparent", s = t.trim());
    }
    const { wrap: a, cleanedText: n } = this.extractWrap(s);
    return {
      text: n ? ge(n, K()) : void 0,
      color: i,
      wrap: a
    };
  }
  addNote(t, r, i) {
    const s = {
      actor: t,
      placement: r,
      message: i.text,
      wrap: i.wrap ?? this.autoWrap()
    }, a = [].concat(t, t);
    this.state.records.notes.push(s), this.state.records.messages.push({
      id: this.state.records.messages.length.toString(),
      from: a[0],
      to: a[1],
      message: i.text,
      wrap: i.wrap ?? this.autoWrap(),
      type: this.LINETYPE.NOTE,
      placement: r
    });
  }
  addLinks(t, r) {
    const i = this.getActor(t);
    try {
      let s = ge(r.text, K());
      s = s.replace(/&equals;/g, "="), s = s.replace(/&amp;/g, "&");
      const a = JSON.parse(s);
      this.insertLinks(i, a);
    } catch (s) {
      I.error("error while parsing actor link text", s);
    }
  }
  addALink(t, r) {
    const i = this.getActor(t);
    try {
      const s = {};
      let a = ge(r.text, K());
      const n = a.indexOf("@");
      a = a.replace(/&equals;/g, "="), a = a.replace(/&amp;/g, "&");
      const o = a.slice(0, n - 1).trim(), h = a.slice(n + 1).trim();
      s[o] = h, this.insertLinks(i, s);
    } catch (s) {
      I.error("error while parsing actor link text", s);
    }
  }
  insertLinks(t, r) {
    if (t.links == null)
      t.links = r;
    else
      for (const i in r)
        t.links[i] = r[i];
  }
  addProperties(t, r) {
    const i = this.getActor(t);
    try {
      const s = ge(r.text, K()), a = JSON.parse(s);
      this.insertProperties(i, a);
    } catch (s) {
      I.error("error while parsing actor properties text", s);
    }
  }
  insertProperties(t, r) {
    if (t.properties == null)
      t.properties = r;
    else
      for (const i in r)
        t.properties[i] = r[i];
  }
  boxEnd() {
    this.state.records.currentBox = void 0;
  }
  addDetails(t, r) {
    const i = this.getActor(t), s = document.getElementById(r.text);
    try {
      const a = s.innerHTML, n = JSON.parse(a);
      n.properties && this.insertProperties(i, n.properties), n.links && this.insertLinks(i, n.links);
    } catch (a) {
      I.error("error while parsing actor details text", a);
    }
  }
  getActorProperty(t, r) {
    if ((t == null ? void 0 : t.properties) !== void 0)
      return t.properties[r];
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-redundant-type-constituents
  apply(t) {
    if (Array.isArray(t))
      t.forEach((r) => {
        this.apply(r);
      });
    else
      switch (t.type) {
        case "sequenceIndex":
          this.state.records.messages.push({
            id: this.state.records.messages.length.toString(),
            from: void 0,
            to: void 0,
            message: {
              start: t.sequenceIndex,
              step: t.sequenceIndexStep,
              visible: t.sequenceVisible
            },
            wrap: !1,
            type: t.signalType
          });
          break;
        case "addParticipant":
          this.addActor(t.actor, t.actor, t.description, t.draw, t.config);
          break;
        case "createParticipant":
          if (this.state.records.actors.has(t.actor))
            throw new Error(
              "It is not possible to have actors with the same id, even if one is destroyed before the next is created. Use 'AS' aliases to simulate the behavior"
            );
          this.state.records.lastCreated = t.actor, this.addActor(t.actor, t.actor, t.description, t.draw, t.config), this.state.records.createdActors.set(t.actor, this.state.records.messages.length);
          break;
        case "destroyParticipant":
          this.state.records.lastDestroyed = t.actor, this.state.records.destroyedActors.set(t.actor, this.state.records.messages.length);
          break;
        case "activeStart":
          this.addSignal(t.actor, void 0, void 0, t.signalType);
          break;
        case "activeEnd":
          this.addSignal(t.actor, void 0, void 0, t.signalType);
          break;
        case "addNote":
          this.addNote(t.actor, t.placement, t.text);
          break;
        case "addLinks":
          this.addLinks(t.actor, t.text);
          break;
        case "addALink":
          this.addALink(t.actor, t.text);
          break;
        case "addProperties":
          this.addProperties(t.actor, t.text);
          break;
        case "addDetails":
          this.addDetails(t.actor, t.text);
          break;
        case "addMessage":
          if (this.state.records.lastCreated) {
            if (t.to !== this.state.records.lastCreated)
              throw new Error(
                "The created participant " + this.state.records.lastCreated.name + " does not have an associated creating message after its declaration. Please check the sequence diagram."
              );
            this.state.records.lastCreated = void 0;
          } else if (this.state.records.lastDestroyed) {
            if (t.to !== this.state.records.lastDestroyed && t.from !== this.state.records.lastDestroyed)
              throw new Error(
                "The destroyed participant " + this.state.records.lastDestroyed.name + " does not have an associated destroying message after its declaration. Please check the sequence diagram."
              );
            this.state.records.lastDestroyed = void 0;
          }
          this.addSignal(t.from, t.to, t.msg, t.signalType, t.activate);
          break;
        case "boxStart":
          this.addBox(t.boxData);
          break;
        case "boxEnd":
          this.boxEnd();
          break;
        case "loopStart":
          this.addSignal(void 0, void 0, t.loopText, t.signalType);
          break;
        case "loopEnd":
          this.addSignal(void 0, void 0, void 0, t.signalType);
          break;
        case "rectStart":
          this.addSignal(void 0, void 0, t.color, t.signalType);
          break;
        case "rectEnd":
          this.addSignal(void 0, void 0, void 0, t.signalType);
          break;
        case "optStart":
          this.addSignal(void 0, void 0, t.optText, t.signalType);
          break;
        case "optEnd":
          this.addSignal(void 0, void 0, void 0, t.signalType);
          break;
        case "altStart":
          this.addSignal(void 0, void 0, t.altText, t.signalType);
          break;
        case "else":
          this.addSignal(void 0, void 0, t.altText, t.signalType);
          break;
        case "altEnd":
          this.addSignal(void 0, void 0, void 0, t.signalType);
          break;
        case "setAccTitle":
          Re(t.text);
          break;
        case "parStart":
          this.addSignal(void 0, void 0, t.parText, t.signalType);
          break;
        case "and":
          this.addSignal(void 0, void 0, t.parText, t.signalType);
          break;
        case "parEnd":
          this.addSignal(void 0, void 0, void 0, t.signalType);
          break;
        case "criticalStart":
          this.addSignal(void 0, void 0, t.criticalText, t.signalType);
          break;
        case "option":
          this.addSignal(void 0, void 0, t.optionText, t.signalType);
          break;
        case "criticalEnd":
          this.addSignal(void 0, void 0, void 0, t.signalType);
          break;
        case "breakStart":
          this.addSignal(void 0, void 0, t.breakText, t.signalType);
          break;
        case "breakEnd":
          this.addSignal(void 0, void 0, void 0, t.signalType);
          break;
      }
  }
  getConfig() {
    return K().sequence;
  }
}, u(ra, "SequenceDB"), ra), fw = /* @__PURE__ */ u((e) => `.actor {
    stroke: ${e.actorBorder};
    fill: ${e.actorBkg};
  }

  text.actor > tspan {
    fill: ${e.actorTextColor};
    stroke: none;
  }

  .actor-line {
    stroke: ${e.actorLineColor};
  }
  
  .innerArc {
    stroke-width: 1.5;
    stroke-dasharray: none;
  }

  .messageLine0 {
    stroke-width: 1.5;
    stroke-dasharray: none;
    stroke: ${e.signalColor};
  }

  .messageLine1 {
    stroke-width: 1.5;
    stroke-dasharray: 2, 2;
    stroke: ${e.signalColor};
  }

  #arrowhead path {
    fill: ${e.signalColor};
    stroke: ${e.signalColor};
  }

  .sequenceNumber {
    fill: ${e.sequenceNumberColor};
  }

  #sequencenumber {
    fill: ${e.signalColor};
  }

  #crosshead path {
    fill: ${e.signalColor};
    stroke: ${e.signalColor};
  }

  .messageText {
    fill: ${e.signalTextColor};
    stroke: none;
  }

  .labelBox {
    stroke: ${e.labelBoxBorderColor};
    fill: ${e.labelBoxBkgColor};
  }

  .labelText, .labelText > tspan {
    fill: ${e.labelTextColor};
    stroke: none;
  }

  .loopText, .loopText > tspan {
    fill: ${e.loopTextColor};
    stroke: none;
  }

  .loopLine {
    stroke-width: 2px;
    stroke-dasharray: 2, 2;
    stroke: ${e.labelBoxBorderColor};
    fill: ${e.labelBoxBorderColor};
  }

  .note {
    //stroke: #decc93;
    stroke: ${e.noteBorderColor};
    fill: ${e.noteBkgColor};
  }

  .noteText, .noteText > tspan {
    fill: ${e.noteTextColor};
    stroke: none;
  }

  .activation0 {
    fill: ${e.activationBkgColor};
    stroke: ${e.activationBorderColor};
  }

  .activation1 {
    fill: ${e.activationBkgColor};
    stroke: ${e.activationBorderColor};
  }

  .activation2 {
    fill: ${e.activationBkgColor};
    stroke: ${e.activationBorderColor};
  }

  .actorPopupMenu {
    position: absolute;
  }

  .actorPopupMenuPanel {
    position: absolute;
    fill: ${e.actorBkg};
    box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
    filter: drop-shadow(3px 5px 2px rgb(0 0 0 / 0.4));
}
  .actor-man line {
    stroke: ${e.actorBorder};
    fill: ${e.actorBkg};
  }
  .actor-man circle, line {
    stroke: ${e.actorBorder};
    fill: ${e.actorBkg};
    stroke-width: 2px;
  }

`, "getStyles"), yw = fw, Qi = 18 * 2, Pi = "actor-top", $i = "actor-bottom", Yo = "actor-box", Ii = "actor-man", an = /* @__PURE__ */ u(function(e, t) {
  return $o(e, t);
}, "drawRect"), mw = /* @__PURE__ */ u(function(e, t, r, i, s) {
  if (t.links === void 0 || t.links === null || Object.keys(t.links).length === 0)
    return { height: 0, width: 0 };
  const a = t.links, n = t.actorCnt, o = t.rectData;
  var h = "none";
  s && (h = "block !important");
  const l = e.append("g");
  l.attr("id", "actor" + n + "_popup"), l.attr("class", "actorPopupMenu"), l.attr("display", h);
  var d = "";
  o.class !== void 0 && (d = " " + o.class);
  let p = o.width > r ? o.width : r;
  const g = l.append("rect");
  if (g.attr("class", "actorPopupMenuPanel" + d), g.attr("x", o.x), g.attr("y", o.height), g.attr("fill", o.fill), g.attr("stroke", o.stroke), g.attr("width", p), g.attr("height", o.height), g.attr("rx", o.rx), g.attr("ry", o.ry), a != null) {
    var f = 20;
    for (let x in a) {
      var y = l.append("a"), m = ns(a[x]);
      y.attr("xlink:href", m), y.attr("target", "_blank"), $w(i)(
        x,
        y,
        o.x + 10,
        o.height + f,
        p,
        20,
        { class: "actor" },
        i
      ), f += 30;
    }
  }
  return g.attr("height", f), { height: o.height + f, width: p };
}, "drawPopup"), Ho = /* @__PURE__ */ u(function(e) {
  return "var pu = document.getElementById('" + e + "'); if (pu != null) { pu.style.display = pu.style.display == 'block' ? 'none' : 'block'; }";
}, "popupMenuToggle"), fo = /* @__PURE__ */ u(async function(e, t, r = null) {
  let i = e.append("foreignObject");
  const s = await un(t.text, fe()), n = i.append("xhtml:div").attr("style", "width: fit-content;").attr("xmlns", "http://www.w3.org/1999/xhtml").html(s).node().getBoundingClientRect();
  if (i.attr("height", Math.round(n.height)).attr("width", Math.round(n.width)), t.class === "noteText") {
    const o = e.node().firstChild;
    o.setAttribute("height", n.height + 2 * t.textMargin);
    const h = o.getBBox();
    i.attr("x", Math.round(h.x + h.width / 2 - n.width / 2)).attr("y", Math.round(h.y + h.height / 2 - n.height / 2));
  } else if (r) {
    let { startx: o, stopx: h, starty: l } = r;
    if (o > h) {
      const d = o;
      o = h, h = d;
    }
    i.attr("x", Math.round(o + Math.abs(o - h) / 2 - n.width / 2)), t.class === "loopText" ? i.attr("y", Math.round(l)) : i.attr("y", Math.round(l - n.height));
  }
  return [i];
}, "drawKatex"), ma = /* @__PURE__ */ u(function(e, t) {
  let r = 0, i = 0;
  const s = t.text.split(St.lineBreakRegex), [a, n] = ls(t.fontSize);
  let o = [], h = 0, l = /* @__PURE__ */ u(() => t.y, "yfunc");
  if (t.valign !== void 0 && t.textMargin !== void 0 && t.textMargin > 0)
    switch (t.valign) {
      case "top":
      case "start":
        l = /* @__PURE__ */ u(() => Math.round(t.y + t.textMargin), "yfunc");
        break;
      case "middle":
      case "center":
        l = /* @__PURE__ */ u(() => Math.round(t.y + (r + i + t.textMargin) / 2), "yfunc");
        break;
      case "bottom":
      case "end":
        l = /* @__PURE__ */ u(() => Math.round(
          t.y + (r + i + 2 * t.textMargin) - t.textMargin
        ), "yfunc");
        break;
    }
  if (t.anchor !== void 0 && t.textMargin !== void 0 && t.width !== void 0)
    switch (t.anchor) {
      case "left":
      case "start":
        t.x = Math.round(t.x + t.textMargin), t.anchor = "start", t.dominantBaseline = "middle", t.alignmentBaseline = "middle";
        break;
      case "middle":
      case "center":
        t.x = Math.round(t.x + t.width / 2), t.anchor = "middle", t.dominantBaseline = "middle", t.alignmentBaseline = "middle";
        break;
      case "right":
      case "end":
        t.x = Math.round(t.x + t.width - t.textMargin), t.anchor = "end", t.dominantBaseline = "middle", t.alignmentBaseline = "middle";
        break;
    }
  for (let [d, p] of s.entries()) {
    t.textMargin !== void 0 && t.textMargin === 0 && a !== void 0 && (h = d * a);
    const g = e.append("text");
    g.attr("x", t.x), g.attr("y", l()), t.anchor !== void 0 && g.attr("text-anchor", t.anchor).attr("dominant-baseline", t.dominantBaseline).attr("alignment-baseline", t.alignmentBaseline), t.fontFamily !== void 0 && g.style("font-family", t.fontFamily), n !== void 0 && g.style("font-size", n), t.fontWeight !== void 0 && g.style("font-weight", t.fontWeight), t.fill !== void 0 && g.attr("fill", t.fill), t.class !== void 0 && g.attr("class", t.class), t.dy !== void 0 ? g.attr("dy", t.dy) : h !== 0 && g.attr("dy", h);
    const f = p || k0;
    if (t.tspan) {
      const y = g.append("tspan");
      y.attr("x", t.x), t.fill !== void 0 && y.attr("fill", t.fill), y.text(f);
    } else
      g.text(f);
    t.valign !== void 0 && t.textMargin !== void 0 && t.textMargin > 0 && (i += (g._groups || g)[0][0].getBBox().height, r = i), o.push(g);
  }
  return o;
}, "drawText"), B2 = /* @__PURE__ */ u(function(e, t) {
  function r(s, a, n, o, h) {
    return s + "," + a + " " + (s + n) + "," + a + " " + (s + n) + "," + (a + o - h) + " " + (s + n - h * 1.2) + "," + (a + o) + " " + s + "," + (a + o);
  }
  u(r, "genPoints");
  const i = e.append("polygon");
  return i.attr("points", r(t.x, t.y, t.width, t.height, 7)), i.attr("class", "labelBox"), t.y = t.y + t.height / 2, ma(e, t), i;
}, "drawLabel"), he = -1, D2 = /* @__PURE__ */ u((e, t, r, i) => {
  e.select && r.forEach((s) => {
    const a = t.get(s), n = e.select("#actor" + a.actorCnt);
    !i.mirrorActors && a.stopy ? n.attr("y2", a.stopy + a.height / 2) : i.mirrorActors && n.attr("y2", a.stopy);
  });
}, "fixLifeLineHeights"), xw = /* @__PURE__ */ u(function(e, t, r, i) {
  var f, y;
  const s = i ? t.stopy : t.starty, a = t.x + t.width / 2, n = s + t.height, o = e.append("g").lower();
  var h = o;
  i || (he++, Object.keys(t.links || {}).length && !r.forceMenus && h.attr("onclick", Ho(`actor${he}_popup`)).attr("cursor", "pointer"), h.append("line").attr("id", "actor" + he).attr("x1", a).attr("y1", n).attr("x2", a).attr("y2", 2e3).attr("class", "actor-line 200").attr("stroke-width", "0.5px").attr("stroke", "#999").attr("name", t.name), h = o.append("g"), t.actorCnt = he, t.links != null && h.attr("id", "root-" + he));
  const l = Er();
  var d = "actor";
  (f = t.properties) != null && f.class ? d = t.properties.class : l.fill = "#eaeaea", i ? d += ` ${$i}` : d += ` ${Pi}`, l.x = t.x, l.y = s, l.width = t.width, l.height = t.height, l.class = d, l.rx = 3, l.ry = 3, l.name = t.name;
  const p = an(h, l);
  if (t.rectData = l, (y = t.properties) != null && y.icon) {
    const m = t.properties.icon.trim();
    m.charAt(0) === "@" ? eh(h, l.x + l.width - 20, l.y + 10, m.substr(1)) : th(h, l.x + l.width - 20, l.y + 10, m);
  }
  bi(r, Ee(t.description))(
    t.description,
    h,
    l.x,
    l.y,
    l.width,
    l.height,
    { class: `actor ${Yo}` },
    r
  );
  let g = t.height;
  if (p.node) {
    const m = p.node().getBBox();
    t.height = m.height, g = m.height;
  }
  return g;
}, "drawActorTypeParticipant"), bw = /* @__PURE__ */ u(function(e, t, r, i) {
  var m, x;
  const s = i ? t.stopy : t.starty, a = t.x + t.width / 2, n = s + t.height, o = e.append("g").lower();
  var h = o;
  i || (he++, Object.keys(t.links || {}).length && !r.forceMenus && h.attr("onclick", Ho(`actor${he}_popup`)).attr("cursor", "pointer"), h.append("line").attr("id", "actor" + he).attr("x1", a).attr("y1", n).attr("x2", a).attr("y2", 2e3).attr("class", "actor-line 200").attr("stroke-width", "0.5px").attr("stroke", "#999").attr("name", t.name), h = o.append("g"), t.actorCnt = he, t.links != null && h.attr("id", "root-" + he));
  const l = Er();
  var d = "actor";
  (m = t.properties) != null && m.class ? d = t.properties.class : l.fill = "#eaeaea", i ? d += ` ${$i}` : d += ` ${Pi}`, l.x = t.x, l.y = s, l.width = t.width, l.height = t.height, l.class = d, l.name = t.name;
  const p = 6, g = {
    ...l,
    x: l.x + -6,
    y: l.y + 6,
    class: "actor"
  }, f = an(h, l);
  if (an(h, g), t.rectData = l, (x = t.properties) != null && x.icon) {
    const b = t.properties.icon.trim();
    b.charAt(0) === "@" ? eh(h, l.x + l.width - 20, l.y + 10, b.substr(1)) : th(h, l.x + l.width - 20, l.y + 10, b);
  }
  bi(r, Ee(t.description))(
    t.description,
    h,
    l.x - p,
    l.y + p,
    l.width,
    l.height,
    { class: `actor ${Yo}` },
    r
  );
  let y = t.height;
  if (f.node) {
    const b = f.node().getBBox();
    t.height = b.height, y = b.height;
  }
  return y;
}, "drawActorTypeCollections"), kw = /* @__PURE__ */ u(function(e, t, r, i) {
  var b, v;
  const s = i ? t.stopy : t.starty, a = t.x + t.width / 2, n = s + t.height, o = e.append("g").lower();
  let h = o;
  i || (he++, Object.keys(t.links || {}).length && !r.forceMenus && h.attr("onclick", Ho(`actor${he}_popup`)).attr("cursor", "pointer"), h.append("line").attr("id", "actor" + he).attr("x1", a).attr("y1", n).attr("x2", a).attr("y2", 2e3).attr("class", "actor-line 200").attr("stroke-width", "0.5px").attr("stroke", "#999").attr("name", t.name), h = o.append("g"), t.actorCnt = he, t.links != null && h.attr("id", "root-" + he));
  const l = Er();
  let d = "actor";
  (b = t.properties) != null && b.class ? d = t.properties.class : l.fill = "#eaeaea", i ? d += ` ${$i}` : d += ` ${Pi}`, l.x = t.x, l.y = s, l.width = t.width, l.height = t.height, l.class = d, l.name = t.name;
  const p = l.height / 2, g = p / (2.5 + l.height / 50), f = h.append("g"), y = h.append("g");
  if (f.append("path").attr(
    "d",
    `M ${l.x},${l.y + p}
    a ${g},${p} 0 0 0 0,${l.height}
    h ${l.width - 2 * g}
    a ${g},${p} 0 0 0 0,-${l.height}
    Z
  `
  ).attr("class", d), y.append("path").attr(
    "d",
    `M ${l.x},${l.y + p}
      a ${g},${p} 0 0 0 0,${l.height}`
  ).attr("stroke", "#666").attr("stroke-width", "1px").attr("class", d), f.attr("transform", `translate(${g}, ${-(l.height / 2)})`), y.attr("transform", `translate(${l.width - g}, ${-l.height / 2})`), t.rectData = l, (v = t.properties) != null && v.icon) {
    const _ = t.properties.icon.trim(), A = l.x + l.width - 20, S = l.y + 10;
    _.charAt(0) === "@" ? eh(h, A, S, _.substr(1)) : th(h, A, S, _);
  }
  bi(r, Ee(t.description))(
    t.description,
    h,
    l.x,
    l.y,
    l.width,
    l.height,
    { class: `actor ${Yo}` },
    r
  );
  let m = t.height;
  const x = f.select("path:last-child");
  if (x.node()) {
    const _ = x.node().getBBox();
    t.height = _.height, m = _.height;
  }
  return m;
}, "drawActorTypeQueue"), vw = /* @__PURE__ */ u(function(e, t, r, i) {
  var m;
  const s = i ? t.stopy : t.starty, a = t.x + t.width / 2, n = s + 75, o = e.append("g").lower();
  i || (he++, o.append("line").attr("id", "actor" + he).attr("x1", a).attr("y1", n).attr("x2", a).attr("y2", 2e3).attr("class", "actor-line 200").attr("stroke-width", "0.5px").attr("stroke", "#999").attr("name", t.name), t.actorCnt = he);
  const h = e.append("g");
  let l = Ii;
  i ? l += ` ${$i}` : l += ` ${Pi}`, h.attr("class", l), h.attr("name", t.name);
  const d = Er();
  d.x = t.x, d.y = s, d.fill = "#eaeaea", d.width = t.width, d.height = t.height, d.class = "actor";
  const p = t.x + t.width / 2, g = s + 30, f = 18;
  h.append("defs").append("marker").attr("id", "filled-head-control").attr("refX", 11).attr("refY", 5.8).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "172.5").append("path").attr("d", "M 14.4 5.6 L 7.2 10.4 L 8.8 5.6 L 7.2 0.8 Z"), h.append("circle").attr("cx", p).attr("cy", g).attr("r", f).attr("fill", "#eaeaf7").attr("stroke", "#666").attr("stroke-width", 1.2), h.append("line").attr("marker-end", "url(#filled-head-control)").attr("transform", `translate(${p}, ${g - f})`);
  const y = h.node().getBBox();
  return t.height = y.height + 2 * (((m = r == null ? void 0 : r.sequence) == null ? void 0 : m.labelBoxHeight) ?? 0), bi(r, Ee(t.description))(
    t.description,
    h,
    d.x,
    d.y + f + (i ? 5 : 10),
    d.width,
    d.height,
    { class: `actor ${Ii}` },
    r
  ), t.height;
}, "drawActorTypeControl"), Sw = /* @__PURE__ */ u(function(e, t, r, i) {
  var m;
  const s = i ? t.stopy : t.starty, a = t.x + t.width / 2, n = s + 75, o = e.append("g").lower(), h = e.append("g");
  let l = Ii;
  i ? l += ` ${$i}` : l += ` ${Pi}`, h.attr("class", l), h.attr("name", t.name);
  const d = Er();
  d.x = t.x, d.y = s, d.fill = "#eaeaea", d.width = t.width, d.height = t.height, d.class = "actor";
  const p = t.x + t.width / 2, g = s + (i ? 10 : 25), f = 18;
  h.append("circle").attr("cx", p).attr("cy", g).attr("r", f).attr("width", t.width).attr("height", t.height), h.append("line").attr("x1", p - f).attr("x2", p + f).attr("y1", g + f).attr("y2", g + f).attr("stroke", "#333").attr("stroke-width", 2);
  const y = h.node().getBBox();
  return t.height = y.height + (((m = r == null ? void 0 : r.sequence) == null ? void 0 : m.labelBoxHeight) ?? 0), i || (he++, o.append("line").attr("id", "actor" + he).attr("x1", a).attr("y1", n).attr("x2", a).attr("y2", 2e3).attr("class", "actor-line 200").attr("stroke-width", "0.5px").attr("stroke", "#999").attr("name", t.name), t.actorCnt = he), bi(r, Ee(t.description))(
    t.description,
    h,
    d.x,
    d.y + (i ? (g - s + f - 5) / 2 : (g + f - s) / 2),
    d.width,
    d.height,
    { class: `actor ${Ii}` },
    r
  ), i ? h.attr("transform", `translate(0, ${f / 2})`) : h.attr("transform", `translate(0, ${f / 2})`), t.height;
}, "drawActorTypeEntity"), Cw = /* @__PURE__ */ u(function(e, t, r, i) {
  var v;
  const s = i ? t.stopy : t.starty, a = t.x + t.width / 2, n = s + t.height + 2 * r.boxTextMargin, o = e.append("g").lower();
  let h = o;
  i || (he++, Object.keys(t.links || {}).length && !r.forceMenus && h.attr("onclick", Ho(`actor${he}_popup`)).attr("cursor", "pointer"), h.append("line").attr("id", "actor" + he).attr("x1", a).attr("y1", n).attr("x2", a).attr("y2", 2e3).attr("class", "actor-line 200").attr("stroke-width", "0.5px").attr("stroke", "#999").attr("name", t.name), h = o.append("g"), t.actorCnt = he, t.links != null && h.attr("id", "root-" + he));
  const l = Er();
  let d = "actor";
  (v = t.properties) != null && v.class ? d = t.properties.class : l.fill = "#eaeaea", i ? d += ` ${$i}` : d += ` ${Pi}`, l.x = t.x, l.y = s, l.width = t.width, l.height = t.height, l.class = d, l.name = t.name, l.x = t.x, l.y = s;
  const p = l.width / 4, g = l.width / 4, f = p / 2, y = f / (2.5 + p / 50), m = h.append("g"), x = `
  M ${l.x},${l.y + y}
  a ${f},${y} 0 0 0 ${p},0
  a ${f},${y} 0 0 0 -${p},0
  l 0,${g - 2 * y}
  a ${f},${y} 0 0 0 ${p},0
  l 0,-${g - 2 * y}
`;
  m.append("path").attr("d", x).attr("fill", "#eaeaea").attr("stroke", "#000").attr("stroke-width", 1).attr("class", d), i ? m.attr("transform", `translate(${p * 1.5}, ${l.height / 4 - 2 * y})`) : m.attr("transform", `translate(${p * 1.5}, ${(l.height + y) / 4})`), t.rectData = l, bi(r, Ee(t.description))(
    t.description,
    h,
    l.x,
    l.y + (i ? (l.height + g) / 4 : (l.height + y) / 2),
    l.width,
    l.height,
    { class: `actor ${Yo}` },
    r
  );
  const b = m.select("path:last-child");
  if (b.node()) {
    const _ = b.node().getBBox();
    t.height = _.height + (r.sequence.labelBoxHeight ?? 0);
  }
  return t.height;
}, "drawActorTypeDatabase"), ww = /* @__PURE__ */ u(function(e, t, r, i) {
  const s = i ? t.stopy : t.starty, a = t.x + t.width / 2, n = s + 80, o = 30, h = e.append("g").lower();
  i || (he++, h.append("line").attr("id", "actor" + he).attr("x1", a).attr("y1", n).attr("x2", a).attr("y2", 2e3).attr("class", "actor-line 200").attr("stroke-width", "0.5px").attr("stroke", "#999").attr("name", t.name), t.actorCnt = he);
  const l = e.append("g");
  let d = Ii;
  i ? d += ` ${$i}` : d += ` ${Pi}`, l.attr("class", d), l.attr("name", t.name);
  const p = Er();
  p.x = t.x, p.y = s, p.fill = "#eaeaea", p.width = t.width, p.height = t.height, p.class = "actor", l.append("line").attr("id", "actor-man-torso" + he).attr("x1", t.x + t.width / 2 - o * 2.5).attr("y1", s + 10).attr("x2", t.x + t.width / 2 - 15).attr("y2", s + 10), l.append("line").attr("id", "actor-man-arms" + he).attr("x1", t.x + t.width / 2 - o * 2.5).attr("y1", s + 0).attr("x2", t.x + t.width / 2 - o * 2.5).attr("y2", s + 20), l.append("circle").attr("cx", t.x + t.width / 2).attr("cy", s + 10).attr("r", o);
  const g = l.node().getBBox();
  return t.height = g.height + (r.sequence.labelBoxHeight ?? 0), bi(r, Ee(t.description))(
    t.description,
    l,
    p.x,
    p.y + (i ? o / 2 - 4 : o / 2 + 3),
    p.width,
    p.height,
    { class: `actor ${Ii}` },
    r
  ), i ? l.attr("transform", `translate(0,${o / 2 + 7})`) : l.attr("transform", `translate(0,${o / 2 + 7})`), t.height;
}, "drawActorTypeBoundary"), Tw = /* @__PURE__ */ u(function(e, t, r, i) {
  const s = i ? t.stopy : t.starty, a = t.x + t.width / 2, n = s + 80, o = e.append("g").lower();
  i || (he++, o.append("line").attr("id", "actor" + he).attr("x1", a).attr("y1", n).attr("x2", a).attr("y2", 2e3).attr("class", "actor-line 200").attr("stroke-width", "0.5px").attr("stroke", "#999").attr("name", t.name), t.actorCnt = he);
  const h = e.append("g");
  let l = Ii;
  i ? l += ` ${$i}` : l += ` ${Pi}`, h.attr("class", l), h.attr("name", t.name);
  const d = Er();
  d.x = t.x, d.y = s, d.fill = "#eaeaea", d.width = t.width, d.height = t.height, d.class = "actor", d.rx = 3, d.ry = 3, h.append("line").attr("id", "actor-man-torso" + he).attr("x1", a).attr("y1", s + 25).attr("x2", a).attr("y2", s + 45), h.append("line").attr("id", "actor-man-arms" + he).attr("x1", a - Qi / 2).attr("y1", s + 33).attr("x2", a + Qi / 2).attr("y2", s + 33), h.append("line").attr("x1", a - Qi / 2).attr("y1", s + 60).attr("x2", a).attr("y2", s + 45), h.append("line").attr("x1", a).attr("y1", s + 45).attr("x2", a + Qi / 2 - 2).attr("y2", s + 60);
  const p = h.append("circle");
  p.attr("cx", t.x + t.width / 2), p.attr("cy", s + 10), p.attr("r", 15), p.attr("width", t.width), p.attr("height", t.height);
  const g = h.node().getBBox();
  return t.height = g.height, bi(r, Ee(t.description))(
    t.description,
    h,
    d.x,
    d.y + 35,
    d.width,
    d.height,
    { class: `actor ${Ii}` },
    r
  ), t.height;
}, "drawActorTypeActor"), _w = /* @__PURE__ */ u(async function(e, t, r, i) {
  switch (t.type) {
    case "actor":
      return await Tw(e, t, r, i);
    case "participant":
      return await xw(e, t, r, i);
    case "boundary":
      return await ww(e, t, r, i);
    case "control":
      return await vw(e, t, r, i);
    case "entity":
      return await Sw(e, t, r, i);
    case "database":
      return await Cw(e, t, r, i);
    case "collections":
      return await bw(e, t, r, i);
    case "queue":
      return await kw(e, t, r, i);
  }
}, "drawActor"), Ew = /* @__PURE__ */ u(function(e, t, r) {
  const s = e.append("g");
  I2(s, t), t.name && bi(r)(
    t.name,
    s,
    t.x,
    t.y + r.boxTextMargin + (t.textMaxHeight || 0) / 2,
    t.width,
    0,
    { class: "text" },
    r
  ), s.lower();
}, "drawBox"), Aw = /* @__PURE__ */ u(function(e) {
  return e.append("g");
}, "anchorElement"), Lw = /* @__PURE__ */ u(function(e, t, r, i, s) {
  const a = Er(), n = t.anchored;
  a.x = t.startx, a.y = t.starty, a.class = "activation" + s % 3, a.width = t.stopx - t.startx, a.height = r - t.starty, an(n, a);
}, "drawActivation"), Bw = /* @__PURE__ */ u(async function(e, t, r, i) {
  const {
    boxMargin: s,
    boxTextMargin: a,
    labelBoxHeight: n,
    labelBoxWidth: o,
    messageFontFamily: h,
    messageFontSize: l,
    messageFontWeight: d
  } = i, p = e.append("g"), g = /* @__PURE__ */ u(function(m, x, b, v) {
    return p.append("line").attr("x1", m).attr("y1", x).attr("x2", b).attr("y2", v).attr("class", "loopLine");
  }, "drawLoopLine");
  g(t.startx, t.starty, t.stopx, t.starty), g(t.stopx, t.starty, t.stopx, t.stopy), g(t.startx, t.stopy, t.stopx, t.stopy), g(t.startx, t.starty, t.startx, t.stopy), t.sections !== void 0 && t.sections.forEach(function(m) {
    g(t.startx, m.y, t.stopx, m.y).style(
      "stroke-dasharray",
      "3, 3"
    );
  });
  let f = rh();
  f.text = r, f.x = t.startx, f.y = t.starty, f.fontFamily = h, f.fontSize = l, f.fontWeight = d, f.anchor = "middle", f.valign = "middle", f.tspan = !1, f.width = o || 50, f.height = n || 20, f.textMargin = a, f.class = "labelText", B2(p, f), f = F2(), f.text = t.title, f.x = t.startx + o / 2 + (t.stopx - t.startx) / 2, f.y = t.starty + s + a, f.anchor = "middle", f.valign = "middle", f.textMargin = a, f.class = "loopText", f.fontFamily = h, f.fontSize = l, f.fontWeight = d, f.wrap = !0;
  let y = Ee(f.text) ? await fo(p, f, t) : ma(p, f);
  if (t.sectionTitles !== void 0) {
    for (const [m, x] of Object.entries(t.sectionTitles))
      if (x.message) {
        f.text = x.message, f.x = t.startx + (t.stopx - t.startx) / 2, f.y = t.sections[m].y + s + a, f.class = "loopText", f.anchor = "middle", f.valign = "middle", f.tspan = !1, f.fontFamily = h, f.fontSize = l, f.fontWeight = d, f.wrap = t.wrap, Ee(f.text) ? (t.starty = t.sections[m].y, await fo(p, f, t)) : ma(p, f);
        let b = Math.round(
          y.map((v) => (v._groups || v)[0][0].getBBox().height).reduce((v, _) => v + _)
        );
        t.sections[m].height += b - (s + a);
      }
  }
  return t.height = Math.round(t.stopy - t.starty), p;
}, "drawLoop"), I2 = /* @__PURE__ */ u(function(e, t) {
  Sf(e, t);
}, "drawBackgroundRect"), Dw = /* @__PURE__ */ u(function(e) {
  e.append("defs").append("symbol").attr("id", "database").attr("fill-rule", "evenodd").attr("clip-rule", "evenodd").append("path").attr("transform", "scale(.5)").attr(
    "d",
    "M12.258.001l.256.004.255.005.253.008.251.01.249.012.247.015.246.016.242.019.241.02.239.023.236.024.233.027.231.028.229.031.225.032.223.034.22.036.217.038.214.04.211.041.208.043.205.045.201.046.198.048.194.05.191.051.187.053.183.054.18.056.175.057.172.059.168.06.163.061.16.063.155.064.15.066.074.033.073.033.071.034.07.034.069.035.068.035.067.035.066.035.064.036.064.036.062.036.06.036.06.037.058.037.058.037.055.038.055.038.053.038.052.038.051.039.05.039.048.039.047.039.045.04.044.04.043.04.041.04.04.041.039.041.037.041.036.041.034.041.033.042.032.042.03.042.029.042.027.042.026.043.024.043.023.043.021.043.02.043.018.044.017.043.015.044.013.044.012.044.011.045.009.044.007.045.006.045.004.045.002.045.001.045v17l-.001.045-.002.045-.004.045-.006.045-.007.045-.009.044-.011.045-.012.044-.013.044-.015.044-.017.043-.018.044-.02.043-.021.043-.023.043-.024.043-.026.043-.027.042-.029.042-.03.042-.032.042-.033.042-.034.041-.036.041-.037.041-.039.041-.04.041-.041.04-.043.04-.044.04-.045.04-.047.039-.048.039-.05.039-.051.039-.052.038-.053.038-.055.038-.055.038-.058.037-.058.037-.06.037-.06.036-.062.036-.064.036-.064.036-.066.035-.067.035-.068.035-.069.035-.07.034-.071.034-.073.033-.074.033-.15.066-.155.064-.16.063-.163.061-.168.06-.172.059-.175.057-.18.056-.183.054-.187.053-.191.051-.194.05-.198.048-.201.046-.205.045-.208.043-.211.041-.214.04-.217.038-.22.036-.223.034-.225.032-.229.031-.231.028-.233.027-.236.024-.239.023-.241.02-.242.019-.246.016-.247.015-.249.012-.251.01-.253.008-.255.005-.256.004-.258.001-.258-.001-.256-.004-.255-.005-.253-.008-.251-.01-.249-.012-.247-.015-.245-.016-.243-.019-.241-.02-.238-.023-.236-.024-.234-.027-.231-.028-.228-.031-.226-.032-.223-.034-.22-.036-.217-.038-.214-.04-.211-.041-.208-.043-.204-.045-.201-.046-.198-.048-.195-.05-.19-.051-.187-.053-.184-.054-.179-.056-.176-.057-.172-.059-.167-.06-.164-.061-.159-.063-.155-.064-.151-.066-.074-.033-.072-.033-.072-.034-.07-.034-.069-.035-.068-.035-.067-.035-.066-.035-.064-.036-.063-.036-.062-.036-.061-.036-.06-.037-.058-.037-.057-.037-.056-.038-.055-.038-.053-.038-.052-.038-.051-.039-.049-.039-.049-.039-.046-.039-.046-.04-.044-.04-.043-.04-.041-.04-.04-.041-.039-.041-.037-.041-.036-.041-.034-.041-.033-.042-.032-.042-.03-.042-.029-.042-.027-.042-.026-.043-.024-.043-.023-.043-.021-.043-.02-.043-.018-.044-.017-.043-.015-.044-.013-.044-.012-.044-.011-.045-.009-.044-.007-.045-.006-.045-.004-.045-.002-.045-.001-.045v-17l.001-.045.002-.045.004-.045.006-.045.007-.045.009-.044.011-.045.012-.044.013-.044.015-.044.017-.043.018-.044.02-.043.021-.043.023-.043.024-.043.026-.043.027-.042.029-.042.03-.042.032-.042.033-.042.034-.041.036-.041.037-.041.039-.041.04-.041.041-.04.043-.04.044-.04.046-.04.046-.039.049-.039.049-.039.051-.039.052-.038.053-.038.055-.038.056-.038.057-.037.058-.037.06-.037.061-.036.062-.036.063-.036.064-.036.066-.035.067-.035.068-.035.069-.035.07-.034.072-.034.072-.033.074-.033.151-.066.155-.064.159-.063.164-.061.167-.06.172-.059.176-.057.179-.056.184-.054.187-.053.19-.051.195-.05.198-.048.201-.046.204-.045.208-.043.211-.041.214-.04.217-.038.22-.036.223-.034.226-.032.228-.031.231-.028.234-.027.236-.024.238-.023.241-.02.243-.019.245-.016.247-.015.249-.012.251-.01.253-.008.255-.005.256-.004.258-.001.258.001zm-9.258 20.499v.01l.001.021.003.021.004.022.005.021.006.022.007.022.009.023.01.022.011.023.012.023.013.023.015.023.016.024.017.023.018.024.019.024.021.024.022.025.023.024.024.025.052.049.056.05.061.051.066.051.07.051.075.051.079.052.084.052.088.052.092.052.097.052.102.051.105.052.11.052.114.051.119.051.123.051.127.05.131.05.135.05.139.048.144.049.147.047.152.047.155.047.16.045.163.045.167.043.171.043.176.041.178.041.183.039.187.039.19.037.194.035.197.035.202.033.204.031.209.03.212.029.216.027.219.025.222.024.226.021.23.02.233.018.236.016.24.015.243.012.246.01.249.008.253.005.256.004.259.001.26-.001.257-.004.254-.005.25-.008.247-.011.244-.012.241-.014.237-.016.233-.018.231-.021.226-.021.224-.024.22-.026.216-.027.212-.028.21-.031.205-.031.202-.034.198-.034.194-.036.191-.037.187-.039.183-.04.179-.04.175-.042.172-.043.168-.044.163-.045.16-.046.155-.046.152-.047.148-.048.143-.049.139-.049.136-.05.131-.05.126-.05.123-.051.118-.052.114-.051.11-.052.106-.052.101-.052.096-.052.092-.052.088-.053.083-.051.079-.052.074-.052.07-.051.065-.051.06-.051.056-.05.051-.05.023-.024.023-.025.021-.024.02-.024.019-.024.018-.024.017-.024.015-.023.014-.024.013-.023.012-.023.01-.023.01-.022.008-.022.006-.022.006-.022.004-.022.004-.021.001-.021.001-.021v-4.127l-.077.055-.08.053-.083.054-.085.053-.087.052-.09.052-.093.051-.095.05-.097.05-.1.049-.102.049-.105.048-.106.047-.109.047-.111.046-.114.045-.115.045-.118.044-.12.043-.122.042-.124.042-.126.041-.128.04-.13.04-.132.038-.134.038-.135.037-.138.037-.139.035-.142.035-.143.034-.144.033-.147.032-.148.031-.15.03-.151.03-.153.029-.154.027-.156.027-.158.026-.159.025-.161.024-.162.023-.163.022-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.011-.178.01-.179.008-.179.008-.181.006-.182.005-.182.004-.184.003-.184.002h-.37l-.184-.002-.184-.003-.182-.004-.182-.005-.181-.006-.179-.008-.179-.008-.178-.01-.176-.011-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.022-.162-.023-.161-.024-.159-.025-.157-.026-.156-.027-.155-.027-.153-.029-.151-.03-.15-.03-.148-.031-.146-.032-.145-.033-.143-.034-.141-.035-.14-.035-.137-.037-.136-.037-.134-.038-.132-.038-.13-.04-.128-.04-.126-.041-.124-.042-.122-.042-.12-.044-.117-.043-.116-.045-.113-.045-.112-.046-.109-.047-.106-.047-.105-.048-.102-.049-.1-.049-.097-.05-.095-.05-.093-.052-.09-.051-.087-.052-.085-.053-.083-.054-.08-.054-.077-.054v4.127zm0-5.654v.011l.001.021.003.021.004.021.005.022.006.022.007.022.009.022.01.022.011.023.012.023.013.023.015.024.016.023.017.024.018.024.019.024.021.024.022.024.023.025.024.024.052.05.056.05.061.05.066.051.07.051.075.052.079.051.084.052.088.052.092.052.097.052.102.052.105.052.11.051.114.051.119.052.123.05.127.051.131.05.135.049.139.049.144.048.147.048.152.047.155.046.16.045.163.045.167.044.171.042.176.042.178.04.183.04.187.038.19.037.194.036.197.034.202.033.204.032.209.03.212.028.216.027.219.025.222.024.226.022.23.02.233.018.236.016.24.014.243.012.246.01.249.008.253.006.256.003.259.001.26-.001.257-.003.254-.006.25-.008.247-.01.244-.012.241-.015.237-.016.233-.018.231-.02.226-.022.224-.024.22-.025.216-.027.212-.029.21-.03.205-.032.202-.033.198-.035.194-.036.191-.037.187-.039.183-.039.179-.041.175-.042.172-.043.168-.044.163-.045.16-.045.155-.047.152-.047.148-.048.143-.048.139-.05.136-.049.131-.05.126-.051.123-.051.118-.051.114-.052.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.051.07-.052.065-.051.06-.05.056-.051.051-.049.023-.025.023-.024.021-.025.02-.024.019-.024.018-.024.017-.024.015-.023.014-.023.013-.024.012-.022.01-.023.01-.023.008-.022.006-.022.006-.022.004-.021.004-.022.001-.021.001-.021v-4.139l-.077.054-.08.054-.083.054-.085.052-.087.053-.09.051-.093.051-.095.051-.097.05-.1.049-.102.049-.105.048-.106.047-.109.047-.111.046-.114.045-.115.044-.118.044-.12.044-.122.042-.124.042-.126.041-.128.04-.13.039-.132.039-.134.038-.135.037-.138.036-.139.036-.142.035-.143.033-.144.033-.147.033-.148.031-.15.03-.151.03-.153.028-.154.028-.156.027-.158.026-.159.025-.161.024-.162.023-.163.022-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.011-.178.009-.179.009-.179.007-.181.007-.182.005-.182.004-.184.003-.184.002h-.37l-.184-.002-.184-.003-.182-.004-.182-.005-.181-.007-.179-.007-.179-.009-.178-.009-.176-.011-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.022-.162-.023-.161-.024-.159-.025-.157-.026-.156-.027-.155-.028-.153-.028-.151-.03-.15-.03-.148-.031-.146-.033-.145-.033-.143-.033-.141-.035-.14-.036-.137-.036-.136-.037-.134-.038-.132-.039-.13-.039-.128-.04-.126-.041-.124-.042-.122-.043-.12-.043-.117-.044-.116-.044-.113-.046-.112-.046-.109-.046-.106-.047-.105-.048-.102-.049-.1-.049-.097-.05-.095-.051-.093-.051-.09-.051-.087-.053-.085-.052-.083-.054-.08-.054-.077-.054v4.139zm0-5.666v.011l.001.02.003.022.004.021.005.022.006.021.007.022.009.023.01.022.011.023.012.023.013.023.015.023.016.024.017.024.018.023.019.024.021.025.022.024.023.024.024.025.052.05.056.05.061.05.066.051.07.051.075.052.079.051.084.052.088.052.092.052.097.052.102.052.105.051.11.052.114.051.119.051.123.051.127.05.131.05.135.05.139.049.144.048.147.048.152.047.155.046.16.045.163.045.167.043.171.043.176.042.178.04.183.04.187.038.19.037.194.036.197.034.202.033.204.032.209.03.212.028.216.027.219.025.222.024.226.021.23.02.233.018.236.017.24.014.243.012.246.01.249.008.253.006.256.003.259.001.26-.001.257-.003.254-.006.25-.008.247-.01.244-.013.241-.014.237-.016.233-.018.231-.02.226-.022.224-.024.22-.025.216-.027.212-.029.21-.03.205-.032.202-.033.198-.035.194-.036.191-.037.187-.039.183-.039.179-.041.175-.042.172-.043.168-.044.163-.045.16-.045.155-.047.152-.047.148-.048.143-.049.139-.049.136-.049.131-.051.126-.05.123-.051.118-.052.114-.051.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.052.07-.051.065-.051.06-.051.056-.05.051-.049.023-.025.023-.025.021-.024.02-.024.019-.024.018-.024.017-.024.015-.023.014-.024.013-.023.012-.023.01-.022.01-.023.008-.022.006-.022.006-.022.004-.022.004-.021.001-.021.001-.021v-4.153l-.077.054-.08.054-.083.053-.085.053-.087.053-.09.051-.093.051-.095.051-.097.05-.1.049-.102.048-.105.048-.106.048-.109.046-.111.046-.114.046-.115.044-.118.044-.12.043-.122.043-.124.042-.126.041-.128.04-.13.039-.132.039-.134.038-.135.037-.138.036-.139.036-.142.034-.143.034-.144.033-.147.032-.148.032-.15.03-.151.03-.153.028-.154.028-.156.027-.158.026-.159.024-.161.024-.162.023-.163.023-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.01-.178.01-.179.009-.179.007-.181.006-.182.006-.182.004-.184.003-.184.001-.185.001-.185-.001-.184-.001-.184-.003-.182-.004-.182-.006-.181-.006-.179-.007-.179-.009-.178-.01-.176-.01-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.023-.162-.023-.161-.024-.159-.024-.157-.026-.156-.027-.155-.028-.153-.028-.151-.03-.15-.03-.148-.032-.146-.032-.145-.033-.143-.034-.141-.034-.14-.036-.137-.036-.136-.037-.134-.038-.132-.039-.13-.039-.128-.041-.126-.041-.124-.041-.122-.043-.12-.043-.117-.044-.116-.044-.113-.046-.112-.046-.109-.046-.106-.048-.105-.048-.102-.048-.1-.05-.097-.049-.095-.051-.093-.051-.09-.052-.087-.052-.085-.053-.083-.053-.08-.054-.077-.054v4.153zm8.74-8.179l-.257.004-.254.005-.25.008-.247.011-.244.012-.241.014-.237.016-.233.018-.231.021-.226.022-.224.023-.22.026-.216.027-.212.028-.21.031-.205.032-.202.033-.198.034-.194.036-.191.038-.187.038-.183.04-.179.041-.175.042-.172.043-.168.043-.163.045-.16.046-.155.046-.152.048-.148.048-.143.048-.139.049-.136.05-.131.05-.126.051-.123.051-.118.051-.114.052-.11.052-.106.052-.101.052-.096.052-.092.052-.088.052-.083.052-.079.052-.074.051-.07.052-.065.051-.06.05-.056.05-.051.05-.023.025-.023.024-.021.024-.02.025-.019.024-.018.024-.017.023-.015.024-.014.023-.013.023-.012.023-.01.023-.01.022-.008.022-.006.023-.006.021-.004.022-.004.021-.001.021-.001.021.001.021.001.021.004.021.004.022.006.021.006.023.008.022.01.022.01.023.012.023.013.023.014.023.015.024.017.023.018.024.019.024.02.025.021.024.023.024.023.025.051.05.056.05.06.05.065.051.07.052.074.051.079.052.083.052.088.052.092.052.096.052.101.052.106.052.11.052.114.052.118.051.123.051.126.051.131.05.136.05.139.049.143.048.148.048.152.048.155.046.16.046.163.045.168.043.172.043.175.042.179.041.183.04.187.038.191.038.194.036.198.034.202.033.205.032.21.031.212.028.216.027.22.026.224.023.226.022.231.021.233.018.237.016.241.014.244.012.247.011.25.008.254.005.257.004.26.001.26-.001.257-.004.254-.005.25-.008.247-.011.244-.012.241-.014.237-.016.233-.018.231-.021.226-.022.224-.023.22-.026.216-.027.212-.028.21-.031.205-.032.202-.033.198-.034.194-.036.191-.038.187-.038.183-.04.179-.041.175-.042.172-.043.168-.043.163-.045.16-.046.155-.046.152-.048.148-.048.143-.048.139-.049.136-.05.131-.05.126-.051.123-.051.118-.051.114-.052.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.051.07-.052.065-.051.06-.05.056-.05.051-.05.023-.025.023-.024.021-.024.02-.025.019-.024.018-.024.017-.023.015-.024.014-.023.013-.023.012-.023.01-.023.01-.022.008-.022.006-.023.006-.021.004-.022.004-.021.001-.021.001-.021-.001-.021-.001-.021-.004-.021-.004-.022-.006-.021-.006-.023-.008-.022-.01-.022-.01-.023-.012-.023-.013-.023-.014-.023-.015-.024-.017-.023-.018-.024-.019-.024-.02-.025-.021-.024-.023-.024-.023-.025-.051-.05-.056-.05-.06-.05-.065-.051-.07-.052-.074-.051-.079-.052-.083-.052-.088-.052-.092-.052-.096-.052-.101-.052-.106-.052-.11-.052-.114-.052-.118-.051-.123-.051-.126-.051-.131-.05-.136-.05-.139-.049-.143-.048-.148-.048-.152-.048-.155-.046-.16-.046-.163-.045-.168-.043-.172-.043-.175-.042-.179-.041-.183-.04-.187-.038-.191-.038-.194-.036-.198-.034-.202-.033-.205-.032-.21-.031-.212-.028-.216-.027-.22-.026-.224-.023-.226-.022-.231-.021-.233-.018-.237-.016-.241-.014-.244-.012-.247-.011-.25-.008-.254-.005-.257-.004-.26-.001-.26.001z"
  );
}, "insertDatabaseIcon"), Iw = /* @__PURE__ */ u(function(e) {
  e.append("defs").append("symbol").attr("id", "computer").attr("width", "24").attr("height", "24").append("path").attr("transform", "scale(.5)").attr(
    "d",
    "M2 2v13h20v-13h-20zm18 11h-16v-9h16v9zm-10.228 6l.466-1h3.524l.467 1h-4.457zm14.228 3h-24l2-6h2.104l-1.33 4h18.45l-1.297-4h2.073l2 6zm-5-10h-14v-7h14v7z"
  );
}, "insertComputerIcon"), Fw = /* @__PURE__ */ u(function(e) {
  e.append("defs").append("symbol").attr("id", "clock").attr("width", "24").attr("height", "24").append("path").attr("transform", "scale(.5)").attr(
    "d",
    "M12 2c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm5.848 12.459c.202.038.202.333.001.372-1.907.361-6.045 1.111-6.547 1.111-.719 0-1.301-.582-1.301-1.301 0-.512.77-5.447 1.125-7.445.034-.192.312-.181.343.014l.985 6.238 5.394 1.011z"
  );
}, "insertClockIcon"), Nw = /* @__PURE__ */ u(function(e) {
  e.append("defs").append("marker").attr("id", "arrowhead").attr("refX", 7.9).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto-start-reverse").append("path").attr("d", "M -1 0 L 10 5 L 0 10 z");
}, "insertArrowHead"), Rw = /* @__PURE__ */ u(function(e) {
  e.append("defs").append("marker").attr("id", "filled-head").attr("refX", 15.5).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
}, "insertArrowFilledHead"), Mw = /* @__PURE__ */ u(function(e) {
  e.append("defs").append("marker").attr("id", "sequencenumber").attr("refX", 15).attr("refY", 15).attr("markerWidth", 60).attr("markerHeight", 40).attr("orient", "auto").append("circle").attr("cx", 15).attr("cy", 15).attr("r", 6);
}, "insertSequenceNumber"), Ow = /* @__PURE__ */ u(function(e) {
  e.append("defs").append("marker").attr("id", "crosshead").attr("markerWidth", 15).attr("markerHeight", 8).attr("orient", "auto").attr("refX", 4).attr("refY", 4.5).append("path").attr("fill", "none").attr("stroke", "#000000").style("stroke-dasharray", "0, 0").attr("stroke-width", "1pt").attr("d", "M 1,2 L 6,7 M 6,2 L 1,7");
}, "insertArrowCrossHead"), F2 = /* @__PURE__ */ u(function() {
  return {
    x: 0,
    y: 0,
    fill: void 0,
    anchor: void 0,
    style: "#666",
    width: void 0,
    height: void 0,
    textMargin: 0,
    rx: 0,
    ry: 0,
    tspan: !0,
    valign: void 0
  };
}, "getTextObj"), Pw = /* @__PURE__ */ u(function() {
  return {
    x: 0,
    y: 0,
    fill: "#EDF2AE",
    stroke: "#666",
    width: 100,
    anchor: "start",
    height: 100,
    rx: 0,
    ry: 0
  };
}, "getNoteRect"), bi = /* @__PURE__ */ function() {
  function e(a, n, o, h, l, d, p) {
    const g = n.append("text").attr("x", o + l / 2).attr("y", h + d / 2 + 5).style("text-anchor", "middle").text(a);
    s(g, p);
  }
  u(e, "byText");
  function t(a, n, o, h, l, d, p, g) {
    const { actorFontSize: f, actorFontFamily: y, actorFontWeight: m } = g, [x, b] = ls(f), v = a.split(St.lineBreakRegex);
    for (let _ = 0; _ < v.length; _++) {
      const A = _ * x - x * (v.length - 1) / 2, S = n.append("text").attr("x", o + l / 2).attr("y", h).style("text-anchor", "middle").style("font-size", b).style("font-weight", m).style("font-family", y);
      S.append("tspan").attr("x", o + l / 2).attr("dy", A).text(v[_]), S.attr("y", h + d / 2).attr("dominant-baseline", "central").attr("alignment-baseline", "central"), s(S, p);
    }
  }
  u(t, "byTspan");
  function r(a, n, o, h, l, d, p, g) {
    const f = n.append("switch"), m = f.append("foreignObject").attr("x", o).attr("y", h).attr("width", l).attr("height", d).append("xhtml:div").style("display", "table").style("height", "100%").style("width", "100%");
    m.append("div").style("display", "table-cell").style("text-align", "center").style("vertical-align", "middle").text(a), t(a, f, o, h, l, d, p, g), s(m, p);
  }
  u(r, "byFo");
  async function i(a, n, o, h, l, d, p, g) {
    const f = await hn(a, fe()), y = n.append("switch"), x = y.append("foreignObject").attr("x", o + l / 2 - f.width / 2).attr("y", h + d / 2 - f.height / 2).attr("width", f.width).attr("height", f.height).append("xhtml:div").style("height", "100%").style("width", "100%");
    x.append("div").style("text-align", "center").style("vertical-align", "middle").html(await un(a, fe())), t(a, y, o, h, l, d, p, g), s(x, p);
  }
  u(i, "byKatex");
  function s(a, n) {
    for (const o in n)
      n.hasOwnProperty(o) && a.attr(o, n[o]);
  }
  return u(s, "_setTextAttrs"), function(a, n = !1) {
    return n ? i : a.textPlacement === "fo" ? r : a.textPlacement === "old" ? e : t;
  };
}(), $w = /* @__PURE__ */ function() {
  function e(s, a, n, o, h, l, d) {
    const p = a.append("text").attr("x", n).attr("y", o).style("text-anchor", "start").text(s);
    i(p, d);
  }
  u(e, "byText");
  function t(s, a, n, o, h, l, d, p) {
    const { actorFontSize: g, actorFontFamily: f, actorFontWeight: y } = p, m = s.split(St.lineBreakRegex);
    for (let x = 0; x < m.length; x++) {
      const b = x * g - g * (m.length - 1) / 2, v = a.append("text").attr("x", n).attr("y", o).style("text-anchor", "start").style("font-size", g).style("font-weight", y).style("font-family", f);
      v.append("tspan").attr("x", n).attr("dy", b).text(m[x]), v.attr("y", o + l / 2).attr("dominant-baseline", "central").attr("alignment-baseline", "central"), i(v, d);
    }
  }
  u(t, "byTspan");
  function r(s, a, n, o, h, l, d, p) {
    const g = a.append("switch"), y = g.append("foreignObject").attr("x", n).attr("y", o).attr("width", h).attr("height", l).append("xhtml:div").style("display", "table").style("height", "100%").style("width", "100%");
    y.append("div").style("display", "table-cell").style("text-align", "center").style("vertical-align", "middle").text(s), t(s, g, n, o, h, l, d, p), i(y, d);
  }
  u(r, "byFo");
  function i(s, a) {
    for (const n in a)
      a.hasOwnProperty(n) && s.attr(n, a[n]);
  }
  return u(i, "_setTextAttrs"), function(s) {
    return s.textPlacement === "fo" ? r : s.textPlacement === "old" ? e : t;
  };
}(), Le = {
  drawRect: an,
  drawText: ma,
  drawLabel: B2,
  drawActor: _w,
  drawBox: Ew,
  drawPopup: mw,
  anchorElement: Aw,
  drawActivation: Lw,
  drawLoop: Bw,
  drawBackgroundRect: I2,
  insertArrowHead: Nw,
  insertArrowFilledHead: Rw,
  insertSequenceNumber: Mw,
  insertArrowCrossHead: Ow,
  insertDatabaseIcon: Dw,
  insertComputerIcon: Iw,
  insertClockIcon: Fw,
  getTextObj: F2,
  getNoteRect: Pw,
  fixLifeLineHeights: D2,
  sanitizeUrl: ns
}, tt = {}, mt = {
  data: {
    startx: void 0,
    stopx: void 0,
    starty: void 0,
    stopy: void 0
  },
  verticalPos: 0,
  sequenceItems: [],
  activations: [],
  models: {
    getHeight: /* @__PURE__ */ u(function() {
      return Math.max.apply(
        null,
        this.actors.length === 0 ? [0] : this.actors.map((e) => e.height || 0)
      ) + (this.loops.length === 0 ? 0 : this.loops.map((e) => e.height || 0).reduce((e, t) => e + t)) + (this.messages.length === 0 ? 0 : this.messages.map((e) => e.height || 0).reduce((e, t) => e + t)) + (this.notes.length === 0 ? 0 : this.notes.map((e) => e.height || 0).reduce((e, t) => e + t));
    }, "getHeight"),
    clear: /* @__PURE__ */ u(function() {
      this.actors = [], this.boxes = [], this.loops = [], this.messages = [], this.notes = [];
    }, "clear"),
    addBox: /* @__PURE__ */ u(function(e) {
      this.boxes.push(e);
    }, "addBox"),
    addActor: /* @__PURE__ */ u(function(e) {
      this.actors.push(e);
    }, "addActor"),
    addLoop: /* @__PURE__ */ u(function(e) {
      this.loops.push(e);
    }, "addLoop"),
    addMessage: /* @__PURE__ */ u(function(e) {
      this.messages.push(e);
    }, "addMessage"),
    addNote: /* @__PURE__ */ u(function(e) {
      this.notes.push(e);
    }, "addNote"),
    lastActor: /* @__PURE__ */ u(function() {
      return this.actors[this.actors.length - 1];
    }, "lastActor"),
    lastLoop: /* @__PURE__ */ u(function() {
      return this.loops[this.loops.length - 1];
    }, "lastLoop"),
    lastMessage: /* @__PURE__ */ u(function() {
      return this.messages[this.messages.length - 1];
    }, "lastMessage"),
    lastNote: /* @__PURE__ */ u(function() {
      return this.notes[this.notes.length - 1];
    }, "lastNote"),
    actors: [],
    boxes: [],
    loops: [],
    messages: [],
    notes: []
  },
  init: /* @__PURE__ */ u(function() {
    this.sequenceItems = [], this.activations = [], this.models.clear(), this.data = {
      startx: void 0,
      stopx: void 0,
      starty: void 0,
      stopy: void 0
    }, this.verticalPos = 0, M2(K());
  }, "init"),
  updateVal: /* @__PURE__ */ u(function(e, t, r, i) {
    e[t] === void 0 ? e[t] = r : e[t] = i(r, e[t]);
  }, "updateVal"),
  updateBounds: /* @__PURE__ */ u(function(e, t, r, i) {
    const s = this;
    let a = 0;
    function n(o) {
      return /* @__PURE__ */ u(function(l) {
        a++;
        const d = s.sequenceItems.length - a + 1;
        s.updateVal(l, "starty", t - d * tt.boxMargin, Math.min), s.updateVal(l, "stopy", i + d * tt.boxMargin, Math.max), s.updateVal(mt.data, "startx", e - d * tt.boxMargin, Math.min), s.updateVal(mt.data, "stopx", r + d * tt.boxMargin, Math.max), o !== "activation" && (s.updateVal(l, "startx", e - d * tt.boxMargin, Math.min), s.updateVal(l, "stopx", r + d * tt.boxMargin, Math.max), s.updateVal(mt.data, "starty", t - d * tt.boxMargin, Math.min), s.updateVal(mt.data, "stopy", i + d * tt.boxMargin, Math.max));
      }, "updateItemBounds");
    }
    u(n, "updateFn"), this.sequenceItems.forEach(n()), this.activations.forEach(n("activation"));
  }, "updateBounds"),
  insert: /* @__PURE__ */ u(function(e, t, r, i) {
    const s = St.getMin(e, r), a = St.getMax(e, r), n = St.getMin(t, i), o = St.getMax(t, i);
    this.updateVal(mt.data, "startx", s, Math.min), this.updateVal(mt.data, "starty", n, Math.min), this.updateVal(mt.data, "stopx", a, Math.max), this.updateVal(mt.data, "stopy", o, Math.max), this.updateBounds(s, n, a, o);
  }, "insert"),
  newActivation: /* @__PURE__ */ u(function(e, t, r) {
    const i = r.get(e.from), s = Uo(e.from).length || 0, a = i.x + i.width / 2 + (s - 1) * tt.activationWidth / 2;
    this.activations.push({
      startx: a,
      starty: this.verticalPos + 2,
      stopx: a + tt.activationWidth,
      stopy: void 0,
      actor: e.from,
      anchored: Le.anchorElement(t)
    });
  }, "newActivation"),
  endActivation: /* @__PURE__ */ u(function(e) {
    const t = this.activations.map(function(r) {
      return r.actor;
    }).lastIndexOf(e.from);
    return this.activations.splice(t, 1)[0];
  }, "endActivation"),
  createLoop: /* @__PURE__ */ u(function(e = { message: void 0, wrap: !1, width: void 0 }, t) {
    return {
      startx: void 0,
      starty: this.verticalPos,
      stopx: void 0,
      stopy: void 0,
      title: e.message,
      wrap: e.wrap,
      width: e.width,
      height: 0,
      fill: t
    };
  }, "createLoop"),
  newLoop: /* @__PURE__ */ u(function(e = { message: void 0, wrap: !1, width: void 0 }, t) {
    this.sequenceItems.push(this.createLoop(e, t));
  }, "newLoop"),
  endLoop: /* @__PURE__ */ u(function() {
    return this.sequenceItems.pop();
  }, "endLoop"),
  isLoopOverlap: /* @__PURE__ */ u(function() {
    return this.sequenceItems.length ? this.sequenceItems[this.sequenceItems.length - 1].overlap : !1;
  }, "isLoopOverlap"),
  addSectionToLoop: /* @__PURE__ */ u(function(e) {
    const t = this.sequenceItems.pop();
    t.sections = t.sections || [], t.sectionTitles = t.sectionTitles || [], t.sections.push({ y: mt.getVerticalPos(), height: 0 }), t.sectionTitles.push(e), this.sequenceItems.push(t);
  }, "addSectionToLoop"),
  saveVerticalPos: /* @__PURE__ */ u(function() {
    this.isLoopOverlap() && (this.savedVerticalPos = this.verticalPos);
  }, "saveVerticalPos"),
  resetVerticalPos: /* @__PURE__ */ u(function() {
    this.isLoopOverlap() && (this.verticalPos = this.savedVerticalPos);
  }, "resetVerticalPos"),
  bumpVerticalPos: /* @__PURE__ */ u(function(e) {
    this.verticalPos = this.verticalPos + e, this.data.stopy = St.getMax(this.data.stopy, this.verticalPos);
  }, "bumpVerticalPos"),
  getVerticalPos: /* @__PURE__ */ u(function() {
    return this.verticalPos;
  }, "getVerticalPos"),
  getBounds: /* @__PURE__ */ u(function() {
    return { bounds: this.data, models: this.models };
  }, "getBounds")
}, Vw = /* @__PURE__ */ u(async function(e, t) {
  mt.bumpVerticalPos(tt.boxMargin), t.height = tt.boxMargin, t.starty = mt.getVerticalPos();
  const r = Er();
  r.x = t.startx, r.y = t.starty, r.width = t.width || tt.width, r.class = "note";
  const i = e.append("g"), s = Le.drawRect(i, r), a = rh();
  a.x = t.startx, a.y = t.starty, a.width = r.width, a.dy = "1em", a.text = t.message, a.class = "noteText", a.fontFamily = tt.noteFontFamily, a.fontSize = tt.noteFontSize, a.fontWeight = tt.noteFontWeight, a.anchor = tt.noteAlign, a.textMargin = tt.noteMargin, a.valign = "center";
  const n = Ee(a.text) ? await fo(i, a) : ma(i, a), o = Math.round(
    n.map((h) => (h._groups || h)[0][0].getBBox().height).reduce((h, l) => h + l)
  );
  s.attr("height", o + 2 * tt.noteMargin), t.height += o + 2 * tt.noteMargin, mt.bumpVerticalPos(o + 2 * tt.noteMargin), t.stopy = t.starty + o + 2 * tt.noteMargin, t.stopx = t.startx + r.width, mt.insert(t.startx, t.starty, t.stopx, t.stopy), mt.models.addNote(t);
}, "drawNote"), as = /* @__PURE__ */ u((e) => ({
  fontFamily: e.messageFontFamily,
  fontSize: e.messageFontSize,
  fontWeight: e.messageFontWeight
}), "messageFont"), vs = /* @__PURE__ */ u((e) => ({
  fontFamily: e.noteFontFamily,
  fontSize: e.noteFontSize,
  fontWeight: e.noteFontWeight
}), "noteFont"), nc = /* @__PURE__ */ u((e) => ({
  fontFamily: e.actorFontFamily,
  fontSize: e.actorFontSize,
  fontWeight: e.actorFontWeight
}), "actorFont");
async function N2(e, t) {
  mt.bumpVerticalPos(10);
  const { startx: r, stopx: i, message: s } = t, a = St.splitBreaks(s).length, n = Ee(s), o = n ? await hn(s, K()) : ee.calculateTextDimensions(s, as(tt));
  if (!n) {
    const p = o.height / a;
    t.height += p, mt.bumpVerticalPos(p);
  }
  let h, l = o.height - 10;
  const d = o.width;
  if (r === i) {
    h = mt.getVerticalPos() + l, tt.rightAngles || (l += tt.boxMargin, h = mt.getVerticalPos() + l), l += 30;
    const p = St.getMax(d / 2, tt.width / 2);
    mt.insert(
      r - p,
      mt.getVerticalPos() - 10 + l,
      i + p,
      mt.getVerticalPos() + 30 + l
    );
  } else
    l += tt.boxMargin, h = mt.getVerticalPos() + l, mt.insert(r, h - 10, i, h);
  return mt.bumpVerticalPos(l), t.height += l, t.stopy = t.starty + t.height, mt.insert(t.fromBounds, t.starty, t.toBounds, t.stopy), h;
}
u(N2, "boundMessage");
var zw = /* @__PURE__ */ u(async function(e, t, r, i) {
  const { startx: s, stopx: a, starty: n, message: o, type: h, sequenceIndex: l, sequenceVisible: d } = t, p = ee.calculateTextDimensions(o, as(tt)), g = rh();
  g.x = s, g.y = n + 10, g.width = a - s, g.class = "messageText", g.dy = "1em", g.text = o, g.fontFamily = tt.messageFontFamily, g.fontSize = tt.messageFontSize, g.fontWeight = tt.messageFontWeight, g.anchor = tt.messageAlign, g.valign = "center", g.textMargin = tt.wrapPadding, g.tspan = !1, Ee(g.text) ? await fo(e, g, { startx: s, stopx: a, starty: r }) : ma(e, g);
  const f = p.width;
  let y;
  s === a ? tt.rightAngles ? y = e.append("path").attr(
    "d",
    `M  ${s},${r} H ${s + St.getMax(tt.width / 2, f / 2)} V ${r + 25} H ${s}`
  ) : y = e.append("path").attr(
    "d",
    "M " + s + "," + r + " C " + (s + 60) + "," + (r - 10) + " " + (s + 60) + "," + (r + 30) + " " + s + "," + (r + 20)
  ) : (y = e.append("line"), y.attr("x1", s), y.attr("y1", r), y.attr("x2", a), y.attr("y2", r)), h === i.db.LINETYPE.DOTTED || h === i.db.LINETYPE.DOTTED_CROSS || h === i.db.LINETYPE.DOTTED_POINT || h === i.db.LINETYPE.DOTTED_OPEN || h === i.db.LINETYPE.BIDIRECTIONAL_DOTTED ? (y.style("stroke-dasharray", "3, 3"), y.attr("class", "messageLine1")) : y.attr("class", "messageLine0");
  let m = "";
  tt.arrowMarkerAbsolute && (m = Ao(!0)), y.attr("stroke-width", 2), y.attr("stroke", "none"), y.style("fill", "none"), (h === i.db.LINETYPE.SOLID || h === i.db.LINETYPE.DOTTED) && y.attr("marker-end", "url(" + m + "#arrowhead)"), (h === i.db.LINETYPE.BIDIRECTIONAL_SOLID || h === i.db.LINETYPE.BIDIRECTIONAL_DOTTED) && (y.attr("marker-start", "url(" + m + "#arrowhead)"), y.attr("marker-end", "url(" + m + "#arrowhead)")), (h === i.db.LINETYPE.SOLID_POINT || h === i.db.LINETYPE.DOTTED_POINT) && y.attr("marker-end", "url(" + m + "#filled-head)"), (h === i.db.LINETYPE.SOLID_CROSS || h === i.db.LINETYPE.DOTTED_CROSS) && y.attr("marker-end", "url(" + m + "#crosshead)"), (d || tt.showSequenceNumbers) && ((h === i.db.LINETYPE.BIDIRECTIONAL_SOLID || h === i.db.LINETYPE.BIDIRECTIONAL_DOTTED) && (s < a ? y.attr("x1", s + 2 * 6) : y.attr("x1", s + 6)), e.append("line").attr("x1", s).attr("y1", r).attr("x2", s).attr("y2", r).attr("stroke-width", 0).attr("marker-start", "url(" + m + "#sequencenumber)"), e.append("text").attr("x", s).attr("y", r + 4).attr("font-family", "sans-serif").attr("font-size", "12px").attr("text-anchor", "middle").attr("class", "sequenceNumber").text(l));
}, "drawMessage"), Ww = /* @__PURE__ */ u(function(e, t, r, i, s, a, n) {
  let o = 0, h = 0, l, d = 0;
  for (const p of i) {
    const g = t.get(p), f = g.box;
    l && l != f && (n || mt.models.addBox(l), h += tt.boxMargin + l.margin), f && f != l && (n || (f.x = o + h, f.y = s), h += f.margin), g.width = g.width || tt.width, g.height = St.getMax(g.height || tt.height, tt.height), g.margin = g.margin || tt.actorMargin, d = St.getMax(d, g.height), r.get(g.name) && (h += g.width / 2), g.x = o + h, g.starty = mt.getVerticalPos(), mt.insert(g.x, s, g.x + g.width, g.height), o += g.width + h, g.box && (g.box.width = o + f.margin - g.box.x), h = g.margin, l = g.box, mt.models.addActor(g);
  }
  l && !n && mt.models.addBox(l), mt.bumpVerticalPos(d);
}, "addActorRenderingData"), oc = /* @__PURE__ */ u(async function(e, t, r, i) {
  if (i) {
    let s = 0;
    mt.bumpVerticalPos(tt.boxMargin * 2);
    for (const a of r) {
      const n = t.get(a);
      n.stopy || (n.stopy = mt.getVerticalPos());
      const o = await Le.drawActor(e, n, tt, !0);
      s = St.getMax(s, o);
    }
    mt.bumpVerticalPos(s + tt.boxMargin);
  } else
    for (const s of r) {
      const a = t.get(s);
      await Le.drawActor(e, a, tt, !1);
    }
}, "drawActors"), R2 = /* @__PURE__ */ u(function(e, t, r, i) {
  let s = 0, a = 0;
  for (const n of r) {
    const o = t.get(n), h = Yw(o), l = Le.drawPopup(
      e,
      o,
      h,
      tt,
      tt.forceMenus,
      i
    );
    l.height > s && (s = l.height), l.width + o.x > a && (a = l.width + o.x);
  }
  return { maxHeight: s, maxWidth: a };
}, "drawActorsPopup"), M2 = /* @__PURE__ */ u(function(e) {
  De(tt, e), e.fontFamily && (tt.actorFontFamily = tt.noteFontFamily = tt.messageFontFamily = e.fontFamily), e.fontSize && (tt.actorFontSize = tt.noteFontSize = tt.messageFontSize = e.fontSize), e.fontWeight && (tt.actorFontWeight = tt.noteFontWeight = tt.messageFontWeight = e.fontWeight);
}, "setConf"), Uo = /* @__PURE__ */ u(function(e) {
  return mt.activations.filter(function(t) {
    return t.actor === e;
  });
}, "actorActivations"), Au = /* @__PURE__ */ u(function(e, t) {
  const r = t.get(e), i = Uo(e), s = i.reduce(
    function(n, o) {
      return St.getMin(n, o.startx);
    },
    r.x + r.width / 2 - 1
  ), a = i.reduce(
    function(n, o) {
      return St.getMax(n, o.stopx);
    },
    r.x + r.width / 2 + 1
  );
  return [s, a];
}, "activationBounds");
function Mr(e, t, r, i, s) {
  mt.bumpVerticalPos(r);
  let a = i;
  if (t.id && t.message && e[t.id]) {
    const n = e[t.id].width, o = as(tt);
    t.message = ee.wrapLabel(`[${t.message}]`, n - 2 * tt.wrapPadding, o), t.width = n, t.wrap = !0;
    const h = ee.calculateTextDimensions(t.message, o), l = St.getMax(h.height, tt.labelBoxHeight);
    a = i + l, I.debug(`${l} - ${t.message}`);
  }
  s(t), mt.bumpVerticalPos(a);
}
u(Mr, "adjustLoopHeightForWrap");
function O2(e, t, r, i, s, a, n) {
  function o(d, p) {
    d.x < s.get(e.from).x ? (mt.insert(
      t.stopx - p,
      t.starty,
      t.startx,
      t.stopy + d.height / 2 + tt.noteMargin
    ), t.stopx = t.stopx + p) : (mt.insert(
      t.startx,
      t.starty,
      t.stopx + p,
      t.stopy + d.height / 2 + tt.noteMargin
    ), t.stopx = t.stopx - p);
  }
  u(o, "receiverAdjustment");
  function h(d, p) {
    d.x < s.get(e.to).x ? (mt.insert(
      t.startx - p,
      t.starty,
      t.stopx,
      t.stopy + d.height / 2 + tt.noteMargin
    ), t.startx = t.startx + p) : (mt.insert(
      t.stopx,
      t.starty,
      t.startx + p,
      t.stopy + d.height / 2 + tt.noteMargin
    ), t.startx = t.startx - p);
  }
  u(h, "senderAdjustment");
  const l = [
    En.ACTOR,
    En.CONTROL,
    En.ENTITY,
    En.DATABASE
  ];
  if (a.get(e.to) == i) {
    const d = s.get(e.to), p = l.includes(d.type) ? Qi / 2 + 3 : d.width / 2 + 3;
    o(d, p), d.starty = r - d.height / 2, mt.bumpVerticalPos(d.height / 2);
  } else if (n.get(e.from) == i) {
    const d = s.get(e.from);
    if (tt.mirrorActors) {
      const p = l.includes(d.type) ? Qi / 2 : d.width / 2;
      h(d, p);
    }
    d.stopy = r - d.height / 2, mt.bumpVerticalPos(d.height / 2);
  } else if (n.get(e.to) == i) {
    const d = s.get(e.to);
    if (tt.mirrorActors) {
      const p = l.includes(d.type) ? Qi / 2 + 3 : d.width / 2 + 3;
      o(d, p);
    }
    d.stopy = r - d.height / 2, mt.bumpVerticalPos(d.height / 2);
  }
}
u(O2, "adjustCreatedDestroyedData");
var qw = /* @__PURE__ */ u(async function(e, t, r, i) {
  const { securityLevel: s, sequence: a } = K();
  tt = a;
  let n;
  s === "sandbox" && (n = yt("#i" + t));
  const o = s === "sandbox" ? yt(n.nodes()[0].contentDocument.body) : yt("body"), h = s === "sandbox" ? n.nodes()[0].contentDocument : document;
  mt.init(), I.debug(i.db);
  const l = s === "sandbox" ? o.select(`[id="${t}"]`) : yt(`[id="${t}"]`), d = i.db.getActors(), p = i.db.getCreatedActors(), g = i.db.getDestroyedActors(), f = i.db.getBoxes();
  let y = i.db.getActorKeys();
  const m = i.db.getMessages(), x = i.db.getDiagramTitle(), b = i.db.hasAtLeastOneBox(), v = i.db.hasAtLeastOneBoxWithTitle(), _ = await P2(d, m, i);
  if (tt.height = await $2(d, _, f), Le.insertComputerIcon(l), Le.insertDatabaseIcon(l), Le.insertClockIcon(l), b && (mt.bumpVerticalPos(tt.boxMargin), v && mt.bumpVerticalPos(f[0].textMaxHeight)), tt.hideUnusedParticipants === !0) {
    const D = /* @__PURE__ */ new Set();
    m.forEach((O) => {
      D.add(O.from), D.add(O.to);
    }), y = y.filter((O) => D.has(O));
  }
  Ww(l, d, p, y, 0, m, !1);
  const A = await jw(m, d, _, i);
  Le.insertArrowHead(l), Le.insertArrowCrossHead(l), Le.insertArrowFilledHead(l), Le.insertSequenceNumber(l);
  function S(D, O) {
    const Y = mt.endActivation(D);
    Y.starty + 18 > O && (Y.starty = O - 6, O += 12), Le.drawActivation(
      l,
      Y,
      O,
      tt,
      Uo(D.from).length
    ), mt.insert(Y.startx, O - 10, Y.stopx, O);
  }
  u(S, "activeEnd");
  let k = 1, L = 1;
  const T = [], C = [];
  let E = 0;
  for (const D of m) {
    let O, Y, M;
    switch (D.type) {
      case i.db.LINETYPE.NOTE:
        mt.resetVerticalPos(), Y = D.noteModel, await Vw(l, Y);
        break;
      case i.db.LINETYPE.ACTIVE_START:
        mt.newActivation(D, l, d);
        break;
      case i.db.LINETYPE.ACTIVE_END:
        S(D, mt.getVerticalPos());
        break;
      case i.db.LINETYPE.LOOP_START:
        Mr(
          A,
          D,
          tt.boxMargin,
          tt.boxMargin + tt.boxTextMargin,
          (G) => mt.newLoop(G)
        );
        break;
      case i.db.LINETYPE.LOOP_END:
        O = mt.endLoop(), await Le.drawLoop(l, O, "loop", tt), mt.bumpVerticalPos(O.stopy - mt.getVerticalPos()), mt.models.addLoop(O);
        break;
      case i.db.LINETYPE.RECT_START:
        Mr(
          A,
          D,
          tt.boxMargin,
          tt.boxMargin,
          (G) => mt.newLoop(void 0, G.message)
        );
        break;
      case i.db.LINETYPE.RECT_END:
        O = mt.endLoop(), C.push(O), mt.models.addLoop(O), mt.bumpVerticalPos(O.stopy - mt.getVerticalPos());
        break;
      case i.db.LINETYPE.OPT_START:
        Mr(
          A,
          D,
          tt.boxMargin,
          tt.boxMargin + tt.boxTextMargin,
          (G) => mt.newLoop(G)
        );
        break;
      case i.db.LINETYPE.OPT_END:
        O = mt.endLoop(), await Le.drawLoop(l, O, "opt", tt), mt.bumpVerticalPos(O.stopy - mt.getVerticalPos()), mt.models.addLoop(O);
        break;
      case i.db.LINETYPE.ALT_START:
        Mr(
          A,
          D,
          tt.boxMargin,
          tt.boxMargin + tt.boxTextMargin,
          (G) => mt.newLoop(G)
        );
        break;
      case i.db.LINETYPE.ALT_ELSE:
        Mr(
          A,
          D,
          tt.boxMargin + tt.boxTextMargin,
          tt.boxMargin,
          (G) => mt.addSectionToLoop(G)
        );
        break;
      case i.db.LINETYPE.ALT_END:
        O = mt.endLoop(), await Le.drawLoop(l, O, "alt", tt), mt.bumpVerticalPos(O.stopy - mt.getVerticalPos()), mt.models.addLoop(O);
        break;
      case i.db.LINETYPE.PAR_START:
      case i.db.LINETYPE.PAR_OVER_START:
        Mr(
          A,
          D,
          tt.boxMargin,
          tt.boxMargin + tt.boxTextMargin,
          (G) => mt.newLoop(G)
        ), mt.saveVerticalPos();
        break;
      case i.db.LINETYPE.PAR_AND:
        Mr(
          A,
          D,
          tt.boxMargin + tt.boxTextMargin,
          tt.boxMargin,
          (G) => mt.addSectionToLoop(G)
        );
        break;
      case i.db.LINETYPE.PAR_END:
        O = mt.endLoop(), await Le.drawLoop(l, O, "par", tt), mt.bumpVerticalPos(O.stopy - mt.getVerticalPos()), mt.models.addLoop(O);
        break;
      case i.db.LINETYPE.AUTONUMBER:
        k = D.message.start || k, L = D.message.step || L, D.message.visible ? i.db.enableSequenceNumbers() : i.db.disableSequenceNumbers();
        break;
      case i.db.LINETYPE.CRITICAL_START:
        Mr(
          A,
          D,
          tt.boxMargin,
          tt.boxMargin + tt.boxTextMargin,
          (G) => mt.newLoop(G)
        );
        break;
      case i.db.LINETYPE.CRITICAL_OPTION:
        Mr(
          A,
          D,
          tt.boxMargin + tt.boxTextMargin,
          tt.boxMargin,
          (G) => mt.addSectionToLoop(G)
        );
        break;
      case i.db.LINETYPE.CRITICAL_END:
        O = mt.endLoop(), await Le.drawLoop(l, O, "critical", tt), mt.bumpVerticalPos(O.stopy - mt.getVerticalPos()), mt.models.addLoop(O);
        break;
      case i.db.LINETYPE.BREAK_START:
        Mr(
          A,
          D,
          tt.boxMargin,
          tt.boxMargin + tt.boxTextMargin,
          (G) => mt.newLoop(G)
        );
        break;
      case i.db.LINETYPE.BREAK_END:
        O = mt.endLoop(), await Le.drawLoop(l, O, "break", tt), mt.bumpVerticalPos(O.stopy - mt.getVerticalPos()), mt.models.addLoop(O);
        break;
      default:
        try {
          M = D.msgModel, M.starty = mt.getVerticalPos(), M.sequenceIndex = k, M.sequenceVisible = i.db.showSequenceNumbers();
          const G = await N2(l, M);
          O2(
            D,
            M,
            G,
            E,
            d,
            p,
            g
          ), T.push({ messageModel: M, lineStartY: G }), mt.models.addMessage(M);
        } catch (G) {
          I.error("error while drawing message", G);
        }
    }
    [
      i.db.LINETYPE.SOLID_OPEN,
      i.db.LINETYPE.DOTTED_OPEN,
      i.db.LINETYPE.SOLID,
      i.db.LINETYPE.DOTTED,
      i.db.LINETYPE.SOLID_CROSS,
      i.db.LINETYPE.DOTTED_CROSS,
      i.db.LINETYPE.SOLID_POINT,
      i.db.LINETYPE.DOTTED_POINT,
      i.db.LINETYPE.BIDIRECTIONAL_SOLID,
      i.db.LINETYPE.BIDIRECTIONAL_DOTTED
    ].includes(D.type) && (k = k + L), E++;
  }
  I.debug("createdActors", p), I.debug("destroyedActors", g), await oc(l, d, y, !1);
  for (const D of T)
    await zw(l, D.messageModel, D.lineStartY, i);
  tt.mirrorActors && await oc(l, d, y, !0), C.forEach((D) => Le.drawBackgroundRect(l, D)), D2(l, d, y, tt);
  for (const D of mt.models.boxes) {
    D.height = mt.getVerticalPos() - D.y, mt.insert(D.x, D.y, D.x + D.width, D.height);
    const O = tt.boxMargin * 2;
    D.startx = D.x - O, D.starty = D.y - O * 0.25, D.stopx = D.startx + D.width + 2 * O, D.stopy = D.starty + D.height + O * 0.75, D.stroke = "rgb(0,0,0, 0.5)", Le.drawBox(l, D, tt);
  }
  b && mt.bumpVerticalPos(tt.boxMargin);
  const w = R2(l, d, y, h), { bounds: W } = mt.getBounds();
  W.startx === void 0 && (W.startx = 0), W.starty === void 0 && (W.starty = 0), W.stopx === void 0 && (W.stopx = 0), W.stopy === void 0 && (W.stopy = 0);
  let N = W.stopy - W.starty;
  N < w.maxHeight && (N = w.maxHeight);
  let B = N + 2 * tt.diagramMarginY;
  tt.mirrorActors && (B = B - tt.boxMargin + tt.bottomMarginAdj);
  let R = W.stopx - W.startx;
  R < w.maxWidth && (R = w.maxWidth);
  const V = R + 2 * tt.diagramMarginX;
  x && l.append("text").text(x).attr("x", (W.stopx - W.startx) / 2 - 2 * tt.diagramMarginX).attr("y", -25), fr(l, B, V, tt.useMaxWidth);
  const $ = x ? 40 : 0;
  l.attr(
    "viewBox",
    W.startx - tt.diagramMarginX + " -" + (tt.diagramMarginY + $) + " " + V + " " + (B + $)
  ), I.debug("models:", mt.models);
}, "draw");
async function P2(e, t, r) {
  const i = {};
  for (const s of t)
    if (e.get(s.to) && e.get(s.from)) {
      const a = e.get(s.to);
      if (s.placement === r.db.PLACEMENT.LEFTOF && !a.prevActor || s.placement === r.db.PLACEMENT.RIGHTOF && !a.nextActor)
        continue;
      const n = s.placement !== void 0, o = !n, h = n ? vs(tt) : as(tt), l = s.wrap ? ee.wrapLabel(s.message, tt.width - 2 * tt.wrapPadding, h) : s.message, p = (Ee(l) ? await hn(s.message, K()) : ee.calculateTextDimensions(l, h)).width + 2 * tt.wrapPadding;
      o && s.from === a.nextActor ? i[s.to] = St.getMax(
        i[s.to] || 0,
        p
      ) : o && s.from === a.prevActor ? i[s.from] = St.getMax(
        i[s.from] || 0,
        p
      ) : o && s.from === s.to ? (i[s.from] = St.getMax(
        i[s.from] || 0,
        p / 2
      ), i[s.to] = St.getMax(
        i[s.to] || 0,
        p / 2
      )) : s.placement === r.db.PLACEMENT.RIGHTOF ? i[s.from] = St.getMax(
        i[s.from] || 0,
        p
      ) : s.placement === r.db.PLACEMENT.LEFTOF ? i[a.prevActor] = St.getMax(
        i[a.prevActor] || 0,
        p
      ) : s.placement === r.db.PLACEMENT.OVER && (a.prevActor && (i[a.prevActor] = St.getMax(
        i[a.prevActor] || 0,
        p / 2
      )), a.nextActor && (i[s.from] = St.getMax(
        i[s.from] || 0,
        p / 2
      )));
    }
  return I.debug("maxMessageWidthPerActor:", i), i;
}
u(P2, "getMaxMessageWidthPerActor");
var Yw = /* @__PURE__ */ u(function(e) {
  let t = 0;
  const r = nc(tt);
  for (const i in e.links) {
    const a = ee.calculateTextDimensions(i, r).width + 2 * tt.wrapPadding + 2 * tt.boxMargin;
    t < a && (t = a);
  }
  return t;
}, "getRequiredPopupWidth");
async function $2(e, t, r) {
  let i = 0;
  for (const a of e.keys()) {
    const n = e.get(a);
    n.wrap && (n.description = ee.wrapLabel(
      n.description,
      tt.width - 2 * tt.wrapPadding,
      nc(tt)
    ));
    const o = Ee(n.description) ? await hn(n.description, K()) : ee.calculateTextDimensions(n.description, nc(tt));
    n.width = n.wrap ? tt.width : St.getMax(tt.width, o.width + 2 * tt.wrapPadding), n.height = n.wrap ? St.getMax(o.height, tt.height) : tt.height, i = St.getMax(i, n.height);
  }
  for (const a in t) {
    const n = e.get(a);
    if (!n)
      continue;
    const o = e.get(n.nextActor);
    if (!o) {
      const p = t[a] + tt.actorMargin - n.width / 2;
      n.margin = St.getMax(p, tt.actorMargin);
      continue;
    }
    const l = t[a] + tt.actorMargin - n.width / 2 - o.width / 2;
    n.margin = St.getMax(l, tt.actorMargin);
  }
  let s = 0;
  return r.forEach((a) => {
    const n = as(tt);
    let o = a.actorKeys.reduce((p, g) => p += e.get(g).width + (e.get(g).margin || 0), 0);
    const h = tt.boxMargin * 8;
    o += h, o -= 2 * tt.boxTextMargin, a.wrap && (a.name = ee.wrapLabel(a.name, o - 2 * tt.wrapPadding, n));
    const l = ee.calculateTextDimensions(a.name, n);
    s = St.getMax(l.height, s);
    const d = St.getMax(o, l.width + 2 * tt.wrapPadding);
    if (a.margin = tt.boxTextMargin, o < d) {
      const p = (d - o) / 2;
      a.margin += p;
    }
  }), r.forEach((a) => a.textMaxHeight = s), St.getMax(i, tt.height);
}
u($2, "calculateActorMargins");
var Hw = /* @__PURE__ */ u(async function(e, t, r) {
  const i = t.get(e.from), s = t.get(e.to), a = i.x, n = s.x, o = e.wrap && e.message;
  let h = Ee(e.message) ? await hn(e.message, K()) : ee.calculateTextDimensions(
    o ? ee.wrapLabel(e.message, tt.width, vs(tt)) : e.message,
    vs(tt)
  );
  const l = {
    width: o ? tt.width : St.getMax(tt.width, h.width + 2 * tt.noteMargin),
    height: 0,
    startx: i.x,
    stopx: 0,
    starty: 0,
    stopy: 0,
    message: e.message
  };
  return e.placement === r.db.PLACEMENT.RIGHTOF ? (l.width = o ? St.getMax(tt.width, h.width) : St.getMax(
    i.width / 2 + s.width / 2,
    h.width + 2 * tt.noteMargin
  ), l.startx = a + (i.width + tt.actorMargin) / 2) : e.placement === r.db.PLACEMENT.LEFTOF ? (l.width = o ? St.getMax(tt.width, h.width + 2 * tt.noteMargin) : St.getMax(
    i.width / 2 + s.width / 2,
    h.width + 2 * tt.noteMargin
  ), l.startx = a - l.width + (i.width - tt.actorMargin) / 2) : e.to === e.from ? (h = ee.calculateTextDimensions(
    o ? ee.wrapLabel(e.message, St.getMax(tt.width, i.width), vs(tt)) : e.message,
    vs(tt)
  ), l.width = o ? St.getMax(tt.width, i.width) : St.getMax(i.width, tt.width, h.width + 2 * tt.noteMargin), l.startx = a + (i.width - l.width) / 2) : (l.width = Math.abs(a + i.width / 2 - (n + s.width / 2)) + tt.actorMargin, l.startx = a < n ? a + i.width / 2 - tt.actorMargin / 2 : n + s.width / 2 - tt.actorMargin / 2), o && (l.message = ee.wrapLabel(
    e.message,
    l.width - 2 * tt.wrapPadding,
    vs(tt)
  )), I.debug(
    `NM:[${l.startx},${l.stopx},${l.starty},${l.stopy}:${l.width},${l.height}=${e.message}]`
  ), l;
}, "buildNoteModel"), Uw = /* @__PURE__ */ u(function(e, t, r) {
  if (![
    r.db.LINETYPE.SOLID_OPEN,
    r.db.LINETYPE.DOTTED_OPEN,
    r.db.LINETYPE.SOLID,
    r.db.LINETYPE.DOTTED,
    r.db.LINETYPE.SOLID_CROSS,
    r.db.LINETYPE.DOTTED_CROSS,
    r.db.LINETYPE.SOLID_POINT,
    r.db.LINETYPE.DOTTED_POINT,
    r.db.LINETYPE.BIDIRECTIONAL_SOLID,
    r.db.LINETYPE.BIDIRECTIONAL_DOTTED
  ].includes(e.type))
    return {};
  const [i, s] = Au(e.from, t), [a, n] = Au(e.to, t), o = i <= a;
  let h = o ? s : i, l = o ? a : n;
  const d = Math.abs(a - n) > 2, p = /* @__PURE__ */ u((m) => o ? -m : m, "adjustValue");
  e.from === e.to ? l = h : (e.activate && !d && (l += p(tt.activationWidth / 2 - 1)), [r.db.LINETYPE.SOLID_OPEN, r.db.LINETYPE.DOTTED_OPEN].includes(e.type) || (l += p(3)), [r.db.LINETYPE.BIDIRECTIONAL_SOLID, r.db.LINETYPE.BIDIRECTIONAL_DOTTED].includes(
    e.type
  ) && (h -= p(3)));
  const g = [i, s, a, n], f = Math.abs(h - l);
  e.wrap && e.message && (e.message = ee.wrapLabel(
    e.message,
    St.getMax(f + 2 * tt.wrapPadding, tt.width),
    as(tt)
  ));
  const y = ee.calculateTextDimensions(e.message, as(tt));
  return {
    width: St.getMax(
      e.wrap ? 0 : y.width + 2 * tt.wrapPadding,
      f + 2 * tt.wrapPadding,
      tt.width
    ),
    height: 0,
    startx: h,
    stopx: l,
    starty: 0,
    stopy: 0,
    message: e.message,
    type: e.type,
    wrap: e.wrap,
    fromBounds: Math.min.apply(null, g),
    toBounds: Math.max.apply(null, g)
  };
}, "buildMessageModel"), jw = /* @__PURE__ */ u(async function(e, t, r, i) {
  const s = {}, a = [];
  let n, o, h;
  for (const l of e) {
    switch (l.type) {
      case i.db.LINETYPE.LOOP_START:
      case i.db.LINETYPE.ALT_START:
      case i.db.LINETYPE.OPT_START:
      case i.db.LINETYPE.PAR_START:
      case i.db.LINETYPE.PAR_OVER_START:
      case i.db.LINETYPE.CRITICAL_START:
      case i.db.LINETYPE.BREAK_START:
        a.push({
          id: l.id,
          msg: l.message,
          from: Number.MAX_SAFE_INTEGER,
          to: Number.MIN_SAFE_INTEGER,
          width: 0
        });
        break;
      case i.db.LINETYPE.ALT_ELSE:
      case i.db.LINETYPE.PAR_AND:
      case i.db.LINETYPE.CRITICAL_OPTION:
        l.message && (n = a.pop(), s[n.id] = n, s[l.id] = n, a.push(n));
        break;
      case i.db.LINETYPE.LOOP_END:
      case i.db.LINETYPE.ALT_END:
      case i.db.LINETYPE.OPT_END:
      case i.db.LINETYPE.PAR_END:
      case i.db.LINETYPE.CRITICAL_END:
      case i.db.LINETYPE.BREAK_END:
        n = a.pop(), s[n.id] = n;
        break;
      case i.db.LINETYPE.ACTIVE_START:
        {
          const p = t.get(l.from ? l.from : l.to.actor), g = Uo(l.from ? l.from : l.to.actor).length, f = p.x + p.width / 2 + (g - 1) * tt.activationWidth / 2, y = {
            startx: f,
            stopx: f + tt.activationWidth,
            actor: l.from,
            enabled: !0
          };
          mt.activations.push(y);
        }
        break;
      case i.db.LINETYPE.ACTIVE_END:
        {
          const p = mt.activations.map((g) => g.actor).lastIndexOf(l.from);
          mt.activations.splice(p, 1).splice(0, 1);
        }
        break;
    }
    l.placement !== void 0 ? (o = await Hw(l, t, i), l.noteModel = o, a.forEach((p) => {
      n = p, n.from = St.getMin(n.from, o.startx), n.to = St.getMax(n.to, o.startx + o.width), n.width = St.getMax(n.width, Math.abs(n.from - n.to)) - tt.labelBoxWidth;
    })) : (h = Uw(l, t, i), l.msgModel = h, h.startx && h.stopx && a.length > 0 && a.forEach((p) => {
      if (n = p, h.startx === h.stopx) {
        const g = t.get(l.from), f = t.get(l.to);
        n.from = St.getMin(
          g.x - h.width / 2,
          g.x - g.width / 2,
          n.from
        ), n.to = St.getMax(
          f.x + h.width / 2,
          f.x + g.width / 2,
          n.to
        ), n.width = St.getMax(n.width, Math.abs(n.to - n.from)) - tt.labelBoxWidth;
      } else
        n.from = St.getMin(h.startx, n.from), n.to = St.getMax(h.stopx, n.to), n.width = St.getMax(n.width, h.width) - tt.labelBoxWidth;
    }));
  }
  return mt.activations = [], I.debug("Loop type widths:", s), s;
}, "calculateLoopBounds"), Gw = {
  bounds: mt,
  drawActors: oc,
  drawActorsPopup: R2,
  setConf: M2,
  draw: qw
}, Xw = {
  parser: hw,
  get db() {
    return new gw();
  },
  renderer: Gw,
  styles: yw,
  init: /* @__PURE__ */ u((e) => {
    e.sequence || (e.sequence = {}), e.wrap && (e.sequence.wrap = e.wrap, ml({ sequence: { wrap: e.wrap } }));
  }, "init")
};
const Kw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: Xw
}, Symbol.toStringTag, { value: "Module" }));
var lc = function() {
  var e = /* @__PURE__ */ u(function(wt, nt, ut, kt) {
    for (ut = ut || {}, kt = wt.length; kt--; ut[wt[kt]] = nt) ;
    return ut;
  }, "o"), t = [1, 18], r = [1, 19], i = [1, 20], s = [1, 41], a = [1, 42], n = [1, 26], o = [1, 24], h = [1, 25], l = [1, 32], d = [1, 33], p = [1, 34], g = [1, 45], f = [1, 35], y = [1, 36], m = [1, 37], x = [1, 38], b = [1, 27], v = [1, 28], _ = [1, 29], A = [1, 30], S = [1, 31], k = [1, 44], L = [1, 46], T = [1, 43], C = [1, 47], E = [1, 9], w = [1, 8, 9], W = [1, 58], N = [1, 59], B = [1, 60], R = [1, 61], V = [1, 62], $ = [1, 63], D = [1, 64], O = [1, 8, 9, 41], Y = [1, 76], M = [1, 8, 9, 12, 13, 22, 39, 41, 44, 68, 69, 70, 71, 72, 73, 74, 79, 81], G = [1, 8, 9, 12, 13, 18, 20, 22, 39, 41, 44, 50, 60, 68, 69, 70, 71, 72, 73, 74, 79, 81, 86, 100, 102, 103], rt = [13, 60, 86, 100, 102, 103], ht = [13, 60, 73, 74, 86, 100, 102, 103], Z = [13, 60, 68, 69, 70, 71, 72, 86, 100, 102, 103], ot = [1, 100], it = [1, 117], bt = [1, 113], xt = [1, 109], Ct = [1, 115], at = [1, 110], lt = [1, 111], Q = [1, 112], U = [1, 114], et = [1, 116], z = [22, 48, 60, 61, 82, 86, 87, 88, 89, 90], Tt = [1, 8, 9, 39, 41, 44], F = [1, 8, 9, 22], te = [1, 145], J = [1, 8, 9, 61], Ut = [1, 8, 9, 22, 48, 60, 61, 82, 86, 87, 88, 89, 90], Wt = {
    trace: /* @__PURE__ */ u(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, start: 3, mermaidDoc: 4, statements: 5, graphConfig: 6, CLASS_DIAGRAM: 7, NEWLINE: 8, EOF: 9, statement: 10, classLabel: 11, SQS: 12, STR: 13, SQE: 14, namespaceName: 15, alphaNumToken: 16, classLiteralName: 17, DOT: 18, className: 19, GENERICTYPE: 20, relationStatement: 21, LABEL: 22, namespaceStatement: 23, classStatement: 24, memberStatement: 25, annotationStatement: 26, clickStatement: 27, styleStatement: 28, cssClassStatement: 29, noteStatement: 30, classDefStatement: 31, direction: 32, acc_title: 33, acc_title_value: 34, acc_descr: 35, acc_descr_value: 36, acc_descr_multiline_value: 37, namespaceIdentifier: 38, STRUCT_START: 39, classStatements: 40, STRUCT_STOP: 41, NAMESPACE: 42, classIdentifier: 43, STYLE_SEPARATOR: 44, members: 45, CLASS: 46, emptyBody: 47, SPACE: 48, ANNOTATION_START: 49, ANNOTATION_END: 50, MEMBER: 51, SEPARATOR: 52, relation: 53, NOTE_FOR: 54, noteText: 55, NOTE: 56, CLASSDEF: 57, classList: 58, stylesOpt: 59, ALPHA: 60, COMMA: 61, direction_tb: 62, direction_bt: 63, direction_rl: 64, direction_lr: 65, relationType: 66, lineType: 67, AGGREGATION: 68, EXTENSION: 69, COMPOSITION: 70, DEPENDENCY: 71, LOLLIPOP: 72, LINE: 73, DOTTED_LINE: 74, CALLBACK: 75, LINK: 76, LINK_TARGET: 77, CLICK: 78, CALLBACK_NAME: 79, CALLBACK_ARGS: 80, HREF: 81, STYLE: 82, CSSCLASS: 83, style: 84, styleComponent: 85, NUM: 86, COLON: 87, UNIT: 88, BRKT: 89, PCT: 90, commentToken: 91, textToken: 92, graphCodeTokens: 93, textNoTagsToken: 94, TAGSTART: 95, TAGEND: 96, "==": 97, "--": 98, DEFAULT: 99, MINUS: 100, keywords: 101, UNICODE_TEXT: 102, BQUOTE_STR: 103, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 7: "CLASS_DIAGRAM", 8: "NEWLINE", 9: "EOF", 12: "SQS", 13: "STR", 14: "SQE", 18: "DOT", 20: "GENERICTYPE", 22: "LABEL", 33: "acc_title", 34: "acc_title_value", 35: "acc_descr", 36: "acc_descr_value", 37: "acc_descr_multiline_value", 39: "STRUCT_START", 41: "STRUCT_STOP", 42: "NAMESPACE", 44: "STYLE_SEPARATOR", 46: "CLASS", 48: "SPACE", 49: "ANNOTATION_START", 50: "ANNOTATION_END", 51: "MEMBER", 52: "SEPARATOR", 54: "NOTE_FOR", 56: "NOTE", 57: "CLASSDEF", 60: "ALPHA", 61: "COMMA", 62: "direction_tb", 63: "direction_bt", 64: "direction_rl", 65: "direction_lr", 68: "AGGREGATION", 69: "EXTENSION", 70: "COMPOSITION", 71: "DEPENDENCY", 72: "LOLLIPOP", 73: "LINE", 74: "DOTTED_LINE", 75: "CALLBACK", 76: "LINK", 77: "LINK_TARGET", 78: "CLICK", 79: "CALLBACK_NAME", 80: "CALLBACK_ARGS", 81: "HREF", 82: "STYLE", 83: "CSSCLASS", 86: "NUM", 87: "COLON", 88: "UNIT", 89: "BRKT", 90: "PCT", 93: "graphCodeTokens", 95: "TAGSTART", 96: "TAGEND", 97: "==", 98: "--", 99: "DEFAULT", 100: "MINUS", 101: "keywords", 102: "UNICODE_TEXT", 103: "BQUOTE_STR" },
    productions_: [0, [3, 1], [3, 1], [4, 1], [6, 4], [5, 1], [5, 2], [5, 3], [11, 3], [15, 1], [15, 1], [15, 3], [15, 2], [19, 1], [19, 3], [19, 1], [19, 2], [19, 2], [19, 2], [10, 1], [10, 2], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 2], [10, 2], [10, 1], [23, 4], [23, 5], [38, 2], [40, 1], [40, 2], [40, 3], [24, 1], [24, 3], [24, 4], [24, 3], [24, 6], [43, 2], [43, 3], [47, 0], [47, 2], [47, 2], [26, 4], [45, 1], [45, 2], [25, 1], [25, 2], [25, 1], [25, 1], [21, 3], [21, 4], [21, 4], [21, 5], [30, 3], [30, 2], [31, 3], [58, 1], [58, 3], [32, 1], [32, 1], [32, 1], [32, 1], [53, 3], [53, 2], [53, 2], [53, 1], [66, 1], [66, 1], [66, 1], [66, 1], [66, 1], [67, 1], [67, 1], [27, 3], [27, 4], [27, 3], [27, 4], [27, 4], [27, 5], [27, 3], [27, 4], [27, 4], [27, 5], [27, 4], [27, 5], [27, 5], [27, 6], [28, 3], [29, 3], [59, 1], [59, 3], [84, 1], [84, 2], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [91, 1], [91, 1], [92, 1], [92, 1], [92, 1], [92, 1], [92, 1], [92, 1], [92, 1], [94, 1], [94, 1], [94, 1], [94, 1], [16, 1], [16, 1], [16, 1], [16, 1], [17, 1], [55, 1]],
    performAction: /* @__PURE__ */ u(function(nt, ut, kt, X, ft, P, At) {
      var q = P.length - 1;
      switch (ft) {
        case 8:
          this.$ = P[q - 1];
          break;
        case 9:
        case 10:
        case 13:
        case 15:
          this.$ = P[q];
          break;
        case 11:
        case 14:
          this.$ = P[q - 2] + "." + P[q];
          break;
        case 12:
        case 16:
          this.$ = P[q - 1] + P[q];
          break;
        case 17:
        case 18:
          this.$ = P[q - 1] + "~" + P[q] + "~";
          break;
        case 19:
          X.addRelation(P[q]);
          break;
        case 20:
          P[q - 1].title = X.cleanupLabel(P[q]), X.addRelation(P[q - 1]);
          break;
        case 31:
          this.$ = P[q].trim(), X.setAccTitle(this.$);
          break;
        case 32:
        case 33:
          this.$ = P[q].trim(), X.setAccDescription(this.$);
          break;
        case 34:
          X.addClassesToNamespace(P[q - 3], P[q - 1]);
          break;
        case 35:
          X.addClassesToNamespace(P[q - 4], P[q - 1]);
          break;
        case 36:
          this.$ = P[q], X.addNamespace(P[q]);
          break;
        case 37:
          this.$ = [P[q]];
          break;
        case 38:
          this.$ = [P[q - 1]];
          break;
        case 39:
          P[q].unshift(P[q - 2]), this.$ = P[q];
          break;
        case 41:
          X.setCssClass(P[q - 2], P[q]);
          break;
        case 42:
          X.addMembers(P[q - 3], P[q - 1]);
          break;
        case 44:
          X.setCssClass(P[q - 5], P[q - 3]), X.addMembers(P[q - 5], P[q - 1]);
          break;
        case 45:
          this.$ = P[q], X.addClass(P[q]);
          break;
        case 46:
          this.$ = P[q - 1], X.addClass(P[q - 1]), X.setClassLabel(P[q - 1], P[q]);
          break;
        case 50:
          X.addAnnotation(P[q], P[q - 2]);
          break;
        case 51:
        case 64:
          this.$ = [P[q]];
          break;
        case 52:
          P[q].push(P[q - 1]), this.$ = P[q];
          break;
        case 53:
          break;
        case 54:
          X.addMember(P[q - 1], X.cleanupLabel(P[q]));
          break;
        case 55:
          break;
        case 56:
          break;
        case 57:
          this.$ = { id1: P[q - 2], id2: P[q], relation: P[q - 1], relationTitle1: "none", relationTitle2: "none" };
          break;
        case 58:
          this.$ = { id1: P[q - 3], id2: P[q], relation: P[q - 1], relationTitle1: P[q - 2], relationTitle2: "none" };
          break;
        case 59:
          this.$ = { id1: P[q - 3], id2: P[q], relation: P[q - 2], relationTitle1: "none", relationTitle2: P[q - 1] };
          break;
        case 60:
          this.$ = { id1: P[q - 4], id2: P[q], relation: P[q - 2], relationTitle1: P[q - 3], relationTitle2: P[q - 1] };
          break;
        case 61:
          X.addNote(P[q], P[q - 1]);
          break;
        case 62:
          X.addNote(P[q]);
          break;
        case 63:
          this.$ = P[q - 2], X.defineClass(P[q - 1], P[q]);
          break;
        case 65:
          this.$ = P[q - 2].concat([P[q]]);
          break;
        case 66:
          X.setDirection("TB");
          break;
        case 67:
          X.setDirection("BT");
          break;
        case 68:
          X.setDirection("RL");
          break;
        case 69:
          X.setDirection("LR");
          break;
        case 70:
          this.$ = { type1: P[q - 2], type2: P[q], lineType: P[q - 1] };
          break;
        case 71:
          this.$ = { type1: "none", type2: P[q], lineType: P[q - 1] };
          break;
        case 72:
          this.$ = { type1: P[q - 1], type2: "none", lineType: P[q] };
          break;
        case 73:
          this.$ = { type1: "none", type2: "none", lineType: P[q] };
          break;
        case 74:
          this.$ = X.relationType.AGGREGATION;
          break;
        case 75:
          this.$ = X.relationType.EXTENSION;
          break;
        case 76:
          this.$ = X.relationType.COMPOSITION;
          break;
        case 77:
          this.$ = X.relationType.DEPENDENCY;
          break;
        case 78:
          this.$ = X.relationType.LOLLIPOP;
          break;
        case 79:
          this.$ = X.lineType.LINE;
          break;
        case 80:
          this.$ = X.lineType.DOTTED_LINE;
          break;
        case 81:
        case 87:
          this.$ = P[q - 2], X.setClickEvent(P[q - 1], P[q]);
          break;
        case 82:
        case 88:
          this.$ = P[q - 3], X.setClickEvent(P[q - 2], P[q - 1]), X.setTooltip(P[q - 2], P[q]);
          break;
        case 83:
          this.$ = P[q - 2], X.setLink(P[q - 1], P[q]);
          break;
        case 84:
          this.$ = P[q - 3], X.setLink(P[q - 2], P[q - 1], P[q]);
          break;
        case 85:
          this.$ = P[q - 3], X.setLink(P[q - 2], P[q - 1]), X.setTooltip(P[q - 2], P[q]);
          break;
        case 86:
          this.$ = P[q - 4], X.setLink(P[q - 3], P[q - 2], P[q]), X.setTooltip(P[q - 3], P[q - 1]);
          break;
        case 89:
          this.$ = P[q - 3], X.setClickEvent(P[q - 2], P[q - 1], P[q]);
          break;
        case 90:
          this.$ = P[q - 4], X.setClickEvent(P[q - 3], P[q - 2], P[q - 1]), X.setTooltip(P[q - 3], P[q]);
          break;
        case 91:
          this.$ = P[q - 3], X.setLink(P[q - 2], P[q]);
          break;
        case 92:
          this.$ = P[q - 4], X.setLink(P[q - 3], P[q - 1], P[q]);
          break;
        case 93:
          this.$ = P[q - 4], X.setLink(P[q - 3], P[q - 1]), X.setTooltip(P[q - 3], P[q]);
          break;
        case 94:
          this.$ = P[q - 5], X.setLink(P[q - 4], P[q - 2], P[q]), X.setTooltip(P[q - 4], P[q - 1]);
          break;
        case 95:
          this.$ = P[q - 2], X.setCssStyle(P[q - 1], P[q]);
          break;
        case 96:
          X.setCssClass(P[q - 1], P[q]);
          break;
        case 97:
          this.$ = [P[q]];
          break;
        case 98:
          P[q - 2].push(P[q]), this.$ = P[q - 2];
          break;
        case 100:
          this.$ = P[q - 1] + P[q];
          break;
      }
    }, "anonymous"),
    table: [{ 3: 1, 4: 2, 5: 3, 6: 4, 7: [1, 6], 10: 5, 16: 39, 17: 40, 19: 21, 21: 7, 23: 8, 24: 9, 25: 10, 26: 11, 27: 12, 28: 13, 29: 14, 30: 15, 31: 16, 32: 17, 33: t, 35: r, 37: i, 38: 22, 42: s, 43: 23, 46: a, 49: n, 51: o, 52: h, 54: l, 56: d, 57: p, 60: g, 62: f, 63: y, 64: m, 65: x, 75: b, 76: v, 78: _, 82: A, 83: S, 86: k, 100: L, 102: T, 103: C }, { 1: [3] }, { 1: [2, 1] }, { 1: [2, 2] }, { 1: [2, 3] }, e(E, [2, 5], { 8: [1, 48] }), { 8: [1, 49] }, e(w, [2, 19], { 22: [1, 50] }), e(w, [2, 21]), e(w, [2, 22]), e(w, [2, 23]), e(w, [2, 24]), e(w, [2, 25]), e(w, [2, 26]), e(w, [2, 27]), e(w, [2, 28]), e(w, [2, 29]), e(w, [2, 30]), { 34: [1, 51] }, { 36: [1, 52] }, e(w, [2, 33]), e(w, [2, 53], { 53: 53, 66: 56, 67: 57, 13: [1, 54], 22: [1, 55], 68: W, 69: N, 70: B, 71: R, 72: V, 73: $, 74: D }), { 39: [1, 65] }, e(O, [2, 40], { 39: [1, 67], 44: [1, 66] }), e(w, [2, 55]), e(w, [2, 56]), { 16: 68, 60: g, 86: k, 100: L, 102: T }, { 16: 39, 17: 40, 19: 69, 60: g, 86: k, 100: L, 102: T, 103: C }, { 16: 39, 17: 40, 19: 70, 60: g, 86: k, 100: L, 102: T, 103: C }, { 16: 39, 17: 40, 19: 71, 60: g, 86: k, 100: L, 102: T, 103: C }, { 60: [1, 72] }, { 13: [1, 73] }, { 16: 39, 17: 40, 19: 74, 60: g, 86: k, 100: L, 102: T, 103: C }, { 13: Y, 55: 75 }, { 58: 77, 60: [1, 78] }, e(w, [2, 66]), e(w, [2, 67]), e(w, [2, 68]), e(w, [2, 69]), e(M, [2, 13], { 16: 39, 17: 40, 19: 80, 18: [1, 79], 20: [1, 81], 60: g, 86: k, 100: L, 102: T, 103: C }), e(M, [2, 15], { 20: [1, 82] }), { 15: 83, 16: 84, 17: 85, 60: g, 86: k, 100: L, 102: T, 103: C }, { 16: 39, 17: 40, 19: 86, 60: g, 86: k, 100: L, 102: T, 103: C }, e(G, [2, 123]), e(G, [2, 124]), e(G, [2, 125]), e(G, [2, 126]), e([1, 8, 9, 12, 13, 20, 22, 39, 41, 44, 68, 69, 70, 71, 72, 73, 74, 79, 81], [2, 127]), e(E, [2, 6], { 10: 5, 21: 7, 23: 8, 24: 9, 25: 10, 26: 11, 27: 12, 28: 13, 29: 14, 30: 15, 31: 16, 32: 17, 19: 21, 38: 22, 43: 23, 16: 39, 17: 40, 5: 87, 33: t, 35: r, 37: i, 42: s, 46: a, 49: n, 51: o, 52: h, 54: l, 56: d, 57: p, 60: g, 62: f, 63: y, 64: m, 65: x, 75: b, 76: v, 78: _, 82: A, 83: S, 86: k, 100: L, 102: T, 103: C }), { 5: 88, 10: 5, 16: 39, 17: 40, 19: 21, 21: 7, 23: 8, 24: 9, 25: 10, 26: 11, 27: 12, 28: 13, 29: 14, 30: 15, 31: 16, 32: 17, 33: t, 35: r, 37: i, 38: 22, 42: s, 43: 23, 46: a, 49: n, 51: o, 52: h, 54: l, 56: d, 57: p, 60: g, 62: f, 63: y, 64: m, 65: x, 75: b, 76: v, 78: _, 82: A, 83: S, 86: k, 100: L, 102: T, 103: C }, e(w, [2, 20]), e(w, [2, 31]), e(w, [2, 32]), { 13: [1, 90], 16: 39, 17: 40, 19: 89, 60: g, 86: k, 100: L, 102: T, 103: C }, { 53: 91, 66: 56, 67: 57, 68: W, 69: N, 70: B, 71: R, 72: V, 73: $, 74: D }, e(w, [2, 54]), { 67: 92, 73: $, 74: D }, e(rt, [2, 73], { 66: 93, 68: W, 69: N, 70: B, 71: R, 72: V }), e(ht, [2, 74]), e(ht, [2, 75]), e(ht, [2, 76]), e(ht, [2, 77]), e(ht, [2, 78]), e(Z, [2, 79]), e(Z, [2, 80]), { 8: [1, 95], 24: 96, 40: 94, 43: 23, 46: a }, { 16: 97, 60: g, 86: k, 100: L, 102: T }, { 41: [1, 99], 45: 98, 51: ot }, { 50: [1, 101] }, { 13: [1, 102] }, { 13: [1, 103] }, { 79: [1, 104], 81: [1, 105] }, { 22: it, 48: bt, 59: 106, 60: xt, 82: Ct, 84: 107, 85: 108, 86: at, 87: lt, 88: Q, 89: U, 90: et }, { 60: [1, 118] }, { 13: Y, 55: 119 }, e(w, [2, 62]), e(w, [2, 128]), { 22: it, 48: bt, 59: 120, 60: xt, 61: [1, 121], 82: Ct, 84: 107, 85: 108, 86: at, 87: lt, 88: Q, 89: U, 90: et }, e(z, [2, 64]), { 16: 39, 17: 40, 19: 122, 60: g, 86: k, 100: L, 102: T, 103: C }, e(M, [2, 16]), e(M, [2, 17]), e(M, [2, 18]), { 39: [2, 36] }, { 15: 124, 16: 84, 17: 85, 18: [1, 123], 39: [2, 9], 60: g, 86: k, 100: L, 102: T, 103: C }, { 39: [2, 10] }, e(Tt, [2, 45], { 11: 125, 12: [1, 126] }), e(E, [2, 7]), { 9: [1, 127] }, e(F, [2, 57]), { 16: 39, 17: 40, 19: 128, 60: g, 86: k, 100: L, 102: T, 103: C }, { 13: [1, 130], 16: 39, 17: 40, 19: 129, 60: g, 86: k, 100: L, 102: T, 103: C }, e(rt, [2, 72], { 66: 131, 68: W, 69: N, 70: B, 71: R, 72: V }), e(rt, [2, 71]), { 41: [1, 132] }, { 24: 96, 40: 133, 43: 23, 46: a }, { 8: [1, 134], 41: [2, 37] }, e(O, [2, 41], { 39: [1, 135] }), { 41: [1, 136] }, e(O, [2, 43]), { 41: [2, 51], 45: 137, 51: ot }, { 16: 39, 17: 40, 19: 138, 60: g, 86: k, 100: L, 102: T, 103: C }, e(w, [2, 81], { 13: [1, 139] }), e(w, [2, 83], { 13: [1, 141], 77: [1, 140] }), e(w, [2, 87], { 13: [1, 142], 80: [1, 143] }), { 13: [1, 144] }, e(w, [2, 95], { 61: te }), e(J, [2, 97], { 85: 146, 22: it, 48: bt, 60: xt, 82: Ct, 86: at, 87: lt, 88: Q, 89: U, 90: et }), e(Ut, [2, 99]), e(Ut, [2, 101]), e(Ut, [2, 102]), e(Ut, [2, 103]), e(Ut, [2, 104]), e(Ut, [2, 105]), e(Ut, [2, 106]), e(Ut, [2, 107]), e(Ut, [2, 108]), e(Ut, [2, 109]), e(w, [2, 96]), e(w, [2, 61]), e(w, [2, 63], { 61: te }), { 60: [1, 147] }, e(M, [2, 14]), { 15: 148, 16: 84, 17: 85, 60: g, 86: k, 100: L, 102: T, 103: C }, { 39: [2, 12] }, e(Tt, [2, 46]), { 13: [1, 149] }, { 1: [2, 4] }, e(F, [2, 59]), e(F, [2, 58]), { 16: 39, 17: 40, 19: 150, 60: g, 86: k, 100: L, 102: T, 103: C }, e(rt, [2, 70]), e(w, [2, 34]), { 41: [1, 151] }, { 24: 96, 40: 152, 41: [2, 38], 43: 23, 46: a }, { 45: 153, 51: ot }, e(O, [2, 42]), { 41: [2, 52] }, e(w, [2, 50]), e(w, [2, 82]), e(w, [2, 84]), e(w, [2, 85], { 77: [1, 154] }), e(w, [2, 88]), e(w, [2, 89], { 13: [1, 155] }), e(w, [2, 91], { 13: [1, 157], 77: [1, 156] }), { 22: it, 48: bt, 60: xt, 82: Ct, 84: 158, 85: 108, 86: at, 87: lt, 88: Q, 89: U, 90: et }, e(Ut, [2, 100]), e(z, [2, 65]), { 39: [2, 11] }, { 14: [1, 159] }, e(F, [2, 60]), e(w, [2, 35]), { 41: [2, 39] }, { 41: [1, 160] }, e(w, [2, 86]), e(w, [2, 90]), e(w, [2, 92]), e(w, [2, 93], { 77: [1, 161] }), e(J, [2, 98], { 85: 146, 22: it, 48: bt, 60: xt, 82: Ct, 86: at, 87: lt, 88: Q, 89: U, 90: et }), e(Tt, [2, 8]), e(O, [2, 44]), e(w, [2, 94])],
    defaultActions: { 2: [2, 1], 3: [2, 2], 4: [2, 3], 83: [2, 36], 85: [2, 10], 124: [2, 12], 127: [2, 4], 137: [2, 52], 148: [2, 11], 152: [2, 39] },
    parseError: /* @__PURE__ */ u(function(nt, ut) {
      if (ut.recoverable)
        this.trace(nt);
      else {
        var kt = new Error(nt);
        throw kt.hash = ut, kt;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ u(function(nt) {
      var ut = this, kt = [0], X = [], ft = [null], P = [], At = this.table, q = "", vt = 0, ct = 0, Nt = 2, pt = 1, gt = P.slice.call(arguments, 1), Jt = Object.create(this.lexer), Et = { yy: {} };
      for (var ue in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, ue) && (Et.yy[ue] = this.yy[ue]);
      Jt.setInput(nt, Et.yy), Et.yy.lexer = Jt, Et.yy.parser = this, typeof Jt.yylloc > "u" && (Jt.yylloc = {});
      var Ke = Jt.yylloc;
      P.push(Ke);
      var se = Jt.options && Jt.options.ranges;
      typeof Et.yy.parseError == "function" ? this.parseError = Et.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function me($t) {
        kt.length = kt.length - 2 * $t, ft.length = ft.length - $t, P.length = P.length - $t;
      }
      u(me, "popStack");
      function Pe() {
        var $t;
        return $t = X.pop() || Jt.lex() || pt, typeof $t != "number" && ($t instanceof Array && (X = $t, $t = X.pop()), $t = ut.symbols_[$t] || $t), $t;
      }
      u(Pe, "lex");
      for (var Gt, Se, ve, Ue, qt = {}, ye, Mt, ae, Zt; ; ) {
        if (Se = kt[kt.length - 1], this.defaultActions[Se] ? ve = this.defaultActions[Se] : ((Gt === null || typeof Gt > "u") && (Gt = Pe()), ve = At[Se] && At[Se][Gt]), typeof ve > "u" || !ve.length || !ve[0]) {
          var jt = "";
          Zt = [];
          for (ye in At[Se])
            this.terminals_[ye] && ye > Nt && Zt.push("'" + this.terminals_[ye] + "'");
          Jt.showPosition ? jt = "Parse error on line " + (vt + 1) + `:
` + Jt.showPosition() + `
Expecting ` + Zt.join(", ") + ", got '" + (this.terminals_[Gt] || Gt) + "'" : jt = "Parse error on line " + (vt + 1) + ": Unexpected " + (Gt == pt ? "end of input" : "'" + (this.terminals_[Gt] || Gt) + "'"), this.parseError(jt, {
            text: Jt.match,
            token: this.terminals_[Gt] || Gt,
            line: Jt.yylineno,
            loc: Ke,
            expected: Zt
          });
        }
        if (ve[0] instanceof Array && ve.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + Se + ", token: " + Gt);
        switch (ve[0]) {
          case 1:
            kt.push(Gt), ft.push(Jt.yytext), P.push(Jt.yylloc), kt.push(ve[1]), Gt = null, ct = Jt.yyleng, q = Jt.yytext, vt = Jt.yylineno, Ke = Jt.yylloc;
            break;
          case 2:
            if (Mt = this.productions_[ve[1]][1], qt.$ = ft[ft.length - Mt], qt._$ = {
              first_line: P[P.length - (Mt || 1)].first_line,
              last_line: P[P.length - 1].last_line,
              first_column: P[P.length - (Mt || 1)].first_column,
              last_column: P[P.length - 1].last_column
            }, se && (qt._$.range = [
              P[P.length - (Mt || 1)].range[0],
              P[P.length - 1].range[1]
            ]), Ue = this.performAction.apply(qt, [
              q,
              ct,
              vt,
              Et.yy,
              ve[1],
              ft,
              P
            ].concat(gt)), typeof Ue < "u")
              return Ue;
            Mt && (kt = kt.slice(0, -1 * Mt * 2), ft = ft.slice(0, -1 * Mt), P = P.slice(0, -1 * Mt)), kt.push(this.productions_[ve[1]][0]), ft.push(qt.$), P.push(qt._$), ae = At[kt[kt.length - 2]][kt[kt.length - 1]], kt.push(ae);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, ie = /* @__PURE__ */ function() {
    var wt = {
      EOF: 1,
      parseError: /* @__PURE__ */ u(function(ut, kt) {
        if (this.yy.parser)
          this.yy.parser.parseError(ut, kt);
        else
          throw new Error(ut);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ u(function(nt, ut) {
        return this.yy = ut || this.yy || {}, this._input = nt, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ u(function() {
        var nt = this._input[0];
        this.yytext += nt, this.yyleng++, this.offset++, this.match += nt, this.matched += nt;
        var ut = nt.match(/(?:\r\n?|\n).*/g);
        return ut ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), nt;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ u(function(nt) {
        var ut = nt.length, kt = nt.split(/(?:\r\n?|\n)/g);
        this._input = nt + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - ut), this.offset -= ut;
        var X = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), kt.length - 1 && (this.yylineno -= kt.length - 1);
        var ft = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: kt ? (kt.length === X.length ? this.yylloc.first_column : 0) + X[X.length - kt.length].length - kt[0].length : this.yylloc.first_column - ut
        }, this.options.ranges && (this.yylloc.range = [ft[0], ft[0] + this.yyleng - ut]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ u(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ u(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ u(function(nt) {
        this.unput(this.match.slice(nt));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ u(function() {
        var nt = this.matched.substr(0, this.matched.length - this.match.length);
        return (nt.length > 20 ? "..." : "") + nt.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ u(function() {
        var nt = this.match;
        return nt.length < 20 && (nt += this._input.substr(0, 20 - nt.length)), (nt.substr(0, 20) + (nt.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ u(function() {
        var nt = this.pastInput(), ut = new Array(nt.length + 1).join("-");
        return nt + this.upcomingInput() + `
` + ut + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ u(function(nt, ut) {
        var kt, X, ft;
        if (this.options.backtrack_lexer && (ft = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (ft.yylloc.range = this.yylloc.range.slice(0))), X = nt[0].match(/(?:\r\n?|\n).*/g), X && (this.yylineno += X.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: X ? X[X.length - 1].length - X[X.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + nt[0].length
        }, this.yytext += nt[0], this.match += nt[0], this.matches = nt, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(nt[0].length), this.matched += nt[0], kt = this.performAction.call(this, this.yy, this, ut, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), kt)
          return kt;
        if (this._backtrack) {
          for (var P in ft)
            this[P] = ft[P];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ u(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var nt, ut, kt, X;
        this._more || (this.yytext = "", this.match = "");
        for (var ft = this._currentRules(), P = 0; P < ft.length; P++)
          if (kt = this._input.match(this.rules[ft[P]]), kt && (!ut || kt[0].length > ut[0].length)) {
            if (ut = kt, X = P, this.options.backtrack_lexer) {
              if (nt = this.test_match(kt, ft[P]), nt !== !1)
                return nt;
              if (this._backtrack) {
                ut = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return ut ? (nt = this.test_match(ut, ft[X]), nt !== !1 ? nt : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ u(function() {
        var ut = this.next();
        return ut || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ u(function(ut) {
        this.conditionStack.push(ut);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ u(function() {
        var ut = this.conditionStack.length - 1;
        return ut > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ u(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ u(function(ut) {
        return ut = this.conditionStack.length - 1 - Math.abs(ut || 0), ut >= 0 ? this.conditionStack[ut] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ u(function(ut) {
        this.begin(ut);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ u(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: {},
      performAction: /* @__PURE__ */ u(function(ut, kt, X, ft) {
        switch (X) {
          case 0:
            return 62;
          case 1:
            return 63;
          case 2:
            return 64;
          case 3:
            return 65;
          case 4:
            break;
          case 5:
            break;
          case 6:
            return this.begin("acc_title"), 33;
          case 7:
            return this.popState(), "acc_title_value";
          case 8:
            return this.begin("acc_descr"), 35;
          case 9:
            return this.popState(), "acc_descr_value";
          case 10:
            this.begin("acc_descr_multiline");
            break;
          case 11:
            this.popState();
            break;
          case 12:
            return "acc_descr_multiline_value";
          case 13:
            return 8;
          case 14:
            break;
          case 15:
            return 7;
          case 16:
            return 7;
          case 17:
            return "EDGE_STATE";
          case 18:
            this.begin("callback_name");
            break;
          case 19:
            this.popState();
            break;
          case 20:
            this.popState(), this.begin("callback_args");
            break;
          case 21:
            return 79;
          case 22:
            this.popState();
            break;
          case 23:
            return 80;
          case 24:
            this.popState();
            break;
          case 25:
            return "STR";
          case 26:
            this.begin("string");
            break;
          case 27:
            return 82;
          case 28:
            return 57;
          case 29:
            return this.begin("namespace"), 42;
          case 30:
            return this.popState(), 8;
          case 31:
            break;
          case 32:
            return this.begin("namespace-body"), 39;
          case 33:
            return this.popState(), 41;
          case 34:
            return "EOF_IN_STRUCT";
          case 35:
            return 8;
          case 36:
            break;
          case 37:
            return "EDGE_STATE";
          case 38:
            return this.begin("class"), 46;
          case 39:
            return this.popState(), 8;
          case 40:
            break;
          case 41:
            return this.popState(), this.popState(), 41;
          case 42:
            return this.begin("class-body"), 39;
          case 43:
            return this.popState(), 41;
          case 44:
            return "EOF_IN_STRUCT";
          case 45:
            return "EDGE_STATE";
          case 46:
            return "OPEN_IN_STRUCT";
          case 47:
            break;
          case 48:
            return "MEMBER";
          case 49:
            return 83;
          case 50:
            return 75;
          case 51:
            return 76;
          case 52:
            return 78;
          case 53:
            return 54;
          case 54:
            return 56;
          case 55:
            return 49;
          case 56:
            return 50;
          case 57:
            return 81;
          case 58:
            this.popState();
            break;
          case 59:
            return "GENERICTYPE";
          case 60:
            this.begin("generic");
            break;
          case 61:
            this.popState();
            break;
          case 62:
            return "BQUOTE_STR";
          case 63:
            this.begin("bqstring");
            break;
          case 64:
            return 77;
          case 65:
            return 77;
          case 66:
            return 77;
          case 67:
            return 77;
          case 68:
            return 69;
          case 69:
            return 69;
          case 70:
            return 71;
          case 71:
            return 71;
          case 72:
            return 70;
          case 73:
            return 68;
          case 74:
            return 72;
          case 75:
            return 73;
          case 76:
            return 74;
          case 77:
            return 22;
          case 78:
            return 44;
          case 79:
            return 100;
          case 80:
            return 18;
          case 81:
            return "PLUS";
          case 82:
            return 87;
          case 83:
            return 61;
          case 84:
            return 89;
          case 85:
            return 89;
          case 86:
            return 90;
          case 87:
            return "EQUALS";
          case 88:
            return "EQUALS";
          case 89:
            return 60;
          case 90:
            return 12;
          case 91:
            return 14;
          case 92:
            return "PUNCTUATION";
          case 93:
            return 86;
          case 94:
            return 102;
          case 95:
            return 48;
          case 96:
            return 48;
          case 97:
            return 9;
        }
      }, "anonymous"),
      rules: [/^(?:.*direction\s+TB[^\n]*)/, /^(?:.*direction\s+BT[^\n]*)/, /^(?:.*direction\s+RL[^\n]*)/, /^(?:.*direction\s+LR[^\n]*)/, /^(?:%%(?!\{)*[^\n]*(\r?\n?)+)/, /^(?:%%[^\n]*(\r?\n)*)/, /^(?:accTitle\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*\{\s*)/, /^(?:[\}])/, /^(?:[^\}]*)/, /^(?:\s*(\r?\n)+)/, /^(?:\s+)/, /^(?:classDiagram-v2\b)/, /^(?:classDiagram\b)/, /^(?:\[\*\])/, /^(?:call[\s]+)/, /^(?:\([\s]*\))/, /^(?:\()/, /^(?:[^(]*)/, /^(?:\))/, /^(?:[^)]*)/, /^(?:["])/, /^(?:[^"]*)/, /^(?:["])/, /^(?:style\b)/, /^(?:classDef\b)/, /^(?:namespace\b)/, /^(?:\s*(\r?\n)+)/, /^(?:\s+)/, /^(?:[{])/, /^(?:[}])/, /^(?:$)/, /^(?:\s*(\r?\n)+)/, /^(?:\s+)/, /^(?:\[\*\])/, /^(?:class\b)/, /^(?:\s*(\r?\n)+)/, /^(?:\s+)/, /^(?:[}])/, /^(?:[{])/, /^(?:[}])/, /^(?:$)/, /^(?:\[\*\])/, /^(?:[{])/, /^(?:[\n])/, /^(?:[^{}\n]*)/, /^(?:cssClass\b)/, /^(?:callback\b)/, /^(?:link\b)/, /^(?:click\b)/, /^(?:note for\b)/, /^(?:note\b)/, /^(?:<<)/, /^(?:>>)/, /^(?:href\b)/, /^(?:[~])/, /^(?:[^~]*)/, /^(?:~)/, /^(?:[`])/, /^(?:[^`]+)/, /^(?:[`])/, /^(?:_self\b)/, /^(?:_blank\b)/, /^(?:_parent\b)/, /^(?:_top\b)/, /^(?:\s*<\|)/, /^(?:\s*\|>)/, /^(?:\s*>)/, /^(?:\s*<)/, /^(?:\s*\*)/, /^(?:\s*o\b)/, /^(?:\s*\(\))/, /^(?:--)/, /^(?:\.\.)/, /^(?::{1}[^:\n;]+)/, /^(?::{3})/, /^(?:-)/, /^(?:\.)/, /^(?:\+)/, /^(?::)/, /^(?:,)/, /^(?:#)/, /^(?:#)/, /^(?:%)/, /^(?:=)/, /^(?:=)/, /^(?:\w+)/, /^(?:\[)/, /^(?:\])/, /^(?:[!"#$%&'*+,-.`?\\/])/, /^(?:[0-9]+)/, /^(?:[\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6]|[\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377]|[\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5]|[\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA]|[\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE]|[\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA]|[\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0]|[\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977]|[\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2]|[\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A]|[\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39]|[\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8]|[\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C]|[\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C]|[\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99]|[\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0]|[\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D]|[\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3]|[\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10]|[\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1]|[\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81]|[\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3]|[\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6]|[\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A]|[\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081]|[\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D]|[\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0]|[\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310]|[\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C]|[\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711]|[\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7]|[\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C]|[\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16]|[\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF]|[\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC]|[\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D]|[\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D]|[\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3]|[\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F]|[\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128]|[\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184]|[\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3]|[\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6]|[\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE]|[\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C]|[\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D]|[\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC]|[\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B]|[\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788]|[\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805]|[\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB]|[\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28]|[\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5]|[\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4]|[\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E]|[\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D]|[\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36]|[\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D]|[\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC]|[\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF]|[\uFFD2-\uFFD7\uFFDA-\uFFDC])/, /^(?:\s)/, /^(?:\s)/, /^(?:$)/],
      conditions: { "namespace-body": { rules: [26, 33, 34, 35, 36, 37, 38, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], inclusive: !1 }, namespace: { rules: [26, 29, 30, 31, 32, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], inclusive: !1 }, "class-body": { rules: [26, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], inclusive: !1 }, class: { rules: [26, 39, 40, 41, 42, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], inclusive: !1 }, acc_descr_multiline: { rules: [11, 12, 26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], inclusive: !1 }, acc_descr: { rules: [9, 26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], inclusive: !1 }, acc_title: { rules: [7, 26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], inclusive: !1 }, callback_args: { rules: [22, 23, 26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], inclusive: !1 }, callback_name: { rules: [19, 20, 21, 26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], inclusive: !1 }, href: { rules: [26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], inclusive: !1 }, struct: { rules: [26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], inclusive: !1 }, generic: { rules: [26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], inclusive: !1 }, bqstring: { rules: [26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], inclusive: !1 }, string: { rules: [24, 25, 26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97], inclusive: !1 }, INITIAL: { rules: [0, 1, 2, 3, 4, 5, 6, 8, 10, 13, 14, 15, 16, 17, 18, 26, 27, 28, 29, 38, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97], inclusive: !0 } }
    };
    return wt;
  }();
  Wt.lexer = ie;
  function dt() {
    this.yy = {};
  }
  return u(dt, "Parser"), dt.prototype = Wt, Wt.Parser = dt, new dt();
}();
lc.parser = lc;
var V2 = lc, Lu = ["#", "+", "~", "-", ""], ia, Bu = (ia = class {
  constructor(t, r) {
    this.memberType = r, this.visibility = "", this.classifier = "", this.text = "";
    const i = ge(t, K());
    this.parseMember(i);
  }
  getDisplayDetails() {
    let t = this.visibility + vi(this.id);
    this.memberType === "method" && (t += `(${vi(this.parameters.trim())})`, this.returnType && (t += " : " + vi(this.returnType))), t = t.trim();
    const r = this.parseClassifier();
    return {
      displayText: t,
      cssStyle: r
    };
  }
  parseMember(t) {
    let r = "";
    if (this.memberType === "method") {
      const a = /([#+~-])?(.+)\((.*)\)([\s$*])?(.*)([$*])?/.exec(t);
      if (a) {
        const n = a[1] ? a[1].trim() : "";
        if (Lu.includes(n) && (this.visibility = n), this.id = a[2], this.parameters = a[3] ? a[3].trim() : "", r = a[4] ? a[4].trim() : "", this.returnType = a[5] ? a[5].trim() : "", r === "") {
          const o = this.returnType.substring(this.returnType.length - 1);
          /[$*]/.exec(o) && (r = o, this.returnType = this.returnType.substring(0, this.returnType.length - 1));
        }
      }
    } else {
      const s = t.length, a = t.substring(0, 1), n = t.substring(s - 1);
      Lu.includes(a) && (this.visibility = a), /[$*]/.exec(n) && (r = n), this.id = t.substring(
        this.visibility === "" ? 0 : 1,
        r === "" ? s : s - 1
      );
    }
    this.classifier = r, this.id = this.id.startsWith(" ") ? " " + this.id.trim() : this.id.trim();
    const i = `${this.visibility ? "\\" + this.visibility : ""}${vi(this.id)}${this.memberType === "method" ? `(${vi(this.parameters)})${this.returnType ? " : " + vi(this.returnType) : ""}` : ""}`;
    this.text = i.replaceAll("<", "&lt;").replaceAll(">", "&gt;"), this.text.startsWith("\\&lt;") && (this.text = this.text.replace("\\&lt;", "~"));
  }
  parseClassifier() {
    switch (this.classifier) {
      case "*":
        return "font-style:italic;";
      case "$":
        return "text-decoration:underline;";
      default:
        return "";
    }
  }
}, u(ia, "ClassMember"), ia), An = "classId-", Du = 0, qi = /* @__PURE__ */ u((e) => St.sanitizeText(e, K()), "sanitizeText"), sa, z2 = (sa = class {
  constructor() {
    this.relations = [], this.classes = /* @__PURE__ */ new Map(), this.styleClasses = /* @__PURE__ */ new Map(), this.notes = [], this.interfaces = [], this.namespaces = /* @__PURE__ */ new Map(), this.namespaceCounter = 0, this.functions = [], this.lineType = {
      LINE: 0,
      DOTTED_LINE: 1
    }, this.relationType = {
      AGGREGATION: 0,
      EXTENSION: 1,
      COMPOSITION: 2,
      DEPENDENCY: 3,
      LOLLIPOP: 4
    }, this.setupToolTips = /* @__PURE__ */ u((t) => {
      let r = yt(".mermaidTooltip");
      (r._groups || r)[0][0] === null && (r = yt("body").append("div").attr("class", "mermaidTooltip").style("opacity", 0)), yt(t).select("svg").selectAll("g.node").on("mouseover", (a) => {
        const n = yt(a.currentTarget);
        if (n.attr("title") === null)
          return;
        const h = this.getBoundingClientRect();
        r.transition().duration(200).style("opacity", ".9"), r.text(n.attr("title")).style("left", window.scrollX + h.left + (h.right - h.left) / 2 + "px").style("top", window.scrollY + h.top - 14 + document.body.scrollTop + "px"), r.html(r.html().replace(/&lt;br\/&gt;/g, "<br/>")), n.classed("hover", !0);
      }).on("mouseout", (a) => {
        r.transition().duration(500).style("opacity", 0), yt(a.currentTarget).classed("hover", !1);
      });
    }, "setupToolTips"), this.direction = "TB", this.setAccTitle = Re, this.getAccTitle = qe, this.setAccDescription = Ye, this.getAccDescription = He, this.setDiagramTitle = Ge, this.getDiagramTitle = Oe, this.getConfig = /* @__PURE__ */ u(() => K().class, "getConfig"), this.functions.push(this.setupToolTips.bind(this)), this.clear(), this.addRelation = this.addRelation.bind(this), this.addClassesToNamespace = this.addClassesToNamespace.bind(this), this.addNamespace = this.addNamespace.bind(this), this.setCssClass = this.setCssClass.bind(this), this.addMembers = this.addMembers.bind(this), this.addClass = this.addClass.bind(this), this.setClassLabel = this.setClassLabel.bind(this), this.addAnnotation = this.addAnnotation.bind(this), this.addMember = this.addMember.bind(this), this.cleanupLabel = this.cleanupLabel.bind(this), this.addNote = this.addNote.bind(this), this.defineClass = this.defineClass.bind(this), this.setDirection = this.setDirection.bind(this), this.setLink = this.setLink.bind(this), this.bindFunctions = this.bindFunctions.bind(this), this.clear = this.clear.bind(this), this.setTooltip = this.setTooltip.bind(this), this.setClickEvent = this.setClickEvent.bind(this), this.setCssStyle = this.setCssStyle.bind(this);
  }
  splitClassNameAndType(t) {
    const r = St.sanitizeText(t, K());
    let i = "", s = r;
    if (r.indexOf("~") > 0) {
      const a = r.split("~");
      s = qi(a[0]), i = qi(a[1]);
    }
    return { className: s, type: i };
  }
  setClassLabel(t, r) {
    const i = St.sanitizeText(t, K());
    r && (r = qi(r));
    const { className: s } = this.splitClassNameAndType(i);
    this.classes.get(s).label = r, this.classes.get(s).text = `${r}${this.classes.get(s).type ? `<${this.classes.get(s).type}>` : ""}`;
  }
  /**
   * Function called by parser when a node definition has been found.
   *
   * @param id - ID of the class to add
   * @public
   */
  addClass(t) {
    const r = St.sanitizeText(t, K()), { className: i, type: s } = this.splitClassNameAndType(r);
    if (this.classes.has(i))
      return;
    const a = St.sanitizeText(i, K());
    this.classes.set(a, {
      id: a,
      type: s,
      label: a,
      text: `${a}${s ? `&lt;${s}&gt;` : ""}`,
      shape: "classBox",
      cssClasses: "default",
      methods: [],
      members: [],
      annotations: [],
      styles: [],
      domId: An + a + "-" + Du
    }), Du++;
  }
  addInterface(t, r) {
    const i = {
      id: `interface${this.interfaces.length}`,
      label: t,
      classId: r
    };
    this.interfaces.push(i);
  }
  /**
   * Function to lookup domId from id in the graph definition.
   *
   * @param id - class ID to lookup
   * @public
   */
  lookUpDomId(t) {
    const r = St.sanitizeText(t, K());
    if (this.classes.has(r))
      return this.classes.get(r).domId;
    throw new Error("Class not found: " + r);
  }
  clear() {
    this.relations = [], this.classes = /* @__PURE__ */ new Map(), this.notes = [], this.interfaces = [], this.functions = [], this.functions.push(this.setupToolTips.bind(this)), this.namespaces = /* @__PURE__ */ new Map(), this.namespaceCounter = 0, this.direction = "TB", Me();
  }
  getClass(t) {
    return this.classes.get(t);
  }
  getClasses() {
    return this.classes;
  }
  getRelations() {
    return this.relations;
  }
  getNotes() {
    return this.notes;
  }
  addRelation(t) {
    I.debug("Adding relation: " + JSON.stringify(t));
    const r = [
      this.relationType.LOLLIPOP,
      this.relationType.AGGREGATION,
      this.relationType.COMPOSITION,
      this.relationType.DEPENDENCY,
      this.relationType.EXTENSION
    ];
    t.relation.type1 === this.relationType.LOLLIPOP && !r.includes(t.relation.type2) ? (this.addClass(t.id2), this.addInterface(t.id1, t.id2), t.id1 = `interface${this.interfaces.length - 1}`) : t.relation.type2 === this.relationType.LOLLIPOP && !r.includes(t.relation.type1) ? (this.addClass(t.id1), this.addInterface(t.id2, t.id1), t.id2 = `interface${this.interfaces.length - 1}`) : (this.addClass(t.id1), this.addClass(t.id2)), t.id1 = this.splitClassNameAndType(t.id1).className, t.id2 = this.splitClassNameAndType(t.id2).className, t.relationTitle1 = St.sanitizeText(
      t.relationTitle1.trim(),
      K()
    ), t.relationTitle2 = St.sanitizeText(
      t.relationTitle2.trim(),
      K()
    ), this.relations.push(t);
  }
  /**
   * Adds an annotation to the specified class Annotations mark special properties of the given type
   * (like 'interface' or 'service')
   *
   * @param className - The class name
   * @param annotation - The name of the annotation without any brackets
   * @public
   */
  addAnnotation(t, r) {
    const i = this.splitClassNameAndType(t).className;
    this.classes.get(i).annotations.push(r);
  }
  /**
   * Adds a member to the specified class
   *
   * @param className - The class name
   * @param member - The full name of the member. If the member is enclosed in `<<brackets>>` it is
   *   treated as an annotation If the member is ending with a closing bracket ) it is treated as a
   *   method Otherwise the member will be treated as a normal property
   * @public
   */
  addMember(t, r) {
    this.addClass(t);
    const i = this.splitClassNameAndType(t).className, s = this.classes.get(i);
    if (typeof r == "string") {
      const a = r.trim();
      a.startsWith("<<") && a.endsWith(">>") ? s.annotations.push(qi(a.substring(2, a.length - 2))) : a.indexOf(")") > 0 ? s.methods.push(new Bu(a, "method")) : a && s.members.push(new Bu(a, "attribute"));
    }
  }
  addMembers(t, r) {
    Array.isArray(r) && (r.reverse(), r.forEach((i) => this.addMember(t, i)));
  }
  addNote(t, r) {
    const i = {
      id: `note${this.notes.length}`,
      class: r,
      text: t
    };
    this.notes.push(i);
  }
  cleanupLabel(t) {
    return t.startsWith(":") && (t = t.substring(1)), qi(t.trim());
  }
  /**
   * Called by parser when assigning cssClass to a class
   *
   * @param ids - Comma separated list of ids
   * @param className - Class to add
   */
  setCssClass(t, r) {
    t.split(",").forEach((i) => {
      let s = i;
      /\d/.exec(i[0]) && (s = An + s);
      const a = this.classes.get(s);
      a && (a.cssClasses += " " + r);
    });
  }
  defineClass(t, r) {
    for (const i of t) {
      let s = this.styleClasses.get(i);
      s === void 0 && (s = { id: i, styles: [], textStyles: [] }, this.styleClasses.set(i, s)), r && r.forEach((a) => {
        if (/color/.exec(a)) {
          const n = a.replace("fill", "bgFill");
          s.textStyles.push(n);
        }
        s.styles.push(a);
      }), this.classes.forEach((a) => {
        a.cssClasses.includes(i) && a.styles.push(...r.flatMap((n) => n.split(",")));
      });
    }
  }
  /**
   * Called by parser when a tooltip is found, e.g. a clickable element.
   *
   * @param ids - Comma separated list of ids
   * @param tooltip - Tooltip to add
   */
  setTooltip(t, r) {
    t.split(",").forEach((i) => {
      r !== void 0 && (this.classes.get(i).tooltip = qi(r));
    });
  }
  getTooltip(t, r) {
    return r && this.namespaces.has(r) ? this.namespaces.get(r).classes.get(t).tooltip : this.classes.get(t).tooltip;
  }
  /**
   * Called by parser when a link is found. Adds the URL to the vertex data.
   *
   * @param ids - Comma separated list of ids
   * @param linkStr - URL to create a link for
   * @param target - Target of the link, _blank by default as originally defined in the svgDraw.js file
   */
  setLink(t, r, i) {
    const s = K();
    t.split(",").forEach((a) => {
      let n = a;
      /\d/.exec(a[0]) && (n = An + n);
      const o = this.classes.get(n);
      o && (o.link = ee.formatUrl(r, s), s.securityLevel === "sandbox" ? o.linkTarget = "_top" : typeof i == "string" ? o.linkTarget = qi(i) : o.linkTarget = "_blank");
    }), this.setCssClass(t, "clickable");
  }
  /**
   * Called by parser when a click definition is found. Registers an event handler.
   *
   * @param ids - Comma separated list of ids
   * @param functionName - Function to be called on click
   * @param functionArgs - Function args the function should be called with
   */
  setClickEvent(t, r, i) {
    t.split(",").forEach((s) => {
      this.setClickFunc(s, r, i), this.classes.get(s).haveCallback = !0;
    }), this.setCssClass(t, "clickable");
  }
  setClickFunc(t, r, i) {
    const s = St.sanitizeText(t, K());
    if (K().securityLevel !== "loose" || r === void 0)
      return;
    const n = s;
    if (this.classes.has(n)) {
      const o = this.lookUpDomId(n);
      let h = [];
      if (typeof i == "string") {
        h = i.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
        for (let l = 0; l < h.length; l++) {
          let d = h[l].trim();
          d.startsWith('"') && d.endsWith('"') && (d = d.substr(1, d.length - 2)), h[l] = d;
        }
      }
      h.length === 0 && h.push(o), this.functions.push(() => {
        const l = document.querySelector(`[id="${o}"]`);
        l !== null && l.addEventListener(
          "click",
          () => {
            ee.runFunc(r, ...h);
          },
          !1
        );
      });
    }
  }
  bindFunctions(t) {
    this.functions.forEach((r) => {
      r(t);
    });
  }
  getDirection() {
    return this.direction;
  }
  setDirection(t) {
    this.direction = t;
  }
  /**
   * Function called by parser when a namespace definition has been found.
   *
   * @param id - ID of the namespace to add
   * @public
   */
  addNamespace(t) {
    this.namespaces.has(t) || (this.namespaces.set(t, {
      id: t,
      classes: /* @__PURE__ */ new Map(),
      children: {},
      domId: An + t + "-" + this.namespaceCounter
    }), this.namespaceCounter++);
  }
  getNamespace(t) {
    return this.namespaces.get(t);
  }
  getNamespaces() {
    return this.namespaces;
  }
  /**
   * Function called by parser when a namespace definition has been found.
   *
   * @param id - ID of the namespace to add
   * @param classNames - IDs of the class to add
   * @public
   */
  addClassesToNamespace(t, r) {
    if (this.namespaces.has(t))
      for (const i of r) {
        const { className: s } = this.splitClassNameAndType(i);
        this.classes.get(s).parent = t, this.namespaces.get(t).classes.set(s, this.classes.get(s));
      }
  }
  setCssStyle(t, r) {
    const i = this.classes.get(t);
    if (!(!r || !i))
      for (const s of r)
        s.includes(",") ? i.styles.push(...s.split(",")) : i.styles.push(s);
  }
  /**
   * Gets the arrow marker for a type index
   *
   * @param type - The type to look for
   * @returns The arrow marker
   */
  getArrowMarker(t) {
    let r;
    switch (t) {
      case 0:
        r = "aggregation";
        break;
      case 1:
        r = "extension";
        break;
      case 2:
        r = "composition";
        break;
      case 3:
        r = "dependency";
        break;
      case 4:
        r = "lollipop";
        break;
      default:
        r = "none";
    }
    return r;
  }
  getData() {
    var a;
    const t = [], r = [], i = K();
    for (const n of this.namespaces.keys()) {
      const o = this.namespaces.get(n);
      if (o) {
        const h = {
          id: o.id,
          label: o.id,
          isGroup: !0,
          padding: i.class.padding ?? 16,
          // parent node must be one of [rect, roundedWithTitle, noteGroup, divider]
          shape: "rect",
          cssStyles: ["fill: none", "stroke: black"],
          look: i.look
        };
        t.push(h);
      }
    }
    for (const n of this.classes.keys()) {
      const o = this.classes.get(n);
      if (o) {
        const h = o;
        h.parentId = o.parent, h.look = i.look, t.push(h);
      }
    }
    let s = 0;
    for (const n of this.notes) {
      s++;
      const o = {
        id: n.id,
        label: n.text,
        isGroup: !1,
        shape: "note",
        padding: i.class.padding ?? 6,
        cssStyles: [
          "text-align: left",
          "white-space: nowrap",
          `fill: ${i.themeVariables.noteBkgColor}`,
          `stroke: ${i.themeVariables.noteBorderColor}`
        ],
        look: i.look
      };
      t.push(o);
      const h = ((a = this.classes.get(n.class)) == null ? void 0 : a.id) ?? "";
      if (h) {
        const l = {
          id: `edgeNote${s}`,
          start: n.id,
          end: h,
          type: "normal",
          thickness: "normal",
          classes: "relation",
          arrowTypeStart: "none",
          arrowTypeEnd: "none",
          arrowheadStyle: "",
          labelStyle: [""],
          style: ["fill: none"],
          pattern: "dotted",
          look: i.look
        };
        r.push(l);
      }
    }
    for (const n of this.interfaces) {
      const o = {
        id: n.id,
        label: n.label,
        isGroup: !1,
        shape: "rect",
        cssStyles: ["opacity: 0;"],
        look: i.look
      };
      t.push(o);
    }
    s = 0;
    for (const n of this.relations) {
      s++;
      const o = {
        id: Es(n.id1, n.id2, {
          prefix: "id",
          counter: s
        }),
        start: n.id1,
        end: n.id2,
        type: "normal",
        label: n.title,
        labelpos: "c",
        thickness: "normal",
        classes: "relation",
        arrowTypeStart: this.getArrowMarker(n.relation.type1),
        arrowTypeEnd: this.getArrowMarker(n.relation.type2),
        startLabelRight: n.relationTitle1 === "none" ? "" : n.relationTitle1,
        endLabelLeft: n.relationTitle2 === "none" ? "" : n.relationTitle2,
        arrowheadStyle: "",
        labelStyle: ["display: inline-block"],
        style: n.style || "",
        pattern: n.relation.lineType == 1 ? "dashed" : "solid",
        look: i.look
      };
      r.push(o);
    }
    return { nodes: t, edges: r, other: {}, config: i, direction: this.getDirection() };
  }
}, u(sa, "ClassDB"), sa), Qw = /* @__PURE__ */ u((e) => `g.classGroup text {
  fill: ${e.nodeBorder || e.classText};
  stroke: none;
  font-family: ${e.fontFamily};
  font-size: 10px;

  .title {
    font-weight: bolder;
  }

}

.nodeLabel, .edgeLabel {
  color: ${e.classText};
}
.edgeLabel .label rect {
  fill: ${e.mainBkg};
}
.label text {
  fill: ${e.classText};
}

.labelBkg {
  background: ${e.mainBkg};
}
.edgeLabel .label span {
  background: ${e.mainBkg};
}

.classTitle {
  font-weight: bolder;
}
.node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${e.mainBkg};
    stroke: ${e.nodeBorder};
    stroke-width: 1px;
  }


.divider {
  stroke: ${e.nodeBorder};
  stroke-width: 1;
}

g.clickable {
  cursor: pointer;
}

g.classGroup rect {
  fill: ${e.mainBkg};
  stroke: ${e.nodeBorder};
}

g.classGroup line {
  stroke: ${e.nodeBorder};
  stroke-width: 1;
}

.classLabel .box {
  stroke: none;
  stroke-width: 0;
  fill: ${e.mainBkg};
  opacity: 0.5;
}

.classLabel .label {
  fill: ${e.nodeBorder};
  font-size: 10px;
}

.relation {
  stroke: ${e.lineColor};
  stroke-width: 1;
  fill: none;
}

.dashed-line{
  stroke-dasharray: 3;
}

.dotted-line{
  stroke-dasharray: 1 2;
}

#compositionStart, .composition {
  fill: ${e.lineColor} !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#compositionEnd, .composition {
  fill: ${e.lineColor} !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#dependencyStart, .dependency {
  fill: ${e.lineColor} !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#dependencyStart, .dependency {
  fill: ${e.lineColor} !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#extensionStart, .extension {
  fill: transparent !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#extensionEnd, .extension {
  fill: transparent !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#aggregationStart, .aggregation {
  fill: transparent !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#aggregationEnd, .aggregation {
  fill: transparent !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#lollipopStart, .lollipop {
  fill: ${e.mainBkg} !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#lollipopEnd, .lollipop {
  fill: ${e.mainBkg} !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

.edgeTerminals {
  font-size: 11px;
  line-height: initial;
}

.classTitleText {
  text-anchor: middle;
  font-size: 18px;
  fill: ${e.textColor};
}
  ${yn()}
`, "getStyles"), W2 = Qw, Zw = /* @__PURE__ */ u((e, t = "TB") => {
  if (!e.doc)
    return t;
  let r = t;
  for (const i of e.doc)
    i.stmt === "dir" && (r = i.value);
  return r;
}, "getDir"), Jw = /* @__PURE__ */ u(function(e, t) {
  return t.db.getClasses();
}, "getClasses"), tT = /* @__PURE__ */ u(async function(e, t, r, i) {
  I.info("REF0:"), I.info("Drawing class diagram (v3)", t);
  const { securityLevel: s, state: a, layout: n } = K(), o = i.db.getData(), h = Ta(t, s);
  o.type = i.type, o.layoutAlgorithm = fn(n), o.nodeSpacing = (a == null ? void 0 : a.nodeSpacing) || 50, o.rankSpacing = (a == null ? void 0 : a.rankSpacing) || 50, o.markers = ["aggregation", "extension", "composition", "dependency", "lollipop"], o.diagramId = t, await wa(o, h);
  const l = 8;
  ee.insertTitle(
    h,
    "classDiagramTitleText",
    (a == null ? void 0 : a.titleTopMargin) ?? 25,
    i.db.getDiagramTitle()
  ), cs(h, l, "classDiagram", (a == null ? void 0 : a.useMaxWidth) ?? !0);
}, "draw"), q2 = {
  getClasses: Jw,
  draw: tT,
  getDir: Zw
}, eT = {
  parser: V2,
  get db() {
    return new z2();
  },
  renderer: q2,
  styles: W2,
  init: /* @__PURE__ */ u((e) => {
    e.class || (e.class = {}), e.class.arrowMarkerAbsolute = e.arrowMarkerAbsolute;
  }, "init")
};
const rT = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: eT
}, Symbol.toStringTag, { value: "Module" }));
var iT = {
  parser: V2,
  get db() {
    return new z2();
  },
  renderer: q2,
  styles: W2,
  init: /* @__PURE__ */ u((e) => {
    e.class || (e.class = {}), e.class.arrowMarkerAbsolute = e.arrowMarkerAbsolute;
  }, "init")
};
const sT = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: iT
}, Symbol.toStringTag, { value: "Module" }));
var cc = function() {
  var e = /* @__PURE__ */ u(function(O, Y, M, G) {
    for (M = M || {}, G = O.length; G--; M[O[G]] = Y) ;
    return M;
  }, "o"), t = [1, 2], r = [1, 3], i = [1, 4], s = [2, 4], a = [1, 9], n = [1, 11], o = [1, 16], h = [1, 17], l = [1, 18], d = [1, 19], p = [1, 33], g = [1, 20], f = [1, 21], y = [1, 22], m = [1, 23], x = [1, 24], b = [1, 26], v = [1, 27], _ = [1, 28], A = [1, 29], S = [1, 30], k = [1, 31], L = [1, 32], T = [1, 35], C = [1, 36], E = [1, 37], w = [1, 38], W = [1, 34], N = [1, 4, 5, 16, 17, 19, 21, 22, 24, 25, 26, 27, 28, 29, 33, 35, 37, 38, 41, 45, 48, 51, 52, 53, 54, 57], B = [1, 4, 5, 14, 15, 16, 17, 19, 21, 22, 24, 25, 26, 27, 28, 29, 33, 35, 37, 38, 39, 40, 41, 45, 48, 51, 52, 53, 54, 57], R = [4, 5, 16, 17, 19, 21, 22, 24, 25, 26, 27, 28, 29, 33, 35, 37, 38, 41, 45, 48, 51, 52, 53, 54, 57], V = {
    trace: /* @__PURE__ */ u(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, start: 3, SPACE: 4, NL: 5, SD: 6, document: 7, line: 8, statement: 9, classDefStatement: 10, styleStatement: 11, cssClassStatement: 12, idStatement: 13, DESCR: 14, "-->": 15, HIDE_EMPTY: 16, scale: 17, WIDTH: 18, COMPOSIT_STATE: 19, STRUCT_START: 20, STRUCT_STOP: 21, STATE_DESCR: 22, AS: 23, ID: 24, FORK: 25, JOIN: 26, CHOICE: 27, CONCURRENT: 28, note: 29, notePosition: 30, NOTE_TEXT: 31, direction: 32, acc_title: 33, acc_title_value: 34, acc_descr: 35, acc_descr_value: 36, acc_descr_multiline_value: 37, CLICK: 38, STRING: 39, HREF: 40, classDef: 41, CLASSDEF_ID: 42, CLASSDEF_STYLEOPTS: 43, DEFAULT: 44, style: 45, STYLE_IDS: 46, STYLEDEF_STYLEOPTS: 47, class: 48, CLASSENTITY_IDS: 49, STYLECLASS: 50, direction_tb: 51, direction_bt: 52, direction_rl: 53, direction_lr: 54, eol: 55, ";": 56, EDGE_STATE: 57, STYLE_SEPARATOR: 58, left_of: 59, right_of: 60, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 4: "SPACE", 5: "NL", 6: "SD", 14: "DESCR", 15: "-->", 16: "HIDE_EMPTY", 17: "scale", 18: "WIDTH", 19: "COMPOSIT_STATE", 20: "STRUCT_START", 21: "STRUCT_STOP", 22: "STATE_DESCR", 23: "AS", 24: "ID", 25: "FORK", 26: "JOIN", 27: "CHOICE", 28: "CONCURRENT", 29: "note", 31: "NOTE_TEXT", 33: "acc_title", 34: "acc_title_value", 35: "acc_descr", 36: "acc_descr_value", 37: "acc_descr_multiline_value", 38: "CLICK", 39: "STRING", 40: "HREF", 41: "classDef", 42: "CLASSDEF_ID", 43: "CLASSDEF_STYLEOPTS", 44: "DEFAULT", 45: "style", 46: "STYLE_IDS", 47: "STYLEDEF_STYLEOPTS", 48: "class", 49: "CLASSENTITY_IDS", 50: "STYLECLASS", 51: "direction_tb", 52: "direction_bt", 53: "direction_rl", 54: "direction_lr", 56: ";", 57: "EDGE_STATE", 58: "STYLE_SEPARATOR", 59: "left_of", 60: "right_of" },
    productions_: [0, [3, 2], [3, 2], [3, 2], [7, 0], [7, 2], [8, 2], [8, 1], [8, 1], [9, 1], [9, 1], [9, 1], [9, 1], [9, 2], [9, 3], [9, 4], [9, 1], [9, 2], [9, 1], [9, 4], [9, 3], [9, 6], [9, 1], [9, 1], [9, 1], [9, 1], [9, 4], [9, 4], [9, 1], [9, 2], [9, 2], [9, 1], [9, 5], [9, 5], [10, 3], [10, 3], [11, 3], [12, 3], [32, 1], [32, 1], [32, 1], [32, 1], [55, 1], [55, 1], [13, 1], [13, 1], [13, 3], [13, 3], [30, 1], [30, 1]],
    performAction: /* @__PURE__ */ u(function(Y, M, G, rt, ht, Z, ot) {
      var it = Z.length - 1;
      switch (ht) {
        case 3:
          return rt.setRootDoc(Z[it]), Z[it];
        case 4:
          this.$ = [];
          break;
        case 5:
          Z[it] != "nl" && (Z[it - 1].push(Z[it]), this.$ = Z[it - 1]);
          break;
        case 6:
        case 7:
          this.$ = Z[it];
          break;
        case 8:
          this.$ = "nl";
          break;
        case 12:
          this.$ = Z[it];
          break;
        case 13:
          const at = Z[it - 1];
          at.description = rt.trimColon(Z[it]), this.$ = at;
          break;
        case 14:
          this.$ = { stmt: "relation", state1: Z[it - 2], state2: Z[it] };
          break;
        case 15:
          const lt = rt.trimColon(Z[it]);
          this.$ = { stmt: "relation", state1: Z[it - 3], state2: Z[it - 1], description: lt };
          break;
        case 19:
          this.$ = { stmt: "state", id: Z[it - 3], type: "default", description: "", doc: Z[it - 1] };
          break;
        case 20:
          var bt = Z[it], xt = Z[it - 2].trim();
          if (Z[it].match(":")) {
            var Ct = Z[it].split(":");
            bt = Ct[0], xt = [xt, Ct[1]];
          }
          this.$ = { stmt: "state", id: bt, type: "default", description: xt };
          break;
        case 21:
          this.$ = { stmt: "state", id: Z[it - 3], type: "default", description: Z[it - 5], doc: Z[it - 1] };
          break;
        case 22:
          this.$ = { stmt: "state", id: Z[it], type: "fork" };
          break;
        case 23:
          this.$ = { stmt: "state", id: Z[it], type: "join" };
          break;
        case 24:
          this.$ = { stmt: "state", id: Z[it], type: "choice" };
          break;
        case 25:
          this.$ = { stmt: "state", id: rt.getDividerId(), type: "divider" };
          break;
        case 26:
          this.$ = { stmt: "state", id: Z[it - 1].trim(), note: { position: Z[it - 2].trim(), text: Z[it].trim() } };
          break;
        case 29:
          this.$ = Z[it].trim(), rt.setAccTitle(this.$);
          break;
        case 30:
        case 31:
          this.$ = Z[it].trim(), rt.setAccDescription(this.$);
          break;
        case 32:
          this.$ = {
            stmt: "click",
            id: Z[it - 3],
            url: Z[it - 2],
            tooltip: Z[it - 1]
          };
          break;
        case 33:
          this.$ = {
            stmt: "click",
            id: Z[it - 3],
            url: Z[it - 1],
            tooltip: ""
          };
          break;
        case 34:
        case 35:
          this.$ = { stmt: "classDef", id: Z[it - 1].trim(), classes: Z[it].trim() };
          break;
        case 36:
          this.$ = { stmt: "style", id: Z[it - 1].trim(), styleClass: Z[it].trim() };
          break;
        case 37:
          this.$ = { stmt: "applyClass", id: Z[it - 1].trim(), styleClass: Z[it].trim() };
          break;
        case 38:
          rt.setDirection("TB"), this.$ = { stmt: "dir", value: "TB" };
          break;
        case 39:
          rt.setDirection("BT"), this.$ = { stmt: "dir", value: "BT" };
          break;
        case 40:
          rt.setDirection("RL"), this.$ = { stmt: "dir", value: "RL" };
          break;
        case 41:
          rt.setDirection("LR"), this.$ = { stmt: "dir", value: "LR" };
          break;
        case 44:
        case 45:
          this.$ = { stmt: "state", id: Z[it].trim(), type: "default", description: "" };
          break;
        case 46:
          this.$ = { stmt: "state", id: Z[it - 2].trim(), classes: [Z[it].trim()], type: "default", description: "" };
          break;
        case 47:
          this.$ = { stmt: "state", id: Z[it - 2].trim(), classes: [Z[it].trim()], type: "default", description: "" };
          break;
      }
    }, "anonymous"),
    table: [{ 3: 1, 4: t, 5: r, 6: i }, { 1: [3] }, { 3: 5, 4: t, 5: r, 6: i }, { 3: 6, 4: t, 5: r, 6: i }, e([1, 4, 5, 16, 17, 19, 22, 24, 25, 26, 27, 28, 29, 33, 35, 37, 38, 41, 45, 48, 51, 52, 53, 54, 57], s, { 7: 7 }), { 1: [2, 1] }, { 1: [2, 2] }, { 1: [2, 3], 4: a, 5: n, 8: 8, 9: 10, 10: 12, 11: 13, 12: 14, 13: 15, 16: o, 17: h, 19: l, 22: d, 24: p, 25: g, 26: f, 27: y, 28: m, 29: x, 32: 25, 33: b, 35: v, 37: _, 38: A, 41: S, 45: k, 48: L, 51: T, 52: C, 53: E, 54: w, 57: W }, e(N, [2, 5]), { 9: 39, 10: 12, 11: 13, 12: 14, 13: 15, 16: o, 17: h, 19: l, 22: d, 24: p, 25: g, 26: f, 27: y, 28: m, 29: x, 32: 25, 33: b, 35: v, 37: _, 38: A, 41: S, 45: k, 48: L, 51: T, 52: C, 53: E, 54: w, 57: W }, e(N, [2, 7]), e(N, [2, 8]), e(N, [2, 9]), e(N, [2, 10]), e(N, [2, 11]), e(N, [2, 12], { 14: [1, 40], 15: [1, 41] }), e(N, [2, 16]), { 18: [1, 42] }, e(N, [2, 18], { 20: [1, 43] }), { 23: [1, 44] }, e(N, [2, 22]), e(N, [2, 23]), e(N, [2, 24]), e(N, [2, 25]), { 30: 45, 31: [1, 46], 59: [1, 47], 60: [1, 48] }, e(N, [2, 28]), { 34: [1, 49] }, { 36: [1, 50] }, e(N, [2, 31]), { 13: 51, 24: p, 57: W }, { 42: [1, 52], 44: [1, 53] }, { 46: [1, 54] }, { 49: [1, 55] }, e(B, [2, 44], { 58: [1, 56] }), e(B, [2, 45], { 58: [1, 57] }), e(N, [2, 38]), e(N, [2, 39]), e(N, [2, 40]), e(N, [2, 41]), e(N, [2, 6]), e(N, [2, 13]), { 13: 58, 24: p, 57: W }, e(N, [2, 17]), e(R, s, { 7: 59 }), { 24: [1, 60] }, { 24: [1, 61] }, { 23: [1, 62] }, { 24: [2, 48] }, { 24: [2, 49] }, e(N, [2, 29]), e(N, [2, 30]), { 39: [1, 63], 40: [1, 64] }, { 43: [1, 65] }, { 43: [1, 66] }, { 47: [1, 67] }, { 50: [1, 68] }, { 24: [1, 69] }, { 24: [1, 70] }, e(N, [2, 14], { 14: [1, 71] }), { 4: a, 5: n, 8: 8, 9: 10, 10: 12, 11: 13, 12: 14, 13: 15, 16: o, 17: h, 19: l, 21: [1, 72], 22: d, 24: p, 25: g, 26: f, 27: y, 28: m, 29: x, 32: 25, 33: b, 35: v, 37: _, 38: A, 41: S, 45: k, 48: L, 51: T, 52: C, 53: E, 54: w, 57: W }, e(N, [2, 20], { 20: [1, 73] }), { 31: [1, 74] }, { 24: [1, 75] }, { 39: [1, 76] }, { 39: [1, 77] }, e(N, [2, 34]), e(N, [2, 35]), e(N, [2, 36]), e(N, [2, 37]), e(B, [2, 46]), e(B, [2, 47]), e(N, [2, 15]), e(N, [2, 19]), e(R, s, { 7: 78 }), e(N, [2, 26]), e(N, [2, 27]), { 5: [1, 79] }, { 5: [1, 80] }, { 4: a, 5: n, 8: 8, 9: 10, 10: 12, 11: 13, 12: 14, 13: 15, 16: o, 17: h, 19: l, 21: [1, 81], 22: d, 24: p, 25: g, 26: f, 27: y, 28: m, 29: x, 32: 25, 33: b, 35: v, 37: _, 38: A, 41: S, 45: k, 48: L, 51: T, 52: C, 53: E, 54: w, 57: W }, e(N, [2, 32]), e(N, [2, 33]), e(N, [2, 21])],
    defaultActions: { 5: [2, 1], 6: [2, 2], 47: [2, 48], 48: [2, 49] },
    parseError: /* @__PURE__ */ u(function(Y, M) {
      if (M.recoverable)
        this.trace(Y);
      else {
        var G = new Error(Y);
        throw G.hash = M, G;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ u(function(Y) {
      var M = this, G = [0], rt = [], ht = [null], Z = [], ot = this.table, it = "", bt = 0, xt = 0, Ct = 2, at = 1, lt = Z.slice.call(arguments, 1), Q = Object.create(this.lexer), U = { yy: {} };
      for (var et in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, et) && (U.yy[et] = this.yy[et]);
      Q.setInput(Y, U.yy), U.yy.lexer = Q, U.yy.parser = this, typeof Q.yylloc > "u" && (Q.yylloc = {});
      var z = Q.yylloc;
      Z.push(z);
      var Tt = Q.options && Q.options.ranges;
      typeof U.yy.parseError == "function" ? this.parseError = U.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function F(ft) {
        G.length = G.length - 2 * ft, ht.length = ht.length - ft, Z.length = Z.length - ft;
      }
      u(F, "popStack");
      function te() {
        var ft;
        return ft = rt.pop() || Q.lex() || at, typeof ft != "number" && (ft instanceof Array && (rt = ft, ft = rt.pop()), ft = M.symbols_[ft] || ft), ft;
      }
      u(te, "lex");
      for (var J, Ut, Wt, ie, dt = {}, wt, nt, ut, kt; ; ) {
        if (Ut = G[G.length - 1], this.defaultActions[Ut] ? Wt = this.defaultActions[Ut] : ((J === null || typeof J > "u") && (J = te()), Wt = ot[Ut] && ot[Ut][J]), typeof Wt > "u" || !Wt.length || !Wt[0]) {
          var X = "";
          kt = [];
          for (wt in ot[Ut])
            this.terminals_[wt] && wt > Ct && kt.push("'" + this.terminals_[wt] + "'");
          Q.showPosition ? X = "Parse error on line " + (bt + 1) + `:
` + Q.showPosition() + `
Expecting ` + kt.join(", ") + ", got '" + (this.terminals_[J] || J) + "'" : X = "Parse error on line " + (bt + 1) + ": Unexpected " + (J == at ? "end of input" : "'" + (this.terminals_[J] || J) + "'"), this.parseError(X, {
            text: Q.match,
            token: this.terminals_[J] || J,
            line: Q.yylineno,
            loc: z,
            expected: kt
          });
        }
        if (Wt[0] instanceof Array && Wt.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + Ut + ", token: " + J);
        switch (Wt[0]) {
          case 1:
            G.push(J), ht.push(Q.yytext), Z.push(Q.yylloc), G.push(Wt[1]), J = null, xt = Q.yyleng, it = Q.yytext, bt = Q.yylineno, z = Q.yylloc;
            break;
          case 2:
            if (nt = this.productions_[Wt[1]][1], dt.$ = ht[ht.length - nt], dt._$ = {
              first_line: Z[Z.length - (nt || 1)].first_line,
              last_line: Z[Z.length - 1].last_line,
              first_column: Z[Z.length - (nt || 1)].first_column,
              last_column: Z[Z.length - 1].last_column
            }, Tt && (dt._$.range = [
              Z[Z.length - (nt || 1)].range[0],
              Z[Z.length - 1].range[1]
            ]), ie = this.performAction.apply(dt, [
              it,
              xt,
              bt,
              U.yy,
              Wt[1],
              ht,
              Z
            ].concat(lt)), typeof ie < "u")
              return ie;
            nt && (G = G.slice(0, -1 * nt * 2), ht = ht.slice(0, -1 * nt), Z = Z.slice(0, -1 * nt)), G.push(this.productions_[Wt[1]][0]), ht.push(dt.$), Z.push(dt._$), ut = ot[G[G.length - 2]][G[G.length - 1]], G.push(ut);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, $ = /* @__PURE__ */ function() {
    var O = {
      EOF: 1,
      parseError: /* @__PURE__ */ u(function(M, G) {
        if (this.yy.parser)
          this.yy.parser.parseError(M, G);
        else
          throw new Error(M);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ u(function(Y, M) {
        return this.yy = M || this.yy || {}, this._input = Y, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ u(function() {
        var Y = this._input[0];
        this.yytext += Y, this.yyleng++, this.offset++, this.match += Y, this.matched += Y;
        var M = Y.match(/(?:\r\n?|\n).*/g);
        return M ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), Y;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ u(function(Y) {
        var M = Y.length, G = Y.split(/(?:\r\n?|\n)/g);
        this._input = Y + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - M), this.offset -= M;
        var rt = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), G.length - 1 && (this.yylineno -= G.length - 1);
        var ht = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: G ? (G.length === rt.length ? this.yylloc.first_column : 0) + rt[rt.length - G.length].length - G[0].length : this.yylloc.first_column - M
        }, this.options.ranges && (this.yylloc.range = [ht[0], ht[0] + this.yyleng - M]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ u(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ u(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ u(function(Y) {
        this.unput(this.match.slice(Y));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ u(function() {
        var Y = this.matched.substr(0, this.matched.length - this.match.length);
        return (Y.length > 20 ? "..." : "") + Y.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ u(function() {
        var Y = this.match;
        return Y.length < 20 && (Y += this._input.substr(0, 20 - Y.length)), (Y.substr(0, 20) + (Y.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ u(function() {
        var Y = this.pastInput(), M = new Array(Y.length + 1).join("-");
        return Y + this.upcomingInput() + `
` + M + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ u(function(Y, M) {
        var G, rt, ht;
        if (this.options.backtrack_lexer && (ht = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (ht.yylloc.range = this.yylloc.range.slice(0))), rt = Y[0].match(/(?:\r\n?|\n).*/g), rt && (this.yylineno += rt.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: rt ? rt[rt.length - 1].length - rt[rt.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + Y[0].length
        }, this.yytext += Y[0], this.match += Y[0], this.matches = Y, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(Y[0].length), this.matched += Y[0], G = this.performAction.call(this, this.yy, this, M, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), G)
          return G;
        if (this._backtrack) {
          for (var Z in ht)
            this[Z] = ht[Z];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ u(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var Y, M, G, rt;
        this._more || (this.yytext = "", this.match = "");
        for (var ht = this._currentRules(), Z = 0; Z < ht.length; Z++)
          if (G = this._input.match(this.rules[ht[Z]]), G && (!M || G[0].length > M[0].length)) {
            if (M = G, rt = Z, this.options.backtrack_lexer) {
              if (Y = this.test_match(G, ht[Z]), Y !== !1)
                return Y;
              if (this._backtrack) {
                M = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return M ? (Y = this.test_match(M, ht[rt]), Y !== !1 ? Y : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ u(function() {
        var M = this.next();
        return M || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ u(function(M) {
        this.conditionStack.push(M);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ u(function() {
        var M = this.conditionStack.length - 1;
        return M > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ u(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ u(function(M) {
        return M = this.conditionStack.length - 1 - Math.abs(M || 0), M >= 0 ? this.conditionStack[M] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ u(function(M) {
        this.begin(M);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ u(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: { "case-insensitive": !0 },
      performAction: /* @__PURE__ */ u(function(M, G, rt, ht) {
        switch (rt) {
          case 0:
            return 38;
          case 1:
            return 40;
          case 2:
            return 39;
          case 3:
            return 44;
          case 4:
            return 51;
          case 5:
            return 52;
          case 6:
            return 53;
          case 7:
            return 54;
          case 8:
            break;
          case 9:
            break;
          case 10:
            return 5;
          case 11:
            break;
          case 12:
            break;
          case 13:
            break;
          case 14:
            break;
          case 15:
            return this.pushState("SCALE"), 17;
          case 16:
            return 18;
          case 17:
            this.popState();
            break;
          case 18:
            return this.begin("acc_title"), 33;
          case 19:
            return this.popState(), "acc_title_value";
          case 20:
            return this.begin("acc_descr"), 35;
          case 21:
            return this.popState(), "acc_descr_value";
          case 22:
            this.begin("acc_descr_multiline");
            break;
          case 23:
            this.popState();
            break;
          case 24:
            return "acc_descr_multiline_value";
          case 25:
            return this.pushState("CLASSDEF"), 41;
          case 26:
            return this.popState(), this.pushState("CLASSDEFID"), "DEFAULT_CLASSDEF_ID";
          case 27:
            return this.popState(), this.pushState("CLASSDEFID"), 42;
          case 28:
            return this.popState(), 43;
          case 29:
            return this.pushState("CLASS"), 48;
          case 30:
            return this.popState(), this.pushState("CLASS_STYLE"), 49;
          case 31:
            return this.popState(), 50;
          case 32:
            return this.pushState("STYLE"), 45;
          case 33:
            return this.popState(), this.pushState("STYLEDEF_STYLES"), 46;
          case 34:
            return this.popState(), 47;
          case 35:
            return this.pushState("SCALE"), 17;
          case 36:
            return 18;
          case 37:
            this.popState();
            break;
          case 38:
            this.pushState("STATE");
            break;
          case 39:
            return this.popState(), G.yytext = G.yytext.slice(0, -8).trim(), 25;
          case 40:
            return this.popState(), G.yytext = G.yytext.slice(0, -8).trim(), 26;
          case 41:
            return this.popState(), G.yytext = G.yytext.slice(0, -10).trim(), 27;
          case 42:
            return this.popState(), G.yytext = G.yytext.slice(0, -8).trim(), 25;
          case 43:
            return this.popState(), G.yytext = G.yytext.slice(0, -8).trim(), 26;
          case 44:
            return this.popState(), G.yytext = G.yytext.slice(0, -10).trim(), 27;
          case 45:
            return 51;
          case 46:
            return 52;
          case 47:
            return 53;
          case 48:
            return 54;
          case 49:
            this.pushState("STATE_STRING");
            break;
          case 50:
            return this.pushState("STATE_ID"), "AS";
          case 51:
            return this.popState(), "ID";
          case 52:
            this.popState();
            break;
          case 53:
            return "STATE_DESCR";
          case 54:
            return 19;
          case 55:
            this.popState();
            break;
          case 56:
            return this.popState(), this.pushState("struct"), 20;
          case 57:
            break;
          case 58:
            return this.popState(), 21;
          case 59:
            break;
          case 60:
            return this.begin("NOTE"), 29;
          case 61:
            return this.popState(), this.pushState("NOTE_ID"), 59;
          case 62:
            return this.popState(), this.pushState("NOTE_ID"), 60;
          case 63:
            this.popState(), this.pushState("FLOATING_NOTE");
            break;
          case 64:
            return this.popState(), this.pushState("FLOATING_NOTE_ID"), "AS";
          case 65:
            break;
          case 66:
            return "NOTE_TEXT";
          case 67:
            return this.popState(), "ID";
          case 68:
            return this.popState(), this.pushState("NOTE_TEXT"), 24;
          case 69:
            return this.popState(), G.yytext = G.yytext.substr(2).trim(), 31;
          case 70:
            return this.popState(), G.yytext = G.yytext.slice(0, -8).trim(), 31;
          case 71:
            return 6;
          case 72:
            return 6;
          case 73:
            return 16;
          case 74:
            return 57;
          case 75:
            return 24;
          case 76:
            return G.yytext = G.yytext.trim(), 14;
          case 77:
            return 15;
          case 78:
            return 28;
          case 79:
            return 58;
          case 80:
            return 5;
          case 81:
            return "INVALID";
        }
      }, "anonymous"),
      rules: [/^(?:click\b)/i, /^(?:href\b)/i, /^(?:"[^"]*")/i, /^(?:default\b)/i, /^(?:.*direction\s+TB[^\n]*)/i, /^(?:.*direction\s+BT[^\n]*)/i, /^(?:.*direction\s+RL[^\n]*)/i, /^(?:.*direction\s+LR[^\n]*)/i, /^(?:%%(?!\{)[^\n]*)/i, /^(?:[^\}]%%[^\n]*)/i, /^(?:[\n]+)/i, /^(?:[\s]+)/i, /^(?:((?!\n)\s)+)/i, /^(?:#[^\n]*)/i, /^(?:%[^\n]*)/i, /^(?:scale\s+)/i, /^(?:\d+)/i, /^(?:\s+width\b)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:classDef\s+)/i, /^(?:DEFAULT\s+)/i, /^(?:\w+\s+)/i, /^(?:[^\n]*)/i, /^(?:class\s+)/i, /^(?:(\w+)+((,\s*\w+)*))/i, /^(?:[^\n]*)/i, /^(?:style\s+)/i, /^(?:[\w,]+\s+)/i, /^(?:[^\n]*)/i, /^(?:scale\s+)/i, /^(?:\d+)/i, /^(?:\s+width\b)/i, /^(?:state\s+)/i, /^(?:.*<<fork>>)/i, /^(?:.*<<join>>)/i, /^(?:.*<<choice>>)/i, /^(?:.*\[\[fork\]\])/i, /^(?:.*\[\[join\]\])/i, /^(?:.*\[\[choice\]\])/i, /^(?:.*direction\s+TB[^\n]*)/i, /^(?:.*direction\s+BT[^\n]*)/i, /^(?:.*direction\s+RL[^\n]*)/i, /^(?:.*direction\s+LR[^\n]*)/i, /^(?:["])/i, /^(?:\s*as\s+)/i, /^(?:[^\n\{]*)/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:[^\n\s\{]+)/i, /^(?:\n)/i, /^(?:\{)/i, /^(?:%%(?!\{)[^\n]*)/i, /^(?:\})/i, /^(?:[\n])/i, /^(?:note\s+)/i, /^(?:left of\b)/i, /^(?:right of\b)/i, /^(?:")/i, /^(?:\s*as\s*)/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:[^\n]*)/i, /^(?:\s*[^:\n\s\-]+)/i, /^(?:\s*:[^:\n;]+)/i, /^(?:[\s\S]*?end note\b)/i, /^(?:stateDiagram\s+)/i, /^(?:stateDiagram-v2\s+)/i, /^(?:hide empty description\b)/i, /^(?:\[\*\])/i, /^(?:[^:\n\s\-\{]+)/i, /^(?:\s*:[^:\n;]+)/i, /^(?:-->)/i, /^(?:--)/i, /^(?::::)/i, /^(?:$)/i, /^(?:.)/i],
      conditions: { LINE: { rules: [12, 13], inclusive: !1 }, struct: { rules: [12, 13, 25, 29, 32, 38, 45, 46, 47, 48, 57, 58, 59, 60, 74, 75, 76, 77, 78], inclusive: !1 }, FLOATING_NOTE_ID: { rules: [67], inclusive: !1 }, FLOATING_NOTE: { rules: [64, 65, 66], inclusive: !1 }, NOTE_TEXT: { rules: [69, 70], inclusive: !1 }, NOTE_ID: { rules: [68], inclusive: !1 }, NOTE: { rules: [61, 62, 63], inclusive: !1 }, STYLEDEF_STYLEOPTS: { rules: [], inclusive: !1 }, STYLEDEF_STYLES: { rules: [34], inclusive: !1 }, STYLE_IDS: { rules: [], inclusive: !1 }, STYLE: { rules: [33], inclusive: !1 }, CLASS_STYLE: { rules: [31], inclusive: !1 }, CLASS: { rules: [30], inclusive: !1 }, CLASSDEFID: { rules: [28], inclusive: !1 }, CLASSDEF: { rules: [26, 27], inclusive: !1 }, acc_descr_multiline: { rules: [23, 24], inclusive: !1 }, acc_descr: { rules: [21], inclusive: !1 }, acc_title: { rules: [19], inclusive: !1 }, SCALE: { rules: [16, 17, 36, 37], inclusive: !1 }, ALIAS: { rules: [], inclusive: !1 }, STATE_ID: { rules: [51], inclusive: !1 }, STATE_STRING: { rules: [52, 53], inclusive: !1 }, FORK_STATE: { rules: [], inclusive: !1 }, STATE: { rules: [12, 13, 39, 40, 41, 42, 43, 44, 49, 50, 54, 55, 56], inclusive: !1 }, ID: { rules: [12, 13], inclusive: !1 }, INITIAL: { rules: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 14, 15, 18, 20, 22, 25, 29, 32, 35, 38, 56, 60, 71, 72, 73, 74, 75, 76, 77, 79, 80, 81], inclusive: !0 } }
    };
    return O;
  }();
  V.lexer = $;
  function D() {
    this.yy = {};
  }
  return u(D, "Parser"), D.prototype = V, V.Parser = D, new D();
}();
cc.parser = cc;
var Y2 = cc, aT = "TB", H2 = "TB", Iu = "dir", Ss = "state", ys = "root", hc = "relation", nT = "classDef", oT = "style", lT = "applyClass", qa = "default", U2 = "divider", j2 = "fill:none", G2 = "fill: #333", X2 = "c", K2 = "text", Q2 = "normal", ol = "rect", ll = "rectWithTitle", cT = "stateStart", hT = "stateEnd", Fu = "divider", Nu = "roundedWithTitle", uT = "note", dT = "noteGroup", kn = "statediagram", pT = "state", gT = `${kn}-${pT}`, Z2 = "transition", fT = "note", yT = "note-edge", mT = `${Z2} ${yT}`, xT = `${kn}-${fT}`, bT = "cluster", kT = `${kn}-${bT}`, vT = "cluster-alt", ST = `${kn}-${vT}`, J2 = "parent", ty = "note", CT = "state", Lh = "----", wT = `${Lh}${ty}`, Ru = `${Lh}${J2}`, ey = /* @__PURE__ */ u((e, t = H2) => {
  if (!e.doc)
    return t;
  let r = t;
  for (const i of e.doc)
    i.stmt === "dir" && (r = i.value);
  return r;
}, "getDir"), TT = /* @__PURE__ */ u(function(e, t) {
  return t.db.getClasses();
}, "getClasses"), _T = /* @__PURE__ */ u(async function(e, t, r, i) {
  I.info("REF0:"), I.info("Drawing state diagram (v2)", t);
  const { securityLevel: s, state: a, layout: n } = K();
  i.db.extract(i.db.getRootDocV2());
  const o = i.db.getData(), h = Ta(t, s);
  o.type = i.type, o.layoutAlgorithm = n, o.nodeSpacing = (a == null ? void 0 : a.nodeSpacing) || 50, o.rankSpacing = (a == null ? void 0 : a.rankSpacing) || 50, o.markers = ["barb"], o.diagramId = t, await wa(o, h);
  const l = 8;
  try {
    (typeof i.db.getLinks == "function" ? i.db.getLinks() : /* @__PURE__ */ new Map()).forEach((p, g) => {
      var _;
      const f = typeof g == "string" ? g : typeof (g == null ? void 0 : g.id) == "string" ? g.id : "";
      if (!f) {
        I.warn(" Invalid or missing stateId from key:", JSON.stringify(g));
        return;
      }
      const y = (_ = h.node()) == null ? void 0 : _.querySelectorAll("g");
      let m;
      if (y == null || y.forEach((A) => {
        var k;
        ((k = A.textContent) == null ? void 0 : k.trim()) === f && (m = A);
      }), !m) {
        I.warn(" Could not find node matching text:", f);
        return;
      }
      const x = m.parentNode;
      if (!x) {
        I.warn(" Node has no parent, cannot wrap:", f);
        return;
      }
      const b = document.createElementNS("http://www.w3.org/2000/svg", "a"), v = p.url.replace(/^"+|"+$/g, "");
      if (b.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", v), b.setAttribute("target", "_blank"), p.tooltip) {
        const A = p.tooltip.replace(/^"+|"+$/g, "");
        b.setAttribute("title", A);
      }
      x.replaceChild(b, m), b.appendChild(m), I.info(" Wrapped node in <a> tag for:", f, p.url);
    });
  } catch (d) {
    I.error(" Error injecting clickable links:", d);
  }
  ee.insertTitle(
    h,
    "statediagramTitleText",
    (a == null ? void 0 : a.titleTopMargin) ?? 25,
    i.db.getDiagramTitle()
  ), cs(h, l, kn, (a == null ? void 0 : a.useMaxWidth) ?? !0);
}, "draw"), ET = {
  getClasses: TT,
  draw: _T,
  getDir: ey
}, Pn = /* @__PURE__ */ new Map(), wi = 0;
function $n(e = "", t = 0, r = "", i = Lh) {
  const s = r !== null && r.length > 0 ? `${i}${r}` : "";
  return `${CT}-${e}${s}-${t}`;
}
u($n, "stateDomId");
var AT = /* @__PURE__ */ u((e, t, r, i, s, a, n, o) => {
  I.trace("items", t), t.forEach((h) => {
    switch (h.stmt) {
      case Ss:
        Oa(e, h, r, i, s, a, n, o);
        break;
      case qa:
        Oa(e, h, r, i, s, a, n, o);
        break;
      case hc:
        {
          Oa(
            e,
            h.state1,
            r,
            i,
            s,
            a,
            n,
            o
          ), Oa(
            e,
            h.state2,
            r,
            i,
            s,
            a,
            n,
            o
          );
          const l = {
            id: "edge" + wi,
            start: h.state1.id,
            end: h.state2.id,
            arrowhead: "normal",
            arrowTypeEnd: "arrow_barb",
            style: j2,
            labelStyle: "",
            label: St.sanitizeText(h.description ?? "", K()),
            arrowheadStyle: G2,
            labelpos: X2,
            labelType: K2,
            thickness: Q2,
            classes: Z2,
            look: n
          };
          s.push(l), wi++;
        }
        break;
    }
  });
}, "setupDoc"), Mu = /* @__PURE__ */ u((e, t = H2) => {
  let r = t;
  if (e.doc)
    for (const i of e.doc)
      i.stmt === "dir" && (r = i.value);
  return r;
}, "getDir");
function Ma(e, t, r) {
  if (!t.id || t.id === "</join></fork>" || t.id === "</choice>")
    return;
  t.cssClasses && (Array.isArray(t.cssCompiledStyles) || (t.cssCompiledStyles = []), t.cssClasses.split(" ").forEach((s) => {
    const a = r.get(s);
    a && (t.cssCompiledStyles = [...t.cssCompiledStyles ?? [], ...a.styles]);
  }));
  const i = e.find((s) => s.id === t.id);
  i ? Object.assign(i, t) : e.push(t);
}
u(Ma, "insertOrUpdateNode");
function ry(e) {
  var t;
  return ((t = e == null ? void 0 : e.classes) == null ? void 0 : t.join(" ")) ?? "";
}
u(ry, "getClassesFromDbInfo");
function iy(e) {
  return (e == null ? void 0 : e.styles) ?? [];
}
u(iy, "getStylesFromDbInfo");
var Oa = /* @__PURE__ */ u((e, t, r, i, s, a, n, o) => {
  var f, y, m;
  const h = t.id, l = r.get(h), d = ry(l), p = iy(l), g = K();
  if (I.info("dataFetcher parsedItem", t, l, p), h !== "root") {
    let x = ol;
    t.start === !0 ? x = cT : t.start === !1 && (x = hT), t.type !== qa && (x = t.type), Pn.get(h) || Pn.set(h, {
      id: h,
      shape: x,
      description: St.sanitizeText(h, g),
      cssClasses: `${d} ${gT}`,
      cssStyles: p
    });
    const b = Pn.get(h);
    t.description && (Array.isArray(b.description) ? (b.shape = ll, b.description.push(t.description)) : (f = b.description) != null && f.length && b.description.length > 0 ? (b.shape = ll, b.description === h ? b.description = [t.description] : b.description = [b.description, t.description]) : (b.shape = ol, b.description = t.description), b.description = St.sanitizeTextOrArray(b.description, g)), ((y = b.description) == null ? void 0 : y.length) === 1 && b.shape === ll && (b.type === "group" ? b.shape = Nu : b.shape = ol), !b.type && t.doc && (I.info("Setting cluster for XCX", h, Mu(t)), b.type = "group", b.isGroup = !0, b.dir = Mu(t), b.shape = t.type === U2 ? Fu : Nu, b.cssClasses = `${b.cssClasses} ${kT} ${a ? ST : ""}`);
    const v = {
      labelStyle: "",
      shape: b.shape,
      label: b.description,
      cssClasses: b.cssClasses,
      cssCompiledStyles: [],
      cssStyles: b.cssStyles,
      id: h,
      dir: b.dir,
      domId: $n(h, wi),
      type: b.type,
      isGroup: b.type === "group",
      padding: 8,
      rx: 10,
      ry: 10,
      look: n
    };
    if (v.shape === Fu && (v.label = ""), e && e.id !== "root" && (I.trace("Setting node ", h, " to be child of its parent ", e.id), v.parentId = e.id), v.centerLabel = !0, t.note) {
      const _ = {
        labelStyle: "",
        shape: uT,
        label: t.note.text,
        cssClasses: xT,
        // useHtmlLabels: false,
        cssStyles: [],
        cssCompiledStyles: [],
        id: h + wT + "-" + wi,
        domId: $n(h, wi, ty),
        type: b.type,
        isGroup: b.type === "group",
        padding: (m = g.flowchart) == null ? void 0 : m.padding,
        look: n,
        position: t.note.position
      }, A = h + Ru, S = {
        labelStyle: "",
        shape: dT,
        label: t.note.text,
        cssClasses: b.cssClasses,
        cssStyles: [],
        id: h + Ru,
        domId: $n(h, wi, J2),
        type: "group",
        isGroup: !0,
        padding: 16,
        //getConfig().flowchart.padding
        look: n,
        position: t.note.position
      };
      wi++, S.id = A, _.parentId = A, Ma(i, S, o), Ma(i, _, o), Ma(i, v, o);
      let k = h, L = _.id;
      t.note.position === "left of" && (k = _.id, L = h), s.push({
        id: k + "-" + L,
        start: k,
        end: L,
        arrowhead: "none",
        arrowTypeEnd: "",
        style: j2,
        labelStyle: "",
        classes: mT,
        arrowheadStyle: G2,
        labelpos: X2,
        labelType: K2,
        thickness: Q2,
        look: n
      });
    } else
      Ma(i, v, o);
  }
  t.doc && (I.trace("Adding nodes children "), AT(t, t.doc, r, i, s, !a, n, o));
}, "dataFetcher"), LT = /* @__PURE__ */ u(() => {
  Pn.clear(), wi = 0;
}, "reset"), lr = {
  START_NODE: "[*]",
  START_TYPE: "start",
  END_NODE: "[*]",
  END_TYPE: "end",
  COLOR_KEYWORD: "color",
  FILL_KEYWORD: "fill",
  BG_FILL: "bgFill",
  STYLECLASS_SEP: ","
}, Ou = /* @__PURE__ */ u(() => /* @__PURE__ */ new Map(), "newClassesList"), Pu = /* @__PURE__ */ u(() => ({
  relations: [],
  states: /* @__PURE__ */ new Map(),
  documents: {}
}), "newDoc"), Ln = /* @__PURE__ */ u((e) => JSON.parse(JSON.stringify(e)), "clone"), ts, Hi = (ts = class {
  constructor(t) {
    this.version = t, this.nodes = [], this.edges = [], this.rootDoc = [], this.classes = Ou(), this.documents = { root: Pu() }, this.currentDocument = this.documents.root, this.startEndCount = 0, this.dividerCnt = 0, this.links = /* @__PURE__ */ new Map(), this.getAccTitle = qe, this.setAccTitle = Re, this.getAccDescription = He, this.setAccDescription = Ye, this.setDiagramTitle = Ge, this.getDiagramTitle = Oe, this.clear(), this.setRootDoc = this.setRootDoc.bind(this), this.getDividerId = this.getDividerId.bind(this), this.setDirection = this.setDirection.bind(this), this.trimColon = this.trimColon.bind(this);
  }
  /**
   * Convert all of the statements (stmts) that were parsed into states and relationships.
   * This is done because a state diagram may have nested sections,
   * where each section is a 'document' and has its own set of statements.
   * Ex: the section within a fork has its own statements, and incoming and outgoing statements
   * refer to the fork as a whole (document).
   * See the parser grammar:  the definition of a document is a document then a 'line', where a line can be a statement.
   * This will push the statement into the list of statements for the current document.
   */
  extract(t) {
    this.clear(!0);
    for (const s of Array.isArray(t) ? t : t.doc)
      switch (s.stmt) {
        case Ss:
          this.addState(s.id.trim(), s.type, s.doc, s.description, s.note);
          break;
        case hc:
          this.addRelation(s.state1, s.state2, s.description);
          break;
        case nT:
          this.addStyleClass(s.id.trim(), s.classes);
          break;
        case oT:
          this.handleStyleDef(s);
          break;
        case lT:
          this.setCssClass(s.id.trim(), s.styleClass);
          break;
        case "click":
          this.addLink(s.id, s.url, s.tooltip);
          break;
      }
    const r = this.getStates(), i = K();
    LT(), Oa(
      void 0,
      this.getRootDocV2(),
      r,
      this.nodes,
      this.edges,
      !0,
      i.look,
      this.classes
    );
    for (const s of this.nodes)
      if (Array.isArray(s.label)) {
        if (s.description = s.label.slice(1), s.isGroup && s.description.length > 0)
          throw new Error(
            `Group nodes can only have label. Remove the additional description for node [${s.id}]`
          );
        s.label = s.label[0];
      }
  }
  handleStyleDef(t) {
    const r = t.id.trim().split(","), i = t.styleClass.split(",");
    for (const s of r) {
      let a = this.getState(s);
      if (!a) {
        const n = s.trim();
        this.addState(n), a = this.getState(n);
      }
      a && (a.styles = i.map((n) => {
        var o;
        return (o = n.replace(/;/g, "")) == null ? void 0 : o.trim();
      }));
    }
  }
  setRootDoc(t) {
    I.info("Setting root doc", t), this.rootDoc = t, this.version === 1 ? this.extract(t) : this.extract(this.getRootDocV2());
  }
  docTranslator(t, r, i) {
    if (r.stmt === hc) {
      this.docTranslator(t, r.state1, !0), this.docTranslator(t, r.state2, !1);
      return;
    }
    if (r.stmt === Ss && (r.id === lr.START_NODE ? (r.id = t.id + (i ? "_start" : "_end"), r.start = i) : r.id = r.id.trim()), r.stmt !== ys && r.stmt !== Ss || !r.doc)
      return;
    const s = [];
    let a = [];
    for (const n of r.doc)
      if (n.type === U2) {
        const o = Ln(n);
        o.doc = Ln(a), s.push(o), a = [];
      } else
        a.push(n);
    if (s.length > 0 && a.length > 0) {
      const n = {
        stmt: Ss,
        id: _0(),
        type: "divider",
        doc: Ln(a)
      };
      s.push(Ln(n)), r.doc = s;
    }
    r.doc.forEach((n) => this.docTranslator(r, n, !0));
  }
  getRootDocV2() {
    return this.docTranslator(
      { id: ys, stmt: ys },
      { id: ys, stmt: ys, doc: this.rootDoc },
      !0
    ), { id: ys, doc: this.rootDoc };
  }
  /**
   * Function called by parser when a node definition has been found.
   *
   * @param descr - description for the state. Can be a string or a list or strings
   * @param classes - class styles to apply to this state. Can be a string (1 style) or an array of styles. If it's just 1 class, convert it to an array of that 1 class.
   * @param styles - styles to apply to this state. Can be a string (1 style) or an array of styles. If it's just 1 style, convert it to an array of that 1 style.
   * @param textStyles - text styles to apply to this state. Can be a string (1 text test) or an array of text styles. If it's just 1 text style, convert it to an array of that 1 text style.
   */
  addState(t, r = qa, i = void 0, s = void 0, a = void 0, n = void 0, o = void 0, h = void 0) {
    const l = t == null ? void 0 : t.trim();
    if (!this.currentDocument.states.has(l))
      I.info("Adding state ", l, s), this.currentDocument.states.set(l, {
        stmt: Ss,
        id: l,
        descriptions: [],
        type: r,
        doc: i,
        note: a,
        classes: [],
        styles: [],
        textStyles: []
      });
    else {
      const d = this.currentDocument.states.get(l);
      if (!d)
        throw new Error(`State not found: ${l}`);
      d.doc || (d.doc = i), d.type || (d.type = r);
    }
    if (s && (I.info("Setting state description", l, s), (Array.isArray(s) ? s : [s]).forEach((p) => this.addDescription(l, p.trim()))), a) {
      const d = this.currentDocument.states.get(l);
      if (!d)
        throw new Error(`State not found: ${l}`);
      d.note = a, d.note.text = St.sanitizeText(d.note.text, K());
    }
    n && (I.info("Setting state classes", l, n), (Array.isArray(n) ? n : [n]).forEach((p) => this.setCssClass(l, p.trim()))), o && (I.info("Setting state styles", l, o), (Array.isArray(o) ? o : [o]).forEach((p) => this.setStyle(l, p.trim()))), h && (I.info("Setting state styles", l, o), (Array.isArray(h) ? h : [h]).forEach((p) => this.setTextStyle(l, p.trim())));
  }
  clear(t) {
    this.nodes = [], this.edges = [], this.documents = { root: Pu() }, this.currentDocument = this.documents.root, this.startEndCount = 0, this.classes = Ou(), t || (this.links = /* @__PURE__ */ new Map(), Me());
  }
  getState(t) {
    return this.currentDocument.states.get(t);
  }
  getStates() {
    return this.currentDocument.states;
  }
  logDocuments() {
    I.info("Documents = ", this.documents);
  }
  getRelations() {
    return this.currentDocument.relations;
  }
  /**
   * Adds a clickable link to a state.
   */
  addLink(t, r, i) {
    this.links.set(t, { url: r, tooltip: i }), I.warn("Adding link", t, r, i);
  }
  /**
   * Get all registered links.
   */
  getLinks() {
    return this.links;
  }
  /**
   * If the id is a start node ( [*] ), then return a new id constructed from
   * the start node name and the current start node count.
   * else return the given id
   */
  startIdIfNeeded(t = "") {
    return t === lr.START_NODE ? (this.startEndCount++, `${lr.START_TYPE}${this.startEndCount}`) : t;
  }
  /**
   * If the id is a start node ( [*] ), then return the start type ('start')
   * else return the given type
   */
  startTypeIfNeeded(t = "", r = qa) {
    return t === lr.START_NODE ? lr.START_TYPE : r;
  }
  /**
   * If the id is an end node ( [*] ), then return a new id constructed from
   * the end node name and the current start_end node count.
   * else return the given id
   */
  endIdIfNeeded(t = "") {
    return t === lr.END_NODE ? (this.startEndCount++, `${lr.END_TYPE}${this.startEndCount}`) : t;
  }
  /**
   * If the id is an end node ( [*] ), then return the end type
   * else return the given type
   *
   */
  endTypeIfNeeded(t = "", r = qa) {
    return t === lr.END_NODE ? lr.END_TYPE : r;
  }
  addRelationObjs(t, r, i = "") {
    const s = this.startIdIfNeeded(t.id.trim()), a = this.startTypeIfNeeded(t.id.trim(), t.type), n = this.startIdIfNeeded(r.id.trim()), o = this.startTypeIfNeeded(r.id.trim(), r.type);
    this.addState(
      s,
      a,
      t.doc,
      t.description,
      t.note,
      t.classes,
      t.styles,
      t.textStyles
    ), this.addState(
      n,
      o,
      r.doc,
      r.description,
      r.note,
      r.classes,
      r.styles,
      r.textStyles
    ), this.currentDocument.relations.push({
      id1: s,
      id2: n,
      relationTitle: St.sanitizeText(i, K())
    });
  }
  /**
   * Add a relation between two items.  The items may be full objects or just the string id of a state.
   */
  addRelation(t, r, i) {
    if (typeof t == "object" && typeof r == "object")
      this.addRelationObjs(t, r, i);
    else if (typeof t == "string" && typeof r == "string") {
      const s = this.startIdIfNeeded(t.trim()), a = this.startTypeIfNeeded(t), n = this.endIdIfNeeded(r.trim()), o = this.endTypeIfNeeded(r);
      this.addState(s, a), this.addState(n, o), this.currentDocument.relations.push({
        id1: s,
        id2: n,
        relationTitle: i ? St.sanitizeText(i, K()) : void 0
      });
    }
  }
  addDescription(t, r) {
    var a;
    const i = this.currentDocument.states.get(t), s = r.startsWith(":") ? r.replace(":", "").trim() : r;
    (a = i == null ? void 0 : i.descriptions) == null || a.push(St.sanitizeText(s, K()));
  }
  cleanupLabel(t) {
    return t.startsWith(":") ? t.slice(2).trim() : t.trim();
  }
  getDividerId() {
    return this.dividerCnt++, `divider-id-${this.dividerCnt}`;
  }
  /**
   * Called when the parser comes across a (style) class definition
   * @example classDef my-style fill:#f96;
   *
   * @param id - the id of this (style) class
   * @param styleAttributes - the string with 1 or more style attributes (each separated by a comma)
   */
  addStyleClass(t, r = "") {
    this.classes.has(t) || this.classes.set(t, { id: t, styles: [], textStyles: [] });
    const i = this.classes.get(t);
    r && i && r.split(lr.STYLECLASS_SEP).forEach((s) => {
      const a = s.replace(/([^;]*);/, "$1").trim();
      if (RegExp(lr.COLOR_KEYWORD).exec(s)) {
        const o = a.replace(lr.FILL_KEYWORD, lr.BG_FILL).replace(lr.COLOR_KEYWORD, lr.FILL_KEYWORD);
        i.textStyles.push(o);
      }
      i.styles.push(a);
    });
  }
  getClasses() {
    return this.classes;
  }
  /**
   * Add a (style) class or css class to a state with the given id.
   * If the state isn't already in the list of known states, add it.
   * Might be called by parser when a style class or CSS class should be applied to a state
   *
   * @param itemIds - The id or a list of ids of the item(s) to apply the css class to
   * @param cssClassName - CSS class name
   */
  setCssClass(t, r) {
    t.split(",").forEach((i) => {
      var a;
      let s = this.getState(i);
      if (!s) {
        const n = i.trim();
        this.addState(n), s = this.getState(n);
      }
      (a = s == null ? void 0 : s.classes) == null || a.push(r);
    });
  }
  /**
   * Add a style to a state with the given id.
   * @example style stateId fill:#f9f,stroke:#333,stroke-width:4px
   *   where 'style' is the keyword
   *   stateId is the id of a state
   *   the rest of the string is the styleText (all of the attributes to be applied to the state)
   *
   * @param itemId - The id of item to apply the style to
   * @param styleText - the text of the attributes for the style
   */
  setStyle(t, r) {
    var i, s;
    (s = (i = this.getState(t)) == null ? void 0 : i.styles) == null || s.push(r);
  }
  /**
   * Add a text style to a state with the given id
   *
   * @param itemId - The id of item to apply the css class to
   * @param cssClassName - CSS class name
   */
  setTextStyle(t, r) {
    var i, s;
    (s = (i = this.getState(t)) == null ? void 0 : i.textStyles) == null || s.push(r);
  }
  /**
   * Finds the direction statement in the root document.
   * @returns the direction statement if present
   */
  getDirectionStatement() {
    return this.rootDoc.find((t) => t.stmt === Iu);
  }
  getDirection() {
    var t;
    return ((t = this.getDirectionStatement()) == null ? void 0 : t.value) ?? aT;
  }
  setDirection(t) {
    const r = this.getDirectionStatement();
    r ? r.value = t : this.rootDoc.unshift({ stmt: Iu, value: t });
  }
  trimColon(t) {
    return t.startsWith(":") ? t.slice(1).trim() : t.trim();
  }
  getData() {
    const t = K();
    return {
      nodes: this.nodes,
      edges: this.edges,
      other: {},
      config: t,
      direction: ey(this.getRootDocV2())
    };
  }
  getConfig() {
    return K().state;
  }
}, u(ts, "StateDB"), ts.relationType = {
  AGGREGATION: 0,
  EXTENSION: 1,
  COMPOSITION: 2,
  DEPENDENCY: 3
}, ts), BT = /* @__PURE__ */ u((e) => `
defs #statediagram-barbEnd {
    fill: ${e.transitionColor};
    stroke: ${e.transitionColor};
  }
g.stateGroup text {
  fill: ${e.nodeBorder};
  stroke: none;
  font-size: 10px;
}
g.stateGroup text {
  fill: ${e.textColor};
  stroke: none;
  font-size: 10px;

}
g.stateGroup .state-title {
  font-weight: bolder;
  fill: ${e.stateLabelColor};
}

g.stateGroup rect {
  fill: ${e.mainBkg};
  stroke: ${e.nodeBorder};
}

g.stateGroup line {
  stroke: ${e.lineColor};
  stroke-width: 1;
}

.transition {
  stroke: ${e.transitionColor};
  stroke-width: 1;
  fill: none;
}

.stateGroup .composit {
  fill: ${e.background};
  border-bottom: 1px
}

.stateGroup .alt-composit {
  fill: #e0e0e0;
  border-bottom: 1px
}

.state-note {
  stroke: ${e.noteBorderColor};
  fill: ${e.noteBkgColor};

  text {
    fill: ${e.noteTextColor};
    stroke: none;
    font-size: 10px;
  }
}

.stateLabel .box {
  stroke: none;
  stroke-width: 0;
  fill: ${e.mainBkg};
  opacity: 0.5;
}

.edgeLabel .label rect {
  fill: ${e.labelBackgroundColor};
  opacity: 0.5;
}
.edgeLabel {
  background-color: ${e.edgeLabelBackground};
  p {
    background-color: ${e.edgeLabelBackground};
  }
  rect {
    opacity: 0.5;
    background-color: ${e.edgeLabelBackground};
    fill: ${e.edgeLabelBackground};
  }
  text-align: center;
}
.edgeLabel .label text {
  fill: ${e.transitionLabelColor || e.tertiaryTextColor};
}
.label div .edgeLabel {
  color: ${e.transitionLabelColor || e.tertiaryTextColor};
}

.stateLabel text {
  fill: ${e.stateLabelColor};
  font-size: 10px;
  font-weight: bold;
}

.node circle.state-start {
  fill: ${e.specialStateColor};
  stroke: ${e.specialStateColor};
}

.node .fork-join {
  fill: ${e.specialStateColor};
  stroke: ${e.specialStateColor};
}

.node circle.state-end {
  fill: ${e.innerEndBackground};
  stroke: ${e.background};
  stroke-width: 1.5
}
.end-state-inner {
  fill: ${e.compositeBackground || e.background};
  // stroke: ${e.background};
  stroke-width: 1.5
}

.node rect {
  fill: ${e.stateBkg || e.mainBkg};
  stroke: ${e.stateBorder || e.nodeBorder};
  stroke-width: 1px;
}
.node polygon {
  fill: ${e.mainBkg};
  stroke: ${e.stateBorder || e.nodeBorder};;
  stroke-width: 1px;
}
#statediagram-barbEnd {
  fill: ${e.lineColor};
}

.statediagram-cluster rect {
  fill: ${e.compositeTitleBackground};
  stroke: ${e.stateBorder || e.nodeBorder};
  stroke-width: 1px;
}

.cluster-label, .nodeLabel {
  color: ${e.stateLabelColor};
  // line-height: 1;
}

.statediagram-cluster rect.outer {
  rx: 5px;
  ry: 5px;
}
.statediagram-state .divider {
  stroke: ${e.stateBorder || e.nodeBorder};
}

.statediagram-state .title-state {
  rx: 5px;
  ry: 5px;
}
.statediagram-cluster.statediagram-cluster .inner {
  fill: ${e.compositeBackground || e.background};
}
.statediagram-cluster.statediagram-cluster-alt .inner {
  fill: ${e.altBackground ? e.altBackground : "#efefef"};
}

.statediagram-cluster .inner {
  rx:0;
  ry:0;
}

.statediagram-state rect.basic {
  rx: 5px;
  ry: 5px;
}
.statediagram-state rect.divider {
  stroke-dasharray: 10,10;
  fill: ${e.altBackground ? e.altBackground : "#efefef"};
}

.note-edge {
  stroke-dasharray: 5;
}

.statediagram-note rect {
  fill: ${e.noteBkgColor};
  stroke: ${e.noteBorderColor};
  stroke-width: 1px;
  rx: 0;
  ry: 0;
}
.statediagram-note rect {
  fill: ${e.noteBkgColor};
  stroke: ${e.noteBorderColor};
  stroke-width: 1px;
  rx: 0;
  ry: 0;
}

.statediagram-note text {
  fill: ${e.noteTextColor};
}

.statediagram-note .nodeLabel {
  color: ${e.noteTextColor};
}
.statediagram .edgeLabel {
  color: red; // ${e.noteTextColor};
}

#dependencyStart, #dependencyEnd {
  fill: ${e.lineColor};
  stroke: ${e.lineColor};
  stroke-width: 1;
}

.statediagramTitleText {
  text-anchor: middle;
  font-size: 18px;
  fill: ${e.textColor};
}
`, "getStyles"), sy = BT, DT = /* @__PURE__ */ u((e) => e.append("circle").attr("class", "start-state").attr("r", K().state.sizeUnit).attr("cx", K().state.padding + K().state.sizeUnit).attr("cy", K().state.padding + K().state.sizeUnit), "drawStartState"), IT = /* @__PURE__ */ u((e) => e.append("line").style("stroke", "grey").style("stroke-dasharray", "3").attr("x1", K().state.textHeight).attr("class", "divider").attr("x2", K().state.textHeight * 2).attr("y1", 0).attr("y2", 0), "drawDivider"), FT = /* @__PURE__ */ u((e, t) => {
  const r = e.append("text").attr("x", 2 * K().state.padding).attr("y", K().state.textHeight + 2 * K().state.padding).attr("font-size", K().state.fontSize).attr("class", "state-title").text(t.id), i = r.node().getBBox();
  return e.insert("rect", ":first-child").attr("x", K().state.padding).attr("y", K().state.padding).attr("width", i.width + 2 * K().state.padding).attr("height", i.height + 2 * K().state.padding).attr("rx", K().state.radius), r;
}, "drawSimpleState"), NT = /* @__PURE__ */ u((e, t) => {
  const r = /* @__PURE__ */ u(function(g, f, y) {
    const m = g.append("tspan").attr("x", 2 * K().state.padding).text(f);
    y || m.attr("dy", K().state.textHeight);
  }, "addTspan"), s = e.append("text").attr("x", 2 * K().state.padding).attr("y", K().state.textHeight + 1.3 * K().state.padding).attr("font-size", K().state.fontSize).attr("class", "state-title").text(t.descriptions[0]).node().getBBox(), a = s.height, n = e.append("text").attr("x", K().state.padding).attr(
    "y",
    a + K().state.padding * 0.4 + K().state.dividerMargin + K().state.textHeight
  ).attr("class", "state-description");
  let o = !0, h = !0;
  t.descriptions.forEach(function(g) {
    o || (r(n, g, h), h = !1), o = !1;
  });
  const l = e.append("line").attr("x1", K().state.padding).attr("y1", K().state.padding + a + K().state.dividerMargin / 2).attr("y2", K().state.padding + a + K().state.dividerMargin / 2).attr("class", "descr-divider"), d = n.node().getBBox(), p = Math.max(d.width, s.width);
  return l.attr("x2", p + 3 * K().state.padding), e.insert("rect", ":first-child").attr("x", K().state.padding).attr("y", K().state.padding).attr("width", p + 2 * K().state.padding).attr("height", d.height + a + 2 * K().state.padding).attr("rx", K().state.radius), e;
}, "drawDescrState"), RT = /* @__PURE__ */ u((e, t, r) => {
  const i = K().state.padding, s = 2 * K().state.padding, a = e.node().getBBox(), n = a.width, o = a.x, h = e.append("text").attr("x", 0).attr("y", K().state.titleShift).attr("font-size", K().state.fontSize).attr("class", "state-title").text(t.id), d = h.node().getBBox().width + s;
  let p = Math.max(d, n);
  p === n && (p = p + s);
  let g;
  const f = e.node().getBBox();
  t.doc, g = o - i, d > n && (g = (n - p) / 2 + i), Math.abs(o - f.x) < i && d > n && (g = o - (d - n) / 2);
  const y = 1 - K().state.textHeight;
  return e.insert("rect", ":first-child").attr("x", g).attr("y", y).attr("class", r ? "alt-composit" : "composit").attr("width", p).attr(
    "height",
    f.height + K().state.textHeight + K().state.titleShift + 1
  ).attr("rx", "0"), h.attr("x", g + i), d <= n && h.attr("x", o + (p - s) / 2 - d / 2 + i), e.insert("rect", ":first-child").attr("x", g).attr(
    "y",
    K().state.titleShift - K().state.textHeight - K().state.padding
  ).attr("width", p).attr("height", K().state.textHeight * 3).attr("rx", K().state.radius), e.insert("rect", ":first-child").attr("x", g).attr(
    "y",
    K().state.titleShift - K().state.textHeight - K().state.padding
  ).attr("width", p).attr("height", f.height + 3 + 2 * K().state.textHeight).attr("rx", K().state.radius), e;
}, "addTitleAndBox"), MT = /* @__PURE__ */ u((e) => (e.append("circle").attr("class", "end-state-outer").attr("r", K().state.sizeUnit + K().state.miniPadding).attr(
  "cx",
  K().state.padding + K().state.sizeUnit + K().state.miniPadding
).attr(
  "cy",
  K().state.padding + K().state.sizeUnit + K().state.miniPadding
), e.append("circle").attr("class", "end-state-inner").attr("r", K().state.sizeUnit).attr("cx", K().state.padding + K().state.sizeUnit + 2).attr("cy", K().state.padding + K().state.sizeUnit + 2)), "drawEndState"), OT = /* @__PURE__ */ u((e, t) => {
  let r = K().state.forkWidth, i = K().state.forkHeight;
  if (t.parentId) {
    let s = r;
    r = i, i = s;
  }
  return e.append("rect").style("stroke", "black").style("fill", "black").attr("width", r).attr("height", i).attr("x", K().state.padding).attr("y", K().state.padding);
}, "drawForkJoinState"), PT = /* @__PURE__ */ u((e, t, r, i) => {
  let s = 0;
  const a = i.append("text");
  a.style("text-anchor", "start"), a.attr("class", "noteText");
  let n = e.replace(/\r\n/g, "<br/>");
  n = n.replace(/\n/g, "<br/>");
  const o = n.split(St.lineBreakRegex);
  let h = 1.25 * K().state.noteMargin;
  for (const l of o) {
    const d = l.trim();
    if (d.length > 0) {
      const p = a.append("tspan");
      if (p.text(d), h === 0) {
        const g = p.node().getBBox();
        h += g.height;
      }
      s += h, p.attr("x", t + K().state.noteMargin), p.attr("y", r + s + 1.25 * K().state.noteMargin);
    }
  }
  return { textWidth: a.node().getBBox().width, textHeight: s };
}, "_drawLongText"), $T = /* @__PURE__ */ u((e, t) => {
  t.attr("class", "state-note");
  const r = t.append("rect").attr("x", 0).attr("y", K().state.padding), i = t.append("g"), { textWidth: s, textHeight: a } = PT(e, 0, 0, i);
  return r.attr("height", a + 2 * K().state.noteMargin), r.attr("width", s + K().state.noteMargin * 2), r;
}, "drawNote"), $u = /* @__PURE__ */ u(function(e, t) {
  const r = t.id, i = {
    id: r,
    label: t.id,
    width: 0,
    height: 0
  }, s = e.append("g").attr("id", r).attr("class", "stateGroup");
  t.type === "start" && DT(s), t.type === "end" && MT(s), (t.type === "fork" || t.type === "join") && OT(s, t), t.type === "note" && $T(t.note.text, s), t.type === "divider" && IT(s), t.type === "default" && t.descriptions.length === 0 && FT(s, t), t.type === "default" && t.descriptions.length > 0 && NT(s, t);
  const a = s.node().getBBox();
  return i.width = a.width + 2 * K().state.padding, i.height = a.height + 2 * K().state.padding, i;
}, "drawState"), Vu = 0, VT = /* @__PURE__ */ u(function(e, t, r) {
  const i = /* @__PURE__ */ u(function(h) {
    switch (h) {
      case Hi.relationType.AGGREGATION:
        return "aggregation";
      case Hi.relationType.EXTENSION:
        return "extension";
      case Hi.relationType.COMPOSITION:
        return "composition";
      case Hi.relationType.DEPENDENCY:
        return "dependency";
    }
  }, "getRelationType");
  t.points = t.points.filter((h) => !Number.isNaN(h.y));
  const s = t.points, a = Ha().x(function(h) {
    return h.x;
  }).y(function(h) {
    return h.y;
  }).curve(_s), n = e.append("path").attr("d", a(s)).attr("id", "edge" + Vu).attr("class", "transition");
  let o = "";
  if (K().state.arrowMarkerAbsolute && (o = Ao(!0)), n.attr(
    "marker-end",
    "url(" + o + "#" + i(Hi.relationType.DEPENDENCY) + "End)"
  ), r.title !== void 0) {
    const h = e.append("g").attr("class", "stateLabel"), { x: l, y: d } = ee.calcLabelPosition(t.points), p = St.getRows(r.title);
    let g = 0;
    const f = [];
    let y = 0, m = 0;
    for (let v = 0; v <= p.length; v++) {
      const _ = h.append("text").attr("text-anchor", "middle").text(p[v]).attr("x", l).attr("y", d + g), A = _.node().getBBox();
      y = Math.max(y, A.width), m = Math.min(m, A.x), I.info(A.x, l, d + g), g === 0 && (g = _.node().getBBox().height, I.info("Title height", g, d)), f.push(_);
    }
    let x = g * p.length;
    if (p.length > 1) {
      const v = (p.length - 1) * g * 0.5;
      f.forEach((_, A) => _.attr("y", d + A * g - v)), x = g * p.length;
    }
    const b = h.node().getBBox();
    h.insert("rect", ":first-child").attr("class", "box").attr("x", l - y / 2 - K().state.padding / 2).attr("y", d - x / 2 - K().state.padding / 2 - 3.5).attr("width", y + K().state.padding).attr("height", x + K().state.padding), I.info(b);
  }
  Vu++;
}, "drawEdge"), wr, cl = {}, zT = /* @__PURE__ */ u(function() {
}, "setConf"), WT = /* @__PURE__ */ u(function(e) {
  e.append("defs").append("marker").attr("id", "dependencyEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 19,7 L9,13 L14,7 L9,1 Z");
}, "insertMarkers"), qT = /* @__PURE__ */ u(function(e, t, r, i) {
  wr = K().state;
  const s = K().securityLevel;
  let a;
  s === "sandbox" && (a = yt("#i" + t));
  const n = s === "sandbox" ? yt(a.nodes()[0].contentDocument.body) : yt("body"), o = s === "sandbox" ? a.nodes()[0].contentDocument : document;
  I.debug("Rendering diagram " + e);
  const h = n.select(`[id='${t}']`);
  WT(h);
  const l = i.db.getRootDoc();
  ay(l, h, void 0, !1, n, o, i);
  const d = wr.padding, p = h.node().getBBox(), g = p.width + d * 2, f = p.height + d * 2, y = g * 1.75;
  fr(h, f, y, wr.useMaxWidth), h.attr(
    "viewBox",
    `${p.x - wr.padding}  ${p.y - wr.padding} ` + g + " " + f
  );
}, "draw"), YT = /* @__PURE__ */ u((e) => e ? e.length * wr.fontSizeFactor : 1, "getLabelWidth"), ay = /* @__PURE__ */ u((e, t, r, i, s, a, n) => {
  const o = new vo({
    compound: !0,
    multigraph: !0
  });
  let h, l = !0;
  for (h = 0; h < e.length; h++)
    if (e[h].stmt === "relation") {
      l = !1;
      break;
    }
  r ? o.setGraph({
    rankdir: "LR",
    multigraph: !0,
    compound: !0,
    // acyclicer: 'greedy',
    ranker: "tight-tree",
    ranksep: l ? 1 : wr.edgeLengthFactor,
    nodeSep: l ? 1 : 50,
    isMultiGraph: !0
    // ranksep: 5,
    // nodesep: 1
  }) : o.setGraph({
    rankdir: "TB",
    multigraph: !0,
    compound: !0,
    // isCompound: true,
    // acyclicer: 'greedy',
    // ranker: 'longest-path'
    ranksep: l ? 1 : wr.edgeLengthFactor,
    nodeSep: l ? 1 : 50,
    ranker: "tight-tree",
    // ranker: 'network-simplex'
    isMultiGraph: !0
  }), o.setDefaultEdgeLabel(function() {
    return {};
  });
  const d = n.db.getStates(), p = n.db.getRelations(), g = Object.keys(d);
  for (const b of g) {
    const v = d[b];
    r && (v.parentId = r);
    let _;
    if (v.doc) {
      let A = t.append("g").attr("id", v.id).attr("class", "stateGroup");
      _ = ay(v.doc, A, v.id, !i, s, a, n);
      {
        A = RT(A, v, i);
        let S = A.node().getBBox();
        _.width = S.width, _.height = S.height + wr.padding / 2, cl[v.id] = { y: wr.compositTitleSize };
      }
    } else
      _ = $u(t, v, o);
    if (v.note) {
      const A = {
        descriptions: [],
        id: v.id + "-note",
        note: v.note,
        type: "note"
      }, S = $u(t, A, o);
      v.note.position === "left of" ? (o.setNode(_.id + "-note", S), o.setNode(_.id, _)) : (o.setNode(_.id, _), o.setNode(_.id + "-note", S)), o.setParent(_.id, _.id + "-group"), o.setParent(_.id + "-note", _.id + "-group");
    } else
      o.setNode(_.id, _);
  }
  I.debug("Count=", o.nodeCount(), o);
  let f = 0;
  p.forEach(function(b) {
    f++, I.debug("Setting edge", b), o.setEdge(
      b.id1,
      b.id2,
      {
        relation: b,
        width: YT(b.title),
        height: wr.labelHeight * St.getRows(b.title).length,
        labelpos: "c"
      },
      "id" + f
    );
  }), Sd(o), I.debug("Graph after layout", o.nodes());
  const y = t.node();
  o.nodes().forEach(function(b) {
    b !== void 0 && o.node(b) !== void 0 ? (I.warn("Node " + b + ": " + JSON.stringify(o.node(b))), s.select("#" + y.id + " #" + b).attr(
      "transform",
      "translate(" + (o.node(b).x - o.node(b).width / 2) + "," + (o.node(b).y + (cl[b] ? cl[b].y : 0) - o.node(b).height / 2) + " )"
    ), s.select("#" + y.id + " #" + b).attr("data-x-shift", o.node(b).x - o.node(b).width / 2), a.querySelectorAll("#" + y.id + " #" + b + " .divider").forEach((_) => {
      const A = _.parentElement;
      let S = 0, k = 0;
      A && (A.parentElement && (S = A.parentElement.getBBox().width), k = parseInt(A.getAttribute("data-x-shift"), 10), Number.isNaN(k) && (k = 0)), _.setAttribute("x1", 0 - k + 8), _.setAttribute("x2", S - k - 8);
    })) : I.debug("No Node " + b + ": " + JSON.stringify(o.node(b)));
  });
  let m = y.getBBox();
  o.edges().forEach(function(b) {
    b !== void 0 && o.edge(b) !== void 0 && (I.debug("Edge " + b.v + " -> " + b.w + ": " + JSON.stringify(o.edge(b))), VT(t, o.edge(b), o.edge(b).relation));
  }), m = y.getBBox();
  const x = {
    id: r || "root",
    label: r || "root",
    width: 0,
    height: 0
  };
  return x.width = m.width + 2 * wr.padding, x.height = m.height + 2 * wr.padding, I.debug("Doc rendered", x, o), x;
}, "renderDoc"), HT = {
  setConf: zT,
  draw: qT
}, UT = {
  parser: Y2,
  get db() {
    return new Hi(1);
  },
  renderer: HT,
  styles: sy,
  init: /* @__PURE__ */ u((e) => {
    e.state || (e.state = {}), e.state.arrowMarkerAbsolute = e.arrowMarkerAbsolute;
  }, "init")
};
const jT = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: UT
}, Symbol.toStringTag, { value: "Module" }));
var GT = {
  parser: Y2,
  get db() {
    return new Hi(2);
  },
  renderer: ET,
  styles: sy,
  init: /* @__PURE__ */ u((e) => {
    e.state || (e.state = {}), e.state.arrowMarkerAbsolute = e.arrowMarkerAbsolute;
  }, "init")
};
const XT = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: GT
}, Symbol.toStringTag, { value: "Module" }));
var uc = function() {
  var e = /* @__PURE__ */ u(function(p, g, f, y) {
    for (f = f || {}, y = p.length; y--; f[p[y]] = g) ;
    return f;
  }, "o"), t = [6, 8, 10, 11, 12, 14, 16, 17, 18], r = [1, 9], i = [1, 10], s = [1, 11], a = [1, 12], n = [1, 13], o = [1, 14], h = {
    trace: /* @__PURE__ */ u(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, start: 3, journey: 4, document: 5, EOF: 6, line: 7, SPACE: 8, statement: 9, NEWLINE: 10, title: 11, acc_title: 12, acc_title_value: 13, acc_descr: 14, acc_descr_value: 15, acc_descr_multiline_value: 16, section: 17, taskName: 18, taskData: 19, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 4: "journey", 6: "EOF", 8: "SPACE", 10: "NEWLINE", 11: "title", 12: "acc_title", 13: "acc_title_value", 14: "acc_descr", 15: "acc_descr_value", 16: "acc_descr_multiline_value", 17: "section", 18: "taskName", 19: "taskData" },
    productions_: [0, [3, 3], [5, 0], [5, 2], [7, 2], [7, 1], [7, 1], [7, 1], [9, 1], [9, 2], [9, 2], [9, 1], [9, 1], [9, 2]],
    performAction: /* @__PURE__ */ u(function(g, f, y, m, x, b, v) {
      var _ = b.length - 1;
      switch (x) {
        case 1:
          return b[_ - 1];
        case 2:
          this.$ = [];
          break;
        case 3:
          b[_ - 1].push(b[_]), this.$ = b[_ - 1];
          break;
        case 4:
        case 5:
          this.$ = b[_];
          break;
        case 6:
        case 7:
          this.$ = [];
          break;
        case 8:
          m.setDiagramTitle(b[_].substr(6)), this.$ = b[_].substr(6);
          break;
        case 9:
          this.$ = b[_].trim(), m.setAccTitle(this.$);
          break;
        case 10:
        case 11:
          this.$ = b[_].trim(), m.setAccDescription(this.$);
          break;
        case 12:
          m.addSection(b[_].substr(8)), this.$ = b[_].substr(8);
          break;
        case 13:
          m.addTask(b[_ - 1], b[_]), this.$ = "task";
          break;
      }
    }, "anonymous"),
    table: [{ 3: 1, 4: [1, 2] }, { 1: [3] }, e(t, [2, 2], { 5: 3 }), { 6: [1, 4], 7: 5, 8: [1, 6], 9: 7, 10: [1, 8], 11: r, 12: i, 14: s, 16: a, 17: n, 18: o }, e(t, [2, 7], { 1: [2, 1] }), e(t, [2, 3]), { 9: 15, 11: r, 12: i, 14: s, 16: a, 17: n, 18: o }, e(t, [2, 5]), e(t, [2, 6]), e(t, [2, 8]), { 13: [1, 16] }, { 15: [1, 17] }, e(t, [2, 11]), e(t, [2, 12]), { 19: [1, 18] }, e(t, [2, 4]), e(t, [2, 9]), e(t, [2, 10]), e(t, [2, 13])],
    defaultActions: {},
    parseError: /* @__PURE__ */ u(function(g, f) {
      if (f.recoverable)
        this.trace(g);
      else {
        var y = new Error(g);
        throw y.hash = f, y;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ u(function(g) {
      var f = this, y = [0], m = [], x = [null], b = [], v = this.table, _ = "", A = 0, S = 0, k = 2, L = 1, T = b.slice.call(arguments, 1), C = Object.create(this.lexer), E = { yy: {} };
      for (var w in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, w) && (E.yy[w] = this.yy[w]);
      C.setInput(g, E.yy), E.yy.lexer = C, E.yy.parser = this, typeof C.yylloc > "u" && (C.yylloc = {});
      var W = C.yylloc;
      b.push(W);
      var N = C.options && C.options.ranges;
      typeof E.yy.parseError == "function" ? this.parseError = E.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function B(ot) {
        y.length = y.length - 2 * ot, x.length = x.length - ot, b.length = b.length - ot;
      }
      u(B, "popStack");
      function R() {
        var ot;
        return ot = m.pop() || C.lex() || L, typeof ot != "number" && (ot instanceof Array && (m = ot, ot = m.pop()), ot = f.symbols_[ot] || ot), ot;
      }
      u(R, "lex");
      for (var V, $, D, O, Y = {}, M, G, rt, ht; ; ) {
        if ($ = y[y.length - 1], this.defaultActions[$] ? D = this.defaultActions[$] : ((V === null || typeof V > "u") && (V = R()), D = v[$] && v[$][V]), typeof D > "u" || !D.length || !D[0]) {
          var Z = "";
          ht = [];
          for (M in v[$])
            this.terminals_[M] && M > k && ht.push("'" + this.terminals_[M] + "'");
          C.showPosition ? Z = "Parse error on line " + (A + 1) + `:
` + C.showPosition() + `
Expecting ` + ht.join(", ") + ", got '" + (this.terminals_[V] || V) + "'" : Z = "Parse error on line " + (A + 1) + ": Unexpected " + (V == L ? "end of input" : "'" + (this.terminals_[V] || V) + "'"), this.parseError(Z, {
            text: C.match,
            token: this.terminals_[V] || V,
            line: C.yylineno,
            loc: W,
            expected: ht
          });
        }
        if (D[0] instanceof Array && D.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + $ + ", token: " + V);
        switch (D[0]) {
          case 1:
            y.push(V), x.push(C.yytext), b.push(C.yylloc), y.push(D[1]), V = null, S = C.yyleng, _ = C.yytext, A = C.yylineno, W = C.yylloc;
            break;
          case 2:
            if (G = this.productions_[D[1]][1], Y.$ = x[x.length - G], Y._$ = {
              first_line: b[b.length - (G || 1)].first_line,
              last_line: b[b.length - 1].last_line,
              first_column: b[b.length - (G || 1)].first_column,
              last_column: b[b.length - 1].last_column
            }, N && (Y._$.range = [
              b[b.length - (G || 1)].range[0],
              b[b.length - 1].range[1]
            ]), O = this.performAction.apply(Y, [
              _,
              S,
              A,
              E.yy,
              D[1],
              x,
              b
            ].concat(T)), typeof O < "u")
              return O;
            G && (y = y.slice(0, -1 * G * 2), x = x.slice(0, -1 * G), b = b.slice(0, -1 * G)), y.push(this.productions_[D[1]][0]), x.push(Y.$), b.push(Y._$), rt = v[y[y.length - 2]][y[y.length - 1]], y.push(rt);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, l = /* @__PURE__ */ function() {
    var p = {
      EOF: 1,
      parseError: /* @__PURE__ */ u(function(f, y) {
        if (this.yy.parser)
          this.yy.parser.parseError(f, y);
        else
          throw new Error(f);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ u(function(g, f) {
        return this.yy = f || this.yy || {}, this._input = g, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ u(function() {
        var g = this._input[0];
        this.yytext += g, this.yyleng++, this.offset++, this.match += g, this.matched += g;
        var f = g.match(/(?:\r\n?|\n).*/g);
        return f ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), g;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ u(function(g) {
        var f = g.length, y = g.split(/(?:\r\n?|\n)/g);
        this._input = g + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - f), this.offset -= f;
        var m = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), y.length - 1 && (this.yylineno -= y.length - 1);
        var x = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: y ? (y.length === m.length ? this.yylloc.first_column : 0) + m[m.length - y.length].length - y[0].length : this.yylloc.first_column - f
        }, this.options.ranges && (this.yylloc.range = [x[0], x[0] + this.yyleng - f]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ u(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ u(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ u(function(g) {
        this.unput(this.match.slice(g));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ u(function() {
        var g = this.matched.substr(0, this.matched.length - this.match.length);
        return (g.length > 20 ? "..." : "") + g.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ u(function() {
        var g = this.match;
        return g.length < 20 && (g += this._input.substr(0, 20 - g.length)), (g.substr(0, 20) + (g.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ u(function() {
        var g = this.pastInput(), f = new Array(g.length + 1).join("-");
        return g + this.upcomingInput() + `
` + f + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ u(function(g, f) {
        var y, m, x;
        if (this.options.backtrack_lexer && (x = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (x.yylloc.range = this.yylloc.range.slice(0))), m = g[0].match(/(?:\r\n?|\n).*/g), m && (this.yylineno += m.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: m ? m[m.length - 1].length - m[m.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + g[0].length
        }, this.yytext += g[0], this.match += g[0], this.matches = g, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(g[0].length), this.matched += g[0], y = this.performAction.call(this, this.yy, this, f, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), y)
          return y;
        if (this._backtrack) {
          for (var b in x)
            this[b] = x[b];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ u(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var g, f, y, m;
        this._more || (this.yytext = "", this.match = "");
        for (var x = this._currentRules(), b = 0; b < x.length; b++)
          if (y = this._input.match(this.rules[x[b]]), y && (!f || y[0].length > f[0].length)) {
            if (f = y, m = b, this.options.backtrack_lexer) {
              if (g = this.test_match(y, x[b]), g !== !1)
                return g;
              if (this._backtrack) {
                f = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return f ? (g = this.test_match(f, x[m]), g !== !1 ? g : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ u(function() {
        var f = this.next();
        return f || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ u(function(f) {
        this.conditionStack.push(f);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ u(function() {
        var f = this.conditionStack.length - 1;
        return f > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ u(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ u(function(f) {
        return f = this.conditionStack.length - 1 - Math.abs(f || 0), f >= 0 ? this.conditionStack[f] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ u(function(f) {
        this.begin(f);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ u(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: { "case-insensitive": !0 },
      performAction: /* @__PURE__ */ u(function(f, y, m, x) {
        switch (m) {
          case 0:
            break;
          case 1:
            break;
          case 2:
            return 10;
          case 3:
            break;
          case 4:
            break;
          case 5:
            return 4;
          case 6:
            return 11;
          case 7:
            return this.begin("acc_title"), 12;
          case 8:
            return this.popState(), "acc_title_value";
          case 9:
            return this.begin("acc_descr"), 14;
          case 10:
            return this.popState(), "acc_descr_value";
          case 11:
            this.begin("acc_descr_multiline");
            break;
          case 12:
            this.popState();
            break;
          case 13:
            return "acc_descr_multiline_value";
          case 14:
            return 17;
          case 15:
            return 18;
          case 16:
            return 19;
          case 17:
            return ":";
          case 18:
            return 6;
          case 19:
            return "INVALID";
        }
      }, "anonymous"),
      rules: [/^(?:%(?!\{)[^\n]*)/i, /^(?:[^\}]%%[^\n]*)/i, /^(?:[\n]+)/i, /^(?:\s+)/i, /^(?:#[^\n]*)/i, /^(?:journey\b)/i, /^(?:title\s[^#\n;]+)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:section\s[^#:\n;]+)/i, /^(?:[^#:\n;]+)/i, /^(?::[^#\n;]+)/i, /^(?::)/i, /^(?:$)/i, /^(?:.)/i],
      conditions: { acc_descr_multiline: { rules: [12, 13], inclusive: !1 }, acc_descr: { rules: [10], inclusive: !1 }, acc_title: { rules: [8], inclusive: !1 }, INITIAL: { rules: [0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 14, 15, 16, 17, 18, 19], inclusive: !0 } }
    };
    return p;
  }();
  h.lexer = l;
  function d() {
    this.yy = {};
  }
  return u(d, "Parser"), d.prototype = h, h.Parser = d, new d();
}();
uc.parser = uc;
var KT = uc, xa = "", Bh = [], nn = [], on = [], QT = /* @__PURE__ */ u(function() {
  Bh.length = 0, nn.length = 0, xa = "", on.length = 0, Me();
}, "clear"), ZT = /* @__PURE__ */ u(function(e) {
  xa = e, Bh.push(e);
}, "addSection"), JT = /* @__PURE__ */ u(function() {
  return Bh;
}, "getSections"), t7 = /* @__PURE__ */ u(function() {
  let e = zu();
  const t = 100;
  let r = 0;
  for (; !e && r < t; )
    e = zu(), r++;
  return nn.push(...on), nn;
}, "getTasks"), e7 = /* @__PURE__ */ u(function() {
  const e = [];
  return nn.forEach((r) => {
    r.people && e.push(...r.people);
  }), [...new Set(e)].sort();
}, "updateActors"), r7 = /* @__PURE__ */ u(function(e, t) {
  const r = t.substr(1).split(":");
  let i = 0, s = [];
  r.length === 1 ? (i = Number(r[0]), s = []) : (i = Number(r[0]), s = r[1].split(","));
  const a = s.map((o) => o.trim()), n = {
    section: xa,
    type: xa,
    people: a,
    task: e,
    score: i
  };
  on.push(n);
}, "addTask"), i7 = /* @__PURE__ */ u(function(e) {
  const t = {
    section: xa,
    type: xa,
    description: e,
    task: e,
    classes: []
  };
  nn.push(t);
}, "addTaskOrg"), zu = /* @__PURE__ */ u(function() {
  const e = /* @__PURE__ */ u(function(r) {
    return on[r].processed;
  }, "compileTask");
  let t = !0;
  for (const [r, i] of on.entries())
    e(r), t = t && i.processed;
  return t;
}, "compileTasks"), s7 = /* @__PURE__ */ u(function() {
  return e7();
}, "getActors"), Wu = {
  getConfig: /* @__PURE__ */ u(() => K().journey, "getConfig"),
  clear: QT,
  setDiagramTitle: Ge,
  getDiagramTitle: Oe,
  setAccTitle: Re,
  getAccTitle: qe,
  setAccDescription: Ye,
  getAccDescription: He,
  addSection: ZT,
  getSections: JT,
  getTasks: t7,
  addTask: r7,
  addTaskOrg: i7,
  getActors: s7
}, a7 = /* @__PURE__ */ u((e) => `.label {
    font-family: ${e.fontFamily};
    color: ${e.textColor};
  }
  .mouth {
    stroke: #666;
  }

  line {
    stroke: ${e.textColor}
  }

  .legend {
    fill: ${e.textColor};
    font-family: ${e.fontFamily};
  }

  .label text {
    fill: #333;
  }
  .label {
    color: ${e.textColor}
  }

  .face {
    ${e.faceColor ? `fill: ${e.faceColor}` : "fill: #FFF8DC"};
    stroke: #999;
  }

  .node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${e.mainBkg};
    stroke: ${e.nodeBorder};
    stroke-width: 1px;
  }

  .node .label {
    text-align: center;
  }
  .node.clickable {
    cursor: pointer;
  }

  .arrowheadPath {
    fill: ${e.arrowheadColor};
  }

  .edgePath .path {
    stroke: ${e.lineColor};
    stroke-width: 1.5px;
  }

  .flowchart-link {
    stroke: ${e.lineColor};
    fill: none;
  }

  .edgeLabel {
    background-color: ${e.edgeLabelBackground};
    rect {
      opacity: 0.5;
    }
    text-align: center;
  }

  .cluster rect {
  }

  .cluster text {
    fill: ${e.titleColor};
  }

  div.mermaidTooltip {
    position: absolute;
    text-align: center;
    max-width: 200px;
    padding: 2px;
    font-family: ${e.fontFamily};
    font-size: 12px;
    background: ${e.tertiaryColor};
    border: 1px solid ${e.border2};
    border-radius: 2px;
    pointer-events: none;
    z-index: 100;
  }

  .task-type-0, .section-type-0  {
    ${e.fillType0 ? `fill: ${e.fillType0}` : ""};
  }
  .task-type-1, .section-type-1  {
    ${e.fillType0 ? `fill: ${e.fillType1}` : ""};
  }
  .task-type-2, .section-type-2  {
    ${e.fillType0 ? `fill: ${e.fillType2}` : ""};
  }
  .task-type-3, .section-type-3  {
    ${e.fillType0 ? `fill: ${e.fillType3}` : ""};
  }
  .task-type-4, .section-type-4  {
    ${e.fillType0 ? `fill: ${e.fillType4}` : ""};
  }
  .task-type-5, .section-type-5  {
    ${e.fillType0 ? `fill: ${e.fillType5}` : ""};
  }
  .task-type-6, .section-type-6  {
    ${e.fillType0 ? `fill: ${e.fillType6}` : ""};
  }
  .task-type-7, .section-type-7  {
    ${e.fillType0 ? `fill: ${e.fillType7}` : ""};
  }

  .actor-0 {
    ${e.actor0 ? `fill: ${e.actor0}` : ""};
  }
  .actor-1 {
    ${e.actor1 ? `fill: ${e.actor1}` : ""};
  }
  .actor-2 {
    ${e.actor2 ? `fill: ${e.actor2}` : ""};
  }
  .actor-3 {
    ${e.actor3 ? `fill: ${e.actor3}` : ""};
  }
  .actor-4 {
    ${e.actor4 ? `fill: ${e.actor4}` : ""};
  }
  .actor-5 {
    ${e.actor5 ? `fill: ${e.actor5}` : ""};
  }
  ${yn()}
`, "getStyles"), n7 = a7, Dh = /* @__PURE__ */ u(function(e, t) {
  return $o(e, t);
}, "drawRect"), o7 = /* @__PURE__ */ u(function(e, t) {
  const i = e.append("circle").attr("cx", t.cx).attr("cy", t.cy).attr("class", "face").attr("r", 15).attr("stroke-width", 2).attr("overflow", "visible"), s = e.append("g");
  s.append("circle").attr("cx", t.cx - 15 / 3).attr("cy", t.cy - 15 / 3).attr("r", 1.5).attr("stroke-width", 2).attr("fill", "#666").attr("stroke", "#666"), s.append("circle").attr("cx", t.cx + 15 / 3).attr("cy", t.cy - 15 / 3).attr("r", 1.5).attr("stroke-width", 2).attr("fill", "#666").attr("stroke", "#666");
  function a(h) {
    const l = da().startAngle(Math.PI / 2).endAngle(3 * (Math.PI / 2)).innerRadius(7.5).outerRadius(6.8181818181818175);
    h.append("path").attr("class", "mouth").attr("d", l).attr("transform", "translate(" + t.cx + "," + (t.cy + 2) + ")");
  }
  u(a, "smile");
  function n(h) {
    const l = da().startAngle(3 * Math.PI / 2).endAngle(5 * (Math.PI / 2)).innerRadius(7.5).outerRadius(6.8181818181818175);
    h.append("path").attr("class", "mouth").attr("d", l).attr("transform", "translate(" + t.cx + "," + (t.cy + 7) + ")");
  }
  u(n, "sad");
  function o(h) {
    h.append("line").attr("class", "mouth").attr("stroke", 2).attr("x1", t.cx - 5).attr("y1", t.cy + 7).attr("x2", t.cx + 5).attr("y2", t.cy + 7).attr("class", "mouth").attr("stroke-width", "1px").attr("stroke", "#666");
  }
  return u(o, "ambivalent"), t.score > 3 ? a(s) : t.score < 3 ? n(s) : o(s), i;
}, "drawFace"), ny = /* @__PURE__ */ u(function(e, t) {
  const r = e.append("circle");
  return r.attr("cx", t.cx), r.attr("cy", t.cy), r.attr("class", "actor-" + t.pos), r.attr("fill", t.fill), r.attr("stroke", t.stroke), r.attr("r", t.r), r.class !== void 0 && r.attr("class", r.class), t.title !== void 0 && r.append("title").text(t.title), r;
}, "drawCircle"), oy = /* @__PURE__ */ u(function(e, t) {
  return o6(e, t);
}, "drawText"), l7 = /* @__PURE__ */ u(function(e, t) {
  function r(s, a, n, o, h) {
    return s + "," + a + " " + (s + n) + "," + a + " " + (s + n) + "," + (a + o - h) + " " + (s + n - h * 1.2) + "," + (a + o) + " " + s + "," + (a + o);
  }
  u(r, "genPoints");
  const i = e.append("polygon");
  i.attr("points", r(t.x, t.y, 50, 20, 7)), i.attr("class", "labelBox"), t.y = t.y + t.labelMargin, t.x = t.x + 0.5 * t.labelMargin, oy(e, t);
}, "drawLabel"), c7 = /* @__PURE__ */ u(function(e, t, r) {
  const i = e.append("g"), s = Er();
  s.x = t.x, s.y = t.y, s.fill = t.fill, s.width = r.width * t.taskCount + // width of the tasks
  r.diagramMarginX * (t.taskCount - 1), s.height = r.height, s.class = "journey-section section-type-" + t.num, s.rx = 3, s.ry = 3, Dh(i, s), ly(r)(
    t.text,
    i,
    s.x,
    s.y,
    s.width,
    s.height,
    { class: "journey-section section-type-" + t.num },
    r,
    t.colour
  );
}, "drawSection"), qu = -1, h7 = /* @__PURE__ */ u(function(e, t, r) {
  const i = t.x + r.width / 2, s = e.append("g");
  qu++;
  const a = 300 + 5 * 30;
  s.append("line").attr("id", "task" + qu).attr("x1", i).attr("y1", t.y).attr("x2", i).attr("y2", a).attr("class", "task-line").attr("stroke-width", "1px").attr("stroke-dasharray", "4 2").attr("stroke", "#666"), o7(s, {
    cx: i,
    cy: 300 + (5 - t.score) * 30,
    score: t.score
  });
  const n = Er();
  n.x = t.x, n.y = t.y, n.fill = t.fill, n.width = r.width, n.height = r.height, n.class = "task task-type-" + t.num, n.rx = 3, n.ry = 3, Dh(s, n);
  let o = t.x + 14;
  t.people.forEach((h) => {
    const l = t.actors[h].color, d = {
      cx: o,
      cy: t.y,
      r: 7,
      fill: l,
      stroke: "#000",
      title: h,
      pos: t.actors[h].position
    };
    ny(s, d), o += 10;
  }), ly(r)(
    t.task,
    s,
    n.x,
    n.y,
    n.width,
    n.height,
    { class: "task" },
    r,
    t.colour
  );
}, "drawTask"), u7 = /* @__PURE__ */ u(function(e, t) {
  Sf(e, t);
}, "drawBackgroundRect"), ly = /* @__PURE__ */ function() {
  function e(s, a, n, o, h, l, d, p) {
    const g = a.append("text").attr("x", n + h / 2).attr("y", o + l / 2 + 5).style("font-color", p).style("text-anchor", "middle").text(s);
    i(g, d);
  }
  u(e, "byText");
  function t(s, a, n, o, h, l, d, p, g) {
    const { taskFontSize: f, taskFontFamily: y } = p, m = s.split(/<br\s*\/?>/gi);
    for (let x = 0; x < m.length; x++) {
      const b = x * f - f * (m.length - 1) / 2, v = a.append("text").attr("x", n + h / 2).attr("y", o).attr("fill", g).style("text-anchor", "middle").style("font-size", f).style("font-family", y);
      v.append("tspan").attr("x", n + h / 2).attr("dy", b).text(m[x]), v.attr("y", o + l / 2).attr("dominant-baseline", "central").attr("alignment-baseline", "central"), i(v, d);
    }
  }
  u(t, "byTspan");
  function r(s, a, n, o, h, l, d, p) {
    const g = a.append("switch"), y = g.append("foreignObject").attr("x", n).attr("y", o).attr("width", h).attr("height", l).attr("position", "fixed").append("xhtml:div").style("display", "table").style("height", "100%").style("width", "100%");
    y.append("div").attr("class", "label").style("display", "table-cell").style("text-align", "center").style("vertical-align", "middle").text(s), t(s, g, n, o, h, l, d, p), i(y, d);
  }
  u(r, "byFo");
  function i(s, a) {
    for (const n in a)
      n in a && s.attr(n, a[n]);
  }
  return u(i, "_setTextAttrs"), function(s) {
    return s.textPlacement === "fo" ? r : s.textPlacement === "old" ? e : t;
  };
}(), d7 = /* @__PURE__ */ u(function(e) {
  e.append("defs").append("marker").attr("id", "arrowhead").attr("refX", 5).attr("refY", 2).attr("markerWidth", 6).attr("markerHeight", 4).attr("orient", "auto").append("path").attr("d", "M 0,0 V 4 L6,2 Z");
}, "initGraphics"), ln = {
  drawRect: Dh,
  drawCircle: ny,
  drawSection: c7,
  drawText: oy,
  drawLabel: l7,
  drawTask: h7,
  drawBackgroundRect: u7,
  initGraphics: d7
}, p7 = /* @__PURE__ */ u(function(e) {
  Object.keys(e).forEach(function(r) {
    Or[r] = e[r];
  });
}, "setConf"), gi = {}, Vn = 0;
function cy(e) {
  const t = K().journey, r = t.maxLabelWidth;
  Vn = 0;
  let i = 60;
  Object.keys(gi).forEach((s) => {
    const a = gi[s].color, n = {
      cx: 20,
      cy: i,
      r: 7,
      fill: a,
      stroke: "#000",
      pos: gi[s].position
    };
    ln.drawCircle(e, n);
    let o = e.append("text").attr("visibility", "hidden").text(s);
    const h = o.node().getBoundingClientRect().width;
    o.remove();
    let l = [];
    if (h <= r)
      l = [s];
    else {
      const d = s.split(" ");
      let p = "";
      o = e.append("text").attr("visibility", "hidden"), d.forEach((g) => {
        const f = p ? `${p} ${g}` : g;
        if (o.text(f), o.node().getBoundingClientRect().width > r) {
          if (p && l.push(p), p = g, o.text(g), o.node().getBoundingClientRect().width > r) {
            let m = "";
            for (const x of g)
              m += x, o.text(m + "-"), o.node().getBoundingClientRect().width > r && (l.push(m.slice(0, -1) + "-"), m = x);
            p = m;
          }
        } else
          p = f;
      }), p && l.push(p), o.remove();
    }
    l.forEach((d, p) => {
      const g = {
        x: 40,
        y: i + 7 + p * 20,
        fill: "#666",
        text: d,
        textMargin: t.boxTextMargin ?? 5
      }, y = ln.drawText(e, g).node().getBoundingClientRect().width;
      y > Vn && y > t.leftMargin - y && (Vn = y);
    }), i += Math.max(20, l.length * 20);
  });
}
u(cy, "drawActorLegend");
var Or = K().journey, Si = 0, g7 = /* @__PURE__ */ u(function(e, t, r, i) {
  const s = K(), a = s.journey.titleColor, n = s.journey.titleFontSize, o = s.journey.titleFontFamily, h = s.securityLevel;
  let l;
  h === "sandbox" && (l = yt("#i" + t));
  const d = h === "sandbox" ? yt(l.nodes()[0].contentDocument.body) : yt("body");
  Ir.init();
  const p = d.select("#" + t);
  ln.initGraphics(p);
  const g = i.db.getTasks(), f = i.db.getDiagramTitle(), y = i.db.getActors();
  for (const A in gi)
    delete gi[A];
  let m = 0;
  y.forEach((A) => {
    gi[A] = {
      color: Or.actorColours[m % Or.actorColours.length],
      position: m
    }, m++;
  }), cy(p), Si = Or.leftMargin + Vn, Ir.insert(0, 0, Si, Object.keys(gi).length * 50), f7(p, g, 0);
  const x = Ir.getBounds();
  f && p.append("text").text(f).attr("x", Si).attr("font-size", n).attr("font-weight", "bold").attr("y", 25).attr("fill", a).attr("font-family", o);
  const b = x.stopy - x.starty + 2 * Or.diagramMarginY, v = Si + x.stopx + 2 * Or.diagramMarginX;
  fr(p, b, v, Or.useMaxWidth), p.append("line").attr("x1", Si).attr("y1", Or.height * 4).attr("x2", v - Si - 4).attr("y2", Or.height * 4).attr("stroke-width", 4).attr("stroke", "black").attr("marker-end", "url(#arrowhead)");
  const _ = f ? 70 : 0;
  p.attr("viewBox", `${x.startx} -25 ${v} ${b + _}`), p.attr("preserveAspectRatio", "xMinYMin meet"), p.attr("height", b + _ + 25);
}, "draw"), Ir = {
  data: {
    startx: void 0,
    stopx: void 0,
    starty: void 0,
    stopy: void 0
  },
  verticalPos: 0,
  sequenceItems: [],
  init: /* @__PURE__ */ u(function() {
    this.sequenceItems = [], this.data = {
      startx: void 0,
      stopx: void 0,
      starty: void 0,
      stopy: void 0
    }, this.verticalPos = 0;
  }, "init"),
  updateVal: /* @__PURE__ */ u(function(e, t, r, i) {
    e[t] === void 0 ? e[t] = r : e[t] = i(r, e[t]);
  }, "updateVal"),
  updateBounds: /* @__PURE__ */ u(function(e, t, r, i) {
    const s = K().journey, a = this;
    let n = 0;
    function o(h) {
      return /* @__PURE__ */ u(function(d) {
        n++;
        const p = a.sequenceItems.length - n + 1;
        a.updateVal(d, "starty", t - p * s.boxMargin, Math.min), a.updateVal(d, "stopy", i + p * s.boxMargin, Math.max), a.updateVal(Ir.data, "startx", e - p * s.boxMargin, Math.min), a.updateVal(Ir.data, "stopx", r + p * s.boxMargin, Math.max), h !== "activation" && (a.updateVal(d, "startx", e - p * s.boxMargin, Math.min), a.updateVal(d, "stopx", r + p * s.boxMargin, Math.max), a.updateVal(Ir.data, "starty", t - p * s.boxMargin, Math.min), a.updateVal(Ir.data, "stopy", i + p * s.boxMargin, Math.max));
      }, "updateItemBounds");
    }
    u(o, "updateFn"), this.sequenceItems.forEach(o());
  }, "updateBounds"),
  insert: /* @__PURE__ */ u(function(e, t, r, i) {
    const s = Math.min(e, r), a = Math.max(e, r), n = Math.min(t, i), o = Math.max(t, i);
    this.updateVal(Ir.data, "startx", s, Math.min), this.updateVal(Ir.data, "starty", n, Math.min), this.updateVal(Ir.data, "stopx", a, Math.max), this.updateVal(Ir.data, "stopy", o, Math.max), this.updateBounds(s, n, a, o);
  }, "insert"),
  bumpVerticalPos: /* @__PURE__ */ u(function(e) {
    this.verticalPos = this.verticalPos + e, this.data.stopy = this.verticalPos;
  }, "bumpVerticalPos"),
  getVerticalPos: /* @__PURE__ */ u(function() {
    return this.verticalPos;
  }, "getVerticalPos"),
  getBounds: /* @__PURE__ */ u(function() {
    return this.data;
  }, "getBounds")
}, hl = Or.sectionFills, Yu = Or.sectionColours, f7 = /* @__PURE__ */ u(function(e, t, r) {
  const i = K().journey;
  let s = "";
  const a = i.height * 2 + i.diagramMarginY, n = r + a;
  let o = 0, h = "#CCC", l = "black", d = 0;
  for (const [p, g] of t.entries()) {
    if (s !== g.section) {
      h = hl[o % hl.length], d = o % hl.length, l = Yu[o % Yu.length];
      let y = 0;
      const m = g.section;
      for (let b = p; b < t.length && t[b].section == m; b++)
        y = y + 1;
      const x = {
        x: p * i.taskMargin + p * i.width + Si,
        y: 50,
        text: g.section,
        fill: h,
        num: d,
        colour: l,
        taskCount: y
      };
      ln.drawSection(e, x, i), s = g.section, o++;
    }
    const f = g.people.reduce((y, m) => (gi[m] && (y[m] = gi[m]), y), {});
    g.x = p * i.taskMargin + p * i.width + Si, g.y = n, g.width = i.diagramMarginX, g.height = i.diagramMarginY, g.colour = l, g.fill = h, g.num = d, g.actors = f, ln.drawTask(e, g, i), Ir.insert(g.x, g.y, g.x + g.width + i.taskMargin, 300 + 5 * 30);
  }
}, "drawTasks"), Hu = {
  setConf: p7,
  draw: g7
}, y7 = {
  parser: KT,
  db: Wu,
  renderer: Hu,
  styles: n7,
  init: /* @__PURE__ */ u((e) => {
    Hu.setConf(e.journey), Wu.clear();
  }, "init")
};
const m7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: y7
}, Symbol.toStringTag, { value: "Module" }));
var dc = function() {
  var e = /* @__PURE__ */ u(function(g, f, y, m) {
    for (y = y || {}, m = g.length; m--; y[g[m]] = f) ;
    return y;
  }, "o"), t = [6, 8, 10, 11, 12, 14, 16, 17, 20, 21], r = [1, 9], i = [1, 10], s = [1, 11], a = [1, 12], n = [1, 13], o = [1, 16], h = [1, 17], l = {
    trace: /* @__PURE__ */ u(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, start: 3, timeline: 4, document: 5, EOF: 6, line: 7, SPACE: 8, statement: 9, NEWLINE: 10, title: 11, acc_title: 12, acc_title_value: 13, acc_descr: 14, acc_descr_value: 15, acc_descr_multiline_value: 16, section: 17, period_statement: 18, event_statement: 19, period: 20, event: 21, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 4: "timeline", 6: "EOF", 8: "SPACE", 10: "NEWLINE", 11: "title", 12: "acc_title", 13: "acc_title_value", 14: "acc_descr", 15: "acc_descr_value", 16: "acc_descr_multiline_value", 17: "section", 20: "period", 21: "event" },
    productions_: [0, [3, 3], [5, 0], [5, 2], [7, 2], [7, 1], [7, 1], [7, 1], [9, 1], [9, 2], [9, 2], [9, 1], [9, 1], [9, 1], [9, 1], [18, 1], [19, 1]],
    performAction: /* @__PURE__ */ u(function(f, y, m, x, b, v, _) {
      var A = v.length - 1;
      switch (b) {
        case 1:
          return v[A - 1];
        case 2:
          this.$ = [];
          break;
        case 3:
          v[A - 1].push(v[A]), this.$ = v[A - 1];
          break;
        case 4:
        case 5:
          this.$ = v[A];
          break;
        case 6:
        case 7:
          this.$ = [];
          break;
        case 8:
          x.getCommonDb().setDiagramTitle(v[A].substr(6)), this.$ = v[A].substr(6);
          break;
        case 9:
          this.$ = v[A].trim(), x.getCommonDb().setAccTitle(this.$);
          break;
        case 10:
        case 11:
          this.$ = v[A].trim(), x.getCommonDb().setAccDescription(this.$);
          break;
        case 12:
          x.addSection(v[A].substr(8)), this.$ = v[A].substr(8);
          break;
        case 15:
          x.addTask(v[A], 0, ""), this.$ = v[A];
          break;
        case 16:
          x.addEvent(v[A].substr(2)), this.$ = v[A];
          break;
      }
    }, "anonymous"),
    table: [{ 3: 1, 4: [1, 2] }, { 1: [3] }, e(t, [2, 2], { 5: 3 }), { 6: [1, 4], 7: 5, 8: [1, 6], 9: 7, 10: [1, 8], 11: r, 12: i, 14: s, 16: a, 17: n, 18: 14, 19: 15, 20: o, 21: h }, e(t, [2, 7], { 1: [2, 1] }), e(t, [2, 3]), { 9: 18, 11: r, 12: i, 14: s, 16: a, 17: n, 18: 14, 19: 15, 20: o, 21: h }, e(t, [2, 5]), e(t, [2, 6]), e(t, [2, 8]), { 13: [1, 19] }, { 15: [1, 20] }, e(t, [2, 11]), e(t, [2, 12]), e(t, [2, 13]), e(t, [2, 14]), e(t, [2, 15]), e(t, [2, 16]), e(t, [2, 4]), e(t, [2, 9]), e(t, [2, 10])],
    defaultActions: {},
    parseError: /* @__PURE__ */ u(function(f, y) {
      if (y.recoverable)
        this.trace(f);
      else {
        var m = new Error(f);
        throw m.hash = y, m;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ u(function(f) {
      var y = this, m = [0], x = [], b = [null], v = [], _ = this.table, A = "", S = 0, k = 0, L = 2, T = 1, C = v.slice.call(arguments, 1), E = Object.create(this.lexer), w = { yy: {} };
      for (var W in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, W) && (w.yy[W] = this.yy[W]);
      E.setInput(f, w.yy), w.yy.lexer = E, w.yy.parser = this, typeof E.yylloc > "u" && (E.yylloc = {});
      var N = E.yylloc;
      v.push(N);
      var B = E.options && E.options.ranges;
      typeof w.yy.parseError == "function" ? this.parseError = w.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function R(it) {
        m.length = m.length - 2 * it, b.length = b.length - it, v.length = v.length - it;
      }
      u(R, "popStack");
      function V() {
        var it;
        return it = x.pop() || E.lex() || T, typeof it != "number" && (it instanceof Array && (x = it, it = x.pop()), it = y.symbols_[it] || it), it;
      }
      u(V, "lex");
      for (var $, D, O, Y, M = {}, G, rt, ht, Z; ; ) {
        if (D = m[m.length - 1], this.defaultActions[D] ? O = this.defaultActions[D] : (($ === null || typeof $ > "u") && ($ = V()), O = _[D] && _[D][$]), typeof O > "u" || !O.length || !O[0]) {
          var ot = "";
          Z = [];
          for (G in _[D])
            this.terminals_[G] && G > L && Z.push("'" + this.terminals_[G] + "'");
          E.showPosition ? ot = "Parse error on line " + (S + 1) + `:
` + E.showPosition() + `
Expecting ` + Z.join(", ") + ", got '" + (this.terminals_[$] || $) + "'" : ot = "Parse error on line " + (S + 1) + ": Unexpected " + ($ == T ? "end of input" : "'" + (this.terminals_[$] || $) + "'"), this.parseError(ot, {
            text: E.match,
            token: this.terminals_[$] || $,
            line: E.yylineno,
            loc: N,
            expected: Z
          });
        }
        if (O[0] instanceof Array && O.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + D + ", token: " + $);
        switch (O[0]) {
          case 1:
            m.push($), b.push(E.yytext), v.push(E.yylloc), m.push(O[1]), $ = null, k = E.yyleng, A = E.yytext, S = E.yylineno, N = E.yylloc;
            break;
          case 2:
            if (rt = this.productions_[O[1]][1], M.$ = b[b.length - rt], M._$ = {
              first_line: v[v.length - (rt || 1)].first_line,
              last_line: v[v.length - 1].last_line,
              first_column: v[v.length - (rt || 1)].first_column,
              last_column: v[v.length - 1].last_column
            }, B && (M._$.range = [
              v[v.length - (rt || 1)].range[0],
              v[v.length - 1].range[1]
            ]), Y = this.performAction.apply(M, [
              A,
              k,
              S,
              w.yy,
              O[1],
              b,
              v
            ].concat(C)), typeof Y < "u")
              return Y;
            rt && (m = m.slice(0, -1 * rt * 2), b = b.slice(0, -1 * rt), v = v.slice(0, -1 * rt)), m.push(this.productions_[O[1]][0]), b.push(M.$), v.push(M._$), ht = _[m[m.length - 2]][m[m.length - 1]], m.push(ht);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, d = /* @__PURE__ */ function() {
    var g = {
      EOF: 1,
      parseError: /* @__PURE__ */ u(function(y, m) {
        if (this.yy.parser)
          this.yy.parser.parseError(y, m);
        else
          throw new Error(y);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ u(function(f, y) {
        return this.yy = y || this.yy || {}, this._input = f, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ u(function() {
        var f = this._input[0];
        this.yytext += f, this.yyleng++, this.offset++, this.match += f, this.matched += f;
        var y = f.match(/(?:\r\n?|\n).*/g);
        return y ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), f;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ u(function(f) {
        var y = f.length, m = f.split(/(?:\r\n?|\n)/g);
        this._input = f + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - y), this.offset -= y;
        var x = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), m.length - 1 && (this.yylineno -= m.length - 1);
        var b = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: m ? (m.length === x.length ? this.yylloc.first_column : 0) + x[x.length - m.length].length - m[0].length : this.yylloc.first_column - y
        }, this.options.ranges && (this.yylloc.range = [b[0], b[0] + this.yyleng - y]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ u(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ u(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ u(function(f) {
        this.unput(this.match.slice(f));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ u(function() {
        var f = this.matched.substr(0, this.matched.length - this.match.length);
        return (f.length > 20 ? "..." : "") + f.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ u(function() {
        var f = this.match;
        return f.length < 20 && (f += this._input.substr(0, 20 - f.length)), (f.substr(0, 20) + (f.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ u(function() {
        var f = this.pastInput(), y = new Array(f.length + 1).join("-");
        return f + this.upcomingInput() + `
` + y + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ u(function(f, y) {
        var m, x, b;
        if (this.options.backtrack_lexer && (b = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (b.yylloc.range = this.yylloc.range.slice(0))), x = f[0].match(/(?:\r\n?|\n).*/g), x && (this.yylineno += x.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: x ? x[x.length - 1].length - x[x.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + f[0].length
        }, this.yytext += f[0], this.match += f[0], this.matches = f, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(f[0].length), this.matched += f[0], m = this.performAction.call(this, this.yy, this, y, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), m)
          return m;
        if (this._backtrack) {
          for (var v in b)
            this[v] = b[v];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ u(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var f, y, m, x;
        this._more || (this.yytext = "", this.match = "");
        for (var b = this._currentRules(), v = 0; v < b.length; v++)
          if (m = this._input.match(this.rules[b[v]]), m && (!y || m[0].length > y[0].length)) {
            if (y = m, x = v, this.options.backtrack_lexer) {
              if (f = this.test_match(m, b[v]), f !== !1)
                return f;
              if (this._backtrack) {
                y = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return y ? (f = this.test_match(y, b[x]), f !== !1 ? f : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ u(function() {
        var y = this.next();
        return y || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ u(function(y) {
        this.conditionStack.push(y);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ u(function() {
        var y = this.conditionStack.length - 1;
        return y > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ u(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ u(function(y) {
        return y = this.conditionStack.length - 1 - Math.abs(y || 0), y >= 0 ? this.conditionStack[y] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ u(function(y) {
        this.begin(y);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ u(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: { "case-insensitive": !0 },
      performAction: /* @__PURE__ */ u(function(y, m, x, b) {
        switch (x) {
          case 0:
            break;
          case 1:
            break;
          case 2:
            return 10;
          case 3:
            break;
          case 4:
            break;
          case 5:
            return 4;
          case 6:
            return 11;
          case 7:
            return this.begin("acc_title"), 12;
          case 8:
            return this.popState(), "acc_title_value";
          case 9:
            return this.begin("acc_descr"), 14;
          case 10:
            return this.popState(), "acc_descr_value";
          case 11:
            this.begin("acc_descr_multiline");
            break;
          case 12:
            this.popState();
            break;
          case 13:
            return "acc_descr_multiline_value";
          case 14:
            return 17;
          case 15:
            return 21;
          case 16:
            return 20;
          case 17:
            return 6;
          case 18:
            return "INVALID";
        }
      }, "anonymous"),
      rules: [/^(?:%(?!\{)[^\n]*)/i, /^(?:[^\}]%%[^\n]*)/i, /^(?:[\n]+)/i, /^(?:\s+)/i, /^(?:#[^\n]*)/i, /^(?:timeline\b)/i, /^(?:title\s[^\n]+)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:section\s[^:\n]+)/i, /^(?::\s(?:[^:\n]|:(?!\s))+)/i, /^(?:[^#:\n]+)/i, /^(?:$)/i, /^(?:.)/i],
      conditions: { acc_descr_multiline: { rules: [12, 13], inclusive: !1 }, acc_descr: { rules: [10], inclusive: !1 }, acc_title: { rules: [8], inclusive: !1 }, INITIAL: { rules: [0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 14, 15, 16, 17, 18], inclusive: !0 } }
    };
    return g;
  }();
  l.lexer = d;
  function p() {
    this.yy = {};
  }
  return u(p, "Parser"), p.prototype = l, l.Parser = p, new p();
}();
dc.parser = dc;
var x7 = dc, hy = {};
Co(hy, {
  addEvent: () => xy,
  addSection: () => gy,
  addTask: () => my,
  addTaskOrg: () => by,
  clear: () => py,
  default: () => b7,
  getCommonDb: () => dy,
  getSections: () => fy,
  getTasks: () => yy
});
var ba = "", uy = 0, Ih = [], yo = [], ka = [], dy = /* @__PURE__ */ u(() => Ec, "getCommonDb"), py = /* @__PURE__ */ u(function() {
  Ih.length = 0, yo.length = 0, ba = "", ka.length = 0, Me();
}, "clear"), gy = /* @__PURE__ */ u(function(e) {
  ba = e, Ih.push(e);
}, "addSection"), fy = /* @__PURE__ */ u(function() {
  return Ih;
}, "getSections"), yy = /* @__PURE__ */ u(function() {
  let e = Uu();
  const t = 100;
  let r = 0;
  for (; !e && r < t; )
    e = Uu(), r++;
  return yo.push(...ka), yo;
}, "getTasks"), my = /* @__PURE__ */ u(function(e, t, r) {
  const i = {
    id: uy++,
    section: ba,
    type: ba,
    task: e,
    score: t || 0,
    //if event is defined, then add it the events array
    events: r ? [r] : []
  };
  ka.push(i);
}, "addTask"), xy = /* @__PURE__ */ u(function(e) {
  ka.find((r) => r.id === uy - 1).events.push(e);
}, "addEvent"), by = /* @__PURE__ */ u(function(e) {
  const t = {
    section: ba,
    type: ba,
    description: e,
    task: e,
    classes: []
  };
  yo.push(t);
}, "addTaskOrg"), Uu = /* @__PURE__ */ u(function() {
  const e = /* @__PURE__ */ u(function(r) {
    return ka[r].processed;
  }, "compileTask");
  let t = !0;
  for (const [r, i] of ka.entries())
    e(r), t = t && i.processed;
  return t;
}, "compileTasks"), b7 = {
  clear: py,
  getCommonDb: dy,
  addSection: gy,
  getSections: fy,
  getTasks: yy,
  addTask: my,
  addTaskOrg: by,
  addEvent: xy
}, k7 = 12, jo = /* @__PURE__ */ u(function(e, t) {
  const r = e.append("rect");
  return r.attr("x", t.x), r.attr("y", t.y), r.attr("fill", t.fill), r.attr("stroke", t.stroke), r.attr("width", t.width), r.attr("height", t.height), r.attr("rx", t.rx), r.attr("ry", t.ry), t.class !== void 0 && r.attr("class", t.class), r;
}, "drawRect"), v7 = /* @__PURE__ */ u(function(e, t) {
  const i = e.append("circle").attr("cx", t.cx).attr("cy", t.cy).attr("class", "face").attr("r", 15).attr("stroke-width", 2).attr("overflow", "visible"), s = e.append("g");
  s.append("circle").attr("cx", t.cx - 15 / 3).attr("cy", t.cy - 15 / 3).attr("r", 1.5).attr("stroke-width", 2).attr("fill", "#666").attr("stroke", "#666"), s.append("circle").attr("cx", t.cx + 15 / 3).attr("cy", t.cy - 15 / 3).attr("r", 1.5).attr("stroke-width", 2).attr("fill", "#666").attr("stroke", "#666");
  function a(h) {
    const l = da().startAngle(Math.PI / 2).endAngle(3 * (Math.PI / 2)).innerRadius(7.5).outerRadius(6.8181818181818175);
    h.append("path").attr("class", "mouth").attr("d", l).attr("transform", "translate(" + t.cx + "," + (t.cy + 2) + ")");
  }
  u(a, "smile");
  function n(h) {
    const l = da().startAngle(3 * Math.PI / 2).endAngle(5 * (Math.PI / 2)).innerRadius(7.5).outerRadius(6.8181818181818175);
    h.append("path").attr("class", "mouth").attr("d", l).attr("transform", "translate(" + t.cx + "," + (t.cy + 7) + ")");
  }
  u(n, "sad");
  function o(h) {
    h.append("line").attr("class", "mouth").attr("stroke", 2).attr("x1", t.cx - 5).attr("y1", t.cy + 7).attr("x2", t.cx + 5).attr("y2", t.cy + 7).attr("class", "mouth").attr("stroke-width", "1px").attr("stroke", "#666");
  }
  return u(o, "ambivalent"), t.score > 3 ? a(s) : t.score < 3 ? n(s) : o(s), i;
}, "drawFace"), S7 = /* @__PURE__ */ u(function(e, t) {
  const r = e.append("circle");
  return r.attr("cx", t.cx), r.attr("cy", t.cy), r.attr("class", "actor-" + t.pos), r.attr("fill", t.fill), r.attr("stroke", t.stroke), r.attr("r", t.r), r.class !== void 0 && r.attr("class", r.class), t.title !== void 0 && r.append("title").text(t.title), r;
}, "drawCircle"), ky = /* @__PURE__ */ u(function(e, t) {
  const r = t.text.replace(/<br\s*\/?>/gi, " "), i = e.append("text");
  i.attr("x", t.x), i.attr("y", t.y), i.attr("class", "legend"), i.style("text-anchor", t.anchor), t.class !== void 0 && i.attr("class", t.class);
  const s = i.append("tspan");
  return s.attr("x", t.x + t.textMargin * 2), s.text(r), i;
}, "drawText"), C7 = /* @__PURE__ */ u(function(e, t) {
  function r(s, a, n, o, h) {
    return s + "," + a + " " + (s + n) + "," + a + " " + (s + n) + "," + (a + o - h) + " " + (s + n - h * 1.2) + "," + (a + o) + " " + s + "," + (a + o);
  }
  u(r, "genPoints");
  const i = e.append("polygon");
  i.attr("points", r(t.x, t.y, 50, 20, 7)), i.attr("class", "labelBox"), t.y = t.y + t.labelMargin, t.x = t.x + 0.5 * t.labelMargin, ky(e, t);
}, "drawLabel"), w7 = /* @__PURE__ */ u(function(e, t, r) {
  const i = e.append("g"), s = Fh();
  s.x = t.x, s.y = t.y, s.fill = t.fill, s.width = r.width, s.height = r.height, s.class = "journey-section section-type-" + t.num, s.rx = 3, s.ry = 3, jo(i, s), vy(r)(
    t.text,
    i,
    s.x,
    s.y,
    s.width,
    s.height,
    { class: "journey-section section-type-" + t.num },
    r,
    t.colour
  );
}, "drawSection"), ju = -1, T7 = /* @__PURE__ */ u(function(e, t, r) {
  const i = t.x + r.width / 2, s = e.append("g");
  ju++;
  const a = 300 + 5 * 30;
  s.append("line").attr("id", "task" + ju).attr("x1", i).attr("y1", t.y).attr("x2", i).attr("y2", a).attr("class", "task-line").attr("stroke-width", "1px").attr("stroke-dasharray", "4 2").attr("stroke", "#666"), v7(s, {
    cx: i,
    cy: 300 + (5 - t.score) * 30,
    score: t.score
  });
  const n = Fh();
  n.x = t.x, n.y = t.y, n.fill = t.fill, n.width = r.width, n.height = r.height, n.class = "task task-type-" + t.num, n.rx = 3, n.ry = 3, jo(s, n), vy(r)(
    t.task,
    s,
    n.x,
    n.y,
    n.width,
    n.height,
    { class: "task" },
    r,
    t.colour
  );
}, "drawTask"), _7 = /* @__PURE__ */ u(function(e, t) {
  jo(e, {
    x: t.startx,
    y: t.starty,
    width: t.stopx - t.startx,
    height: t.stopy - t.starty,
    fill: t.fill,
    class: "rect"
  }).lower();
}, "drawBackgroundRect"), E7 = /* @__PURE__ */ u(function() {
  return {
    x: 0,
    y: 0,
    fill: void 0,
    "text-anchor": "start",
    width: 100,
    height: 100,
    textMargin: 0,
    rx: 0,
    ry: 0
  };
}, "getTextObj"), Fh = /* @__PURE__ */ u(function() {
  return {
    x: 0,
    y: 0,
    width: 100,
    anchor: "start",
    height: 100,
    rx: 0,
    ry: 0
  };
}, "getNoteRect"), vy = /* @__PURE__ */ function() {
  function e(s, a, n, o, h, l, d, p) {
    const g = a.append("text").attr("x", n + h / 2).attr("y", o + l / 2 + 5).style("font-color", p).style("text-anchor", "middle").text(s);
    i(g, d);
  }
  u(e, "byText");
  function t(s, a, n, o, h, l, d, p, g) {
    const { taskFontSize: f, taskFontFamily: y } = p, m = s.split(/<br\s*\/?>/gi);
    for (let x = 0; x < m.length; x++) {
      const b = x * f - f * (m.length - 1) / 2, v = a.append("text").attr("x", n + h / 2).attr("y", o).attr("fill", g).style("text-anchor", "middle").style("font-size", f).style("font-family", y);
      v.append("tspan").attr("x", n + h / 2).attr("dy", b).text(m[x]), v.attr("y", o + l / 2).attr("dominant-baseline", "central").attr("alignment-baseline", "central"), i(v, d);
    }
  }
  u(t, "byTspan");
  function r(s, a, n, o, h, l, d, p) {
    const g = a.append("switch"), y = g.append("foreignObject").attr("x", n).attr("y", o).attr("width", h).attr("height", l).attr("position", "fixed").append("xhtml:div").style("display", "table").style("height", "100%").style("width", "100%");
    y.append("div").attr("class", "label").style("display", "table-cell").style("text-align", "center").style("vertical-align", "middle").text(s), t(s, g, n, o, h, l, d, p), i(y, d);
  }
  u(r, "byFo");
  function i(s, a) {
    for (const n in a)
      n in a && s.attr(n, a[n]);
  }
  return u(i, "_setTextAttrs"), function(s) {
    return s.textPlacement === "fo" ? r : s.textPlacement === "old" ? e : t;
  };
}(), A7 = /* @__PURE__ */ u(function(e) {
  e.append("defs").append("marker").attr("id", "arrowhead").attr("refX", 5).attr("refY", 2).attr("markerWidth", 6).attr("markerHeight", 4).attr("orient", "auto").append("path").attr("d", "M 0,0 V 4 L6,2 Z");
}, "initGraphics");
function Nh(e, t) {
  e.each(function() {
    var r = yt(this), i = r.text().split(/(\s+|<br>)/).reverse(), s, a = [], n = 1.1, o = r.attr("y"), h = parseFloat(r.attr("dy")), l = r.text(null).append("tspan").attr("x", 0).attr("y", o).attr("dy", h + "em");
    for (let d = 0; d < i.length; d++)
      s = i[i.length - 1 - d], a.push(s), l.text(a.join(" ").trim()), (l.node().getComputedTextLength() > t || s === "<br>") && (a.pop(), l.text(a.join(" ").trim()), s === "<br>" ? a = [""] : a = [s], l = r.append("tspan").attr("x", 0).attr("y", o).attr("dy", n + "em").text(s));
  });
}
u(Nh, "wrap");
var L7 = /* @__PURE__ */ u(function(e, t, r, i) {
  var p;
  const s = r % k7 - 1, a = e.append("g");
  t.section = s, a.attr(
    "class",
    (t.class ? t.class + " " : "") + "timeline-node " + ("section-" + s)
  );
  const n = a.append("g"), o = a.append("g"), l = o.append("text").text(t.descr).attr("dy", "1em").attr("alignment-baseline", "middle").attr("dominant-baseline", "middle").attr("text-anchor", "middle").call(Nh, t.width).node().getBBox(), d = (p = i.fontSize) != null && p.replace ? i.fontSize.replace("px", "") : i.fontSize;
  return t.height = l.height + d * 1.1 * 0.5 + t.padding, t.height = Math.max(t.height, t.maxHeight), t.width = t.width + 2 * t.padding, o.attr("transform", "translate(" + t.width / 2 + ", " + t.padding / 2 + ")"), D7(n, t, s, i), t;
}, "drawNode"), B7 = /* @__PURE__ */ u(function(e, t, r) {
  var o;
  const i = e.append("g"), a = i.append("text").text(t.descr).attr("dy", "1em").attr("alignment-baseline", "middle").attr("dominant-baseline", "middle").attr("text-anchor", "middle").call(Nh, t.width).node().getBBox(), n = (o = r.fontSize) != null && o.replace ? r.fontSize.replace("px", "") : r.fontSize;
  return i.remove(), a.height + n * 1.1 * 0.5 + t.padding;
}, "getVirtualNodeHeight"), D7 = /* @__PURE__ */ u(function(e, t, r) {
  e.append("path").attr("id", "node-" + t.id).attr("class", "node-bkg node-" + t.type).attr(
    "d",
    `M0 ${t.height - 5} v${-t.height + 2 * 5} q0,-5 5,-5 h${t.width - 2 * 5} q5,0 5,5 v${t.height - 5} H0 Z`
  ), e.append("line").attr("class", "node-line-" + r).attr("x1", 0).attr("y1", t.height).attr("x2", t.width).attr("y2", t.height);
}, "defaultBkg"), Ui = {
  drawRect: jo,
  drawCircle: S7,
  drawSection: w7,
  drawText: ky,
  drawLabel: C7,
  drawTask: T7,
  drawBackgroundRect: _7,
  getTextObj: E7,
  getNoteRect: Fh,
  initGraphics: A7,
  drawNode: L7,
  getVirtualNodeHeight: B7
}, I7 = /* @__PURE__ */ u(function(e, t, r, i) {
  var C, E, w;
  const s = K(), a = ((C = s.timeline) == null ? void 0 : C.leftMargin) ?? 50;
  I.debug("timeline", i.db);
  const n = s.securityLevel;
  let o;
  n === "sandbox" && (o = yt("#i" + t));
  const l = (n === "sandbox" ? yt(o.nodes()[0].contentDocument.body) : yt("body")).select("#" + t);
  l.append("g");
  const d = i.db.getTasks(), p = i.db.getCommonDb().getDiagramTitle();
  I.debug("task", d), Ui.initGraphics(l);
  const g = i.db.getSections();
  I.debug("sections", g);
  let f = 0, y = 0, m = 0, x = 0, b = 50 + a, v = 50;
  x = 50;
  let _ = 0, A = !0;
  g.forEach(function(W) {
    const N = {
      number: _,
      descr: W,
      section: _,
      width: 150,
      padding: 20,
      maxHeight: f
    }, B = Ui.getVirtualNodeHeight(l, N, s);
    I.debug("sectionHeight before draw", B), f = Math.max(f, B + 20);
  });
  let S = 0, k = 0;
  I.debug("tasks.length", d.length);
  for (const [W, N] of d.entries()) {
    const B = {
      number: W,
      descr: N,
      section: N.section,
      width: 150,
      padding: 20,
      maxHeight: y
    }, R = Ui.getVirtualNodeHeight(l, B, s);
    I.debug("taskHeight before draw", R), y = Math.max(y, R + 20), S = Math.max(S, N.events.length);
    let V = 0;
    for (const $ of N.events) {
      const D = {
        descr: $,
        section: N.section,
        number: N.section,
        width: 150,
        padding: 20,
        maxHeight: 50
      };
      V += Ui.getVirtualNodeHeight(l, D, s);
    }
    N.events.length > 0 && (V += (N.events.length - 1) * 10), k = Math.max(k, V);
  }
  I.debug("maxSectionHeight before draw", f), I.debug("maxTaskHeight before draw", y), g && g.length > 0 ? g.forEach((W) => {
    const N = d.filter(($) => $.section === W), B = {
      number: _,
      descr: W,
      section: _,
      width: 200 * Math.max(N.length, 1) - 50,
      padding: 20,
      maxHeight: f
    };
    I.debug("sectionNode", B);
    const R = l.append("g"), V = Ui.drawNode(R, B, _, s);
    I.debug("sectionNode output", V), R.attr("transform", `translate(${b}, ${x})`), v += f + 50, N.length > 0 && Gu(
      l,
      N,
      _,
      b,
      v,
      y,
      s,
      S,
      k,
      f,
      !1
    ), b += 200 * Math.max(N.length, 1), v = x, _++;
  }) : (A = !1, Gu(
    l,
    d,
    _,
    b,
    v,
    y,
    s,
    S,
    k,
    f,
    !0
  ));
  const L = l.node().getBBox();
  I.debug("bounds", L), p && l.append("text").text(p).attr("x", L.width / 2 - a).attr("font-size", "4ex").attr("font-weight", "bold").attr("y", 20), m = A ? f + y + 150 : y + 100, l.append("g").attr("class", "lineWrapper").append("line").attr("x1", a).attr("y1", m).attr("x2", L.width + 3 * a).attr("y2", m).attr("stroke-width", 4).attr("stroke", "black").attr("marker-end", "url(#arrowhead)"), dn(
    void 0,
    l,
    ((E = s.timeline) == null ? void 0 : E.padding) ?? 50,
    ((w = s.timeline) == null ? void 0 : w.useMaxWidth) ?? !1
  );
}, "draw"), Gu = /* @__PURE__ */ u(function(e, t, r, i, s, a, n, o, h, l, d) {
  var p;
  for (const g of t) {
    const f = {
      descr: g.task,
      section: r,
      number: r,
      width: 150,
      padding: 20,
      maxHeight: a
    };
    I.debug("taskNode", f);
    const y = e.append("g").attr("class", "taskWrapper"), x = Ui.drawNode(y, f, r, n).height;
    if (I.debug("taskHeight after draw", x), y.attr("transform", `translate(${i}, ${s})`), a = Math.max(a, x), g.events) {
      const b = e.append("g").attr("class", "lineWrapper");
      let v = a;
      s += 100, v = v + F7(e, g.events, r, i, s, n), s -= 100, b.append("line").attr("x1", i + 190 / 2).attr("y1", s + a).attr("x2", i + 190 / 2).attr("y2", s + a + 100 + h + 100).attr("stroke-width", 2).attr("stroke", "black").attr("marker-end", "url(#arrowhead)").attr("stroke-dasharray", "5,5");
    }
    i = i + 200, d && !((p = n.timeline) != null && p.disableMulticolor) && r++;
  }
  s = s - 10;
}, "drawTasks"), F7 = /* @__PURE__ */ u(function(e, t, r, i, s, a) {
  let n = 0;
  const o = s;
  s = s + 100;
  for (const h of t) {
    const l = {
      descr: h,
      section: r,
      number: r,
      width: 150,
      padding: 20,
      maxHeight: 50
    };
    I.debug("eventNode", l);
    const d = e.append("g").attr("class", "eventWrapper"), g = Ui.drawNode(d, l, r, a).height;
    n = n + g, d.attr("transform", `translate(${i}, ${s})`), s = s + 10 + g;
  }
  return s = o, n;
}, "drawEvents"), N7 = {
  setConf: /* @__PURE__ */ u(() => {
  }, "setConf"),
  draw: I7
}, R7 = /* @__PURE__ */ u((e) => {
  let t = "";
  for (let r = 0; r < e.THEME_COLOR_LIMIT; r++)
    e["lineColor" + r] = e["lineColor" + r] || e["cScaleInv" + r], Ni(e["lineColor" + r]) ? e["lineColor" + r] = Ft(e["lineColor" + r], 20) : e["lineColor" + r] = zt(e["lineColor" + r], 20);
  for (let r = 0; r < e.THEME_COLOR_LIMIT; r++) {
    const i = "" + (17 - 3 * r);
    t += `
    .section-${r - 1} rect, .section-${r - 1} path, .section-${r - 1} circle, .section-${r - 1} path  {
      fill: ${e["cScale" + r]};
    }
    .section-${r - 1} text {
     fill: ${e["cScaleLabel" + r]};
    }
    .node-icon-${r - 1} {
      font-size: 40px;
      color: ${e["cScaleLabel" + r]};
    }
    .section-edge-${r - 1}{
      stroke: ${e["cScale" + r]};
    }
    .edge-depth-${r - 1}{
      stroke-width: ${i};
    }
    .section-${r - 1} line {
      stroke: ${e["cScaleInv" + r]} ;
      stroke-width: 3;
    }

    .lineWrapper line{
      stroke: ${e["cScaleLabel" + r]} ;
    }

    .disabled, .disabled circle, .disabled text {
      fill: lightgray;
    }
    .disabled text {
      fill: #efefef;
    }
    `;
  }
  return t;
}, "genSections"), M7 = /* @__PURE__ */ u((e) => `
  .edge {
    stroke-width: 3;
  }
  ${R7(e)}
  .section-root rect, .section-root path, .section-root circle  {
    fill: ${e.git0};
  }
  .section-root text {
    fill: ${e.gitBranchLabel0};
  }
  .icon-container {
    height:100%;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  .edge {
    fill: none;
  }
  .eventWrapper  {
   filter: brightness(120%);
  }
`, "getStyles"), O7 = M7, P7 = {
  db: hy,
  renderer: N7,
  parser: x7,
  styles: O7
};
const $7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: P7
}, Symbol.toStringTag, { value: "Module" }));
var pc = function() {
  var e = /* @__PURE__ */ u(function(A, S, k, L) {
    for (k = k || {}, L = A.length; L--; k[A[L]] = S) ;
    return k;
  }, "o"), t = [1, 4], r = [1, 13], i = [1, 12], s = [1, 15], a = [1, 16], n = [1, 20], o = [1, 19], h = [6, 7, 8], l = [1, 26], d = [1, 24], p = [1, 25], g = [6, 7, 11], f = [1, 6, 13, 15, 16, 19, 22], y = [1, 33], m = [1, 34], x = [1, 6, 7, 11, 13, 15, 16, 19, 22], b = {
    trace: /* @__PURE__ */ u(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, start: 3, mindMap: 4, spaceLines: 5, SPACELINE: 6, NL: 7, MINDMAP: 8, document: 9, stop: 10, EOF: 11, statement: 12, SPACELIST: 13, node: 14, ICON: 15, CLASS: 16, nodeWithId: 17, nodeWithoutId: 18, NODE_DSTART: 19, NODE_DESCR: 20, NODE_DEND: 21, NODE_ID: 22, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 6: "SPACELINE", 7: "NL", 8: "MINDMAP", 11: "EOF", 13: "SPACELIST", 15: "ICON", 16: "CLASS", 19: "NODE_DSTART", 20: "NODE_DESCR", 21: "NODE_DEND", 22: "NODE_ID" },
    productions_: [0, [3, 1], [3, 2], [5, 1], [5, 2], [5, 2], [4, 2], [4, 3], [10, 1], [10, 1], [10, 1], [10, 2], [10, 2], [9, 3], [9, 2], [12, 2], [12, 2], [12, 2], [12, 1], [12, 1], [12, 1], [12, 1], [12, 1], [14, 1], [14, 1], [18, 3], [17, 1], [17, 4]],
    performAction: /* @__PURE__ */ u(function(S, k, L, T, C, E, w) {
      var W = E.length - 1;
      switch (C) {
        case 6:
        case 7:
          return T;
        case 8:
          T.getLogger().trace("Stop NL ");
          break;
        case 9:
          T.getLogger().trace("Stop EOF ");
          break;
        case 11:
          T.getLogger().trace("Stop NL2 ");
          break;
        case 12:
          T.getLogger().trace("Stop EOF2 ");
          break;
        case 15:
          T.getLogger().info("Node: ", E[W].id), T.addNode(E[W - 1].length, E[W].id, E[W].descr, E[W].type);
          break;
        case 16:
          T.getLogger().trace("Icon: ", E[W]), T.decorateNode({ icon: E[W] });
          break;
        case 17:
        case 21:
          T.decorateNode({ class: E[W] });
          break;
        case 18:
          T.getLogger().trace("SPACELIST");
          break;
        case 19:
          T.getLogger().trace("Node: ", E[W].id), T.addNode(0, E[W].id, E[W].descr, E[W].type);
          break;
        case 20:
          T.decorateNode({ icon: E[W] });
          break;
        case 25:
          T.getLogger().trace("node found ..", E[W - 2]), this.$ = { id: E[W - 1], descr: E[W - 1], type: T.getType(E[W - 2], E[W]) };
          break;
        case 26:
          this.$ = { id: E[W], descr: E[W], type: T.nodeType.DEFAULT };
          break;
        case 27:
          T.getLogger().trace("node found ..", E[W - 3]), this.$ = { id: E[W - 3], descr: E[W - 1], type: T.getType(E[W - 2], E[W]) };
          break;
      }
    }, "anonymous"),
    table: [{ 3: 1, 4: 2, 5: 3, 6: [1, 5], 8: t }, { 1: [3] }, { 1: [2, 1] }, { 4: 6, 6: [1, 7], 7: [1, 8], 8: t }, { 6: r, 7: [1, 10], 9: 9, 12: 11, 13: i, 14: 14, 15: s, 16: a, 17: 17, 18: 18, 19: n, 22: o }, e(h, [2, 3]), { 1: [2, 2] }, e(h, [2, 4]), e(h, [2, 5]), { 1: [2, 6], 6: r, 12: 21, 13: i, 14: 14, 15: s, 16: a, 17: 17, 18: 18, 19: n, 22: o }, { 6: r, 9: 22, 12: 11, 13: i, 14: 14, 15: s, 16: a, 17: 17, 18: 18, 19: n, 22: o }, { 6: l, 7: d, 10: 23, 11: p }, e(g, [2, 22], { 17: 17, 18: 18, 14: 27, 15: [1, 28], 16: [1, 29], 19: n, 22: o }), e(g, [2, 18]), e(g, [2, 19]), e(g, [2, 20]), e(g, [2, 21]), e(g, [2, 23]), e(g, [2, 24]), e(g, [2, 26], { 19: [1, 30] }), { 20: [1, 31] }, { 6: l, 7: d, 10: 32, 11: p }, { 1: [2, 7], 6: r, 12: 21, 13: i, 14: 14, 15: s, 16: a, 17: 17, 18: 18, 19: n, 22: o }, e(f, [2, 14], { 7: y, 11: m }), e(x, [2, 8]), e(x, [2, 9]), e(x, [2, 10]), e(g, [2, 15]), e(g, [2, 16]), e(g, [2, 17]), { 20: [1, 35] }, { 21: [1, 36] }, e(f, [2, 13], { 7: y, 11: m }), e(x, [2, 11]), e(x, [2, 12]), { 21: [1, 37] }, e(g, [2, 25]), e(g, [2, 27])],
    defaultActions: { 2: [2, 1], 6: [2, 2] },
    parseError: /* @__PURE__ */ u(function(S, k) {
      if (k.recoverable)
        this.trace(S);
      else {
        var L = new Error(S);
        throw L.hash = k, L;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ u(function(S) {
      var k = this, L = [0], T = [], C = [null], E = [], w = this.table, W = "", N = 0, B = 0, R = 2, V = 1, $ = E.slice.call(arguments, 1), D = Object.create(this.lexer), O = { yy: {} };
      for (var Y in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, Y) && (O.yy[Y] = this.yy[Y]);
      D.setInput(S, O.yy), O.yy.lexer = D, O.yy.parser = this, typeof D.yylloc > "u" && (D.yylloc = {});
      var M = D.yylloc;
      E.push(M);
      var G = D.options && D.options.ranges;
      typeof O.yy.parseError == "function" ? this.parseError = O.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function rt(et) {
        L.length = L.length - 2 * et, C.length = C.length - et, E.length = E.length - et;
      }
      u(rt, "popStack");
      function ht() {
        var et;
        return et = T.pop() || D.lex() || V, typeof et != "number" && (et instanceof Array && (T = et, et = T.pop()), et = k.symbols_[et] || et), et;
      }
      u(ht, "lex");
      for (var Z, ot, it, bt, xt = {}, Ct, at, lt, Q; ; ) {
        if (ot = L[L.length - 1], this.defaultActions[ot] ? it = this.defaultActions[ot] : ((Z === null || typeof Z > "u") && (Z = ht()), it = w[ot] && w[ot][Z]), typeof it > "u" || !it.length || !it[0]) {
          var U = "";
          Q = [];
          for (Ct in w[ot])
            this.terminals_[Ct] && Ct > R && Q.push("'" + this.terminals_[Ct] + "'");
          D.showPosition ? U = "Parse error on line " + (N + 1) + `:
` + D.showPosition() + `
Expecting ` + Q.join(", ") + ", got '" + (this.terminals_[Z] || Z) + "'" : U = "Parse error on line " + (N + 1) + ": Unexpected " + (Z == V ? "end of input" : "'" + (this.terminals_[Z] || Z) + "'"), this.parseError(U, {
            text: D.match,
            token: this.terminals_[Z] || Z,
            line: D.yylineno,
            loc: M,
            expected: Q
          });
        }
        if (it[0] instanceof Array && it.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + ot + ", token: " + Z);
        switch (it[0]) {
          case 1:
            L.push(Z), C.push(D.yytext), E.push(D.yylloc), L.push(it[1]), Z = null, B = D.yyleng, W = D.yytext, N = D.yylineno, M = D.yylloc;
            break;
          case 2:
            if (at = this.productions_[it[1]][1], xt.$ = C[C.length - at], xt._$ = {
              first_line: E[E.length - (at || 1)].first_line,
              last_line: E[E.length - 1].last_line,
              first_column: E[E.length - (at || 1)].first_column,
              last_column: E[E.length - 1].last_column
            }, G && (xt._$.range = [
              E[E.length - (at || 1)].range[0],
              E[E.length - 1].range[1]
            ]), bt = this.performAction.apply(xt, [
              W,
              B,
              N,
              O.yy,
              it[1],
              C,
              E
            ].concat($)), typeof bt < "u")
              return bt;
            at && (L = L.slice(0, -1 * at * 2), C = C.slice(0, -1 * at), E = E.slice(0, -1 * at)), L.push(this.productions_[it[1]][0]), C.push(xt.$), E.push(xt._$), lt = w[L[L.length - 2]][L[L.length - 1]], L.push(lt);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, v = /* @__PURE__ */ function() {
    var A = {
      EOF: 1,
      parseError: /* @__PURE__ */ u(function(k, L) {
        if (this.yy.parser)
          this.yy.parser.parseError(k, L);
        else
          throw new Error(k);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ u(function(S, k) {
        return this.yy = k || this.yy || {}, this._input = S, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ u(function() {
        var S = this._input[0];
        this.yytext += S, this.yyleng++, this.offset++, this.match += S, this.matched += S;
        var k = S.match(/(?:\r\n?|\n).*/g);
        return k ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), S;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ u(function(S) {
        var k = S.length, L = S.split(/(?:\r\n?|\n)/g);
        this._input = S + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - k), this.offset -= k;
        var T = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), L.length - 1 && (this.yylineno -= L.length - 1);
        var C = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: L ? (L.length === T.length ? this.yylloc.first_column : 0) + T[T.length - L.length].length - L[0].length : this.yylloc.first_column - k
        }, this.options.ranges && (this.yylloc.range = [C[0], C[0] + this.yyleng - k]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ u(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ u(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ u(function(S) {
        this.unput(this.match.slice(S));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ u(function() {
        var S = this.matched.substr(0, this.matched.length - this.match.length);
        return (S.length > 20 ? "..." : "") + S.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ u(function() {
        var S = this.match;
        return S.length < 20 && (S += this._input.substr(0, 20 - S.length)), (S.substr(0, 20) + (S.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ u(function() {
        var S = this.pastInput(), k = new Array(S.length + 1).join("-");
        return S + this.upcomingInput() + `
` + k + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ u(function(S, k) {
        var L, T, C;
        if (this.options.backtrack_lexer && (C = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (C.yylloc.range = this.yylloc.range.slice(0))), T = S[0].match(/(?:\r\n?|\n).*/g), T && (this.yylineno += T.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: T ? T[T.length - 1].length - T[T.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + S[0].length
        }, this.yytext += S[0], this.match += S[0], this.matches = S, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(S[0].length), this.matched += S[0], L = this.performAction.call(this, this.yy, this, k, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), L)
          return L;
        if (this._backtrack) {
          for (var E in C)
            this[E] = C[E];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ u(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var S, k, L, T;
        this._more || (this.yytext = "", this.match = "");
        for (var C = this._currentRules(), E = 0; E < C.length; E++)
          if (L = this._input.match(this.rules[C[E]]), L && (!k || L[0].length > k[0].length)) {
            if (k = L, T = E, this.options.backtrack_lexer) {
              if (S = this.test_match(L, C[E]), S !== !1)
                return S;
              if (this._backtrack) {
                k = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return k ? (S = this.test_match(k, C[T]), S !== !1 ? S : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ u(function() {
        var k = this.next();
        return k || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ u(function(k) {
        this.conditionStack.push(k);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ u(function() {
        var k = this.conditionStack.length - 1;
        return k > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ u(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ u(function(k) {
        return k = this.conditionStack.length - 1 - Math.abs(k || 0), k >= 0 ? this.conditionStack[k] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ u(function(k) {
        this.begin(k);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ u(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: { "case-insensitive": !0 },
      performAction: /* @__PURE__ */ u(function(k, L, T, C) {
        switch (T) {
          case 0:
            return k.getLogger().trace("Found comment", L.yytext), 6;
          case 1:
            return 8;
          case 2:
            this.begin("CLASS");
            break;
          case 3:
            return this.popState(), 16;
          case 4:
            this.popState();
            break;
          case 5:
            k.getLogger().trace("Begin icon"), this.begin("ICON");
            break;
          case 6:
            return k.getLogger().trace("SPACELINE"), 6;
          case 7:
            return 7;
          case 8:
            return 15;
          case 9:
            k.getLogger().trace("end icon"), this.popState();
            break;
          case 10:
            return k.getLogger().trace("Exploding node"), this.begin("NODE"), 19;
          case 11:
            return k.getLogger().trace("Cloud"), this.begin("NODE"), 19;
          case 12:
            return k.getLogger().trace("Explosion Bang"), this.begin("NODE"), 19;
          case 13:
            return k.getLogger().trace("Cloud Bang"), this.begin("NODE"), 19;
          case 14:
            return this.begin("NODE"), 19;
          case 15:
            return this.begin("NODE"), 19;
          case 16:
            return this.begin("NODE"), 19;
          case 17:
            return this.begin("NODE"), 19;
          case 18:
            return 13;
          case 19:
            return 22;
          case 20:
            return 11;
          case 21:
            this.begin("NSTR2");
            break;
          case 22:
            return "NODE_DESCR";
          case 23:
            this.popState();
            break;
          case 24:
            k.getLogger().trace("Starting NSTR"), this.begin("NSTR");
            break;
          case 25:
            return k.getLogger().trace("description:", L.yytext), "NODE_DESCR";
          case 26:
            this.popState();
            break;
          case 27:
            return this.popState(), k.getLogger().trace("node end ))"), "NODE_DEND";
          case 28:
            return this.popState(), k.getLogger().trace("node end )"), "NODE_DEND";
          case 29:
            return this.popState(), k.getLogger().trace("node end ...", L.yytext), "NODE_DEND";
          case 30:
            return this.popState(), k.getLogger().trace("node end (("), "NODE_DEND";
          case 31:
            return this.popState(), k.getLogger().trace("node end (-"), "NODE_DEND";
          case 32:
            return this.popState(), k.getLogger().trace("node end (-"), "NODE_DEND";
          case 33:
            return this.popState(), k.getLogger().trace("node end (("), "NODE_DEND";
          case 34:
            return this.popState(), k.getLogger().trace("node end (("), "NODE_DEND";
          case 35:
            return k.getLogger().trace("Long description:", L.yytext), 20;
          case 36:
            return k.getLogger().trace("Long description:", L.yytext), 20;
        }
      }, "anonymous"),
      rules: [/^(?:\s*%%.*)/i, /^(?:mindmap\b)/i, /^(?::::)/i, /^(?:.+)/i, /^(?:\n)/i, /^(?:::icon\()/i, /^(?:[\s]+[\n])/i, /^(?:[\n]+)/i, /^(?:[^\)]+)/i, /^(?:\))/i, /^(?:-\))/i, /^(?:\(-)/i, /^(?:\)\))/i, /^(?:\))/i, /^(?:\(\()/i, /^(?:\{\{)/i, /^(?:\()/i, /^(?:\[)/i, /^(?:[\s]+)/i, /^(?:[^\(\[\n\)\{\}]+)/i, /^(?:$)/i, /^(?:["][`])/i, /^(?:[^`"]+)/i, /^(?:[`]["])/i, /^(?:["])/i, /^(?:[^"]+)/i, /^(?:["])/i, /^(?:[\)]\))/i, /^(?:[\)])/i, /^(?:[\]])/i, /^(?:\}\})/i, /^(?:\(-)/i, /^(?:-\))/i, /^(?:\(\()/i, /^(?:\()/i, /^(?:[^\)\]\(\}]+)/i, /^(?:.+(?!\(\())/i],
      conditions: { CLASS: { rules: [3, 4], inclusive: !1 }, ICON: { rules: [8, 9], inclusive: !1 }, NSTR2: { rules: [22, 23], inclusive: !1 }, NSTR: { rules: [25, 26], inclusive: !1 }, NODE: { rules: [21, 24, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36], inclusive: !1 }, INITIAL: { rules: [0, 1, 2, 5, 6, 7, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20], inclusive: !0 } }
    };
    return A;
  }();
  b.lexer = v;
  function _() {
    this.yy = {};
  }
  return u(_, "Parser"), _.prototype = b, b.Parser = _, new _();
}();
pc.parser = pc;
var V7 = pc, ci = {
  DEFAULT: 0,
  NO_BORDER: 0,
  ROUNDED_RECT: 1,
  RECT: 2,
  CIRCLE: 3,
  CLOUD: 4,
  BANG: 5,
  HEXAGON: 6
}, aa, z7 = (aa = class {
  constructor() {
    this.nodes = [], this.count = 0, this.elements = {}, this.getLogger = this.getLogger.bind(this), this.nodeType = ci, this.clear(), this.getType = this.getType.bind(this), this.getElementById = this.getElementById.bind(this), this.getParent = this.getParent.bind(this), this.getMindmap = this.getMindmap.bind(this), this.addNode = this.addNode.bind(this), this.decorateNode = this.decorateNode.bind(this);
  }
  clear() {
    this.nodes = [], this.count = 0, this.elements = {}, this.baseLevel = void 0;
  }
  getParent(t) {
    for (let r = this.nodes.length - 1; r >= 0; r--)
      if (this.nodes[r].level < t)
        return this.nodes[r];
    return null;
  }
  getMindmap() {
    return this.nodes.length > 0 ? this.nodes[0] : null;
  }
  addNode(t, r, i, s) {
    var d, p;
    I.info("addNode", t, r, i, s);
    let a = !1;
    this.nodes.length === 0 ? (this.baseLevel = t, t = 0, a = !0) : this.baseLevel !== void 0 && (t = t - this.baseLevel, a = !1);
    const n = K();
    let o = ((d = n.mindmap) == null ? void 0 : d.padding) ?? de.mindmap.padding;
    switch (s) {
      case this.nodeType.ROUNDED_RECT:
      case this.nodeType.RECT:
      case this.nodeType.HEXAGON:
        o *= 2;
        break;
    }
    const h = {
      id: this.count++,
      nodeId: ge(r, n),
      level: t,
      descr: ge(i, n),
      type: s,
      children: [],
      width: ((p = n.mindmap) == null ? void 0 : p.maxNodeWidth) ?? de.mindmap.maxNodeWidth,
      padding: o,
      isRoot: a
    }, l = this.getParent(t);
    if (l)
      l.children.push(h), this.nodes.push(h);
    else if (a)
      this.nodes.push(h);
    else
      throw new Error(
        `There can be only one root. No parent could be found for ("${h.descr}")`
      );
  }
  getType(t, r) {
    switch (I.debug("In get type", t, r), t) {
      case "[":
        return this.nodeType.RECT;
      case "(":
        return r === ")" ? this.nodeType.ROUNDED_RECT : this.nodeType.CLOUD;
      case "((":
        return this.nodeType.CIRCLE;
      case ")":
        return this.nodeType.CLOUD;
      case "))":
        return this.nodeType.BANG;
      case "{{":
        return this.nodeType.HEXAGON;
      default:
        return this.nodeType.DEFAULT;
    }
  }
  setElementForId(t, r) {
    this.elements[t] = r;
  }
  getElementById(t) {
    return this.elements[t];
  }
  decorateNode(t) {
    if (!t)
      return;
    const r = K(), i = this.nodes[this.nodes.length - 1];
    t.icon && (i.icon = ge(t.icon, r)), t.class && (i.class = ge(t.class, r));
  }
  type2Str(t) {
    switch (t) {
      case this.nodeType.DEFAULT:
        return "no-border";
      case this.nodeType.RECT:
        return "rect";
      case this.nodeType.ROUNDED_RECT:
        return "rounded-rect";
      case this.nodeType.CIRCLE:
        return "circle";
      case this.nodeType.CLOUD:
        return "cloud";
      case this.nodeType.BANG:
        return "bang";
      case this.nodeType.HEXAGON:
        return "hexgon";
      default:
        return "no-border";
    }
  }
  /**
   * Assign section numbers to nodes based on their position relative to root
   * @param node - The mindmap node to process
   * @param sectionNumber - The section number to assign (undefined for root)
   */
  assignSections(t, r) {
    if (t.level === 0 ? t.section = void 0 : t.section = r, t.children)
      for (const [i, s] of t.children.entries()) {
        const a = t.level === 0 ? i : r;
        this.assignSections(s, a);
      }
  }
  /**
   * Convert mindmap tree structure to flat array of nodes
   * @param node - The mindmap node to process
   * @param processedNodes - Array to collect processed nodes
   */
  flattenNodes(t, r) {
    const i = ["mindmap-node"];
    t.isRoot === !0 ? i.push("section-root", "section--1") : t.section !== void 0 && i.push(`section-${t.section}`), t.class && i.push(t.class);
    const s = i.join(" "), a = /* @__PURE__ */ u((o) => {
      switch (o) {
        case ci.CIRCLE:
          return "mindmapCircle";
        case ci.RECT:
          return "rect";
        case ci.ROUNDED_RECT:
          return "rounded";
        case ci.CLOUD:
          return "cloud";
        case ci.BANG:
          return "bang";
        case ci.HEXAGON:
          return "hexagon";
        case ci.DEFAULT:
          return "defaultMindmapNode";
        case ci.NO_BORDER:
        default:
          return "rect";
      }
    }, "getShapeFromType"), n = {
      id: t.id.toString(),
      domId: "node_" + t.id.toString(),
      label: t.descr,
      isGroup: !1,
      shape: a(t.type),
      width: t.width,
      height: t.height ?? 0,
      padding: t.padding,
      cssClasses: s,
      cssStyles: [],
      look: "default",
      icon: t.icon,
      x: t.x,
      y: t.y,
      // Mindmap-specific properties
      level: t.level,
      nodeId: t.nodeId,
      type: t.type,
      section: t.section
    };
    if (r.push(n), t.children)
      for (const o of t.children)
        this.flattenNodes(o, r);
  }
  /**
   * Generate edges from parent-child relationships in mindmap tree
   * @param node - The mindmap node to process
   * @param edges - Array to collect edges
   */
  generateEdges(t, r) {
    if (t.children)
      for (const i of t.children) {
        let s = "edge";
        i.section !== void 0 && (s += ` section-edge-${i.section}`);
        const a = t.level + 1;
        s += ` edge-depth-${a}`;
        const n = {
          id: `edge_${t.id}_${i.id}`,
          start: t.id.toString(),
          end: i.id.toString(),
          type: "normal",
          curve: "basis",
          thickness: "normal",
          look: "default",
          classes: s,
          // Store mindmap-specific data
          depth: t.level,
          section: i.section
        };
        r.push(n), this.generateEdges(i, r);
      }
  }
  /**
   * Get structured data for layout algorithms
   * Following the pattern established by ER diagrams
   * @returns Structured data containing nodes, edges, and config
   */
  getData() {
    const t = this.getMindmap(), r = K(), s = Ax().layout !== void 0, a = r;
    if (s || (a.layout = "cose-bilkent"), !t)
      return {
        nodes: [],
        edges: [],
        config: a
      };
    I.debug("getData: mindmapRoot", t, r), this.assignSections(t);
    const n = [], o = [];
    this.flattenNodes(t, n), this.generateEdges(t, o), I.debug(
      `getData: processed ${n.length} nodes and ${o.length} edges`
    );
    const h = /* @__PURE__ */ new Map();
    for (const l of n)
      h.set(l.id, {
        shape: l.shape,
        width: l.width,
        height: l.height,
        padding: l.padding
      });
    return {
      nodes: n,
      edges: o,
      config: a,
      // Store the root node for mindmap-specific layout algorithms
      rootNode: t,
      // Properties required by dagre layout algorithm
      markers: ["point"],
      // Mindmaps don't use markers
      direction: "TB",
      // Top-to-bottom direction for mindmaps
      nodeSpacing: 50,
      // Default spacing between nodes
      rankSpacing: 50,
      // Default spacing between ranks
      // Add shapes for ELK compatibility
      shapes: Object.fromEntries(h),
      // Additional properties that layout algorithms might expect
      type: "mindmap",
      diagramId: "mindmap-" + Qm()
    };
  }
  // Expose logger to grammar
  getLogger() {
    return I;
  }
}, u(aa, "MindmapDB"), aa), W7 = /* @__PURE__ */ u(async (e, t, r, i) => {
  var h, l;
  I.debug(`Rendering mindmap diagram
` + e);
  const s = i.db, a = s.getData(), n = Ta(t, a.config.securityLevel);
  a.type = i.type, a.layoutAlgorithm = fn(a.config.layout, {
    fallback: "cose-bilkent"
  }), a.diagramId = t, s.getMindmap() && (a.nodes.forEach((d) => {
    d.shape === "rounded" ? (d.radius = 15, d.taper = 15, d.stroke = "none", d.width = 0, d.padding = 15) : d.shape === "circle" ? d.padding = 10 : d.shape === "rect" && (d.width = 0, d.padding = 10);
  }), await wa(a, n), cs(
    n,
    ((h = a.config.mindmap) == null ? void 0 : h.padding) ?? de.mindmap.padding,
    "mindmapDiagram",
    ((l = a.config.mindmap) == null ? void 0 : l.useMaxWidth) ?? de.mindmap.useMaxWidth
  ));
}, "draw"), q7 = {
  draw: W7
}, Y7 = /* @__PURE__ */ u((e) => {
  let t = "";
  for (let r = 0; r < e.THEME_COLOR_LIMIT; r++)
    e["lineColor" + r] = e["lineColor" + r] || e["cScaleInv" + r], Ni(e["lineColor" + r]) ? e["lineColor" + r] = Ft(e["lineColor" + r], 20) : e["lineColor" + r] = zt(e["lineColor" + r], 20);
  for (let r = 0; r < e.THEME_COLOR_LIMIT; r++) {
    const i = "" + (17 - 3 * r);
    t += `
    .section-${r - 1} rect, .section-${r - 1} path, .section-${r - 1} circle, .section-${r - 1} polygon, .section-${r - 1} path  {
      fill: ${e["cScale" + r]};
    }
    .section-${r - 1} text {
     fill: ${e["cScaleLabel" + r]};
    }
    .node-icon-${r - 1} {
      font-size: 40px;
      color: ${e["cScaleLabel" + r]};
    }
    .section-edge-${r - 1}{
      stroke: ${e["cScale" + r]};
    }
    .edge-depth-${r - 1}{
      stroke-width: ${i};
    }
    .section-${r - 1} line {
      stroke: ${e["cScaleInv" + r]} ;
      stroke-width: 3;
    }

    .disabled, .disabled circle, .disabled text {
      fill: lightgray;
    }
    .disabled text {
      fill: #efefef;
    }
    `;
  }
  return t;
}, "genSections"), H7 = /* @__PURE__ */ u((e) => `
  .edge {
    stroke-width: 3;
  }
  ${Y7(e)}
  .section-root rect, .section-root path, .section-root circle, .section-root polygon  {
    fill: ${e.git0};
  }
  .section-root text {
    fill: ${e.gitBranchLabel0};
  }
  .section-root span {
    color: ${e.gitBranchLabel0};
  }
  .section-2 span {
    color: ${e.gitBranchLabel0};
  }
  .icon-container {
    height:100%;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  .edge {
    fill: none;
  }
  .mindmap-node-label {
    dy: 1em;
    alignment-baseline: middle;
    text-anchor: middle;
    dominant-baseline: middle;
    text-align: center;
  }
`, "getStyles"), U7 = H7, j7 = {
  get db() {
    return new z7();
  },
  renderer: q7,
  parser: V7,
  styles: U7
};
const G7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: j7
}, Symbol.toStringTag, { value: "Module" }));
var gc = function() {
  var e = /* @__PURE__ */ u(function(L, T, C, E) {
    for (C = C || {}, E = L.length; E--; C[L[E]] = T) ;
    return C;
  }, "o"), t = [1, 4], r = [1, 13], i = [1, 12], s = [1, 15], a = [1, 16], n = [1, 20], o = [1, 19], h = [6, 7, 8], l = [1, 26], d = [1, 24], p = [1, 25], g = [6, 7, 11], f = [1, 31], y = [6, 7, 11, 24], m = [1, 6, 13, 16, 17, 20, 23], x = [1, 35], b = [1, 36], v = [1, 6, 7, 11, 13, 16, 17, 20, 23], _ = [1, 38], A = {
    trace: /* @__PURE__ */ u(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, start: 3, mindMap: 4, spaceLines: 5, SPACELINE: 6, NL: 7, KANBAN: 8, document: 9, stop: 10, EOF: 11, statement: 12, SPACELIST: 13, node: 14, shapeData: 15, ICON: 16, CLASS: 17, nodeWithId: 18, nodeWithoutId: 19, NODE_DSTART: 20, NODE_DESCR: 21, NODE_DEND: 22, NODE_ID: 23, SHAPE_DATA: 24, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 6: "SPACELINE", 7: "NL", 8: "KANBAN", 11: "EOF", 13: "SPACELIST", 16: "ICON", 17: "CLASS", 20: "NODE_DSTART", 21: "NODE_DESCR", 22: "NODE_DEND", 23: "NODE_ID", 24: "SHAPE_DATA" },
    productions_: [0, [3, 1], [3, 2], [5, 1], [5, 2], [5, 2], [4, 2], [4, 3], [10, 1], [10, 1], [10, 1], [10, 2], [10, 2], [9, 3], [9, 2], [12, 3], [12, 2], [12, 2], [12, 2], [12, 1], [12, 2], [12, 1], [12, 1], [12, 1], [12, 1], [14, 1], [14, 1], [19, 3], [18, 1], [18, 4], [15, 2], [15, 1]],
    performAction: /* @__PURE__ */ u(function(T, C, E, w, W, N, B) {
      var R = N.length - 1;
      switch (W) {
        case 6:
        case 7:
          return w;
        case 8:
          w.getLogger().trace("Stop NL ");
          break;
        case 9:
          w.getLogger().trace("Stop EOF ");
          break;
        case 11:
          w.getLogger().trace("Stop NL2 ");
          break;
        case 12:
          w.getLogger().trace("Stop EOF2 ");
          break;
        case 15:
          w.getLogger().info("Node: ", N[R - 1].id), w.addNode(N[R - 2].length, N[R - 1].id, N[R - 1].descr, N[R - 1].type, N[R]);
          break;
        case 16:
          w.getLogger().info("Node: ", N[R].id), w.addNode(N[R - 1].length, N[R].id, N[R].descr, N[R].type);
          break;
        case 17:
          w.getLogger().trace("Icon: ", N[R]), w.decorateNode({ icon: N[R] });
          break;
        case 18:
        case 23:
          w.decorateNode({ class: N[R] });
          break;
        case 19:
          w.getLogger().trace("SPACELIST");
          break;
        case 20:
          w.getLogger().trace("Node: ", N[R - 1].id), w.addNode(0, N[R - 1].id, N[R - 1].descr, N[R - 1].type, N[R]);
          break;
        case 21:
          w.getLogger().trace("Node: ", N[R].id), w.addNode(0, N[R].id, N[R].descr, N[R].type);
          break;
        case 22:
          w.decorateNode({ icon: N[R] });
          break;
        case 27:
          w.getLogger().trace("node found ..", N[R - 2]), this.$ = { id: N[R - 1], descr: N[R - 1], type: w.getType(N[R - 2], N[R]) };
          break;
        case 28:
          this.$ = { id: N[R], descr: N[R], type: 0 };
          break;
        case 29:
          w.getLogger().trace("node found ..", N[R - 3]), this.$ = { id: N[R - 3], descr: N[R - 1], type: w.getType(N[R - 2], N[R]) };
          break;
        case 30:
          this.$ = N[R - 1] + N[R];
          break;
        case 31:
          this.$ = N[R];
          break;
      }
    }, "anonymous"),
    table: [{ 3: 1, 4: 2, 5: 3, 6: [1, 5], 8: t }, { 1: [3] }, { 1: [2, 1] }, { 4: 6, 6: [1, 7], 7: [1, 8], 8: t }, { 6: r, 7: [1, 10], 9: 9, 12: 11, 13: i, 14: 14, 16: s, 17: a, 18: 17, 19: 18, 20: n, 23: o }, e(h, [2, 3]), { 1: [2, 2] }, e(h, [2, 4]), e(h, [2, 5]), { 1: [2, 6], 6: r, 12: 21, 13: i, 14: 14, 16: s, 17: a, 18: 17, 19: 18, 20: n, 23: o }, { 6: r, 9: 22, 12: 11, 13: i, 14: 14, 16: s, 17: a, 18: 17, 19: 18, 20: n, 23: o }, { 6: l, 7: d, 10: 23, 11: p }, e(g, [2, 24], { 18: 17, 19: 18, 14: 27, 16: [1, 28], 17: [1, 29], 20: n, 23: o }), e(g, [2, 19]), e(g, [2, 21], { 15: 30, 24: f }), e(g, [2, 22]), e(g, [2, 23]), e(y, [2, 25]), e(y, [2, 26]), e(y, [2, 28], { 20: [1, 32] }), { 21: [1, 33] }, { 6: l, 7: d, 10: 34, 11: p }, { 1: [2, 7], 6: r, 12: 21, 13: i, 14: 14, 16: s, 17: a, 18: 17, 19: 18, 20: n, 23: o }, e(m, [2, 14], { 7: x, 11: b }), e(v, [2, 8]), e(v, [2, 9]), e(v, [2, 10]), e(g, [2, 16], { 15: 37, 24: f }), e(g, [2, 17]), e(g, [2, 18]), e(g, [2, 20], { 24: _ }), e(y, [2, 31]), { 21: [1, 39] }, { 22: [1, 40] }, e(m, [2, 13], { 7: x, 11: b }), e(v, [2, 11]), e(v, [2, 12]), e(g, [2, 15], { 24: _ }), e(y, [2, 30]), { 22: [1, 41] }, e(y, [2, 27]), e(y, [2, 29])],
    defaultActions: { 2: [2, 1], 6: [2, 2] },
    parseError: /* @__PURE__ */ u(function(T, C) {
      if (C.recoverable)
        this.trace(T);
      else {
        var E = new Error(T);
        throw E.hash = C, E;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ u(function(T) {
      var C = this, E = [0], w = [], W = [null], N = [], B = this.table, R = "", V = 0, $ = 0, D = 2, O = 1, Y = N.slice.call(arguments, 1), M = Object.create(this.lexer), G = { yy: {} };
      for (var rt in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, rt) && (G.yy[rt] = this.yy[rt]);
      M.setInput(T, G.yy), G.yy.lexer = M, G.yy.parser = this, typeof M.yylloc > "u" && (M.yylloc = {});
      var ht = M.yylloc;
      N.push(ht);
      var Z = M.options && M.options.ranges;
      typeof G.yy.parseError == "function" ? this.parseError = G.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function ot(F) {
        E.length = E.length - 2 * F, W.length = W.length - F, N.length = N.length - F;
      }
      u(ot, "popStack");
      function it() {
        var F;
        return F = w.pop() || M.lex() || O, typeof F != "number" && (F instanceof Array && (w = F, F = w.pop()), F = C.symbols_[F] || F), F;
      }
      u(it, "lex");
      for (var bt, xt, Ct, at, lt = {}, Q, U, et, z; ; ) {
        if (xt = E[E.length - 1], this.defaultActions[xt] ? Ct = this.defaultActions[xt] : ((bt === null || typeof bt > "u") && (bt = it()), Ct = B[xt] && B[xt][bt]), typeof Ct > "u" || !Ct.length || !Ct[0]) {
          var Tt = "";
          z = [];
          for (Q in B[xt])
            this.terminals_[Q] && Q > D && z.push("'" + this.terminals_[Q] + "'");
          M.showPosition ? Tt = "Parse error on line " + (V + 1) + `:
` + M.showPosition() + `
Expecting ` + z.join(", ") + ", got '" + (this.terminals_[bt] || bt) + "'" : Tt = "Parse error on line " + (V + 1) + ": Unexpected " + (bt == O ? "end of input" : "'" + (this.terminals_[bt] || bt) + "'"), this.parseError(Tt, {
            text: M.match,
            token: this.terminals_[bt] || bt,
            line: M.yylineno,
            loc: ht,
            expected: z
          });
        }
        if (Ct[0] instanceof Array && Ct.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + xt + ", token: " + bt);
        switch (Ct[0]) {
          case 1:
            E.push(bt), W.push(M.yytext), N.push(M.yylloc), E.push(Ct[1]), bt = null, $ = M.yyleng, R = M.yytext, V = M.yylineno, ht = M.yylloc;
            break;
          case 2:
            if (U = this.productions_[Ct[1]][1], lt.$ = W[W.length - U], lt._$ = {
              first_line: N[N.length - (U || 1)].first_line,
              last_line: N[N.length - 1].last_line,
              first_column: N[N.length - (U || 1)].first_column,
              last_column: N[N.length - 1].last_column
            }, Z && (lt._$.range = [
              N[N.length - (U || 1)].range[0],
              N[N.length - 1].range[1]
            ]), at = this.performAction.apply(lt, [
              R,
              $,
              V,
              G.yy,
              Ct[1],
              W,
              N
            ].concat(Y)), typeof at < "u")
              return at;
            U && (E = E.slice(0, -1 * U * 2), W = W.slice(0, -1 * U), N = N.slice(0, -1 * U)), E.push(this.productions_[Ct[1]][0]), W.push(lt.$), N.push(lt._$), et = B[E[E.length - 2]][E[E.length - 1]], E.push(et);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, S = /* @__PURE__ */ function() {
    var L = {
      EOF: 1,
      parseError: /* @__PURE__ */ u(function(C, E) {
        if (this.yy.parser)
          this.yy.parser.parseError(C, E);
        else
          throw new Error(C);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ u(function(T, C) {
        return this.yy = C || this.yy || {}, this._input = T, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ u(function() {
        var T = this._input[0];
        this.yytext += T, this.yyleng++, this.offset++, this.match += T, this.matched += T;
        var C = T.match(/(?:\r\n?|\n).*/g);
        return C ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), T;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ u(function(T) {
        var C = T.length, E = T.split(/(?:\r\n?|\n)/g);
        this._input = T + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - C), this.offset -= C;
        var w = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), E.length - 1 && (this.yylineno -= E.length - 1);
        var W = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: E ? (E.length === w.length ? this.yylloc.first_column : 0) + w[w.length - E.length].length - E[0].length : this.yylloc.first_column - C
        }, this.options.ranges && (this.yylloc.range = [W[0], W[0] + this.yyleng - C]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ u(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ u(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ u(function(T) {
        this.unput(this.match.slice(T));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ u(function() {
        var T = this.matched.substr(0, this.matched.length - this.match.length);
        return (T.length > 20 ? "..." : "") + T.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ u(function() {
        var T = this.match;
        return T.length < 20 && (T += this._input.substr(0, 20 - T.length)), (T.substr(0, 20) + (T.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ u(function() {
        var T = this.pastInput(), C = new Array(T.length + 1).join("-");
        return T + this.upcomingInput() + `
` + C + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ u(function(T, C) {
        var E, w, W;
        if (this.options.backtrack_lexer && (W = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (W.yylloc.range = this.yylloc.range.slice(0))), w = T[0].match(/(?:\r\n?|\n).*/g), w && (this.yylineno += w.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: w ? w[w.length - 1].length - w[w.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + T[0].length
        }, this.yytext += T[0], this.match += T[0], this.matches = T, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(T[0].length), this.matched += T[0], E = this.performAction.call(this, this.yy, this, C, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), E)
          return E;
        if (this._backtrack) {
          for (var N in W)
            this[N] = W[N];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ u(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var T, C, E, w;
        this._more || (this.yytext = "", this.match = "");
        for (var W = this._currentRules(), N = 0; N < W.length; N++)
          if (E = this._input.match(this.rules[W[N]]), E && (!C || E[0].length > C[0].length)) {
            if (C = E, w = N, this.options.backtrack_lexer) {
              if (T = this.test_match(E, W[N]), T !== !1)
                return T;
              if (this._backtrack) {
                C = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return C ? (T = this.test_match(C, W[w]), T !== !1 ? T : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ u(function() {
        var C = this.next();
        return C || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ u(function(C) {
        this.conditionStack.push(C);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ u(function() {
        var C = this.conditionStack.length - 1;
        return C > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ u(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ u(function(C) {
        return C = this.conditionStack.length - 1 - Math.abs(C || 0), C >= 0 ? this.conditionStack[C] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ u(function(C) {
        this.begin(C);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ u(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: { "case-insensitive": !0 },
      performAction: /* @__PURE__ */ u(function(C, E, w, W) {
        switch (w) {
          case 0:
            return this.pushState("shapeData"), E.yytext = "", 24;
          case 1:
            return this.pushState("shapeDataStr"), 24;
          case 2:
            return this.popState(), 24;
          case 3:
            const N = /\n\s*/g;
            return E.yytext = E.yytext.replace(N, "<br/>"), 24;
          case 4:
            return 24;
          case 5:
            this.popState();
            break;
          case 6:
            return C.getLogger().trace("Found comment", E.yytext), 6;
          case 7:
            return 8;
          case 8:
            this.begin("CLASS");
            break;
          case 9:
            return this.popState(), 17;
          case 10:
            this.popState();
            break;
          case 11:
            C.getLogger().trace("Begin icon"), this.begin("ICON");
            break;
          case 12:
            return C.getLogger().trace("SPACELINE"), 6;
          case 13:
            return 7;
          case 14:
            return 16;
          case 15:
            C.getLogger().trace("end icon"), this.popState();
            break;
          case 16:
            return C.getLogger().trace("Exploding node"), this.begin("NODE"), 20;
          case 17:
            return C.getLogger().trace("Cloud"), this.begin("NODE"), 20;
          case 18:
            return C.getLogger().trace("Explosion Bang"), this.begin("NODE"), 20;
          case 19:
            return C.getLogger().trace("Cloud Bang"), this.begin("NODE"), 20;
          case 20:
            return this.begin("NODE"), 20;
          case 21:
            return this.begin("NODE"), 20;
          case 22:
            return this.begin("NODE"), 20;
          case 23:
            return this.begin("NODE"), 20;
          case 24:
            return 13;
          case 25:
            return 23;
          case 26:
            return 11;
          case 27:
            this.begin("NSTR2");
            break;
          case 28:
            return "NODE_DESCR";
          case 29:
            this.popState();
            break;
          case 30:
            C.getLogger().trace("Starting NSTR"), this.begin("NSTR");
            break;
          case 31:
            return C.getLogger().trace("description:", E.yytext), "NODE_DESCR";
          case 32:
            this.popState();
            break;
          case 33:
            return this.popState(), C.getLogger().trace("node end ))"), "NODE_DEND";
          case 34:
            return this.popState(), C.getLogger().trace("node end )"), "NODE_DEND";
          case 35:
            return this.popState(), C.getLogger().trace("node end ...", E.yytext), "NODE_DEND";
          case 36:
            return this.popState(), C.getLogger().trace("node end (("), "NODE_DEND";
          case 37:
            return this.popState(), C.getLogger().trace("node end (-"), "NODE_DEND";
          case 38:
            return this.popState(), C.getLogger().trace("node end (-"), "NODE_DEND";
          case 39:
            return this.popState(), C.getLogger().trace("node end (("), "NODE_DEND";
          case 40:
            return this.popState(), C.getLogger().trace("node end (("), "NODE_DEND";
          case 41:
            return C.getLogger().trace("Long description:", E.yytext), 21;
          case 42:
            return C.getLogger().trace("Long description:", E.yytext), 21;
        }
      }, "anonymous"),
      rules: [/^(?:@\{)/i, /^(?:["])/i, /^(?:["])/i, /^(?:[^\"]+)/i, /^(?:[^}^"]+)/i, /^(?:\})/i, /^(?:\s*%%.*)/i, /^(?:kanban\b)/i, /^(?::::)/i, /^(?:.+)/i, /^(?:\n)/i, /^(?:::icon\()/i, /^(?:[\s]+[\n])/i, /^(?:[\n]+)/i, /^(?:[^\)]+)/i, /^(?:\))/i, /^(?:-\))/i, /^(?:\(-)/i, /^(?:\)\))/i, /^(?:\))/i, /^(?:\(\()/i, /^(?:\{\{)/i, /^(?:\()/i, /^(?:\[)/i, /^(?:[\s]+)/i, /^(?:[^\(\[\n\)\{\}@]+)/i, /^(?:$)/i, /^(?:["][`])/i, /^(?:[^`"]+)/i, /^(?:[`]["])/i, /^(?:["])/i, /^(?:[^"]+)/i, /^(?:["])/i, /^(?:[\)]\))/i, /^(?:[\)])/i, /^(?:[\]])/i, /^(?:\}\})/i, /^(?:\(-)/i, /^(?:-\))/i, /^(?:\(\()/i, /^(?:\()/i, /^(?:[^\)\]\(\}]+)/i, /^(?:.+(?!\(\())/i],
      conditions: { shapeDataEndBracket: { rules: [], inclusive: !1 }, shapeDataStr: { rules: [2, 3], inclusive: !1 }, shapeData: { rules: [1, 4, 5], inclusive: !1 }, CLASS: { rules: [9, 10], inclusive: !1 }, ICON: { rules: [14, 15], inclusive: !1 }, NSTR2: { rules: [28, 29], inclusive: !1 }, NSTR: { rules: [31, 32], inclusive: !1 }, NODE: { rules: [27, 30, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42], inclusive: !1 }, INITIAL: { rules: [0, 6, 7, 8, 11, 12, 13, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26], inclusive: !0 } }
    };
    return L;
  }();
  A.lexer = S;
  function k() {
    this.yy = {};
  }
  return u(k, "Parser"), k.prototype = A, A.Parser = k, new k();
}();
gc.parser = gc;
var X7 = gc, Fr = [], Rh = [], fc = 0, Mh = {}, K7 = /* @__PURE__ */ u(() => {
  Fr = [], Rh = [], fc = 0, Mh = {};
}, "clear"), Q7 = /* @__PURE__ */ u((e) => {
  if (Fr.length === 0)
    return null;
  const t = Fr[0].level;
  let r = null;
  for (let i = Fr.length - 1; i >= 0; i--)
    if (Fr[i].level === t && !r && (r = Fr[i]), Fr[i].level < t)
      throw new Error('Items without section detected, found section ("' + Fr[i].label + '")');
  return e === (r == null ? void 0 : r.level) ? null : r;
}, "getSection"), Sy = /* @__PURE__ */ u(function() {
  return Rh;
}, "getSections"), Z7 = /* @__PURE__ */ u(function() {
  const e = [], t = [], r = Sy(), i = K();
  for (const s of r) {
    const a = {
      id: s.id,
      label: ge(s.label ?? "", i),
      isGroup: !0,
      ticket: s.ticket,
      shape: "kanbanSection",
      level: s.level,
      look: i.look
    };
    t.push(a);
    const n = Fr.filter((o) => o.parentId === s.id);
    for (const o of n) {
      const h = {
        id: o.id,
        parentId: s.id,
        label: ge(o.label ?? "", i),
        isGroup: !1,
        ticket: o == null ? void 0 : o.ticket,
        priority: o == null ? void 0 : o.priority,
        assigned: o == null ? void 0 : o.assigned,
        icon: o == null ? void 0 : o.icon,
        shape: "kanbanItem",
        level: o.level,
        rx: 5,
        ry: 5,
        cssStyles: ["text-align: left"]
      };
      t.push(h);
    }
  }
  return { nodes: t, edges: e, other: {}, config: K() };
}, "getData"), J7 = /* @__PURE__ */ u((e, t, r, i, s) => {
  var l, d;
  const a = K();
  let n = ((l = a.mindmap) == null ? void 0 : l.padding) ?? de.mindmap.padding;
  switch (i) {
    case ze.ROUNDED_RECT:
    case ze.RECT:
    case ze.HEXAGON:
      n *= 2;
  }
  const o = {
    id: ge(t, a) || "kbn" + fc++,
    level: e,
    label: ge(r, a),
    width: ((d = a.mindmap) == null ? void 0 : d.maxNodeWidth) ?? de.mindmap.maxNodeWidth,
    padding: n,
    isGroup: !1
  };
  if (s !== void 0) {
    let p;
    s.includes(`
`) ? p = s + `
` : p = `{
` + s + `
}`;
    const g = Io(p, { schema: Do });
    if (g.shape && (g.shape !== g.shape.toLowerCase() || g.shape.includes("_")))
      throw new Error(`No such shape: ${g.shape}. Shape names should be lowercase.`);
    g != null && g.shape && g.shape === "kanbanItem" && (o.shape = g == null ? void 0 : g.shape), g != null && g.label && (o.label = g == null ? void 0 : g.label), g != null && g.icon && (o.icon = g == null ? void 0 : g.icon.toString()), g != null && g.assigned && (o.assigned = g == null ? void 0 : g.assigned.toString()), g != null && g.ticket && (o.ticket = g == null ? void 0 : g.ticket.toString()), g != null && g.priority && (o.priority = g == null ? void 0 : g.priority);
  }
  const h = Q7(e);
  h ? o.parentId = h.id || "kbn" + fc++ : Rh.push(o), Fr.push(o);
}, "addNode"), ze = {
  DEFAULT: 0,
  NO_BORDER: 0,
  ROUNDED_RECT: 1,
  RECT: 2,
  CIRCLE: 3,
  CLOUD: 4,
  BANG: 5,
  HEXAGON: 6
}, t8 = /* @__PURE__ */ u((e, t) => {
  switch (I.debug("In get type", e, t), e) {
    case "[":
      return ze.RECT;
    case "(":
      return t === ")" ? ze.ROUNDED_RECT : ze.CLOUD;
    case "((":
      return ze.CIRCLE;
    case ")":
      return ze.CLOUD;
    case "))":
      return ze.BANG;
    case "{{":
      return ze.HEXAGON;
    default:
      return ze.DEFAULT;
  }
}, "getType"), e8 = /* @__PURE__ */ u((e, t) => {
  Mh[e] = t;
}, "setElementForId"), r8 = /* @__PURE__ */ u((e) => {
  if (!e)
    return;
  const t = K(), r = Fr[Fr.length - 1];
  e.icon && (r.icon = ge(e.icon, t)), e.class && (r.cssClasses = ge(e.class, t));
}, "decorateNode"), i8 = /* @__PURE__ */ u((e) => {
  switch (e) {
    case ze.DEFAULT:
      return "no-border";
    case ze.RECT:
      return "rect";
    case ze.ROUNDED_RECT:
      return "rounded-rect";
    case ze.CIRCLE:
      return "circle";
    case ze.CLOUD:
      return "cloud";
    case ze.BANG:
      return "bang";
    case ze.HEXAGON:
      return "hexgon";
    default:
      return "no-border";
  }
}, "type2Str"), s8 = /* @__PURE__ */ u(() => I, "getLogger"), a8 = /* @__PURE__ */ u((e) => Mh[e], "getElementById"), n8 = {
  clear: K7,
  addNode: J7,
  getSections: Sy,
  getData: Z7,
  nodeType: ze,
  getType: t8,
  setElementForId: e8,
  decorateNode: r8,
  type2Str: i8,
  getLogger: s8,
  getElementById: a8
}, o8 = n8, l8 = /* @__PURE__ */ u(async (e, t, r, i) => {
  var x, b, v, _, A;
  I.debug(`Rendering kanban diagram
` + e);
  const a = i.db.getData(), n = K();
  n.htmlLabels = !1;
  const o = xi(t), h = o.append("g");
  h.attr("class", "sections");
  const l = o.append("g");
  l.attr("class", "items");
  const d = a.nodes.filter(
    // TODO: TypeScript 5.5 will infer this predicate automatically
    (S) => S.isGroup
  );
  let p = 0;
  const g = 10, f = [];
  let y = 25;
  for (const S of d) {
    const k = ((x = n == null ? void 0 : n.kanban) == null ? void 0 : x.sectionWidth) || 200;
    p = p + 1, S.x = k * p + (p - 1) * g / 2, S.width = k, S.y = 0, S.height = k * 3, S.rx = 5, S.ry = 5, S.cssClasses = S.cssClasses + " section-" + p;
    const L = await Xc(h, S);
    y = Math.max(y, (b = L == null ? void 0 : L.labelBBox) == null ? void 0 : b.height), f.push(L);
  }
  let m = 0;
  for (const S of d) {
    const k = f[m];
    m = m + 1;
    const L = ((v = n == null ? void 0 : n.kanban) == null ? void 0 : v.sectionWidth) || 200, T = -L * 3 / 2 + y;
    let C = T;
    const E = a.nodes.filter((N) => N.parentId === S.id);
    for (const N of E) {
      if (N.isGroup)
        throw new Error("Groups within groups are not allowed in Kanban diagrams");
      N.x = S.x, N.width = L - 1.5 * g;
      const R = (await Oo(l, N, { config: n })).node().getBBox();
      N.y = C + R.height / 2, await Pl(N), C = N.y + R.height / 2 + g / 2;
    }
    const w = k.cluster.select("rect"), W = Math.max(C - T + 3 * g, 50) + (y - 25);
    w.attr("height", W);
  }
  dn(
    void 0,
    o,
    ((_ = n.mindmap) == null ? void 0 : _.padding) ?? de.kanban.padding,
    ((A = n.mindmap) == null ? void 0 : A.useMaxWidth) ?? de.kanban.useMaxWidth
  );
}, "draw"), c8 = {
  draw: l8
}, h8 = /* @__PURE__ */ u((e) => {
  let t = "";
  for (let i = 0; i < e.THEME_COLOR_LIMIT; i++)
    e["lineColor" + i] = e["lineColor" + i] || e["cScaleInv" + i], Ni(e["lineColor" + i]) ? e["lineColor" + i] = Ft(e["lineColor" + i], 20) : e["lineColor" + i] = zt(e["lineColor" + i], 20);
  const r = /* @__PURE__ */ u((i, s) => e.darkMode ? zt(i, s) : Ft(i, s), "adjuster");
  for (let i = 0; i < e.THEME_COLOR_LIMIT; i++) {
    const s = "" + (17 - 3 * i);
    t += `
    .section-${i - 1} rect, .section-${i - 1} path, .section-${i - 1} circle, .section-${i - 1} polygon, .section-${i - 1} path  {
      fill: ${r(e["cScale" + i], 10)};
      stroke: ${r(e["cScale" + i], 10)};

    }
    .section-${i - 1} text {
     fill: ${e["cScaleLabel" + i]};
    }
    .node-icon-${i - 1} {
      font-size: 40px;
      color: ${e["cScaleLabel" + i]};
    }
    .section-edge-${i - 1}{
      stroke: ${e["cScale" + i]};
    }
    .edge-depth-${i - 1}{
      stroke-width: ${s};
    }
    .section-${i - 1} line {
      stroke: ${e["cScaleInv" + i]} ;
      stroke-width: 3;
    }

    .disabled, .disabled circle, .disabled text {
      fill: lightgray;
    }
    .disabled text {
      fill: #efefef;
    }

  .node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${e.background};
    stroke: ${e.nodeBorder};
    stroke-width: 1px;
  }

  .kanban-ticket-link {
    fill: ${e.background};
    stroke: ${e.nodeBorder};
    text-decoration: underline;
  }
    `;
  }
  return t;
}, "genSections"), u8 = /* @__PURE__ */ u((e) => `
  .edge {
    stroke-width: 3;
  }
  ${h8(e)}
  .section-root rect, .section-root path, .section-root circle, .section-root polygon  {
    fill: ${e.git0};
  }
  .section-root text {
    fill: ${e.gitBranchLabel0};
  }
  .icon-container {
    height:100%;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  .edge {
    fill: none;
  }
  .cluster-label, .label {
    color: ${e.textColor};
    fill: ${e.textColor};
    }
  .kanban-label {
    dy: 1em;
    alignment-baseline: middle;
    text-anchor: middle;
    dominant-baseline: middle;
    text-align: center;
  }
    ${yn()}
`, "getStyles"), d8 = u8, p8 = {
  db: o8,
  renderer: c8,
  parser: X7,
  styles: d8
};
const g8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: p8
}, Symbol.toStringTag, { value: "Module" }));
var yc = function() {
  var e = /* @__PURE__ */ u(function(o, h, l, d) {
    for (l = l || {}, d = o.length; d--; l[o[d]] = h) ;
    return l;
  }, "o"), t = [1, 9], r = [1, 10], i = [1, 5, 10, 12], s = {
    trace: /* @__PURE__ */ u(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, start: 3, SANKEY: 4, NEWLINE: 5, csv: 6, opt_eof: 7, record: 8, csv_tail: 9, EOF: 10, "field[source]": 11, COMMA: 12, "field[target]": 13, "field[value]": 14, field: 15, escaped: 16, non_escaped: 17, DQUOTE: 18, ESCAPED_TEXT: 19, NON_ESCAPED_TEXT: 20, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 4: "SANKEY", 5: "NEWLINE", 10: "EOF", 11: "field[source]", 12: "COMMA", 13: "field[target]", 14: "field[value]", 18: "DQUOTE", 19: "ESCAPED_TEXT", 20: "NON_ESCAPED_TEXT" },
    productions_: [0, [3, 4], [6, 2], [9, 2], [9, 0], [7, 1], [7, 0], [8, 5], [15, 1], [15, 1], [16, 3], [17, 1]],
    performAction: /* @__PURE__ */ u(function(h, l, d, p, g, f, y) {
      var m = f.length - 1;
      switch (g) {
        case 7:
          const x = p.findOrCreateNode(f[m - 4].trim().replaceAll('""', '"')), b = p.findOrCreateNode(f[m - 2].trim().replaceAll('""', '"')), v = parseFloat(f[m].trim());
          p.addLink(x, b, v);
          break;
        case 8:
        case 9:
        case 11:
          this.$ = f[m];
          break;
        case 10:
          this.$ = f[m - 1];
          break;
      }
    }, "anonymous"),
    table: [{ 3: 1, 4: [1, 2] }, { 1: [3] }, { 5: [1, 3] }, { 6: 4, 8: 5, 15: 6, 16: 7, 17: 8, 18: t, 20: r }, { 1: [2, 6], 7: 11, 10: [1, 12] }, e(r, [2, 4], { 9: 13, 5: [1, 14] }), { 12: [1, 15] }, e(i, [2, 8]), e(i, [2, 9]), { 19: [1, 16] }, e(i, [2, 11]), { 1: [2, 1] }, { 1: [2, 5] }, e(r, [2, 2]), { 6: 17, 8: 5, 15: 6, 16: 7, 17: 8, 18: t, 20: r }, { 15: 18, 16: 7, 17: 8, 18: t, 20: r }, { 18: [1, 19] }, e(r, [2, 3]), { 12: [1, 20] }, e(i, [2, 10]), { 15: 21, 16: 7, 17: 8, 18: t, 20: r }, e([1, 5, 10], [2, 7])],
    defaultActions: { 11: [2, 1], 12: [2, 5] },
    parseError: /* @__PURE__ */ u(function(h, l) {
      if (l.recoverable)
        this.trace(h);
      else {
        var d = new Error(h);
        throw d.hash = l, d;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ u(function(h) {
      var l = this, d = [0], p = [], g = [null], f = [], y = this.table, m = "", x = 0, b = 0, v = 2, _ = 1, A = f.slice.call(arguments, 1), S = Object.create(this.lexer), k = { yy: {} };
      for (var L in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, L) && (k.yy[L] = this.yy[L]);
      S.setInput(h, k.yy), k.yy.lexer = S, k.yy.parser = this, typeof S.yylloc > "u" && (S.yylloc = {});
      var T = S.yylloc;
      f.push(T);
      var C = S.options && S.options.ranges;
      typeof k.yy.parseError == "function" ? this.parseError = k.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function E(G) {
        d.length = d.length - 2 * G, g.length = g.length - G, f.length = f.length - G;
      }
      u(E, "popStack");
      function w() {
        var G;
        return G = p.pop() || S.lex() || _, typeof G != "number" && (G instanceof Array && (p = G, G = p.pop()), G = l.symbols_[G] || G), G;
      }
      u(w, "lex");
      for (var W, N, B, R, V = {}, $, D, O, Y; ; ) {
        if (N = d[d.length - 1], this.defaultActions[N] ? B = this.defaultActions[N] : ((W === null || typeof W > "u") && (W = w()), B = y[N] && y[N][W]), typeof B > "u" || !B.length || !B[0]) {
          var M = "";
          Y = [];
          for ($ in y[N])
            this.terminals_[$] && $ > v && Y.push("'" + this.terminals_[$] + "'");
          S.showPosition ? M = "Parse error on line " + (x + 1) + `:
` + S.showPosition() + `
Expecting ` + Y.join(", ") + ", got '" + (this.terminals_[W] || W) + "'" : M = "Parse error on line " + (x + 1) + ": Unexpected " + (W == _ ? "end of input" : "'" + (this.terminals_[W] || W) + "'"), this.parseError(M, {
            text: S.match,
            token: this.terminals_[W] || W,
            line: S.yylineno,
            loc: T,
            expected: Y
          });
        }
        if (B[0] instanceof Array && B.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + N + ", token: " + W);
        switch (B[0]) {
          case 1:
            d.push(W), g.push(S.yytext), f.push(S.yylloc), d.push(B[1]), W = null, b = S.yyleng, m = S.yytext, x = S.yylineno, T = S.yylloc;
            break;
          case 2:
            if (D = this.productions_[B[1]][1], V.$ = g[g.length - D], V._$ = {
              first_line: f[f.length - (D || 1)].first_line,
              last_line: f[f.length - 1].last_line,
              first_column: f[f.length - (D || 1)].first_column,
              last_column: f[f.length - 1].last_column
            }, C && (V._$.range = [
              f[f.length - (D || 1)].range[0],
              f[f.length - 1].range[1]
            ]), R = this.performAction.apply(V, [
              m,
              b,
              x,
              k.yy,
              B[1],
              g,
              f
            ].concat(A)), typeof R < "u")
              return R;
            D && (d = d.slice(0, -1 * D * 2), g = g.slice(0, -1 * D), f = f.slice(0, -1 * D)), d.push(this.productions_[B[1]][0]), g.push(V.$), f.push(V._$), O = y[d[d.length - 2]][d[d.length - 1]], d.push(O);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, a = /* @__PURE__ */ function() {
    var o = {
      EOF: 1,
      parseError: /* @__PURE__ */ u(function(l, d) {
        if (this.yy.parser)
          this.yy.parser.parseError(l, d);
        else
          throw new Error(l);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ u(function(h, l) {
        return this.yy = l || this.yy || {}, this._input = h, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ u(function() {
        var h = this._input[0];
        this.yytext += h, this.yyleng++, this.offset++, this.match += h, this.matched += h;
        var l = h.match(/(?:\r\n?|\n).*/g);
        return l ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), h;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ u(function(h) {
        var l = h.length, d = h.split(/(?:\r\n?|\n)/g);
        this._input = h + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - l), this.offset -= l;
        var p = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), d.length - 1 && (this.yylineno -= d.length - 1);
        var g = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: d ? (d.length === p.length ? this.yylloc.first_column : 0) + p[p.length - d.length].length - d[0].length : this.yylloc.first_column - l
        }, this.options.ranges && (this.yylloc.range = [g[0], g[0] + this.yyleng - l]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ u(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ u(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ u(function(h) {
        this.unput(this.match.slice(h));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ u(function() {
        var h = this.matched.substr(0, this.matched.length - this.match.length);
        return (h.length > 20 ? "..." : "") + h.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ u(function() {
        var h = this.match;
        return h.length < 20 && (h += this._input.substr(0, 20 - h.length)), (h.substr(0, 20) + (h.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ u(function() {
        var h = this.pastInput(), l = new Array(h.length + 1).join("-");
        return h + this.upcomingInput() + `
` + l + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ u(function(h, l) {
        var d, p, g;
        if (this.options.backtrack_lexer && (g = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (g.yylloc.range = this.yylloc.range.slice(0))), p = h[0].match(/(?:\r\n?|\n).*/g), p && (this.yylineno += p.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: p ? p[p.length - 1].length - p[p.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + h[0].length
        }, this.yytext += h[0], this.match += h[0], this.matches = h, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(h[0].length), this.matched += h[0], d = this.performAction.call(this, this.yy, this, l, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), d)
          return d;
        if (this._backtrack) {
          for (var f in g)
            this[f] = g[f];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ u(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var h, l, d, p;
        this._more || (this.yytext = "", this.match = "");
        for (var g = this._currentRules(), f = 0; f < g.length; f++)
          if (d = this._input.match(this.rules[g[f]]), d && (!l || d[0].length > l[0].length)) {
            if (l = d, p = f, this.options.backtrack_lexer) {
              if (h = this.test_match(d, g[f]), h !== !1)
                return h;
              if (this._backtrack) {
                l = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return l ? (h = this.test_match(l, g[p]), h !== !1 ? h : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ u(function() {
        var l = this.next();
        return l || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ u(function(l) {
        this.conditionStack.push(l);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ u(function() {
        var l = this.conditionStack.length - 1;
        return l > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ u(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ u(function(l) {
        return l = this.conditionStack.length - 1 - Math.abs(l || 0), l >= 0 ? this.conditionStack[l] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ u(function(l) {
        this.begin(l);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ u(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: { "case-insensitive": !0 },
      performAction: /* @__PURE__ */ u(function(l, d, p, g) {
        switch (p) {
          case 0:
            return this.pushState("csv"), 4;
          case 1:
            return this.pushState("csv"), 4;
          case 2:
            return 10;
          case 3:
            return 5;
          case 4:
            return 12;
          case 5:
            return this.pushState("escaped_text"), 18;
          case 6:
            return 20;
          case 7:
            return this.popState("escaped_text"), 18;
          case 8:
            return 19;
        }
      }, "anonymous"),
      rules: [/^(?:sankey-beta\b)/i, /^(?:sankey\b)/i, /^(?:$)/i, /^(?:((\u000D\u000A)|(\u000A)))/i, /^(?:(\u002C))/i, /^(?:(\u0022))/i, /^(?:([\u0020-\u0021\u0023-\u002B\u002D-\u007E])*)/i, /^(?:(\u0022)(?!(\u0022)))/i, /^(?:(([\u0020-\u0021\u0023-\u002B\u002D-\u007E])|(\u002C)|(\u000D)|(\u000A)|(\u0022)(\u0022))*)/i],
      conditions: { csv: { rules: [2, 3, 4, 5, 6, 7, 8], inclusive: !1 }, escaped_text: { rules: [7, 8], inclusive: !1 }, INITIAL: { rules: [0, 1, 2, 3, 4, 5, 6, 7, 8], inclusive: !0 } }
    };
    return o;
  }();
  s.lexer = a;
  function n() {
    this.yy = {};
  }
  return u(n, "Parser"), n.prototype = s, s.Parser = n, new n();
}();
yc.parser = yc;
var mo = yc, Go = [], Xo = [], xo = /* @__PURE__ */ new Map(), f8 = /* @__PURE__ */ u(() => {
  Go = [], Xo = [], xo = /* @__PURE__ */ new Map(), Me();
}, "clear"), na, y8 = (na = class {
  constructor(t, r, i = 0) {
    this.source = t, this.target = r, this.value = i;
  }
}, u(na, "SankeyLink"), na), m8 = /* @__PURE__ */ u((e, t, r) => {
  Go.push(new y8(e, t, r));
}, "addLink"), oa, x8 = (oa = class {
  constructor(t) {
    this.ID = t;
  }
}, u(oa, "SankeyNode"), oa), b8 = /* @__PURE__ */ u((e) => {
  e = St.sanitizeText(e, K());
  let t = xo.get(e);
  return t === void 0 && (t = new x8(e), xo.set(e, t), Xo.push(t)), t;
}, "findOrCreateNode"), k8 = /* @__PURE__ */ u(() => Xo, "getNodes"), v8 = /* @__PURE__ */ u(() => Go, "getLinks"), S8 = /* @__PURE__ */ u(() => ({
  nodes: Xo.map((e) => ({ id: e.ID })),
  links: Go.map((e) => ({
    source: e.source.ID,
    target: e.target.ID,
    value: e.value
  }))
}), "getGraph"), C8 = {
  nodesMap: xo,
  getConfig: /* @__PURE__ */ u(() => K().sankey, "getConfig"),
  getNodes: k8,
  getLinks: v8,
  getGraph: S8,
  addLink: m8,
  findOrCreateNode: b8,
  getAccTitle: qe,
  setAccTitle: Re,
  getAccDescription: He,
  setAccDescription: Ye,
  getDiagramTitle: Oe,
  setDiagramTitle: Ge,
  clear: f8
}, fi, Xu = (fi = class {
  static next(t) {
    return new fi(t + ++fi.count);
  }
  constructor(t) {
    this.id = t, this.href = `#${t}`;
  }
  toString() {
    return "url(" + this.href + ")";
  }
}, u(fi, "Uid"), fi.count = 0, fi), w8 = {
  left: rx,
  right: ex,
  center: tx,
  justify: Jm
}, T8 = /* @__PURE__ */ u(function(e, t, r, i) {
  const { securityLevel: s, sankey: a } = K(), n = Md.sankey;
  let o;
  s === "sandbox" && (o = yt("#i" + t));
  const h = s === "sandbox" ? yt(o.nodes()[0].contentDocument.body) : yt("body"), l = s === "sandbox" ? h.select(`[id="${t}"]`) : yt(`[id="${t}"]`), d = (a == null ? void 0 : a.width) ?? n.width, p = (a == null ? void 0 : a.height) ?? n.width, g = (a == null ? void 0 : a.useMaxWidth) ?? n.useMaxWidth, f = (a == null ? void 0 : a.nodeAlignment) ?? n.nodeAlignment, y = (a == null ? void 0 : a.prefix) ?? n.prefix, m = (a == null ? void 0 : a.suffix) ?? n.suffix, x = (a == null ? void 0 : a.showValues) ?? n.showValues, b = i.db.getGraph(), v = w8[f];
  Zm().nodeId((E) => E.id).nodeWidth(10).nodePadding(10 + (x ? 15 : 0)).nodeAlign(v).extent([
    [0, 0],
    [d, p]
  ])(b);
  const S = Va(ix);
  l.append("g").attr("class", "nodes").selectAll(".node").data(b.nodes).join("g").attr("class", "node").attr("id", (E) => (E.uid = Xu.next("node-")).id).attr("transform", function(E) {
    return "translate(" + E.x0 + "," + E.y0 + ")";
  }).attr("x", (E) => E.x0).attr("y", (E) => E.y0).append("rect").attr("height", (E) => E.y1 - E.y0).attr("width", (E) => E.x1 - E.x0).attr("fill", (E) => S(E.id));
  const k = /* @__PURE__ */ u(({ id: E, value: w }) => x ? `${E}
${y}${Math.round(w * 100) / 100}${m}` : E, "getText");
  l.append("g").attr("class", "node-labels").attr("font-size", 14).selectAll("text").data(b.nodes).join("text").attr("x", (E) => E.x0 < d / 2 ? E.x1 + 6 : E.x0 - 6).attr("y", (E) => (E.y1 + E.y0) / 2).attr("dy", `${x ? "0" : "0.35"}em`).attr("text-anchor", (E) => E.x0 < d / 2 ? "start" : "end").text(k);
  const L = l.append("g").attr("class", "links").attr("fill", "none").attr("stroke-opacity", 0.5).selectAll(".link").data(b.links).join("g").attr("class", "link").style("mix-blend-mode", "multiply"), T = (a == null ? void 0 : a.linkColor) ?? "gradient";
  if (T === "gradient") {
    const E = L.append("linearGradient").attr("id", (w) => (w.uid = Xu.next("linearGradient-")).id).attr("gradientUnits", "userSpaceOnUse").attr("x1", (w) => w.source.x1).attr("x2", (w) => w.target.x0);
    E.append("stop").attr("offset", "0%").attr("stop-color", (w) => S(w.source.id)), E.append("stop").attr("offset", "100%").attr("stop-color", (w) => S(w.target.id));
  }
  let C;
  switch (T) {
    case "gradient":
      C = /* @__PURE__ */ u((E) => E.uid, "coloring");
      break;
    case "source":
      C = /* @__PURE__ */ u((E) => S(E.source.id), "coloring");
      break;
    case "target":
      C = /* @__PURE__ */ u((E) => S(E.target.id), "coloring");
      break;
    default:
      C = T;
  }
  L.append("path").attr("d", sx()).attr("stroke", C).attr("stroke-width", (E) => Math.max(1, E.width)), dn(void 0, l, 0, g);
}, "draw"), _8 = {
  draw: T8
}, E8 = /* @__PURE__ */ u((e) => e.replaceAll(/^[^\S\n\r]+|[^\S\n\r]+$/g, "").replaceAll(/([\n\r])+/g, `
`).trim(), "prepareTextForParsing"), A8 = /* @__PURE__ */ u((e) => `.label {
      font-family: ${e.fontFamily};
    }`, "getStyles"), L8 = A8, B8 = mo.parse.bind(mo);
mo.parse = (e) => B8(E8(e));
var D8 = {
  styles: L8,
  parser: mo,
  db: C8,
  renderer: _8
};
const I8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: D8
}, Symbol.toStringTag, { value: "Module" }));
var F8 = de.packet, la, Cy = (la = class {
  constructor() {
    this.packet = [], this.setAccTitle = Re, this.getAccTitle = qe, this.setDiagramTitle = Ge, this.getDiagramTitle = Oe, this.getAccDescription = He, this.setAccDescription = Ye;
  }
  getConfig() {
    const t = gr({
      ...F8,
      ...fe().packet
    });
    return t.showBits && (t.paddingY += 10), t;
  }
  getPacket() {
    return this.packet;
  }
  pushWord(t) {
    t.length > 0 && this.packet.push(t);
  }
  clear() {
    Me(), this.packet = [];
  }
}, u(la, "PacketDB"), la), N8 = 1e4, R8 = /* @__PURE__ */ u((e, t) => {
  hs(e, t);
  let r = -1, i = [], s = 1;
  const { bitsPerRow: a } = t.getConfig();
  for (let { start: n, end: o, bits: h, label: l } of e.blocks) {
    if (n !== void 0 && o !== void 0 && o < n)
      throw new Error(`Packet block ${n} - ${o} is invalid. End must be greater than start.`);
    if (n ?? (n = r + 1), n !== r + 1)
      throw new Error(
        `Packet block ${n} - ${o ?? n} is not contiguous. It should start from ${r + 1}.`
      );
    if (h === 0)
      throw new Error(`Packet block ${n} is invalid. Cannot have a zero bit field.`);
    for (o ?? (o = n + (h ?? 1) - 1), h ?? (h = o - n + 1), r = o, I.debug(`Packet block ${n} - ${r} with label ${l}`); i.length <= a + 1 && t.getPacket().length < N8; ) {
      const [d, p] = M8({ start: n, end: o, bits: h, label: l }, s, a);
      if (i.push(d), d.end + 1 === s * a && (t.pushWord(i), i = [], s++), !p)
        break;
      ({ start: n, end: o, bits: h, label: l } = p);
    }
  }
  t.pushWord(i);
}, "populate"), M8 = /* @__PURE__ */ u((e, t, r) => {
  if (e.start === void 0)
    throw new Error("start should have been set during first phase");
  if (e.end === void 0)
    throw new Error("end should have been set during first phase");
  if (e.start > e.end)
    throw new Error(`Block start ${e.start} is greater than block end ${e.end}.`);
  if (e.end + 1 <= t * r)
    return [e, void 0];
  const i = t * r - 1, s = t * r;
  return [
    {
      start: e.start,
      end: i,
      label: e.label,
      bits: i - e.start
    },
    {
      start: s,
      end: e.end,
      label: e.label,
      bits: e.end - s
    }
  ];
}, "getNextFittingBlock"), wy = {
  // @ts-expect-error - PacketDB is not assignable to DiagramDB
  parser: { yy: void 0 },
  parse: /* @__PURE__ */ u(async (e) => {
    var i;
    const t = await os("packet", e), r = (i = wy.parser) == null ? void 0 : i.yy;
    if (!(r instanceof Cy))
      throw new Error(
        "parser.parser?.yy was not a PacketDB. This is due to a bug within Mermaid, please report this issue at https://github.com/mermaid-js/mermaid/issues."
      );
    I.debug(t), R8(t, r);
  }, "parse")
}, O8 = /* @__PURE__ */ u((e, t, r, i) => {
  const s = i.db, a = s.getConfig(), { rowHeight: n, paddingY: o, bitWidth: h, bitsPerRow: l } = a, d = s.getPacket(), p = s.getDiagramTitle(), g = n + o, f = g * (d.length + 1) - (p ? 0 : n), y = h * l + 2, m = xi(t);
  m.attr("viewbox", `0 0 ${y} ${f}`), fr(m, f, y, a.useMaxWidth);
  for (const [x, b] of d.entries())
    P8(m, b, x, a);
  m.append("text").text(p).attr("x", y / 2).attr("y", f - g / 2).attr("dominant-baseline", "middle").attr("text-anchor", "middle").attr("class", "packetTitle");
}, "draw"), P8 = /* @__PURE__ */ u((e, t, r, { rowHeight: i, paddingX: s, paddingY: a, bitWidth: n, bitsPerRow: o, showBits: h }) => {
  const l = e.append("g"), d = r * (i + a) + a;
  for (const p of t) {
    const g = p.start % o * n + 1, f = (p.end - p.start + 1) * n - s;
    if (l.append("rect").attr("x", g).attr("y", d).attr("width", f).attr("height", i).attr("class", "packetBlock"), l.append("text").attr("x", g + f / 2).attr("y", d + i / 2).attr("class", "packetLabel").attr("dominant-baseline", "middle").attr("text-anchor", "middle").text(p.label), !h)
      continue;
    const y = p.end === p.start, m = d - 2;
    l.append("text").attr("x", g + (y ? f / 2 : 0)).attr("y", m).attr("class", "packetByte start").attr("dominant-baseline", "auto").attr("text-anchor", y ? "middle" : "start").text(p.start), y || l.append("text").attr("x", g + f).attr("y", m).attr("class", "packetByte end").attr("dominant-baseline", "auto").attr("text-anchor", "end").text(p.end);
  }
}, "drawWord"), $8 = { draw: O8 }, V8 = {
  byteFontSize: "10px",
  startByteColor: "black",
  endByteColor: "black",
  labelColor: "black",
  labelFontSize: "12px",
  titleColor: "black",
  titleFontSize: "14px",
  blockStrokeColor: "black",
  blockStrokeWidth: "1",
  blockFillColor: "#efefef"
}, z8 = /* @__PURE__ */ u(({ packet: e } = {}) => {
  const t = gr(V8, e);
  return `
	.packetByte {
		font-size: ${t.byteFontSize};
	}
	.packetByte.start {
		fill: ${t.startByteColor};
	}
	.packetByte.end {
		fill: ${t.endByteColor};
	}
	.packetLabel {
		fill: ${t.labelColor};
		font-size: ${t.labelFontSize};
	}
	.packetTitle {
		fill: ${t.titleColor};
		font-size: ${t.titleFontSize};
	}
	.packetBlock {
		stroke: ${t.blockStrokeColor};
		stroke-width: ${t.blockStrokeWidth};
		fill: ${t.blockFillColor};
	}
	`;
}, "styles"), W8 = {
  parser: wy,
  get db() {
    return new Cy();
  },
  renderer: $8,
  styles: z8
};
const q8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: W8
}, Symbol.toStringTag, { value: "Module" }));
var Cs = {
  showLegend: !0,
  ticks: 5,
  max: null,
  min: 0,
  graticule: "circle"
}, Ty = {
  axes: [],
  curves: [],
  options: Cs
}, ps = structuredClone(Ty), Y8 = de.radar, H8 = /* @__PURE__ */ u(() => gr({
  ...Y8,
  ...fe().radar
}), "getConfig"), _y = /* @__PURE__ */ u(() => ps.axes, "getAxes"), U8 = /* @__PURE__ */ u(() => ps.curves, "getCurves"), j8 = /* @__PURE__ */ u(() => ps.options, "getOptions"), G8 = /* @__PURE__ */ u((e) => {
  ps.axes = e.map((t) => ({
    name: t.name,
    label: t.label ?? t.name
  }));
}, "setAxes"), X8 = /* @__PURE__ */ u((e) => {
  ps.curves = e.map((t) => ({
    name: t.name,
    label: t.label ?? t.name,
    entries: K8(t.entries)
  }));
}, "setCurves"), K8 = /* @__PURE__ */ u((e) => {
  if (e[0].axis == null)
    return e.map((r) => r.value);
  const t = _y();
  if (t.length === 0)
    throw new Error("Axes must be populated before curves for reference entries");
  return t.map((r) => {
    const i = e.find((s) => {
      var a;
      return ((a = s.axis) == null ? void 0 : a.$refText) === r.name;
    });
    if (i === void 0)
      throw new Error("Missing entry for axis " + r.label);
    return i.value;
  });
}, "computeCurveEntries"), Q8 = /* @__PURE__ */ u((e) => {
  var r, i, s, a, n;
  const t = e.reduce(
    (o, h) => (o[h.name] = h, o),
    {}
  );
  ps.options = {
    showLegend: ((r = t.showLegend) == null ? void 0 : r.value) ?? Cs.showLegend,
    ticks: ((i = t.ticks) == null ? void 0 : i.value) ?? Cs.ticks,
    max: ((s = t.max) == null ? void 0 : s.value) ?? Cs.max,
    min: ((a = t.min) == null ? void 0 : a.value) ?? Cs.min,
    graticule: ((n = t.graticule) == null ? void 0 : n.value) ?? Cs.graticule
  };
}, "setOptions"), Z8 = /* @__PURE__ */ u(() => {
  Me(), ps = structuredClone(Ty);
}, "clear"), Pa = {
  getAxes: _y,
  getCurves: U8,
  getOptions: j8,
  setAxes: G8,
  setCurves: X8,
  setOptions: Q8,
  getConfig: H8,
  clear: Z8,
  setAccTitle: Re,
  getAccTitle: qe,
  setDiagramTitle: Ge,
  getDiagramTitle: Oe,
  getAccDescription: He,
  setAccDescription: Ye
}, J8 = /* @__PURE__ */ u((e) => {
  hs(e, Pa);
  const { axes: t, curves: r, options: i } = e;
  Pa.setAxes(t), Pa.setCurves(r), Pa.setOptions(i);
}, "populate"), t_ = {
  parse: /* @__PURE__ */ u(async (e) => {
    const t = await os("radar", e);
    I.debug(t), J8(t);
  }, "parse")
}, e_ = /* @__PURE__ */ u((e, t, r, i) => {
  const s = i.db, a = s.getAxes(), n = s.getCurves(), o = s.getOptions(), h = s.getConfig(), l = s.getDiagramTitle(), d = xi(t), p = r_(d, h), g = o.max ?? Math.max(...n.map((m) => Math.max(...m.entries))), f = o.min, y = Math.min(h.width, h.height) / 2;
  i_(p, a, y, o.ticks, o.graticule), s_(p, a, y, h), Ey(p, a, n, f, g, o.graticule, h), By(p, n, o.showLegend, h), p.append("text").attr("class", "radarTitle").text(l).attr("x", 0).attr("y", -h.height / 2 - h.marginTop);
}, "draw"), r_ = /* @__PURE__ */ u((e, t) => {
  const r = t.width + t.marginLeft + t.marginRight, i = t.height + t.marginTop + t.marginBottom, s = {
    x: t.marginLeft + t.width / 2,
    y: t.marginTop + t.height / 2
  };
  return e.attr("viewbox", `0 0 ${r} ${i}`).attr("width", r).attr("height", i), e.append("g").attr("transform", `translate(${s.x}, ${s.y})`);
}, "drawFrame"), i_ = /* @__PURE__ */ u((e, t, r, i, s) => {
  if (s === "circle")
    for (let a = 0; a < i; a++) {
      const n = r * (a + 1) / i;
      e.append("circle").attr("r", n).attr("class", "radarGraticule");
    }
  else if (s === "polygon") {
    const a = t.length;
    for (let n = 0; n < i; n++) {
      const o = r * (n + 1) / i, h = t.map((l, d) => {
        const p = 2 * d * Math.PI / a - Math.PI / 2, g = o * Math.cos(p), f = o * Math.sin(p);
        return `${g},${f}`;
      }).join(" ");
      e.append("polygon").attr("points", h).attr("class", "radarGraticule");
    }
  }
}, "drawGraticule"), s_ = /* @__PURE__ */ u((e, t, r, i) => {
  const s = t.length;
  for (let a = 0; a < s; a++) {
    const n = t[a].label, o = 2 * a * Math.PI / s - Math.PI / 2;
    e.append("line").attr("x1", 0).attr("y1", 0).attr("x2", r * i.axisScaleFactor * Math.cos(o)).attr("y2", r * i.axisScaleFactor * Math.sin(o)).attr("class", "radarAxisLine"), e.append("text").text(n).attr("x", r * i.axisLabelFactor * Math.cos(o)).attr("y", r * i.axisLabelFactor * Math.sin(o)).attr("class", "radarAxisLabel");
  }
}, "drawAxes");
function Ey(e, t, r, i, s, a, n) {
  const o = t.length, h = Math.min(n.width, n.height) / 2;
  r.forEach((l, d) => {
    if (l.entries.length !== o)
      return;
    const p = l.entries.map((g, f) => {
      const y = 2 * Math.PI * f / o - Math.PI / 2, m = Ay(g, i, s, h), x = m * Math.cos(y), b = m * Math.sin(y);
      return { x, y: b };
    });
    a === "circle" ? e.append("path").attr("d", Ly(p, n.curveTension)).attr("class", `radarCurve-${d}`) : a === "polygon" && e.append("polygon").attr("points", p.map((g) => `${g.x},${g.y}`).join(" ")).attr("class", `radarCurve-${d}`);
  });
}
u(Ey, "drawCurves");
function Ay(e, t, r, i) {
  const s = Math.min(Math.max(e, t), r);
  return i * (s - t) / (r - t);
}
u(Ay, "relativeRadius");
function Ly(e, t) {
  const r = e.length;
  let i = `M${e[0].x},${e[0].y}`;
  for (let s = 0; s < r; s++) {
    const a = e[(s - 1 + r) % r], n = e[s], o = e[(s + 1) % r], h = e[(s + 2) % r], l = {
      x: n.x + (o.x - a.x) * t,
      y: n.y + (o.y - a.y) * t
    }, d = {
      x: o.x - (h.x - n.x) * t,
      y: o.y - (h.y - n.y) * t
    };
    i += ` C${l.x},${l.y} ${d.x},${d.y} ${o.x},${o.y}`;
  }
  return `${i} Z`;
}
u(Ly, "closedRoundCurve");
function By(e, t, r, i) {
  if (!r)
    return;
  const s = (i.width / 2 + i.marginRight) * 3 / 4, a = -(i.height / 2 + i.marginTop) * 3 / 4, n = 20;
  t.forEach((o, h) => {
    const l = e.append("g").attr("transform", `translate(${s}, ${a + h * n})`);
    l.append("rect").attr("width", 12).attr("height", 12).attr("class", `radarLegendBox-${h}`), l.append("text").attr("x", 16).attr("y", 0).attr("class", "radarLegendText").text(o.label);
  });
}
u(By, "drawLegend");
var a_ = { draw: e_ }, n_ = /* @__PURE__ */ u((e, t) => {
  let r = "";
  for (let i = 0; i < e.THEME_COLOR_LIMIT; i++) {
    const s = e[`cScale${i}`];
    r += `
		.radarCurve-${i} {
			color: ${s};
			fill: ${s};
			fill-opacity: ${t.curveOpacity};
			stroke: ${s};
			stroke-width: ${t.curveStrokeWidth};
		}
		.radarLegendBox-${i} {
			fill: ${s};
			fill-opacity: ${t.curveOpacity};
			stroke: ${s};
		}
		`;
  }
  return r;
}, "genIndexStyles"), o_ = /* @__PURE__ */ u((e) => {
  const t = _o(), r = fe(), i = gr(t, r.themeVariables), s = gr(i.radar, e);
  return { themeVariables: i, radarOptions: s };
}, "buildRadarStyleOptions"), l_ = /* @__PURE__ */ u(({ radar: e } = {}) => {
  const { themeVariables: t, radarOptions: r } = o_(e);
  return `
	.radarTitle {
		font-size: ${t.fontSize};
		color: ${t.titleColor};
		dominant-baseline: hanging;
		text-anchor: middle;
	}
	.radarAxisLine {
		stroke: ${r.axisColor};
		stroke-width: ${r.axisStrokeWidth};
	}
	.radarAxisLabel {
		dominant-baseline: middle;
		text-anchor: middle;
		font-size: ${r.axisLabelFontSize}px;
		color: ${r.axisColor};
	}
	.radarGraticule {
		fill: ${r.graticuleColor};
		fill-opacity: ${r.graticuleOpacity};
		stroke: ${r.graticuleColor};
		stroke-width: ${r.graticuleStrokeWidth};
	}
	.radarLegendText {
		text-anchor: start;
		font-size: ${r.legendFontSize}px;
		dominant-baseline: hanging;
	}
	${n_(t, r)}
	`;
}, "styles"), c_ = {
  parser: t_,
  db: Pa,
  renderer: a_,
  styles: l_
};
const h_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: c_
}, Symbol.toStringTag, { value: "Module" }));
var mc = function() {
  var e = /* @__PURE__ */ u(function(_, A, S, k) {
    for (S = S || {}, k = _.length; k--; S[_[k]] = A) ;
    return S;
  }, "o"), t = [1, 15], r = [1, 7], i = [1, 13], s = [1, 14], a = [1, 19], n = [1, 16], o = [1, 17], h = [1, 18], l = [8, 30], d = [8, 10, 21, 28, 29, 30, 31, 39, 43, 46], p = [1, 23], g = [1, 24], f = [8, 10, 15, 16, 21, 28, 29, 30, 31, 39, 43, 46], y = [8, 10, 15, 16, 21, 27, 28, 29, 30, 31, 39, 43, 46], m = [1, 49], x = {
    trace: /* @__PURE__ */ u(function() {
    }, "trace"),
    yy: {},
    symbols_: { error: 2, spaceLines: 3, SPACELINE: 4, NL: 5, separator: 6, SPACE: 7, EOF: 8, start: 9, BLOCK_DIAGRAM_KEY: 10, document: 11, stop: 12, statement: 13, link: 14, LINK: 15, START_LINK: 16, LINK_LABEL: 17, STR: 18, nodeStatement: 19, columnsStatement: 20, SPACE_BLOCK: 21, blockStatement: 22, classDefStatement: 23, cssClassStatement: 24, styleStatement: 25, node: 26, SIZE: 27, COLUMNS: 28, "id-block": 29, end: 30, NODE_ID: 31, nodeShapeNLabel: 32, dirList: 33, DIR: 34, NODE_DSTART: 35, NODE_DEND: 36, BLOCK_ARROW_START: 37, BLOCK_ARROW_END: 38, classDef: 39, CLASSDEF_ID: 40, CLASSDEF_STYLEOPTS: 41, DEFAULT: 42, class: 43, CLASSENTITY_IDS: 44, STYLECLASS: 45, style: 46, STYLE_ENTITY_IDS: 47, STYLE_DEFINITION_DATA: 48, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 4: "SPACELINE", 5: "NL", 7: "SPACE", 8: "EOF", 10: "BLOCK_DIAGRAM_KEY", 15: "LINK", 16: "START_LINK", 17: "LINK_LABEL", 18: "STR", 21: "SPACE_BLOCK", 27: "SIZE", 28: "COLUMNS", 29: "id-block", 30: "end", 31: "NODE_ID", 34: "DIR", 35: "NODE_DSTART", 36: "NODE_DEND", 37: "BLOCK_ARROW_START", 38: "BLOCK_ARROW_END", 39: "classDef", 40: "CLASSDEF_ID", 41: "CLASSDEF_STYLEOPTS", 42: "DEFAULT", 43: "class", 44: "CLASSENTITY_IDS", 45: "STYLECLASS", 46: "style", 47: "STYLE_ENTITY_IDS", 48: "STYLE_DEFINITION_DATA" },
    productions_: [0, [3, 1], [3, 2], [3, 2], [6, 1], [6, 1], [6, 1], [9, 3], [12, 1], [12, 1], [12, 2], [12, 2], [11, 1], [11, 2], [14, 1], [14, 4], [13, 1], [13, 1], [13, 1], [13, 1], [13, 1], [13, 1], [13, 1], [19, 3], [19, 2], [19, 1], [20, 1], [22, 4], [22, 3], [26, 1], [26, 2], [33, 1], [33, 2], [32, 3], [32, 4], [23, 3], [23, 3], [24, 3], [25, 3]],
    performAction: /* @__PURE__ */ u(function(A, S, k, L, T, C, E) {
      var w = C.length - 1;
      switch (T) {
        case 4:
          L.getLogger().debug("Rule: separator (NL) ");
          break;
        case 5:
          L.getLogger().debug("Rule: separator (Space) ");
          break;
        case 6:
          L.getLogger().debug("Rule: separator (EOF) ");
          break;
        case 7:
          L.getLogger().debug("Rule: hierarchy: ", C[w - 1]), L.setHierarchy(C[w - 1]);
          break;
        case 8:
          L.getLogger().debug("Stop NL ");
          break;
        case 9:
          L.getLogger().debug("Stop EOF ");
          break;
        case 10:
          L.getLogger().debug("Stop NL2 ");
          break;
        case 11:
          L.getLogger().debug("Stop EOF2 ");
          break;
        case 12:
          L.getLogger().debug("Rule: statement: ", C[w]), typeof C[w].length == "number" ? this.$ = C[w] : this.$ = [C[w]];
          break;
        case 13:
          L.getLogger().debug("Rule: statement #2: ", C[w - 1]), this.$ = [C[w - 1]].concat(C[w]);
          break;
        case 14:
          L.getLogger().debug("Rule: link: ", C[w], A), this.$ = { edgeTypeStr: C[w], label: "" };
          break;
        case 15:
          L.getLogger().debug("Rule: LABEL link: ", C[w - 3], C[w - 1], C[w]), this.$ = { edgeTypeStr: C[w], label: C[w - 1] };
          break;
        case 18:
          const W = parseInt(C[w]), N = L.generateId();
          this.$ = { id: N, type: "space", label: "", width: W, children: [] };
          break;
        case 23:
          L.getLogger().debug("Rule: (nodeStatement link node) ", C[w - 2], C[w - 1], C[w], " typestr: ", C[w - 1].edgeTypeStr);
          const B = L.edgeStrToEdgeData(C[w - 1].edgeTypeStr);
          this.$ = [
            { id: C[w - 2].id, label: C[w - 2].label, type: C[w - 2].type, directions: C[w - 2].directions },
            { id: C[w - 2].id + "-" + C[w].id, start: C[w - 2].id, end: C[w].id, label: C[w - 1].label, type: "edge", directions: C[w].directions, arrowTypeEnd: B, arrowTypeStart: "arrow_open" },
            { id: C[w].id, label: C[w].label, type: L.typeStr2Type(C[w].typeStr), directions: C[w].directions }
          ];
          break;
        case 24:
          L.getLogger().debug("Rule: nodeStatement (abc88 node size) ", C[w - 1], C[w]), this.$ = { id: C[w - 1].id, label: C[w - 1].label, type: L.typeStr2Type(C[w - 1].typeStr), directions: C[w - 1].directions, widthInColumns: parseInt(C[w], 10) };
          break;
        case 25:
          L.getLogger().debug("Rule: nodeStatement (node) ", C[w]), this.$ = { id: C[w].id, label: C[w].label, type: L.typeStr2Type(C[w].typeStr), directions: C[w].directions, widthInColumns: 1 };
          break;
        case 26:
          L.getLogger().debug("APA123", this ? this : "na"), L.getLogger().debug("COLUMNS: ", C[w]), this.$ = { type: "column-setting", columns: C[w] === "auto" ? -1 : parseInt(C[w]) };
          break;
        case 27:
          L.getLogger().debug("Rule: id-block statement : ", C[w - 2], C[w - 1]), L.generateId(), this.$ = { ...C[w - 2], type: "composite", children: C[w - 1] };
          break;
        case 28:
          L.getLogger().debug("Rule: blockStatement : ", C[w - 2], C[w - 1], C[w]);
          const R = L.generateId();
          this.$ = { id: R, type: "composite", label: "", children: C[w - 1] };
          break;
        case 29:
          L.getLogger().debug("Rule: node (NODE_ID separator): ", C[w]), this.$ = { id: C[w] };
          break;
        case 30:
          L.getLogger().debug("Rule: node (NODE_ID nodeShapeNLabel separator): ", C[w - 1], C[w]), this.$ = { id: C[w - 1], label: C[w].label, typeStr: C[w].typeStr, directions: C[w].directions };
          break;
        case 31:
          L.getLogger().debug("Rule: dirList: ", C[w]), this.$ = [C[w]];
          break;
        case 32:
          L.getLogger().debug("Rule: dirList: ", C[w - 1], C[w]), this.$ = [C[w - 1]].concat(C[w]);
          break;
        case 33:
          L.getLogger().debug("Rule: nodeShapeNLabel: ", C[w - 2], C[w - 1], C[w]), this.$ = { typeStr: C[w - 2] + C[w], label: C[w - 1] };
          break;
        case 34:
          L.getLogger().debug("Rule: BLOCK_ARROW nodeShapeNLabel: ", C[w - 3], C[w - 2], " #3:", C[w - 1], C[w]), this.$ = { typeStr: C[w - 3] + C[w], label: C[w - 2], directions: C[w - 1] };
          break;
        case 35:
        case 36:
          this.$ = { type: "classDef", id: C[w - 1].trim(), css: C[w].trim() };
          break;
        case 37:
          this.$ = { type: "applyClass", id: C[w - 1].trim(), styleClass: C[w].trim() };
          break;
        case 38:
          this.$ = { type: "applyStyles", id: C[w - 1].trim(), stylesStr: C[w].trim() };
          break;
      }
    }, "anonymous"),
    table: [{ 9: 1, 10: [1, 2] }, { 1: [3] }, { 10: t, 11: 3, 13: 4, 19: 5, 20: 6, 21: r, 22: 8, 23: 9, 24: 10, 25: 11, 26: 12, 28: i, 29: s, 31: a, 39: n, 43: o, 46: h }, { 8: [1, 20] }, e(l, [2, 12], { 13: 4, 19: 5, 20: 6, 22: 8, 23: 9, 24: 10, 25: 11, 26: 12, 11: 21, 10: t, 21: r, 28: i, 29: s, 31: a, 39: n, 43: o, 46: h }), e(d, [2, 16], { 14: 22, 15: p, 16: g }), e(d, [2, 17]), e(d, [2, 18]), e(d, [2, 19]), e(d, [2, 20]), e(d, [2, 21]), e(d, [2, 22]), e(f, [2, 25], { 27: [1, 25] }), e(d, [2, 26]), { 19: 26, 26: 12, 31: a }, { 10: t, 11: 27, 13: 4, 19: 5, 20: 6, 21: r, 22: 8, 23: 9, 24: 10, 25: 11, 26: 12, 28: i, 29: s, 31: a, 39: n, 43: o, 46: h }, { 40: [1, 28], 42: [1, 29] }, { 44: [1, 30] }, { 47: [1, 31] }, e(y, [2, 29], { 32: 32, 35: [1, 33], 37: [1, 34] }), { 1: [2, 7] }, e(l, [2, 13]), { 26: 35, 31: a }, { 31: [2, 14] }, { 17: [1, 36] }, e(f, [2, 24]), { 10: t, 11: 37, 13: 4, 14: 22, 15: p, 16: g, 19: 5, 20: 6, 21: r, 22: 8, 23: 9, 24: 10, 25: 11, 26: 12, 28: i, 29: s, 31: a, 39: n, 43: o, 46: h }, { 30: [1, 38] }, { 41: [1, 39] }, { 41: [1, 40] }, { 45: [1, 41] }, { 48: [1, 42] }, e(y, [2, 30]), { 18: [1, 43] }, { 18: [1, 44] }, e(f, [2, 23]), { 18: [1, 45] }, { 30: [1, 46] }, e(d, [2, 28]), e(d, [2, 35]), e(d, [2, 36]), e(d, [2, 37]), e(d, [2, 38]), { 36: [1, 47] }, { 33: 48, 34: m }, { 15: [1, 50] }, e(d, [2, 27]), e(y, [2, 33]), { 38: [1, 51] }, { 33: 52, 34: m, 38: [2, 31] }, { 31: [2, 15] }, e(y, [2, 34]), { 38: [2, 32] }],
    defaultActions: { 20: [2, 7], 23: [2, 14], 50: [2, 15], 52: [2, 32] },
    parseError: /* @__PURE__ */ u(function(A, S) {
      if (S.recoverable)
        this.trace(A);
      else {
        var k = new Error(A);
        throw k.hash = S, k;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ u(function(A) {
      var S = this, k = [0], L = [], T = [null], C = [], E = this.table, w = "", W = 0, N = 0, B = 2, R = 1, V = C.slice.call(arguments, 1), $ = Object.create(this.lexer), D = { yy: {} };
      for (var O in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, O) && (D.yy[O] = this.yy[O]);
      $.setInput(A, D.yy), D.yy.lexer = $, D.yy.parser = this, typeof $.yylloc > "u" && ($.yylloc = {});
      var Y = $.yylloc;
      C.push(Y);
      var M = $.options && $.options.ranges;
      typeof D.yy.parseError == "function" ? this.parseError = D.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function G(U) {
        k.length = k.length - 2 * U, T.length = T.length - U, C.length = C.length - U;
      }
      u(G, "popStack");
      function rt() {
        var U;
        return U = L.pop() || $.lex() || R, typeof U != "number" && (U instanceof Array && (L = U, U = L.pop()), U = S.symbols_[U] || U), U;
      }
      u(rt, "lex");
      for (var ht, Z, ot, it, bt = {}, xt, Ct, at, lt; ; ) {
        if (Z = k[k.length - 1], this.defaultActions[Z] ? ot = this.defaultActions[Z] : ((ht === null || typeof ht > "u") && (ht = rt()), ot = E[Z] && E[Z][ht]), typeof ot > "u" || !ot.length || !ot[0]) {
          var Q = "";
          lt = [];
          for (xt in E[Z])
            this.terminals_[xt] && xt > B && lt.push("'" + this.terminals_[xt] + "'");
          $.showPosition ? Q = "Parse error on line " + (W + 1) + `:
` + $.showPosition() + `
Expecting ` + lt.join(", ") + ", got '" + (this.terminals_[ht] || ht) + "'" : Q = "Parse error on line " + (W + 1) + ": Unexpected " + (ht == R ? "end of input" : "'" + (this.terminals_[ht] || ht) + "'"), this.parseError(Q, {
            text: $.match,
            token: this.terminals_[ht] || ht,
            line: $.yylineno,
            loc: Y,
            expected: lt
          });
        }
        if (ot[0] instanceof Array && ot.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + Z + ", token: " + ht);
        switch (ot[0]) {
          case 1:
            k.push(ht), T.push($.yytext), C.push($.yylloc), k.push(ot[1]), ht = null, N = $.yyleng, w = $.yytext, W = $.yylineno, Y = $.yylloc;
            break;
          case 2:
            if (Ct = this.productions_[ot[1]][1], bt.$ = T[T.length - Ct], bt._$ = {
              first_line: C[C.length - (Ct || 1)].first_line,
              last_line: C[C.length - 1].last_line,
              first_column: C[C.length - (Ct || 1)].first_column,
              last_column: C[C.length - 1].last_column
            }, M && (bt._$.range = [
              C[C.length - (Ct || 1)].range[0],
              C[C.length - 1].range[1]
            ]), it = this.performAction.apply(bt, [
              w,
              N,
              W,
              D.yy,
              ot[1],
              T,
              C
            ].concat(V)), typeof it < "u")
              return it;
            Ct && (k = k.slice(0, -1 * Ct * 2), T = T.slice(0, -1 * Ct), C = C.slice(0, -1 * Ct)), k.push(this.productions_[ot[1]][0]), T.push(bt.$), C.push(bt._$), at = E[k[k.length - 2]][k[k.length - 1]], k.push(at);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }, "parse")
  }, b = /* @__PURE__ */ function() {
    var _ = {
      EOF: 1,
      parseError: /* @__PURE__ */ u(function(S, k) {
        if (this.yy.parser)
          this.yy.parser.parseError(S, k);
        else
          throw new Error(S);
      }, "parseError"),
      // resets the lexer, sets new input
      setInput: /* @__PURE__ */ u(function(A, S) {
        return this.yy = S || this.yy || {}, this._input = A, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      }, "setInput"),
      // consumes and returns one char from the input
      input: /* @__PURE__ */ u(function() {
        var A = this._input[0];
        this.yytext += A, this.yyleng++, this.offset++, this.match += A, this.matched += A;
        var S = A.match(/(?:\r\n?|\n).*/g);
        return S ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), A;
      }, "input"),
      // unshifts one char (or a string) into the input
      unput: /* @__PURE__ */ u(function(A) {
        var S = A.length, k = A.split(/(?:\r\n?|\n)/g);
        this._input = A + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - S), this.offset -= S;
        var L = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), k.length - 1 && (this.yylineno -= k.length - 1);
        var T = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: k ? (k.length === L.length ? this.yylloc.first_column : 0) + L[L.length - k.length].length - k[0].length : this.yylloc.first_column - S
        }, this.options.ranges && (this.yylloc.range = [T[0], T[0] + this.yyleng - S]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      // When called from action, caches matched text and appends it on next action
      more: /* @__PURE__ */ u(function() {
        return this._more = !0, this;
      }, "more"),
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: /* @__PURE__ */ u(function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      }, "reject"),
      // retain first n characters of the match
      less: /* @__PURE__ */ u(function(A) {
        this.unput(this.match.slice(A));
      }, "less"),
      // displays already matched input, i.e. for error messages
      pastInput: /* @__PURE__ */ u(function() {
        var A = this.matched.substr(0, this.matched.length - this.match.length);
        return (A.length > 20 ? "..." : "") + A.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      // displays upcoming input, i.e. for error messages
      upcomingInput: /* @__PURE__ */ u(function() {
        var A = this.match;
        return A.length < 20 && (A += this._input.substr(0, 20 - A.length)), (A.substr(0, 20) + (A.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: /* @__PURE__ */ u(function() {
        var A = this.pastInput(), S = new Array(A.length + 1).join("-");
        return A + this.upcomingInput() + `
` + S + "^";
      }, "showPosition"),
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: /* @__PURE__ */ u(function(A, S) {
        var k, L, T;
        if (this.options.backtrack_lexer && (T = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (T.yylloc.range = this.yylloc.range.slice(0))), L = A[0].match(/(?:\r\n?|\n).*/g), L && (this.yylineno += L.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: L ? L[L.length - 1].length - L[L.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + A[0].length
        }, this.yytext += A[0], this.match += A[0], this.matches = A, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(A[0].length), this.matched += A[0], k = this.performAction.call(this, this.yy, this, S, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), k)
          return k;
        if (this._backtrack) {
          for (var C in T)
            this[C] = T[C];
          return !1;
        }
        return !1;
      }, "test_match"),
      // return next match in input
      next: /* @__PURE__ */ u(function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var A, S, k, L;
        this._more || (this.yytext = "", this.match = "");
        for (var T = this._currentRules(), C = 0; C < T.length; C++)
          if (k = this._input.match(this.rules[T[C]]), k && (!S || k[0].length > S[0].length)) {
            if (S = k, L = C, this.options.backtrack_lexer) {
              if (A = this.test_match(k, T[C]), A !== !1)
                return A;
              if (this._backtrack) {
                S = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return S ? (A = this.test_match(S, T[L]), A !== !1 ? A : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      // return next match that has a token
      lex: /* @__PURE__ */ u(function() {
        var S = this.next();
        return S || this.lex();
      }, "lex"),
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: /* @__PURE__ */ u(function(S) {
        this.conditionStack.push(S);
      }, "begin"),
      // pop the previously active lexer condition state off the condition stack
      popState: /* @__PURE__ */ u(function() {
        var S = this.conditionStack.length - 1;
        return S > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: /* @__PURE__ */ u(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: /* @__PURE__ */ u(function(S) {
        return S = this.conditionStack.length - 1 - Math.abs(S || 0), S >= 0 ? this.conditionStack[S] : "INITIAL";
      }, "topState"),
      // alias for begin(condition)
      pushState: /* @__PURE__ */ u(function(S) {
        this.begin(S);
      }, "pushState"),
      // return the number of states currently on the stack
      stateStackSize: /* @__PURE__ */ u(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: {},
      performAction: /* @__PURE__ */ u(function(S, k, L, T) {
        switch (L) {
          case 0:
            return S.getLogger().debug("Found block-beta"), 10;
          case 1:
            return S.getLogger().debug("Found id-block"), 29;
          case 2:
            return S.getLogger().debug("Found block"), 10;
          case 3:
            S.getLogger().debug(".", k.yytext);
            break;
          case 4:
            S.getLogger().debug("_", k.yytext);
            break;
          case 5:
            return 5;
          case 6:
            return k.yytext = -1, 28;
          case 7:
            return k.yytext = k.yytext.replace(/columns\s+/, ""), S.getLogger().debug("COLUMNS (LEX)", k.yytext), 28;
          case 8:
            this.pushState("md_string");
            break;
          case 9:
            return "MD_STR";
          case 10:
            this.popState();
            break;
          case 11:
            this.pushState("string");
            break;
          case 12:
            S.getLogger().debug("LEX: POPPING STR:", k.yytext), this.popState();
            break;
          case 13:
            return S.getLogger().debug("LEX: STR end:", k.yytext), "STR";
          case 14:
            return k.yytext = k.yytext.replace(/space\:/, ""), S.getLogger().debug("SPACE NUM (LEX)", k.yytext), 21;
          case 15:
            return k.yytext = "1", S.getLogger().debug("COLUMNS (LEX)", k.yytext), 21;
          case 16:
            return 42;
          case 17:
            return "LINKSTYLE";
          case 18:
            return "INTERPOLATE";
          case 19:
            return this.pushState("CLASSDEF"), 39;
          case 20:
            return this.popState(), this.pushState("CLASSDEFID"), "DEFAULT_CLASSDEF_ID";
          case 21:
            return this.popState(), this.pushState("CLASSDEFID"), 40;
          case 22:
            return this.popState(), 41;
          case 23:
            return this.pushState("CLASS"), 43;
          case 24:
            return this.popState(), this.pushState("CLASS_STYLE"), 44;
          case 25:
            return this.popState(), 45;
          case 26:
            return this.pushState("STYLE_STMNT"), 46;
          case 27:
            return this.popState(), this.pushState("STYLE_DEFINITION"), 47;
          case 28:
            return this.popState(), 48;
          case 29:
            return this.pushState("acc_title"), "acc_title";
          case 30:
            return this.popState(), "acc_title_value";
          case 31:
            return this.pushState("acc_descr"), "acc_descr";
          case 32:
            return this.popState(), "acc_descr_value";
          case 33:
            this.pushState("acc_descr_multiline");
            break;
          case 34:
            this.popState();
            break;
          case 35:
            return "acc_descr_multiline_value";
          case 36:
            return 30;
          case 37:
            return this.popState(), S.getLogger().debug("Lex: (("), "NODE_DEND";
          case 38:
            return this.popState(), S.getLogger().debug("Lex: (("), "NODE_DEND";
          case 39:
            return this.popState(), S.getLogger().debug("Lex: ))"), "NODE_DEND";
          case 40:
            return this.popState(), S.getLogger().debug("Lex: (("), "NODE_DEND";
          case 41:
            return this.popState(), S.getLogger().debug("Lex: (("), "NODE_DEND";
          case 42:
            return this.popState(), S.getLogger().debug("Lex: (-"), "NODE_DEND";
          case 43:
            return this.popState(), S.getLogger().debug("Lex: -)"), "NODE_DEND";
          case 44:
            return this.popState(), S.getLogger().debug("Lex: (("), "NODE_DEND";
          case 45:
            return this.popState(), S.getLogger().debug("Lex: ]]"), "NODE_DEND";
          case 46:
            return this.popState(), S.getLogger().debug("Lex: ("), "NODE_DEND";
          case 47:
            return this.popState(), S.getLogger().debug("Lex: ])"), "NODE_DEND";
          case 48:
            return this.popState(), S.getLogger().debug("Lex: /]"), "NODE_DEND";
          case 49:
            return this.popState(), S.getLogger().debug("Lex: /]"), "NODE_DEND";
          case 50:
            return this.popState(), S.getLogger().debug("Lex: )]"), "NODE_DEND";
          case 51:
            return this.popState(), S.getLogger().debug("Lex: )"), "NODE_DEND";
          case 52:
            return this.popState(), S.getLogger().debug("Lex: ]>"), "NODE_DEND";
          case 53:
            return this.popState(), S.getLogger().debug("Lex: ]"), "NODE_DEND";
          case 54:
            return S.getLogger().debug("Lexa: -)"), this.pushState("NODE"), 35;
          case 55:
            return S.getLogger().debug("Lexa: (-"), this.pushState("NODE"), 35;
          case 56:
            return S.getLogger().debug("Lexa: ))"), this.pushState("NODE"), 35;
          case 57:
            return S.getLogger().debug("Lexa: )"), this.pushState("NODE"), 35;
          case 58:
            return S.getLogger().debug("Lex: ((("), this.pushState("NODE"), 35;
          case 59:
            return S.getLogger().debug("Lexa: )"), this.pushState("NODE"), 35;
          case 60:
            return S.getLogger().debug("Lexa: )"), this.pushState("NODE"), 35;
          case 61:
            return S.getLogger().debug("Lexa: )"), this.pushState("NODE"), 35;
          case 62:
            return S.getLogger().debug("Lexc: >"), this.pushState("NODE"), 35;
          case 63:
            return S.getLogger().debug("Lexa: (["), this.pushState("NODE"), 35;
          case 64:
            return S.getLogger().debug("Lexa: )"), this.pushState("NODE"), 35;
          case 65:
            return this.pushState("NODE"), 35;
          case 66:
            return this.pushState("NODE"), 35;
          case 67:
            return this.pushState("NODE"), 35;
          case 68:
            return this.pushState("NODE"), 35;
          case 69:
            return this.pushState("NODE"), 35;
          case 70:
            return this.pushState("NODE"), 35;
          case 71:
            return this.pushState("NODE"), 35;
          case 72:
            return S.getLogger().debug("Lexa: ["), this.pushState("NODE"), 35;
          case 73:
            return this.pushState("BLOCK_ARROW"), S.getLogger().debug("LEX ARR START"), 37;
          case 74:
            return S.getLogger().debug("Lex: NODE_ID", k.yytext), 31;
          case 75:
            return S.getLogger().debug("Lex: EOF", k.yytext), 8;
          case 76:
            this.pushState("md_string");
            break;
          case 77:
            this.pushState("md_string");
            break;
          case 78:
            return "NODE_DESCR";
          case 79:
            this.popState();
            break;
          case 80:
            S.getLogger().debug("Lex: Starting string"), this.pushState("string");
            break;
          case 81:
            S.getLogger().debug("LEX ARR: Starting string"), this.pushState("string");
            break;
          case 82:
            return S.getLogger().debug("LEX: NODE_DESCR:", k.yytext), "NODE_DESCR";
          case 83:
            S.getLogger().debug("LEX POPPING"), this.popState();
            break;
          case 84:
            S.getLogger().debug("Lex: =>BAE"), this.pushState("ARROW_DIR");
            break;
          case 85:
            return k.yytext = k.yytext.replace(/^,\s*/, ""), S.getLogger().debug("Lex (right): dir:", k.yytext), "DIR";
          case 86:
            return k.yytext = k.yytext.replace(/^,\s*/, ""), S.getLogger().debug("Lex (left):", k.yytext), "DIR";
          case 87:
            return k.yytext = k.yytext.replace(/^,\s*/, ""), S.getLogger().debug("Lex (x):", k.yytext), "DIR";
          case 88:
            return k.yytext = k.yytext.replace(/^,\s*/, ""), S.getLogger().debug("Lex (y):", k.yytext), "DIR";
          case 89:
            return k.yytext = k.yytext.replace(/^,\s*/, ""), S.getLogger().debug("Lex (up):", k.yytext), "DIR";
          case 90:
            return k.yytext = k.yytext.replace(/^,\s*/, ""), S.getLogger().debug("Lex (down):", k.yytext), "DIR";
          case 91:
            return k.yytext = "]>", S.getLogger().debug("Lex (ARROW_DIR end):", k.yytext), this.popState(), this.popState(), "BLOCK_ARROW_END";
          case 92:
            return S.getLogger().debug("Lex: LINK", "#" + k.yytext + "#"), 15;
          case 93:
            return S.getLogger().debug("Lex: LINK", k.yytext), 15;
          case 94:
            return S.getLogger().debug("Lex: LINK", k.yytext), 15;
          case 95:
            return S.getLogger().debug("Lex: LINK", k.yytext), 15;
          case 96:
            return S.getLogger().debug("Lex: START_LINK", k.yytext), this.pushState("LLABEL"), 16;
          case 97:
            return S.getLogger().debug("Lex: START_LINK", k.yytext), this.pushState("LLABEL"), 16;
          case 98:
            return S.getLogger().debug("Lex: START_LINK", k.yytext), this.pushState("LLABEL"), 16;
          case 99:
            this.pushState("md_string");
            break;
          case 100:
            return S.getLogger().debug("Lex: Starting string"), this.pushState("string"), "LINK_LABEL";
          case 101:
            return this.popState(), S.getLogger().debug("Lex: LINK", "#" + k.yytext + "#"), 15;
          case 102:
            return this.popState(), S.getLogger().debug("Lex: LINK", k.yytext), 15;
          case 103:
            return this.popState(), S.getLogger().debug("Lex: LINK", k.yytext), 15;
          case 104:
            return S.getLogger().debug("Lex: COLON", k.yytext), k.yytext = k.yytext.slice(1), 27;
        }
      }, "anonymous"),
      rules: [/^(?:block-beta\b)/, /^(?:block:)/, /^(?:block\b)/, /^(?:[\s]+)/, /^(?:[\n]+)/, /^(?:((\u000D\u000A)|(\u000A)))/, /^(?:columns\s+auto\b)/, /^(?:columns\s+[\d]+)/, /^(?:["][`])/, /^(?:[^`"]+)/, /^(?:[`]["])/, /^(?:["])/, /^(?:["])/, /^(?:[^"]*)/, /^(?:space[:]\d+)/, /^(?:space\b)/, /^(?:default\b)/, /^(?:linkStyle\b)/, /^(?:interpolate\b)/, /^(?:classDef\s+)/, /^(?:DEFAULT\s+)/, /^(?:\w+\s+)/, /^(?:[^\n]*)/, /^(?:class\s+)/, /^(?:(\w+)+((,\s*\w+)*))/, /^(?:[^\n]*)/, /^(?:style\s+)/, /^(?:(\w+)+((,\s*\w+)*))/, /^(?:[^\n]*)/, /^(?:accTitle\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*\{\s*)/, /^(?:[\}])/, /^(?:[^\}]*)/, /^(?:end\b\s*)/, /^(?:\(\(\()/, /^(?:\)\)\))/, /^(?:[\)]\))/, /^(?:\}\})/, /^(?:\})/, /^(?:\(-)/, /^(?:-\))/, /^(?:\(\()/, /^(?:\]\])/, /^(?:\()/, /^(?:\]\))/, /^(?:\\\])/, /^(?:\/\])/, /^(?:\)\])/, /^(?:[\)])/, /^(?:\]>)/, /^(?:[\]])/, /^(?:-\))/, /^(?:\(-)/, /^(?:\)\))/, /^(?:\))/, /^(?:\(\(\()/, /^(?:\(\()/, /^(?:\{\{)/, /^(?:\{)/, /^(?:>)/, /^(?:\(\[)/, /^(?:\()/, /^(?:\[\[)/, /^(?:\[\|)/, /^(?:\[\()/, /^(?:\)\)\))/, /^(?:\[\\)/, /^(?:\[\/)/, /^(?:\[\\)/, /^(?:\[)/, /^(?:<\[)/, /^(?:[^\(\[\n\-\)\{\}\s\<\>:]+)/, /^(?:$)/, /^(?:["][`])/, /^(?:["][`])/, /^(?:[^`"]+)/, /^(?:[`]["])/, /^(?:["])/, /^(?:["])/, /^(?:[^"]+)/, /^(?:["])/, /^(?:\]>\s*\()/, /^(?:,?\s*right\s*)/, /^(?:,?\s*left\s*)/, /^(?:,?\s*x\s*)/, /^(?:,?\s*y\s*)/, /^(?:,?\s*up\s*)/, /^(?:,?\s*down\s*)/, /^(?:\)\s*)/, /^(?:\s*[xo<]?--+[-xo>]\s*)/, /^(?:\s*[xo<]?==+[=xo>]\s*)/, /^(?:\s*[xo<]?-?\.+-[xo>]?\s*)/, /^(?:\s*~~[\~]+\s*)/, /^(?:\s*[xo<]?--\s*)/, /^(?:\s*[xo<]?==\s*)/, /^(?:\s*[xo<]?-\.\s*)/, /^(?:["][`])/, /^(?:["])/, /^(?:\s*[xo<]?--+[-xo>]\s*)/, /^(?:\s*[xo<]?==+[=xo>]\s*)/, /^(?:\s*[xo<]?-?\.+-[xo>]?\s*)/, /^(?::\d+)/],
      conditions: { STYLE_DEFINITION: { rules: [28], inclusive: !1 }, STYLE_STMNT: { rules: [27], inclusive: !1 }, CLASSDEFID: { rules: [22], inclusive: !1 }, CLASSDEF: { rules: [20, 21], inclusive: !1 }, CLASS_STYLE: { rules: [25], inclusive: !1 }, CLASS: { rules: [24], inclusive: !1 }, LLABEL: { rules: [99, 100, 101, 102, 103], inclusive: !1 }, ARROW_DIR: { rules: [85, 86, 87, 88, 89, 90, 91], inclusive: !1 }, BLOCK_ARROW: { rules: [76, 81, 84], inclusive: !1 }, NODE: { rules: [37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 77, 80], inclusive: !1 }, md_string: { rules: [9, 10, 78, 79], inclusive: !1 }, space: { rules: [], inclusive: !1 }, string: { rules: [12, 13, 82, 83], inclusive: !1 }, acc_descr_multiline: { rules: [34, 35], inclusive: !1 }, acc_descr: { rules: [32], inclusive: !1 }, acc_title: { rules: [30], inclusive: !1 }, INITIAL: { rules: [0, 1, 2, 3, 4, 5, 6, 7, 8, 11, 14, 15, 16, 17, 18, 19, 23, 26, 29, 31, 33, 36, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 92, 93, 94, 95, 96, 97, 98, 104], inclusive: !0 } }
    };
    return _;
  }();
  x.lexer = b;
  function v() {
    this.yy = {};
  }
  return u(v, "Parser"), v.prototype = x, x.Parser = v, new v();
}();
mc.parser = mc;
var u_ = mc, Vr = /* @__PURE__ */ new Map(), Oh = [], xc = /* @__PURE__ */ new Map(), Ku = "color", Qu = "fill", d_ = "bgFill", Dy = ",", p_ = K(), bo = /* @__PURE__ */ new Map(), g_ = /* @__PURE__ */ u((e) => St.sanitizeText(e, p_), "sanitizeText"), f_ = /* @__PURE__ */ u(function(e, t = "") {
  let r = bo.get(e);
  r || (r = { id: e, styles: [], textStyles: [] }, bo.set(e, r)), t != null && t.split(Dy).forEach((i) => {
    const s = i.replace(/([^;]*);/, "$1").trim();
    if (RegExp(Ku).exec(i)) {
      const n = s.replace(Qu, d_).replace(Ku, Qu);
      r.textStyles.push(n);
    }
    r.styles.push(s);
  });
}, "addStyleClass"), y_ = /* @__PURE__ */ u(function(e, t = "") {
  const r = Vr.get(e);
  t != null && (r.styles = t.split(Dy));
}, "addStyle2Node"), m_ = /* @__PURE__ */ u(function(e, t) {
  e.split(",").forEach(function(r) {
    let i = Vr.get(r);
    if (i === void 0) {
      const s = r.trim();
      i = { id: s, type: "na", children: [] }, Vr.set(s, i);
    }
    i.classes || (i.classes = []), i.classes.push(t);
  });
}, "setCssClass"), Iy = /* @__PURE__ */ u((e, t) => {
  const r = e.flat(), i = [], s = r.find((n) => (n == null ? void 0 : n.type) === "column-setting"), a = (s == null ? void 0 : s.columns) ?? -1;
  for (const n of r) {
    if (typeof a == "number" && a > 0 && n.type !== "column-setting" && typeof n.widthInColumns == "number" && n.widthInColumns > a && I.warn(
      `Block ${n.id} width ${n.widthInColumns} exceeds configured column width ${a}`
    ), n.label && (n.label = g_(n.label)), n.type === "classDef") {
      f_(n.id, n.css);
      continue;
    }
    if (n.type === "applyClass") {
      m_(n.id, (n == null ? void 0 : n.styleClass) ?? "");
      continue;
    }
    if (n.type === "applyStyles") {
      n != null && n.stylesStr && y_(n.id, n == null ? void 0 : n.stylesStr);
      continue;
    }
    if (n.type === "column-setting")
      t.columns = n.columns ?? -1;
    else if (n.type === "edge") {
      const o = (xc.get(n.id) ?? 0) + 1;
      xc.set(n.id, o), n.id = o + "-" + n.id, Oh.push(n);
    } else {
      n.label || (n.type === "composite" ? n.label = "" : n.label = n.id);
      const o = Vr.get(n.id);
      if (o === void 0 ? Vr.set(n.id, n) : (n.type !== "na" && (o.type = n.type), n.label !== n.id && (o.label = n.label)), n.children && Iy(n.children, n), n.type === "space") {
        const h = n.width ?? 1;
        for (let l = 0; l < h; l++) {
          const d = ax(n);
          d.id = d.id + "-" + l, Vr.set(d.id, d), i.push(d);
        }
      } else o === void 0 && i.push(n);
    }
  }
  t.children = i;
}, "populateBlockDatabase"), Ph = [], Ya = { id: "root", type: "composite", children: [], columns: -1 }, x_ = /* @__PURE__ */ u(() => {
  I.debug("Clear called"), Me(), Ya = { id: "root", type: "composite", children: [], columns: -1 }, Vr = /* @__PURE__ */ new Map([["root", Ya]]), Ph = [], bo = /* @__PURE__ */ new Map(), Oh = [], xc = /* @__PURE__ */ new Map();
}, "clear");
function Fy(e) {
  switch (I.debug("typeStr2Type", e), e) {
    case "[]":
      return "square";
    case "()":
      return I.debug("we have a round"), "round";
    case "(())":
      return "circle";
    case ">]":
      return "rect_left_inv_arrow";
    case "{}":
      return "diamond";
    case "{{}}":
      return "hexagon";
    case "([])":
      return "stadium";
    case "[[]]":
      return "subroutine";
    case "[()]":
      return "cylinder";
    case "((()))":
      return "doublecircle";
    case "[//]":
      return "lean_right";
    case "[\\\\]":
      return "lean_left";
    case "[/\\]":
      return "trapezoid";
    case "[\\/]":
      return "inv_trapezoid";
    case "<[]>":
      return "block_arrow";
    default:
      return "na";
  }
}
u(Fy, "typeStr2Type");
function Ny(e) {
  switch (I.debug("typeStr2Type", e), e) {
    case "==":
      return "thick";
    default:
      return "normal";
  }
}
u(Ny, "edgeTypeStr2Type");
function Ry(e) {
  switch (e.replace(/^[\s-]+|[\s-]+$/g, "")) {
    case "x":
      return "arrow_cross";
    case "o":
      return "arrow_circle";
    case ">":
      return "arrow_point";
    default:
      return "";
  }
}
u(Ry, "edgeStrToEdgeData");
var Zu = 0, b_ = /* @__PURE__ */ u(() => (Zu++, "id-" + Math.random().toString(36).substr(2, 12) + "-" + Zu), "generateId"), k_ = /* @__PURE__ */ u((e) => {
  Ya.children = e, Iy(e, Ya), Ph = Ya.children;
}, "setHierarchy"), v_ = /* @__PURE__ */ u((e) => {
  const t = Vr.get(e);
  return t ? t.columns ? t.columns : t.children ? t.children.length : -1 : -1;
}, "getColumns"), S_ = /* @__PURE__ */ u(() => [...Vr.values()], "getBlocksFlat"), C_ = /* @__PURE__ */ u(() => Ph || [], "getBlocks"), w_ = /* @__PURE__ */ u(() => Oh, "getEdges"), T_ = /* @__PURE__ */ u((e) => Vr.get(e), "getBlock"), __ = /* @__PURE__ */ u((e) => {
  Vr.set(e.id, e);
}, "setBlock"), E_ = /* @__PURE__ */ u(() => I, "getLogger"), A_ = /* @__PURE__ */ u(function() {
  return bo;
}, "getClasses"), L_ = {
  getConfig: /* @__PURE__ */ u(() => fe().block, "getConfig"),
  typeStr2Type: Fy,
  edgeTypeStr2Type: Ny,
  edgeStrToEdgeData: Ry,
  getLogger: E_,
  getBlocksFlat: S_,
  getBlocks: C_,
  getEdges: w_,
  setHierarchy: k_,
  getBlock: T_,
  setBlock: __,
  getColumns: v_,
  getClasses: A_,
  clear: x_,
  generateId: b_
}, B_ = L_, Bn = /* @__PURE__ */ u((e, t) => {
  const r = wc, i = r(e, "r"), s = r(e, "g"), a = r(e, "b");
  return Zi(i, s, a, t);
}, "fade"), D_ = /* @__PURE__ */ u((e) => `.label {
    font-family: ${e.fontFamily};
    color: ${e.nodeTextColor || e.textColor};
  }
  .cluster-label text {
    fill: ${e.titleColor};
  }
  .cluster-label span,p {
    color: ${e.titleColor};
  }



  .label text,span,p {
    fill: ${e.nodeTextColor || e.textColor};
    color: ${e.nodeTextColor || e.textColor};
  }

  .node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${e.mainBkg};
    stroke: ${e.nodeBorder};
    stroke-width: 1px;
  }
  .flowchart-label text {
    text-anchor: middle;
  }
  // .flowchart-label .text-outer-tspan {
  //   text-anchor: middle;
  // }
  // .flowchart-label .text-inner-tspan {
  //   text-anchor: start;
  // }

  .node .label {
    text-align: center;
  }
  .node.clickable {
    cursor: pointer;
  }

  .arrowheadPath {
    fill: ${e.arrowheadColor};
  }

  .edgePath .path {
    stroke: ${e.lineColor};
    stroke-width: 2.0px;
  }

  .flowchart-link {
    stroke: ${e.lineColor};
    fill: none;
  }

  .edgeLabel {
    background-color: ${e.edgeLabelBackground};
    rect {
      opacity: 0.5;
      background-color: ${e.edgeLabelBackground};
      fill: ${e.edgeLabelBackground};
    }
    text-align: center;
  }

  /* For html labels only */
  .labelBkg {
    background-color: ${Bn(e.edgeLabelBackground, 0.5)};
    // background-color:
  }

  .node .cluster {
    // fill: ${Bn(e.mainBkg, 0.5)};
    fill: ${Bn(e.clusterBkg, 0.5)};
    stroke: ${Bn(e.clusterBorder, 0.2)};
    box-shadow: rgba(50, 50, 93, 0.25) 0px 13px 27px -5px, rgba(0, 0, 0, 0.3) 0px 8px 16px -8px;
    stroke-width: 1px;
  }

  .cluster text {
    fill: ${e.titleColor};
  }

  .cluster span,p {
    color: ${e.titleColor};
  }
  /* .cluster div {
    color: ${e.titleColor};
  } */

  div.mermaidTooltip {
    position: absolute;
    text-align: center;
    max-width: 200px;
    padding: 2px;
    font-family: ${e.fontFamily};
    font-size: 12px;
    background: ${e.tertiaryColor};
    border: 1px solid ${e.border2};
    border-radius: 2px;
    pointer-events: none;
    z-index: 100;
  }

  .flowchartTitleText {
    text-anchor: middle;
    font-size: 18px;
    fill: ${e.textColor};
  }
  ${yn()}
`, "getStyles"), I_ = D_, F_ = /* @__PURE__ */ u((e, t, r, i) => {
  t.forEach((s) => {
    q_[s](e, r, i);
  });
}, "insertMarkers"), N_ = /* @__PURE__ */ u((e, t, r) => {
  I.trace("Making markers for ", r), e.append("defs").append("marker").attr("id", r + "_" + t + "-extensionStart").attr("class", "marker extension " + t).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 1,7 L18,13 V 1 Z"), e.append("defs").append("marker").attr("id", r + "_" + t + "-extensionEnd").attr("class", "marker extension " + t).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 1,1 V 13 L18,7 Z");
}, "extension"), R_ = /* @__PURE__ */ u((e, t, r) => {
  e.append("defs").append("marker").attr("id", r + "_" + t + "-compositionStart").attr("class", "marker composition " + t).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"), e.append("defs").append("marker").attr("id", r + "_" + t + "-compositionEnd").attr("class", "marker composition " + t).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
}, "composition"), M_ = /* @__PURE__ */ u((e, t, r) => {
  e.append("defs").append("marker").attr("id", r + "_" + t + "-aggregationStart").attr("class", "marker aggregation " + t).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"), e.append("defs").append("marker").attr("id", r + "_" + t + "-aggregationEnd").attr("class", "marker aggregation " + t).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
}, "aggregation"), O_ = /* @__PURE__ */ u((e, t, r) => {
  e.append("defs").append("marker").attr("id", r + "_" + t + "-dependencyStart").attr("class", "marker dependency " + t).attr("refX", 6).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 5,7 L9,13 L1,7 L9,1 Z"), e.append("defs").append("marker").attr("id", r + "_" + t + "-dependencyEnd").attr("class", "marker dependency " + t).attr("refX", 13).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
}, "dependency"), P_ = /* @__PURE__ */ u((e, t, r) => {
  e.append("defs").append("marker").attr("id", r + "_" + t + "-lollipopStart").attr("class", "marker lollipop " + t).attr("refX", 13).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("circle").attr("stroke", "black").attr("fill", "transparent").attr("cx", 7).attr("cy", 7).attr("r", 6), e.append("defs").append("marker").attr("id", r + "_" + t + "-lollipopEnd").attr("class", "marker lollipop " + t).attr("refX", 1).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("circle").attr("stroke", "black").attr("fill", "transparent").attr("cx", 7).attr("cy", 7).attr("r", 6);
}, "lollipop"), $_ = /* @__PURE__ */ u((e, t, r) => {
  e.append("marker").attr("id", r + "_" + t + "-pointEnd").attr("class", "marker " + t).attr("viewBox", "0 0 10 10").attr("refX", 6).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 0 0 L 10 5 L 0 10 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0"), e.append("marker").attr("id", r + "_" + t + "-pointStart").attr("class", "marker " + t).attr("viewBox", "0 0 10 10").attr("refX", 4.5).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 0 5 L 10 10 L 10 0 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
}, "point"), V_ = /* @__PURE__ */ u((e, t, r) => {
  e.append("marker").attr("id", r + "_" + t + "-circleEnd").attr("class", "marker " + t).attr("viewBox", "0 0 10 10").attr("refX", 11).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0"), e.append("marker").attr("id", r + "_" + t + "-circleStart").attr("class", "marker " + t).attr("viewBox", "0 0 10 10").attr("refX", -1).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
}, "circle"), z_ = /* @__PURE__ */ u((e, t, r) => {
  e.append("marker").attr("id", r + "_" + t + "-crossEnd").attr("class", "marker cross " + t).attr("viewBox", "0 0 11 11").attr("refX", 12).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0"), e.append("marker").attr("id", r + "_" + t + "-crossStart").attr("class", "marker cross " + t).attr("viewBox", "0 0 11 11").attr("refX", -1).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0");
}, "cross"), W_ = /* @__PURE__ */ u((e, t, r) => {
  e.append("defs").append("marker").attr("id", r + "_" + t + "-barbEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 14).attr("markerUnits", "strokeWidth").attr("orient", "auto").append("path").attr("d", "M 19,7 L9,13 L14,7 L9,1 Z");
}, "barb"), q_ = {
  extension: N_,
  composition: R_,
  aggregation: M_,
  dependency: O_,
  lollipop: P_,
  point: $_,
  circle: V_,
  cross: z_,
  barb: W_
}, Y_ = F_, ld, cd, Be = ((cd = (ld = K()) == null ? void 0 : ld.block) == null ? void 0 : cd.padding) ?? 8;
function My(e, t) {
  if (e === 0 || !Number.isInteger(e))
    throw new Error("Columns must be an integer !== 0.");
  if (t < 0 || !Number.isInteger(t))
    throw new Error("Position must be a non-negative integer." + t);
  if (e < 0)
    return { px: t, py: 0 };
  if (e === 1)
    return { px: 0, py: t };
  const r = t % e, i = Math.floor(t / e);
  return { px: r, py: i };
}
u(My, "calculateBlockPosition");
var H_ = /* @__PURE__ */ u((e) => {
  let t = 0, r = 0;
  for (const i of e.children) {
    const { width: s, height: a, x: n, y: o } = i.size ?? { width: 0, height: 0, x: 0, y: 0 };
    I.debug(
      "getMaxChildSize abc95 child:",
      i.id,
      "width:",
      s,
      "height:",
      a,
      "x:",
      n,
      "y:",
      o,
      i.type
    ), i.type !== "space" && (s > t && (t = s / (e.widthInColumns ?? 1)), a > r && (r = a));
  }
  return { width: t, height: r };
}, "getMaxChildSize");
function ko(e, t, r = 0, i = 0) {
  var n, o, h, l, d, p, g, f, y, m, x;
  I.debug(
    "setBlockSizes abc95 (start)",
    e.id,
    (n = e == null ? void 0 : e.size) == null ? void 0 : n.x,
    "block width =",
    e == null ? void 0 : e.size,
    "siblingWidth",
    r
  ), (o = e == null ? void 0 : e.size) != null && o.width || (e.size = {
    width: r,
    height: i,
    x: 0,
    y: 0
  });
  let s = 0, a = 0;
  if (((h = e.children) == null ? void 0 : h.length) > 0) {
    for (const T of e.children)
      ko(T, t);
    const b = H_(e);
    s = b.width, a = b.height, I.debug("setBlockSizes abc95 maxWidth of", e.id, ":s children is ", s, a);
    for (const T of e.children)
      T.size && (I.debug(
        `abc95 Setting size of children of ${e.id} id=${T.id} ${s} ${a} ${JSON.stringify(T.size)}`
      ), T.size.width = s * (T.widthInColumns ?? 1) + Be * ((T.widthInColumns ?? 1) - 1), T.size.height = a, T.size.x = 0, T.size.y = 0, I.debug(
        `abc95 updating size of ${e.id} children child:${T.id} maxWidth:${s} maxHeight:${a}`
      ));
    for (const T of e.children)
      ko(T, t, s, a);
    const v = e.columns ?? -1;
    let _ = 0;
    for (const T of e.children)
      _ += T.widthInColumns ?? 1;
    let A = e.children.length;
    v > 0 && v < _ && (A = v);
    const S = Math.ceil(_ / A);
    let k = A * (s + Be) + Be, L = S * (a + Be) + Be;
    if (k < r) {
      I.debug(
        `Detected to small sibling: abc95 ${e.id} siblingWidth ${r} siblingHeight ${i} width ${k}`
      ), k = r, L = i;
      const T = (r - A * Be - Be) / A, C = (i - S * Be - Be) / S;
      I.debug("Size indata abc88", e.id, "childWidth", T, "maxWidth", s), I.debug("Size indata abc88", e.id, "childHeight", C, "maxHeight", a), I.debug("Size indata abc88 xSize", A, "padding", Be);
      for (const E of e.children)
        E.size && (E.size.width = T, E.size.height = C, E.size.x = 0, E.size.y = 0);
    }
    if (I.debug(
      `abc95 (finale calc) ${e.id} xSize ${A} ySize ${S} columns ${v}${e.children.length} width=${Math.max(k, ((l = e.size) == null ? void 0 : l.width) || 0)}`
    ), k < (((d = e == null ? void 0 : e.size) == null ? void 0 : d.width) || 0)) {
      k = ((p = e == null ? void 0 : e.size) == null ? void 0 : p.width) || 0;
      const T = v > 0 ? Math.min(e.children.length, v) : e.children.length;
      if (T > 0) {
        const C = (k - T * Be - Be) / T;
        I.debug("abc95 (growing to fit) width", e.id, k, (g = e.size) == null ? void 0 : g.width, C);
        for (const E of e.children)
          E.size && (E.size.width = C);
      }
    }
    e.size = {
      width: k,
      height: L,
      x: 0,
      y: 0
    };
  }
  I.debug(
    "setBlockSizes abc94 (done)",
    e.id,
    (f = e == null ? void 0 : e.size) == null ? void 0 : f.x,
    (y = e == null ? void 0 : e.size) == null ? void 0 : y.width,
    (m = e == null ? void 0 : e.size) == null ? void 0 : m.y,
    (x = e == null ? void 0 : e.size) == null ? void 0 : x.height
  );
}
u(ko, "setBlockSizes");
function $h(e, t) {
  var i, s, a, n, o, h, l, d, p, g, f, y, m, x, b, v, _;
  I.debug(
    `abc85 layout blocks (=>layoutBlocks) ${e.id} x: ${(i = e == null ? void 0 : e.size) == null ? void 0 : i.x} y: ${(s = e == null ? void 0 : e.size) == null ? void 0 : s.y} width: ${(a = e == null ? void 0 : e.size) == null ? void 0 : a.width}`
  );
  const r = e.columns ?? -1;
  if (I.debug("layoutBlocks columns abc95", e.id, "=>", r, e), e.children && // find max width of children
  e.children.length > 0) {
    const A = ((o = (n = e == null ? void 0 : e.children[0]) == null ? void 0 : n.size) == null ? void 0 : o.width) ?? 0, S = e.children.length * A + (e.children.length - 1) * Be;
    I.debug("widthOfChildren 88", S, "posX");
    let k = 0;
    I.debug("abc91 block?.size?.x", e.id, (h = e == null ? void 0 : e.size) == null ? void 0 : h.x);
    let L = (l = e == null ? void 0 : e.size) != null && l.x ? ((d = e == null ? void 0 : e.size) == null ? void 0 : d.x) + (-((p = e == null ? void 0 : e.size) == null ? void 0 : p.width) / 2 || 0) : -Be, T = 0;
    for (const C of e.children) {
      const E = e;
      if (!C.size)
        continue;
      const { width: w, height: W } = C.size, { px: N, py: B } = My(r, k);
      if (B != T && (T = B, L = (g = e == null ? void 0 : e.size) != null && g.x ? ((f = e == null ? void 0 : e.size) == null ? void 0 : f.x) + (-((y = e == null ? void 0 : e.size) == null ? void 0 : y.width) / 2 || 0) : -Be, I.debug("New row in layout for block", e.id, " and child ", C.id, T)), I.debug(
        `abc89 layout blocks (child) id: ${C.id} Pos: ${k} (px, py) ${N},${B} (${(m = E == null ? void 0 : E.size) == null ? void 0 : m.x},${(x = E == null ? void 0 : E.size) == null ? void 0 : x.y}) parent: ${E.id} width: ${w}${Be}`
      ), E.size) {
        const V = w / 2;
        C.size.x = L + Be + V, I.debug(
          `abc91 layout blocks (calc) px, pyid:${C.id} startingPos=X${L} new startingPosX${C.size.x} ${V} padding=${Be} width=${w} halfWidth=${V} => x:${C.size.x} y:${C.size.y} ${C.widthInColumns} (width * (child?.w || 1)) / 2 ${w * ((C == null ? void 0 : C.widthInColumns) ?? 1) / 2}`
        ), L = C.size.x + V, C.size.y = E.size.y - E.size.height / 2 + B * (W + Be) + W / 2 + Be, I.debug(
          `abc88 layout blocks (calc) px, pyid:${C.id}startingPosX${L}${Be}${V}=>x:${C.size.x}y:${C.size.y}${C.widthInColumns}(width * (child?.w || 1)) / 2${w * ((C == null ? void 0 : C.widthInColumns) ?? 1) / 2}`
        );
      }
      C.children && $h(C);
      let R = (C == null ? void 0 : C.widthInColumns) ?? 1;
      r > 0 && (R = Math.min(R, r - k % r)), k += R, I.debug("abc88 columnsPos", C, k);
    }
  }
  I.debug(
    `layout blocks (<==layoutBlocks) ${e.id} x: ${(b = e == null ? void 0 : e.size) == null ? void 0 : b.x} y: ${(v = e == null ? void 0 : e.size) == null ? void 0 : v.y} width: ${(_ = e == null ? void 0 : e.size) == null ? void 0 : _.width}`
  );
}
u($h, "layoutBlocks");
function Vh(e, { minX: t, minY: r, maxX: i, maxY: s } = { minX: 0, minY: 0, maxX: 0, maxY: 0 }) {
  if (e.size && e.id !== "root") {
    const { x: a, y: n, width: o, height: h } = e.size;
    a - o / 2 < t && (t = a - o / 2), n - h / 2 < r && (r = n - h / 2), a + o / 2 > i && (i = a + o / 2), n + h / 2 > s && (s = n + h / 2);
  }
  if (e.children)
    for (const a of e.children)
      ({ minX: t, minY: r, maxX: i, maxY: s } = Vh(a, { minX: t, minY: r, maxX: i, maxY: s }));
  return { minX: t, minY: r, maxX: i, maxY: s };
}
u(Vh, "findBounds");
function Oy(e) {
  const t = e.getBlock("root");
  if (!t)
    return;
  ko(t, e, 0, 0), $h(t), I.debug("getBlocks", JSON.stringify(t, null, 2));
  const { minX: r, minY: i, maxX: s, maxY: a } = Vh(t), n = a - i, o = s - r;
  return { x: r, y: i, width: o, height: n };
}
u(Oy, "layout");
function bc(e, t) {
  t && e.attr("style", t);
}
u(bc, "applyStyle");
function Py(e, t) {
  const r = yt(document.createElementNS("http://www.w3.org/2000/svg", "foreignObject")), i = r.append("xhtml:div"), s = e.label, a = e.isNode ? "nodeLabel" : "edgeLabel", n = i.append("span");
  return n.html(ge(s, t)), bc(n, e.labelStyle), n.attr("class", a), bc(i, e.labelStyle), i.style("display", "inline-block"), i.style("white-space", "nowrap"), i.attr("xmlns", "http://www.w3.org/1999/xhtml"), r.node();
}
u(Py, "addHtmlLabel");
var U_ = /* @__PURE__ */ u(async (e, t, r, i) => {
  let s = e || "";
  typeof s == "object" && (s = s[0]);
  const a = K();
  if (ke(a.flowchart.htmlLabels)) {
    s = s.replace(/\\n|\n/g, "<br />"), I.debug("vertexText" + s);
    const n = await Gc(Qr(s)), o = {
      isNode: i,
      label: n,
      labelStyle: t.replace("fill:", "color:")
    };
    return Py(o, a);
  } else {
    const n = document.createElementNS("http://www.w3.org/2000/svg", "text");
    n.setAttribute("style", t.replace("color:", "fill:"));
    let o = [];
    typeof s == "string" ? o = s.split(/\\n|\n|<br\s*\/?>/gi) : Array.isArray(s) ? o = s : o = [];
    for (const h of o) {
      const l = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
      l.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"), l.setAttribute("dy", "1em"), l.setAttribute("x", "0"), r ? l.setAttribute("class", "title-row") : l.setAttribute("class", "row"), l.textContent = h.trim(), n.appendChild(l);
    }
    return n;
  }
}, "createLabel"), Nr = U_, j_ = /* @__PURE__ */ u((e, t, r, i, s) => {
  t.arrowTypeStart && Ju(e, "start", t.arrowTypeStart, r, i, s), t.arrowTypeEnd && Ju(e, "end", t.arrowTypeEnd, r, i, s);
}, "addEdgeMarkers"), G_ = {
  arrow_cross: "cross",
  arrow_point: "point",
  arrow_barb: "barb",
  arrow_circle: "circle",
  aggregation: "aggregation",
  extension: "extension",
  composition: "composition",
  dependency: "dependency",
  lollipop: "lollipop"
}, Ju = /* @__PURE__ */ u((e, t, r, i, s, a) => {
  const n = G_[r];
  if (!n) {
    I.warn(`Unknown arrow type: ${r}`);
    return;
  }
  const o = t === "start" ? "Start" : "End";
  e.attr(`marker-${t}`, `url(${i}#${s}_${a}-${n}${o})`);
}, "addEdgeMarker"), kc = {}, rr = {}, X_ = /* @__PURE__ */ u(async (e, t) => {
  const r = K(), i = ke(r.flowchart.htmlLabels), s = t.labelType === "markdown" ? _r(
    e,
    t.label,
    {
      style: t.labelStyle,
      useHtmlLabels: i,
      addSvgBackground: !0
    },
    r
  ) : await Nr(t.label, t.labelStyle), a = e.insert("g").attr("class", "edgeLabel"), n = a.insert("g").attr("class", "label");
  n.node().appendChild(s);
  let o = s.getBBox();
  if (i) {
    const l = s.children[0], d = yt(s);
    o = l.getBoundingClientRect(), d.attr("width", o.width), d.attr("height", o.height);
  }
  n.attr("transform", "translate(" + -o.width / 2 + ", " + -o.height / 2 + ")"), kc[t.id] = a, t.width = o.width, t.height = o.height;
  let h;
  if (t.startLabelLeft) {
    const l = await Nr(t.startLabelLeft, t.labelStyle), d = e.insert("g").attr("class", "edgeTerminals"), p = d.insert("g").attr("class", "inner");
    h = p.node().appendChild(l);
    const g = l.getBBox();
    p.attr("transform", "translate(" + -g.width / 2 + ", " + -g.height / 2 + ")"), rr[t.id] || (rr[t.id] = {}), rr[t.id].startLeft = d, $a(h, t.startLabelLeft);
  }
  if (t.startLabelRight) {
    const l = await Nr(t.startLabelRight, t.labelStyle), d = e.insert("g").attr("class", "edgeTerminals"), p = d.insert("g").attr("class", "inner");
    h = d.node().appendChild(l), p.node().appendChild(l);
    const g = l.getBBox();
    p.attr("transform", "translate(" + -g.width / 2 + ", " + -g.height / 2 + ")"), rr[t.id] || (rr[t.id] = {}), rr[t.id].startRight = d, $a(h, t.startLabelRight);
  }
  if (t.endLabelLeft) {
    const l = await Nr(t.endLabelLeft, t.labelStyle), d = e.insert("g").attr("class", "edgeTerminals"), p = d.insert("g").attr("class", "inner");
    h = p.node().appendChild(l);
    const g = l.getBBox();
    p.attr("transform", "translate(" + -g.width / 2 + ", " + -g.height / 2 + ")"), d.node().appendChild(l), rr[t.id] || (rr[t.id] = {}), rr[t.id].endLeft = d, $a(h, t.endLabelLeft);
  }
  if (t.endLabelRight) {
    const l = await Nr(t.endLabelRight, t.labelStyle), d = e.insert("g").attr("class", "edgeTerminals"), p = d.insert("g").attr("class", "inner");
    h = p.node().appendChild(l);
    const g = l.getBBox();
    p.attr("transform", "translate(" + -g.width / 2 + ", " + -g.height / 2 + ")"), d.node().appendChild(l), rr[t.id] || (rr[t.id] = {}), rr[t.id].endRight = d, $a(h, t.endLabelRight);
  }
  return s;
}, "insertEdgeLabel");
function $a(e, t) {
  K().flowchart.htmlLabels && e && (e.style.width = t.length * 9 + "px", e.style.height = "12px");
}
u($a, "setTerminalWidth");
var K_ = /* @__PURE__ */ u((e, t) => {
  I.debug("Moving label abc88 ", e.id, e.label, kc[e.id], t);
  let r = t.updatedPath ? t.updatedPath : t.originalPath;
  const i = K(), { subGraphTitleTotalMargin: s } = gn(i);
  if (e.label) {
    const a = kc[e.id];
    let n = e.x, o = e.y;
    if (r) {
      const h = ee.calcLabelPosition(r);
      I.debug(
        "Moving label " + e.label + " from (",
        n,
        ",",
        o,
        ") to (",
        h.x,
        ",",
        h.y,
        ") abc88"
      ), t.updatedPath && (n = h.x, o = h.y);
    }
    a.attr("transform", `translate(${n}, ${o + s / 2})`);
  }
  if (e.startLabelLeft) {
    const a = rr[e.id].startLeft;
    let n = e.x, o = e.y;
    if (r) {
      const h = ee.calcTerminalLabelPosition(e.arrowTypeStart ? 10 : 0, "start_left", r);
      n = h.x, o = h.y;
    }
    a.attr("transform", `translate(${n}, ${o})`);
  }
  if (e.startLabelRight) {
    const a = rr[e.id].startRight;
    let n = e.x, o = e.y;
    if (r) {
      const h = ee.calcTerminalLabelPosition(
        e.arrowTypeStart ? 10 : 0,
        "start_right",
        r
      );
      n = h.x, o = h.y;
    }
    a.attr("transform", `translate(${n}, ${o})`);
  }
  if (e.endLabelLeft) {
    const a = rr[e.id].endLeft;
    let n = e.x, o = e.y;
    if (r) {
      const h = ee.calcTerminalLabelPosition(e.arrowTypeEnd ? 10 : 0, "end_left", r);
      n = h.x, o = h.y;
    }
    a.attr("transform", `translate(${n}, ${o})`);
  }
  if (e.endLabelRight) {
    const a = rr[e.id].endRight;
    let n = e.x, o = e.y;
    if (r) {
      const h = ee.calcTerminalLabelPosition(e.arrowTypeEnd ? 10 : 0, "end_right", r);
      n = h.x, o = h.y;
    }
    a.attr("transform", `translate(${n}, ${o})`);
  }
}, "positionEdgeLabel"), Q_ = /* @__PURE__ */ u((e, t) => {
  const r = e.x, i = e.y, s = Math.abs(t.x - r), a = Math.abs(t.y - i), n = e.width / 2, o = e.height / 2;
  return s >= n || a >= o;
}, "outsideNode"), Z_ = /* @__PURE__ */ u((e, t, r) => {
  I.debug(`intersection calc abc89:
  outsidePoint: ${JSON.stringify(t)}
  insidePoint : ${JSON.stringify(r)}
  node        : x:${e.x} y:${e.y} w:${e.width} h:${e.height}`);
  const i = e.x, s = e.y, a = Math.abs(i - r.x), n = e.width / 2;
  let o = r.x < t.x ? n - a : n + a;
  const h = e.height / 2, l = Math.abs(t.y - r.y), d = Math.abs(t.x - r.x);
  if (Math.abs(s - t.y) * n > Math.abs(i - t.x) * h) {
    let p = r.y < t.y ? t.y - h - s : s - h - t.y;
    o = d * p / l;
    const g = {
      x: r.x < t.x ? r.x + o : r.x - d + o,
      y: r.y < t.y ? r.y + l - p : r.y - l + p
    };
    return o === 0 && (g.x = t.x, g.y = t.y), d === 0 && (g.x = t.x), l === 0 && (g.y = t.y), I.debug(`abc89 topp/bott calc, Q ${l}, q ${p}, R ${d}, r ${o}`, g), g;
  } else {
    r.x < t.x ? o = t.x - n - i : o = i - n - t.x;
    let p = l * o / d, g = r.x < t.x ? r.x + d - o : r.x - d + o, f = r.y < t.y ? r.y + p : r.y - p;
    return I.debug(`sides calc abc89, Q ${l}, q ${p}, R ${d}, r ${o}`, { _x: g, _y: f }), o === 0 && (g = t.x, f = t.y), d === 0 && (g = t.x), l === 0 && (f = t.y), { x: g, y: f };
  }
}, "intersection"), td = /* @__PURE__ */ u((e, t) => {
  I.debug("abc88 cutPathAtIntersect", e, t);
  let r = [], i = e[0], s = !1;
  return e.forEach((a) => {
    if (!Q_(t, a) && !s) {
      const n = Z_(t, i, a);
      let o = !1;
      r.forEach((h) => {
        o = o || h.x === n.x && h.y === n.y;
      }), r.some((h) => h.x === n.x && h.y === n.y) || r.push(n), s = !0;
    } else
      i = a, s || r.push(a);
  }), r;
}, "cutPathAtIntersect"), J_ = /* @__PURE__ */ u(function(e, t, r, i, s, a, n) {
  let o = r.points;
  I.debug("abc88 InsertEdge: edge=", r, "e=", t);
  let h = !1;
  const l = a.node(t.v);
  var d = a.node(t.w);
  d != null && d.intersect && (l != null && l.intersect) && (o = o.slice(1, r.points.length - 1), o.unshift(l.intersect(o[0])), o.push(d.intersect(o[o.length - 1]))), r.toCluster && (I.debug("to cluster abc88", i[r.toCluster]), o = td(r.points, i[r.toCluster].node), h = !0), r.fromCluster && (I.debug("from cluster abc88", i[r.fromCluster]), o = td(o.reverse(), i[r.fromCluster].node).reverse(), h = !0);
  const p = o.filter((A) => !Number.isNaN(A.y));
  let g = _s;
  r.curve && (s === "graph" || s === "flowchart") && (g = r.curve);
  const { x: f, y } = b0(r), m = Ha().x(f).y(y).curve(g);
  let x;
  switch (r.thickness) {
    case "normal":
      x = "edge-thickness-normal";
      break;
    case "thick":
      x = "edge-thickness-thick";
      break;
    case "invisible":
      x = "edge-thickness-thick";
      break;
    default:
      x = "";
  }
  switch (r.pattern) {
    case "solid":
      x += " edge-pattern-solid";
      break;
    case "dotted":
      x += " edge-pattern-dotted";
      break;
    case "dashed":
      x += " edge-pattern-dashed";
      break;
  }
  const b = e.append("path").attr("d", m(p)).attr("id", r.id).attr("class", " " + x + (r.classes ? " " + r.classes : "")).attr("style", r.style);
  let v = "";
  (K().flowchart.arrowMarkerAbsolute || K().state.arrowMarkerAbsolute) && (v = Ao(!0)), j_(b, r, v, n, s);
  let _ = {};
  return h && (_.updatedPath = o), _.originalPath = r.points, _;
}, "insertEdge"), tE = /* @__PURE__ */ u((e) => {
  const t = /* @__PURE__ */ new Set();
  for (const r of e)
    switch (r) {
      case "x":
        t.add("right"), t.add("left");
        break;
      case "y":
        t.add("up"), t.add("down");
        break;
      default:
        t.add(r);
        break;
    }
  return t;
}, "expandAndDeduplicateDirections"), eE = /* @__PURE__ */ u((e, t, r) => {
  const i = tE(e), s = 2, a = t.height + 2 * r.padding, n = a / s, o = t.width + 2 * n + r.padding, h = r.padding / 2;
  return i.has("right") && i.has("left") && i.has("up") && i.has("down") ? [
    // Bottom
    { x: 0, y: 0 },
    { x: n, y: 0 },
    { x: o / 2, y: 2 * h },
    { x: o - n, y: 0 },
    { x: o, y: 0 },
    // Right
    { x: o, y: -a / 3 },
    { x: o + 2 * h, y: -a / 2 },
    { x: o, y: -2 * a / 3 },
    { x: o, y: -a },
    // Top
    { x: o - n, y: -a },
    { x: o / 2, y: -a - 2 * h },
    { x: n, y: -a },
    // Left
    { x: 0, y: -a },
    { x: 0, y: -2 * a / 3 },
    { x: -2 * h, y: -a / 2 },
    { x: 0, y: -a / 3 }
  ] : i.has("right") && i.has("left") && i.has("up") ? [
    { x: n, y: 0 },
    { x: o - n, y: 0 },
    { x: o, y: -a / 2 },
    { x: o - n, y: -a },
    { x: n, y: -a },
    { x: 0, y: -a / 2 }
  ] : i.has("right") && i.has("left") && i.has("down") ? [
    { x: 0, y: 0 },
    { x: n, y: -a },
    { x: o - n, y: -a },
    { x: o, y: 0 }
  ] : i.has("right") && i.has("up") && i.has("down") ? [
    { x: 0, y: 0 },
    { x: o, y: -n },
    { x: o, y: -a + n },
    { x: 0, y: -a }
  ] : i.has("left") && i.has("up") && i.has("down") ? [
    { x: o, y: 0 },
    { x: 0, y: -n },
    { x: 0, y: -a + n },
    { x: o, y: -a }
  ] : i.has("right") && i.has("left") ? [
    { x: n, y: 0 },
    { x: n, y: -h },
    { x: o - n, y: -h },
    { x: o - n, y: 0 },
    { x: o, y: -a / 2 },
    { x: o - n, y: -a },
    { x: o - n, y: -a + h },
    { x: n, y: -a + h },
    { x: n, y: -a },
    { x: 0, y: -a / 2 }
  ] : i.has("up") && i.has("down") ? [
    // Bottom center
    { x: o / 2, y: 0 },
    // Left pont of bottom arrow
    { x: 0, y: -h },
    { x: n, y: -h },
    // Left top over vertical section
    { x: n, y: -a + h },
    { x: 0, y: -a + h },
    // Top of arrow
    { x: o / 2, y: -a },
    { x: o, y: -a + h },
    // Top of right vertical bar
    { x: o - n, y: -a + h },
    { x: o - n, y: -h },
    { x: o, y: -h }
  ] : i.has("right") && i.has("up") ? [
    { x: 0, y: 0 },
    { x: o, y: -n },
    { x: 0, y: -a }
  ] : i.has("right") && i.has("down") ? [
    { x: 0, y: 0 },
    { x: o, y: 0 },
    { x: 0, y: -a }
  ] : i.has("left") && i.has("up") ? [
    { x: o, y: 0 },
    { x: 0, y: -n },
    { x: o, y: -a }
  ] : i.has("left") && i.has("down") ? [
    { x: o, y: 0 },
    { x: 0, y: 0 },
    { x: o, y: -a }
  ] : i.has("right") ? [
    { x: n, y: -h },
    { x: n, y: -h },
    { x: o - n, y: -h },
    { x: o - n, y: 0 },
    { x: o, y: -a / 2 },
    { x: o - n, y: -a },
    { x: o - n, y: -a + h },
    // top left corner of arrow
    { x: n, y: -a + h },
    { x: n, y: -a + h }
  ] : i.has("left") ? [
    { x: n, y: 0 },
    { x: n, y: -h },
    // Two points, the right corners
    { x: o - n, y: -h },
    { x: o - n, y: -a + h },
    { x: n, y: -a + h },
    { x: n, y: -a },
    { x: 0, y: -a / 2 }
  ] : i.has("up") ? [
    // Bottom center
    { x: n, y: -h },
    // Left top over vertical section
    { x: n, y: -a + h },
    { x: 0, y: -a + h },
    // Top of arrow
    { x: o / 2, y: -a },
    { x: o, y: -a + h },
    // Top of right vertical bar
    { x: o - n, y: -a + h },
    { x: o - n, y: -h }
  ] : i.has("down") ? [
    // Bottom center
    { x: o / 2, y: 0 },
    // Left pont of bottom arrow
    { x: 0, y: -h },
    { x: n, y: -h },
    // Left top over vertical section
    { x: n, y: -a + h },
    { x: o - n, y: -a + h },
    { x: o - n, y: -h },
    { x: o, y: -h }
  ] : [{ x: 0, y: 0 }];
}, "getArrowPoints");
function $y(e, t) {
  return e.intersect(t);
}
u($y, "intersectNode");
var rE = $y;
function Vy(e, t, r, i) {
  var s = e.x, a = e.y, n = s - i.x, o = a - i.y, h = Math.sqrt(t * t * o * o + r * r * n * n), l = Math.abs(t * r * n / h);
  i.x < s && (l = -l);
  var d = Math.abs(t * r * o / h);
  return i.y < a && (d = -d), { x: s + l, y: a + d };
}
u(Vy, "intersectEllipse");
var zy = Vy;
function Wy(e, t, r) {
  return zy(e, t, t, r);
}
u(Wy, "intersectCircle");
var iE = Wy;
function qy(e, t, r, i) {
  var s, a, n, o, h, l, d, p, g, f, y, m, x, b, v;
  if (s = t.y - e.y, n = e.x - t.x, h = t.x * e.y - e.x * t.y, g = s * r.x + n * r.y + h, f = s * i.x + n * i.y + h, !(g !== 0 && f !== 0 && vc(g, f)) && (a = i.y - r.y, o = r.x - i.x, l = i.x * r.y - r.x * i.y, d = a * e.x + o * e.y + l, p = a * t.x + o * t.y + l, !(d !== 0 && p !== 0 && vc(d, p)) && (y = s * o - a * n, y !== 0)))
    return m = Math.abs(y / 2), x = n * l - o * h, b = x < 0 ? (x - m) / y : (x + m) / y, x = a * h - s * l, v = x < 0 ? (x - m) / y : (x + m) / y, { x: b, y: v };
}
u(qy, "intersectLine");
function vc(e, t) {
  return e * t > 0;
}
u(vc, "sameSign");
var sE = qy, aE = Yy;
function Yy(e, t, r) {
  var i = e.x, s = e.y, a = [], n = Number.POSITIVE_INFINITY, o = Number.POSITIVE_INFINITY;
  typeof t.forEach == "function" ? t.forEach(function(y) {
    n = Math.min(n, y.x), o = Math.min(o, y.y);
  }) : (n = Math.min(n, t.x), o = Math.min(o, t.y));
  for (var h = i - e.width / 2 - n, l = s - e.height / 2 - o, d = 0; d < t.length; d++) {
    var p = t[d], g = t[d < t.length - 1 ? d + 1 : 0], f = sE(
      e,
      r,
      { x: h + p.x, y: l + p.y },
      { x: h + g.x, y: l + g.y }
    );
    f && a.push(f);
  }
  return a.length ? (a.length > 1 && a.sort(function(y, m) {
    var x = y.x - r.x, b = y.y - r.y, v = Math.sqrt(x * x + b * b), _ = m.x - r.x, A = m.y - r.y, S = Math.sqrt(_ * _ + A * A);
    return v < S ? -1 : v === S ? 0 : 1;
  }), a[0]) : e;
}
u(Yy, "intersectPolygon");
var nE = /* @__PURE__ */ u((e, t) => {
  var r = e.x, i = e.y, s = t.x - r, a = t.y - i, n = e.width / 2, o = e.height / 2, h, l;
  return Math.abs(a) * n > Math.abs(s) * o ? (a < 0 && (o = -o), h = a === 0 ? 0 : o * s / a, l = o) : (s < 0 && (n = -n), h = n, l = s === 0 ? 0 : n * a / s), { x: r + h, y: i + l };
}, "intersectRect"), oE = nE, Te = {
  node: rE,
  circle: iE,
  ellipse: zy,
  polygon: aE,
  rect: oE
}, Xe = /* @__PURE__ */ u(async (e, t, r, i) => {
  const s = K();
  let a;
  const n = t.useHtmlLabels || ke(s.flowchart.htmlLabels);
  r ? a = r : a = "node default";
  const o = e.insert("g").attr("class", a).attr("id", t.domId || t.id), h = o.insert("g").attr("class", "label").attr("style", t.labelStyle);
  let l;
  t.labelText === void 0 ? l = "" : l = typeof t.labelText == "string" ? t.labelText : t.labelText[0];
  const d = h.node();
  let p;
  t.labelType === "markdown" ? p = _r(
    h,
    ge(Qr(l), s),
    {
      useHtmlLabels: n,
      width: t.width || s.flowchart.wrappingWidth,
      classes: "markdown-node-label"
    },
    s
  ) : p = d.appendChild(
    await Nr(
      ge(Qr(l), s),
      t.labelStyle,
      !1,
      i
    )
  );
  let g = p.getBBox();
  const f = t.padding / 2;
  if (ke(s.flowchart.htmlLabels)) {
    const y = p.children[0], m = yt(p), x = y.getElementsByTagName("img");
    if (x) {
      const b = l.replace(/<img[^>]*>/g, "").trim() === "";
      await Promise.all(
        [...x].map(
          (v) => new Promise((_) => {
            function A() {
              if (v.style.display = "flex", v.style.flexDirection = "column", b) {
                const S = s.fontSize ? s.fontSize : window.getComputedStyle(document.body).fontSize, L = parseInt(S, 10) * 5 + "px";
                v.style.minWidth = L, v.style.maxWidth = L;
              } else
                v.style.width = "100%";
              _(v);
            }
            u(A, "setupImage"), setTimeout(() => {
              v.complete && A();
            }), v.addEventListener("error", A), v.addEventListener("load", A);
          })
        )
      );
    }
    g = y.getBoundingClientRect(), m.attr("width", g.width), m.attr("height", g.height);
  }
  return n ? h.attr("transform", "translate(" + -g.width / 2 + ", " + -g.height / 2 + ")") : h.attr("transform", "translate(0, " + -g.height / 2 + ")"), t.centerLabel && h.attr("transform", "translate(" + -g.width / 2 + ", " + -g.height / 2 + ")"), h.insert("rect", ":first-child"), { shapeSvg: o, bbox: g, halfPadding: f, label: h };
}, "labelHelper"), Ae = /* @__PURE__ */ u((e, t) => {
  const r = t.node().getBBox();
  e.width = r.width, e.height = r.height;
}, "updateNodeBounds");
function Wr(e, t, r, i) {
  return e.insert("polygon", ":first-child").attr(
    "points",
    i.map(function(s) {
      return s.x + "," + s.y;
    }).join(" ")
  ).attr("class", "label-container").attr("transform", "translate(" + -t / 2 + "," + r / 2 + ")");
}
u(Wr, "insertPolygonShape");
var lE = /* @__PURE__ */ u(async (e, t) => {
  t.useHtmlLabels || K().flowchart.htmlLabels || (t.centerLabel = !0);
  const { shapeSvg: i, bbox: s, halfPadding: a } = await Xe(
    e,
    t,
    "node " + t.classes,
    !0
  );
  I.info("Classes = ", t.classes);
  const n = i.insert("rect", ":first-child");
  return n.attr("rx", t.rx).attr("ry", t.ry).attr("x", -s.width / 2 - a).attr("y", -s.height / 2 - a).attr("width", s.width + t.padding).attr("height", s.height + t.padding), Ae(t, n), t.intersect = function(o) {
    return Te.rect(t, o);
  }, i;
}, "note"), cE = lE, ed = /* @__PURE__ */ u((e) => e ? " " + e : "", "formatClass"), Ar = /* @__PURE__ */ u((e, t) => `${t || "node default"}${ed(e.classes)} ${ed(
  e.class
)}`, "getClassesFromNode"), rd = /* @__PURE__ */ u(async (e, t) => {
  const { shapeSvg: r, bbox: i } = await Xe(
    e,
    t,
    Ar(t, void 0),
    !0
  ), s = i.width + t.padding, a = i.height + t.padding, n = s + a, o = [
    { x: n / 2, y: 0 },
    { x: n, y: -n / 2 },
    { x: n / 2, y: -n },
    { x: 0, y: -n / 2 }
  ];
  I.info("Question main (Circle)");
  const h = Wr(r, n, n, o);
  return h.attr("style", t.style), Ae(t, h), t.intersect = function(l) {
    return I.warn("Intersect called"), Te.polygon(t, o, l);
  }, r;
}, "question"), hE = /* @__PURE__ */ u((e, t) => {
  const r = e.insert("g").attr("class", "node default").attr("id", t.domId || t.id), i = 28, s = [
    { x: 0, y: i / 2 },
    { x: i / 2, y: 0 },
    { x: 0, y: -28 / 2 },
    { x: -28 / 2, y: 0 }
  ];
  return r.insert("polygon", ":first-child").attr(
    "points",
    s.map(function(n) {
      return n.x + "," + n.y;
    }).join(" ")
  ).attr("class", "state-start").attr("r", 7).attr("width", 28).attr("height", 28), t.width = 28, t.height = 28, t.intersect = function(n) {
    return Te.circle(t, 14, n);
  }, r;
}, "choice"), uE = /* @__PURE__ */ u(async (e, t) => {
  const { shapeSvg: r, bbox: i } = await Xe(
    e,
    t,
    Ar(t, void 0),
    !0
  ), s = 4, a = i.height + t.padding, n = a / s, o = i.width + 2 * n + t.padding, h = [
    { x: n, y: 0 },
    { x: o - n, y: 0 },
    { x: o, y: -a / 2 },
    { x: o - n, y: -a },
    { x: n, y: -a },
    { x: 0, y: -a / 2 }
  ], l = Wr(r, o, a, h);
  return l.attr("style", t.style), Ae(t, l), t.intersect = function(d) {
    return Te.polygon(t, h, d);
  }, r;
}, "hexagon"), dE = /* @__PURE__ */ u(async (e, t) => {
  const { shapeSvg: r, bbox: i } = await Xe(e, t, void 0, !0), s = 2, a = i.height + 2 * t.padding, n = a / s, o = i.width + 2 * n + t.padding, h = eE(t.directions, i, t), l = Wr(r, o, a, h);
  return l.attr("style", t.style), Ae(t, l), t.intersect = function(d) {
    return Te.polygon(t, h, d);
  }, r;
}, "block_arrow"), pE = /* @__PURE__ */ u(async (e, t) => {
  const { shapeSvg: r, bbox: i } = await Xe(
    e,
    t,
    Ar(t, void 0),
    !0
  ), s = i.width + t.padding, a = i.height + t.padding, n = [
    { x: -a / 2, y: 0 },
    { x: s, y: 0 },
    { x: s, y: -a },
    { x: -a / 2, y: -a },
    { x: 0, y: -a / 2 }
  ];
  return Wr(r, s, a, n).attr("style", t.style), t.width = s + a, t.height = a, t.intersect = function(h) {
    return Te.polygon(t, n, h);
  }, r;
}, "rect_left_inv_arrow"), gE = /* @__PURE__ */ u(async (e, t) => {
  const { shapeSvg: r, bbox: i } = await Xe(e, t, Ar(t), !0), s = i.width + t.padding, a = i.height + t.padding, n = [
    { x: -2 * a / 6, y: 0 },
    { x: s - a / 6, y: 0 },
    { x: s + 2 * a / 6, y: -a },
    { x: a / 6, y: -a }
  ], o = Wr(r, s, a, n);
  return o.attr("style", t.style), Ae(t, o), t.intersect = function(h) {
    return Te.polygon(t, n, h);
  }, r;
}, "lean_right"), fE = /* @__PURE__ */ u(async (e, t) => {
  const { shapeSvg: r, bbox: i } = await Xe(
    e,
    t,
    Ar(t, void 0),
    !0
  ), s = i.width + t.padding, a = i.height + t.padding, n = [
    { x: 2 * a / 6, y: 0 },
    { x: s + a / 6, y: 0 },
    { x: s - 2 * a / 6, y: -a },
    { x: -a / 6, y: -a }
  ], o = Wr(r, s, a, n);
  return o.attr("style", t.style), Ae(t, o), t.intersect = function(h) {
    return Te.polygon(t, n, h);
  }, r;
}, "lean_left"), yE = /* @__PURE__ */ u(async (e, t) => {
  const { shapeSvg: r, bbox: i } = await Xe(
    e,
    t,
    Ar(t, void 0),
    !0
  ), s = i.width + t.padding, a = i.height + t.padding, n = [
    { x: -2 * a / 6, y: 0 },
    { x: s + 2 * a / 6, y: 0 },
    { x: s - a / 6, y: -a },
    { x: a / 6, y: -a }
  ], o = Wr(r, s, a, n);
  return o.attr("style", t.style), Ae(t, o), t.intersect = function(h) {
    return Te.polygon(t, n, h);
  }, r;
}, "trapezoid"), mE = /* @__PURE__ */ u(async (e, t) => {
  const { shapeSvg: r, bbox: i } = await Xe(
    e,
    t,
    Ar(t, void 0),
    !0
  ), s = i.width + t.padding, a = i.height + t.padding, n = [
    { x: a / 6, y: 0 },
    { x: s - a / 6, y: 0 },
    { x: s + 2 * a / 6, y: -a },
    { x: -2 * a / 6, y: -a }
  ], o = Wr(r, s, a, n);
  return o.attr("style", t.style), Ae(t, o), t.intersect = function(h) {
    return Te.polygon(t, n, h);
  }, r;
}, "inv_trapezoid"), xE = /* @__PURE__ */ u(async (e, t) => {
  const { shapeSvg: r, bbox: i } = await Xe(
    e,
    t,
    Ar(t, void 0),
    !0
  ), s = i.width + t.padding, a = i.height + t.padding, n = [
    { x: 0, y: 0 },
    { x: s + a / 2, y: 0 },
    { x: s, y: -a / 2 },
    { x: s + a / 2, y: -a },
    { x: 0, y: -a }
  ], o = Wr(r, s, a, n);
  return o.attr("style", t.style), Ae(t, o), t.intersect = function(h) {
    return Te.polygon(t, n, h);
  }, r;
}, "rect_right_inv_arrow"), bE = /* @__PURE__ */ u(async (e, t) => {
  const { shapeSvg: r, bbox: i } = await Xe(
    e,
    t,
    Ar(t, void 0),
    !0
  ), s = i.width + t.padding, a = s / 2, n = a / (2.5 + s / 50), o = i.height + n + t.padding, h = "M 0," + n + " a " + a + "," + n + " 0,0,0 " + s + " 0 a " + a + "," + n + " 0,0,0 " + -s + " 0 l 0," + o + " a " + a + "," + n + " 0,0,0 " + s + " 0 l 0," + -o, l = r.attr("label-offset-y", n).insert("path", ":first-child").attr("style", t.style).attr("d", h).attr("transform", "translate(" + -s / 2 + "," + -(o / 2 + n) + ")");
  return Ae(t, l), t.intersect = function(d) {
    const p = Te.rect(t, d), g = p.x - t.x;
    if (a != 0 && (Math.abs(g) < t.width / 2 || Math.abs(g) == t.width / 2 && Math.abs(p.y - t.y) > t.height / 2 - n)) {
      let f = n * n * (1 - g * g / (a * a));
      f != 0 && (f = Math.sqrt(f)), f = n - f, d.y - t.y > 0 && (f = -f), p.y += f;
    }
    return p;
  }, r;
}, "cylinder"), kE = /* @__PURE__ */ u(async (e, t) => {
  const { shapeSvg: r, bbox: i, halfPadding: s } = await Xe(
    e,
    t,
    "node " + t.classes + " " + t.class,
    !0
  ), a = r.insert("rect", ":first-child"), n = t.positioned ? t.width : i.width + t.padding, o = t.positioned ? t.height : i.height + t.padding, h = t.positioned ? -n / 2 : -i.width / 2 - s, l = t.positioned ? -o / 2 : -i.height / 2 - s;
  if (a.attr("class", "basic label-container").attr("style", t.style).attr("rx", t.rx).attr("ry", t.ry).attr("x", h).attr("y", l).attr("width", n).attr("height", o), t.props) {
    const d = new Set(Object.keys(t.props));
    t.props.borders && (Ko(a, t.props.borders, n, o), d.delete("borders")), d.forEach((p) => {
      I.warn(`Unknown node property ${p}`);
    });
  }
  return Ae(t, a), t.intersect = function(d) {
    return Te.rect(t, d);
  }, r;
}, "rect"), vE = /* @__PURE__ */ u(async (e, t) => {
  const { shapeSvg: r, bbox: i, halfPadding: s } = await Xe(
    e,
    t,
    "node " + t.classes,
    !0
  ), a = r.insert("rect", ":first-child"), n = t.positioned ? t.width : i.width + t.padding, o = t.positioned ? t.height : i.height + t.padding, h = t.positioned ? -n / 2 : -i.width / 2 - s, l = t.positioned ? -o / 2 : -i.height / 2 - s;
  if (a.attr("class", "basic cluster composite label-container").attr("style", t.style).attr("rx", t.rx).attr("ry", t.ry).attr("x", h).attr("y", l).attr("width", n).attr("height", o), t.props) {
    const d = new Set(Object.keys(t.props));
    t.props.borders && (Ko(a, t.props.borders, n, o), d.delete("borders")), d.forEach((p) => {
      I.warn(`Unknown node property ${p}`);
    });
  }
  return Ae(t, a), t.intersect = function(d) {
    return Te.rect(t, d);
  }, r;
}, "composite"), SE = /* @__PURE__ */ u(async (e, t) => {
  const { shapeSvg: r } = await Xe(e, t, "label", !0);
  I.trace("Classes = ", t.class);
  const i = r.insert("rect", ":first-child"), s = 0, a = 0;
  if (i.attr("width", s).attr("height", a), r.attr("class", "label edgeLabel"), t.props) {
    const n = new Set(Object.keys(t.props));
    t.props.borders && (Ko(i, t.props.borders, s, a), n.delete("borders")), n.forEach((o) => {
      I.warn(`Unknown node property ${o}`);
    });
  }
  return Ae(t, i), t.intersect = function(n) {
    return Te.rect(t, n);
  }, r;
}, "labelRect");
function Ko(e, t, r, i) {
  const s = [], a = /* @__PURE__ */ u((o) => {
    s.push(o, 0);
  }, "addBorder"), n = /* @__PURE__ */ u((o) => {
    s.push(0, o);
  }, "skipBorder");
  t.includes("t") ? (I.debug("add top border"), a(r)) : n(r), t.includes("r") ? (I.debug("add right border"), a(i)) : n(i), t.includes("b") ? (I.debug("add bottom border"), a(r)) : n(r), t.includes("l") ? (I.debug("add left border"), a(i)) : n(i), e.attr("stroke-dasharray", s.join(" "));
}
u(Ko, "applyNodePropertyBorders");
var CE = /* @__PURE__ */ u(async (e, t) => {
  let r;
  t.classes ? r = "node " + t.classes : r = "node default";
  const i = e.insert("g").attr("class", r).attr("id", t.domId || t.id), s = i.insert("rect", ":first-child"), a = i.insert("line"), n = i.insert("g").attr("class", "label"), o = t.labelText.flat ? t.labelText.flat() : t.labelText;
  let h = "";
  typeof o == "object" ? h = o[0] : h = o, I.info("Label text abc79", h, o, typeof o == "object");
  const l = n.node().appendChild(await Nr(h, t.labelStyle, !0, !0));
  let d = { width: 0, height: 0 };
  if (ke(K().flowchart.htmlLabels)) {
    const m = l.children[0], x = yt(l);
    d = m.getBoundingClientRect(), x.attr("width", d.width), x.attr("height", d.height);
  }
  I.info("Text 2", o);
  const p = o.slice(1, o.length);
  let g = l.getBBox();
  const f = n.node().appendChild(
    await Nr(
      p.join ? p.join("<br/>") : p,
      t.labelStyle,
      !0,
      !0
    )
  );
  if (ke(K().flowchart.htmlLabels)) {
    const m = f.children[0], x = yt(f);
    d = m.getBoundingClientRect(), x.attr("width", d.width), x.attr("height", d.height);
  }
  const y = t.padding / 2;
  return yt(f).attr(
    "transform",
    "translate( " + // (titleBox.width - bbox.width) / 2 +
    (d.width > g.width ? 0 : (g.width - d.width) / 2) + ", " + (g.height + y + 5) + ")"
  ), yt(l).attr(
    "transform",
    "translate( " + // (titleBox.width - bbox.width) / 2 +
    (d.width < g.width ? 0 : -(g.width - d.width) / 2) + ", 0)"
  ), d = n.node().getBBox(), n.attr(
    "transform",
    "translate(" + -d.width / 2 + ", " + (-d.height / 2 - y + 3) + ")"
  ), s.attr("class", "outer title-state").attr("x", -d.width / 2 - y).attr("y", -d.height / 2 - y).attr("width", d.width + t.padding).attr("height", d.height + t.padding), a.attr("class", "divider").attr("x1", -d.width / 2 - y).attr("x2", d.width / 2 + y).attr("y1", -d.height / 2 - y + g.height + y).attr("y2", -d.height / 2 - y + g.height + y), Ae(t, s), t.intersect = function(m) {
    return Te.rect(t, m);
  }, i;
}, "rectWithTitle"), wE = /* @__PURE__ */ u(async (e, t) => {
  const { shapeSvg: r, bbox: i } = await Xe(
    e,
    t,
    Ar(t, void 0),
    !0
  ), s = i.height + t.padding, a = i.width + s / 4 + t.padding, n = r.insert("rect", ":first-child").attr("style", t.style).attr("rx", s / 2).attr("ry", s / 2).attr("x", -a / 2).attr("y", -s / 2).attr("width", a).attr("height", s);
  return Ae(t, n), t.intersect = function(o) {
    return Te.rect(t, o);
  }, r;
}, "stadium"), TE = /* @__PURE__ */ u(async (e, t) => {
  const { shapeSvg: r, bbox: i, halfPadding: s } = await Xe(
    e,
    t,
    Ar(t, void 0),
    !0
  ), a = r.insert("circle", ":first-child");
  return a.attr("style", t.style).attr("rx", t.rx).attr("ry", t.ry).attr("r", i.width / 2 + s).attr("width", i.width + t.padding).attr("height", i.height + t.padding), I.info("Circle main"), Ae(t, a), t.intersect = function(n) {
    return I.info("Circle intersect", t, i.width / 2 + s, n), Te.circle(t, i.width / 2 + s, n);
  }, r;
}, "circle"), _E = /* @__PURE__ */ u(async (e, t) => {
  const { shapeSvg: r, bbox: i, halfPadding: s } = await Xe(
    e,
    t,
    Ar(t, void 0),
    !0
  ), a = 5, n = r.insert("g", ":first-child"), o = n.insert("circle"), h = n.insert("circle");
  return n.attr("class", t.class), o.attr("style", t.style).attr("rx", t.rx).attr("ry", t.ry).attr("r", i.width / 2 + s + a).attr("width", i.width + t.padding + a * 2).attr("height", i.height + t.padding + a * 2), h.attr("style", t.style).attr("rx", t.rx).attr("ry", t.ry).attr("r", i.width / 2 + s).attr("width", i.width + t.padding).attr("height", i.height + t.padding), I.info("DoubleCircle main"), Ae(t, o), t.intersect = function(l) {
    return I.info("DoubleCircle intersect", t, i.width / 2 + s + a, l), Te.circle(t, i.width / 2 + s + a, l);
  }, r;
}, "doublecircle"), EE = /* @__PURE__ */ u(async (e, t) => {
  const { shapeSvg: r, bbox: i } = await Xe(
    e,
    t,
    Ar(t, void 0),
    !0
  ), s = i.width + t.padding, a = i.height + t.padding, n = [
    { x: 0, y: 0 },
    { x: s, y: 0 },
    { x: s, y: -a },
    { x: 0, y: -a },
    { x: 0, y: 0 },
    { x: -8, y: 0 },
    { x: s + 8, y: 0 },
    { x: s + 8, y: -a },
    { x: -8, y: -a },
    { x: -8, y: 0 }
  ], o = Wr(r, s, a, n);
  return o.attr("style", t.style), Ae(t, o), t.intersect = function(h) {
    return Te.polygon(t, n, h);
  }, r;
}, "subroutine"), AE = /* @__PURE__ */ u((e, t) => {
  const r = e.insert("g").attr("class", "node default").attr("id", t.domId || t.id), i = r.insert("circle", ":first-child");
  return i.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14), Ae(t, i), t.intersect = function(s) {
    return Te.circle(t, 7, s);
  }, r;
}, "start"), id = /* @__PURE__ */ u((e, t, r) => {
  const i = e.insert("g").attr("class", "node default").attr("id", t.domId || t.id);
  let s = 70, a = 10;
  r === "LR" && (s = 10, a = 70);
  const n = i.append("rect").attr("x", -1 * s / 2).attr("y", -1 * a / 2).attr("width", s).attr("height", a).attr("class", "fork-join");
  return Ae(t, n), t.height = t.height + t.padding / 2, t.width = t.width + t.padding / 2, t.intersect = function(o) {
    return Te.rect(t, o);
  }, i;
}, "forkJoin"), LE = /* @__PURE__ */ u((e, t) => {
  const r = e.insert("g").attr("class", "node default").attr("id", t.domId || t.id), i = r.insert("circle", ":first-child"), s = r.insert("circle", ":first-child");
  return s.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14), i.attr("class", "state-end").attr("r", 5).attr("width", 10).attr("height", 10), Ae(t, s), t.intersect = function(a) {
    return Te.circle(t, 7, a);
  }, r;
}, "end"), BE = /* @__PURE__ */ u(async (e, t) => {
  var T;
  const r = t.padding / 2, i = 4, s = 8;
  let a;
  t.classes ? a = "node " + t.classes : a = "node default";
  const n = e.insert("g").attr("class", a).attr("id", t.domId || t.id), o = n.insert("rect", ":first-child"), h = n.insert("line"), l = n.insert("line");
  let d = 0, p = i;
  const g = n.insert("g").attr("class", "label");
  let f = 0;
  const y = (T = t.classData.annotations) == null ? void 0 : T[0], m = t.classData.annotations[0] ? "" + t.classData.annotations[0] + "" : "", x = g.node().appendChild(await Nr(m, t.labelStyle, !0, !0));
  let b = x.getBBox();
  if (ke(K().flowchart.htmlLabels)) {
    const C = x.children[0], E = yt(x);
    b = C.getBoundingClientRect(), E.attr("width", b.width), E.attr("height", b.height);
  }
  t.classData.annotations[0] && (p += b.height + i, d += b.width);
  let v = t.classData.label;
  t.classData.type !== void 0 && t.classData.type !== "" && (K().flowchart.htmlLabels ? v += "&lt;" + t.classData.type + "&gt;" : v += "<" + t.classData.type + ">");
  const _ = g.node().appendChild(await Nr(v, t.labelStyle, !0, !0));
  yt(_).attr("class", "classTitle");
  let A = _.getBBox();
  if (ke(K().flowchart.htmlLabels)) {
    const C = _.children[0], E = yt(_);
    A = C.getBoundingClientRect(), E.attr("width", A.width), E.attr("height", A.height);
  }
  p += A.height + i, A.width > d && (d = A.width);
  const S = [];
  t.classData.members.forEach(async (C) => {
    const E = C.getDisplayDetails();
    let w = E.displayText;
    K().flowchart.htmlLabels && (w = w.replace(/</g, "&lt;").replace(/>/g, "&gt;"));
    const W = g.node().appendChild(
      await Nr(
        w,
        E.cssStyle ? E.cssStyle : t.labelStyle,
        !0,
        !0
      )
    );
    let N = W.getBBox();
    if (ke(K().flowchart.htmlLabels)) {
      const B = W.children[0], R = yt(W);
      N = B.getBoundingClientRect(), R.attr("width", N.width), R.attr("height", N.height);
    }
    N.width > d && (d = N.width), p += N.height + i, S.push(W);
  }), p += s;
  const k = [];
  if (t.classData.methods.forEach(async (C) => {
    const E = C.getDisplayDetails();
    let w = E.displayText;
    K().flowchart.htmlLabels && (w = w.replace(/</g, "&lt;").replace(/>/g, "&gt;"));
    const W = g.node().appendChild(
      await Nr(
        w,
        E.cssStyle ? E.cssStyle : t.labelStyle,
        !0,
        !0
      )
    );
    let N = W.getBBox();
    if (ke(K().flowchart.htmlLabels)) {
      const B = W.children[0], R = yt(W);
      N = B.getBoundingClientRect(), R.attr("width", N.width), R.attr("height", N.height);
    }
    N.width > d && (d = N.width), p += N.height + i, k.push(W);
  }), p += s, y) {
    let C = (d - b.width) / 2;
    yt(x).attr(
      "transform",
      "translate( " + (-1 * d / 2 + C) + ", " + -1 * p / 2 + ")"
    ), f = b.height + i;
  }
  let L = (d - A.width) / 2;
  return yt(_).attr(
    "transform",
    "translate( " + (-1 * d / 2 + L) + ", " + (-1 * p / 2 + f) + ")"
  ), f += A.height + i, h.attr("class", "divider").attr("x1", -d / 2 - r).attr("x2", d / 2 + r).attr("y1", -p / 2 - r + s + f).attr("y2", -p / 2 - r + s + f), f += s, S.forEach((C) => {
    yt(C).attr(
      "transform",
      "translate( " + -d / 2 + ", " + (-1 * p / 2 + f + s / 2) + ")"
    );
    const E = C == null ? void 0 : C.getBBox();
    f += ((E == null ? void 0 : E.height) ?? 0) + i;
  }), f += s, l.attr("class", "divider").attr("x1", -d / 2 - r).attr("x2", d / 2 + r).attr("y1", -p / 2 - r + s + f).attr("y2", -p / 2 - r + s + f), f += s, k.forEach((C) => {
    yt(C).attr(
      "transform",
      "translate( " + -d / 2 + ", " + (-1 * p / 2 + f) + ")"
    );
    const E = C == null ? void 0 : C.getBBox();
    f += ((E == null ? void 0 : E.height) ?? 0) + i;
  }), o.attr("style", t.style).attr("class", "outer title-state").attr("x", -d / 2 - r).attr("y", -(p / 2) - r).attr("width", d + t.padding).attr("height", p + t.padding), Ae(t, o), t.intersect = function(C) {
    return Te.rect(t, C);
  }, n;
}, "class_box"), sd = {
  rhombus: rd,
  composite: vE,
  question: rd,
  rect: kE,
  labelRect: SE,
  rectWithTitle: CE,
  choice: hE,
  circle: TE,
  doublecircle: _E,
  stadium: wE,
  hexagon: uE,
  block_arrow: dE,
  rect_left_inv_arrow: pE,
  lean_right: gE,
  lean_left: fE,
  trapezoid: yE,
  inv_trapezoid: mE,
  rect_right_inv_arrow: xE,
  cylinder: bE,
  start: AE,
  end: LE,
  note: cE,
  subroutine: EE,
  fork: id,
  join: id,
  class_box: BE
}, zn = {}, Hy = /* @__PURE__ */ u(async (e, t, r) => {
  let i, s;
  if (t.link) {
    let a;
    K().securityLevel === "sandbox" ? a = "_top" : t.linkTarget && (a = t.linkTarget || "_blank"), i = e.insert("svg:a").attr("xlink:href", t.link).attr("target", a), s = await sd[t.shape](i, t, r);
  } else
    s = await sd[t.shape](e, t, r), i = s;
  return t.tooltip && s.attr("title", t.tooltip), t.class && s.attr("class", "node default " + t.class), zn[t.id] = i, t.haveCallback && zn[t.id].attr("class", zn[t.id].attr("class") + " clickable"), i;
}, "insertNode"), DE = /* @__PURE__ */ u((e) => {
  const t = zn[e.id];
  I.trace(
    "Transforming node",
    e.diff,
    e,
    "translate(" + (e.x - e.width / 2 - 5) + ", " + e.width / 2 + ")"
  );
  const r = 8, i = e.diff || 0;
  return e.clusterNode ? t.attr(
    "transform",
    "translate(" + (e.x + i - e.width / 2) + ", " + (e.y - e.height / 2 - r) + ")"
  ) : t.attr("transform", "translate(" + e.x + ", " + e.y + ")"), i;
}, "positionNode");
function zh(e, t, r = !1) {
  var g, f, y;
  const i = e;
  let s = "default";
  (((g = i == null ? void 0 : i.classes) == null ? void 0 : g.length) || 0) > 0 && (s = ((i == null ? void 0 : i.classes) ?? []).join(" ")), s = s + " flowchart-label";
  let a = 0, n = "", o;
  switch (i.type) {
    case "round":
      a = 5, n = "rect";
      break;
    case "composite":
      a = 0, n = "composite", o = 0;
      break;
    case "square":
      n = "rect";
      break;
    case "diamond":
      n = "question";
      break;
    case "hexagon":
      n = "hexagon";
      break;
    case "block_arrow":
      n = "block_arrow";
      break;
    case "odd":
      n = "rect_left_inv_arrow";
      break;
    case "lean_right":
      n = "lean_right";
      break;
    case "lean_left":
      n = "lean_left";
      break;
    case "trapezoid":
      n = "trapezoid";
      break;
    case "inv_trapezoid":
      n = "inv_trapezoid";
      break;
    case "rect_left_inv_arrow":
      n = "rect_left_inv_arrow";
      break;
    case "circle":
      n = "circle";
      break;
    case "ellipse":
      n = "ellipse";
      break;
    case "stadium":
      n = "stadium";
      break;
    case "subroutine":
      n = "subroutine";
      break;
    case "cylinder":
      n = "cylinder";
      break;
    case "group":
      n = "rect";
      break;
    case "doublecircle":
      n = "doublecircle";
      break;
    default:
      n = "rect";
  }
  const h = Yc((i == null ? void 0 : i.styles) ?? []), l = i.label, d = i.size ?? { width: 0, height: 0, x: 0, y: 0 };
  return {
    labelStyle: h.labelStyle,
    shape: n,
    labelText: l,
    rx: a,
    ry: a,
    class: s,
    style: h.style,
    id: i.id,
    directions: i.directions,
    width: d.width,
    height: d.height,
    x: d.x,
    y: d.y,
    positioned: r,
    intersect: void 0,
    type: i.type,
    padding: o ?? ((y = (f = fe()) == null ? void 0 : f.block) == null ? void 0 : y.padding) ?? 0
  };
}
u(zh, "getNodeFromBlock");
async function Uy(e, t, r) {
  const i = zh(t, r, !1);
  if (i.type === "group")
    return;
  const s = fe(), a = await Hy(e, i, { config: s }), n = a.node().getBBox(), o = r.getBlock(i.id);
  o.size = { width: n.width, height: n.height, x: 0, y: 0, node: a }, r.setBlock(o), a.remove();
}
u(Uy, "calculateBlockSize");
async function jy(e, t, r) {
  const i = zh(t, r, !0);
  if (r.getBlock(i.id).type !== "space") {
    const a = fe();
    await Hy(e, i, { config: a }), t.intersect = i == null ? void 0 : i.intersect, DE(i);
  }
}
u(jy, "insertBlockPositioned");
async function Qo(e, t, r, i) {
  for (const s of t)
    await i(e, s, r), s.children && await Qo(e, s.children, r, i);
}
u(Qo, "performOperations");
async function Gy(e, t, r) {
  await Qo(e, t, r, Uy);
}
u(Gy, "calculateBlockSizes");
async function Xy(e, t, r) {
  await Qo(e, t, r, jy);
}
u(Xy, "insertBlocks");
async function Ky(e, t, r, i, s) {
  const a = new vo({
    multigraph: !0,
    compound: !0
  });
  a.setGraph({
    rankdir: "TB",
    nodesep: 10,
    ranksep: 10,
    marginx: 8,
    marginy: 8
  });
  for (const n of r)
    n.size && a.setNode(n.id, {
      width: n.size.width,
      height: n.size.height,
      intersect: n.intersect
    });
  for (const n of t)
    if (n.start && n.end) {
      const o = i.getBlock(n.start), h = i.getBlock(n.end);
      if (o != null && o.size && (h != null && h.size)) {
        const l = o.size, d = h.size, p = [
          { x: l.x, y: l.y },
          { x: l.x + (d.x - l.x) / 2, y: l.y + (d.y - l.y) / 2 },
          { x: d.x, y: d.y }
        ];
        J_(
          e,
          { v: n.start, w: n.end, name: n.id },
          {
            ...n,
            arrowTypeEnd: n.arrowTypeEnd,
            arrowTypeStart: n.arrowTypeStart,
            points: p,
            classes: "edge-thickness-normal edge-pattern-solid flowchart-link LS-a1 LE-b1"
          },
          void 0,
          "block",
          a,
          s
        ), n.label && (await X_(e, {
          ...n,
          label: n.label,
          labelStyle: "stroke: #333; stroke-width: 1.5px;fill:none;",
          arrowTypeEnd: n.arrowTypeEnd,
          arrowTypeStart: n.arrowTypeStart,
          points: p,
          classes: "edge-thickness-normal edge-pattern-solid flowchart-link LS-a1 LE-b1"
        }), K_(
          { ...n, x: p[1].x, y: p[1].y },
          {
            originalPath: p
          }
        ));
      }
    }
}
u(Ky, "insertEdges");
var IE = /* @__PURE__ */ u(function(e, t) {
  return t.db.getClasses();
}, "getClasses"), FE = /* @__PURE__ */ u(async function(e, t, r, i) {
  const { securityLevel: s, block: a } = fe(), n = i.db;
  let o;
  s === "sandbox" && (o = yt("#i" + t));
  const h = s === "sandbox" ? yt(o.nodes()[0].contentDocument.body) : yt("body"), l = s === "sandbox" ? h.select(`[id="${t}"]`) : yt(`[id="${t}"]`);
  Y_(l, ["point", "circle", "cross"], i.type, t);
  const p = n.getBlocks(), g = n.getBlocksFlat(), f = n.getEdges(), y = l.insert("g").attr("class", "block");
  await Gy(y, p, n);
  const m = Oy(n);
  if (await Xy(y, p, n), await Ky(y, f, g, n, t), m) {
    const x = m, b = Math.max(1, Math.round(0.125 * (x.width / x.height))), v = x.height + b + 10, _ = x.width + 10, { useMaxWidth: A } = a;
    fr(l, v, _, !!A), I.debug("Here Bounds", m, x), l.attr(
      "viewBox",
      `${x.x - 5} ${x.y - 5} ${x.width + 10} ${x.height + 10}`
    );
  }
}, "draw"), NE = {
  draw: FE,
  getClasses: IE
}, RE = {
  parser: u_,
  db: B_,
  renderer: NE,
  styles: I_
};
const ME = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: RE
}, Symbol.toStringTag, { value: "Module" }));
var ad = {
  L: "left",
  R: "right",
  T: "top",
  B: "bottom"
}, nd = {
  L: /* @__PURE__ */ u((e) => `${e},${e / 2} 0,${e} 0,0`, "L"),
  R: /* @__PURE__ */ u((e) => `0,${e / 2} ${e},0 ${e},${e}`, "R"),
  T: /* @__PURE__ */ u((e) => `0,0 ${e},0 ${e / 2},${e}`, "T"),
  B: /* @__PURE__ */ u((e) => `${e / 2},0 ${e},${e} 0,${e}`, "B")
}, Dn = {
  L: /* @__PURE__ */ u((e, t) => e - t + 2, "L"),
  R: /* @__PURE__ */ u((e, t) => e - 2, "R"),
  T: /* @__PURE__ */ u((e, t) => e - t + 2, "T"),
  B: /* @__PURE__ */ u((e, t) => e - 2, "B")
}, OE = /* @__PURE__ */ u(function(e) {
  return cr(e) ? e === "L" ? "R" : "L" : e === "T" ? "B" : "T";
}, "getOppositeArchitectureDirection"), od = /* @__PURE__ */ u(function(e) {
  const t = e;
  return t === "L" || t === "R" || t === "T" || t === "B";
}, "isArchitectureDirection"), cr = /* @__PURE__ */ u(function(e) {
  const t = e;
  return t === "L" || t === "R";
}, "isArchitectureDirectionX"), Fi = /* @__PURE__ */ u(function(e) {
  const t = e;
  return t === "T" || t === "B";
}, "isArchitectureDirectionY"), Wh = /* @__PURE__ */ u(function(e, t) {
  const r = cr(e) && Fi(t), i = Fi(e) && cr(t);
  return r || i;
}, "isArchitectureDirectionXY"), PE = /* @__PURE__ */ u(function(e) {
  const t = e[0], r = e[1], i = cr(t) && Fi(r), s = Fi(t) && cr(r);
  return i || s;
}, "isArchitecturePairXY"), $E = /* @__PURE__ */ u(function(e) {
  return e !== "LL" && e !== "RR" && e !== "TT" && e !== "BB";
}, "isValidArchitectureDirectionPair"), Sc = /* @__PURE__ */ u(function(e, t) {
  const r = `${e}${t}`;
  return $E(r) ? r : void 0;
}, "getArchitectureDirectionPair"), VE = /* @__PURE__ */ u(function([e, t], r) {
  const i = r[0], s = r[1];
  return cr(i) ? Fi(s) ? [e + (i === "L" ? -1 : 1), t + (s === "T" ? 1 : -1)] : [e + (i === "L" ? -1 : 1), t] : cr(s) ? [e + (s === "L" ? 1 : -1), t + (i === "T" ? 1 : -1)] : [e, t + (i === "T" ? 1 : -1)];
}, "shiftPositionByArchitectureDirectionPair"), zE = /* @__PURE__ */ u(function(e) {
  return e === "LT" || e === "TL" ? [1, 1] : e === "BL" || e === "LB" ? [1, -1] : e === "BR" || e === "RB" ? [-1, -1] : [-1, 1];
}, "getArchitectureDirectionXYFactors"), WE = /* @__PURE__ */ u(function(e, t) {
  return Wh(e, t) ? "bend" : cr(e) ? "horizontal" : "vertical";
}, "getArchitectureDirectionAlignment"), qE = /* @__PURE__ */ u(function(e) {
  return e.type === "service";
}, "isArchitectureService"), YE = /* @__PURE__ */ u(function(e) {
  return e.type === "junction";
}, "isArchitectureJunction"), Qy = /* @__PURE__ */ u((e) => e.data(), "edgeData"), Ts = /* @__PURE__ */ u((e) => e.data(), "nodeData"), HE = de.architecture, ca, Zy = (ca = class {
  constructor() {
    this.nodes = {}, this.groups = {}, this.edges = [], this.registeredIds = {}, this.elements = {}, this.setAccTitle = Re, this.getAccTitle = qe, this.setDiagramTitle = Ge, this.getDiagramTitle = Oe, this.getAccDescription = He, this.setAccDescription = Ye, this.clear();
  }
  clear() {
    this.nodes = {}, this.groups = {}, this.edges = [], this.registeredIds = {}, this.dataStructures = void 0, this.elements = {}, Me();
  }
  addService({
    id: t,
    icon: r,
    in: i,
    title: s,
    iconText: a
  }) {
    if (this.registeredIds[t] !== void 0)
      throw new Error(
        `The service id [${t}] is already in use by another ${this.registeredIds[t]}`
      );
    if (i !== void 0) {
      if (t === i)
        throw new Error(`The service [${t}] cannot be placed within itself`);
      if (this.registeredIds[i] === void 0)
        throw new Error(
          `The service [${t}]'s parent does not exist. Please make sure the parent is created before this service`
        );
      if (this.registeredIds[i] === "node")
        throw new Error(`The service [${t}]'s parent is not a group`);
    }
    this.registeredIds[t] = "node", this.nodes[t] = {
      id: t,
      type: "service",
      icon: r,
      iconText: a,
      title: s,
      edges: [],
      in: i
    };
  }
  getServices() {
    return Object.values(this.nodes).filter(qE);
  }
  addJunction({ id: t, in: r }) {
    this.registeredIds[t] = "node", this.nodes[t] = {
      id: t,
      type: "junction",
      edges: [],
      in: r
    };
  }
  getJunctions() {
    return Object.values(this.nodes).filter(YE);
  }
  getNodes() {
    return Object.values(this.nodes);
  }
  getNode(t) {
    return this.nodes[t] ?? null;
  }
  addGroup({ id: t, icon: r, in: i, title: s }) {
    var a, n, o;
    if (((a = this.registeredIds) == null ? void 0 : a[t]) !== void 0)
      throw new Error(
        `The group id [${t}] is already in use by another ${this.registeredIds[t]}`
      );
    if (i !== void 0) {
      if (t === i)
        throw new Error(`The group [${t}] cannot be placed within itself`);
      if (((n = this.registeredIds) == null ? void 0 : n[i]) === void 0)
        throw new Error(
          `The group [${t}]'s parent does not exist. Please make sure the parent is created before this group`
        );
      if (((o = this.registeredIds) == null ? void 0 : o[i]) === "node")
        throw new Error(`The group [${t}]'s parent is not a group`);
    }
    this.registeredIds[t] = "group", this.groups[t] = {
      id: t,
      icon: r,
      title: s,
      in: i
    };
  }
  getGroups() {
    return Object.values(this.groups);
  }
  addEdge({
    lhsId: t,
    rhsId: r,
    lhsDir: i,
    rhsDir: s,
    lhsInto: a,
    rhsInto: n,
    lhsGroup: o,
    rhsGroup: h,
    title: l
  }) {
    if (!od(i))
      throw new Error(
        `Invalid direction given for left hand side of edge ${t}--${r}. Expected (L,R,T,B) got ${String(i)}`
      );
    if (!od(s))
      throw new Error(
        `Invalid direction given for right hand side of edge ${t}--${r}. Expected (L,R,T,B) got ${String(s)}`
      );
    if (this.nodes[t] === void 0 && this.groups[t] === void 0)
      throw new Error(
        `The left-hand id [${t}] does not yet exist. Please create the service/group before declaring an edge to it.`
      );
    if (this.nodes[r] === void 0 && this.groups[r] === void 0)
      throw new Error(
        `The right-hand id [${r}] does not yet exist. Please create the service/group before declaring an edge to it.`
      );
    const d = this.nodes[t].in, p = this.nodes[r].in;
    if (o && d && p && d == p)
      throw new Error(
        `The left-hand id [${t}] is modified to traverse the group boundary, but the edge does not pass through two groups.`
      );
    if (h && d && p && d == p)
      throw new Error(
        `The right-hand id [${r}] is modified to traverse the group boundary, but the edge does not pass through two groups.`
      );
    const g = {
      lhsId: t,
      lhsDir: i,
      lhsInto: a,
      lhsGroup: o,
      rhsId: r,
      rhsDir: s,
      rhsInto: n,
      rhsGroup: h,
      title: l
    };
    this.edges.push(g), this.nodes[t] && this.nodes[r] && (this.nodes[t].edges.push(this.edges[this.edges.length - 1]), this.nodes[r].edges.push(this.edges[this.edges.length - 1]));
  }
  getEdges() {
    return this.edges;
  }
  /**
   * Returns the current diagram's adjacency list, spatial map, & group alignments.
   * If they have not been created, run the algorithms to generate them.
   * @returns
   */
  getDataStructures() {
    if (this.dataStructures === void 0) {
      const t = {}, r = Object.entries(this.nodes).reduce((h, [l, d]) => (h[l] = d.edges.reduce((p, g) => {
        var m, x;
        const f = (m = this.getNode(g.lhsId)) == null ? void 0 : m.in, y = (x = this.getNode(g.rhsId)) == null ? void 0 : x.in;
        if (f && y && f !== y) {
          const b = WE(g.lhsDir, g.rhsDir);
          b !== "bend" && (t[f] ?? (t[f] = {}), t[f][y] = b, t[y] ?? (t[y] = {}), t[y][f] = b);
        }
        if (g.lhsId === l) {
          const b = Sc(g.lhsDir, g.rhsDir);
          b && (p[b] = g.rhsId);
        } else {
          const b = Sc(g.rhsDir, g.lhsDir);
          b && (p[b] = g.lhsId);
        }
        return p;
      }, {}), h), {}), i = Object.keys(r)[0], s = { [i]: 1 }, a = Object.keys(r).reduce(
        (h, l) => l === i ? h : { ...h, [l]: 1 },
        {}
      ), n = /* @__PURE__ */ u((h) => {
        const l = { [h]: [0, 0] }, d = [h];
        for (; d.length > 0; ) {
          const p = d.shift();
          if (p) {
            s[p] = 1, delete a[p];
            const g = r[p], [f, y] = l[p];
            Object.entries(g).forEach(([m, x]) => {
              s[x] || (l[x] = VE(
                [f, y],
                m
              ), d.push(x));
            });
          }
        }
        return l;
      }, "BFS"), o = [n(i)];
      for (; Object.keys(a).length > 0; )
        o.push(n(Object.keys(a)[0]));
      this.dataStructures = {
        adjList: r,
        spatialMaps: o,
        groupAlignments: t
      };
    }
    return this.dataStructures;
  }
  setElementForId(t, r) {
    this.elements[t] = r;
  }
  getElementById(t) {
    return this.elements[t];
  }
  getConfig() {
    return gr({
      ...HE,
      ...fe().architecture
    });
  }
  getConfigField(t) {
    return this.getConfig()[t];
  }
}, u(ca, "ArchitectureDB"), ca), UE = /* @__PURE__ */ u((e, t) => {
  hs(e, t), e.groups.map((r) => t.addGroup(r)), e.services.map((r) => t.addService({ ...r, type: "service" })), e.junctions.map((r) => t.addJunction({ ...r, type: "junction" })), e.edges.map((r) => t.addEdge(r));
}, "populateDb"), Jy = {
  parser: {
    // @ts-expect-error - ArchitectureDB is not assignable to DiagramDB
    yy: void 0
  },
  parse: /* @__PURE__ */ u(async (e) => {
    var i;
    const t = await os("architecture", e);
    I.debug(t);
    const r = (i = Jy.parser) == null ? void 0 : i.yy;
    if (!(r instanceof Zy))
      throw new Error(
        "parser.parser?.yy was not a ArchitectureDB. This is due to a bug within Mermaid, please report this issue at https://github.com/mermaid-js/mermaid/issues."
      );
    UE(t, r);
  }, "parse")
}, jE = /* @__PURE__ */ u((e) => `
  .edge {
    stroke-width: ${e.archEdgeWidth};
    stroke: ${e.archEdgeColor};
    fill: none;
  }

  .arrow {
    fill: ${e.archEdgeArrowColor};
  }

  .node-bkg {
    fill: none;
    stroke: ${e.archGroupBorderColor};
    stroke-width: ${e.archGroupBorderWidth};
    stroke-dasharray: 8;
  }
  .node-icon-text {
    display: flex; 
    align-items: center;
  }
  
  .node-icon-text > div {
    color: #fff;
    margin: 1px;
    height: fit-content;
    text-align: center;
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
  }
`, "getStyles"), GE = jE, ms = /* @__PURE__ */ u((e) => `<g><rect width="80" height="80" style="fill: #087ebf; stroke-width: 0px;"/>${e}</g>`, "wrapIcon"), cn = {
  prefix: "mermaid-architecture",
  height: 80,
  width: 80,
  icons: {
    database: {
      body: ms(
        '<path id="b" data-name="4" d="m20,57.86c0,3.94,8.95,7.14,20,7.14s20-3.2,20-7.14" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><path id="c" data-name="3" d="m20,45.95c0,3.94,8.95,7.14,20,7.14s20-3.2,20-7.14" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><path id="d" data-name="2" d="m20,34.05c0,3.94,8.95,7.14,20,7.14s20-3.2,20-7.14" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><ellipse id="e" data-name="1" cx="40" cy="22.14" rx="20" ry="7.14" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><line x1="20" y1="57.86" x2="20" y2="22.14" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><line x1="60" y1="57.86" x2="60" y2="22.14" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/>'
      )
    },
    server: {
      body: ms(
        '<rect x="17.5" y="17.5" width="45" height="45" rx="2" ry="2" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><line x1="17.5" y1="32.5" x2="62.5" y2="32.5" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><line x1="17.5" y1="47.5" x2="62.5" y2="47.5" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><g><path d="m56.25,25c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z" style="fill: #fff; stroke-width: 0px;"/><path d="m56.25,25c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z" style="fill: none; stroke: #fff; stroke-miterlimit: 10;"/></g><g><path d="m56.25,40c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z" style="fill: #fff; stroke-width: 0px;"/><path d="m56.25,40c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z" style="fill: none; stroke: #fff; stroke-miterlimit: 10;"/></g><g><path d="m56.25,55c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z" style="fill: #fff; stroke-width: 0px;"/><path d="m56.25,55c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z" style="fill: none; stroke: #fff; stroke-miterlimit: 10;"/></g><g><circle cx="32.5" cy="25" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/><circle cx="27.5" cy="25" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/><circle cx="22.5" cy="25" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/></g><g><circle cx="32.5" cy="40" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/><circle cx="27.5" cy="40" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/><circle cx="22.5" cy="40" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/></g><g><circle cx="32.5" cy="55" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/><circle cx="27.5" cy="55" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/><circle cx="22.5" cy="55" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/></g>'
      )
    },
    disk: {
      body: ms(
        '<rect x="20" y="15" width="40" height="50" rx="1" ry="1" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><ellipse cx="24" cy="19.17" rx=".8" ry=".83" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><ellipse cx="56" cy="19.17" rx=".8" ry=".83" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><ellipse cx="24" cy="60.83" rx=".8" ry=".83" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><ellipse cx="56" cy="60.83" rx=".8" ry=".83" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><ellipse cx="40" cy="33.75" rx="14" ry="14.58" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><ellipse cx="40" cy="33.75" rx="4" ry="4.17" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><path d="m37.51,42.52l-4.83,13.22c-.26.71-1.1,1.02-1.76.64l-4.18-2.42c-.66-.38-.81-1.26-.33-1.84l9.01-10.8c.88-1.05,2.56-.08,2.09,1.2Z" style="fill: #fff; stroke-width: 0px;"/>'
      )
    },
    internet: {
      body: ms(
        '<circle cx="40" cy="40" r="22.5" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><line x1="40" y1="17.5" x2="40" y2="62.5" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><line x1="17.5" y1="40" x2="62.5" y2="40" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><path d="m39.99,17.51c-15.28,11.1-15.28,33.88,0,44.98" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><path d="m40.01,17.51c15.28,11.1,15.28,33.88,0,44.98" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><line x1="19.75" y1="30.1" x2="60.25" y2="30.1" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><line x1="19.75" y1="49.9" x2="60.25" y2="49.9" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/>'
      )
    },
    cloud: {
      body: ms(
        '<path d="m65,47.5c0,2.76-2.24,5-5,5H20c-2.76,0-5-2.24-5-5,0-1.87,1.03-3.51,2.56-4.36-.04-.21-.06-.42-.06-.64,0-2.6,2.48-4.74,5.65-4.97,1.65-4.51,6.34-7.76,11.85-7.76.86,0,1.69.08,2.5.23,2.09-1.57,4.69-2.5,7.5-2.5,6.1,0,11.19,4.38,12.28,10.17,2.14.56,3.72,2.51,3.72,4.83,0,.03,0,.07-.01.1,2.29.46,4.01,2.48,4.01,4.9Z" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/>'
      )
    },
    unknown: D0,
    blank: {
      body: ms("")
    }
  }
}, XE = /* @__PURE__ */ u(async function(e, t, r) {
  const i = r.getConfigField("padding"), s = r.getConfigField("iconSize"), a = s / 2, n = s / 6, o = n / 2;
  await Promise.all(
    t.edges().map(async (h) => {
      var C, E;
      const {
        source: l,
        sourceDir: d,
        sourceArrow: p,
        sourceGroup: g,
        target: f,
        targetDir: y,
        targetArrow: m,
        targetGroup: x,
        label: b
      } = Qy(h);
      let { x: v, y: _ } = h[0].sourceEndpoint();
      const { x: A, y: S } = h[0].midpoint();
      let { x: k, y: L } = h[0].targetEndpoint();
      const T = i + 4;
      if (g && (cr(d) ? v += d === "L" ? -T : T : _ += d === "T" ? -T : T + 18), x && (cr(y) ? k += y === "L" ? -T : T : L += y === "T" ? -T : T + 18), !g && ((C = r.getNode(l)) == null ? void 0 : C.type) === "junction" && (cr(d) ? v += d === "L" ? a : -a : _ += d === "T" ? a : -a), !x && ((E = r.getNode(f)) == null ? void 0 : E.type) === "junction" && (cr(y) ? k += y === "L" ? a : -a : L += y === "T" ? a : -a), h[0]._private.rscratch) {
        const w = e.insert("g");
        if (w.insert("path").attr("d", `M ${v},${_} L ${A},${S} L${k},${L} `).attr("class", "edge").attr("id", Es(l, f, { prefix: "L" })), p) {
          const W = cr(d) ? Dn[d](v, n) : v - o, N = Fi(d) ? Dn[d](_, n) : _ - o;
          w.insert("polygon").attr("points", nd[d](n)).attr("transform", `translate(${W},${N})`).attr("class", "arrow");
        }
        if (m) {
          const W = cr(y) ? Dn[y](k, n) : k - o, N = Fi(y) ? Dn[y](L, n) : L - o;
          w.insert("polygon").attr("points", nd[y](n)).attr("transform", `translate(${W},${N})`).attr("class", "arrow");
        }
        if (b) {
          const W = Wh(d, y) ? "XY" : cr(d) ? "X" : "Y";
          let N = 0;
          W === "X" ? N = Math.abs(v - k) : W === "Y" ? N = Math.abs(_ - L) / 1.5 : N = Math.abs(v - k) / 2;
          const B = w.append("g");
          if (await _r(
            B,
            b,
            {
              useHtmlLabels: !1,
              width: N,
              classes: "architecture-service-label"
            },
            K()
          ), B.attr("dy", "1em").attr("alignment-baseline", "middle").attr("dominant-baseline", "middle").attr("text-anchor", "middle"), W === "X")
            B.attr("transform", "translate(" + A + ", " + S + ")");
          else if (W === "Y")
            B.attr("transform", "translate(" + A + ", " + S + ") rotate(-90)");
          else if (W === "XY") {
            const R = Sc(d, y);
            if (R && PE(R)) {
              const V = B.node().getBoundingClientRect(), [$, D] = zE(R);
              B.attr("dominant-baseline", "auto").attr("transform", `rotate(${-1 * $ * D * 45})`);
              const O = B.node().getBoundingClientRect();
              B.attr(
                "transform",
                `
                translate(${A}, ${S - V.height / 2})
                translate(${$ * O.width / 2}, ${D * O.height / 2})
                rotate(${-1 * $ * D * 45}, 0, ${V.height / 2})
              `
              );
            }
          }
        }
      }
    })
  );
}, "drawEdges"), KE = /* @__PURE__ */ u(async function(e, t, r) {
  const s = r.getConfigField("padding") * 0.75, a = r.getConfigField("fontSize"), o = r.getConfigField("iconSize") / 2;
  await Promise.all(
    t.nodes().map(async (h) => {
      const l = Ts(h);
      if (l.type === "group") {
        const { h: d, w: p, x1: g, y1: f } = h.boundingBox(), y = e.append("rect");
        y.attr("id", `group-${l.id}`).attr("x", g + o).attr("y", f + o).attr("width", p).attr("height", d).attr("class", "node-bkg");
        const m = e.append("g");
        let x = g, b = f;
        if (l.icon) {
          const v = m.append("g");
          v.html(
            `<g>${await Bi(l.icon, { height: s, width: s, fallbackPrefix: cn.prefix })}</g>`
          ), v.attr(
            "transform",
            "translate(" + (x + o + 1) + ", " + (b + o + 1) + ")"
          ), x += s, b += a / 2 - 1 - 2;
        }
        if (l.label) {
          const v = m.append("g");
          await _r(
            v,
            l.label,
            {
              useHtmlLabels: !1,
              width: p,
              classes: "architecture-service-label"
            },
            K()
          ), v.attr("dy", "1em").attr("alignment-baseline", "middle").attr("dominant-baseline", "start").attr("text-anchor", "start"), v.attr(
            "transform",
            "translate(" + (x + o + 4) + ", " + (b + o + 2) + ")"
          );
        }
        r.setElementForId(l.id, y);
      }
    })
  );
}, "drawGroups"), QE = /* @__PURE__ */ u(async function(e, t, r) {
  const i = K();
  for (const s of r) {
    const a = t.append("g"), n = e.getConfigField("iconSize");
    if (s.title) {
      const d = a.append("g");
      await _r(
        d,
        s.title,
        {
          useHtmlLabels: !1,
          width: n * 1.5,
          classes: "architecture-service-label"
        },
        i
      ), d.attr("dy", "1em").attr("alignment-baseline", "middle").attr("dominant-baseline", "middle").attr("text-anchor", "middle"), d.attr("transform", "translate(" + n / 2 + ", " + n + ")");
    }
    const o = a.append("g");
    if (s.icon)
      o.html(
        `<g>${await Bi(s.icon, { height: n, width: n, fallbackPrefix: cn.prefix })}</g>`
      );
    else if (s.iconText) {
      o.html(
        `<g>${await Bi("blank", { height: n, width: n, fallbackPrefix: cn.prefix })}</g>`
      );
      const g = o.append("g").append("foreignObject").attr("width", n).attr("height", n).append("div").attr("class", "node-icon-text").attr("style", `height: ${n}px;`).append("div").html(ge(s.iconText, i)), f = parseInt(
        window.getComputedStyle(g.node(), null).getPropertyValue("font-size").replace(/\D/g, "")
      ) ?? 16;
      g.attr("style", `-webkit-line-clamp: ${Math.floor((n - 2) / f)};`);
    } else
      o.append("path").attr("class", "node-bkg").attr("id", "node-" + s.id).attr(
        "d",
        `M0 ${n} v${-n} q0,-5 5,-5 h${n} q5,0 5,5 v${n} H0 Z`
      );
    a.attr("id", `service-${s.id}`).attr("class", "architecture-service");
    const { width: h, height: l } = a.node().getBBox();
    s.width = h, s.height = l, e.setElementForId(s.id, a);
  }
  return 0;
}, "drawServices"), ZE = /* @__PURE__ */ u(function(e, t, r) {
  r.forEach((i) => {
    const s = t.append("g"), a = e.getConfigField("iconSize");
    s.append("g").append("rect").attr("id", "node-" + i.id).attr("fill-opacity", "0").attr("width", a).attr("height", a), s.attr("class", "architecture-junction");
    const { width: o, height: h } = s._groups[0][0].getBBox();
    s.width = o, s.height = h, e.setElementForId(i.id, s);
  });
}, "drawJunctions");
F0([
  {
    name: cn.prefix,
    icons: cn
  }
]);
So.use(nx);
function tm(e, t, r) {
  e.forEach((i) => {
    t.add({
      group: "nodes",
      data: {
        type: "service",
        id: i.id,
        icon: i.icon,
        label: i.title,
        parent: i.in,
        width: r.getConfigField("iconSize"),
        height: r.getConfigField("iconSize")
      },
      classes: "node-service"
    });
  });
}
u(tm, "addServices");
function em(e, t, r) {
  e.forEach((i) => {
    t.add({
      group: "nodes",
      data: {
        type: "junction",
        id: i.id,
        parent: i.in,
        width: r.getConfigField("iconSize"),
        height: r.getConfigField("iconSize")
      },
      classes: "node-junction"
    });
  });
}
u(em, "addJunctions");
function rm(e, t) {
  t.nodes().map((r) => {
    const i = Ts(r);
    if (i.type === "group")
      return;
    i.x = r.position().x, i.y = r.position().y, e.getElementById(i.id).attr("transform", "translate(" + (i.x || 0) + "," + (i.y || 0) + ")");
  });
}
u(rm, "positionNodes");
function im(e, t) {
  e.forEach((r) => {
    t.add({
      group: "nodes",
      data: {
        type: "group",
        id: r.id,
        icon: r.icon,
        label: r.title,
        parent: r.in
      },
      classes: "node-group"
    });
  });
}
u(im, "addGroups");
function sm(e, t) {
  e.forEach((r) => {
    const { lhsId: i, rhsId: s, lhsInto: a, lhsGroup: n, rhsInto: o, lhsDir: h, rhsDir: l, rhsGroup: d, title: p } = r, g = Wh(r.lhsDir, r.rhsDir) ? "segments" : "straight", f = {
      id: `${i}-${s}`,
      label: p,
      source: i,
      sourceDir: h,
      sourceArrow: a,
      sourceGroup: n,
      sourceEndpoint: h === "L" ? "0 50%" : h === "R" ? "100% 50%" : h === "T" ? "50% 0" : "50% 100%",
      target: s,
      targetDir: l,
      targetArrow: o,
      targetGroup: d,
      targetEndpoint: l === "L" ? "0 50%" : l === "R" ? "100% 50%" : l === "T" ? "50% 0" : "50% 100%"
    };
    t.add({
      group: "edges",
      data: f,
      classes: g
    });
  });
}
u(sm, "addEdges");
function am(e, t, r) {
  const i = /* @__PURE__ */ u((o, h) => Object.entries(o).reduce(
    (l, [d, p]) => {
      var y;
      let g = 0;
      const f = Object.entries(p);
      if (f.length === 1)
        return l[d] = f[0][1], l;
      for (let m = 0; m < f.length - 1; m++)
        for (let x = m + 1; x < f.length; x++) {
          const [b, v] = f[m], [_, A] = f[x];
          if (((y = r[b]) == null ? void 0 : y[_]) === h)
            l[d] ?? (l[d] = []), l[d] = [...l[d], ...v, ...A];
          else if (b === "default" || _ === "default")
            l[d] ?? (l[d] = []), l[d] = [...l[d], ...v, ...A];
          else {
            const k = `${d}-${g++}`;
            l[k] = v;
            const L = `${d}-${g++}`;
            l[L] = A;
          }
        }
      return l;
    },
    {}
  ), "flattenAlignments"), s = t.map((o) => {
    const h = {}, l = {};
    return Object.entries(o).forEach(([d, [p, g]]) => {
      var y, m, x;
      const f = ((y = e.getNode(d)) == null ? void 0 : y.in) ?? "default";
      h[g] ?? (h[g] = {}), (m = h[g])[f] ?? (m[f] = []), h[g][f].push(d), l[p] ?? (l[p] = {}), (x = l[p])[f] ?? (x[f] = []), l[p][f].push(d);
    }), {
      horiz: Object.values(i(h, "horizontal")).filter(
        (d) => d.length > 1
      ),
      vert: Object.values(i(l, "vertical")).filter(
        (d) => d.length > 1
      )
    };
  }), [a, n] = s.reduce(
    ([o, h], { horiz: l, vert: d }) => [
      [...o, ...l],
      [...h, ...d]
    ],
    [[], []]
  );
  return {
    horizontal: a,
    vertical: n
  };
}
u(am, "getAlignments");
function nm(e, t) {
  const r = [], i = /* @__PURE__ */ u((a) => `${a[0]},${a[1]}`, "posToStr"), s = /* @__PURE__ */ u((a) => a.split(",").map((n) => parseInt(n)), "strToPos");
  return e.forEach((a) => {
    const n = Object.fromEntries(
      Object.entries(a).map(([d, p]) => [i(p), d])
    ), o = [i([0, 0])], h = {}, l = {
      L: [-1, 0],
      R: [1, 0],
      T: [0, 1],
      B: [0, -1]
    };
    for (; o.length > 0; ) {
      const d = o.shift();
      if (d) {
        h[d] = 1;
        const p = n[d];
        if (p) {
          const g = s(d);
          Object.entries(l).forEach(([f, y]) => {
            const m = i([g[0] + y[0], g[1] + y[1]]), x = n[m];
            x && !h[m] && (o.push(m), r.push({
              [ad[f]]: x,
              [ad[OE(f)]]: p,
              gap: 1.5 * t.getConfigField("iconSize")
            }));
          });
        }
      }
    }
  }), r;
}
u(nm, "getRelativeConstraints");
function om(e, t, r, i, s, { spatialMaps: a, groupAlignments: n }) {
  return new Promise((o) => {
    const h = yt("body").append("div").attr("id", "cy").attr("style", "display:none"), l = So({
      container: document.getElementById("cy"),
      style: [
        {
          selector: "edge",
          style: {
            "curve-style": "straight",
            label: "data(label)",
            "source-endpoint": "data(sourceEndpoint)",
            "target-endpoint": "data(targetEndpoint)"
          }
        },
        {
          selector: "edge.segments",
          style: {
            "curve-style": "segments",
            "segment-weights": "0",
            "segment-distances": [0.5],
            // @ts-ignore Incorrect library types
            "edge-distances": "endpoints",
            "source-endpoint": "data(sourceEndpoint)",
            "target-endpoint": "data(targetEndpoint)"
          }
        },
        {
          selector: "node",
          style: {
            // @ts-ignore Incorrect library types
            "compound-sizing-wrt-labels": "include"
          }
        },
        {
          selector: "node[label]",
          style: {
            "text-valign": "bottom",
            "text-halign": "center",
            "font-size": `${s.getConfigField("fontSize")}px`
          }
        },
        {
          selector: ".node-service",
          style: {
            label: "data(label)",
            width: "data(width)",
            height: "data(height)"
          }
        },
        {
          selector: ".node-junction",
          style: {
            width: "data(width)",
            height: "data(height)"
          }
        },
        {
          selector: ".node-group",
          style: {
            // @ts-ignore Incorrect library types
            padding: `${s.getConfigField("padding")}px`
          }
        }
      ],
      layout: {
        name: "grid",
        boundingBox: {
          x1: 0,
          x2: 100,
          y1: 0,
          y2: 100
        }
      }
    });
    h.remove(), im(r, l), tm(e, l, s), em(t, l, s), sm(i, l);
    const d = am(s, a, n), p = nm(a, s), g = l.layout({
      name: "fcose",
      quality: "proof",
      styleEnabled: !1,
      animate: !1,
      nodeDimensionsIncludeLabels: !1,
      // Adjust the edge parameters if it passes through the border of a group
      // Hacky fix for: https://github.com/iVis-at-Bilkent/cytoscape.js-fcose/issues/67
      idealEdgeLength(f) {
        const [y, m] = f.connectedNodes(), { parent: x } = Ts(y), { parent: b } = Ts(m);
        return x === b ? 1.5 * s.getConfigField("iconSize") : 0.5 * s.getConfigField("iconSize");
      },
      edgeElasticity(f) {
        const [y, m] = f.connectedNodes(), { parent: x } = Ts(y), { parent: b } = Ts(m);
        return x === b ? 0.45 : 1e-3;
      },
      alignmentConstraint: d,
      relativePlacementConstraint: p
    });
    g.one("layoutstop", () => {
      var y;
      function f(m, x, b, v) {
        let _, A;
        const { x: S, y: k } = m, { x: L, y: T } = x;
        A = (v - k + (S - b) * (k - T) / (S - L)) / Math.sqrt(1 + Math.pow((k - T) / (S - L), 2)), _ = Math.sqrt(Math.pow(v - k, 2) + Math.pow(b - S, 2) - Math.pow(A, 2));
        const C = Math.sqrt(Math.pow(L - S, 2) + Math.pow(T - k, 2));
        _ = _ / C;
        let E = (L - S) * (v - k) - (T - k) * (b - S);
        switch (!0) {
          case E >= 0:
            E = 1;
            break;
          case E < 0:
            E = -1;
            break;
        }
        let w = (L - S) * (b - S) + (T - k) * (v - k);
        switch (!0) {
          case w >= 0:
            w = 1;
            break;
          case w < 0:
            w = -1;
            break;
        }
        return A = Math.abs(A) * E, _ = _ * w, {
          distances: A,
          weights: _
        };
      }
      u(f, "getSegmentWeights"), l.startBatch();
      for (const m of Object.values(l.edges()))
        if ((y = m.data) != null && y.call(m)) {
          const { x, y: b } = m.source().position(), { x: v, y: _ } = m.target().position();
          if (x !== v && b !== _) {
            const A = m.sourceEndpoint(), S = m.targetEndpoint(), { sourceDir: k } = Qy(m), [L, T] = Fi(k) ? [A.x, S.y] : [S.x, A.y], { weights: C, distances: E } = f(A, S, L, T);
            m.style("segment-distances", E), m.style("segment-weights", C);
          }
        }
      l.endBatch(), g.run();
    }), g.run(), l.ready((f) => {
      I.info("Ready", f), o(l);
    });
  });
}
u(om, "layoutArchitecture");
var JE = /* @__PURE__ */ u(async (e, t, r, i) => {
  const s = i.db, a = s.getServices(), n = s.getJunctions(), o = s.getGroups(), h = s.getEdges(), l = s.getDataStructures(), d = xi(t), p = d.append("g");
  p.attr("class", "architecture-edges");
  const g = d.append("g");
  g.attr("class", "architecture-services");
  const f = d.append("g");
  f.attr("class", "architecture-groups"), await QE(s, g, a), ZE(s, g, n);
  const y = await om(a, n, o, h, s, l);
  await XE(p, y, s), await KE(f, y, s), rm(s, y), dn(void 0, d, s.getConfigField("padding"), s.getConfigField("useMaxWidth"));
}, "draw"), t9 = { draw: JE }, e9 = {
  parser: Jy,
  get db() {
    return new Zy();
  },
  renderer: t9,
  styles: GE
};
const r9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: e9
}, Symbol.toStringTag, { value: "Module" }));
var ha, lm = (ha = class {
  constructor() {
    this.nodes = [], this.levels = /* @__PURE__ */ new Map(), this.outerNodes = [], this.classes = /* @__PURE__ */ new Map(), this.setAccTitle = Re, this.getAccTitle = qe, this.setDiagramTitle = Ge, this.getDiagramTitle = Oe, this.getAccDescription = He, this.setAccDescription = Ye;
  }
  getNodes() {
    return this.nodes;
  }
  getConfig() {
    const t = de, r = fe();
    return gr({
      ...t.treemap,
      ...r.treemap ?? {}
    });
  }
  addNode(t, r) {
    this.nodes.push(t), this.levels.set(t, r), r === 0 && (this.outerNodes.push(t), this.root ?? (this.root = t));
  }
  getRoot() {
    return { name: "", children: this.outerNodes };
  }
  addClass(t, r) {
    const i = this.classes.get(t) ?? { id: t, styles: [], textStyles: [] }, s = r.replace(/\\,/g, "").replace(/,/g, ";").replace(//g, ",").split(";");
    s && s.forEach((a) => {
      Vc(a) && (i != null && i.textStyles ? i.textStyles.push(a) : i.textStyles = [a]), i != null && i.styles ? i.styles.push(a) : i.styles = [a];
    }), this.classes.set(t, i);
  }
  getClasses() {
    return this.classes;
  }
  getStylesForClass(t) {
    var r;
    return ((r = this.classes.get(t)) == null ? void 0 : r.styles) ?? [];
  }
  clear() {
    Me(), this.nodes = [], this.levels = /* @__PURE__ */ new Map(), this.outerNodes = [], this.classes = /* @__PURE__ */ new Map(), this.root = void 0;
  }
}, u(ha, "TreeMapDB"), ha);
function cm(e) {
  if (!e.length)
    return [];
  const t = [], r = [];
  return e.forEach((i) => {
    const s = {
      name: i.name,
      children: i.type === "Leaf" ? void 0 : []
    };
    for (s.classSelector = i == null ? void 0 : i.classSelector, i != null && i.cssCompiledStyles && (s.cssCompiledStyles = [i.cssCompiledStyles]), i.type === "Leaf" && i.value !== void 0 && (s.value = i.value); r.length > 0 && r[r.length - 1].level >= i.level; )
      r.pop();
    if (r.length === 0)
      t.push(s);
    else {
      const a = r[r.length - 1].node;
      a.children ? a.children.push(s) : a.children = [s];
    }
    i.type !== "Leaf" && r.push({ node: s, level: i.level });
  }), t;
}
u(cm, "buildHierarchy");
var i9 = /* @__PURE__ */ u((e, t) => {
  hs(e, t);
  const r = [];
  for (const a of e.TreemapRows ?? [])
    a.$type === "ClassDefStatement" && t.addClass(a.className ?? "", a.styleText ?? "");
  for (const a of e.TreemapRows ?? []) {
    const n = a.item;
    if (!n)
      continue;
    const o = a.indent ? parseInt(a.indent) : 0, h = s9(n), l = n.classSelector ? t.getStylesForClass(n.classSelector) : [], d = l.length > 0 ? l.join(";") : void 0, p = {
      level: o,
      name: h,
      type: n.$type,
      value: n.value,
      classSelector: n.classSelector,
      cssCompiledStyles: d
    };
    r.push(p);
  }
  const i = cm(r), s = /* @__PURE__ */ u((a, n) => {
    for (const o of a)
      t.addNode(o, n), o.children && o.children.length > 0 && s(o.children, n + 1);
  }, "addNodesRecursively");
  s(i, 0);
}, "populate"), s9 = /* @__PURE__ */ u((e) => e.name ? String(e.name) : "", "getItemName"), hm = {
  // @ts-expect-error - TreeMapDB is not assignable to DiagramDB
  parser: { yy: void 0 },
  parse: /* @__PURE__ */ u(async (e) => {
    var t;
    try {
      const i = await os("treemap", e);
      I.debug("Treemap AST:", i);
      const s = (t = hm.parser) == null ? void 0 : t.yy;
      if (!(s instanceof lm))
        throw new Error(
          "parser.parser?.yy was not a TreemapDB. This is due to a bug within Mermaid, please report this issue at https://github.com/mermaid-js/mermaid/issues."
        );
      i9(i, s);
    } catch (r) {
      throw I.error("Error parsing treemap:", r), r;
    }
  }, "parse")
}, a9 = 10, xs = 10, La = 25, n9 = /* @__PURE__ */ u((e, t, r, i) => {
  const s = i.db, a = s.getConfig(), n = a.padding ?? a9, o = s.getDiagramTitle(), h = s.getRoot(), { themeVariables: l } = fe();
  if (!h)
    return;
  const d = o ? 30 : 0, p = xi(t), g = a.nodeWidth ? a.nodeWidth * xs : 960, f = a.nodeHeight ? a.nodeHeight * xs : 500, y = g, m = f + d;
  p.attr("viewBox", `0 0 ${y} ${m}`), fr(p, m, y, a.useMaxWidth);
  let x;
  try {
    const B = a.valueFormat || ",";
    if (B === "$0,0")
      x = /* @__PURE__ */ u((R) => "$" + Ea(",")(R), "valueFormat");
    else if (B.startsWith("$") && B.includes(",")) {
      const R = /\.\d+/.exec(B), V = R ? R[0] : "";
      x = /* @__PURE__ */ u(($) => "$" + Ea("," + V)($), "valueFormat");
    } else if (B.startsWith("$")) {
      const R = B.substring(1);
      x = /* @__PURE__ */ u((V) => "$" + Ea(R || "")(V), "valueFormat");
    } else
      x = Ea(B);
  } catch (B) {
    I.error("Error creating format function:", B), x = Ea(",");
  }
  const b = Va().range([
    "transparent",
    l.cScale0,
    l.cScale1,
    l.cScale2,
    l.cScale3,
    l.cScale4,
    l.cScale5,
    l.cScale6,
    l.cScale7,
    l.cScale8,
    l.cScale9,
    l.cScale10,
    l.cScale11
  ]), v = Va().range([
    "transparent",
    l.cScalePeer0,
    l.cScalePeer1,
    l.cScalePeer2,
    l.cScalePeer3,
    l.cScalePeer4,
    l.cScalePeer5,
    l.cScalePeer6,
    l.cScalePeer7,
    l.cScalePeer8,
    l.cScalePeer9,
    l.cScalePeer10,
    l.cScalePeer11
  ]), _ = Va().range([
    l.cScaleLabel0,
    l.cScaleLabel1,
    l.cScaleLabel2,
    l.cScaleLabel3,
    l.cScaleLabel4,
    l.cScaleLabel5,
    l.cScaleLabel6,
    l.cScaleLabel7,
    l.cScaleLabel8,
    l.cScaleLabel9,
    l.cScaleLabel10,
    l.cScaleLabel11
  ]);
  o && p.append("text").attr("x", y / 2).attr("y", d / 2).attr("class", "treemapTitle").attr("text-anchor", "middle").attr("dominant-baseline", "middle").text(o);
  const A = p.append("g").attr("transform", `translate(0, ${d})`).attr("class", "treemapContainer"), S = ox(h).sum((B) => B.value ?? 0).sort((B, R) => (R.value ?? 0) - (B.value ?? 0)), L = lx().size([g, f]).paddingTop(
    (B) => B.children && B.children.length > 0 ? La + xs : 0
  ).paddingInner(n).paddingLeft((B) => B.children && B.children.length > 0 ? xs : 0).paddingRight((B) => B.children && B.children.length > 0 ? xs : 0).paddingBottom((B) => B.children && B.children.length > 0 ? xs : 0).round(!0)(S), T = L.descendants().filter((B) => B.children && B.children.length > 0), C = A.selectAll(".treemapSection").data(T).enter().append("g").attr("class", "treemapSection").attr("transform", (B) => `translate(${B.x0},${B.y0})`);
  C.append("rect").attr("width", (B) => B.x1 - B.x0).attr("height", La).attr("class", "treemapSectionHeader").attr("fill", "none").attr("fill-opacity", 0.6).attr("stroke-width", 0.6).attr("style", (B) => B.depth === 0 ? "display: none;" : ""), C.append("clipPath").attr("id", (B, R) => `clip-section-${t}-${R}`).append("rect").attr("width", (B) => Math.max(0, B.x1 - B.x0 - 12)).attr("height", La), C.append("rect").attr("width", (B) => B.x1 - B.x0).attr("height", (B) => B.y1 - B.y0).attr("class", (B, R) => `treemapSection section${R}`).attr("fill", (B) => b(B.data.name)).attr("fill-opacity", 0.6).attr("stroke", (B) => v(B.data.name)).attr("stroke-width", 2).attr("stroke-opacity", 0.4).attr("style", (B) => {
    if (B.depth === 0)
      return "display: none;";
    const R = It({ cssCompiledStyles: B.data.cssCompiledStyles });
    return R.nodeStyles + ";" + R.borderStyles.join(";");
  }), C.append("text").attr("class", "treemapSectionLabel").attr("x", 6).attr("y", La / 2).attr("dominant-baseline", "middle").text((B) => B.depth === 0 ? "" : B.data.name).attr("font-weight", "bold").attr("style", (B) => {
    if (B.depth === 0)
      return "display: none;";
    const R = "dominant-baseline: middle; font-size: 12px; fill:" + _(B.data.name) + "; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;", V = It({ cssCompiledStyles: B.data.cssCompiledStyles });
    return R + V.labelStyles.replace("color:", "fill:");
  }).each(function(B) {
    if (B.depth === 0)
      return;
    const R = yt(this), V = B.data.name;
    R.text(V);
    const $ = B.x1 - B.x0, D = 6;
    let O;
    a.showValues !== !1 && B.value ? O = $ - 10 - 30 - 10 - D : O = $ - D - 6;
    const M = Math.max(15, O), G = R.node();
    if (G.getComputedTextLength() > M) {
      const ht = "...";
      let Z = V;
      for (; Z.length > 0; ) {
        if (Z = V.substring(0, Z.length - 1), Z.length === 0) {
          R.text(ht), G.getComputedTextLength() > M && R.text("");
          break;
        }
        if (R.text(Z + ht), G.getComputedTextLength() <= M)
          break;
      }
    }
  }), a.showValues !== !1 && C.append("text").attr("class", "treemapSectionValue").attr("x", (B) => B.x1 - B.x0 - 10).attr("y", La / 2).attr("text-anchor", "end").attr("dominant-baseline", "middle").text((B) => B.value ? x(B.value) : "").attr("font-style", "italic").attr("style", (B) => {
    if (B.depth === 0)
      return "display: none;";
    const R = "text-anchor: end; dominant-baseline: middle; font-size: 10px; fill:" + _(B.data.name) + "; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;", V = It({ cssCompiledStyles: B.data.cssCompiledStyles });
    return R + V.labelStyles.replace("color:", "fill:");
  });
  const E = L.leaves(), w = A.selectAll(".treemapLeafGroup").data(E).enter().append("g").attr("class", (B, R) => `treemapNode treemapLeafGroup leaf${R}${B.data.classSelector ? ` ${B.data.classSelector}` : ""}x`).attr("transform", (B) => `translate(${B.x0},${B.y0})`);
  w.append("rect").attr("width", (B) => B.x1 - B.x0).attr("height", (B) => B.y1 - B.y0).attr("class", "treemapLeaf").attr("fill", (B) => B.parent ? b(B.parent.data.name) : b(B.data.name)).attr("style", (B) => It({ cssCompiledStyles: B.data.cssCompiledStyles }).nodeStyles).attr("fill-opacity", 0.3).attr("stroke", (B) => B.parent ? b(B.parent.data.name) : b(B.data.name)).attr("stroke-width", 3), w.append("clipPath").attr("id", (B, R) => `clip-${t}-${R}`).append("rect").attr("width", (B) => Math.max(0, B.x1 - B.x0 - 4)).attr("height", (B) => Math.max(0, B.y1 - B.y0 - 4)), w.append("text").attr("class", "treemapLabel").attr("x", (B) => (B.x1 - B.x0) / 2).attr("y", (B) => (B.y1 - B.y0) / 2).attr("style", (B) => {
    const R = "text-anchor: middle; dominant-baseline: middle; font-size: 38px;fill:" + _(B.data.name) + ";", V = It({ cssCompiledStyles: B.data.cssCompiledStyles });
    return R + V.labelStyles.replace("color:", "fill:");
  }).attr("clip-path", (B, R) => `url(#clip-${t}-${R})`).text((B) => B.data.name).each(function(B) {
    const R = yt(this), V = B.x1 - B.x0, $ = B.y1 - B.y0, D = R.node(), O = 4, Y = V - 2 * O, M = $ - 2 * O;
    if (Y < 10 || M < 10) {
      R.style("display", "none");
      return;
    }
    let G = parseInt(R.style("font-size"), 10);
    const rt = 8, ht = 28, Z = 0.6, ot = 6, it = 2;
    for (; D.getComputedTextLength() > Y && G > rt; )
      G--, R.style("font-size", `${G}px`);
    let bt = Math.max(
      ot,
      Math.min(ht, Math.round(G * Z))
    ), xt = G + it + bt;
    for (; xt > M && G > rt && (G--, bt = Math.max(
      ot,
      Math.min(ht, Math.round(G * Z))
    ), !(bt < ot && G === rt)); )
      R.style("font-size", `${G}px`), xt = G + it + bt;
    R.style("font-size", `${G}px`), (D.getComputedTextLength() > Y || G < rt || M < G) && R.style("display", "none");
  }), a.showValues !== !1 && w.append("text").attr("class", "treemapValue").attr("x", (R) => (R.x1 - R.x0) / 2).attr("y", function(R) {
    return (R.y1 - R.y0) / 2;
  }).attr("style", (R) => {
    const V = "text-anchor: middle; dominant-baseline: hanging; font-size: 28px;fill:" + _(R.data.name) + ";", $ = It({ cssCompiledStyles: R.data.cssCompiledStyles });
    return V + $.labelStyles.replace("color:", "fill:");
  }).attr("clip-path", (R, V) => `url(#clip-${t}-${V})`).text((R) => R.value ? x(R.value) : "").each(function(R) {
    const V = yt(this), $ = this.parentNode;
    if (!$) {
      V.style("display", "none");
      return;
    }
    const D = yt($).select(".treemapLabel");
    if (D.empty() || D.style("display") === "none") {
      V.style("display", "none");
      return;
    }
    const O = parseFloat(D.style("font-size")), Y = 28, M = 0.6, G = 6, rt = 2, ht = Math.max(
      G,
      Math.min(Y, Math.round(O * M))
    );
    V.style("font-size", `${ht}px`);
    const ot = (R.y1 - R.y0) / 2 + O / 2 + rt;
    V.attr("y", ot);
    const it = R.x1 - R.x0, Ct = R.y1 - R.y0 - 4, at = it - 2 * 4;
    V.node().getComputedTextLength() > at || ot + ht > Ct || ht < G ? V.style("display", "none") : V.style("display", null);
  });
  const N = a.diagramPadding ?? 8;
  cs(p, N, "flowchart", (a == null ? void 0 : a.useMaxWidth) || !1);
}, "draw"), o9 = /* @__PURE__ */ u(function(e, t) {
  return t.db.getClasses();
}, "getClasses"), l9 = { draw: n9, getClasses: o9 }, c9 = {
  sectionStrokeColor: "black",
  sectionStrokeWidth: "1",
  sectionFillColor: "#efefef",
  leafStrokeColor: "black",
  leafStrokeWidth: "1",
  leafFillColor: "#efefef",
  labelColor: "black",
  labelFontSize: "12px",
  valueFontSize: "10px",
  valueColor: "black",
  titleColor: "black",
  titleFontSize: "14px"
}, h9 = /* @__PURE__ */ u(({
  treemap: e
} = {}) => {
  const t = gr(c9, e);
  return `
  .treemapNode.section {
    stroke: ${t.sectionStrokeColor};
    stroke-width: ${t.sectionStrokeWidth};
    fill: ${t.sectionFillColor};
  }
  .treemapNode.leaf {
    stroke: ${t.leafStrokeColor};
    stroke-width: ${t.leafStrokeWidth};
    fill: ${t.leafFillColor};
  }
  .treemapLabel {
    fill: ${t.labelColor};
    font-size: ${t.labelFontSize};
  }
  .treemapValue {
    fill: ${t.valueColor};
    font-size: ${t.valueFontSize};
  }
  .treemapTitle {
    fill: ${t.titleColor};
    font-size: ${t.titleFontSize};
  }
  `;
}, "getStyles"), u9 = h9, d9 = {
  parser: hm,
  get db() {
    return new lm();
  },
  renderer: l9,
  styles: u9
};
const p9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  diagram: d9
}, Symbol.toStringTag, { value: "Module" }));
export {
  y9 as m
};
